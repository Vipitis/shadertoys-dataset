{"id": "4d33DM", "name": "sP.2 - dust", "author": "patu", "description": "No as many dots as it looks like.  Try to manipulate RES value.", "tags": ["2d", "dust"], "likes": 15, "viewed": 782, "published": "Public API", "date": "1449877861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime * .6\n#define FOV 9.\n#define RES 20.\n#define LAYERS 8.\n#define n (u / iResolution.y - .5)\n\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n\tfloat d, s;\n    \n    c = vec4(.4, sin(t / 4.), cos(t / 7.), 1.) * cos(n.y * 3.14);\n    \n    for (float i = 1.; i < LAYERS; i++) {\n        vec2 uv = n * tan(radians(i * 4. + FOV) / 2.0);\n        uv += vec2(- t / 8. + i / 12., sin(i - t / 4. + uv.x) * .1);\n        \n        s = .01 * noise(ceil(uv * RES + i * 9.) + i + t * vec2(.2, .01));\n        d = length(mod(uv, 1. / RES) - .5 / RES);\n\n        if (d < s) c += 1. / i - d * i * 6.; \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d33DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 127, 167, 304], [306, 306, 329, 329, 700], [702, 702, 743, 743, 1192]]}
{"id": "4d33DN", "name": "Black Sea", "author": "Kchplr", "description": "A test refactoring cpu-bound javascript code to a fragment shader.\nThe original ( http://www.kchapelier.com/blacksea/ ) was using a WebWorker to produce a heightmap of fixed dimension.", "tags": ["procedural", "2d", "noise", "heightmap"], "likes": 8, "viewed": 649, "published": "Public API", "date": "1449580203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D and 3D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\n\n\n//\n// Black Sea code starts here\n// The code in the comments is the original cpu-bound javascript code for each map\n//\n// The original can be found here\n// http://www.kchapelier.com/blacksea/\n//\n\n\nvec2 propensityDistortionMap(vec2 p, float distortionLevel) {\n    /*\n    mapX.map(function (value, x, y) {\n        var dist = noise.perlin2(400 + x / 50, 400 + y / 50) / 40\n        + noise.simplex2(400 + x / 25, 400 + y / 25) / 60\n        + noise.simplex2(400 + x / 10, 400 + y / 10) / 130;\n        return dist * distortionLevel;\n    });\n\n    mapY.map(function (value, x, y) {\n        var dist = noise.perlin2(4000 + x / 50, 4000 + y / 50) / 40\n        + noise.simplex2(4000 + x / 25, 4000 + y / 25) / 60\n        + noise.simplex2(4000 + x / 10, 4000 + y / 10) / 130;\n        return dist * distortionLevel;\n    });\n\n    return {\n        x: mapX,\n        y: mapY\n    };\n    */\n    \n    vec2 dist = vec2(\n        cnoise(vec2(400. + p.x / 50., 400. + p.y / 50.)) / 40. +\n        snoise(vec2(400. + p.x / 25., 400. + p.y / 25.)) / 60. +\n        snoise(vec2(400. + p.x / 10., 400. + p.y / 10.)) / 130.,\n        cnoise(vec2(4000. + p.x / 50., 4000. + p.y / 50.)) / 40. +\n        snoise(vec2(4000. + p.x / 25., 4000. + p.y / 25.)) / 60. +\n        snoise(vec2(4000. + p.x / 10., 4000. + p.y / 10.)) / 130.\n    );\n    \n    return dist * distortionLevel;\n}\n\nfloat heightPropensityMap(vec2 p, vec2 propensityDistortion) {\n    /*\n        // distortion\n        var dx = distortions.x.get(x, y),\n            dy = distortions.y.get(x, y);\n\n        var base = Math.abs(Math.min(1, Math.max(-1, Math.min(\n            noise.perlin3(x / 400 + dx, y / 400 + dy, 10),\n            noise.perlin3(x / 250, y / 250, 15)\n        ))));\n\n        // soften with large scale perlin cloud\n\n        var v = Math.min(\n            noise.perlin3(x / 300 + dx * 1.3, y / 300 + dy, 50),\n            noise.perlin3(x / 300 + dx, y / 300 + dy * 1.3, 50.30)\n        );\n\n        var increment = Math.pow(1 - Math.sqrt(Math.abs(v)), 3);\n\n        return Math.max(0, Math.min(1, (base * increment) * 2));\n\t*/\n    \n    float dx = propensityDistortion.x;\n    float dy = propensityDistortion.y;\n    \n    float base = abs(min(\n        cnoise(vec3(p.x / 400. + dx, p.y / 400. + dy, 10.)),\n        cnoise(vec3(p.x / 250., p.y / 250., 15.))\n    ));\n    \n    float v = abs(min(\n        cnoise(vec3(p.x / 300. + dx * 1.3, p.y / 300. + dy, 50.)),\n        cnoise(vec3(p.x / 300. + dx, p.y / 300. + dy * 1.3, 50.30))\n    ));\n    \n    float increment = pow(1. - sqrt(v), 3.);\n    \n    return clamp(base * increment * 2., 0., 1.);\n}\n\nfloat altHeightPropensityMap(vec2 p, vec2 propensityDistortion) {\n    /*\n        // distortion\n        var dx = distortions.x.get(x, y),\n            dy = distortions.y.get(x, y);\n\n        var base = Math.abs(Math.pow(0.2, Math.max(-1, Math.min(\n            noise.perlin3(x / 200 + dx, y / 200 + dy, 50),\n            noise.perlin3(x / 450, y / 450, 55)\n        ))));\n\n        base += Math.abs(Math.min(1, Math.max(-1, Math.min(\n            noise.perlin3(x / 400 + dx, y / 400 + dy, 10),\n            noise.perlin3(x / 250, y / 250, 15)\n        ))));\n\n        var v = Math.min(\n            noise.perlin3(x / 300 + dx * 1.3, y / 300 + dy, 50),\n            noise.perlin3(x / 300 + dx, y / 300 + dy * 1.3, 50.30)\n        );\n\n        var increment = Math.pow(1 - Math.sqrt(Math.abs(v)), 3);\n\n        return Math.max(0, Math.min(1, (base * increment) * 2));\n\t*/\n    \n    float dx = propensityDistortion.x;\n    float dy = propensityDistortion.y;\n    \n    float base = abs(pow(0.2, max(-1., min(\n        cnoise(vec3(p.x / 200. + dx, p.y / 200. + dy, 50.)),\n        cnoise(vec3(p.x / 450., p.y / 450., 55.))\n    ))));\n    \n    base += abs(min(\n        cnoise(vec3(p.x / 400. + dx, p.y / 400. + dy, 10.)),\n        cnoise(vec3(p.x / 250., p.y / 250., 15.))\n    ));\n    \n    float v = abs(min(\n        cnoise(vec3(p.x / 300. + dx * 1.3, p.y / 300. + dy, 50.)),\n        cnoise(vec3(p.x / 300. + dx, p.y / 300. + dy * 1.3, 50.30))\n    ));\n    \n    float increment = pow(1. - sqrt(v), 3.);\n    \n    return clamp(base * increment * 2., 0., 1.);\n}\n\nfloat lerp(float a, float b, float w) {\n    return a + w * (b-a);\n}\n\nfloat heightMap(vec2 p, float propensity, float abyss) {\n    /*\n    \tvalue = Math.abs(noise.perlin3(x / 1200, y / 1200, 300 + propensity * 0.4 + abyss * 0.2)) * (32 + propensity * 32) +\n        noise.simplex2(x / 600, y / 600) * (16 + propensity * 16) +\n        noise.perlin2(x / 300, y / 300) * (8 + propensity * 8) +\n        noise.perlin2(x / 150, y / 150) * (4 + propensity * 4) +\n        noise.perlin2(x / 75, y / 75) * (2 + propensity * 2) +\n        noise.simplex2(x / 75, y / 75) +\n        noise.perlin2(x / 35, y / 35) +\n        noise.perlin2(x / 17, y / 17) * (1 + propensity * propensity * propensity) +\n        noise.perlin2(x / 8, y / 8) * 0.5 +\n        noise.perlin2(x / 4, y / 4) * 0.2 + propensity;\n\n        value = Math.max(0, Math.min(1, (value + 31) / 100));\n\n        value = Mathp.wshaper(value - (abyss * Math.pow(0.5 - value / 2, 2)), 0, 1, [Math.max(0, value - abyss * 4), 0.5, 1]);\n        \n\t*/\n    \n    float value = abs(cnoise(vec3(p.x / 1200., p.y / 1200., 300. + propensity * 0.4 + abyss * 0.2))) * (32. + propensity * 32.);\n    value += snoise(vec2(p.x / 600., p.y / 600.)) * (16. + propensity * 16.);\n    value += cnoise(vec2(p.x / 300., p.y / 300.)) * (8. + propensity * 8.);\n    value += cnoise(vec2(p.x / 150., p.y / 150.)) * (4. + propensity * 4.);\n    value += cnoise(vec2(p.x / 75., p.y / 75.)) * (2. + propensity * 2.);\n    value += snoise(vec2(p.x / 75., p.y / 75.));\n    value += cnoise(vec2(p.x / 35., p.y / 35.));\n    value += cnoise(vec2(p.x / 17., p.y / 17.)) * (1. + pow(propensity, 3.));\n    value += cnoise(vec2(p.x / 8., p.y / 8.)) * 0.5;\n    value += cnoise(vec2(p.x / 4., p.y / 4.)) * 0.2;\n    value += propensity;\n    \n    value = clamp((value + 31.) / 100., 0., 1.);\n    \n    value = value - (abyss * pow(0.5 - value * 0.5, 2.));\n    \n    // apply a lerp for values between 0. and 0.5\n    if (value > 0. && value <= 0.5) {\n        float minv = max(0., value - abyss * 4.);\n        value = lerp(minv, 0.5, value * 2.);\n    }\n    \n    return value;\n}\n\nfloat blackSea(float v, float seaLevel) {\n    /*\n    \tvalue = Math.max(0, Math.min(255, continentMap.get(x, y) ? (value - 30) * 1.5 : value / 1.75));\n\n        if (highlightMap && !highlightMap.get(x, y)) {\n        \tvalue = value / 1.75;\n\t\t}\n\n\t\treturn value;\n\t*/\n    \n    if (v >= seaLevel) {\n        return (v - 30. / 255.) * 1.5;\n    } else {\n        return v / 1.75;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // could be shader attributes\n    float distortion = 1.,\n          seaLevel = 0.45,\n          movementX = iTime * 13.,\n          movementY = iTime * 50.,\n          scale = 650. / min(iResolution.x, iResolution.y);\n    \n    vec2 p = fragCoord * scale + vec2(movementX, movementY);\n    \n    vec2 propensityDistortion = propensityDistortionMap(p, distortion);\n    \n    float heightPropensity = heightPropensityMap(p, propensityDistortion),\n          altHeightPropensity = altHeightPropensityMap(p, propensityDistortion),\n          height = heightMap(p, heightPropensity, altHeightPropensity);\n    \n    height = blackSea(height, seaLevel);\n    \n\tfragColor = vec4(height, height, height,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d33DN.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 376, 397, 397, 446], [448, 448, 469, 469, 518], [520, 520, 542, 542, 579], [581, 581, 602, 602, 651], [653, 653, 675, 675, 715], [717, 717, 745, 745, 797], [799, 799, 823, 823, 2969], [2971, 2971, 2995, 2995, 4501], [4504, 4504, 4523, 4523, 4563], [4565, 4589, 4611, 4611, 6907], [6909, 6951, 6983, 6983, 9313], [9316, 9316, 9335, 9335, 9375], [9377, 9401, 9423, 9423, 10465], [10467, 10509, 10541, 10541, 11656], [11662, 11859, 11920, 12533, 13004], [13006, 13006, 13068, 13721, 14231], [14233, 14233, 14298, 15086, 15761], [15763, 15763, 15802, 15802, 15830], [15832, 15832, 15888, 16748, 17829], [17831, 17831, 17872, 18092, 18212], [18214, 18214, 18271, 18305, 18965]]}
{"id": "4d33Rf", "name": "Cassini oval", "author": "Gavreg", "description": "Dymanic cassini ovals", "tags": ["cassiniovalmathanimation"], "likes": 5, "viewed": 204, "published": "Public", "date": "1451208372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//    https://en.wikipedia.org/wiki/Cassini_oval\nbool curve(in float x, in float y, in float start, out float r)\n{\n    float a = 1.0;\n    float c = (abs(fract(start + iTime*0.03)*1.3)+0.7)*a;\n    r=abs( (x*x+y*y)*(x*x+y*y)-2.0*c*c*(x*x-y*y) - c*c*c*c+a*a*a*a) ;\n    if  (r <= 0.013)\n       return true;\n    else \n        return false;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x/=iResolution.y/iResolution.x;\n\n\t//fragColor = \n    \n    float u = uv.x*2.0-1.0/(iResolution.y/iResolution.x);\n    float v = uv.y*2.0-1.0;\n      \n    fragColor = vec4(0,0,0,1);\n    \n    for (float t=0.0; t<1.0;t+=0.04)\n    {\n        float r;\n    \tcurve(u,v,t,r);\n        float col = 1.0/(r*300.0);\n        fragColor += vec4(col*(sin(t*3.14)+2.0),col*(cos(t*3.14)+2.0),col,1.0)* vec4(uv+iTime/10000.0,1.0,0.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d33Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 114, 114, 341], [343, 343, 400, 400, 871]]}
{"id": "4d3GRX", "name": "Round Rock Island", "author": "Hamneggs", "description": "It's lonely on Round Rock Island. Uses lots of FBMs and an atmospheric scattering approach from a shader that I can no longer find.", "tags": ["ray", "time", "displacement", "ocean", "sky", "reflections", "scattering", "bump", "mapping", "surface", "island", "march", "rock", "sand", "atmospheric", "real"], "likes": 34, "viewed": 835, "published": "Public", "date": "1451268266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Version 1.0:\tInitial release.\n * Version 1.1:\tAdded a couple quality defines. CALC_OCCLUSION specifies to calculate\n * \t\t\t\tambient occlusion, which is about 5 calls to dist(), each of which has\n * \t\t\t\tabout 10 texture samples.\n * \t\t\t\tHQ_RENDER does a whole lot. In its absence, the FBMs have one fewer\n * \t\t\t\toctave, the rock loses a middle octave of noise, the sand is no longer\n * \t\t\t\timage-reflective, and the field as in the ocean reflections is textured\n * \t\t\t\tonly with the sand texture. This cuts out a whole lot of texture calls,\n * \t\t\t\tand a deep-in-there branch.\n * \t\t\t\tThese defines are commented by default. Enable them to see the whole\n * \t\t\t\tpicture.\n */\n\n// Render quality defines.\n// #define CALC_OCCLUSION\n// #define HQ_RENDER\n\n// Occlusion attenuation factor.\n#define OCC_FACTOR 1.5\n    \n// Light and reflection penumbra factors.\n#define PENUMBRA_FACTOR 50.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 4.0\n// Main marching steps.\n#define V_STEPS 100\n// Reflection marching steps.\n#define R_STEPS 30\n// Shadow marching steps.\n#define S_STEPS 30\n// Maximum successful marching distance.\n#define EPSILON .025\n// Max ray depth.\n#define MAX_DEPTH 150.0\n\n// How fast do you want time to go?\n#define TIME_WARP .3\n\n// Object constants.\n#define SAND_NOISE_TEX iChannel1\n#define SAND_BUMP_HEIGHT .6\n#define OCEAN_NOISE_TEX iChannel1\n#define OCEAN_HEIGHT -.25\n#define OCEAN_AMPLITUDE .45\n#define OCEAN_SPEED .35\n#define WALL_BUMP_HEIGHT 7.5\n#define WALL_DIFF_TEX iChannel2\n#define RAND_NOISE_TEX iChannel0\nconst vec2 ROCK_DIM = vec2(4.0,1.75);\n\n// Object IDs for shading.\n#define ID_ROCK 1.0\n#define ID_SAND 128.0\n#define ID_OCEAN 256.0\n\n// Environment and color constants.\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\nconst vec3 PLANET_ROT = vec3(0.0,0.0,1.0);\t\t\t\t\t// The axis on which the planet rotates.\nconst vec3 SUN_DIR = vec3(0., 0.995037, 0.0995037);\t\t\t// The starting direction of the sun.\nconst vec3 SKY_COLOR_A = vec3(0.53,0.81,0.92);\t\t\t    // Sky color.\nconst vec3 SKY_COLOR_B = vec3(0.23,0.34,0.85);\t\t\t\t// High angle sky.\nconst vec3 SUN_COLOR_A = vec3(4.0);\t\t\t\t\t\t\t// Noontime sun color.\nconst vec3 SUN_COLOR_B = vec3(2.0, .66, 0.06);\t\t\t\t// Evening sun color.\nconst vec3 GROUND_COLOR = vec3(.6, .5, .32);\t\t\t\t// Average ground color.\nconst vec3 SAND_COLOR = vec3(.4, .35, .22);\t\t\t\t\t// The color of the sand.\nconst vec3 ROCK_COLOR_A = vec3(.4,.3,.15);\t\t\t\t\t// One rock color.\nconst vec3 ROCK_COLOR_B = vec3(.4,.2,.15);\t\t\t\t\t// Another rock color.\n#define NIGHT_BRIGHTNESS .1\n\n// Math constants.\nconst mat2 ROT45 = mat2(-.710, -.710, .710, -.710);\nconst mat2 ROT90 = mat2(0.,1.,-1.,0.);\nconst vec2 RAND_SEED = vec2(12.9898,78.233);\n#define PI   3.141593\n#define PI4 12.56637\n\n// Camera parameters.\nconst vec3 CAM_LOOK_AT = vec3(0.0, 2.0, 0.0);\nconst float CAM_DIST_AWAY = 50.25; // How far away the camera is from CAM_LOOK_AT.\nconst float CAM_ZOOM = 1.0;\n\n/*\n\tOlinde Rodrigues' vector rotation formula for rotating a vector <a>\n\taround a vector <b> <t> radians.\n*/\nvec3 rodRot( in vec3 a, in vec3 b, in float t )\n{\n    // Straight from wikipedia.\n\treturn normalize(a*cos(t) + cross(b, a)*sin(t) + b*dot(b,a)*(1.0-cos(t)));\n}\n\n/*\n\tMy goofy redefinition-of-basis-based camera.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in vec3 up, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, up)*uv.x + up*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade( in float s, in float e, in float t, in float duration )\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tA decoration function to get between you and and camera().\n\tNevermind that it does fancy animation; death to interface degraders!\n*/\nvoid animateCam(in vec2 uv, in float t, out vec3 p, out vec3 d, out vec3 e, out float s )\n{\n\tt = mod(t,35.0);\n    \n    vec3 u = UP;\n    float f = 1.0;\n    if(t<PI4)\n    {\n    \te = vec3(30.0*cos(t*.125),2.0,30.0*sin(t*.125));\n   \t\td = normalize(vec3(0.0)-e);\n        s = shutterfade(0.0, PI4, t, .5);\n    }\n    else if(t<20.0)\n    {\n        e = mix(PLANET_ROT*-10.0,PLANET_ROT*10.0,smoothstep(PI4,20.0,t));\n        e.y += 1.0;\n        d = PLANET_ROT;\n        s = shutterfade(PI4, 20.0, t, .5);\n    }\n    else if(t<25.0)\n    {\n        e = mix(vec3(-10.0,1.0,3.0),vec3(10.0,1.0,3.0),smoothstep(20.0,25.0,t));\n        d = vec3(0.948683, 0.316228, 0.0);\n        u = vec3(-d.y,d.x,0.0); \n        s = shutterfade(20.0, 25.0, t, .5);\n    }\n    else if(t<30.0)\n    {\n        e = mix(vec3(-30.0,10.0,-10.0),vec3(10.0,10.0,10.0),smoothstep(25.0,30.0,t));\n        d = vec3(0.666667, -0.333333, 0.666667);\n        u = vec3(-d.y,d.x,0.0); \n        s = shutterfade(25.0, 30.0, t, .5);\n    }\n    else\n    {\n        e = mix(vec3(1.0,1.0,2.0),vec3(1.0,5.0,1.5),smoothstep(30.0,35.0,t));\n        d = UP;\n        u = PLANET_ROT;\n        f = .5;\n        s = shutterfade(30.0, 35.0, t, .5);\n    }\n    camera(uv, e, d, u, f, p, d);\n}\n\n/*\n\tTakes a vec2 containing a distance and a primitive's ID and returns\n\tthe ID and distance of the nearer primitive, effectively performing\n\ta solid modeling union.\n*/\nvec2 u( in vec2 a, in vec2 b )\n{\n    return mix(a,b,step(b.s,a.s));\n}\n\n/*\n\tThe random function from the first Stack Overflow article that is\n\treturned after googling \"GLSL noise\".\n\tCan we have a conversation about how GLSL defines a noise function\n\tbut no vendors actually implement it?\n*/\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co,RAND_SEED)) * 43758.5453);\n}\n\n/*\n\tA 2D texture-sampled noise function. Used when the surface to be\n\tdistorted exists entirely in one plane.\n*/\nfloat n(vec2 p, sampler2D tex)\n{\n    return texture(tex,p).r;\n}\n\n/*\n\tIQ's seminal noise function. I learned that the weird ring artifacts\n\twere due to vflipping it's texture buddy.\n*/\nfloat nIQ( in vec3 x, in sampler2D t )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( t, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n/*\n\tA 2D FBM with time dependence.\n*/\nfloat fbm2Dt( in vec2 p, in float t, in sampler2D tex )\n{\n    float r = n(p+t*.1,tex);\n    p*=ROT45;p*=2.0;p+=t*-.24;\n    r += n(p,tex)*.500;\n    p*=ROT45;p*=2.0;p+=t*-.12;\n    #ifdef HQ_RENDERING\n    r += n(p,tex)*.250;\n    #endif\n    return r*1.0075;\n}\n\n/*\n\tA 3 octave FBM that uses IQ's noise.\n*/\nfloat fbm3D( in vec3 p, in sampler2D t )\n{\n    float r = nIQ(p, t)*.5;\n    r += nIQ(p*2.0, t)*.25;\n    r += nIQ(p*4.1, t)*.125;\n    return r * 1.11872;\n}\n\n    \n/*\n\tReturns the distance to the ocean plane.\n*/\nfloat ocean( in vec3 p )\n{\n    // Translate to the Y coordinate of the ocean.\n    p.y -= OCEAN_HEIGHT;\n    // Do some optimization where if we're beyond a certain\n    // distance from the plane, we don't worry about calculating the bump height.\n    // The *4.0 is there because the bump map would fall to 0 near the horizon.\n    if(p.y>OCEAN_AMPLITUDE*4.0)return p.y;\n    // If we're within that threshold, we modulate the distance by the bump map.\n    else return p.y+fbm2Dt(p.xz*.025, iTime*OCEAN_SPEED, OCEAN_NOISE_TEX)*OCEAN_AMPLITUDE;\n}\n\n/*\n\tReturns the distance to the sand. This is really just sphere that looks cool\n\tand is drowning.\n*/\nfloat sand( in vec3 p )\n{\n    // Translate the sphere down into the water.\n    p.y += 50.0;\n    // An inlining of the classic sphere distance formula.\n    float sphere = length(p)-51.0;\n    // Same distance check as with the ocean.\n    if(sphere-SAND_BUMP_HEIGHT> 0.0) return sphere;\n   \t// Same method of height modulation. Since we're only considering the\n    // scalp of the sphere, we don't need worry about the fact that we're\n    // using a 2D fbm.\n    else\n    {\n        return sphere + fbm2Dt(p.xz*.025,0.0,SAND_NOISE_TEX)\n            \t\t  * SAND_BUMP_HEIGHT;\t// The general height of the sand features.\n    }\n}\n\n/*\n\tThe distance function of the rock.\n*/\nfloat rock( in vec3 p )\n{\n    // Inlined torus distance function.\n    vec2 q = vec2(length(p.xy)-ROCK_DIM.x,p.z);\n  \tfloat d = length(q)-ROCK_DIM.y;\n    \n    // The sum of the heights of the FBM and noise calls.\n    if(d > 1.5125) return d;\n    else\n    {        \n        float t = fbm3D(p, RAND_NOISE_TEX);\n        #ifdef HQ_RENDERING\n        t += nIQ(p*1.0,RAND_NOISE_TEX)*.5;\n        #endif\n        t += nIQ(p*32.0,RAND_NOISE_TEX)*.0125;\n        return d + t;\n    }\n}\n\n\n/*\n\tThe scene's distance function.\n*/\nfloat dist( in vec3 p )\n{\n    // I think nesting this is a bit more better than dicing it out\n    // into two calls. Could someone confirm or deny this?\n    return min(sand(p),min(ocean(p),rock(p)));\n}\n\n/*\n\tThe distance function of the stuff that's visible in \n\treflections. This doesn't include some stuff to save\n\ttime.\n*/\nfloat distR( in vec3 p )\n{\n    // By not having the ocean here we're cutting out hundreds\n    // of texture samples per ray.\n    return min(sand(p),rock(p));\n}\n\n/*\n\tReturns the id and distance of the nearest object.\n*/\nvec2 distID( in vec3 p )\n{\n    vec2 d = u(vec2(sand(p),ID_SAND), vec2(ocean(p), ID_OCEAN));\n    return u(d, vec2(rock(p), ID_ROCK));\n}\n\n/*\n\tAnother reflection shortcut variation of another function.\n*/\nvec2 distIDR( in vec3 p )\n{\n    return u(vec2(sand(p),ID_SAND),vec2(rock(p), ID_ROCK));\n}\n\n/*\n\tReturns the direction of the sun based on the current time.\n*/\nvec3 sunDir()\n{\n    return rodRot(SUN_DIR, PLANET_ROT, iTime*TIME_WARP);\n}\n\n/*\n\tReturns the color of the sun. Just does some janky fading\n\tbetween white at zenith and yellow at asimuth.\n*/\nvec3 sunColor( in vec3 sunDir )\n{\n    return mix(SUN_COLOR_B, SUN_COLOR_A, clamp(dot(sunDir,UP),0.0,1.0));\n}\n\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\n\n/*\n\tTakes a ray direction (presumably out into the sky)\n\tand returns how much it hits a star.\n*/\nfloat stars( in vec3 d)\n{\n    d = rodRot( d, PLANET_ROT, -iTime*TIME_WARP);\n    return pow(nIQ(d*200.0,RAND_NOISE_TEX),80.0); // These numbers are so magic they\n    \t\t\t\t\t\t\t\t\t\t\t\t\t// could carry the Lakers.\n}\n\n/*\n\tCombines the sky radiance from the magic above with a specular \n\thighl^H^H^H^H^H^Hsun.\n*/\nvec3 sky( in vec3 d, in vec3 ld )\n{\n    // Get the sky color.\n    vec3 sky = calculateSkyLuminanceRGB(ld, d, 3.0);\n    \n    // How night time is it? This variable will tell you.\n    float night = smoothstep(-0.0, -0.5, clamp(dot(ld, UP),-0.5, -0.0));\n    // Set a general brightness level so we don't just have a white screen,\n    // and artificially darken stuff at night so it looks good.\n    sky *= .040-.035*night;\n    \n    // Create a spot for the sun. This version gives us some nice edges\n    // without having a pow(x,VERY_LARGE_NUMBER) call.\n    float sunspot = smoothstep(.99935, .99965, max(dot(d,ld),0.0));\n    sunspot += smoothstep(.98000, 1.0, max(dot(d,ld),0.0))*.05; // Corona.\n    \n   \t// Mix the sky with the sun.\n    sky = sky*(1.0+sunspot);\n    \n    // Also add in the stars.\n    return sky + stars(d)*.5;\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm( in vec3 p )\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tReturns the surface normal of the stuff in reflections.\n*/\nvec3 normR( in vec3 p )\n{\n\treturn normalize(vec3(distR(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  distR(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  distR(vec3(p.x,p.y,p.z+EPSILON)))-distR(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction d\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = dist(p+d*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r*.66; // The higher levels of noise in the rock may be skipped\n        \t\t\t  // if the steps are too large.\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tYet another secondary function for the case of reflections. This one\n\tdoes ray marching.\n*/\nvoid marchR( inout vec3 p, in vec3 d, in vec3 e )\n{\n\tfloat r = distR(p+d*EPSILON);\n\tfor(int i = 0; i < R_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || length(p-e) > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += d*r; // Eh the reflections are barely seen. We don't need to\n        \t\t  // attenuate distance marched because of high frequency distance stuff.\n        r = distR(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 n, in vec3 ldir, in float p )\n{    \n    // Do some quick \"is the sun even shining on here\" tests.\n    // We wait until the sun is just below the horizon before considering\n    // it gone.\n    if( dot(n,ldir) <= 0.0 || dot(ldir,UP) <= -.25) return 0.0;\n    \n\tfloat t = EPSILON*40.0;\n\tfloat res = 1.0;\n    for ( int i = 0; i < S_STEPS; ++i )\n    {\n        float d = distR( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tIQ's really compact implementation of Oren Nayar reflectance.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion( in vec3 pos, in vec3 norm)\n{\n    // I even unrolled it for you. Aren't I nice?\n    float result = pow(2.0,-1.0)*(0.25-dist(pos+0.25*norm));\n    result += pow(2.0,-2.0)*(0.50-dist(pos+0.50*norm));\n    result += pow(2.0,-3.0)*(0.75-dist(pos+0.75*norm));\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tPerforms the full suite of lighting for Oren Nayar-appropriate\n\tsurfaces. Calculates direct (sun), sky, and ambient radiance\n\tcontributions.\n*/\nvec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld )\n{\n    // Get an ambient occlusion value.\n    #ifdef CALC_OCCLUSION\n    float amb = occlusion(p,n)*max(dot(ld,UP),0.25);\n    #else\n    float amb = 1.0;\n    #endif\n    \n    // Get light colors and radiance for the three lights.\n    // (Or just specral radiance if that's your thing.)\n    vec3 skc = .6*orenNayar(n,-d,UP)*sky(n,ld);\n    vec3 sun = orenNayar(n,-d,ld)*sunColor(ld);\n    vec3 gnd = .2*GROUND_COLOR*max(orenNayar(n,-d,-UP),0.25);\n    \n    // Modulate those by ambient occlussion and shadowing.\n    skc *= amb;\n    gnd *= amb;\n    sun *= shadow(p,n,ld,PENUMBRA_FACTOR);;\n    \n    // Return the sum.\n    return skc+gnd+sun; \n}\n\n/*\n\tReturns the texture of the sand, and does some basic distance\n\tfiltering.\n*/\nvec3 texSand( in vec3 p, in float l )\n{\n    // Essentially what we're doing is just calculating low contrast\n    // random values whose contrast diminishes with distance.\n    return SAND_COLOR*mix(.75+rand(p.xz)*.25, .85, clamp(l/MAX_DEPTH,0.0,1.0));\n}\n\n/*\n\tShades dry sand. Just takes in an illumination value and texture\n\tand multiplies the two together. Simple.\n*/\nvec3 shadeDrySand( in vec3 i, in vec3 t )\n{\n    return i*t;\n}\n\n/*\n\tNon reflective wet sand is a bit harder, but still simple.\n\tEssentially we're doing per-pixel Phong shading, but the diffuse\n\tterm is .5 of the dry sand result. Oh, and the ambient term is\n\tthe sky above.\n*/\nvec3 shadeWetSand( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n\t// Specular.\n\tvec3 r = reflect(d,n);\n    vec3 spec = sunColor(ld) * max( pow(dot(ld,r),50.0), 0.0);\n    // Diffuse.\n    vec3 diff = shadeDrySand(i,tex)*.5;\n    // Ambient.\n    vec3 ambi = sky(n,ld);\n    return spec+diff+ambi;\n}\n\n/*\n\tConstructs the appearance of non-reflection sand (sand that is \n\talready a reflection.) Since you barely see this sand, we don't\n\tworry about if it's wet or not. (To save cycles.)\n*/\nvec3 shadeSand( in vec3 p, in vec3 i, in float l )\n{\n    // Get the texture of the sand.\n    vec3 tex = texSand(p,l);\n    // Pass it into the the shading function.\n    return shadeDrySand(i,tex);\n}\n\n/*\n\tPrepares the texture of the rock. It's pretty much just\n\ta jumbled mix of two colors.\n*/\nvec3 texRock( in vec3 p )\n{\n    p.y *= 8.0;\n    float chroma = nIQ(p*8.0, RAND_NOISE_TEX);\n    // Mix the two rock colors based on a noise value, then somewhat\n    // randomize the lumosity to make it look rough.\n    return mix(ROCK_COLOR_A, ROCK_COLOR_B,chroma)*mix(.8, 1.2, rand(p.xy));\n}\n\n/*\n\tShades the rock. With the illumination color and value pre-computed\n\tthis is a simple task.\n*/\nvec3 shadeRock( in vec3 p, in vec3 i )\n{\n    return texRock(p)*i;\n}\n\n/*\n\tShades the scene as seen through a reflection.\n\tNote how reflections only feature a subset of the\n\tscene's items.\n*/\nvec3 shadeR( in vec3 p, in vec3 d, in vec3 ld, in vec3 e )\n{\n    // Get the distance to the point.\n    float l = length(p-e);\n    \n    // If the ray ran out of length, we return the sky.\n    if(l > MAX_DEPTH) return sky(d,ld);\n    \n    // Get the ID of the current object.\n    float id = distID(p).t;\n    // Get the surface normal of the reflected scene.\n    vec3 n = normR(p);\n    // Get a general light color to use...wherever.\n    vec3 i = light(p,d,e,n,ld);\n    \n    // Do some piecewise shading.\n    #ifdef HQ_RENDERING\n    if(id == ID_ROCK) return shadeRock(p,i);\n    else \t\t\t  return shadeSand(p,i,l);\n    #else\n    return shadeSand(p,i,l);\n    #endif\n}\n\n/*\n\tConstructs the appearance of reflective sand.\n*/\nvec3 shadeWetSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )\n{\n    // Get the reflected ray direction.\n    vec3 r = reflect(d,n);\n    \n    // March the (now reflected) ray in that direction.\n    #ifdef HQ_RENDERING\n    marchR(p,r,e);\n    // Get the appearance of the point the reflect ray found.\n    vec3 reflection = shadeR(p,r,ld,e);\n    #else\n    vec3 reflection = sky(r,ld);\n    #endif\n    // Create a standard Phong specular term to spice things up in\n    // the shiny department.\n    vec3 specular = pow(max(dot(r,ld),0.0),350.0)*sunColor(ld);\n    // Get the reflectance of the surface given the angle of incidence.\n    float reflectance = max(length(cross(n,d)),0.0);\n    // Get the diffuse term. (discussed in shadeWetSand().)\n    vec3 diffuse = tex*i*.5;\n    // Return a blend of the reflection and the sand and the specular highlight.\n    return mix(diffuse, reflection, pow(reflectance,128.0))+specular;\n}\n\n/*\n\tConstructs the appearance of first-bounce sand, whether it's wet and reflective\n\tor not.\n*/\nvec3 shadeSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in float l )\n{\n    // Compute the texture of the sand.\n    vec3 tex = texSand(p,l);\n    \n    // Figure out how wet the sand is. This is just some quasi-good value\n    // that is vaguely related to the height of the water, but higher.\n    float wetness = clamp(smoothstep(OCEAN_HEIGHT, 0.075, p.y),\n                          0.0,1.0);\n    \n    // Get the appearance of reflective wet sand.\n    vec3 wet = shadeWetSandR(p,d,e,n,i,ld,tex);\n    // Get the appearance of the dry sand.\n    vec3 dry = shadeDrySand(i,tex);\n    \n    // Return a mix of wet and dry sand based on the wetness of the sand.\n    return mix(wet,dry,wetness);\n}\n\n/*\n\tShades the ocean with its reflections.\n*/\nvec3 shadeOceanR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld, in vec3 sky )\n{\n    // Get the pirate vector.\n    vec3 r = reflect(d,n);\n    \n    // March P away from where it started out.\n    marchR(p,r,e);\n    \n    // Get the image of the reflection.\n    vec3 reflection = shadeR(p,r,ld,e);\n    // Make a swanky specular highlight.\n    vec3 specular = pow(max(dot(r,ld),0.0),500.0)*sunColor(ld);\n    \n    // Get a non-reflection color for the ocean.\n    vec3 ocean = vec3(.0,.08, .1)*max(0.005, dot(d,UP));\n    // Get how much the reflection should be visible.\n    float reflectance = pow(max(length(cross(n,d)),0.0),2.0); //Sin^2(incidence)\n    // Do some mixin'.\n    return mix(ocean,reflection,reflectance*.5)+specular;\n}\n\n/*\n\tThe first bounce shading function. Takes that first ray, beats it up,\n\tand sends to next Tuesday.\n*/\nvec3 shade( in vec3 p, in vec3 d, in vec3 e )\n{\n    // Get the distance for that gentle blend at the horizon.\n    float l = length(p-e);\n    // Get the sun direction and sky color once, and pass it around.\n    vec3 ld = sunDir();\n    vec3 s = sky(d,ld);\n    \n    // Take care of the appearance of culled stuff--they're sky now.\n    if(l > MAX_DEPTH) return s;\n    \n    // Get the ID of the object we're shading, and make a place\n    // to store the final result.\n    float id = distID(p).t;\n    vec3 result;\n    \n    // Get the normal and create a general Oren Nayar term to be\n    // the shade functions' village bicycle, right next to the\n    // light direction, which is the village Razor scooter.\n    vec3 n = norm(p);\n    vec3 i = light(p,d,e,n,ld);\n    \n    // Shade the surface, based on the object ID.\n    if(id == ID_OCEAN){\n        float distSand = sand(p);\n        float distOcean = ocean(p);\n        vec3 sand = shadeSandR(p,d,e,n,i,ld,l);\n        vec3 ocean = shadeOceanR(p,d,e,n,ld,s);\n        result = mix(sand,ocean,clamp(distSand-distOcean,0.0,2.0)*.5);\n    }\n    else if(id == ID_SAND)\tresult = shadeSandR(p,d,e,n,i,ld,l);\n    else result = shadeRock(p,i);\n        \n    // Mix this shaded color with the color of the sky at far distances,\n    // so we don't have that ugly plane() @ MAX_DEPTH edge.\n\treturn mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));\n}\n\n/*\n\tPerforms some quick post-processing. Does gamma correction\n\tand adds a soft vignette just to make whatever you're doing\n\tlook pretty.\n*/\nvec3 postProcess( in vec2 uv, in vec3 c )\n{\n    float vig = 1.0-dot(uv,uv)*.3;\n    return pow(c,vec3(1.0/2.2))*vig;\n}\n\n/*\n\tShadertoy's entry point.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Standard pixel-coordinate normalization.\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Position, direction, and eye.\n    // Notice that it spells out the Processing file extension?\n    vec3 p,d,e;\n    \n    // The shutter. This is populated by animateCam() as a frame\n    // brightness coefficient to fade between scenes.\n    float s;\n    \n    // Set up the camera.\n    animateCam(uv,iTime,p,d,e,s);\n    \n    // Do the actual ray marching.\n    march(p,d,e);\n    \n    // Store the final pixel color.\n    //fragColor = postProcess(uv,shade(p,d,e)).rgbb*s;\n    // Eventually the alpha of fragColor may be used.\n    fragColor = vec4(postProcess(uv,shade(p,d,e)),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3GRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[3038, 3147, 3196, 3228, 3306], [3308, 3360, 3459, 3459, 3535], [3537, 3586, 3662, 3662, 3742], [3744, 3881, 3972, 3972, 5091], [5093, 5262, 5294, 5294, 5331], [5333, 5552, 5578, 5578, 5635], [5637, 5750, 5782, 5782, 5813], [5815, 5934, 5974, 5974, 6176], [6178, 6216, 6273, 6273, 6470], [6472, 6516, 6558, 6558, 6669], [6676, 6724, 6750, 6801, 7265], [7267, 7369, 7394, 7443, 7987], [7989, 8031, 8056, 8096, 8501], [8504, 8542, 8567, 8694, 8743], [8745, 8867, 8893, 8991, 9026], [9028, 9086, 9112, 9112, 9220], [9222, 9288, 9315, 9315, 9377], [9379, 9446, 9461, 9461, 9520], [9522, 9635, 9668, 9668, 9743], [9745, 10071, 10115, 10115, 10153], [10154, 10154, 10184, 10184, 10306], [10307, 10307, 10337, 10347, 10489], [10490, 10490, 10520, 10520, 10593], [10594, 10594, 10701, 10701, 11098], [11099, 11099, 11164, 11164, 11958], [11959, 11959, 12081, 12081, 12197], [12198, 12198, 12265, 12265, 12785], [12787, 12884, 12909, 12909, 13090], [13092, 13186, 13221, 13247, 14013], [14015, 14094, 14118, 14118, 14268], [14270, 14333, 14358, 14358, 14512], [14514, 14662, 14712, 14712, 14987], [14989, 15085, 15136, 15136, 15448], [15450, 15526, 15594, 15750, 16117], [16119, 16188, 16243, 16243, 16544], [16546, 16677, 16722, 16772, 16978], [16980, 17128, 17198, 17237, 17831], [17833, 17914, 17953, 18084, 18166], [18168, 18282, 18325, 18325, 18343], [18345, 18557, 18658, 18672, 18887], [18889, 19076, 19128, 19164, 19273], [19275, 19368, 19395, 19395, 19658], [19660, 19759, 19799, 19799, 19826], [19828, 19949, 20009, 20047, 20609], [20611, 20664, 20766, 20806, 21620], [21622, 21718, 21816, 21856, 22431], [22433, 22479, 22568, 22598, 23215], [23217, 23322, 23369, 23431, 24734], [24736, 24877, 24920, 24920, 24994], [24996, 25028, 25085, 25133, 25828]]}
{"id": "4d3GW7", "name": "2015/12/12", "author": "hughsk", "description": "Experimenting with refraction  still some room for improving accuracy/aesthetics but happy with it so far :)", "tags": ["grid", "sdf", "refraction", "color", "refract"], "likes": 40, "viewed": 1676, "published": "Public API", "date": "1449892463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GLSLIFY 1\n\nvec2 mapRefract(vec3 p);\nvec2 mapSolid(vec3 p);\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 50; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapRefract(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_3975550108(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 60; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapSolid(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_766934105(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal_3606979787(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapRefract( pos + v1*eps ).x +\n                    v2 * mapRefract( pos + v2*eps ).x +\n                    v3 * mapRefract( pos + v3*eps ).x +\n                    v4 * mapRefract( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_3606979787(vec3 pos) {\n  return calcNormal_3606979787(pos, 0.002);\n}\n\nvec3 calcNormal_1245821463(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapSolid( pos + v1*eps ).x +\n                    v2 * mapSolid( pos + v2*eps ).x +\n                    v3 * mapSolid( pos + v3*eps ).x +\n                    v4 * mapSolid( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_1245821463(vec3 pos) {\n  return calcNormal_1245821463(pos, 0.002);\n}\n\nfloat beckmannDistribution_2315452051(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular_1460171947(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n\n  //Distribution term\n  float D = beckmannDistribution_2315452051(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix_1535977339(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_870892966(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_870892966(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_1535977339(origin, target, 0.0);\n  return getRay_870892966(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera_421267681(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame_1062606552(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_870892966(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n// Originally sourced from:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdBox_1117569599(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nhighp float random_2281831123(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat fogFactorExp2_529295689(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) / denom;\n\n  return t;\n}\n\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\n\nfloat icosahedral(vec3 p, float r) {\n  float s = abs(dot(p,n4));\n  s = max(s, abs(dot(p,n5)));\n  s = max(s, abs(dot(p,n6)));\n  s = max(s, abs(dot(p,n7)));\n  s = max(s, abs(dot(p,n8)));\n  s = max(s, abs(dot(p,n9)));\n  s = max(s, abs(dot(p,n10)));\n  s = max(s, abs(dot(p,n11)));\n  s = max(s, abs(dot(p,n12)));\n  s = max(s, abs(dot(p,n13)));\n  return s - r;\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec2 mapRefract(vec3 p) {\n  float d  = icosahedral(p, 1.0);\n  float id = 0.0;\n\n  return vec2(d, id);\n}\n\nvec2 mapSolid(vec3 p) {\n  p.xz = rotate2D(p.xz, iTime * 1.25);\n  p.yx = rotate2D(p.yx, iTime * 1.85);\n  p.y += sin(iTime) * 0.25;\n  p.x += cos(iTime) * 0.25;\n\n  float d = length(p) - 0.25;\n  float id = 1.0;\n  float pulse = pow(sin(iTime * 2.) * 0.5 + 0.5, 9.0) * 2.;\n\n  d = mix(d, sdBox_1117569599(p, vec3(0.175)), pulse);\n\n  return vec2(d, id);\n}\n\n// Source: http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  vec3 col = 0.1 + (\n    palette(clamp((random_2281831123(rd.xz + sin(iTime * 0.1)) * 0.5 + 0.5) * 0.035 - rd.y * 0.5 + 0.35, -1.0, 1.0)\n      , vec3(0.5, 0.45, 0.55)\n      , vec3(0.5, 0.5, 0.5)\n      , vec3(1.05, 1.0, 1.0)\n      , vec3(0.275, 0.2, 0.19)\n    )\n  );\n\n  float t = intersectPlane(ro, rd, vec3(0, 1, 0), 4.);\n\n  if (t > 0.0) {\n    vec3 p = ro + rd * t;\n    float g = (1.0 - pow(abs(sin(p.x) * cos(p.z)), 0.25));\n\n    col += (1.0 - fogFactorExp2_529295689(t, 0.04)) * g * vec3(5, 4, 2) * 0.075;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n\n  vec2  uv       = squareFrame_1062606552(iResolution.xy, fragCoord);\n  float dist     = 4.5;\n  float rotation = iMouse.z > 0.0\n    ? 6. * iMouse.x / iResolution.x\n    : iTime * 0.45;\n  float height = iMouse.z > 0.0\n    ? 5. * (iMouse.y / iResolution.y * 2.0 - 1.0)\n    : -0.2;\n    \n  orbitCamera_421267681(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n\n  vec3 color = bg(ro, rd);\n  vec2 t = calcRayIntersection_3975550108(ro, rd);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal_3606979787(pos);\n    vec3 ldir1 = normalize(vec3(0.8, 1, 0));\n    vec3 ldir2 = normalize(vec3(-0.4, -1.3, 0));\n    vec3 lcol1 = vec3(0.6, 0.5, 1.1);\n    vec3 lcol2 = vec3(1.4, 0.9, 0.8) * 0.7;\n\n    vec3 ref = refract(rd, nor, 0.97);\n    vec2 u = calcRayIntersection_766934105(ro + ref * 0.1, ref);\n    if (u.x > -0.5) {\n      vec3 pos2 = ro + ref * u.x;\n      vec3 nor2 = calcNormal_1245821463(pos2);\n      float spec = cookTorranceSpecular_1460171947(ldir1, -ref, nor2, 0.6, 0.95) * 2.;\n      float diff1 = 0.05 + max(0., dot(ldir1, nor2));\n      float diff2 = max(0., dot(ldir2, nor2));\n\n      color = spec + (diff1 * lcol1 + diff2 * lcol2);\n    } else {\n      color = bg(ro + ref * 0.1, ref) * 1.1;\n    }\n\n    color += color * cookTorranceSpecular_1460171947(ldir1, -rd, nor, 0.2, 0.9) * 2.;\n    color += 0.05;\n  }\n\n  float vignette = 1.0 - max(0.0, dot(uv * 0.155, uv));\n\n  color.r = smoothstep(0.05, 0.995, color.r);\n  color.b = smoothstep(-0.05, 0.95, color.b);\n  color.g = smoothstep(-0.1, 0.95, color.g);\n  color.b *= vignette;\n\n  fragColor.rgb = color;\n  fragColor.a   = clamp(t.x, 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3GW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 160, 160, 554], [556, 556, 622, 622, 697], [699, 699, 790, 790, 1182], [1184, 1184, 1249, 1249, 1323], [1325, 1325, 1374, 1374, 1762], [1764, 1764, 1802, 1802, 1848], [1850, 1850, 1899, 1899, 2279], [2281, 2281, 2319, 2319, 2365], [2367, 2367, 2432, 2432, 2714], [2716, 2716, 2859, 2859, 3592], [3594, 3594, 3640, 3640, 3771], [3773, 3773, 3831, 3831, 3955], [3957, 3957, 4029, 4029, 4220], [4222, 4222, 4292, 4292, 4352], [4354, 4354, 4437, 4437, 4563], [4565, 4565, 4754, 4754, 5034], [5036, 5135, 5191, 5191, 5298], [5541, 5541, 5617, 5617, 5731], [5733, 5733, 5795, 5795, 5884], [6247, 6247, 6283, 6283, 6603], [6605, 6605, 6637, 6637, 6692], [6694, 6694, 6719, 6719, 6796], [6798, 6798, 6821, 6821, 7145], [7147, 7219, 7291, 7291, 7334], [7336, 7336, 7363, 7363, 7891], [7893, 7893, 7948, 7948, 9590]]}
{"id": "4d3GzB", "name": "ya'll", "author": "gfobe", "description": "for a workshop", "tags": ["workshop"], "likes": 3, "viewed": 229, "published": "Public", "date": "1450318574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv*2.;\n    uv = uv-1.;\n    uv = abs(uv); \n    \n    uv = uv-.3;\n    \n    float angle = atan(uv.y*2.,uv.x*2.0);\n    float dist = length(uv);\n    \n    dist = dist+dist*sin(dist*20.+iTime)*.5;\n    \n    uv.y = sin(angle+iTime*.5)*dist;\n    uv.x = cos(angle+iTime*.1)*dist;\n\t\n    uv = uv+.5;\n    \n    vec4 color = texture(iChannel0, abs(uv));\n    color += texture(iChannel1, uv);\n                           \n    //color += sin(color*10.+dist)*500.;\n    \n    \n    color.rgb = sin((color.rgb+vec3(0.11,.88,.11))*6.28+iTime);\n   \n    \n   \tcolor = mix(color,color,uv.x);\n    \n    uv.xy = uv.xy+color.rg*.1-.1;\n    fragColor = vec4(color);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3GzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 744]]}
{"id": "4dc3D8", "name": "CircleWave", "author": "RenoM", "description": "wave effect", "tags": ["wavecircle2d"], "likes": 59, "viewed": 4724, "published": "Public", "date": "1449175911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 20.\n#define SPEED 9.\n#define FREQUENCY .3\n\nfloat d;\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\n/*\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\n{\n    vec2 R = iResolution.xy, \n         p = SCALE*(U+U/R)/R.y,\n         i = ceil(p);\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\n}*/\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, \n         p = SCALE*(U+U/R)/R.y,\n         f = fract(p);\n    p=floor(p);\n    float t=(p.x+p.y)*FREQUENCY\n           +iTime*SPEED;\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\n    O.xyz = vec3(C(f)*D(f,o));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 479, 520, 520, 749]]}
{"id": "4dc3DN", "name": "Sphere Cell Noise?", "author": "reza", "description": "Faking it till I make it. ", "tags": ["noise", "sphere"], "likes": 11, "viewed": 296, "published": "Public", "date": "1449588454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.2831853072\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n\nconst vec3 cGammaCorrection = vec3( 0.4545454545 );\n\nvec3 gamma( in vec3 color )\n{\n  return pow( color, cGammaCorrection );\n}\n\nvec4 gamma( in vec4 color )\n{\n  return vec4( gamma( color.rgb ), color.a );\n}\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nconst vec3 light = vec3(0.0,0.0,1.0); //ui:-1.0,1.0,1.0\nconst float rad = 2.0;  //slider:0.0,2.0,1.0\nconst float shinyness = 6.0;  //slider:0.0,6.0,1.0\nconst float noiseScale = 0.10;  //slider:0.0,1.0,1.0\n\nfloat blinnPhongSpecular( vec3 lightDirection, vec3 viewDirection, vec3 surfaceNormal, float shininess ) {\n  vec3 H = normalize(viewDirection + lightDirection);\n  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\n}\n\nvec3 sphere( in vec2 pos, in float radius, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n  \tuv.x *= iResolution.x / iResolution.y;   \n    vec2 sp = - 1.0 + 2.0 * uv;\n  \tfloat r = 1.0 / radius;\n  \tvec2 p = - 1.0 * r + 2.0 * r * ( uv - pos );\n\n  vec3 pt = vec3( sp, 1.0 - length( p ) );\n  vec3 diff = pt - light;\n  float clr = clamp( dot( pt, light ), 0.0, 1.0 );\n  clr = blinnPhongSpecular( light, vec3( 0.0, 0.0, 1.0 ), pt, shinyness );\n  vec3 col = vec3( clr );\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for( int i = 0; i < 40; i++) {\n\t    vec2 pos = vec2( snoise( noiseScale * vec2( float( i ) * 10.0, time ) ), snoise( noiseScale * vec2( -float(i) * 10.0, -time ) ) );\n\t    pos.x *= iResolution.x / iResolution.y;\n\t\tvec3 sp = clamp( sphere( pos, rad * ( 1.0 + abs( snoise( noiseScale * vec2( float(i) + time ) ) ) ), fragCoord ), 0.0, 1.0 );\n    \tfragColor.rgb = max( fragColor.rgb, sp );\n    }\n    fragColor.rgb = 1.0 - fragColor.rgb;\n    fragColor = gamma( fragColor );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 166, 166, 209], [211, 211, 240, 240, 288], [291, 660, 681, 681, 730], [732, 732, 753, 753, 802], [804, 804, 826, 826, 863], [865, 865, 889, 889, 2395], [2436, 2604, 2710, 2710, 2824], [2826, 2826, 2890, 2890, 3329], [3332, 3332, 3389, 3389, 3931]]}
{"id": "4dc3R2", "name": "Rainbow Snake", "author": "BigWIngs", "description": "This is my experiment making interlocking scales. You can change the number of scales with the define on line 4. You can also change the shape of the scales by playing with the shape values at lines 176.  Put fullscreen and enjoy!", "tags": ["2d", "snake", "scales"], "likes": 57, "viewed": 1333, "published": "Public", "date": "1450812983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Rainbow Snake\" by Martijn Steinrucken aka BigWings - 2015\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SIZE 10.\n#define PI 3.1415\n\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash12(vec2 p) {\n     // From https://www.shadertoy.com/view/4djSRW\n\t// Dave Hoskins\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat brightness(vec2 uv, vec2 id) {\n    // returns the brightness of a scale, based on its id\n\tfloat t = iTime;\n    float n = hash12(id);\n    float c = mix(0.7, 1., n);\t\t\t\t// random variation\n    \n    float x = abs(id.x-SIZE*.5);\n    float stripes = sin(x*.65+sin(id.y*.5)+.3)*.5+.5;\t\t// pattern\n    stripes = pow(stripes, 4.);\n    c *= 1.-stripes*.5;\n    \n    float y = floor(uv.y*SIZE);\n    float twinkle = sin(t+n*6.28)*.5 +.5;\n    twinkle = pow(twinkle, 40.);\n    c += twinkle*.5;                 \n    \n    return c;\n}\n\nfloat spokes(vec2 uv, float spikeFrequency) {\n\t// creates spokes radiating from the top of the scale\n    \n    vec2 p = vec2(0., 1.);\n    vec2 d = p-uv;\n    float l = length(d);\n    d /= l;\n    \n    vec2 up = vec2(1., 0.);\n    \n    float c = dot(up, d);\n    c = abs(sin(c*spikeFrequency));\n    c *= l;\n    \n    return c;\n}\n\nvec4 ScaleInfo(vec2 uv, vec2 p, vec3 shape) {\n    \n    float spikeAmount = shape.x;\n    float spikeFrequency = shape.y;\n    float sag = shape.z;\n    \n    uv -= p;\n    \n    uv = uv*2.-1.;\n  \t\n    float d2 = spokes(uv, spikeFrequency);\n    \n    uv.x *= 1.+uv.y*sag;\n   \n\tfloat d1 = dot(uv, uv);\t\t\t\t\t// distance to the center of the scale\n   \n    float threshold = 1.;//sin(iTime)*.5 +.5;\n    \n    float d = d1+d2*spikeAmount;\n    \n    float f = 0.05;//fwidth(d);\n    float c = smoothstep(threshold, threshold-f, d);\n    \n    return vec4(d1, d2, d, c);\n}\n\nvec4 ScaleCol(vec2 uv, vec2 p, vec4 i) {\n    \n    vec3 col1 = vec3(.1, .3, .2);\n    vec3 col2 = vec3(.8, .5, .2);\n    vec3 baseCol = vec3(.1, .3, .2)*3.;\n    uv-=p;\n    \n    float grad = 1.-uv.y;\n    float col = grad+i.x;\n    col = col*.2+.5;\n    \n    vec4 c = vec4(col*baseCol, i.a);\n    \n    c.rgb = mix(c.rgb, col1, i.y*i.x*.5);\t\t// add spokes\n    c.rgb = mix(c.rgb, col2, i.x);\t\t\t\t// add edge highlights\n            \n    c = mix(vec4(0.), c, i.a);\n    \n    float fade = 0.3;\n    float shadow = smoothstep(1.+fade, 1., i.z);\n  \n\tc.a = mix(shadow*.25, 1., i.a);\n    \n    return c;\n}\n\n\nvec4 Scale(vec2 uv, vec2 p, vec3 shape) {\n    \n    vec4 info = ScaleInfo(uv, p, shape);\n    vec4 c = ScaleCol(uv, p, info);\n    \n    return c;\n}\n\nvec4 ScaleTex(vec2 uv, vec2 uv2, vec3 shape) {\n    // id = a vec2 that is unique per scale, can be used to apply effects on a per-scale basis\n    // shape = a vec3 describing the shape of the scale:\n    //\t\t\tx = the amount of spikyness, can go negative to bulge spikes the opposite way\n    //\t\t\ty = the number of spikes\n    //          z = the taper of the scale (0=round -1=top wider 1=bottom wider)\n    \n    vec2 id = floor(uv2);\n    uv2 -= id;\n    \n    // need to render a bunch of scales per pixel, so they can overlap\n    vec4 rScale = Scale(uv2, vec2(.5, 0.01), shape);\n   \tvec4 lScale = Scale(uv2, vec2(-.5, 0.01), shape);\n    vec4 bScale = Scale(uv2, vec2(0., -0.5), shape);\n    vec4 tScale = Scale(uv2, vec2(0., 0.5), shape);\n    vec4 t2Scale = Scale(uv2, vec2(1., 0.5), shape);\n    \n    // every scale has a slightly different brightness + pattern\n    rScale.rgb *= brightness(uv, id+vec2(1.,0.));\n    lScale.rgb *= brightness(uv, id+vec2(0.,0.));\n    \n    bScale.rgb *= brightness(uv, id+vec2(0.,0.));\n    \n    tScale.rgb *= brightness(uv, id+vec2(0.,1.));\n    t2Scale.rgb *= brightness(uv, id+vec2(2.,1.));\n    \n    // start with base color and alpha blend in all of the scales\n    vec4 c =  vec4(.1, .3, .2,1.);\n    c = mix(c, bScale, bScale.a);\n    c = mix(c, rScale, rScale.a);\n    c = mix(c, lScale, lScale.a);\n    c = mix(c, tScale, tScale.a);\n    c = mix(c, t2Scale, t2Scale.a);\n    \n   // c.rg = uv;\n   // c.b = 0.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;  // get uvs in 0 to 1 range\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = m*2. - 1.;\n    float t = iTime;\n    \n    \n    \n   \tuv.x += sin(t+uv.y)*.1;\n    \n    uv.x*=2.;\n    \n    uv -=.5;\n    \n    \n    vec2 uv2 = uv * SIZE;\t\t\t\t\t\t// uv2 -2.5 - 2.5\n    uv2.y -= t;\n    uv +=.5;\n       \n    float grad = (uv2.y+12.5)/15.;\t\t\t\t// goes from 0-1 \n\n    vec3 center = vec3(.6, 1., -.8);  \t\t\t// scale shape settings for center -> amount frequency sag\n    vec3 outside = vec3(0.1, 8., -.9);  \t\t// settings for side\n    \n    float sideFade = pow(uv.x-1.,2.);\n    vec3 shape = mix(center, outside, sideFade);// morph between scale shapes\n    \n   // shape = mix(center, outside, 1.);\n    \n  \n    \n    vec4 c = ScaleTex(uv, uv2, shape);\t\t\t// sample scales\n    c = mix(c, vec4(c.g), sideFade);\t\t\t// fade color towards the edges\n    \n    t*=.1;\t\t\t\t\t\t\t\t\t\t// rainbow....\n    c.r += sin(t)*.4;\n    c.g -= abs(sin(t*1.324))*.435;\n    c.b += sin(t*0.324)*.3;\n    \n    float y = pow(uv.y-.5,2.)*4.;\t\t\t\t// vignette\n    c *= 1.-y;\n\t\n    fragColor = vec4(c);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3R2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 279, 301, 369, 485], [487, 487, 523, 581, 1010], [1012, 1012, 1057, 1112, 1333], [1335, 1335, 1380, 1380, 1886], [1888, 1888, 1928, 1928, 2472], [2475, 2475, 2516, 2516, 2619], [2621, 2621, 2667, 3021, 4071], [4073, 4073, 4130, 4130, 5259]]}
{"id": "4dcGRX", "name": "Simple sphere raytracer", "author": "myownclone", "description": "Modified raytracer based on sergei_am's raytracer.", "tags": ["raytracer", "sphere"], "likes": 2, "viewed": 179, "published": "Public", "date": "1451136982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool testSphere( out vec3 N, in vec3 ray, in vec3 sphere, in float radius )\n{\n    float A = dot( ray, ray );\n    float B = dot( ray, sphere )*(-2.0);\n    float C = dot( sphere, sphere ) - radius*radius;\n    float det = B*B - 4.0*A*C;\n    if( det < 0.0 ) return false;\n    \n    float t = (-B+sqrt(det)) / (2.0*A);\n    \n    vec3 hit = ray*t;\n   \n    N = normalize( hit - sphere );\n    return true;\n}\n\nbool scene( out vec3 N, in vec3 ray )\n{\n    if( testSphere( N, ray, vec3(0,0,5) /* sphere position */, 1.0 /* sphere radius */ ))\n        return true;\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xKoef = 10.0*sin(iTime);\n    float yKoef = 10.0*cos(iTime);\n    float zKoef = 10.0*sin(iTime);\n    \n    vec3 V = normalize( vec3( (fragCoord.xy - iResolution.xy*0.5) / iResolution.xx, 1.0 )); // ray from \"screen\"\n    vec3 L = normalize( vec3(1.0*xKoef,1.0*yKoef,1.0*zKoef)); // light position\n    vec3 N;\n    \n    float Y = fragCoord.y / iResolution.y; // 2d y coord\n    \n    vec3 Sky = vec3( 0.45, 1.0-sin(iTime)*0.75, 1.0 )*Y*0.5; // background color\n    \n    vec3 frag = Sky;\n    \n    if( scene( N, V )) // if sphere is hit by ray, get ray hit normal\n    {\n        float dotNL =  max( dot( N, L ), 0.0 ); // dot product of ray hit normal, used by calculating lighting\n        vec3 H = normalize( V - reflect(V,N)); \n        float dotHL = max( dot( H, L ), 0.0 );\n        float spec = pow( dotHL, 32.0 ); // specular part\n        \n        float Albedo = 0.9; // intensity of light\n        \n        float F = pow( 1.0 - max( dot( V, N ), 0.0 ), 100.0);  // fresnel\n        \n        float Ambient = Albedo + (1.0-Albedo)*F;\n        \n        frag = vec3(sin(iTime),0.5,0.5)*dotNL*Albedo; // standart lighting\n        frag += vec3(1,1,1)*spec*Albedo; // specular lighting\n        frag += Sky * Ambient; // ambient lighting\n    }\n    fragColor = vec4( frag, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 77, 77, 397], [399, 399, 438, 438, 569], [571, 571, 628, 628, 1902]]}
{"id": "4dd3D8", "name": "dot fader", "author": "masaki", "description": "fade in-out dot color", "tags": ["2d"], "likes": 7, "viewed": 900, "published": "Public API", "date": "1449373134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define ALT  0.48\n\nvoid mainImage( out vec4 fragColor, vec2 p)\n{\n    \n\tvec2 uv = p / iResolution.xy;\n    float t = sin(iTime);\n    uv = .5 * sin(uv * PI) + .5;\n    float f = ALT * (t + 1.0);\n    float s = smoothstep(f, 1.0, uv.x * uv.y);\n    p = step(2.,mod(p.xy, 3.));\n    \n    fragColor = p.x * p.y * vec4(0., .7*s, 1.*s, 1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dd3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 84, 84, 350]]}
{"id": "4ddGD7", "name": "783 // Julioid Virii", "author": "MrHenryBemis", "description": "O gof brace yr teraflops dogg ///~?`/`/~??~????~~~//////////", "tags": ["julia", "bacteria", "organism"], "likes": 3, "viewed": 193, "published": "Public", "date": "1450125119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Hypercomplex\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define iTime iTime*sin(19.83)/cos(12.34)*18.3\n\nconst int NUM_STEPS = 64;\nconst int AO_SAMPLES = 3;\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD = 0.0030783;\nconst float EPSILON = 1e-5;\nvec3 RED = vec3(sin(0.6),sin(0.6832),sin(0.783)/2.0);\nvec3 ORANGE = vec3(0.7,sin(0.6783),0.313);\nvec3 BLUE = vec3(0.224,sin(0.3837),0.3);\nconst vec3 WHITE = vec3(1.0,0.99,0.98398);\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * sin(1.9783) + 0.6783,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 29.0) / (3.14783 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n    \n}\n\n// julia based on iq's implementation\nfloat julia(vec3 co,vec4 q) {\n    vec4 nz, z = vec4(co,0.0);\n    float z2 = dot(co,co), md2 = 1.7834;  \n    for(int i = 1; i < 8; i++) {\n        md2 *= 4.0*z2;\n        nz.x = z.x*z.x-dot(z.yzw,z.yzw);\n        nz.y = -1.77783*(z.x*z.y + z.w*z.z);\n        nz.z = 2.07830*(z.x*z.z + z.w*z.y);\n        nz.w = sin(7.777830)*(z.x*z.w - z.y*z.z);\n        z = nz + q;\n        z2 = dot(z,z);\n        if(z2 > 22.0) break;\n    }    \n\treturn sin(0.25)*sqrt(z2/md2)*log(z2);\n        //*(fract(sin(dot(co.xy ,vec2(12.9898,78.233)/15.0))));\n   \n}\n\n\nfloat rsq(float x) {\n    x = sin(x);\n    return pow(abs(x),2.783) * sign(x);\n}\n\n// world\nfloat map(vec3 p) {\n    const float M = -1.783;\n    float time = iTime + rsq(iTime*-0.7835) * -tan(-3.0);\n    return julia(p,vec4( \n       sin(time*0.36783)*0.140783*sin(M),\n        cos(time*0.59783)*0.240783*cos(M),\n        sin(time*0.73783)*0.140783*sin(M),\n        cos(time*0.42783)*0.240783*cos(M)\n       // sin(time*0.96783)*0.140783*cos(M),\n       // cos(time*0.59783)*0.240783*sin(M),\n       // sin(time*0.73783)*0.140783*cos(M),\n       // cos(time*0.42783)*0.240783*sin(M)\n    ));\n}\n        //sin(time*0.96783)*0.140783*sin(M),\n        //cos(time*0.59783)*0.240783*cos(M),\n        //sin(time*0.73783)*0.140783*sin(M),\n        //cos(time*0.42783)*0.240783*cos(M)\nvec3 getNormal(vec3 p) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map(p));\n}\nfloat getAO(vec3 p,vec3 n) {    \n    const float R = 3.0;\n    const float D = 0.783;\n    float r = cos(0.7);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.1+f*R;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;    \n    for(int i = 3; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        float d = map(p);\n        if(d < TRESHOLD) break;\n        t += max(d-TRESHOLD,EPSILON);\n    }    \n    return step(t,2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.1;\n    vec2 sc = vec2(sin(time),cos(time));\n    \n    // tracing of distance map\n    vec3 p;\n    vec3 ori = vec3(0.0,0.0,1.5);\n    vec3 dir = normalize(vec3(uv.xy,-1.0));    \n    ori.xz = vec2(ori.x * sc.y - ori.z * sc.x, ori.x * sc.x + ori.z * sc.y);\n    dir.xz = vec2(dir.x * sc.y - dir.z * sc.x, dir.x * sc.x + dir.z * sc.y);\n    \n    float mask = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p);\n    float ao = getAO(p,n);\n    \n    // bg    \n    vec3 bg = vec3(mix(vec3(4.5),vec3(6.5,6.2,6.0), pow(length(uv)*4.09,5.2)));\n    \n    // color\n    vec3 l0 = (vec3 (-0.3,-0.5,0.5));\n    vec3 l1 = (vec3(-0.3,0.5,-0.5));\n    vec3 l2 = (vec3(0.2,-0.2,0.0));\n    vec3 color;\n    color  = vec3((diffuse(n,l0,3.0) + specular(n,l0,dir,4.0)) * ORANGE);\n    color += vec3((diffuse(n,l1,3.0) + specular(n,l1,dir,4.0)) * BLUE);    \n    color = clamp(color*ao*0.9999,0.001,1.0);\n    color = pow(mix(bg,color,mask),vec3(0.7));\n        \n    color = vec3(ao);\n    color = n / 2.783 + 0.5;\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddGD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[540, 552, 590, 590, 639], [640, 640, 686, 686, 797], [799, 837, 866, 866, 1368], [1371, 1371, 1391, 1391, 1449], [1451, 1460, 1479, 1479, 1950], [1959, 2130, 2154, 2154, 2326], [2327, 2327, 2355, 2355, 2682], [2684, 2684, 2737, 2737, 2960], [2962, 2962, 3019, 3019, 4171]]}
{"id": "4ddGWn", "name": "Warp Experiment 8", "author": "aiekick", "description": "Warp Experiment 6", "tags": ["experiment", "warp", "8"], "likes": 3, "viewed": 648, "published": "Public API", "date": "1448996115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 3. * (2.*fragCoord - iResolution.xy) / iResolution.y;\n\t\n\tuv *= dot(uv, uv) * .3;\n\t\n\tfloat r = mod( floor(uv.x-iTime) + floor(uv.y), 2.);\n\t\n\tfragColor = vec4(r);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 231]]}
{"id": "4ddGzj", "name": "PS3 XBM attempt 01", "author": "jabudcha", "description": "Based on: https://www.shadertoy.com/view/Xlj3Rm\nI wanted to make it look closer to how the PS3 menu looks :)", "tags": ["waves", "sine", "menu", "ps3", "playstation", "xbm"], "likes": 8, "viewed": 612, "published": "Public", "date": "1450914870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 0.4;\nconst float widthFactor = 2.0;\n\nvec3 calcSine(vec2 uv, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent, bool dir)\n{\n    float angle = iTime * speed * frequency + (shift + uv.x) * 0.75;\n    \n    float y = sin(angle) * amplitude + offset;\n    float clampY = clamp(0.0,y,y);\n    float diffY = y - uv.y;\n    \n    float dsqr = distance(y,uv.y);\n    float scale = 1.0;\n    \n    if(dir && diffY > 0.0)\n    {\n        dsqr = dsqr * 4.0;\n    }\n    else if(!dir && diffY < 0.0)\n    {\n        dsqr = dsqr * 4.0;\n    }\n    \n    scale = pow(smoothstep(width * widthFactor, 0.0, dsqr), exponent);\n    \n    return min(color * scale, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    float t1 = (sin(iTime/20.0) / 3.14) + 0.2;\n\tfloat t2 = (sin(iTime/10.0) / 3.14) + 0.2;\n    \n    color += calcSine(uv, 0.20, 0.2, 0.0, 0.5,  vec3(0.5, 0.5, 0.5), 0.1, 15.0,false);\n    color += calcSine(uv, 0.40, 0.15, 0.0, 0.5, vec3(0.5, 0.5, 0.5), 0.1, 17.0,false);\n    color += calcSine(uv, 0.60, 0.15, 0.0, 0.5, vec3(0.5, 0.5, 0.5), 0.05, 23.0,false);\n    \n    color += calcSine(uv, 0.26, 0.07, 0.0, 0.3, vec3(0.5, 0.5, 0.5), 0.1, 17.0,true);\n    color += calcSine(uv, 0.46, 0.07, 0.0, 0.3, vec3(0.5, 0.5, 0.5), 0.05, 23.0,true);\n    color += calcSine(uv, 0.58, 0.05, 0.0, 0.3, vec3(0.5, 0.5, 0.5), 0.2, 15.0,true);\n\n    color.x += t1 * (1.0-uv.y);\n\tcolor.y += t2 * (1.0-uv.y);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 222, 222, 733], [735, 735, 792, 792, 1594]]}
{"id": "4dtGRj", "name": "DOT02 - Sun", "author": "Makio64", "description": "Sun", "tags": ["dotcolorcircleabstract"], "likes": 1, "viewed": 162, "published": "Public", "date": "1450868940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rx = iResolution.x/iResolution.y;\n\nvec3 color(vec3 col, vec2 center, float radius, vec2 uv){\n    float d = distance(vec2(center.x*rx,center.y),uv);\n    float v = smoothstep( 0., radius, d );\n    return col * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //base\n\tvec2 uv = fragCoord.xy/iResolution.yy;\n\tvec3 col = vec3(.5);\n    vec3 col2 = vec3(0.5);\n    \n    //push somecolor on it\n    col2 += .9*color(vec3(.3,abs(sin(iTime))*.4,.5),vec2(.5,.6),.6, uv);\n    col2 += .9*color(vec3(abs(cos(iTime/3.))*.5,.2,.2), vec2(sin(iTime/2.)*.3+.5,cos(iTime)*.5+.6), 1., uv);\n    col2 += 1.8*color(vec3(.45,abs(cos(iTime/3.))*.05+.4,.15), vec2(.7,.5), 1.2, uv);\n    col2 += .6*color(vec3(.2,.2,.15), vec2(cos(iTime/2.),.7), 1.2, uv);\n    \n    //basic\n    col += col2*.5;\n    col *= col/2.;\n\tfragColor = vec4(col,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 218], [220, 220, 277, 288, 839]]}
{"id": "4dtGWM", "name": "Arlo", "author": "iq", "description": "Arlo, from Pixar's movie The Good Dinosaur, simplified and remade as a procedural distance field. I'm using ray differentials to do heightmap and texture filtering without edge artifacts. Video [url]https://www.youtube.com/watch?v=yMpG6qEb8js[/url]", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf"], "likes": 102, "viewed": 18522, "published": "Public API", "date": "1450089159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// Needless to say this is pure fan-art. While I did work in the film\n// a few years before I made this shader, I did not work on the\n// character Arlo (rather I worked on the environments), and I didn't\n// use any of Pixar's assets to make this shader. In fact, I modeled\n// Arlo's SDF here in Shadertoy directly as I always do, eyeballing\n// the proportions and colors from memory and by looking at online\n// posters of the film.\n\n// The shader uses ray differentials to do proper texture filtering,\n// more information here:\n// http://www.iquilezles.org/www/articles/filteringrm/filteringrm.htm\n\n\n// https://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n\treturn vec2(-b - h, -b+h);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n// https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n// https://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n#define ZERO (min(iFrame,0))\n\n//---------------------------------------------------------------------------\n\n// https://iquilezles.org/www/articles/biplanar/biplanar.htm\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 g1, in vec3 g2 )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = textureGrad( sam, p.yz, g1.yz, g2.yz );\n\tvec4 y = textureGrad( sam, p.zx, g1.zx, g2.zx );\n\tvec4 z = textureGrad( sam, p.xy, g1.xy, g2.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\n// http://www.iquilezles.org/www/articles/texture/texture.htm\nvec4 textureImproved( sampler2D tex, in vec2 res, in vec2 uv, in vec2 g1, in vec2 g2 )\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\n\tuv = (uv - 0.5)/res;\n\treturn textureGrad( tex, uv, g1, g2 );\n}\n\n//---------------------------------------------------------------------------\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv  = vec3(0.0,0.0,1.0);\n    vec3  uu  = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n//---------------------------------------------------------------------------\n\nvec2 leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float d3 = b.x - 0.15;\n    b = sdSegment( p, pb, pc );\n    d3 = smin( d3, b.x - 0.15, 0.1 );\n\n    // knee\n    float d4 = sdEllipsoid( p, pb+vec3(-0.02,0.05,0.0), vec3(0.14) );\n    //d4 -= 0.01*abs(sin(50.0*p.y));\n    d4 -= 0.015*abs(sin(40.0*p.y));\n    d3 = smin( d3, d4, 0.05 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    // space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    // shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n    \n    // muslo\n    d4 = sdEllipsoid( p, pa+vec3(0.0,0.2,-0.1*l), vec3(0.35)*m );\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\n\n// make all these zero for the rest position\nconst float headOffCenter = 0.5;\nconst vec3  headAngle = vec3(-0.2,-0.4,1.6);\n\nvec3 headTransform( in vec3 p )\n{\n    const vec3 ce = vec3(-2.6,1.7,headOffCenter);\n    \n    p -= ce;\n    p.xy = mat2(cos(headAngle.x),sin(headAngle.x),-sin(headAngle.x),cos(headAngle.x))*p.xy;\n    p.yz = mat2(cos(headAngle.y),sin(headAngle.y),-sin(headAngle.y),cos(headAngle.y))*p.yz;\n    p.xz = mat2(cos(headAngle.z),sin(headAngle.z),-sin(headAngle.z),cos(headAngle.z))*p.xz;\n    p += ce;\n    p.z -= headOffCenter;\n    \n    return p;\n}\n\nvec2 mapArlo( vec3 p )\n{\n// bounding volumes\n//res.x = min(res.x,length(p-vec3(-0.05,0.45,0.2))-3.5);\n//res.x = min(res.x,sdLine(p,vec3(-1.5,0.65,0.4),vec3(1.3,-0.7,0.2)).x-2.28);\n\n\n    // body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    //neck wrinkles\n    float r = length(p-vec3(-1.2,0.2,0.0));\n    d -= 0.05*abs(sin(35.0*r))*exp(-7.0*abs(r)) * clamp(1.0-(p.y-0.3)*10.0,0.0,1.0);\n\n    // tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    // neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,headOffCenter), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n\t}\n\n    float dn;\n    // front-left leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    // back-left leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // front-right leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // back-right leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n        \n    // head\n    p = headTransform(p);\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdSegment( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    // mouth\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdSegment( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n        \n    d3 = smin( d3, d4, 0.1 );\n        \n    // mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    // brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n    // eye wholes\n    d4 = sdEllipsoid( s, vec3(-2.79,2.36,0.04), vec3(0.12,0.15,0.15) );\n    d3 = smax( d3, -d4, 0.025 );    \n        \n    // nose holes    \n    d4 = sdEllipsoid( s, vec3(-3.4,2.17,0.09), vec3(0.1,0.025,0.025) );\n    d3 = smax( d3, -d4, 0.04 );    \n        \n    d = smin( d, d3, 0.02 );\n    }\n    vec2 res = vec2(d,0.0);\n    \n    // eyes\n    float d4 = sdSphere( s, vec3(-2.755,2.36,0.045), 0.16 );\n    if( d4<res.x ) res = vec2(d4,1.0);\n    \n    float te = textureLod( iChannel0, 3.0*p.xy, 0.0 ).x;\n    float ve = normalize(p).y;\n    res.x -= te*0.01*(1.0-smoothstep(0.6,1.5,length(p)))*(1.0-ve*ve);\n    \n    if( dn<res.x )  res = vec2(dn,3.0);\n\n    return res;\n}\n\nvec2 legSimple( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.15;// - 0.2*b.y;\n    float d3 = b.x - tr;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.15;// - 0.2*b.y;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    // paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    // nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    // space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    // shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\nfloat mapArloSimple( vec3 p )\n{\n    // body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    // tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    // neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n    //d = min(d,d3);\n\t}\n\n    float dn;\n    // front-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    // back-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // front-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    // back-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \n    // head\n    p = headTransform(p);\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdSegment( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    // mouth\n    //l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdSegment( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n            \n    d3 = smin( d3, d4, 0.1 );\n\n    // mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    // brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n    d = smin( d, d3, 0.01 );\n    }\n    \n    return min(d,dn);\n}\n\nvec3 drddx, drddy;\n\nvec2 mapTerrain( vec3 p, float t )\n{\n    float h = -2.0+0.03;\n\n    h += 5.0*textureImproved( iChannel2, iChannelResolution[2].xy, 0.0004*p.xz, 0.0004*t*drddx.xz, 0.0004*t*drddy.xz ).x;\n    \n    float di = smoothstep(100.0,500.0,length(p.xz) );\n    h += 2.0*di;\n    h *= 1.0 + 3.0*di;\n\n\tconst float stonesClip = 100.0;\n    if( (p.y-h)<0.5 && t<stonesClip )\n    {\n        float at = 1.0-smoothstep( stonesClip/2.0, stonesClip, t );\n        float gr = textureGrad( iChannel2, 0.004*p.xz, 0.004*t*drddx.xz, 0.004*t*drddy.xz ).x;\n        float pi = textureGrad( iChannel0, 0.400*p.xz, 0.400*t*drddx.xz, 0.400*t*drddy.xz ).x;\n            \n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        h += at*(1.0-gr)*0.15*pi;\n        h += at*0.1*textureGrad( iChannel2, 0.04*p.xz, 0.04*t*drddx.xz, 0.04*t*drddy.xz ).x;\n    }\n\n    float d = 0.8*(p.y-h);\n    \n    return vec2(d,2.0);\n}\n\nfloat mapTotal( in vec3 pos )\n{\n    float d1 = mapArlo( pos ).x;\n    float d2 = mapTerrain( pos, length(pos) ).x;\n    return min(d1,d2);\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTotal( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapTotal( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapTotal( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapTotal( pos + e.xxx ) );\n#else\n    // trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapTotal(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\nfloat calcOcclusionArlo( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapArlo( pos + h*dir ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat calcOcclusionTerrain( in vec3 pos, in vec3 nor, float t )\n{\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapTerrain( pos + h*dir, t ).x);\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadowArlo( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    \n    // check bounding volume first\n    vec2 bv = sphIntersect( ro, rd, vec4(-0.05,0.45,0.2,3.5) );\n    if( bv.y>0.0 )\n    {\n        float t = 0.01;\n        if( bv.x>0.0 ) t=max(t,bv.x);\n        for( int i=0; i<32; i++ )\n        {\n            float h = mapArloSimple(ro + rd*t );\n            res = min( res, k*h/t );\n            t += clamp( h, 0.04, 0.5 );\n\t\t    if( res<0.01 || t>bv.y) break;\n        }\n        res = smoothstep(0.0,1.0,res);\n    }\n    return res;\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadowTerrain( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.1;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapTerrain(pos, length(pos)).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.05, 10.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return smoothstep(0.0,1.0,res);\n}\n\n// https://iquilezles.org/www/articles/filteringrm/filteringrm.htm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 rdx, in vec3 rdy )\n{\n    const vec3 sunDir = normalize( vec3(0.1,0.05,0.2) );\n    const float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    float mateK = 0.0;\n    float mateN = 16.0;\n    float focc = 1.0;\n    \n    // derivatives\n    vec3 dposdx = t*drddx;\n    vec3 dposdy = t*drddy;\n    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n    if( m<0.5 ) // arlo\n    {\n        mateD = vec3(0.05,0.2,0.04)*0.7;\n        mateS = vec3(2.0,1.0,1.0)*0.5;\n    \n        // back\n        float pz = smoothstep(0.0,1.0,max(0.0,pos.y-0.0));\n        float pp = smoothstep( 0.6, 1.6, sin(pos.x*18.0) + pz*1.5 );\n        pp *= 1.0-smoothstep(0.1,1.5,length(pos-vec3(0.0,1.0,0.0)));\n        mateD = mix( mateD, vec3(0.05,0.2,0.08)*0.54, pp );         \n    \n        // nose\n        mateD = mix( mateD, vec3(0.13,0.21,0.04)*0.7,1.0-smoothstep(0.0,0.5,length(pos-vec3(-3.45,2.15,0.0))));\n\n        // belly\n        mateD = mix( mateD, vec3(0.16,0.22,0.10)*0.55,smoothstep(0.5,1.0,-nor.y)*(1.0-smoothstep(0.9,1.2,length(pos))));\n\n        // neck\n        vec2 b = sdSegment( pos, vec3(-0.9,-0.3,0.0), vec3(-2.6,1.7,0.0) );\n        float tr = 0.3;// - 0.25*b.y;\n        float d3 = b.x - tr;\n        float bn = 1.0-smoothstep(0.05,0.15,d3);\n        bn *= smoothstep(0.0,0.5,-nor.y);\n        bn *= 1.0-smoothstep(0.7,1.0,b.y);\n        mateD = mix( mateD, vec3(0.1,0.23,0.07)*0.7,bn);\n\n        vec3 tc = texcube( iChannel1, 0.2*pos, nor, 4.0, 0.2*dposdx, 0.2*dposdy ).xyz;\n        mateD *= 0.7+0.6*tc*tc;\n\n        float te = texcube( iChannel0, 2.0*pos, nor, 4.0, 2.0*dposdx, 2.0*dposdy ).x;\n        mateD *= 0.9 + 0.1*te;    \n    \n        mateK = 0.75*(0.5+0.5*tc.x*te);\n        \n        mateD.z += 0.05*(texcube( iChannel1, 0.025*pos, nor, 4.0, 0.025*dposdx, 0.025*dposdy ).x-0.5);\n    }\n\telse if( m<1.5 ) // eyes\n    {\n        vec3 uvw = headTransform(pos);\n        mateD = vec3(0.2,0.2,0.2)*0.7;\n        mateK = 2.0;\n        mateS = vec3(0.4);\n        mateN = 128.0;\n        vec3 cen = vec3(-2.755,2.36,0.1*sign(uvw.z));\n        vec3 dir = normalize(uvw-cen);\n        vec3 view = vec3(-1.0,-0.1,0.1);//normalize( ro-(cen) );\n        float d = dot( dir, view ); \n        \n        float p = 1.0-smoothstep( 0.82, 0.83, d );\n        mateD *= p;\n        mateS *= p;\n        float r  = pow(clamp( (d-0.83)/(1.0-0.83),0.0,1.0),2.0);\n        \n        float br = 3.5*pow(clamp(dot( nor, view ),0.0,1.0),32.0);\n        mateD = mix( mateD, vec3(0.03,0.015,0.0)*2.5*(1.0+br), smoothstep(0.0,0.05,r) );\n        mateD = mix( mateD, vec3(0.00,0.000,0.0), smoothstep(0.5,0.60,r) );\n        \n        float ff = smoothstep( 0.0, 0.1, -uvw.x-2.75 );\n        mateD *= ff;\n        mateS *= ff;\n        mateK *= ff;\n    }\n\telse if( m<2.5 ) // terrain\n    {\n        mateD = vec3(0.1,0.05,0.02);\n        mateD = pow( textureGrad( iChannel1, 0.3*pos.xz, 0.3*dposdx.xz, 0.3*dposdy.xz ).xyz, vec3(1.5))*0.3*vec3(1.1,1.0,0.9);\n        mateK = 1.0;\n        mateS = vec3(0.0,0.0,0.0);\n        focc = textureGrad( iChannel0, 0.5*pos.xz, 0.5*dposdx.xz, 0.5*dposdy.xz ).x;\n        \n        // grass        \n        float gr = textureGrad( iChannel2, 0.004*pos.xz, 0.004*dposdx.xz, 0.004*dposdy.xz ).x;\n        float pi = textureGrad( iChannel0, 0.400*pos.xz, 0.400*dposdx.xz, 0.400*dposdy.xz ).x;\n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        float hi = smoothstep( 0.85, 1.0, nor.y )*gr;//iq\n        mateD = mix( mateD, vec3(0.25,0.14,0.0)*0.4*(0.75+0.5*pi), hi );\n        focc = mix( focc, 1.0, hi );\n        mateK *= 1.0-hi;\n        \n        mateD *= 0.9;\n    }\n\telse //if( m<3.5 ) // nails\n    {\n        mateD = vec3(0.12,0.12,0.05)*1.3;\n        mateK = 0.0;\n        mateS = vec3(0.0,0.0,0.0);\n        float gr = texcube( iChannel2, 0.8*pos*vec3(1.0,0.2,1.0), nor, 4.0, 0.8*dposdx*vec3(1.0,0.2,1.0), 0.8*dposdy*vec3(1.0,0.2,1.0) ).x;\n        mateD *= 0.6 + 0.8*gr;\n    }    \n    \n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = min(calcOcclusionArlo(pos,nor),\n                    calcOcclusionTerrain(pos,nor,t) )*focc;\n        \n\n    vec3 col = vec3(0.0);\n    // sun\n    {\n    float dif = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    if( dif>0.0 )\n    {\n        dif *= min( calcShadowArlo( pos, sunDir, 32.0 ),\n                    calcShadowTerrain( pos, sunDir, 32.0 ) );\n    }\n    dif = clamp(dif, 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n    float sli = 0.04+0.96*pow(clamp(1.0-dot(hal,sunDir),0.0,1.0),5.0);\n    col += mateD*4.0*vec3(1.1,0.7,0.3)*dif;\n    col +=      12.0*vec3(1.0,0.9,0.8)*dif*pow(spe,mateN)*mateK*sli;\n    // sss\n    col += mateD*10.0*fre*(0.2+0.8*dif*occ)*mateS;\n    }\n    \n    // sky dome\n    {\n    float dif = occ*(0.5+0.5*nor.y);\n    float spe = smoothstep( -0.2, 0.2, reflect( rd, nor ).y );\n    float sli = 0.04+0.96*pow(fre,5.0);\n    col += mateD*5.4*vec3(0.2,0.6,1.3)*dif;\n    col +=       3.0*vec3(0.3,0.4,1.0)*dif*mateK*spe*sli*occ;\n    }\n    \n    // ground bounce\n    {\n    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n    col += mateD*2.5*vec3(0.4,0.1,0.1)*bou*(0.5+0.5*occ);\n    }\n    \n    // back bounce\n    {\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    col += mateD*1.0*vec3(0.8,0.5,0.4)*bak*occ;\n    }\n\n    // fog\n    col = mix( col, vec3(0.4,0.5,0.8), 1.0-exp(-.0007*t));\n    \n    return col;        \n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0);\n    float maxdist = 1500.0;\n    \n    // Arlo\n    vec2 bv = sphIntersect( ro, rd, vec4(-0.05,0.45,0.2,3.5) );\n    if( bv.y>0.0 )\n    {\n        vec2 tmp;\n        float t = 8.0;\n        if( bv.x>0.0 ) t = max( t, bv.x );\n        for( int i=0; i<128; i++ )\n        {\n            vec3 p = ro + t*rd;\n            vec2 h = mapArlo( p );\n            tmp = vec2(t,h.y);\n            if( h.x<(0.0001*t) ||  t>bv.y ) break;\n            t += h.x*0.9;\n        }\n        if( t<bv.y )\n        {\n            maxdist = t;\n            res = tmp;\n        }\n    }\n        \n    // terrain\n    float tp = (55.0-ro.y)/rd.y;\n    {\n        if( tp>0.0 ) maxdist = min(maxdist,tp);\n        float t = 5.0;\n        vec2 tmp;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 p = ro + t*rd;\n            vec2 h = mapTerrain( p, t );\n            tmp = vec2(t,h.y);\n            if( h.x<(0.0001*t) || t>maxdist ) break;\n            t += h.x*0.75;\n        }\n\n        if( t<maxdist )\n        {\n            res = tmp;\n        }\n    }\n    \n    return res;\n}\n\nfloat cloud( in vec2 uv )\n{\n    uv = uv.yx;\n    \n    float f  = 0.5*texture( iChannel0, uv*1.0 ).x;\n          f += 0.3*texture( iChannel0, uv*2.1 ).x;\n          f += 0.2*texture( iChannel2, uv*0.5 ).x;\n          f += 0.1*texture( iChannel2, uv*1.1 ).x;\n    \n    return smoothstep(0.3,1.0,f);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    // sky\n    vec3 col = clamp(vec3(0.2,0.4,0.5)*1.3 - rd.y,0.0,1.0);\n    \n    // clouds\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n    vec2 uv = (ro+t*rd).xz;\n    float cl1 = cloud( .000051*uv );\n\tfloat cl2 = cloud( .000051*(uv+200.0*rd.xz));\n    vec3 ccol = mix( vec3(0.3,0.1,0.3)*0.55, vec3(1.5,0.4,0.1)*3.0, clamp(cl2-cl1,0.0,1.0) );\n    col = mix( col, ccol, cl1 );\n    }\n    // horizon\n    col = mix( col, vec3(0.4,0.5,0.6), exp(-abs(15.0*rd.y)) ) ;\n\n    vec2 tm = raycast( ro, rd );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, rdx, rdy );\n    }\n\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // camera\n    float an = 5.9 - 0.5*cos(0.07*(iTime-10.0));\n    vec3 ro = vec3(12.5*sin(an),0.45,12.5*cos(an));\n    vec3 ta = vec3(0.0,0.6,0.0);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, -0.05 );\n    vec3 rd = normalize( ca * vec3(p,-4.5) );\n\n    // ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-4.5) );\n    vec3 rdy = normalize( ca * vec3(py,-4.5) );\n    drddx = rdx - rd;\n    drddy = rdy - rd;\n\n    // render\n    vec3 col = render( ro, rd, rdx, rdy);\n\n    //float sun = clamp( 0.2 + 0.8*dot(rd,sunDir), 0.0, 1.0 );\n\t//col += vec3(0.4,0.3,0.2)*1.0*pow(sun,8.0);\n\n    // grade\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col);\n        \n    // vignette    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtGWM.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[1242, 1311, 1369, 1369, 1561], [1563, 1634, 1679, 1679, 1804], [1806, 1877, 1929, 1929, 1959], [1961, 2032, 2086, 2086, 2150], [2152, 2216, 2245, 2245, 2271], [2272, 2272, 2319, 2319, 2797], [2799, 2840, 2889, 2889, 3278], [3280, 3333, 3374, 3374, 3446], [3448, 3501, 3542, 3542, 3614], [3725, 3786, 3875, 3875, 4117], [4119, 4181, 4269, 4269, 4438], [4440, 4519, 4544, 4544, 4724], [4726, 4726, 4781, 4781, 4959], [4961, 5040, 5117, 5117, 6477], [6480, 6604, 6637, 6637, 7041], [7043, 7043, 7067, 7236, 10562], [10564, 10564, 10647, 10647, 11771], [11773, 11773, 11804, 11816, 14467], [14489, 14489, 14525, 14525, 15366], [15368, 15368, 15399, 15399, 15506], [15508, 15573, 15619, 15619, 16125], [16127, 16127, 16180, 16180, 16498], [16500, 16500, 16565, 16565, 16889], [16891, 16954, 17014, 17014, 17506], [17508, 17571, 17631, 17631, 17928], [17930, 17997, 18120, 18120, 18222], [18224, 18224, 18312, 18312, 23758], [23760, 23760, 23800, 23800, 24858], [24860, 24860, 24887, 24887, 25153], [25155, 25155, 25220, 25231, 25850], [25852, 25852, 25909, 25909, 26944]]}
{"id": "4lSGRR", "name": "Testshader B", "author": "ambi", "description": "Nice swirling colors", "tags": ["fractal", "colors"], "likes": 6, "viewed": 542, "published": "Public API", "date": "1451343146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Basic fractal by @paulofalcao\n// modified by ambi\n\nconst int maxIterations=7;//a nice value for fullscreen is 8\n\nfloat circleSize=1.0/(3.0*pow(2.0,float(maxIterations)));\n\n//generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n\tvec2 uv=iResolution.xy;uv=-.5*(uv-2.0*fragCoord.xy)/uv.x;\n    float pi = 3.14159265358979323846264;\n\n\t//global rotation and zoom\n\t//uv=rot(uv,iTime);\n    uv*=2.4;\n\t\n\t//mirror, rotate and scale 6 times...\n\tfloat s=0.3;\n    vec4 col=vec4(1.0,0.0,0.5,1.0);\n\tfor(int i=0;i<maxIterations;i++){\n\t\tuv=abs(uv)-s;\n\t\tuv=rot(uv,iTime);\n\t\ts=s/(1.6+sin(iTime*0.3)*0.3);\n        float m=float(i)*pi;\n        float cl=pow(length(vec2(0.5,0.5)-uv),0.2);\n        col=vec4((0.5+sin((m*1.0 + iTime)*2.337 +uv.x*m*5.0))*cl,\n                 (0.5+cos((m*2.3 + iTime)*1.000 +uv.y*m*5.0))*cl,\n                 (0.5+sin((m*0.5 + iTime)*3.995 -uv.x*m*5.0))*cl,1.0);\n\t}\n\t\n\t//draw a circle\n    float l=length(uv);\n\tfloat c=l-0.1>circleSize?0.0:pow(1.0-l*3.0,2.0);\t\n\n\tfragColor = vec4(c,c,c,1.0)*col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 201, 227, 227, 292], [294, 294, 350, 369, 1145]]}
{"id": "4s33R2", "name": "Xor - Pixel Noise 2", "author": "Xor", "description": "Here is another version of my Pixel Noise shader: https://www.shadertoy.com/view/Mls3zs\nUpdate 2021: Cleaned up the code a bit and added AA.", "tags": ["2d", "noise", "pixel", "xor"], "likes": 4, "viewed": 197, "published": "Public", "date": "1450730194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 3\n\nfloat hash(vec2 n)\n{\n \treturn fract(cos(n.x*.331+n.y*.845)*956.75);   \n}\nfloat fractal(vec2 n,float t)\n{\t\n    float ft = floor(t);\n    float total = 0.;\n    \n    for(float i = 0.;i<8.;i++)\n    {\n        float w = 1.-(i+ft-t)/7.;\n        total += (hash(floor(n/exp2(i+ft-t)+i+ft))-total)*w*w;\n    }\n \treturn total*total;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = fragCoord-iResolution.xy/2.;\n    float total = 0.;\n    for(int a = 0;a<AA*AA;a++)\n    {\n        vec2 c = center+vec2(a%AA,a/AA)/float(AA);\n        total += fractal(c/8.,iTime*.5);\n    }\n    total /= float(AA*AA);\n    \n\tfragColor = vec4(total);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 34, 34, 86], [87, 87, 118, 118, 335], [336, 336, 393, 393, 657]]}
{"id": "4s33Rj", "name": "Music MandelBox Colour", "author": "pixelbeast", "description": "Added color to an old shardertoty ", "tags": ["viz3dmusicfft"], "likes": 5, "viewed": 761, "published": "Public API", "date": "1451186481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Iain Melvin, 2015\n// fft distortions of mandlebox 3d, colour\n// with help from:\n// https://www.shadertoy.com/view/XsB3Rm  // Original Raymarch tutorial (iq)\n// https://www.shadertoy.com/view/ldSGRK  // for mandlebox formula (klems)\n// Raymarch tutorial: - iq/2013\n\n\nfloat mandel3D(vec3 z,float fft){\n  const float scale=3.5; //2.0; // -1.5\n  const float r=0.5; \n  const float f=1.125;\n  vec3 offset = z;\n  const int niter = 13;\n  float dr = 1.0;\n  for (int i=0;i<niter;i++){\n\t//fold\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n\t//warp\n\tfloat l = length(z);\n\tif (l<r){\n\t  z/=r*r;\n\t}else if (l<1.0){\n\t  z/=l*l;\n\t}\n\tz*=scale;\n\tdr = dr * abs(scale) + 1.0;\n\t// scale by fft\n\tfloat fft_scale = 1.0-(fft*0.34);\n\tz*=fft_scale;\n\t//dr = dr * fft_scale; // I think there is something to do here\n\tz+=offset;\n  }\n  float zr = length(z);\n  return zr / abs(dr);\n}\n\nvec2 map( in vec3 pos ) {\n    float d = length(pos);\n    float fft = 0.8*texture(iChannel0, vec2((d/32.0),0.3) )[0];\t\n\treturn vec2(mandel3D(pos*1.5,fft),fft);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){\n\tfloat precis = 0.015;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<120; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x; //dist to solid\n\t    m = res.y; //fft\n    }\n    if (t>maxd) { t=-0.5; m=0.0; }\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos ){\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// iq's smooth hsv to rgb\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec2 res = castRay(ro,rd,15.0);\n    float t = res.x; // dist to func\n\tfloat m = res.y; // fft intense at collision\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    if (t==-0.5) { nor=vec3(1.0,0.0,0.0); }\n\n\tcol = hsv2rgb(vec3(m*2.0,1.0,1.0)); // hue sat lum\n    \n    float ao = 1.0;\n\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\tfloat sh = 1.0;\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n    brdf += 2.20*dif*vec3(1.00,0.90,0.70);\n\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\tfloat spe = sh*pow(pp,16.0);\n\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n\n\treturn vec3( clamp(col,0.0,10.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = -55.0; //+ iTime;\n    \n    vec3 d = vec3(0.25*mo.x,0.25*mo.y,0.0);\n    \n    d.x += 5.5*(1.0-cos(0.6*iTime));\n    d.y += 2.5*(1.0-cos(0.05*iTime));\n    \n\t// camera\t\n\tvec3 ro = vec3( d.x, d.y, 6.0 );\n    vec3 ta = vec3( -0.0, -0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt( col );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 270, 303, 303, 844], [846, 846, 871, 871, 1006], [1008, 1008, 1062, 1062, 1401], [1403, 1403, 1434, 1434, 1655], [1657, 1683, 1709, 1709, 1865], [1867, 1867, 1906, 1906, 2917], [2919, 2919, 2976, 2976, 3668]]}
{"id": "4s33RX", "name": "Moon Rock", "author": "foxes", "description": "Procedural noised rock model with ray cast rendering.", "tags": ["procedural", "3d", "raymarching", "noise", "shadow", "moon", "rock", "reycast"], "likes": 15, "viewed": 1244, "published": "Public API", "date": "1451148250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pradius 1.3\n#define mradius 0.1\n#define iterations 20.0\n#define shadowit 10.0\n#define line 0.39\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\nfloat noise3( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + dot(p.yz,vec2(157.0,113.0));\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\n\nfloat heightMap(vec3 rad,float d)\n{\n    float iline=1.0/(1.0-line);\n    float a=noise3(rad*1.6)*0.885;\n    float na=a;\n    if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    if (abs(d-a)<0.2) {\n        na+=noise3(rad*8.0)*0.1;\n        a=na;\n        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    }\n    if (abs(d-a)<0.02) {\n        na+=noise3(rad*32.0)*0.01;\n        a=na;\n        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    }\n    if (abs(d-a)<0.01) a+=noise3(rad*128.0)*0.005;\n    return a;\n}\n\nvec3 distObj(vec3 pos,vec3 ray,float radius,float minr)\n{\n    float b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    float sta=radius-minr;\n    float invm=1.0/sta;\n    float rq=radius*radius;\n    vec3 dist=ray*10000.0;\n    if(c <rq)\n    {\n        vec3 r1 = (ray*(abs(b)-sqrt(rq-c))-pos);\n\t\tfloat maxs=abs(dot(r1,ray));//*0.5;\n        if (c<minr*minr) {\n            vec3 r2 = (ray*(abs(b)-sqrt(minr*minr-c))-pos);\n            maxs=maxs-abs(dot(r2,ray));\n        }// else {\n            maxs*=0.5;\n        //}\n        float len;\n        float h;\n\n        for (float m=0.0; (m<iterations); m+=1.0) {\n            len=length(r1);\n            vec3 d=r1/len;\n            h=sta*heightMap(d,(len-minr)*invm)+minr;\n            if (abs(h-len)<0.0001) break;\n            maxs=abs(maxs);\n            if (len<h) maxs=-maxs;\n            r1+=ray*maxs*abs(len-h);\n            maxs*=0.99;\n        }\n        if (len<h+0.1) dist=r1+pos;\n    }\n    return dist;\n}\n\nfloat noiseSpace(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.0625*1.5;\n    float d2=zoom/d;\n\n\tfloat rq=r*r;\n    float l1=sqrt(abs(r-c));\n    r1= (ray*(b-l1)-pos)*mr;\n\n    r1*=d2;\n    s+=abs(noise3(vec3(r1+subnoise))*d);\n    s+=abs(noise3(vec3(r1*0.5+subnoise))*d*2.0);\n    s+=abs(noise3(vec3(r1*0.25+subnoise))*d*4.0);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n\tfloat mx = iMouse.x>0.0?iMouse.x/iResolution.x*10.0:0.5;\n    float my = iMouse.y>0.0?iMouse.y/iResolution.y*4.0-2.0:0.0;\n    vec2 rotate = vec2(mx+iTime*0.02,my);\n\n    vec2 sins=sin(rotate);\n    vec2 coss=cos(rotate);\n    mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    \n    \n    float time=iTime*1.0;\n\t\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 ray1 = normalize(vec3(p+vec2(0.0,0.01),2.0));\n    vec3 ray2 = normalize(vec3(p+vec2(0.01,0.0),2.0));\n    vec3 pos = vec3(0.0,0.0,3.0);\n    \n    vec3 light=vec3(-30.0,0.0,-30.0);\n    \n    vec3 n1=distObj(pos*mr,ray1*mr,pradius,mradius);\n    vec3 n2=distObj(pos*mr,ray2*mr,pradius,mradius);\n    vec3 rt=distObj(pos*mr,ray*mr,pradius,mradius);\n    \n    vec3 lightn=normalize(light*mr-rt);\n    vec3 sd=distObj((pos-light)*mr,-lightn,pradius,mradius);\n    \n    float shadow=1.0-clamp(pow(length(sd+light*mr-rt),2.0)*200.0,0.0,1.0);\n    vec3 n=normalize(cross(n1-rt,n2-rt));\n    \n    //fragColor = vec4(vec3(shadow),1.0);\n    fragColor.a = 1.0;\n    \n    if (length(n1)>100.0 || length(n2)>100.0 || length(rt)>100.0) fragColor.a=0.0;\n    \n    float s4=noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0));\n    if (fragColor.a<1.0) {\n        s4=pow(s4*1.8,5.7);\n        fragColor=vec4((mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(0.5),pow(s4*2.0,0.1))*s4*0.2),1.0);\n    } else {\n        rt=rt-pos*mr;\n        float fd=(length(rt)-mradius)/(pradius-mradius);\n        float c=dot(n,lightn)*shadow;\n        if (fd<line) {\n        \tfragColor.xyz = mix(vec3(0.21,0.19,0.0),vec3(1.0,0.99,1.0),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1)*c;\n        } else {\n            fragColor.xyz = mix(mix(vec3(1.0,1.0,0.9),vec3(0.8,0.79,0.7),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1),vec3(1.0),pow(fd+0.5,10.0))*c;\n        }\n    }\n    \n    fragColor = min( vec4(1.0), fragColor );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 204, 204, 240], [241, 241, 265, 265, 512], [514, 514, 549, 549, 1041], [1043, 1043, 1100, 1100, 1994], [1996, 1996, 2074, 2074, 2472], [2474, 2474, 2531, 2531, 4526]]}
{"id": "4s33W7", "name": "Paratrooper", "author": "pimuri", "description": "Trying to imitate an old game. \nYes, the code is fugly. \nNot sure if we could add mouse control for shooting and perhaps some actual paratroopers.", "tags": ["game", "80s", "unfinished", "paratrooper"], "likes": 1, "viewed": 209, "published": "Public", "date": "1450643517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// color def\n#define color_transparent vec4(0.0, 0.0, 0.0, 0.0)\n#define color_white vec4(1.0, 1.0, 1.0, 1.0)\n#define color_pink vec4(1.0, 0.3137, 1.0, 1.0)\n#define color_light_blue vec4(0.3137, 1.0, 1.0, 1.0)\n\n\n// ground def\n#define ground_start vec2(-2.0, 0.85)\n#define ground_end vec2(2.0,  0.85)\n\n\n// turret base def\n#define turret_base_width 0.35\n#define turret_base_height 0.3\n#define turret_base_center vec2(0.0, - 0.7)\n\n// turret barrel def\n#define tb_mount_point vec2(0.0, -0.51)\n#define tb_fov 90.0\n\n// tb_c_radius = turret barrel circle radius\n#define tb_c_radius 0.0010\n\n// tb_a_s = turret barrel angle speed\n#define tb_a_s 0.014\n\n#define tb_length 50\n\n// turret base mount def  (tbm)\n#define tbm_center vec2(0.0, - 0.51)\n#define tbm_width 0.1\n#define tbm_height 0.08\n\n\n// stolen from https://www.shadertoy.com/view/Xd2XWR (and modified for my own purposes)\n// who got it from Iigo Quilez (iq)\n// Thanks!\nvec4 line(vec2 p,vec2 start,vec2 end, vec4 currColor, vec4 newColor, bool mixColors )\n{\n    vec2 pa = -p - start;\n    vec2 ba = end - start;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    if(mixColors) {\n\t\treturn clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0) * (currColor + newColor) ;    \n    }\n    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0) * newColor;\n}\n\nvec4 rect(vec2 p, vec2 start, vec2 end, vec4 currColor, vec4 newColor, bool mixColors)\n{\n\tvec2 minPoint, maxPoint;\n    \n    minPoint.x = min(start.x, end.x);\n    minPoint.y = min(start.y, end.y);\n    maxPoint.x = max(start.x, end.x);\n    maxPoint.y = max(start.y, end.y);\n   \n    if(p.x > minPoint.x && p.x < maxPoint.x && p.y > minPoint.y && p.y < maxPoint.y) {\n        if(mixColors)\n        {\n        \treturn currColor + newColor;\n        }\n    \treturn newColor;\n    }\n    return currColor;\n}\n\nvec4 circle(vec2 p, vec2 pos, float radius, vec4 currColor, vec4 newColor, bool mixColors)\n{\n    // x^2 + y^2 < radius\n    \n    float x2 = (p.x - pos.x) * (p.x - pos.x);\n    float y2 = (p.y - pos.y) * (p.y - pos.y);\n        \n    if(x2 + y2 < radius) {\n        if(mixColors)\n        {\n        \treturn currColor + newColor;\n        }\n    \treturn newColor;\n    \n    }\n    return currColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cba = 0.0; // current barrel angle\n    \n    cba = sin(iTime) * tb_fov * tb_a_s; // tb field of view / tb angle speed\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // ground\n    fragColor = line(p, ground_start, ground_end, fragColor, color_light_blue, false);\n    \n    // turret base\n    fragColor = rect(p, vec2(turret_base_center.x - turret_base_width/2.0,turret_base_center.y - turret_base_height/2.0), vec2(turret_base_center.x + turret_base_width/2.0,turret_base_center.y + turret_base_height/2.0), fragColor, color_white, false);\n    \n    vec2 bsp = vec2( 0.0, tbm_center.y + 0.04); // barrel start point\n    \n    // turret barrel\n    for(int i = 1; i <= tb_length; i++)\n    {\n    \tfragColor = circle(p, vec2(bsp.x + float(i) * sin(cba)*tb_c_radius*2.0, bsp.y + float(i) * cos(cba)*tb_c_radius*2.0), tb_c_radius, fragColor, color_light_blue, false);\n    }\n    \n    \n    // turret base mount\n    fragColor = rect(p, vec2(tbm_center.x - tbm_width/2.0, tbm_center.y - tbm_height/2.0), vec2( tbm_center.x + tbm_width/2.0, tbm_center.y + tbm_height/2.0), fragColor, color_pink, false);\n    fragColor = circle(p, bsp, 0.0023, fragColor, color_pink, false);\n    fragColor = circle(p, bsp, 0.00023, fragColor, color_light_blue, false);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 920, 1007, 1007, 1327], [1329, 1329, 1417, 1417, 1823], [1825, 1825, 1917, 1943, 2213], [2217, 2217, 2274, 2274, 3607]]}
{"id": "4s33zf", "name": "Over the Moon", "author": "BigWIngs", "description": "Moonlit winter scene. Hope you like it!", "tags": ["2d", "tree", "stars", "moon", "night", "snow", "winter"], "likes": 130, "viewed": 5648, "published": "Public", "date": "1451268517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Over the Moon\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// Facebook: https://www.facebook.com/groups/theartofcode\n//\n// Music: A Miserable Heart - Marek Iwaszkiewicz\n// Soundcloud: https://soundcloud.com/shyprince/a-miserable-heart-piano\n//\n// I made a video tutorial about this effect which you can see here:\n// https://youtu.be/LLZPnh_LK8c\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,b) S(x, x+b, z)*S(y+b, y, z)\n#define saturate(x) clamp(x,0.,1.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n#define MOONPOS vec2(1.3, .8)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n    // From Dave Hoskins\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a) / (b-a)) * (d-c) + c;\n}\n\nfloat within(float a, float b, float t) {\n\treturn (t-a) / (b-a); \n}\n\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n\tfloat y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    \n    float horizontal = B(left, right, uv.x, blur);\n    float vertical = B(bottom.z, top.z, uv.y, blur);\n    return horizontal*vertical;\n}\n\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n\tuv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);\n    \n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n   \n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    \n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    \n    return col;\n}\n\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\n\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n\tuv *= d;\n    float x = uv.x*PI*f+p;\n    float c = getheight(x)*a+y;\n    \n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    \n    float e = fwidth(uv.y);\n    \n    vec4 col = vec4(S(c+e, c-e, uv.y));\n    //col.rgb *= mix(0.9, 1., abs(uv.y-c)*20.);\n    \n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    \n    x = fract(x);\n    \n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus+d*.1);\n    //col += pineCol;\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);\n    \n    return saturate(col);\n}\n\nvec4 gradient(vec2 uv) {\n    \n\tfloat c = 1.-length(MOONPOS-uv)/1.4;\n    \n    vec4 col = vec4(c);\n    \n    return col;\n}\n\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n\tfloat dist = length(uv-pos);\n    return S(radius+blur, radius-blur, dist);\n}\n\nvec4 moon(vec2 uv) {\n   \tfloat c = circ(uv, MOONPOS, .07, .001);\n    \n    c *= 1.-circ(uv, MOONPOS+vec2(.03), .07, .001)*.95;\n    c = saturate(c);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.8;\n    \n    return col;\n}\n\nvec4 moonglow(vec2 uv, float foreground) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n    return col;\n}\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*.05;\n     \n    vec2 bgUV = uv*vec2(iResolution.x/iResolution.y, 1.);\n    vec4 col = gradient(bgUV)*.8;\n    col += moon(bgUV);\n    col += stars(uv, t);\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.);\n        trees = mix(trees, layer, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    col = mix(col, trees, trees.a);\n    \n    col += moonglow(bgUV, 1.);\n    col = saturate(col);\n    \n    vec4 foreground = landscape(uv, .02, t, 3., .0, -0.04, 1., .1);\n    foreground.rgb *= vec3(.1, .1, .2)*.5;\n    \n    col = mix(col, foreground, foreground.a);\n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "llf3WB", "previewfilepath": "https://soundcloud.com/shyprince/a-miserable-heart-piano", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/shyprince/a-miserable-heart-piano", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s33zf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[695, 805, 828, 853, 965], [967, 986, 1008, 1008, 1124], [1126, 1126, 1184, 1184, 1223], [1225, 1225, 1266, 1266, 1292], [1294, 1294, 1353, 1353, 1623], [1625, 1625, 1675, 1675, 2353], [2355, 2355, 2381, 2381, 2450], [2452, 2452, 2547, 2547, 3270], [3272, 3272, 3296, 3296, 3391], [3393, 3393, 3450, 3450, 3528], [3530, 3530, 3550, 3550, 3746], [3748, 3748, 3790, 3790, 3906], [3908, 3908, 3939, 3939, 4289], [4291, 4291, 4348, 4348, 5299]]}
{"id": "4s3GD8", "name": "TruchetFlipPlanes", "author": "jt", "description": "Perspective projection of changing truchet-tiles, based on Fabrice's compactification of my TruchetFlip\n[url]https://www.shadertoy.com/view/4st3R7[/url]\n[url]https://www.shadertoy.com/view/lst3R7[/url]\n[url]https://www.shadertoy.com/view/Xd33W8[/url]", "tags": ["truchet", "perspective", "planes"], "likes": 10, "viewed": 182, "published": "Public", "date": "1449167887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Truchet Flip Planes - written 2015 by JT, compactified & documented by FabriceNeyret2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// based on\n// https://www.shadertoy.com/view/Xd33W8 Checkers Perspective Planes (JT)\n// https://www.shadertoy.com/view/4st3R7 TruchetTilesFlip (JT)\n// https://www.shadertoy.com/view/lst3R7 TruchetTilesFlip2 (FabriceNeyret2)\n\n#define R(s) texture(iChannel0, s + t/1e3).x  // random generator\n#define S(v) smoothstep(.45,.55, len(v))        // use either len() or length()\n\nfloat t,s,d;\n\nfloat len(vec2 v) {                             // roundness tuning. richer than length(v)\n    float w = .2 + 1.6*abs(fract(t/16.)-.5);    // 1/w in [1/5 .. 1]\n    v = pow(v, vec2(1./w));\n    return pow(v.x+v.y, w);\n}\n\nvoid mainImage( out vec4 O,  vec2 I ) {\n    t = iTime;\n\n    vec2 w = iResolution.xy;\n    I = (I+I-w)/w.y;\n    I /= vec2(2, d=I.y) * abs(d) / 5.;\n    I.y += t;\n    w = ceil(I);\n    I.x *= s = sign( R(w/128.) - .5 );          // random flip (for orientation and coloring)\n    s *= 2.*mod(w.x+w.y,2.)-1.;                 // checkboard flip (for coloring)\n    O -= O -(s*S(I=fract(I))*S(1.-I) + .5-.5*s)*d*d;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3GD8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 563, 582, 653, 780], [782, 782, 821, 821, 1188]]}
{"id": "4s3GW8", "name": "[Test] Winding number", "author": "Ultraviolet", "description": "this shader computes the winding numbers.", "tags": ["testpolygon"], "likes": 5, "viewed": 226, "published": "Public", "date": "1449154572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926536;\n\n\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{\n    p = bbmin + mod(p-bbmin, 2.0*(bbmax - bbmin));\n    if(p > bbmax)\n    \tp = bbmax - (p - bbmax);\n    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\n\nvec2 normal(vec2 p0, vec2 p1)\n{\n    vec2 diff = p1 - p0;\n    return vec2(-diff.y, diff.x);\n}\n\nfloat PointSegDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    float s = 1.0;//sign(dot(p-p0, normal(p0, p1)));\n    vec2 d = p1 - p0;\n    \n    float t = dot(p - p0, d) / dot(d, d);\n\n    if(t > 1.0)\n        return length(p1 - p) * s;\n    if(t < 0.0)\n        return length(p0 - p) * s;\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return length(proj-p) * s;\n}\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    a = mod(a-PI, 2.*PI)-PI;\n    \n    return a;\n}\n\nfloat Winding(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float winding = 0.0;\n    \n    winding += angle(p0-p, p1-p);\n    winding += angle(p1-p, p2-p);\n    winding += angle(p2-p, p3-p);\n    winding += angle(p3-p, p0-p);\n    \n    return winding;\n    \n}\n    \nfloat PointPolyDistance(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float d = PointSegDistance(p, p0, p1);\n    d = min(d, PointSegDistance(p, p1, p2));\n    d = min(d, PointSegDistance(p, p2, p3));\n    d = min(d, PointSegDistance(p, p3, p0));\n\n    \n    float s = 1.0;\n    \n    if(Winding(p, p0, p1, p2, p3) > 0.5)\n        s = -1.0;\n    \n    return d * s;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 p0 = vec2(0.5, 0.5); p0 = p0 + p0*iTime*0.5; BoxReflect(p0, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p1 = vec2(1.0, 0.2); p1 = p1 + p1*iTime*0.5; BoxReflect(p1, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p2 = vec2(0.6, 0.8); p2 = p2 + p2*iTime*0.5; BoxReflect(p2, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p3 = vec2(1.2, 0.9); p3 = p3 + p3*iTime*0.5; BoxReflect(p3, vec2(0.0), vec2(ratio, 1.0));\n    float d = Winding(uv, p0, p1, p2, p3);\n    \n\tfragColor = vec4(max(d, 0.0), max(-d, 0.0), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3GW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 97, 97, 203], [205, 205, 266, 266, 346], [349, 349, 380, 380, 441], [443, 443, 493, 493, 792], [794, 794, 815, 815, 844], [846, 846, 877, 877, 965], [967, 967, 1026, 1026, 1224], [1230, 1230, 1299, 1299, 1591], [1595, 1595, 1652, 1652, 2247]]}
{"id": "4sc3Wn", "name": "Neontoy", "author": "Flyguy", "description": " A neon Shadertoy logo made using AutoCAD and converted to GLSL using C# and netDxf. \nThe font is a slightly modified version of Srfm_Neon by Srfm.", "tags": ["distancefield", "text", "neon"], "likes": 66, "viewed": 4016, "published": "Public API", "date": "1448935145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nfloat scale = 1.0 / 6.0;\n\nfloat epsilon = 1e-3;\nfloat infinity = 1e6;\n\n//Settings\n//Uses cheaper arcs for common sweep angles (90 & 180 degrees).\n#define USE_CHEAP_ARCS\n\n#define TEXT_COLOR   vec3(1.00, 0.20, 0.10)\n#define BORDER_COLOR vec3(0.05, 0.20, 1.00)\n\n#define BRIGHTNESS 0.004\n#define THICKNESS  0.002\n\n//Checks if a and b are approximately equal.\nbool ApproxEqual(float a, float b)\n{\n    return abs(a - b) <= epsilon;\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;  \n\tuv -= origin;\n    \n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n    #ifdef USE_CHEAP_ARCS\n        if(ApproxEqual(sweep, pi)) //180 degrees\n        {\n            float d = abs(length(uv) - radius) + step(uv.y, 0.0) * infinity;\n            d = min(d, min(length(uv - vec2(radius, 0)), length(uv + vec2(radius, 0))));\n            return d;\n        }\n        else if(ApproxEqual(sweep, pi/2.0)) //90 degrees\n        {\n            float d = abs(length(uv) - radius) + step(min(uv.x, uv.y), 0.0) * infinity;\n            d = min(d, min(length(uv - vec2(0, radius)), length(uv - vec2(radius, 0))));\n            return d;\n        }\n        else //Others\n        {\n            float offs = (sweep / 2.0 - pi);\n            float ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n            ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n            return distance(radius * vec2(cos(ang), sin(ang)), uv); \n        }\n    #else\n        float offs = (sweep / 2.0 - pi);\n        float ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n        ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n        return distance(radius * vec2(cos(ang), sin(ang)), uv);\n\t#endif\n}\n\nfloat dfLogo(vec2 uv)\n{\n\tfloat dist = infinity;\n\n\tdist = min(dist, dfLine(vec2(0.267,1.200), vec2(0.533,1.200), uv));\n\tdist = min(dist, dfLine(vec2(0.267,0.667), vec2(0.533,0.667), uv));\n\tdist = min(dist, dfLine(vec2(0.533,0.000), vec2(0.067,0.000), uv));\n\tdist = min(dist, dfLine(vec2(0.400,0.133), vec2(0.067,0.133), uv));\n\tdist = min(dist, dfLine(vec2(1.000,1.200), vec2(1.000,0.067), uv));\n\tdist = min(dist, dfLine(vec2(1.133,0.067), vec2(1.133,0.533), uv));\n\tdist = min(dist, dfLine(vec2(1.200,0.600), vec2(1.667,0.600), uv));\n\tdist = min(dist, dfLine(vec2(1.733,0.667), vec2(1.733,1.133), uv));\n\tdist = min(dist, dfLine(vec2(1.867,1.133), vec2(1.867,0.000), uv));\n\tdist = min(dist, dfLine(vec2(3.000,0.067), vec2(3.000,1.200), uv));\n\tdist = min(dist, dfLine(vec2(3.867,0.333), vec2(3.867,0.867), uv));\n\tdist = min(dist, dfLine(vec2(3.533,1.200), vec2(3.000,1.200), uv));\n\tdist = min(dist, dfLine(vec2(3.133,0.067), vec2(3.133,1.000), uv));\n\tdist = min(dist, dfLine(vec2(3.533,0.000), vec2(3.267,0.000), uv));\n\tdist = min(dist, dfLine(vec2(4.867,1.200), vec2(4.000,1.200), uv));\n\tdist = min(dist, dfLine(vec2(4.000,1.200), vec2(4.000,0.667), uv));\n\tdist = min(dist, dfLine(vec2(4.000,0.000), vec2(4.867,0.000), uv));\n\tdist = min(dist, dfLine(vec2(4.467,0.667), vec2(4.000,0.667), uv));\n\tdist = min(dist, dfLine(vec2(4.467,0.533), vec2(4.000,0.533), uv));\n\tdist = min(dist, dfLine(vec2(4.000,0.533), vec2(4.000,0.000), uv));\n\tdist = min(dist, dfLine(vec2(5.000,0.000), vec2(5.000,1.200), uv));\n\tdist = min(dist, dfLine(vec2(5.000,1.200), vec2(5.533,1.200), uv));\n\tdist = min(dist, dfLine(vec2(5.533,0.533), vec2(5.205,0.533), uv));\n\tdist = min(dist, dfLine(vec2(5.166,0.413), vec2(5.716,0.013), uv));\n\tdist = min(dist, dfLine(vec2(5.410,0.400), vec2(5.794,0.121), uv));\n\tdist = min(dist, dfLine(vec2(6.000,1.200), vec2(6.333,1.200), uv));\n\tdist = min(dist, dfLine(vec2(6.467,0.067), vec2(6.467,1.200), uv));\n\tdist = min(dist, dfLine(vec2(6.333,0.067), vec2(6.333,1.200), uv));\n\tdist = min(dist, dfLine(vec2(6.467,1.200), vec2(6.800,1.200), uv));\n\tdist = min(dist, dfLine(vec2(7.000,1.000), vec2(7.000,0.333), uv));\n\tdist = min(dist, dfLine(vec2(7.333,0.000), vec2(7.467,0.000), uv));\n\tdist = min(dist, dfLine(vec2(7.800,0.333), vec2(7.800,0.867), uv));\n\tdist = min(dist, dfLine(vec2(7.133,0.867), vec2(7.133,0.733), uv));\n\tdist = min(dist, dfLine(vec2(8.467,0.067), vec2(8.467,0.533), uv));\n\tdist = min(dist, dfLine(vec2(8.467,0.533), vec2(8.800,1.200), uv));\n\tdist = min(dist, dfLine(vec2(2.530,1.153), vec2(2.864,0.087), uv));\n\tdist = min(dist, dfLine(vec2(2.403,1.153), vec2(2.043,0.000), uv));\n\tdist = min(dist, dfLine(vec2(2.626,0.400), vec2(2.736,0.047), uv));\n\tdist = min(dist, dfLine(vec2(2.626,0.400), vec2(2.307,0.400), uv));\n\tdist = min(dist, dfLine(vec2(8.333,0.067), vec2(8.333,0.533), uv));\n\tdist = min(dist, dfLine(vec2(8.333,0.533), vec2(8.000,1.200), uv));\n\n\tdist = min(dist, dfArc(vec2(0.267,0.933),1.571, 3.142, 0.267, uv));\n\tdist = min(dist, dfArc(vec2(0.067,0.067),1.571, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(0.533,0.333),4.712, 3.142, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(1.067,0.067),3.142, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(1.200,0.533),1.571, 1.571, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(1.667,0.667),4.712, 1.571, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(1.800,1.133),0.000, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(3.067,0.067),3.142, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(3.533,0.867),0.000, 1.571, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(3.533,0.333),4.712, 1.571, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(4.467,0.600),4.712, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(5.533,0.867),4.712, 3.142, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(5.205,0.467),1.571, 2.513, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(5.755,0.067),4.084, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(6.400,0.067),3.142, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(7.467,0.867),0.000, 3.142, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(7.467,0.333),4.712, 1.571, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(7.333,0.333),3.142, 1.571, 0.333, uv));\n\tdist = min(dist, dfArc(vec2(8.400,0.067),3.142, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(2.800,0.067),3.444, 3.142, 0.067, uv));\n\tdist = min(dist, dfArc(vec2(2.467,1.133),0.303, 2.536, 0.067, uv));\n\n\treturn dist;\n}\n\nfloat dfBorder(vec2 uv)\n{\n    float dist = infinity;\n    \n\tdist = min(dist, dfLine(vec2(0.067,1.533), vec2(8.733,1.533), uv));\n\tdist = min(dist, dfLine(vec2(9.133,1.133), vec2(9.133,0.067), uv));\n\tdist = min(dist, dfLine(vec2(8.733,-0.333), vec2(4.467,-0.333), uv));\n\tdist = min(dist, dfLine(vec2(-0.333,0.067), vec2(-0.333,1.133), uv));\n\tdist = min(dist, dfLine(vec2(0.067,1.400), vec2(4.333,1.400), uv));\n\tdist = min(dist, dfLine(vec2(9.000,1.133), vec2(9.000,0.067), uv));\n\tdist = min(dist, dfLine(vec2(8.733,-0.200), vec2(0.067,-0.200), uv));\n\tdist = min(dist, dfLine(vec2(-0.200,0.067), vec2(-0.200,1.133), uv));\n\tdist = min(dist, dfLine(vec2(4.333,-0.333), vec2(0.067,-0.333), uv));\n\tdist = min(dist, dfLine(vec2(4.467,1.400), vec2(8.733,1.400), uv));\n\tdist = min(dist, dfArc(vec2(8.733,1.133),0.000, 1.571, 0.400, uv));\n\tdist = min(dist, dfArc(vec2(8.733,0.067),4.712, 1.571, 0.400, uv));\n\tdist = min(dist, dfArc(vec2(0.067,0.067),3.142, 1.571, 0.400, uv));\n\tdist = min(dist, dfArc(vec2(0.067,1.133),1.571, 1.571, 0.400, uv));\n\tdist = min(dist, dfArc(vec2(8.733,1.133),0.000, 1.571, 0.267, uv));\n\tdist = min(dist, dfArc(vec2(8.733,0.067),4.712, 1.571, 0.267, uv));\n\tdist = min(dist, dfArc(vec2(0.067,0.067),3.142, 1.571, 0.267, uv));\n\tdist = min(dist, dfArc(vec2(0.067,1.133),1.571, 1.571, 0.267, uv));\n    \n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n\t\n    vec2 offs = vec2(9.0, 1.5) * scale/2.0;\n    \n    float dist = 0.0;\n    float shade = 0.0;\n    vec3 color = vec3(0);\n    \n    //Flicker fade in effect.\n    float tf_text = max(epsilon, iTime - 0.6);\n    float bright_text = BRIGHTNESS * min(1.0, 1.0 - sin(tf_text * pi * 50.0) / (tf_text * pi * 1.3));\n    \n    float tf_bord = max(epsilon, iTime - 0.5);\n    float bright_bord = BRIGHTNESS * min(1.0, 1.0 - sin(tf_bord * pi * 50.0) / (tf_bord * pi * 1.3));\n    \n    //\"Shadertoy\"\n\tdist = dfLogo(uv + offs);\n\t\n\tshade = bright_text / max(epsilon, dist - THICKNESS);\n\t\n\tcolor += TEXT_COLOR * shade;\n    \n    //Border\n    dist = dfBorder(uv + offs);\n\t\n\tshade = bright_bord / max(epsilon, dist - THICKNESS);\n\t\n\tcolor += BORDER_COLOR * shade;\n\t\n\tfragColor = vec4(color , 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 409, 445, 445, 481], [483, 513, 558, 558, 736], [738, 760, 835, 835, 2050], [2052, 2052, 2075, 2075, 6396], [6398, 6398, 6423, 6423, 7731], [7734, 7734, 7792, 7792, 8669]]}
{"id": "4sc3z2", "name": "Noise Lab (3D)", "author": "candycat", "description": "try to fake http://www.noisemachine.com/talk1/19.html in 3D.", "tags": ["perlin", "simplex"], "likes": 139, "viewed": 12075, "published": "Public", "date": "1450771042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define Use_Perlin\n//#define Use_Value\n#define Use_Simplex\n\n// ========= Hash ===========\n\nvec3 hashOld33(vec3 p)\n{   \n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat hashOld31(vec3 p)\n{\n    float h = dot(p,vec3(127.1,311.7, 74.7));\n    \n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// ========= Noise ===========\n\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat noise(vec3 p) {\n#ifdef Use_Perlin\n    return perlin_noise(p * 2.0);\n#elif defined Use_Value\n    return value_noise(p * 2.0);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    \n    return 0.0;\n}\n\n// ========== Different function ==========\n\nfloat noise_itself(vec3 p)\n{\n    return noise(p * 8.0);\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec3 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 2.5 + p.x * 5.0 - 1.5);\n    \n    return f ;\n}\n\n\n// ========== Draw ==========\n\nvec3 draw_simple(float f)\n{\n    f = f * 0.5 + 0.5;\n    return f * vec3(25.0/255.0, 161.0/255.0, 245.0/255.0);\n}\n\nvec3 draw_cloud(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(8.0/255.0, 65.0/255.0, 82.0/255.0),\n              \tvec3(178.0/255.0, 161.0/255.0, 205.0/255.0),\n               \tf*f);\n}\n\nvec3 draw_fire(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(131.0/255.0, 8.0/255.0, 0.0/255.0),\n              \tvec3(204.0/255.0, 194.0/255.0, 56.0/255.0),\n               \tpow(f, 3.));\n}\n\nvec3 draw_marble(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(31.0/255.0, 14.0/255.0, 4.0/255.0),\n              \tvec3(172.0/255.0, 153.0/255.0, 138.0/255.0),\n               \t1.0 - pow(f, 3.));\n}\n\nvec3 draw_circle_outline(vec2 p, float radius, vec3 col)\n{\n    p = 2.0 * p - vec2(iResolution.x/iResolution.y, 1.0);\n    return \tmix(vec3(0.0), col, smoothstep(0.0, 0.02, abs(length(p) - radius)));\n        \t\n}\n\n// ========= Marching ===========\n#define FAR 30.0\n#define PRECISE 0.001\n#define SPEED 0.05\n\nfloat map(vec3 pos)\n{\n    return length(pos - (vec3(0.0, 0.0, 1.5) + iTime * vec3(0.0, 0.0, SPEED))) - 1.0;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy) - map(pos - eps.xyy),\n                    \t\tmap(pos + eps.yxy) - map(pos - eps.yxy),\n                         \tmap(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nvec3 getBackground(vec2 uv, vec2 split)\n{\n    vec3 pos = vec3(uv * vec2(iResolution.x/iResolution.y, 1.0), iTime * SPEED);\n    float f;\n    if (uv.x < split.x && uv.y > split.y) {\n        f = noise_itself(pos);\n    } else if (uv.x < split.x && uv.y <= split.y) {\n        f = noise_sum(pos);\n    } else if (uv.x >= split.x && uv.y < split.y) {\n        f = noise_sum_abs(pos);\n    } else {\n        f = noise_sum_abs_sin(pos);\n    }\n    \n    return vec3(f * 0.5 + 0.5);\n}\n\nvec3 getColor(vec2 uv, vec3 pos, vec3 rd, vec2 split)\n{\n    vec3 nor = normal(pos);\n    vec3 light = normalize(vec3(0.5, 1.0, -0.2));\n        \n    float diff = dot(light, nor);\n    diff = diff * 0.5 + 0.5;\n    \n    vec3 col;\n    float f;\n    if (uv.x < split.x && uv.y > split.y) {\n        f = noise_itself(pos);\n        col = draw_simple(f);\n    } else if (uv.x < split.x && uv.y <= split.y) {\n        f = noise_sum(pos);\n        col = draw_cloud(f);\n    } else if (uv.x >= split.x && uv.y < split.y) {\n        f = noise_sum_abs(pos);\n        col = draw_fire(f);\n    } else {\n        f = noise_sum_abs_sin(pos);\n        col = draw_marble(f);\n    }\n    \n    vec3 edge = col * pow((1.0 - clamp(dot(nor, -rd), 0.0, 1.0)), 5.0);\n    \n    return col + edge;\n}\n\nvec3 marching(vec3 ro, vec3 rd, vec2 uv, vec2 split)\n{\n    float t = 0.0;\n    float d = 1.0;\n    vec3 pos;\n    for (int i = 0; i < 50; i++) {\n        pos = ro + rd * t;\n        d = map(pos);\n        t += d;\n        if (d < PRECISE || t > FAR) break;\n    }\n \n    vec3 col = getBackground(uv, split);\n    \n    if (t < FAR) {\n        pos = ro + rd * t;\n        col = getColor(uv, pos, rd, split);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 split = vec2(0.5, 0.5);\n    if (iMouse.z > 0.0) {\n        split += 2.0 * iMouse.xy/iResolution.xy - 1.0;\n    }\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0) + iTime * vec3(0.0, 0.0, SPEED);\n    vec3 rd = vec3((p * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0), 1.0);\n    col = marching(ro, rd, p, split);\n\t\n    col = draw_circle_outline(p * vec2(iResolution.x/iResolution.y, 1.0), 0.9, col);\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005, abs(p.x - split.x)));\n    col = mix(vec3(0.3, 0.0, 0.0), col, smoothstep(0.0, 0.005*iResolution.x/iResolution.y, abs(p.y - split.y)));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 93, 117, 117, 298], [300, 300, 325, 325, 431], [523, 572, 595, 595, 710], [712, 712, 734, 734, 886], [888, 920, 947, 947, 1480], [1482, 1482, 1510, 1510, 2449], [2451, 2451, 2480, 2480, 3197], [3199, 3199, 3220, 3220, 3414], [3416, 3461, 3489, 3489, 3518], [3520, 3520, 3545, 3545, 3798], [3800, 3800, 3829, 3829, 4107], [4109, 4109, 4142, 4142, 4236], [4239, 4270, 4297, 4297, 4381], [4383, 4383, 4409, 4409, 4573], [4575, 4575, 4600, 4600, 4770], [4772, 4772, 4799, 4799, 4976], [4978, 4978, 5036, 5036, 5187], [5189, 5282, 5303, 5303, 5391], [5393, 5393, 5416, 5416, 5651], [5653, 5653, 5694, 5694, 6121], [6123, 6123, 6178, 6178, 6878], [6880, 6880, 6934, 6934, 7302], [7304, 7304, 7361, 7361, 8080]]}
{"id": "4sc3zf", "name": "Searching in the night", "author": "pyrite", "description": "I'm learning to use volumetric lighting. ", "tags": ["lighting", "volumetric", "ssaa"], "likes": 10, "viewed": 438, "published": "Public", "date": "1451260297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Austin Kootz - pyrite/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to iq for his SSAA implementation\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 1\n\nvec3 raymarch(in vec3 ro, in vec3 rd){\n    vec3 col = vec3(0.0);\n    float density = 0.025;\n    float stepsize = 0.05;\n    \n    for(int i = 0; i<500; i++){\n        vec3 voxelcolor = vec3(0);\n    \tro += rd*stepsize;\n       \t\n        if (dot(vec3(1,0,0),normalize(ro))>0.95) voxelcolor = density*vec3(1.0/(length(ro)));\n        if ((length(ro)<0.5)&&(dot(vec3(1,0,0),normalize(ro))>0.95)){\n            voxelcolor = vec3 (0.0);\n            col += voxelcolor;\n            break;\n        }\n    \tcol += voxelcolor;\n    //if (length(ro)<1.0) col = vec3 (1);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // camera\n    float an = 0.5*iTime - 5.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(3.0*an),6.0*cos(an),6.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {   \n        \n        vec3 p = vec3((-iResolution.xy + 2.0*(fragCoord.xy-0.5+(vec2(float(m),float(n))+0.5)/float(AA))) / iResolution.y,2.0);\n    \t\n        \n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.z*ww );\n        \n        //render scene\n        vec3 col = raymarch(ro,rd);\n        \n        //vignette\n        //col -= 0.2*length(p.xy);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sc3zf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[173, 225, 263, 263, 799], [802, 802, 859, 859, 1746]]}
{"id": "4scGW7", "name": "RollingHillsXP", "author": "nslottow", "description": "Understanding raymarching via iq's nice article: http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm", "tags": ["raymarching"], "likes": 2, "viewed": 714, "published": "Public API", "date": "1449913353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat f(float x, float z)\n{\n    return sin(x + cos(z * 3.0 + iTime * 0.5)) * sin(z + iTime);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 20.0;\n    const float dt = 0.08;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(p.x, p.z);\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = 0.02;\n    vec3 n = vec3(\n        f(p.x - eps, p.z) - f(p.x + eps, p.z),\n        2.0 * eps,\n        f(p.x, p.z - eps) - f(p.x, p.z + eps));\n    return normalize(n);  \n}\n\nvec3 getShading(vec3 p, vec3 n)\n{\n    return dot(n, vec3(0.0, 1.0, 0.0)) * vec3(0.2, 0.7, 0.2);\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 n = getNormal(p);\n    vec3 s = getShading(p, n);\n    \n    return s;\n}\n\nvec3 skyColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    const float hfov = 45.0 * 0.5 * 3.1415926535 / 180.0;\n    const float tanhfov = tan(hfov);\n    const float near = 0.1;\n    const float far = 1.0;\n    \n    vec2 uv = fragCoord.xy / (iResolution.xy * 0.5) - vec2(1.0, 1.0);\n    float dx = tanhfov * uv.x / aspect;\n    float dy = tanhfov * uv.y;\n    \n    vec3 viewRayDir = normalize(vec3(dx, dy, 1.0) * (far - near));\n    \n    float bob = -0.4 + 0.1 * cos(iTime * 0.5);\n    mat4 inverseViewMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, bob, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n        );\n    \n    const vec3 ro = vec3(0.0, 7.0, 0.0);\n    vec3 rd = (inverseViewMatrix * vec4(viewRayDir, 0.0)).xyz;\n    float resT;\n    \n    if (castRay(ro, rd, resT))\n    {\n        fragColor = vec4(terrainColor(ro, rd, resT), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(skyColor(fragCoord), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 95], [97, 97, 145, 145, 609], [611, 611, 635, 635, 825], [827, 827, 860, 860, 924], [926, 926, 972, 972, 1077], [1079, 1079, 1110, 1110, 1196], [1198, 1198, 1255, 1255, 2189]]}
{"id": "4scGzf", "name": "Xmas Tree 2", "author": "rigster", "description": "Twisting xmas tree effect. Merry Christmas!", "tags": ["2d", "warping", "fog", "tree", "xmas", "twisting"], "likes": 0, "viewed": 603, "published": "Public", "date": "1451514629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this gives the shape of the tree\nfloat shapeTree(float y)\n{\n    return 0.25 + fract(-y * 5.0) / 10.0 - y / 4.0;\n}\n\nfloat fogColor(vec2 uvFog, float time)\n{\n    //the intensity of the fog\n    return clamp(0.5 * (0.8 - uvFog.y +\n\t   \t\t\t\t\t0.4 * (1.0 - length(uvFog)) * sin(sqrt(length(uvFog)) * 16.0 - time) + \n                       \t0.5 * (1.0 - length(vec2(1.0, 0.0) - uvFog)) * sin(sqrt(length(vec2(1.0, 0.0) - uvFog)) * 12.0 - time * 0.7) + \n                       \t0.5 * (1.0 - length(vec2(0.5, 0.0) - uvFog)) * sin(sqrt(length(vec2(0.5, 0.0) - uvFog)) * 7.0 - time * 0.9)          \n    \t\t\t\t), 0.0, 1.0);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//coords to range [0,1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //with a little horizontal twist for the fog\n    vec2 uvFog = vec2(uv.x + sin(uv.y * 5.0 + iTime * 0.5) * uv.y * 0.2 + sin(uv.y * 4.0 + iTime * 0.9) * uv.y * 0.3\n                      , uv.y);\n       \n        \n    //the final color of the background\n\tfragColor = vec4(fogColor(uvFog, iTime - 0.5), 0.1 * fogColor(uvFog, iTime), 0.5 * fogColor(uvFog, iTime + 0.5), 1.0);\n\n        \n    //rotation angle\n    float rad = iTime + uv.y;\n    \n    //the width of the rotated tree\n    float cosTime = cos(rad);\n    float sinTime = sin(rad);\n    \n    float rotTree = abs(shapeTree(uv.y) * cosTime);\n    \n    if (uv.x > 0.5 - rotTree && uv.x < 0.5 + rotTree)\n    {\n        //if inside the tree, draw in tree color with a lame shading and metallic shine effect \n        fragColor = vec4(0.0, 0.6 * abs(cos(rad + 0.3)) + 0.4, 0.0, 1.0) + fogColor(uvFog, iTime);\n    }\n\n    if(cosTime * sinTime >= 0.0)\n    {\n        //show the left edge\n        float distLeft = 0.01 * abs(sinTime) - abs(uv.x - 0.5 + rotTree);\n        //if(uv.x > 0.5 - rotTree - 0.02 * abs(sinTime) && uv.x < 0.5 - rotTree + 0.02 * abs(sinTime))\n        if(distLeft > 0.0)\n        {\n            float col = distLeft * 50.0;\n            fragColor += vec4(col, col, col, 1.0);\n        }\n    }\n    else\n    {\n        //show the right edge\n        float distRight = 0.01 * abs(sinTime) - abs(uv.x - 0.5 - rotTree);\n        //if(uv.x > 0.5 + rotTree - 0.02 * abs(sinTime) && uv.x < 0.5 + rotTree + 0.02 * abs(sinTime))\n        if(distRight > 0.0)\n        {\n            float col = distRight * 50.0;\n            fragColor += vec4(col, col, col, 1.0);\n        }\n    }\n        \n}\n", "image_inputs": [{"id": "Xsf3R4", "previewfilepath": "https://soundcloud.com/snoopdogg/blue-xmas-prod-fredwreck", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/snoopdogg/blue-xmas-prod-fredwreck", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 61, 61, 115], [117, 117, 157, 188, 615], [618, 618, 675, 700, 2381]]}
{"id": "4sd3D7", "name": "Apollonian Voronoi", "author": "rwvens", "description": "Just a couple quick changes to iq's smooth voronoi shader to use what's called multiplicative weighting, or apollonian metric if I'm not mistaken. I'm using something like it in the procedural generation for a 2D strategy game I'm working on.", "tags": ["voronoi"], "likes": 17, "viewed": 885, "published": "Public", "date": "1450150906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified to use multiplicative weighting by Reinier Vens\n\n// Smooth Voronoi - avoiding aliasing, by replacing the usual min() function, which is\n// discontinuous, with a smooth version. That can help preventing some aliasing, and also\n// provides with more artistic control of the final procedural textures/models.\n\n// The parameter w controls the smoothness\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nvec4 voronoi( in vec2 x, float w )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec4 m = vec4( 8.0, 0.0, 0.0, 0.0 );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n        float weight = o.x * .5 + .5;\n\t\t\n\t\t// animate\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n\n        // distance to cell\t\t\n\t\tfloat d = length(g - f + o) * weight;\n\t\t\n        // do the smoth min for colors and distances\t\t\n\t\tvec3 col = 0.5 + 0.5*sin( hash1(dot(n+g,vec2(7.0,113.0)))*2.5 + 3.5 + vec3(2.0,3.0,2.0));\n\t\tfloat h = smoothstep( 0.0, 1.0, 0.5 + 0.5*(m.x-d)/w );\n\t\t\n\t    m.x   = mix( m.x,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w); // distance\n\t\tm.yzw = mix( m.yzw, col, h ) - h*(1.0-h)*w/(1.0+3.0*w); // color\n    }\n\t\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.yy;\n\t\n\t//float k = 2.0 + 70.0 * pow( 0.5 + 0.5*sin(0.25*6.2831*iTime), 4.0 );\n\t//k = 0.5 - 0.5*cos(0.25*6.2831*iTime);\n    vec4 c = voronoi( 6.0*p, .005 );\n\n    vec3 col = c.yzw;\n\t\n\tcol *= 1.0 - .1 * smoothstep(0.04,0.05,c.x);//*step(p.y,0.33);\n\t//col *= mix(c.x,1.0,step(p.y,0.66));\n\t\n\t//col *= smoothstep( 0.005, 0.007, abs(p.y-0.33) );\n\t//col *= smoothstep( 0.005, 0.007, abs(p.y-0.66) );\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sd3D7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[443, 487, 511, 511, 546], [547, 547, 571, 571, 670], [672, 672, 708, 708, 1485], [1487, 1487, 1544, 1544, 2012]]}
{"id": "4sdGD8", "name": "Optimized Ashima SimplexNoise2D", "author": "Makio64", "description": "I already optimized it a bit but I'm looking to a way to optimize it more, anyone have idea ?\ncheers!\n\nOptimized 3d Ashima : https://www.shadertoy.com/view/Xd3GRf", "tags": ["noise", "simplexnoise", "optimization", "noise2d", "ashima"], "likes": 11, "viewed": 1754, "published": "Public API", "date": "1449363244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\n\n// v5 fixed diagonal from abje comment\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n\nvoid mainImage( out vec4 o,  in vec2 u ) {\n\to = vec4( snoise( 5.*u/iResolution.y + iTime) );\n}\n\n// v4 \n// - add lowp precision qualifiers\n// - reorganize operation to use MAD operation where possible : https://www.opengl.org/wiki/GLSL_Optimizations#Assignment_with_MAD\n// - remove intermediate variable where its not needed\n\n\n// v3 \n// - from FabriceNeyret2 comment\n/*\nvec3 permute(vec3 x) { return mod( x*x*34.+x, 289.); }\n\nfloat snoise(vec2 v) {\n  float X=.211324865405187, Y=.366025403784439, Z=-.577350269189626, W=.024390243902439;\n  vec2 i = floor(v + (v.x+v.y)*Y),\n      x0 = v -   i + (i.x+i.y)*X,\n       j = step(x0.yx, x0),\n      x1 = x0+X-j, \n      x3 = x0+Z; \n\n  i = mod(i,289.);\n  vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))\n                           + i.x + vec3(0, j.x, 1 )   ),\n\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = 2. * fract(p * W) - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5),\n       g = a0 * vec3(x0.x,x1.x,x3.x) \n          + h * vec3(x0.y,x1.y,x3.y); \n\n  m = m*m*m*m* ( 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ) );  \n  return 130. * dot(m, g);\n}\n\nvoid mainImage( out vec4 o,  vec2 u )\n{\n \to = vec4( .5+.5*snoise( 5.*u/iResolution.y + iTime) );\n}\n\n//*/\n// v2 inspired by this thread\n// http://forum.unity3d.com/threads/2d-3d-4d-optimised-perlin-noise-cg-hlsl-library-cginc.218372/\n/*\n\nvec3 permute(vec3 x) { return mod( x*x*34.+x, 289.); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy) );\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i,289.);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  vec3 x = 2. * fract(p * C.www) - 1.;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m = m*m*m*m*(1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ));\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130. * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 o,  vec2 u )\n{\n \to = vec4( .5+.5*snoise( 5.*u/iResolution.y + iTime) );\n}\n\n\n//*/\n// v1 original version\n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n/*\n\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 o,  vec2 u )\n{\n \to = vec4( .5+.5*snoise( 5.*u/iResolution.y + iTime) );\n}\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 1031, 1073, 1073, 1125]]}
{"id": "4sdGDM", "name": "Spectrum D", "author": "gigatron", "description": "Another spectrum unreal2 remix Byproduct ... Purple motion second reality ...", "tags": ["anotherspectrum"], "likes": 8, "viewed": 190, "published": "Public", "date": "1450084165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n2D LED Spectrum - Visualiser\nBased on Led Spectrum Analyser by: simesgreen - 27th February, 2013 https://www.shadertoy.com/view/Msl3zr\n2D LED Spectrum by: uNiversal - 27th May, 2015\nCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // quantize coordinates\n    const float bands = 60.0;\n    const float segs = 40.0;\n    vec2 p;\n    p.x = floor(uv.x*bands)/bands;\n    p.y = floor(uv.y*segs)/segs;\n\n    // read frequency data from first row of texture\n    float fft  = texture( iChannel0, vec2(p.x,iTime) ).x;\n   \n    // led color\n    vec3 color = mix(vec3(2.0, 2.0, 2.0), vec3(2.0, 2.0, 2.0), sqrt(uv.y));\n\n    // mask for bar graph\n   float mask = (p.y < fft+0.1) ? 1.0 : 0.0;\n\n    \t mask*= (p.y > fft-.1) ? 1.0 : 0.0;\n      \n    // led shape\n    vec2 d = fract((uv - p) *vec2(bands, segs)) - 0.5;\n    float led = smoothstep(0.5, 0.35, abs(d.x)) *\n                smoothstep(0.5, 0.35, abs(d.y));\n    vec3 ledColor = led*color*mask;\n\n    // output final color\n     \n    fragColor = vec4(ledColor, 1.0);\n    fragColor  += vec4(uv/fft,-0.8*sin(-iTime-.5),1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dsGzH", "previewfilepath": "https://soundcloud.com/byproduct/purple-motion-2nd-reality-ost", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/byproduct/purple-motion-2nd-reality-ost", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGDM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 265, 322, 354, 1232]]}
{"id": "4sdGW4", "name": "grey spot illusion", "author": "warlock", "description": "when black is dominant", "tags": ["2d", "illusion", "onetweet"], "likes": 1, "viewed": 138, "published": "Public", "date": "1449670816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 s, vec2 f )\n{\n    /*\n    vec2 r = iResolution.xy;\n\tvec2 u = (f.xy / r.xy) * 2. - 1.;\n\ts -= s - length(u * vec2(r.x/r.y,1.) * sin(iTime) );\n\t/**/\n    s.xyz = iResolution;\n    s -= s - length( (f+f-s.xy)/s.y * sin(iTime) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 169, 248]]}
{"id": "4sdGzj", "name": "Voxel Edges with SSAA", "author": "pyrite", "description": "iq's Voxel Edges demo, with an added 4xSSAA method used to render the left half of the screen.", "tags": ["iq", "msaa"], "likes": 7, "viewed": 686, "published": "Public", "date": "1450915918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 ed = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 co = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 ep = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 cp = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        vec4 ee = 1.0-ep*(1.0-ed);\n        float www = 1.0;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.x )*ee.x;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.x )*ee.y;\n        www *= 1.0 - smoothstep( 0.85, 0.99,     uv.y )*ee.z;\n        www *= 1.0 - smoothstep( 0.85, 0.99, 1.0-uv.y )*ee.w;\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x))*(1.0-ee.x)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y))*(1.0-ee.y)*(1.0-ee.z);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z))*(1.0-ee.y)*(1.0-ee.w);\n        www *= 1.0 - smoothstep( 0.85, 0.99, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w))*(1.0-ee.x)*(1.0-ee.w);\n\t\t\n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.01*pos.xz ).zyx; \n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = 0.0; \n        // (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        // (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-ep.x*(1.0-ed.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-ep.y*(1.0-ed.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-ep.z*(1.0-ed.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-ep.w*(1.0-ed.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-cp.x*(1.0-co.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-cp.y*(1.0-co.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-cp.z*(1.0-co.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-cp.w*(1.0-co.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.90, 0.95, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvec3 renderAA(in vec3 ro, in mat3 cam, in vec2 s){\n    float cordis = 0.5;\n    float scrdis = -2.5;\n    \n    vec3 col;\n    col = vec3(0,0,0);\n    \n    vec3 rdaa1 = cam * normalize(vec3(s.x-cordis/iResolution.x,s.y-cordis/iResolution.y,scrdis));\n    col += 0.25*vec3(render(ro,rdaa1));\n    vec3 rdaa2 = cam * normalize(vec3(s.x-cordis/iResolution.x,s.y+cordis/iResolution.y,scrdis));\n    col += 0.25*vec3(render(ro,rdaa2));\n    vec3 rdaa3 = cam * normalize(vec3(s.x+cordis/iResolution.x,s.y-cordis/iResolution.y,scrdis));\n    col += 0.25*vec3(render(ro,rdaa3));\n    vec3 rdaa4 = cam * normalize(vec3(s.x+cordis/iResolution.x,s.y+cordis/iResolution.y,scrdis));\n    col += 0.25*vec3(render(ro,rdaa4));\n    \n    return col;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = vec3(0,0,0);\n    if(fragCoord.x>iResolution.x/2.0+1.0){\n    \tcol = render( ro, rd );\n    }else if (fragCoord.x<iResolution.x/2.0-1.0){\n        col = renderAA(ro,cam,p);\n    }\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGzj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 125, 151, 151, 362], [364, 364, 417, 417, 569], [571, 571, 599, 599, 974], [999, 999, 1022, 1022, 1161], [1208, 1208, 1279, 1279, 1816], [1818, 1818, 1850, 1850, 2034], [2036, 2036, 2088, 2088, 2266], [2268, 2268, 2307, 2307, 6988], [6990, 6990, 7040, 7040, 7713], [7715, 7715, 7772, 7787, 8667], [8669, 8669, 8763, 8763, 9062]]}
{"id": "4st3DM", "name": "Psyne", "author": "TomoAlien", "description": "I haven't made one in a while, so have yet another plasma.", "tags": ["ugly", "plasma", "colorful", "psychedelic", "psy"], "likes": 11, "viewed": 800, "published": "Public", "date": "1450093367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    float n = iTime;\n    \n    float x = uv.x*(sin(uv.y+n*0.5)*2.);\n    float y = uv.y*(sin(uv.x+n*0.2)*2.);\n    \n    float xp = uv.x-0.5+sin(x*3.+n-sin(y*7.+n));\n    float yp = uv.y-0.5+sin(y*3.+n+sin(x*5.-n));\n    \n    float eh = ((sqrt(xp*xp+yp*yp)*5.+n));\n    \n\tfragColor = vec4(sin(eh*0.5+(y+n*1.1)*5.-n*5.),sin(eh*0.6+(y+n)*5.-n*5.),sin(eh*0.7+(y+n*1.2)*5.-n*5.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]]}
{"id": "4st3Rf", "name": "Yolka", "author": "madware", "description": "This Is Yolka\nMerry Christmas and Happy New Year!", "tags": ["2d", "barycentric"], "likes": 7, "viewed": 732, "published": "Public", "date": "1451391206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n   29.12.2015\n   Yolka. Made by Madware\n   Merry Christmas and Happy New Year!\n*/\n\n#define vc3 vec3\n#define vc2 vec2\n#define time iTime\n#define px2 p.x * p.x\n#define ss(x, y) sin((time + x) * y)\n#define _f(x) * x + x\n#define mx mix(col,\n#define f1(x,y) f += x*ns(p); p *= y\n#define area(v0, v1) dot(v0, vc2(v1.y, -v1.x))\n#define IsIn(b) all(greaterThanEqual(b, vc3(0.))) && all(lessThanEqual(b, vc3(1.)))\n#define smst smoothstep\n#define snow(p)         smst(p.y, p.y + .005, sin(p.x + .2) * .2 - .25)\n#define moon(p,pp,rad)  smst(.97, 1., distance(p, pp) / rad)\n#define h(n) fract(sin(n)*753.5453)\n#define flt float\n#define fori(x) for(flt i = 0.; i < x; i++)\n#define pa(x,y) pow(abs(x),y)\n#define cmix col = mix\n#define rres return f\n#define clp clamp\n\nfloat gir(vc2 p, vc2 pp, flt rad )\n{    \n    return smst(.95, 1., 1.- distance(p, pp) / rad);    \n}\n\nconst flt PI = 3.141593;\nconst flt stp = PI * .4;\nconst flt deg45 = PI / 4.;\n\n// noise from https://www.shadertoy.com/view/4sfGzS (simplified 2d version)\nflt ns(vc2 x )\n{\n    vc2 p = floor(x);\n    vc2 f = fract(x);\n    f = f*f*(3. - f - f);\n\t\n    flt n = p.x + p.y*157. + 113.;\n    return mix(mix( h(n+ 0.), h(n+ 1.),f.x),\n               mix( h(n+63.), h(n+64.),f.x),f.y);\n}\n\nflt fbm(vc2 p)\n{\n    flt f = 0.;\n    f1(   .5,2.02);\n    f1(  .25,2.03);\n    f1( .125,2.01);\n    f1(.0625,2.04);\n    f /= .9375;\n    rres;    \n}\n\nvc3 baryc(vc2 p0, vc2 p1, vc2 p2, vc2 p )\n{\n\tvc2 e0 = p1 - p0;\n\tvc2 e1 = p2 - p1;\n\n\tvc2 v0 = p0 - p;\n\tvc2 v1 = p1 - p;\n\tvc2 v2 = p2 - p;\n    \n    flt a = area(e0, e1);\n\tflt a1 = area(v1, v2);\n\tflt a2 = area(v2, v0);\n\tflt a3 = area(v0, v1);\n\n\treturn vc3(a1 / a, a2 / a, a3 / a);\n}   \n\nflt es( vc2 p0, vc2 p1, vc2 p2, vc3 _avec, vc2 p)\n{\n    flt f = 0.;\n    vc2 _p = p + (p - p2) * (px2 * 1.25 + fbm(p*100.)*.055 + fbm(p*200.)*.035);\n    _p.x -= sign(_p.x)*fbm(p*700.)*(px2 *.5);\n    vc3 bar = baryc( p0, p1, p2, _p);\n    if(IsIn(bar))    \n\t   f = dot(bar, _avec);    \n    rres;    \n}\n\nflt star(vc2 sp, vc2 p, flt or, flt ir)\n{\n    flt f = 0.;\n    flt ang = PI * .5 + ss(0., 1.5)*.05; \n    vc3 clr = vc3(1., .2, .2);\n        \n    fori(5.)\n    {\n        vc2 op = vc2(sp.x + cos(ang) * or, sp.y + sin(ang) * or);\n        vc2 p1 = vc2(sp.x + cos(ang + deg45) * ir, sp.y + sin(ang + deg45) * ir);\n        vc3 b = baryc(sp, op, p1, p);\n        if(IsIn(b))\n    \t{\n\t   \t\tf = dot(b, clr);\n            break;\n    \t}\n        \n        vc2 p2 = vc2(sp.x + cos(ang - deg45) * ir, sp.y + sin(ang - deg45) * ir);\n        \n        b = baryc(sp, op, p2, p);\n        if(IsIn(b))\n    \t{\n\t   \t\tf = dot(b, clr);\n            break;\n    \t}\n        ang += stp;\n    }    \n    rres;    \n}\n\nvoid mainImage( out vec4 fragColor, in vc2 fragCoord )\n{\n    flt t =  ss( 0.,  1.);    \n    flt t2 = ss( 0.,  3.) _f(.5);\n    flt t3 = ss(-PI,  3.) _f(.5);\n    flt t4 = t2 * .02;\n    flt t5 = ss( 0., .75) * .03;\n    \n    flt a = 0.;\n    flt ab = 0.;\n\tvc2 p = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vc3 snc = vc3(.81, .73, .83);\n    \n    vc3 avec = vc3(.045, .36,  1.); \n    vc3 davec = vc3(.02,.01,0.);\n    vc2 dp = vc2(.01, .05 - t4);    \n    \n\tvc2 v1 = vc2(-.5,-.8); vc2 v2 = vc2(.5,-.8); vc2 v3 = vc2(0.,-t4);\n\tvc3 col = vc3(.1, .1, .11);\n    vc3 wt = vc3(1.);\n    vc3 girc = vc3(.1, .9, .17);\n    \n    if(t <= 0.)\n        girc = mix(girc.yxz, girc, t + 1.);        \n    else\n        girc = mix(girc, girc.zxy, t);\n    \n    ab = es(v1, v2, v3, avec, p);\n    if(ab > 0.) a = ab;\n    \n    fori(8.)\n    {    \n        v1 += vc2(.04, .15 - t4*.3); v2 += vc2(-.04, .15 - t4*.3); v3 += vec2(.0, .1 - t4*.2);    \n        avec += davec;\n\n        ab = es(v1, v2, v3, avec, p + dp);\n        if(ab > 0.) a = mix(a, 0., .3);    \n        ab = es(v1, v2, v3, avec, p);\n        if(ab > 0.) a = ab;\n        dp += vc2(0., -.0035);\n    }       \n     \n    if(a > .1)\n    {\n        col = mix(vc3(0.), vc3(.18, .53, .26), a * (1. + fbm(p*150.)*.45));\n        col += girc * t2 * .02;\n        col += girc.zyx * t3 * .02;\n        col = col + vc3(1., 0., 0.) * pow(clp(p.y - t4 + .1, 0., 1.), 2.) * 1.3 * t;\n        \n        flt kf = 1.;\n        flt kk = 0.;\n        \n        for(flt k = -.75; k < .4; k += .15)\n        {\n            for(flt j = -.34; j < .58; j += .12)\n            { \n                flt jj = j * kf;\n                flt rg = gir(p,vc2(jj, k + kk + jj / 4. + pa(p.x, 2.)), .3) * t2;\n                flt gg = gir(p,vc2(jj + .06 * kf, k + kk + (jj + .06 * kf) / 4. + pa(p.x, 2.)), .3) * t3;\n                \n                cmix(mx girc, rg), wt, pow(rg, 8.));\n                cmix(mx girc.zyx, gg), wt, pow(gg, 8.));\n                kf -= .011111;\n            }   \n            kk -= t4 * .25;\n        }        \n    }\n    else\n    {\n        vc2 mlt = vc2(.8, .7 + t5);\n        vc2 msd = vc2(.9, .7 - t5);\n        \n        flt l = length(mlt);\n        flt an = atan(mlt.y, mlt.x) + mod(time *.1, PI);\n        \n        mlt = vc2(l * cos(an) * 2.1, l * sin(an) *.9 - .4);   \n        msd += mlt - vc2(.8, .7 + t5);\n        \n        vc3 sky = vc3(.01+(-p.x * 1. - p.y) * .07, (p.x * 1. - p.y) * .1, .17+(p.x * 1. - p.y) * .07);\n        \n        flt snw = snow(p);\n        \n        col = mx sky, clp(p.y + .3, 0., 1.));\n        \n        if(snw > 0.) \n        {\n            col = mx vc3(.81, .73, .83), snw * (1. - fbm(p * 150.) * .06 + p.y * .55));  \n            if(es(vc2(-.5,-.8), vc2(.5,-.8), vc2(0.,-t4), avec, p + vec2(0., 0.05)) <= 0.01)\n            {\n                vc2 pp = vc2(p.x, p.y * 3. + 1.6);\n            \tflt aa = (1. - clp(distance(pp, vc2(0., -.5)) / 1.5, 0., 1.)) / 4.;\n          \n                col += girc * t2 * aa;\n                col += girc.zyx * t3 * aa;\n            }\n        }\n  \t\telse   \n        {\n            fori(25.)\n            {\n                flt a1 = ss(i, .3) _f(.5);\n                col = mx snc, a1 * gir(p, vc2(mod(h(i*72.04) * 6. - time * .02, 4.) - 2. ,h(mod(i,30.) * 200.) * 2. - 1.),.125 + a1*.05));                \n            }\n            col = mx vc3(.87, .8, .6), clp(moon(p,mlt, .24) - moon(p,msd, .2), 0., 1.));  \n        }\n    }\n    \n    v3 += vc2(.0,.035);\n    \n    a = star(v3, p, .13, .06);\n    if(a > 0.)\n    \tcmix(vc3(.6 + .35 * t, .11, .14), vec3(1., .7, .7), star(v3, p, .115, .055) * (t _f(.5)) * .9); \n\n    fori(70.){\n        flt a2 = ss(i + h(i), .3) _f(.5);\n        col = mx snc*1.35, gir(p, vc2(h(i*72.04) *  4. - 2. + a2 ,mod((h(mod(i ,30.) * 200.) - time *.1) * 2., 2.) - 1.)*1.1,.35 + a2 *.25));\n    }\n    \n\tfragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "MsXGR4", "previewfilepath": "https://soundcloud.com/officialdeanmartin/10-jingle-bells-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/officialdeanmartin/10-jingle-bells-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 758, 794, 794, 857], [937, 1013, 1029, 1029, 1233], [1235, 1235, 1251, 1251, 1379], [1381, 1381, 1424, 1424, 1660], [1665, 1665, 1716, 1716, 1963], [1965, 1965, 2006, 2006, 2641], [2643, 2643, 2699, 2699, 6448]]}
{"id": "4st3W7", "name": "Gnihihihi Balls", "author": "DrLuke", "description": "Just some Raymarching balls", "tags": ["raymarching", "spheres", "balls"], "likes": 5, "viewed": 811, "published": "Public API", "date": "1450113057", "time_retrieved": "2021-10-01T00:00:00", "image_code": " #define MARCHLIMIT 70\n\nvec3 camPos = vec3(0.0, 0.0, -1.0);\nvec3 ld = vec3(0.0, 0.0, 1.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nvec3 right = vec3(1.0, 0.0, 0.0);\nvec3 lightpos = vec3(1.5, 1.5, 1.5);\n\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 range(vec3 p)\n{\n    // Sphere with Radius\n    vec3 spherepos = vec3(0.0, 0.0, 0.0);\n    float radius = log(sin(iTime*0.1)*0.05+1.0)+0.1;\n\t\n    // Sinewave effect\n    //\t\t\t\t\t\t\t\t\t\t  V this cosine with floor acts as a toggle \n    float xampl = sin(iTime*1.3)*0.4*floor(cos(iTime*0.4)+1.0);\n    float yampl = sin(iTime*1.3)*0.4-(floor(-cos(iTime*0.4)+1.0)*0.3);\n    \n    p.x += cos((max(-2.0+p.z-camPos.z,0.)))*xampl-xampl;\n    p.y += sin((max(-2.0+p.z-camPos.z,0.)))*yampl;\n    \n    // Pulsating effect\n    p.x *= -min(+2.0+p.z-camPos.z,0.)*sin(iTime*3.0)*0.1 + 1.0;\n    p.y *= -min(+2.0+p.z-camPos.z,0.)*sin(iTime*3.0)*0.1 + 1.0;\n    \n    p = mod(p + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    spherepos = mod(spherepos + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    \n    vec3 diff = p - spherepos;\n    \n    vec3 normal = normalize(diff);\n\n    \n    return vec4(normal, length(diff)-radius);\n}\n\n// Basic linear interpolation (Only used in the fresnel effect\nvec3 lerp(vec3 a, vec3 b, float p)\n{\n    p = clamp(p,0.,1.);\n \treturn a*(1.0-p)+b*p;   \n}\n\n\nvec4 march(vec3 cam, vec3 n)\n{\n    \n    float len = 1.0;\n    vec4 ret;\n    \n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        ret = range(camPos + len*n)*0.5;\n\t\tlen += ret.w;\n    }\n    \n\treturn vec4(ret.xyz, len);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*1.0) / iResolution.xy - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float rotangle = iTime*0.08;\n    vec2 newuv;\n    newuv.x = uv.x*cos(rotangle)-uv.y*sin(rotangle);\n    newuv.y = uv.x*sin(rotangle)+uv.y*cos(rotangle);\n    uv = newuv;\n    \n    camPos = vec3(0.5, 0.5, iTime*1.0);\n\n    ld = normalize(vec3(0.0, sin(iTime*0.8)*0.1, cos(iTime*0.8)*0.5));\n    \n    // This is the raymarching vector. It is calculated by interpreting the uv coordinates as angles, and thus rotating\n    // the ld (lookdirection) vector by the given angle. It is then used as the direction for the ray to march in.\n    // With this projection you can see the full 360 around you. Try changing the zoom to something like 1.5\n    float zoom = 0.6;\n    vec3 n = normalize(vec3(sin(uv.x*3.1415*zoom),sin(uv.y*3.1415*zoom) ,ld.z*cos(uv.x*3.1415*zoom)*cos(uv.y*3.1415*zoom)));\n    \n    vec4 rangeret = march(camPos, n); // March rays from the camera in the direction of n\n    \n    float d = log(rangeret.w / 1.0 + 1.0);\t// Take logarithm of distance to make transition more smooth for further away objects\n    vec3 normal = rangeret.xyz;\t// Extract normal from return vector\n    \n    // Calculate angle between the raymarching ray and normal (I think this is broken, but it looks good)\n    vec3 p = camPos + n*d;\n    float angle = acos(dot(normal, n)/length(normal)*length(n));\n    \n    //                | I'm Using the HSV colorspace for fancy colors \n    //                |               | Interpolation between normal color and reflection color depending on the angle of the normal\n    //                |               |    | Fade through colors depending on distance and time (H), also fade to black in the distance (V), (S) stays fixed to 2\n    //                |               |    |                                                         | reflection color is just a color from the current time +120second\n    //                |               |    |                                                         |                                                                   | parameter used for lerp\n\tfragColor = vec4(hsv2rgb_smooth(lerp(vec3(d*0.1 + iTime*0.01, 2.0, max(1.0 - log(d),0.0)),vec3(d*0.1 + (iTime+120.0)*0.01 , 2.0, max(1.0 - log(d),0.0)),cos(angle/10.0))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 228, 262, 262, 440], [442, 442, 462, 488, 1375], [1377, 1440, 1476, 1476, 1529], [1532, 1532, 1562, 1562, 1751], [1754, 1754, 1811, 1811, 4127]]}
{"id": "4st3W8", "name": "~{{{-{-{{{ 135 }}}-}-}}}~", "author": "MrHenryBemis", "description": "MANDALIC GEMATRIAD HYPERSURFACTOID", "tags": ["spheres", "folding", "mandala"], "likes": 7, "viewed": 170, "published": "Public", "date": "1449343205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime tan(iTime*.1)\n\n#define DTM 135.0\n\n#define D 30.0\n#define T 5.0\n#define M 100.0\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float scale = (sin(iTime)*.5+.5);\n    \n    float d; \n    \n    vec3 col = vec3(.3);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        vec2 p = vec2(cos(float(i)/22.0*PI*22.0+iTime), sin(float(i)/22.0*PI*2.0+iTime));\n    \n        d = length(uv-p)*0.3;\n        \n        \n    \tif(d <= 3.0)\n        {\n            col += (vec3(\n            sin(-iTime*PI*2.0+D+d*PI),\n            sin(-iTime*PI*7.0+4.0*PI/3.0+M+d*PI),\n            sin(-iTime*PI*1.0+2.0*PI/2.0+T+d*PI))*.5+.5)*sin(d*PI*DTM+iTime*DTM);\n        }\n    }\n    \n    d = length(uv)*2.2;\n    \n    col += vec3(\n    \tsin(-iTime*PI*3.0+D+d*PI),\n        sin(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n        sin(-iTime*PI*3.0+3.0*PI/2.0+T+d*PI));\n    \n\t\tfragColor = vec4(col, 1.0);\n}\n\n\n/*\n#define iTime iTime*.2\n\n#define DMT 134.0\n\n#define D 4.0\n#define M 40.0\n#define T 90.0\n\n#define PI 3.14159265359\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * MOD3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//float hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float scale = (sin(iTime)*.5+.5);\n    \n    float d = length(uv)*1.2;\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 2; i++)\n    {\n        vec2 p = hash21(float(i))*2.0-1.0;\n    \n        d = length(uv-p)*1.5;\n        \n        \n    \tif(d <= 1.0)\n        {\n            col += (vec3(\n            sin(-iTime*PI*2.0+D+d*PI),\n            sin(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n            sin(-iTime*PI*2.0+2.0*PI/3.0+T+d*PI))*.5+.5)*(sin(d*PI*DMT)*.5+.5);\n        }\n    }\n    \n    col = vec3(\n            sin(col.x*2.0+D),\n            sin(col.y*2.0+4.0*PI/3.0+M),\n            sin(col.z*2.0+2.0*PI/3.0+T))*.5+.5;\n    \n\t\tfragColor = vec4(col, 1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 177, 177, 1004]]}
{"id": "4stGD8", "name": "Bubbles space", "author": "And390", "description": "Geometry creates by simplex noise. You can enable morphing or shadows. Point lights, shadows and morphing are expensive.", "tags": ["raytracing", "noise", "light", "shadows", "simplex"], "likes": 3, "viewed": 267, "published": "Public", "date": "1449364949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// uncomment to enable\n//#define MORPHING 0.05\n//#define SHADOWS 1\n//#define DIRECT_LIGHT vec3(1.0, 1.0, -1.0)\n//#define BEND_PATH 1   //move on sin path\n#define NAVIGATE 1    //navigate in four directions around the bubbles\nconst float bubbleSize = 0.5;\nconst int lightsCount = 2;\nconst bool headlamp = false;  //additional light\nconst float lightPower = 0.8;\nconst float lightSpeed = 1.0;\nconst float epsilon = 0.0001;\n\n\nfloat simplex(vec3 v);\nfloat simplex(vec4 v);\n\nfloat noise(vec3 p) {\n    #ifdef MORPHING\n    \treturn simplex(vec4(p, iTime*MORPHING));\n    #else\n    \treturn simplex(p);\n    #endif\n}\n\nfloat map(vec3 p) {\n    // bubbles are less with simplex4d, so increase the size\n    #ifdef MORPHING\n    float finaBubblesSize = bubbleSize * 1.3;\n    #else\n    float finaBubblesSize = bubbleSize;\n    #endif\n    return noise(p) + (1.0 - finaBubblesSize);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(epsilon, 0.0);\n    return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),\n                          map(p+e.yxy) - map(p-e.yxy),\n                          map(p+e.yyx) - map(p-e.yyx)));\n}\n\nvec3 getLightPos(vec3 origin, int i) {\n    vec3 p = 1.0 * sin(lightSpeed * vec3(iTime*0.3, iTime*0.1, iTime*0.2) + 500.*vec3(i));\n    p.z += 1.2;\n    p.xy *= p.z / 2.;\n    return origin + p;\n}\n\nfloat mapLight(vec3 p, vec3 origin) {\n    float d = 1000.;\n    for (int i=0; i<lightsCount; i++)  d = min(d, length(p - getLightPos(origin, i)) - 0.05);\n    return d;\n}\n\nfloat mapAll(vec3 p, vec3 origin, out bool matchLight) {\n    float d = map(p);\n    if (d < epsilon) {\n        matchLight = false;\n        return d;\n    } else {\n        matchLight = true;\n        return min(d, mapLight(p, origin));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n    \n    p.y /= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);  //view position\n    vec3 right = (vec3(1., 0., 0.));  //view direction\n    vec3 up = vec3(0., 1., 0.);\n    \n    //    move by z\n    float mz = 0.10;\n    ro.z += iTime * mz;\n    \n        #ifdef BEND_PATH\n    //    move by x\n    float mxa = 0.05;\n    float mxr = 4.;\n    ro.x += sin(iTime*mxa)*mxr;\n    float a = atan(cos(iTime*mxa)*mxr*mxa/mz);\n    right = vec3(right.z*sin(a)+right.x*cos(a), right.y, right.z*cos(a)-right.x*sin(a));  //rotate by y\n    up = vec3(up.z*sin(a)+up.x*cos(a), up.y, up.z*cos(a)-up.x*sin(a));  //rotate by y\n    \n    //    move by y\n    float mya = 0.10;\n    float myr = 4.;\n    ro.y += sin(iTime*mya)*myr;  \n    a = -atan(cos(iTime*mya)*myr*mya/mz);\n    right = vec3(right.x, right.y*cos(a)-right.z*sin(a), right.y*sin(a)+right.z*cos(a));  //rotate by x\n    up = vec3(up.x, up.y*cos(a)-up.z*sin(a), up.y*sin(a)+up.z*cos(a));  //rotate by x\n    #endif\n\n    //    move around the bubbles\n    vec3 origin = ro;\n    vec3 dir = cross(right, up);\n    #ifdef NAVIGATE\n    vec3 down = -up;\n    vec3 left = -right;\n    float turnK = 0.3;\n    for (int i=0; i<2; i++) {\n        float baseD = map(ro + dir);\n        if (baseD > 1.)  break;\n        float dUp = map(ro + dir + up) - baseD;\n        float dDown = map(ro + dir + down) - baseD;\n        float dLeft = map(ro + dir + left) - baseD;\n        float dRight = map(ro + dir + right) - baseD;    \n        ro += turnK * (1. - baseD) * \n            (up * dUp + down * dDown + left * dLeft + right * dRight);\n    }\n    #else\n    ro += up * noise(ro);  //simple navigation\n    #endif\n    \n    vec3 rd = p.x * right + p.y * up + dir;\n    \n    //    ray tracing\n    float tmax = 20.0;\n    float t = 0.0;  //distance from point of view\n    float dist;\n    bool open = false;\n    bool matchLight = false;    \n    for (int i=0; i<1000; i++) {\n        dist = mapAll(ro + t*rd, origin, matchLight);  //distance to target\n        if (dist<epsilon) {\n            if (open)  break;\n            else  t += epsilon + epsilon - dist/5.;\n        }\n        else {\n            open = true;\n            // different accuracy relate to distance\n            t += dist < 0.01 ? dist : dist < 0.1 ? dist/3. : dist/5.;\n        }\n        if (t > tmax)  break;\n    }\n    \n    //    lighting\n    vec3 col = vec3(0);\n    if (dist<epsilon) {\n        if (matchLight) {\n            col = vec3(1., 1., 1.);\n        }\n        else {\n            vec3 pos = ro + t*rd;\n            vec3 normal = calcNormal(pos);\n            float lightness = 0.0;\n            #ifdef DIRECT_LIGHT\n            {\n                vec3 lightDir = normalize(DIRECT_LIGHT);\n                lightness += dot(normal, lightDir);\n            }\n            #endif\n            for (int l=0; l<lightsCount + (headlamp ? 1 : 0); l++) {\n                vec3 lightPos = l==lightsCount ? ro+up/2. : getLightPos(origin, l);\n                vec3 lightDir = normalize(lightPos-pos);\n                float lightDist = length(lightPos-pos);\n                //if (lightDist >= lightDistance)  continue;\n                \n                // shadows\n                #ifdef SHADOWS\n                float t = epsilon+epsilon-dist;\n                float tmax = length(pos - lightPos);\n                for (int i=0; i<300; i++) {\n                    float dist = map(pos + t*lightDir);\n                    if (dist<epsilon)  break;\n                    else  t += dist < 0.01 ? dist : dist < 0.1 ? dist/3. : dist/5.;\n                    if (t > tmax)  break;\n                }\n                if (t > tmax)\n                #endif\n                {\n                     //float attenuation = pow(max(0.0, 1.0 - lightDist / lightDistance), lightDecay);\n                     float attenuation = min(1.0, lightPower / lightDist);\n                     lightness += dot(normal, lightDir) * attenuation;\n                     if (lightness > (1.0/0.6))  break;\n                }\n            }\n            col = vec3(1.0, 0.8, 0.6) * lightness;\n        }\n    }\n        \n    \n\tfragColor = vec4(col, 1.);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) );\n\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 470, 491, 491, 604], [606, 606, 625, 686, 862], [864, 864, 889, 889, 1091], [1093, 1093, 1131, 1131, 1285], [1287, 1287, 1324, 1324, 1455], [1457, 1457, 1513, 1513, 1696], [1698, 1698, 1755, 1755, 5886], [5889, 6281, 6304, 6304, 6353], [6355, 6355, 6376, 6376, 6425], [6427, 6427, 6448, 6448, 6497], [6499, 6499, 6523, 6523, 6563], [6565, 6565, 6587, 6587, 6627], [6629, 6629, 6659, 6659, 6711], [6713, 6713, 6741, 6741, 6793], [6795, 6795, 6820, 6820, 8961], [8963, 8963, 8995, 8995, 9258], [9266, 9340, 9365, 9365, 11842]]}
{"id": "4stGW4", "name": "Cloudy lake", "author": "Draedrus", "description": "This is my first draft on terrain generation. I added day&night cycle and other stuff to make this more \"real\". I hope you will love the scene as much I love working on it :-)\nThe moon and the sun are also rendered, but not always on the camera sight ;-)", "tags": ["heightmap", "nightday"], "likes": 6, "viewed": 305, "published": "Public", "date": "1449668127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\n#define NEAR 0.0\n#define FAR 5.0\n#define MOUNTS 4.0\n#define OCTAVES 8\n#define FOG_SPEED_FACTOR 0.02\n#define ASTRALSPEED 0.2\n#define CAMROTSPEED 0.08\n#define WATERLEVEL 0.2\n#define ASTRESIZE 0.3\n#define NIGHTANDDAY\n\n#define FIX2018\n#ifdef FIX2018\n#undef ASTRALSPEED\n#define ASTRALSPEED 0.1\n#endif\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n#ifdef NIGHTANDDAY\n    vec3 sunPos;\n\tvec3 moonPos;\n#else\n\tvec3 sunPos = vec3(0.1, 3.0, 0.0);\n#endif\n    Light sun;\n#ifdef NIGHTANDDAY\n    Light moon;\n#endif\nvec4 ambientColor = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 skyColor = vec4(0.6, 0.6, 0.9, 1.0);\nvec4 nightSkyColor = vec4(0.1, 0.1, 0.4, 1.0);\nvec4 waterColor = vec4(0.1, 0.4, 0.7, 1.0);\nvec4 nightWaterColor = vec4(0.01, 0.1, 0.4, 1.0);\nvec4 mountColor = vec4(0.6, 0.5, 0.5, 1.0);\nvec4 fogColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat noise(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(noise(wx+0.0)     ,      noise(wx+1.0), f.x),\n                mix(noise(wx+0.0+winy), noise(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(noise(wx+0.0+winz)     ,      noise(wx+1.0+winz), f.x),\n                mix(noise(wx+0.0+winy+winz), noise(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nvec4 clouds2(vec3 p, float y) {\n    p.z = p.z+cos(iTime*FOG_SPEED_FACTOR);\n    vec4 c = vec4(perlin(p*6.0));\n    c = mix(c, vec4(perlin(p*2.0)), y);\n    c = mix(c, vec4(perlin(p*4.0)), y);\n    return clamp(c, 0.0, 1.0);\n}\n\nvec4 blinnPhong(vec4 bColor, Light l, vec3 normal, vec3 vV, float shininess) {\n    vec3 N = normalize(normal);\n    float lambertTerm = max(dot(-l.d, N), 0.0);\n    float specular = 0.0;\n    float screenGamma = 2.2;\n\n    if(lambertTerm>0.0) {\n        vec3 viewDir = normalize(vV);\n\n        vec3 halfDir = normalize(-l.d+vV);\n        float specAngle = max(dot(halfDir, N), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    vec4 colorLinear = //ambientColor +\n        lambertTerm * bColor; // diffuse color\n    \tif(shininess>0.0)\n        colorLinear += specular * vec4(1.0); // specular color\n    vec3 colorGammaCorrected = pow(colorLinear.xyz, vec3(1.0/screenGamma));\n    return vec4(colorGammaCorrected, 1.0)*l.power;\n}\n\n/*****\n * START TERRAIN GENERATION\n *****/\n\nfloat mapTerrain(vec2 a) {\n    //return (cos(a.x*30.0)*sin(a.y*30.0))*0.1;\n    float h = perlin(vec3(a.x, a.y, a.x*a.y)*2.1)*0.3;\n    h+=smoothNoise(vec3(a.x, a.y, a.x*a.y)*2.0)*0.1;\n    h+=smoothNoise(vec3(a.x*a.x, a.y, a.x*a.y)*0.02)*4.0;\n    return h;\n}\n\nfloat map(vec3 pt) {\n    return perlin(pt);\n}\n\n/*****\n * END TERRAIN GENERATION\n *****/\n\n// again, thanks IQ for the method, without this one I could not have a terrain before long !\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - mapTerrain( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float t = -1.0;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\nvec4 pixColor(vec3 ro, vec3 rd) {\n    float t = raycast(ro, rd, NEAR, FAR);\n    vec3 pt = ro+t*rd;\n    if(t>FAR) { // sky\n        vec4 pColor = skyColor;\n        #ifdef NIGHTANDDAY\n        pColor = mix(\n            skyColor,\n            nightSkyColor,\n            max(1.0-sun.o.y/3.0, 0.0));\n        // sun\n        float t2 = IntersectSphere(ro, rd, sun.o, ASTRESIZE);\n        if(t2>0.0) {\n            pColor = mix(\n                vec4(1.0, 1.0, 0.4, 1.0),\n                vec4(1.0, 0.0, 0.0, 1.0),\n                max(1.0-sun.o.y/3.0, 0.0))*(smoothNoise((ro+rd*t2-sun.o))+0.8);\n        }\n        // moon\n        t2 = IntersectSphere(ro, rd, moon.o, ASTRESIZE);\n        if(t2>0.0) {\n            pColor = moon.diffuseColor*perlin(ro+rd*t2-moon.o);\n        }\n        #endif\n        // clouds\n        pColor+= perlin(vec3(rd.x/2.0, rd.y/2.0, rd.z/2.5))/2.5;\n        return pColor;\n    }else if(t>MOUNTS) {\n        float y = pt.y;\n        vec4 pColor = vec4(0.0);\n        pColor = mix(mountColor, vec4(1.0), smoothNoise(pt)*(y/0.3));\n        #ifdef NIGHTANDDAY\n        return mix(pColor, vec4(0.0), max(1.0-sun.o.y/3.0, 0.0));\n        #else\n        return pColor;\n       \t#endif\n    }else{ // terrain\n        vec3 normal = pt-vec3(\n            mapTerrain( vec2(pt.x, pt.y)),\n            mapTerrain( vec2(pt.x, pt.y)+0.1),\n            mapTerrain( vec2(pt.x, pt.y))\n        );\n        #ifdef NIGHTANDDAY\n        Light astre = sun;\n        if(moon.o.y>sun.o.y)\n            astre = moon;\n        #endif\n        float y = pt.y;\n        vec4 pColor = vec4(0.0);//vec4(0.1, 0.8, 0.5, 1.0)*pt.y*perlin(pt);\n        if(y<WATERLEVEL) { // water\n            pt.y = WATERLEVEL;\n            y = pt.y;\n            pColor = waterColor*perlin(rd*0.5);\n            #ifdef NIGHTANDDAY\n            \n            pColor = mix(\n                mix(pColor, max(clouds2(pt, 1.0-(FAR-t)/FAR), 0.0), 0.5),\n                nightWaterColor,\n                max(1.0-astre.o.y/3.0, 0.0));\n            \n                pColor = blinnPhong(pColor, astre, vec3(\n                    max(noise(pt.x)-0.99, 0.0),\n                    max(noise(pt.x)-0.98, 0.0)+0.02,\n                    max(noise(pt.z)-0.99, 0.0)), rd, -0.5);\n            return pColor;\n            #endif\n            return mix(pColor, max(clouds2(pt, 1.0-(FAR-t)/FAR), 0.0), 0.5);\n        }else if(y>=WATERLEVEL) { // trees\n            vec3 n = vec3(\n                cos((t+FAR)*600.0)/20.0+0.3,\n                0.3,\n               \tsin((t+FAR)*600.0)/20.0+0.3\n                );\n            pColor = mix(vec4(0.1, 0.8, 0.5, 1.0)*pt.y*perlin(pt), vec4(1.0), y/0.8);\n            \n        \t#ifdef NIGHTANDDAY\n        \t\tpColor = mix(pColor,\n                         astre.diffuseColor*\n                             max(0.0, dot(-astre.d, normalize(n)))*y*3.9,\n                         max(0.0, dot(-astre.d, normalize(normal))-0.5))*y*3.0;\n        \t\tpColor = blinnPhong(pColor, astre, n, rd, -1.0);\n            #else\n        \t\tpColor = mix(pColor,\n                         sun.diffuseColor*max(dot(-sun.d, normalize(n)),\n                                               0.0)*y*3.9,\n                         max(dot(-sun.d, normalize(normal))-0.5,\n                                               0.0))*y*3.0;\n        \t\tpColor = blinnPhong(pColor, sun, n, rd, -1.0);\n            #endif\n        }\n        #ifdef NIGHTANDDAY\n        return mix(\n            pColor+max(clouds2(pt, 1.0-(FAR-t)/FAR)*((0.25-y)/0.25), 0.0),\n            vec4(0.0),\n            max(1.0-astre.o.y/3.0, 0.0));\n\n        #else\n        //pColor = blinnPhong(pColor, sun, normal, rd);\n        return pColor+max(clouds2(pt, 1.0-(FAR-t)/FAR)*((0.25-y)/0.25), 0.0);//vec4(normal, 1.0);\n        \n       \t#endif\n    }\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 camPos(float t) {\n    return vec3(cos(t), 0.7, sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunPos = FAR*vec3(cos(iTime*ASTRALSPEED), sin(iTime*ASTRALSPEED), 0.0);\n    sun = Light(\n        sunPos,\n        normalize(vec3(0.0, 0.0, 0.0)-sunPos),\n        vec4(1.0, 1.0, 0.3, 1.0),\n        16.0,\n    \t1.0);\n#ifdef NIGHTANDDAY\n    moonPos = -sunPos;\n    moon = Light(\n        moonPos,\n        normalize(vec3(0.0, 0.0, 0.0)-moonPos),\n        vec4(0.9, 0.9, 1.0, 1.0),\n        16.0,\n    \t0.3);\n#endif\n    vec2 pixel = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    // corrections added from 2018, initial shader from 2015\n    #ifdef FIX2018\n    pixel.x *= iResolution.x/iResolution.y;\n    #endif\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n\n    vec3 ro = camPos(Time);\n    vec3 rd = vec3(pixel, 2.0)+vec3(mv, 0.0)*1.0;\n    mat3 ca = setCamera(ro, camPos(Time+3.0), vec3(0.0, 1.0, 0.0));\n\n    rd = ca*normalize(rd);\n    fragColor = pixColor(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[939, 1035, 1057, 1057, 1103], [1105, 1169, 1196, 1196, 1752], [1754, 1817, 1839, 1839, 2004], [2006, 2006, 2037, 2037, 2227], [2229, 2229, 2307, 2307, 2958], [2960, 3004, 3030, 3078, 3260], [3262, 3262, 3282, 3282, 3307], [3351, 3445, 3516, 3516, 3707], [3709, 3709, 3769, 3769, 4085], [4087, 4087, 4120, 4120, 7791], [7793, 7858, 7921, 7921, 8071], [8073, 8073, 8095, 8095, 8135], [8137, 8137, 8194, 8194, 9117]]}
{"id": "4stGWN", "name": "From Bohr to Heisenberg", "author": "CartesianOwl", "description": "Testing the water with glsl shading!  \n\nThe raytracing implementation was borrowed from iq.  My complements to the chef!  Thank you for creating this website.  :)\n\nRaytracing implementation taken from here:\nhttps://www.shadertoy.com/view/Xds\n", "tags": ["raytracing", "spheres", "physics"], "likes": 3, "viewed": 319, "published": "Public", "date": "1449708468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// Altered by CartesianOwl - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n        return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat length2( vec2 p )\n{\n        return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n        p = p*p*p; p = p*p;\n        return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n        p = p*p; p = p*p; p = p*p;\n        return pow( p.x + p.y, 1.0/8.0 );\n}\n\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n        return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opTwist2( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = cos(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    float time = iTime;\n    vec2 res = opU( vec2( sdPlane(     pos - vec3(0.0, -5.0, 0.0)), 1.0 ),\n                        vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    \n   \n    for (float i = 0.0; i < 15.0; i += 1.0)\n    {\n        \n    \tres = opU( res, vec2( sdSphere(    opTwist2(pos)-vec3( cos(0.1*i*time),sin(0.1*i*time), 0.0), 0.25 ), 46.9 ) );\n    }\n    \n    for ( float i = 0.0; i < 15.0; i += 1.0)\n    {\n        \n    \tres = opU( res, vec2( sdSphere(    pos-vec3( cos(0.1*i*time),sin(0.1*i*time), 0.0), 0.25 ), 46.9 ) );\n    }\n    \n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n        float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n            vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n            m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n        float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n                float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n        vec3 eps = vec3( 0.001, 0.0, 0.0 );\n        vec3 nor = vec3(\n            map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n            map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n            map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n        return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n        float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n        float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n                col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n                \n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n                vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n                float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n                float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n                vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n                brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n                brdf += 0.02;\n                col = col*brdf;\n\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n        return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n                 \n        float time = 15.0 + iTime;\n\n        // camera       \n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        \n        // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render   \n    vec3 col = render( ro, rd );\n\n        col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stGWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[159, 412, 437, 437, 459], [461, 461, 496, 496, 522], [525, 525, 561, 561, 660], [664, 664, 689, 689, 733], [735, 735, 760, 760, 832], [834, 834, 859, 859, 938], [942, 1016, 1049, 1049, 1075], [1077, 1077, 1107, 1107, 1147], [1149, 1149, 1179, 1179, 1208], [1210, 1210, 1234, 1234, 1366], [1368, 1368, 1393, 1393, 1525], [1527, 1601, 1626, 1626, 2205], [2207, 2207, 2247, 2247, 2858], [2861, 2861, 2935, 2935, 3217], [3219, 3219, 3251, 3251, 3514], [3516, 3516, 3558, 3558, 3864], [3869, 3869, 3908, 3908, 5637], [5639, 5639, 5691, 5691, 5896], [5898, 5898, 5955, 5955, 6641]]}
{"id": "4stGzj", "name": "One Phone", "author": "dr2", "description": ".. to rule them all", "tags": ["raymarching", "android", "cellphone"], "likes": 4, "viewed": 604, "published": "Public API", "date": "1450898785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"One Phone\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  const vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r) {\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrShCylDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nmat3 RMatFromEuAng (vec3 eu)\n{\n  vec4 q, p1, p2, p3;\n  float a1, a2, a3, c1, s1, p4w;\n  a1 = 0.5 * eu.y;\n  a2 = 0.5 * (eu.x - eu.z);\n  a3 = 0.5 * (eu.x + eu.z);\n  s1 = sin (a1);\n  c1 = cos (a1);\n  q = vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3), c1 * cos (a3));\n  p1 = 2. * q.x * q;\n  p2.yzw = 2. * q.y * q.yzw;\n  p3.zw  = 2. * q.z * q.zw;\n  p4w    = 2. * q.w * q.w - 1.;\n  return mat3 (p1.x + p4w,  p1.y - p3.w, p1.z + p2.w,\n               p1.y + p3.w, p2.y + p4w,  p2.z - p1.w,\n               p1.z - p2.w, p2.z + p1.w, p3.z + p4w);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 objMat;\nvec3 sunDirMv, qHit, ltDir, phSize;\nvec2 scrnSize;\nfloat dstFar, dstFarMv, tCur, rAngH, rAngL, rAngA, gDisp;\nint idObj, idObjMv;\nbool walk, hOr, vOr;\nconst int idPhScrn = 10, idPhFace = 11, idRing = 12, idLens = 13,\n   idBut = 14, idSock = 15;\n\nvec3 BgColMv (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDirMv), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    col = mix (vec3 (0.6, 0.5, 0.3),\n       0.9 * (vec3 (0.1, 0.2, 0.4) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat ObjDfMv (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  hGap = 2.5;\n  bf = PrBox2Df (p.xz, vec2 (7. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  bFac = (ip.x == 0. && ip.y == 0.) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFarMv;\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = pp;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.)));\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 1; }\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 2; }\n  d = p.y + 1.;\n  if (d < dMin) { dMin = d;  idObjMv = 0;  qHit = p; }\n  return dMin;\n}\n\nfloat ObjRayMv (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDfMv (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFarMv) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNfMv (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDfMv (p + e.xxx), ObjDfMv (p + e.xyy),\n     ObjDfMv (p + e.yxy), ObjDfMv (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFarMv;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjColMv (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  if (idObjMv == 1) col = vec3 (0.65, 0.8, 0.2);\n  else if (idObjMv == 2) col = vec3 (0.8, 0.8, 0.);\n  else col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.5, 0.4),\n     (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  return col * (0.3 + 0.7 * max (dot (vn, sunDirMv), 0.)) +\n     0.3 * pow (max (0., dot (sunDirMv, reflect (rd, vn))), 64.);\n}\n\nfloat ObjSShadowMv (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 15; j ++) {\n    h = ObjDfMv (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 28.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 + (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nvec3 ShowSceneMv (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, refl;\n  int idObjT;\n  dstHit = ObjRayMv (ro, rd);\n  if (dstHit < dstFarMv) {\n    ro += rd * dstHit;\n    idObjT = idObjMv;\n    vn = ObjNfMv (ro);\n    col = ObjColMv (rd, vn, dstHit);\n    idObjMv = idObjT;\n    if (idObjMv > 0) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRayMv (ro, rd);\n      if (dstHit < dstFarMv) {\n        ro += rd * dstHit;\n\t    c = ObjColMv (rd, ObjNfMv (ro), dstHit);\n      } else {\n        c = BgColMv (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= (0.8 + 0.2 * ObjSShadowMv (ro, sunDirMv));\n  } else {\n    col = BgColMv (ro, rd);\n  }\n  return col;\n}\n\nvec3 ScrnCol (vec2 w)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, col;\n  float f;\n  bool isMv;\n  isMv = true;\n  if (hOr) {\n    w = w.yx;\n    w.x *= -1.;\n    w /= scrnSize.y;\n  } else {\n    w /= scrnSize.x;\n    if (abs (w.y) > scrnSize.x / scrnSize.y) isMv = false;\n  }\n  if (! vOr) w *= -1.;\n  if (isMv) {\n    ro = TrackPath (tCur);\n    vd = normalize (vec3 (0., 2., 0.) - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (vec3 (w, 1.));\n    col = ShowSceneMv (ro, rd);\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid SetState ()\n{\n  float tCyc, wkSpd;\n  wkSpd = 0.7;\n  tCyc = mod (wkSpd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (wkSpd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  phSize = vec3 (0.85, 0.015, 1.55);\n  scrnSize = phSize.xz - vec2 (0.05, 0.2);\n  sunDirMv = normalize (vec3 (1., 2., 1.));\n  dstFarMv = 150.;\n  dstFar = 50.;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p = objMat * p;\n  q = p;\n  d = min (PrCylDf (q - vec3 (0.5, 0., 1.) * phSize, phSize.y, 0.05 * phSize.z),\n     PrCylDf (q - vec3 (0., 0., -1.) * phSize, 1.2 * phSize.y, 0.05 * phSize.z));\n  d = max (PrRoundBoxDf (q, phSize, 0.03), - d); \n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idPhFace; }\n  q = p;\n  q.yz -= vec2 (- 2.3, 0.8) * phSize.yz;\n  d = PrShCylDf (q.xzy, 0.1 * phSize.x, 0.12 * phSize.x, 2.3 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idRing; }\n  d = PrCylDf (q.xzy, 0.1 * phSize.x, 1.5 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idLens; }\n  q = p;\n  q.yz -= vec2 (- 1.8, 0.75) * phSize.yz;\n  q.x = abs (q.x) - 0.3 * phSize.x;\n  d = PrShCylDf (q.xzy, 0.04 * phSize.x, 0.05 * phSize.x, 1.8 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idRing; }\n  q = p;\n  q.yz -= vec2 (- 2., 0.45) * phSize.yz;\n  q.z = abs (q.z) - 0.09 * phSize.z;\n  d = PrRoundBoxDf (q, vec3 (0.16, 0.05, 0.06) * phSize, 0.03);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBut; }\n  q = p;\n  d = min (PrCylDf (q - vec3 (0.5, 0., 0.97) * phSize, phSize.y, 0.05 * phSize.z),\n     PrCylDf (q - vec3 (0., 0., -0.97) * phSize, 1.2 * phSize.y, 0.05 * phSize.z));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idSock; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, vnn, col;\n  float dstHit;\n  int idObjT;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idPhFace) {\n      vnn = objMat * vn;\n      if (vnn.y > 0.999) {\n        if (abs (qHit.x) < scrnSize.x && abs (qHit.z) < scrnSize.y) {\n\t      col = ScrnCol (qHit.xz);\n\t      idObj = idPhScrn;\n\t    } else col = (abs (qHit.x) < 0.1 * phSize.x &&\n\t       abs (qHit.z + 0.93 * phSize.z) < 0.03 * phSize.z) ?\n\t       vec3 (0.8, 0.8, 0.3) : vec3 (0.1);\n      } else if (vnn.y < -0.999) {\n        if (abs (abs (qHit.x) - 0.02 * phSize.x) < 0.006 * phSize.x) {\n\t      col = vec3 (0.5) * SmoothBump (0.15, 0.85, 0.1,\n\t         mod (30. * qHit.z / phSize.z, 1.));\n        } else {\n\t      vnn = VaryNf (31. * qHit, vec3 (0., -1., 0.), 0.5);\n          vn = vnn * objMat;\n          col = vec3 (0.);\n\t    }\n      } else col = vec3 (0.48, 0.48, 0.5);\n    } else if (idObj == idRing) col = vec3 (0.6, 0.65, 0.6);\n    else if (idObj == idLens) col = vec3 (0.1);\n    else if (idObj == idBut) col = vec3 (0.65, 0.6, 0.6);\n    else if (idObj == idSock) col = vec3 (0.1);\n    if (idObj != idPhScrn) col = col * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n  } else col = vec3 (0.7, 0.5, 0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, sv, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, ss;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  SetState ();\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 2. * pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  objMat = RMatFromEuAng (2. * pi * mod (vec3 (0.27, 0.34, 0.11) *\n     0.3 * tCur, 1.));\n  sv = objMat[1];\n  if (abs (sv.y) > 4. * max (abs (sv.x), abs (sv.z))) {\n    hOr = false;\n    vOr = true;\n  } else {\n    hOr = (abs (sv.z) < abs (sv.x));\n    vOr = (hOr ? (sv.x >= 0.) : (sv.z >= 0.));\n  }\n  rd = normalize (vec3 (uv, 5.)) * vuMat;\n  ro = vec3 (0., 0., -10.) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  col = ShowScene (ro, rd);\n  ss = dot (uv, uv);\n  col = mix (col, vec3 (0.1, 0.1, 0.5), smoothstep (0.9, 1., ss * ss));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stGzj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 264, 288, 288, 335], [337, 337, 362, 362, 561], [563, 563, 584, 584, 723], [725, 725, 754, 754, 966], [968, 968, 1007, 1007, 1230], [1232, 1232, 1278, 1278, 1325], [1327, 1327, 1360, 1360, 1444], [1446, 1446, 1479, 1479, 1506], [1508, 1508, 1550, 1550, 1601], [1603, 1603, 1660, 1660, 1748], [1750, 1750, 1804, 1804, 1993], [1995, 1995, 2025, 2025, 2536], [2538, 2538, 2568, 2568, 2642], [2644, 2644, 2701, 2701, 2784], [3044, 3044, 3077, 3077, 3614], [3616, 3616, 3640, 3640, 4990], [4992, 4992, 5027, 5027, 5207], [5209, 5209, 5232, 5232, 5448], [5450, 5450, 5485, 5485, 5814], [5816, 5816, 5862, 5862, 6211], [6213, 6213, 6252, 6252, 6465], [6467, 6467, 6493, 6493, 7234], [7236, 7236, 7273, 7273, 7983], [7985, 7985, 8008, 8008, 8615], [8617, 8617, 8635, 8635, 9266], [9268, 9268, 9290, 9290, 10608], [10610, 10610, 10643, 10643, 10819], [10821, 10821, 10842, 10842, 11050], [11052, 11052, 11087, 11087, 12502], [12504, 12504, 12560, 12560, 13698]]}
{"id": "4stGzX", "name": "Ray marched scene for beginners", "author": "consoleartist", "description": "This one is for beginners and is my first attempt at creating a ray marched scene. The goals were to setup a navigable camera, construct a simple scene, and shade it with shadows and reflections", "tags": ["raymarch", "tutorial", "sphere", "lambert", "plane"], "likes": 8, "viewed": 1039, "published": "Public API", "date": "1451344373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Some of the sources I used to construct this scene:\n//Distance Functions (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n//https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n\nfloat sphere (vec3 rayPos, vec3 center, float radius) //sphere primitive with offset controls\n{\n    return length(rayPos - center) - radius;\n}\n\n\nfloat sdPlane( vec3 rayPos, vec4 n )\n{\n  n = normalize(n); // orientation of plane, n must be normalized!\n  return dot(rayPos,n.xyz) + n.w;\n}\n\n\nfloat uberSphere(vec3 rayPos) //a more complex sphere shape using booleans\n{\n   rayPos -= vec3(0.0, sin(iTime * 2.0) +2.0, 0.0); //bounce animation\n   \n\n   \n   //sphere \n   return sphere(rayPos, vec3(0.0, 0.0, 0.0), 2.0);\n    \n   \n    \n             \n}\n\n//the final assembled scene\nfloat scene(vec3 rayPos)\n{\n   float dist_a = sphere(rayPos, vec3(-0.0, -0.0, 0.0), 3.0);\n   float dist_b = sdPlane(rayPos, vec4(0.0, 1.0, 0.0, 1.0));\n   float booleanFloor = max(dist_b, -dist_a); // this cuts a sphere into the plane\n  \n   //return min(uberSphere(rayPos),booleanFloor); //this combines the floor with our uber sphere for the final scene\n   return min(uberSphere(rayPos),dist_b); // simplifed the scene with this line. comment this out and uncomment the above line for some additional boolean logic\n}\n\n//normals\nvec3 normal(vec3 rayPos)\n{\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(scene(rayPos + e.xyy) - scene(rayPos - e.xyy),\n                          scene(rayPos + e.yxy) - scene(rayPos - e.yxy),\n                          scene(rayPos + e.yyx) - scene(rayPos - e.yyx)));\n}\n\n//fresnel\nfloat fresnel(vec3 n, vec3 eye)\n{\n    \n    return 1.0 - max(dot(n,eye), 0.0);\n    \n}\n\n\n//Lambert Diffuse Lighting\nfloat diffuse(vec3 normal, vec3 lightVector)\n{\n    return max(dot(normal, lightVector), 0.0);\n}\n\n//hard shadows. Now we march from the current rayPos/Surface toward the lightsource. \n//If we hit an object in the scene then the surface point is in shadow and we return 0.0\nfloat shadow(vec3 rayPos, vec3 lightDir, vec3 normal)\n{\n    float sVal = 1.0; //initial shadow value.sVal gets mutiplied with diffuse lighting\n    float sEPS = 0.01;// our shadow epsilon/precision value\n    vec3 ro = rayPos + (normal * sEPS); //reduces self-shadow artifacts since we are starting the march slightly above our surface\n    vec3 rd = lightDir; // we are now marching from our surface to light source.\n    float sDist; //initializing our shadow distance value\n    \n    \n      for(int i = 0; i < 36; i++)\n      {\n        sDist = scene(ro); //comparing shadow ray position with our scene\n        if(sDist < sEPS)\n        {\n            sVal = 0.0;\n            break;\n        }\n        ro += rd * sDist;\n     }\n    \n    return sVal;\n}\n\n//reflections\nfloat reflection(vec3 eye, vec3 rayPos, vec3 n, vec3 lightDir)\n{\n    float rVal = 0.0;  //reflection boolean value: 0 = miss, 1 = hit\n    vec3 refVec = normalize(reflect(-eye, n)); //normalized reflection vector\n    float rEPS = 0.01; //reflection EPSILON\n    vec3 ro = rayPos + (n * rEPS);// starts marching slightly \"above\" our surface to lessen artifacts\n    vec3 rd = refVec;\n    float rDist; //initializing reflection distance value. This gets plugged into the scene function\n    float rShadowVal = 1.0;\n    for(int i = 0; i < 24; i++)\n    {\n        rDist = scene(ro);\n        if(rDist < rEPS)\n        {\n            \n          float rDiffuseVal = max(dot(normal(ro), lightDir), 0.0);\n            if(rDiffuseVal > 0.0) //then we calculate reflection shadow ray\n            {\n              rShadowVal = shadow(ro, lightDir, normal(ro));\n            }\n            \n            rVal = rDiffuseVal * rShadowVal;\n            break;\n        }\n        ro += rd * rDist;\n    }\n        \n    return rVal;\n        \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // color outs\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float alpha = 1.0;\n    \n    //Scene directional light\n    vec3 lightPos = vec3( sin(iTime * 2.0) * 5.0, 3.0, cos(iTime * 2.0) * 5.0); //this makes the lightsource rotate around the scene center\n    vec3 lightDir = normalize(lightPos - vec3(0.0, 0.0, 0.0)); //normalized light vector derived from lightPos. This vector is useful for shading and marching shadow rays\n    \n    \n\t//Normalized device coordinates and aspect correction   \n    vec2 uv = fragCoord.xy / iResolution.xy;   \n    uv = uv * 2.0 - 1.0; // remap range from 0...1 to -1...1\n    \n    float aspectRatio = iResolution.x/ iResolution.y;\n    uv.x *= aspectRatio; //aspect correction\n    \n    //Mouse values for navigation or other shenanigans. Normalized device coords and aspect correction to match UVs\n    vec2 daMouse = iMouse.xy/ iResolution.xy;\n    daMouse = daMouse * 2.0 - 1.0;\n    daMouse.x *= aspectRatio;\n   \n    // camera controls (horizontal mouse = rotate, vertical mouse = elevation)\n    vec3 camControls;\n    camControls.x = sin(daMouse.x * 2.0) * 5.0;\n    camControls.y = (daMouse.y * 0.5 + 0.5) * 9.0;\n    camControls.z = cos(daMouse.x * 2.0) * 5.0;\n    \n    //mapping camera to UV cordinates\n    vec3 cameraOrigin = vec3(camControls); //cam controls\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDirection = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upVector, cameraOrigin));\n    vec3 cameraUp = cross(cameraDirection, -cameraRight); //negate cameraRight to flip properly?\n   \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDirection);\n    \n    //Precision value used in the ray marching loop below. This number equals our \"surface\". If the distance returned from rayPos \n    //to our scene function is less than this then we have \"touched\" our object and break out of the loop to do normals and lighting\n    const float EPSILON = 0.01; \n    \n    //inital ray position per pixel. This is the value that gets marched forward and tested    \n    vec3 rayPos = cameraOrigin; \n    float shadowVal = 1.0;\n    \n    \n    for (int i = 0; i < 200; i++) // the larger the loop the more accurate/slower the render time\n    {\n        float dist = scene(rayPos); // plug current rayPos into our scene function\n        \n        if (dist < EPSILON) //then the ray has hit our surface so we calculate normals and lighting at this point\n        {\n            \n            vec3 n = normal(rayPos);\n            vec3 eye = normalize(cameraOrigin - rayPos);\n            float diffuseVal = diffuse(n, lightDir);\n            if(diffuseVal > 0.0) //then we calculate shadow ray\n            {\n                shadowVal = shadow(rayPos, lightDir, n);\n            }\n            float refVal = reflection(eye, rayPos, n, lightDir);\n            float fresnelVal = fresnel(n, eye);\n            \n            \n            color = vec3((diffuseVal * shadowVal) + (refVal * fresnelVal));\n            break;\n        }\n        \n        rayPos += dist * rayDir; //if nothing is hit we march forward and try again        \n    }\n    \n    fragColor = vec4(color,alpha);//final color output\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 246, 341, 341, 388], [391, 391, 429, 429, 532], [535, 535, 611, 611, 786], [788, 816, 842, 842, 1331], [1333, 1343, 1369, 1369, 1627], [1629, 1639, 1672, 1672, 1723], [1726, 1753, 1799, 1799, 1848], [1850, 2025, 2080, 2080, 2768], [2770, 2784, 2848, 2848, 3793], [3800, 3800, 3857, 3875, 7067]]}
{"id": "4tSXDt", "name": "Touch with LeapMotion Hand Test", "author": "edankwan", "description": "It is a test for the LeapMotion WebGL demo http://www.edankwan.com/experiments/touch/", "tags": ["test"], "likes": 1, "viewed": 411, "published": "Public", "date": "1451414690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float INTERSECTION_PRECISION = 0.001;\nconst float NEAR = 0.1;\nconst float FAR = 2000.0;\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\nfloat sdCappedCylinderLower( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y + h.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat sdFingerBone( in vec3 p, in mat4 fingerBone) {\n    \n    vec3 scale = vec3(fingerBone[0][3], fingerBone[1][3], fingerBone[2][3]);\n    \n    fingerBone[0][3] = 0.0;\n    fingerBone[1][3] = 0.0;\n    fingerBone[2][3] = 0.0;\n    \n    p = (fingerBone * vec4(p, 1.0)).xyz;\n    \n    return min(\n        sdSphere(p, scale.x),\n        sdCappedCylinderLower(p, vec2(scale.x, scale.y / 2.0))\n    );\n}\n\nfloat map( in vec3 p, in mat4[16] data ) {\n    float d = FAR;\n    \n    mat4 palmData = data[0];\n    vec3 scale = vec3(palmData[0][3], palmData[1][3], palmData[2][3]);\n    \n    palmData[0][3] = 0.0;\n    palmData[1][3] = 0.0;\n    palmData[2][3] = 0.0;\n    \n    d = min(d, sdHexPrism((palmData * vec4(p, 1.0)).xyz, vec2(scale.x, scale.z / 2.0)));\n    \n    for( int i = 1; i < 16; i++ ) {\n        d = min(d, sdFingerBone(p, data[i]));\n    }\n    \n    \n    //d = min(d, sdHexPrism(p, vec2(100.0, 10.0)));\n    \n    //d = min(d, sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)));\n    \n    //d = min(d, sdCappedCylinderLower(p, vec2(100.0, 100.0)));\n    \n    return d;\n}\n\nvec3 calcNormal_old( in vec3 pos, in mat4[16] data ) {\n    vec3 eps = vec3(0.002,0.0,0.0);\n    return normalize( vec3(\n           map(pos+eps.xyy, data) - map(pos-eps.xyy, data),\n           map(pos+eps.yxy, data) - map(pos-eps.yxy, data),\n           map(pos+eps.yyx, data) - map(pos-eps.yyx, data) ) );\n}\n\nvec3 calcNormal( in vec3 pos, in mat4[16] data )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*.01;\n    return normalize( e.xyy*map( pos + e.xyy, data ) +\n                      e.yyx*map( pos + e.yyx, data ) +\n                      e.yxy*map( pos + e.yxy, data ) +\n                      e.xxx*map( pos + e.xxx, data ) );\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd, in mat4[16] data ) {\n    \n    float d = NEAR;\n    float sumd = NEAR;\n    \n    vec3 p = ro + rd * d;\n    \n    float t = 0.0;\n    for( int i=0; i<50; i++ ) { \n        d = map( p, data );\n        if(d < INTERSECTION_PRECISION || sumd > FAR) break;\n        \n        sumd += d;\n        p += rd * d;\n    }\n\n    return vec4(p, d);\n    \n}\n\n\nvoid render(in vec3 ro, in vec3 rd, inout vec3 col, in mat4[16] data ) {\n\n    vec4 res = intersect(ro, rd, data);\n    vec3 pos = res.xyz;\n    vec3 nor = calcNormal( pos, data );\n    vec3 ref = reflect( rd, nor );\n    \n    if (res.w < INTERSECTION_PRECISION) {\n        col = vec3(1.0, 1.0, 1.0);\n    \n        // lighitng\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00);\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00);\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25);\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n        brdf += 0.02;\n        col = col*brdf;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    mat4 data[16];\n    \n\t// data dumped from the webpage\n    data[0] = mat4( 0.5071753263473511, 0.37931835651397705, 0.8147028684616089, 33.020286560058594, 0.8555222749710083, -0.5918408632278442, -0.3567546010017395, 36.038330078125, 0.2751452326774597, 0.8457598090171814, -0.6530782580375671, 25.9517879486084, -145.39219665527344, 101.49678039550781, 68.79705047607422, 1.0);\n    data[1] = mat4( 0.5983963012695312, 0.758206307888031, -0.25893062353134155, 8.985650062561035, 3.3658409392955946e-10, 0.32317841053009033, 0.9463380575180054, 44.30060958862305, 0.801200270652771, -0.5662851929664612, 0.19338877499103546, 8.985650062561035, -34.11090850830078, -88.48513793945312, -147.6454620361328, 1.0);\n    data[2] = mat4( 0.8364007472991943, 0.5346810817718506, -0.12062347680330276, 8.985650062561035, 1.5648309314997277e-8, 0.22006824612617493, 0.9754844903945923, 30.258787155151367, 0.5481184720993042, -0.8158959150314331, 0.18406522274017334, 8.985650062561035, -44.376338958740234, -88.93354797363281, -159.31216430664062, 1.0);\n    data[3] = mat4( 0.9921209812164307, 0.12517434358596802, -0.005222442094236612, 8.985650062561035, 5.661379143262479e-10, 0.0416850782930851, 0.9991307854652405, 15.952950477600098, 0.12528324127197266, -0.9912586212158203, 0.0413566417992115, 8.985650062561035, -62.56550598144531, -50.18754196166992, -173.701904296875, 0.9999999403953552);\n    data[4] = mat4( 0.9149901270866394, 0.36118781566619873, -0.1798233836889267, 8.583100318908691, -2.1303717900877928e-8, 0.4456852078437805, 0.8951897621154785, 38.1278076171875, 0.4034762680530548, -0.8190897703170776, 0.40779757499694824, 8.583100318908691, -12.331381797790527, -154.5205841064453, -173.60504150390625, 1.0);\n    data[5] = mat4( 0.8975245356559753, 0.44039908051490784, -0.022325173020362854, 8.583099365234375, 1.3945320453956356e-8, 0.05062802881002426, 0.9987175464630127, 21.450544357299805, 0.44096460938453674, -0.8963735103607178, 0.04543989151716232, 8.583100318908691, -9.800576210021973, -94.13629913330078, -220.8803253173828, 1.0);\n    data[6] = mat4( 0.8854115605354309, 0.44700491428375244, 0.12740905582904816, 8.583100318908691, -4.148359167288618e-8, -0.27411115169525146, 0.961698055267334, 11.688687324523926, 0.46480798721313477, -0.8514986038208008, -0.24270115792751312, 8.583099365234375, -7.581989765167236, -29.797914505004883, -239.5002899169922, 1.0);\n    data[7] = mat4( 0.9694989919662476, 0.21628578007221222, -0.115291528403759, 8.429749488830566, 6.317946166234378e-10, 0.4703948199748993, 0.8824560642242432, 42.77682876586914, 0.24509523808956146, -0.8555402755737305, 0.45604729652404785, 8.429749488830566, 2.7783355712890625, -160.21107482910156, -168.93592834472656, 1.0);\n    data[8] = mat4( 0.9228090643882751, 0.3836064040660858, -0.03563050553202629, 8.429750442504883, -2.2501051688550433e-8, 0.09248493611812592, 0.9957140684127808, 25.23654556274414, 0.3852575719356537, -0.9188539385795593, 0.08534594625234604, 8.429749488830566, 11.869654655456543, -106.56092071533203, -217.85340881347656, 1.0);\n    data[9] = mat4( 0.8772222995758057, 0.4674670398235321, 0.10934170335531235, 8.429750442504883, 2.0535672717869602e-8, -0.22775517404079437, 0.9737184047698975, 12.829567909240723, 0.4800843894481659, -0.8541674613952637, -0.19979192316532135, 8.429750442504883, 20.8353214263916, -43.19974136352539, -239.99951171875, 0.9999999403953552);\n    data[10] = mat4( 0.9830896258354187, 0.16083373129367828, -0.08756321668624878, 8.02145004272461, 2.3755797329272355e-10, 0.4781606197357178, 0.8782724142074585, 39.651947021484375, 0.1831251084804535, -0.8634204864501953, 0.47007474303245544, 8.02145004272461, 19.648418426513672, -152.8498992919922, -161.8258819580078, 1.0);\n    data[11] = mat4( 0.9358811378479004, 0.3485816419124603, -0.05116010084748268, 8.02145004272461, 8.598387779557015e-9, 0.145210862159729, 0.9894007444381714, 24.584932327270508, 0.3523159325122833, -0.9259614944458008, 0.1359000951051712, 8.02145004272461, 29.295255661010742, -107.8292007446289, -205.30209350585938, 1.0);\n    data[12] = mat4( 0.8877815008163452, 0.4560469090938568, 0.06217017024755478, 8.02145004272461, 6.990820811125786e-9, -0.13507471978664398, 0.9908353686332703, 12.711485862731934, 0.46026504039764404, -0.8796454071998596, -0.11991684138774872, 8.02145004272461, 38.15982437133789, -55.37266540527344, -226.62335205078125, 0.9999999403953552);\n    data[13] = mat4( 0.9999863505363464, 0.0046876524575054646, -0.0022922460921108723, 7.12529993057251, -9.570149360482727e-12, 0.4392881691455841, 0.8983461856842041, 31.380311965942383, 0.005218090955168009, -0.8983339071273804, 0.43928220868110657, 7.12529993057251, 30.588350296020508, -136.5830535888672, -154.39779663085938, 0.9999999403953552);\n    data[14] = mat4( 0.9570824503898621, 0.2880112826824188, -0.03229079768061638, 7.12529993057251, -1.515598491153014e-8, 0.11141838878393173, 0.9937736392021179, 17.358001708984375, 0.2898157835006714, -0.9511232972145081, 0.10663658380508423, 7.12529993057251, 44.9504508972168, -83.1126480102539, -192.5747833251953, 1.0);\n    data[15] = mat4( 0.880604088306427, 0.4666370451450348, 0.08237865567207336, 7.12529993057251, -1.8095587250854805e-8, -0.17384862899780273, 0.9847723841667175, 11.763103485107422, 0.4738526940345764, -0.867194652557373, -0.15309181809425354, 7.12529993057251, 56.18177795410156, -27.11683464050293, -206.44894409179688, 1.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 2.1;\n    \n    // camera\n    vec3 ro = vec3(0.0, 200.0, 500.0);\n    \n    ro.x = sin(time) * 400.0;\n    ro.z = cos(time) * 400.0;\n    \n    vec3 ta = vec3(0.0, 200.0, 0.0);\n    \n    // look at\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n    \n    \n    // ray direction\n    vec3 rd = normalize( camMat * vec3(uv, 2.0) );\n    \n    vec3 col = vec3(0.9);\n    \n    render(ro, rd, col, data);\n    \n    // gamma\n    fragColor = vec4(pow(col, vec3(0.75)), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 130, 130, 154], [156, 156, 189, 215, 246], [247, 247, 283, 283, 367], [370, 370, 416, 416, 521], [523, 523, 587, 587, 765], [767, 767, 819, 819, 1159], [1161, 1161, 1203, 1203, 1810], [1812, 1812, 1866, 1866, 2116], [2118, 2118, 2168, 2168, 2431], [2434, 2434, 2494, 2494, 2804], [2807, 2807, 2879, 2879, 3964], [3966, 3966, 4023, 4023, 10069]]}
{"id": "ld33z2", "name": "Terrain thingy - Raymarching", "author": "Lallis", "description": "Trying out some terrain marching. It's obviously still lacking clouds (and maybe rivers?) but I don't think I'll ever get them done so publishing this as it is. :)", "tags": ["procedural", "raymarching", "terrain"], "likes": 6, "viewed": 310, "published": "Public", "date": "1450856109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//some fbm for water color; quite expensive and doesn't make much of a difference\n#define WATERFBM\n\n//mouse rotate\n#define MOUSE\n\n#define DRAWDISTANCE 100.0\n#define time iTime*0.75\n#define WATERH 1.75\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453);\n}\n\nfloat smooth3D(vec3 p)\n{\n    vec3 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n\tfloat p0 = noise3D(p);\n\tfloat x = noise3D(p+vec3(1.0,0.0,0.0));\n\tfloat y = noise3D(p+vec3(0.0,1.0,0.0));\n\tfloat z = noise3D(p+vec3(0.0,0.0,1.0));\n\tfloat xy = noise3D(p+vec3(1.0,1.0,0.0));\n\tfloat xz = noise3D(p+vec3(1.0,0.0,1.0));\n\tfloat yz = noise3D(p+vec3(0.0,1.0,1.0));\n\tfloat xyz = noise3D(p+1.0);\n\t\n    return mix(\tmix(\tmix(p0, x, \t f.x), \n                    \tmix(y, \txy,  f.x), \tf.y), \n               \tmix(\tmix(z, \txz,\t f.x), \n                    \tmix(yz, xyz, f.x), \tf.y), \tf.z);\n}\n\nfloat fbm3D(vec3 p)\n{\n \tfloat f = 0.5000*smooth3D(p*1.00);\n    \t  f+= 0.2500*smooth3D(p*2.01);\n    \t  f+= 0.1250*smooth3D(p*4.02);\n    \t  f/= 0.875;\n    return f;\n}\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat noise2D(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat smooth2D(vec2 p)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f); // smoothing\n    \n\tfloat p0 = noise2D( p );\n\tfloat x = noise2D( p+vec2( 1.0, 0.0 ) );\n\tfloat y = noise2D( p+vec2( 0.0, 1.0 ) );\n\tfloat xy = noise2D( p+vec2( 1.0, 1.0 ) );\n    return mix(\tmix( p0, x, f.x ),\n        \t\tmix( y, xy, f.x ), f.y );\n}\nfloat fbm(vec2 rp)\n{\n    float f = 0.0;\n    f += smooth2D( rp*1.0 )*0.5;\n    f += smooth2D( rp*2.0 )*0.25;\n    f += smooth2D( rp*4.0 )*0.125;\n    f += smooth2D( rp*8.0 )*0.0625;\n    f /= 0.9375;\n    return f;\n}\nfloat terrain(vec3 rp)\n{\n    float d = 0.0;\n    d += smooth2D( rp.xz*0.25 )*2.5;\n    d += smooth2D( rp.xz*0.5 )*1.0; \n    d += abs(sin((rp.x+rp.z)+fbm(rp.xz)*3.14*2.0))*0.10;\n    d += abs(sin((rp.x-rp.z)+fbm(rp.xz)*3.14*2.0))*0.10;\n    float f = 7.5;\n    rp/=f;\n    float asd1 = clamp(abs(2.0/3.14*asin( sin(2.0*3.14/16.0*((rp.x+rp.z)+fbm(rp.xz+21.)*3.14*8.0) ) ) ), 0.0, 1.0)*1.5;\n    rp*=f;\n\td += asd1;\n    d = min(rp.y-d, rp.y-WATERH); \n    return d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.02 ,0.0,0.0);\n\treturn normalize( vec3(\n           terrain(rp+eps.xyy) - terrain(rp-eps.xyy),\n           terrain(rp+eps.yxy) - terrain(rp-eps.yxy),   //from iq\n           terrain(rp+eps.yyx) - terrain(rp-eps.yyx) ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float td, float dmax)\n{\n\tfloat res = 1.0;\n    float ld = 0.1;\n    float ldmax = 25.0; \n    vec3 rp = ro+rd*ld;\n    \n\tfor(int i = 0; i<128; i++ )\n\t{\n\t\tfloat d = terrain(rp);\n\t\tif(d < 0.01) return 0.0;\n\t\tres = min(res, 8.0*d);\n        if(ld>ldmax) break;\n        ld += d*0.5*(1.0+td/dmax);\n\t\trp = ro+rd*ld;\n\t}\n\treturn res;\n}\n\nvec3 terrainColor( vec3 rp, vec3 n )\n{\n    vec3 col = texture( iChannel1, rp.xz).rgb*0.15;\n    float snow = texture(iChannel2, rp.xz*1.0).r;\n    col = mix(col,vec3(0.5),clamp(rp.y-1.5-snow*7.0*fbm(rp.xz),0.0,1.0)*smoothstep(0.5,1.0,dot(n,normalize(vec3(1.0,1.0,0.0)))));\n    \n    col = mix( col, vec3( 0.035,0.045,0.025)*fbm(rp.xz*100.0), smoothstep(0.65, 0.9, n.y)*smoothstep(2.25, 1.0, rp.y-WATERH) );\n    col = mix( col, vec3( 0.085,0.075,0.05 ), smoothstep(0.80, 0.9, n.y)*smoothstep(0.25, 0.0, rp.y-WATERH ) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x*= iResolution.x/iResolution.y;\n    vec3 col = vec3( 0.0 );\n    \n    float z = -9.0;\n    \n    vec3 ro = vec3( 0.0, 0.0, -(1.5+sin(time*0.11))+z );\n    vec3 rd = normalize( vec3( p, z ) - ro );\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ang = vec3( 3.14*0.25, 3.14*1.75, 0.0 );\n    ro *= rot( ang );\n    \n    rd *= rot( ang );\n\trd *= rot( vec3(0.0, 4.0-time*0.06, 0.0) );\n   \n    #ifdef MOUSE\n    rd *= rot(vec3(0.0, m.x*6.28,0.0)); \n    #endif\n    \n    ro.z += sin(time*0.01)*50.0;\n    ro.x += cos(time*0.01)*50.0;\n    \n    float d = 0.0;\n    float td = 0.5;\n    float dmax= DRAWDISTANCE;\n    vec3 rp = ro+rd*td;\n    \n    for( int i = 0; i < 256; i++ )\n    {\n     \td = terrain( rp );\n        if( d < 0.001 ) break;\n        td += d*0.25*(1.0+td/dmax);\n        if( td > dmax ) \n        {\n            td = dmax;\n            break;\n        }\n        rp = ro+rd*td;\n    }\n    rp = ro+rd*td;\n    vec3 s = normalize(vec3(1.0,0.5,0.0));  \n    if( d < 0.001 )\n    {             \n        vec3 n = normal(rp);\n        \n        // http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n        float sha = softShadow( rp, s, td, dmax );\n        float sun = clamp( dot( n, s ), 0.0, 1.0 );\n        float sky = clamp( 0.5 + 0.5*n.y, 0.0, 1.0 );\n        float ind = clamp( dot( n, s*vec3(-1.0,0.0,-1.0) ), 0.0, 1.0 );                       \n        \n        vec3 lighting = vec3(0.0);\n        lighting += sun*vec3(1.34,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lighting += sky*vec3(0.16,0.20,0.28);\n        lighting += ind*vec3(0.40,0.28,0.20);\n        \n        if( rp.y < WATERH+0.001 )\n        {\t\t\t\t\t\t\t\t\t\n            col = vec3( 0.10, 0.13, 0.16 );\n            #ifdef WATERFBM\n            col *= (1.0+0.5*fbm3D(vec3(rp.xz*0.1,time*0.07)*10.0+fbm3D(vec3(rp.xz*0.5,time*0.07)*10.0)));\n            #endif\n        }\n        else\n        {\n            col = terrainColor( rp, n );\n        }\n        \n        col *= lighting;\n    }\n\n\n    float r = min(1.0, td/40.0);\n    r*=r;\n    float rpy = rp.y/4.0;\n    col = mix( col, vec3( 0.68, 0.84, 1.0 )*0.8, min(1.0,r/rpy));  \n    vec3 tmp1 = vec3(smooth3D(rd*200.0))*vec3(0.99,0.99,1.0);\n    tmp1 -= 0.95;\n    tmp1 = max(vec3(0.0),tmp1)*20.0;\n    vec3 tmp2 = mix( vec3( 0.05, 0.15, 0.35 ), tmp1, smoothstep( 0.0, 30.0, rp.y )*smoothstep( 15.0, 35.0, td) );\n    col = mix( col, tmp2, smoothstep( 0.0, 15.0, rp.y )*smoothstep( 15.0, 35.0, td) );  \n    \n    rd -= s;\n\tfloat rdatan = atan(rd.y, rd.z);\n    rd += s;\n    \n    float srd = max(0.0,dot(s,rd))*fbm(vec2(rdatan*4.0,time*0.5)); \n    col = mix(col,vec3(1.0,0.8,0.4),0.18*srd );\n    \n  \tfloat ss = clamp( dot(rd, s), 0.0, 1.0);         //\n    col += 0.4*pow(ss,5.0)*vec3(1.0,0.7,0.5)*2.0;    // from iq's shader https://www.shadertoy.com/view/llj3Rz\n    col += 0.4*pow(ss,64.0)*vec3(1.0,0.9,0.7)*2.0;   //\n    \n    col = clamp(col, 0.0, 1.0);\n    col = pow(col, vec3(0.45));\n    \n    float t = 0.5;\n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018);\n    \n    p.x/=iResolution.x/iResolution.y;\n    col *= smoothstep( 1.325, 0.825, abs(p.x) );\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\n    \n     float jitter = (noise3D(rd)*2.0-1.0)*2.0/256.0;\n    col += jitter;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld33z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 202, 225, 225, 298], [300, 300, 324, 324, 885], [887, 887, 908, 908, 1051], [1053, 1053, 1073, 1073, 1336], [1338, 1338, 1360, 1360, 1428], [1431, 1431, 1455, 1455, 1765], [1766, 1766, 1786, 1786, 1976], [1977, 1977, 2001, 2001, 2432], [2434, 2434, 2456, 2456, 2699], [2701, 2701, 2759, 2759, 3058], [3060, 3060, 3098, 3098, 3598], [3600, 3600, 3657, 3657, 6988]]}
{"id": "ld3GDH", "name": "Jade Gully", "author": "jameswilddev", "description": "This could definitely be sped up quite a lot.", "tags": ["xtreme"], "likes": 3, "viewed": 109, "published": "Public", "date": "1449273214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 spatial;\n\nvec3 chequer(vec2 uv) {\n    uv = fract(uv);\n    return uv.x > 0.5 == uv.y > 0.5 ? vec3(1.0, 1.0, 0.6): vec3(0.6, 0.6, 1.0);\n}\n\n#define PI 3.142\n\nvec2 worldUv;\nvec3 col;\n\nfloat camZ;\n\nvoid platform(float left, float right, float top, float bottom, float front, float back) {    \n    if(left < right) {\n        if(spatial.x < left || spatial.x > right) return;\n    } else {\n    \tif(spatial.x < left && spatial.x > right) return;\n    }\n    \n    float topPos = (1.0 / (spatial.y / top)) + camZ;\n    if(topPos < front) {\n        float y = spatial.y * (front - camZ);\n        if(y > bottom) return;\n        col = vec3(0.3);\n        worldUv = vec2(spatial.x * 6.0, y);\n        return;\n    }\n    if(topPos > back) return;\n    worldUv = vec2(spatial.x * 6.0, topPos);\n    col = vec3(2.0 / ((top / 3.0) + 1.0));\n}\n\nvec3 compute(vec2 coord, vec2 res, float seconds) {\n    coord -= res / 2.0;\n    float extent = min(res.x, res.y);\n    coord.y -= extent / 3.0;\n    spatial = vec2((atan(coord.x, coord.y) / PI * 2.0) + 2.0, length(coord) * 2.0 / extent);\n    seconds *= 0.25;\n    spatial.x += seconds;\n    spatial.x = mod(spatial.x, 4.0);\n    camZ = sin(PI * seconds) * 4.0 + 4.0;\n    \n    col = vec3(0.0);\n    \n    platform(3.75, 0.25, 6.0, 7.0, 5.0, 16.0);\n    \n\tplatform(0.25, 0.375, 3.0, 25.0, 7.0, 9.0);\n    \n    platform(0.25, 0.5, 6.5, 7.0, 14.0, 16.0);\n    platform(0.5, 0.75, 7.0, 7.5, 14.0, 16.0);\n    platform(0.75, 1.0, 7.5, 8.0, 14.0, 16.0);\n    platform(1.0, 1.25, 8.0, 8.5, 6.0, 16.0);\n    platform(1.25, 2.0, 6.0, 8.5, 7.5, 16.0);\n    platform(1.375, 1.625, 7.0, 7.5, 6.0, 7.5);\n    platform(1.75, 2.0, 6.0, 6.5, 6.0, 7.5);\n    platform(2.0, 2.5, 6.0, 8.5, 8.5, 16.0);\n    \n    platform(3.75, 3.8, 3.0, 6.0, 13.0, 15.0);\n    platform(3.625, 3.75, 3.0, 25.0, 13.0, 15.0);\n    \n    platform(0.25, 0.375, 3.0, 9.0, 7.0, 9.0);\n    platform(0.2, 0.25, 3.0, 6.0, 7.0, 9.0);\n    \n    platform(3.75, 3.8, 3.0, 6.0, 7.0, 9.0);\n    platform(3.625, 3.75, 3.0, 25.0, 7.0, 9.0);\n    \n    platform(1.5, 2.5, 2.0, 6.0, 10.0, 16.0);\n    platform(2.5, 2.75, 6.0, 7.0, 7.0, 16.0);\n    platform(2.5, 3.75, 6.0, 7.0, 5.0, 7.0);\n    \n    vec3 color = chequer(worldUv) * col;\n    \n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(compute(fragCoord, iResolution.xy, iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3GDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 38, 38, 140], [198, 198, 288, 288, 818], [820, 820, 871, 871, 2217], [2219, 2219, 2276, 2276, 2344]]}
{"id": "ld3GR8", "name": "pitture", "author": "fresco", "description": "supe supe supe", "tags": ["2d", "noise"], "likes": 0, "viewed": 107, "published": "Public", "date": "1449592721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//    uniform float _ran;\n//    uniform vec3 _rgb;\nfloat hash( vec2 p )\n{\n        float h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p )\n{    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\n        vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ),\n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ),\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n       float _ran = 0.2;\n   vec3 _rgb = vec3(0.8,.5,0.3);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n      //vec2 pos = fragCoord.xy/iResolution.xy;\n      //float asd = noise(fragCoord.xy/512.*20.*_ran +iTime) ;\n      //float asd2 = noise(fragCoord.xy/512.*10.*_ran +iTime) ;\n    //  fragColor = vec4(vec3(asd,asd2*asd,0)+_rgb,1);\n    \n    vec2 pos = fragCoord.xy/iResolution.xy;\n\n    //float noi = noise(fragCoord.xy*(mouse+_rgb.xy)*0.1)+noise(fragCoord.xy*0.1+iTime*0.5);\n    float noi = noise(pos * 20.+iTime) + noise(pos*10.-iTime);\n    float omg = length(vec2(0.,.0)-vec2(noi,0.)*4.);\n    omg += 7.;\n    fragColor = vec4(vec2(omg*(omg-10.)),step(omg*noi,0.0),1.);\n    //fragColor = vec4(vec2(omg*(omg-10.)),omg*noi,1.);\n\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3GR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 73, 73, 170], [171, 171, 197, 197, 497], [499, 499, 555, 555, 1292]]}
{"id": "ld3Gz2", "name": "Snail", "author": "iq", "description": "Procedural modeling and procedural lighting. Shading is a mix of procedural and textures. SDF rendered through raymarching.", "tags": ["procedural", "3d", "raymarching", "distancefield", "sdf", "snail"], "likes": 652, "viewed": 157113, "published": "Public API", "date": "1450918438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\n// You can buy a metal print of this shader here:\n// https://www.redbubble.com/i/metal-print/Snail-by-InigoQuilez/39845499.0JXQP\n\n\n// antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\n\n#define ZERO (min(iFrame,0))\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\n//---------------------------------------------------------------------------\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    p -= vec3(0.05,0.12,-0.09);    \n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float np = (log(   r)/b-t)/(2.0*pi);\n    float nm = (log(0.11)/b-t)/(2.0*pi);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/pi);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d;\n}\n\nvec2 mapSnail( vec3 p, out vec4 matInfo )\n{\n    const vec3 head = vec3(-0.76,0.6,-0.3);\n    \n    vec3 q = p - head;\n\n    // body\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    float d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n\n    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n    d1 = smin( d1, d2, 0.03 );\n    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float co = 0.988771078;\n    float si = 0.149438132;\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = textureLod( iChannel1, 5.0*p.xy, 0. ).x;\n    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp2(-abs(2.9*p.z) );\n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    \n    return smax( d, -d2, 0.02 );\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    // leaf    \n    vec2 res = vec2( mapLeaf( p ), 4.0);\n    \n    // stem\n    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    float d3 = b3.x - 0.04 + 0.02*b3.y;\n    if( d3<res.x ) res = vec2(d3,3.0);\n    \n   \t// snail \n    float boundingVolume = sdCapsule(p, vec3(0.0), vec3(-0.6,0.7,0.0), 0.55);\n    if( boundingVolume<res.x )\n    {\n    vec2 tmp = mapSnail( p, matInfo );\n    if( tmp.x<res.x  ) { res = tmp; }\n    \n    // shell\n    float bb = length( p-vec3(0.25,0.3,-0.1) )-0.6;\n    if( bb<res.x )\n    {\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapOpaque(pos+eps*e,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    return min( min(d1,d4), min(d2,d3) );\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\n    if( m<1.5 ) // snail body\n    {\n        float dis = texture( iChannel1, 5.0*pos.xy ).x;\n\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5*be;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*be;\n        \n        mateK = vec2( 60.0, 0.7 + 2.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n\telse if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n        \n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leaf\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        mateD *= 0.8;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));\n        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));\n        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    dif1 *= fsha;\n    float sha = 1.0; if( dif1>0.0001 ) sha=calcSoftShadow( pos, sunDir, 20.0 ); \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    // illumination\n    vec3 col = vec3(0.0);\n    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;               // sun\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce\n\n    col *= mateD;\n\n    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss\n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2\n\tcol += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky\n\n    col += mateE;\n\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);\n    \n    // hide aliasing a bit\n    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n\treturn res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    // fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    return pow(col,vec3(3.5,3.0,6.0))*0.2;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 q )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    col = pow( col, vec3(0.45) );\n    \n    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);\n\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    return clamp( col, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt )\n{\n    vec3 w = normalize(ro-rt);\n    float m = sqrt(1.0-w.y*w.y);\n    return mat3( w.z,     0.0, -w.x, \n                 0.0,     m*m, -w.z*w.y,\n                 w.x*m, w.y*m,  w.z*m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #if AA<2\n        vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        vec2  q = fragCoord/iResolution.xy;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd, q );\n    #else\n        vec3 col = vec3(0.0);\n        for( int m=ZERO; m<AA; m++ )\n        for( int n=ZERO; n<AA; n++ )\n        {\n            vec2 rr = vec2(float(m),float(n))/float(AA);\n\n            vec2 p = (2.0*(fragCoord+rr)-iResolution.xy)/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n            vec2 q = (fragCoord+rr)/iResolution.xy;\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n\t\t    col += render( ro, rd, q );\n        }    \n        col /= float(AA*AA);\n    #endif\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3Gz2.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[890, 964, 1004, 1004, 1040], [1042, 1116, 1170, 1170, 1234], [1236, 1310, 1362, 1362, 1392], [1394, 1468, 1501, 1501, 1556], [1558, 1632, 1684, 1684, 1798], [1800, 1874, 1916, 1916, 2037], [2039, 2103, 2132, 2132, 2158], [2159, 2159, 2206, 2206, 2684], [2686, 2686, 2735, 2735, 3145], [3147, 3199, 3240, 3240, 3312], [3314, 3366, 3407, 3407, 3479], [3481, 3533, 3571, 3571, 3642], [3644, 3723, 3747, 3747, 3789], [3791, 3791, 3827, 3827, 4091], [4201, 4280, 4328, 4328, 5703], [5705, 5705, 5748, 5748, 7726], [7732, 7732, 7760, 7760, 7896], [7898, 7898, 7926, 7926, 8615], [8617, 8617, 8661, 8661, 9409], [9411, 9475, 9527, 9527, 10114], [10116, 10193, 10231, 10231, 10943], [10945, 10945, 10994, 10994, 11172], [11174, 11238, 11295, 11295, 11573], [11575, 11652, 11694, 11694, 12020], [12022, 12022, 12065, 12065, 12416], [12418, 12480, 12537, 12537, 12833], [12889, 12889, 12974, 12974, 18897], [18899, 18899, 19018, 19018, 20059], [20061, 20109, 20217, 20217, 20511], [20513, 20513, 20626, 20626, 20920], [20922, 20922, 20952, 20973, 21505], [21507, 21507, 21557, 21593, 22585], [22587, 22587, 22629, 22629, 22815], [22817, 22817, 22874, 22874, 23995]]}
{"id": "ldc3Dn", "name": "zinetest3", "author": "macbooktall", "description": "color palette and base ray march code by iq https://www.shadertoy.com/view/Xds3zN\nmenger sponge by Cale https://www.shadertoy.com/view/ltjGzd", "tags": ["fractal"], "likes": 34, "viewed": 1470, "published": "Public API", "date": "1448929285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//forked By Cale Bradbury, 2015 from https://www.shadertoy.com/view/ltjGzd\n\n//fuck yeah, mirror that shit\n#define MIRROR\n\n// Base ray trace code via https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat qbox( vec3 p, float s )\n{\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box(vec3 p, vec3 b){ \n    p = abs(p) - b;\n    return max(p.x, max(p.y,p.z));\n}\n\nvec2 map( in vec3 pos )\n{\n    float size = .35;\n    pos = mod(pos,size)-0.5*size;\n\t\n    float res = qbox(pos,size);\n\n    pos+=size;\n    \n    for(float i = 0.0; i<3.;i++){\n        size /= 3.0;\n        \n        float b = box(opRep(pos,vec3(size*3.,size*3.,0)),vec3(size,size,10.));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(size*6.,0.,size*6.)),vec3(size,10.,size));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(0.,size*6.,size*6.)),vec3(10.,size,size));\n        res = opS(res,b);\n    }\n\t\n    return vec2(res,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.;\n    float tmax = 120.0;\n    \n\tfloat precis = 0.0001;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<120; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    \n    const vec3 a = vec3(.5, .0, .5);\n    const vec3 b = vec3(.5, 1., .5);\n    const vec3 c = vec3(1., 1., 1.);\n    const vec3 d = vec3(.0, .1, 0.2);\n    \n    col = palette(0.3+res.x*2., a, b, c, d);\n    col = mix( col, vec3(1.0), 1.0-exp( -.5*res.x*res.x ) );\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0+2.0*(fragCoord.xy / iResolution.xy);\n\tp.x *= iResolution.x/iResolution.y;\n\n    // camera\t\n\tvec3 ro = vec3(0., .0, -iTime*0.4 );\n    //vec3( -0.5+camDist*cos(0.1*time), 5.0, 0.5 + camDist*sin(0.1*time) );\n\tvec3 ta = ro + vec3(0., 0., -1. );\n\t\n\t// camera-to-world transformation\n//    mat3 ca = setCamera( ro, ta, 56.54 );\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,.8) );\n\n    // render\t\n    vec3 col = render( ro, rd);\n    col += (vec3(1.)*p.y)*0.35;\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldc3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 302, 335, 335, 361], [363, 363, 393, 393, 422], [424, 424, 455, 455, 503], [505, 505, 531, 531, 589], [591, 591, 616, 616, 1132], [1134, 1134, 1174, 1174, 1494], [1496, 1496, 1568, 1568, 1611], [1613, 1613, 1652, 1652, 2014], [2016, 2016, 2068, 2068, 2245], [2247, 2247, 2304, 2304, 2858]]}
{"id": "ldc3Dr", "name": "Lone Christmas Tree", "author": "jwa", "description": "Another Christmas tree!", "tags": ["christmas", "tree"], "likes": 3, "viewed": 180, "published": "Public", "date": "1448988899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on this shader\n// https://www.shadertoy.com/view/Xds3z by inigo quilez\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdGround( vec3 p )\n{\n    float a = 0.1;\n    float f = 1.0;\n    float h = 0.25;\n    for(int i=0; i<2; i++)\n    {\n\t\th += (p.y- a*(sin(f*p.x)-sin(f*p.z)));\n    \ta*=0.85;\n        f*=1.13;\n    }\n    return h;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdGround(     pos), 1.0 ),\n\t                vec2( sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.1,0.2) ), 100.0 ) );\n    \n    res = opU(res, vec2( sdCone( pos-vec3( 0.0,0.5,0.0), vec3(0.3,0.6,0.3) ), 200.0 ) );\n    res = opU(res, vec2( sdCone( pos-vec3( 0.0,0.65,0.0), vec3(0.35,0.6,0.3) ), 300.0 ) );\n    res = opU(res, vec2( sdCone( pos-vec3( 0.0,0.8,0.0), vec3(0.5,0.6,0.3) ), 400.0 ) );\n    res = opU(res, vec2( sdCone( pos-vec3( 0.0,0.95,0.0), vec3(0.75,0.6,0.3) ), 500.0 ) );\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n    \n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.4, 0.8, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n       \tvec3 nor = calcNormal( pos );\n       \n        vec3 lightDir = normalize(vec3(1,-1,2));\n        float l = 0.5+ 0.5*dot(lightDir, nor);\n        // material        \n\t\tcol = vec3(0.05,0.5,0.10);\n\t\tcol *= l;\n        if( m<50.5 )\n        {                    \n            col = l*vec3(2.5);\n        }\n        \n        else if( m<150.0 )\n        {\n                      \n            col = l*vec3(0.3,0.25,0.01);\n        }\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n \t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 3.5*cos(0.1*time), 0.5, 3.5*sin(0.1*time) );\n\tvec3 ta = vec3( -0.25, 0.2, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,3.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldc3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 119, 119, 288], [290, 290, 316, 316, 501], [503, 503, 539, 539, 638], [639, 713, 743, 743, 776], [778, 852, 877, 877, 1402], [1404, 1404, 1444, 1444, 1770], [1773, 1773, 1805, 1805, 2031], [2033, 2033, 2072, 2072, 2700], [2702, 2702, 2754, 2754, 2931], [2933, 2933, 2990, 2990, 3501]]}
{"id": "ldc3Rj", "name": "Logo bouncer", "author": "gigatron", "description": "gigatron logo bounce ...wip !", "tags": ["logobounce"], "likes": 0, "viewed": 99, "published": "Public", "date": "1450783459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 road(vec3 pos)\n{\n\tvec3 c1 = vec3(0.0,0.5,0.2);\n\tvec3 c2 = vec3(0.0,0.3,0.4);\n\t \n\tfloat a=iTime;\n\t\n\tif(abs(pos.x) < 1.8)\n\t{\n\t\t//c1 = vec3(0.9,0.0,0.1);\n\t\t//c2 = vec3(0.9,0.0,8.0);\n\t\t\n\t\t\n\t}\n\t\n\tfor(float i=-10.0;i<120.0;i+=1.2){\n\tif(abs(pos.x) > i  && (abs(pos.x) < i+0.6))    //left and right line\n\t{\n\t\tc1 = vec3(0.0,0.7,0.3);\n\t\tc2 = vec3(0.0,0.4,0.4);\n\t}\n\t}\n\n\t\n\t\n\t\n\t\n\t\n\tfloat t = iTime * 2.5;  //speed of the fx\n\t\n\t\n\t\n\t\n\tfloat rep = fract(pos.y+t*2.0);\n\tfloat blur =  dot(pos,pos)*0.004;\n\tvec3 ground = mix(c1,c2,smoothstep(0.25-blur*0.25,0.25+blur*0.25,rep)*smoothstep(0.75+blur*0.25,0.75-blur*0.25,rep));\n\t\n\treturn ground;\n}\n\nvec3 sky(vec2 uv)\n{\n\treturn mix(vec3(1.0,1.0,1.0),vec3(0.1,0.7,1.0),uv.y);\n}\n\n\n\n\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\nfloat dfSemiArc2(float rma, float rmi, vec2 uv)\n{\n\treturn min(abs(length(uv) - rma) - rmi, uv.x+4.0);\n}\n\n\n\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.t));\n}\n\n//--- Letters ---\nvoid G(inout float df, vec2 uv)\n{\n\t\n\tdf = min(df, dfSemiArc(0.5, 0.125, uv));\n\tdf = min(df, dfQuad(vec2(0.000, 0.375), vec2(0.000, 0.625), vec2(0.250, 0.625), vec2(0.25, 0.375), uv));\n\tdf = min(df, dfRect(vec2(0.250, 0.50), uv - vec2(0.0,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.250,-0.125), vec2(-0.125,0.125), vec2(0.250,0.125), vec2(0.250,-0.125), uv));\t\n}\n\nvoid I(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.280,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,0.40)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,-0.625)));\n}\n\n//\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.1,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,-0.20)));\n   \n}\n\n\nvoid T(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.700, 0.25), uv - vec2(-0.8,0.38)));\n    \n \n   \n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.0,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.95,0.38)));\n   df = min(df, dfRect(vec2(0.200, 0.60), uv - vec2(-0.600,-0.10)));\n    df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.95,-0.10)));\n    \n  //  df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.80,-0.10)));\n\n   df = min(df, dfQuad(vec2(-0.900,-0.100), vec2(-0.600,-0.100), vec2(-0.350,-0.625), vec2(-0.550,-0.625), uv));\n   \n   \n}\n\nvoid O(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.20,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.750,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,-0.625)));\n   \n}\n\nvoid N(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.30,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.650,-0.625)));\n   df = min(df, dfQuad(vec2( -1.300,.625), vec2(-1.000,0.625), vec2(-0.450,-0.625), vec2(-0.650,-0.625), uv));\n}\n\n\n\n\n\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n//---------------\n\n//--- From e#26829.0 ---\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy / iResolution.xy;\n    vec2 aspect = iResolution.xy/iResolution.y;\n   // float t = mod(iTime * 0.2, 10.) + iTime;\n\tfloat t=iTime; \n    \n    float bf=1.4;\n\tuv = (uv - aspect/2.0)*16.0*abs(sin(t*0.2+bf/12.));\n\n\tfloat dist = 1e6;\n\t\n\tfloat charSpace = 1.025;\n\t\n\tvec2 chuv = uv;\n\tchuv.x += charSpace * 2.6;\n    \n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.)))); chuv.x -= charSpace;\n    \n    I(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*2.0)))); chuv.x -= charSpace;\n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*3.0)))); chuv.x -= charSpace;\n    A(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*4.0)))); chuv.x -= charSpace;\n    T(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*5.0)))); chuv.x -= charSpace;\n    R(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*6.0)))); chuv.x -= charSpace;\n    O(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*7.0)))); chuv.x -= charSpace;\n    \n\tN(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*8.0)))); chuv.x -= charSpace;\n\n\t\n\tfloat mask = smoothstep(2.0/iResolution.y,0.050,dist);\n\t\n\tvec3 textcol =  vec3(sky(uv)*.8);\n    vec3 pos = vec3(uv.x/abs(uv.y),0.5/abs(uv.y-0.01 ),step(0.0,uv.y)*8.0-1.0);\n\tvec3 color = vec3(0.0);\n\n\t//color = mix(road(pos ),sky(uv),step(.0,pos.z));\n    \n    \n\t color   = mix(sky(uv )-textcol,road(pos ),mask);\n       \n    \n    \n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldc3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 630], [632, 632, 651, 651, 708], [713, 713, 761, 761, 815], [817, 817, 866, 866, 920], [924, 924, 983, 983, 1272], [1274, 1274, 1308, 1308, 1374], [1376, 1394, 1427, 1427, 1752], [1754, 1754, 1787, 1787, 1995], [1997, 2001, 2034, 2034, 2314], [2317, 2317, 2350, 2350, 2498], [2500, 2500, 2533, 2533, 3005], [3007, 3007, 3040, 3040, 3322], [3324, 3324, 3357, 3357, 3608], [3614, 3614, 3647, 3647, 4076], [4096, 4121, 4166, 4166, 4199], [4203, 4203, 4260, 4260, 5576]]}
{"id": "ldc3RS", "name": "Necromulok - Spiral", "author": "Necromurlok", "description": "Spiral", "tags": ["spiral"], "likes": 7, "viewed": 260, "published": "Public", "date": "1450361783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\n\n\nvec3 spiral(in vec2 uv, in vec2 pos, in float rev, in float freq)\n{\n    uv = uv - pos;\n    float angle = atan(uv.x, uv.y);\n    float rad = length(uv) * PI * rev;\n    float r = cos(angle + rad - iTime * 1.0 * freq) / PI + 0.5;\n    float g = cos(angle + rad - iTime * 2.0 * freq) / PI + 0.5;\n    float b = cos(angle + rad - iTime * 3.0 * freq) / PI + 0.5;\n    \n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy;\n    \n    float t = iTime * 1.0;\n    float cost = cos(t);\n    float sint = sin(t);\n    \n    mat2 m = mat2(cost, sint, -sint, cost);\n    \n    uv *= m;\n    \n    t = sin(iTime * 0.5) + PI * 0.5;\n    fragColor = vec4(spiral(uv, vec2(-0.0, 0.0) * t, 50.0 + t * 50.0, 4.0), 1.0) * 1.0;\n   fragColor += vec4(spiral(uv, vec2(0.25, 0.0) * t, 6.0 + t * 6.0, 5.0), 1.0) * 1.0;\n    fragColor *= vec4(spiral(uv, vec2(0.0, 0.25) * t, 6.0 + t * 6.0, 6.0), 1.0) * 1.0;\n    fragColor *= vec4(spiral(uv, vec2(0.0, -0.25) * t, 6.0 + t * 6.0, 7.0), 1.0) * 1.0;\n/*\n    fragColor += vec4(spiral(uv, vec2(-0.5, 0.5) * t, t * 30.0, 5.0), 1.0) * 0.125;\n    fragColor += vec4(spiral(uv, vec2(0.5, 0.5) * t, t * 30.0, 6.0), 1.0) * 0.125;\n    fragColor += vec4(spiral(uv, vec2(0.5, -0.5) * t, t * 30.0, 7.0), 1.0) * 0.125;\n    fragColor += vec4(spiral(uv, vec2(-0.5, -0.5) * t, t * 30.0, 8.0), 1.0) * 0.125;\n*/\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldc3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 101, 101, 420], [422, 422, 479, 479, 1431]]}
{"id": "ldcGWM", "name": " sA.4 - Trans Europe Express", "author": "patu", "description": "Trans Europe Express", "tags": ["2d", "trans", "europe", "express"], "likes": 4, "viewed": 372, "published": "Public API", "date": "1449970751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 c, in vec2 f) {\n\tvec2\tv = (f.xy / iResolution.y) * 2. - 1.,\n       \t\tq = v, \n        \to;\n    \n    c -= c; //mac\n    \n    o.x = v.x - .5;\n    o.y = abs(v.y);\n    \n    for (float i = 0.; i < 18.; i++) {\n        v = o;\n        \n        v.y = .12 / v.y;\n\t\tv.x *= v.y;\n        v.y += iTime * 1.75;\n        v.x += -.1 + sin(v.y / i / 4. + i) * i * 2.; \n        \n        for (float j = .1 ; j < .3; j += .1) \n    \t\tif ((v.x += j) > -.1  && v.x < .1) \n                c += max(-.7, 2.2 - pow((abs(v.x - .05)) * 64., 0.4) * 2.2);\n    }\n    \n    c += fract(v.y) < .02 ? .2 : 0.;\n    if (q.y > 0.) c = .3 - clamp(c, 0., 1.)  - q.y / 1.5;\n}", "image_inputs": [{"id": "4sl3RH", "previewfilepath": "https://soundcloud.com/jonathanysp/trans-europe-express-kraftwerk", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/jonathanysp/trans-europe-express-kraftwerk", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 653]]}
{"id": "ldcGWr", "name": "Bubbles in Diamond", "author": "cabbibo", "description": "Bubbles in a diamond", "tags": ["refract"], "likes": 25, "viewed": 538, "published": "Public", "date": "1448943409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\n\n\n\n// From https://www.shadertoy.com/view/XtjSRm\n// shane code\nfloat vNoise( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io ){  \n    \n    float n = vNoise( pos * 4. + vec3( 0. , iTime * .1 , 0. ) );\n \tvec2 res = vec2( io *  ( sdSphere( pos  , .6 ) + .2 * n ) , 1. ); \n  \n    if( io < 0. ){\n        \n        n = vNoise( pos * 8. - vec3( 0. , iTime , 0. ) );\n        res = opU( res ,  vec2( sdSphere( pos  , .3 ) - .1 * n  , 2. ) );\n        \n        \n    }\n    \n    return res;\n    \n    \n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd , float io ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t , io );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos, in float io ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy , io).x - map(pos-eps.xyy , io).x,\n\t    map(pos+eps.yxy , io).x - map(pos-eps.yxy , io).x,\n\t    map(pos+eps.yyx , io).x - map(pos-eps.yyx , io).x );\n\treturn normalize(nor);\n}\n\n\n\n// Gets background color if nothing is hit\n// also used for refraction\nvec3 bgCol( in vec3 p ){\n \n float n = vNoise( p );\n vec3 disPos = vec3( p +  .5 *  ( sin( p.x * 10. ) + sin( p.y  * 10. ) + sin( p.z * 10.)));\n \n return vec3( n );\n    \n\n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n  \n     \n  float ior = .7; // index of refraction\n  float lba = .03; // light bend amount\n    \n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos , 1. );\n \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n  \tvec3 refrR = refract( rd , norm , ior * (1. - lba) );\n    vec3 refrG = refract( rd , norm , ior * 1. );\n    vec3 refrB = refract( rd , norm , ior * (1. + lba) );\n      \n   \tvec3 posR = pos + refrR * INTERSECTION_PRECISION * 1000.;\n    vec3 posG = pos + refrG * INTERSECTION_PRECISION * 1000.;\n    vec3 posB = pos + refrB * INTERSECTION_PRECISION * 1000.;\n      \n      \n    //vec3 colR = texture( iChannel0 , refrR ).xyz * vec3( 1. , 0., 0. );\n    //vec3 colG = texture( iChannel0 , refrG ).xyz * vec3( 0. , 1., 0. );\n    //vec3 colB = texture( iChannel0 , refrB ).xyz * vec3( 0. , 0., 1. );\n      \n\n      \n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n      \n      \n    vec2 resR = calcIntersection( posR , refrR , -1. );\n    vec2 resG = calcIntersection( posG , refrG , -1. );\n    vec2 resB = calcIntersection( posB , refrB , -1. );\n      \n   \n    vec3 p2 , n2 , r2;\n        \n    if( resR.y == 2. ){\n      p2 = posR + refrR * resR.x;\n      n2 = calcNormal( p2 , -1. );\n        \n      \n      r = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n    }else{\n       \n      p2 = posR + refrR * resR.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrR , n2 , ior * (1. - lba) );\n        \n      r = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).x;\n        \n    }\n      \n    if( resG.y == 2. ){\n      \n      p2 = posG + refrG * resG.x;\n      n2 = calcNormal( p2 , -1. );\n      g = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n       \n      p2 = posG + refrG * resG.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrG , n2 , ior * 1. );\n        \n        \n      \n      g = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).y;\n        \n    }\n      \n    if( resB.y == 2. ){\n        \n      p2 = posB + refrB * resB.x;\n      n2 = calcNormal( p2 , -1. );\n      b = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n        \n    }else{\n       \n      p2 = posB + refrB * resB.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrB , n2 , ior * (1. + lba) );\n        \n      b = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).z;\n        \n    }\n      \n      \n    color = vec3( r , g , b );\n          \n      \n    \n    \n      \n    \n      \n      \n      \n        \n        \n  }else{\n   \n  \tcolor = bgCol( rd * MAX_TRACE_DISTANCE );\n      \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n\tfloat angle =  iMouse.x / iResolution.x * 2. * 3.14 ;\n    vec3 ro = vec3( cos( angle ) * 2.  , 0., sin( angle ) * 2. );\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd , 1. );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}\n", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 321, 348, 348, 914], [918, 949, 1013, 1013, 1191], [1193, 1287, 1316, 1316, 1359], [1361, 1361, 1392, 1392, 1488], [1490, 1490, 1525, 1525, 1549], [1552, 1636, 1668, 1668, 2034], [2038, 2038, 2097, 2097, 2569], [2573, 2686, 2730, 2730, 2986], [2990, 3061, 3085, 3085, 3232], [3235, 3235, 3279, 3279, 5940], [5944, 5944, 6001, 6001, 6580]]}
{"id": "ldd3DH", "name": "fwidth() curvature test", "author": "kuvkar", "description": "Testing finding curvature with fwidth function. Left side shows curvature, white areas are curvier ones. Funny valve model by accident. \"Rust\" on the model from curvature. Went overboard with shading, was supposed to only be a test. Oh well.", "tags": ["shadows", "bumpmapping", "curvature"], "likes": 21, "viewed": 514, "published": "Public", "date": "1449527171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nmat3 rotation;\n\nvec3 lightDir = normalize(vec3(1.0, 1.0, -3.0));\n\nfloat map(in vec3 rp)\n{\n    rp *= rotation;\n    float m = length(rp + sin(rp * 32.) * 0.042) - 0.5;\n    m += length(sin(rp * 80.0) * 0.0025);\n    return m;\n    \n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.001, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    p *= 2.0;\n    p *= rotation;\n    n *= rotation;\n    vec4 c1 = texture(tex, p.xy);\n    vec4 c2 = texture(tex, p.yz);\n    vec4 c3 = texture(tex, p.xz);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\n\nvec3 bump(in vec3 rp, in vec3 g)\n{\n    vec2 off = vec2(0.001, 0.0);\n    float xy = tex3D(iChannel0, rp + off.xyy, g).r - tex3D(iChannel0, rp - off.xyy, g).r;\n    float zy = tex3D(iChannel0, rp + off.yyx, g).r - tex3D(iChannel0, rp - off.yyx, g).r;\n    \n    mat3 bmat;\n    bmat[0] = cross(g, vec3(0.0, 1.0, 0.0));\n    bmat[1] = cross(bmat[0], g);\n    bmat[2] = g;\n    \n    vec3 bmg = -cross( normalize(vec3(.0, 1.0, xy)), normalize(vec3(1.0, .0, zy)) );\n    return bmat * bmg;\n}\n\nfloat shadow(in vec3 rp)\n{\n    \n    mat3 trn;\n    vec3 ld = lightDir;\n    float s = 1.0;\n    const float dst = 0.04;\n    rp = rp + ld * dst * 1.04;\n    \n    for (int i = 0; i < 15; ++i)\n    {\n    \tfloat d = map(rp);\n        s = min(s, d / dst);\n        rp += max(d * 0.75, 0.01) * ld;\n    }\n    return s;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    for (int i = 0; i < 450; ++i)\n    {\n        float dist = map(rp);\n        if(dist < 0.0)\n        {\n            rp += dist * rd;\n            hit = true;\n            break;\n        }\n        \n        if(rp.z > 2.0) break;\n        \n        rp += rd * max(dist * 0.25, 0.0002);\n    }\n    \n    if(hit)\n    {\n        color = vec4(.0);\n        vec3 g = grad(rp);\n        float d = dot(g, lightDir);\n        d = clamp(d, 0.0, 1.0);\n        //////////////////////\n        // Getting the curvature from 2 derivates : position and normal.\n        vec3 gw = fwidth(g);\n        vec3 pw = fwidth(rp);\n        \n        float wfcurvature = length(gw) / length(pw);\n        wfcurvature = smoothstep(0.0, 30., wfcurvature);\n        color = vec4(wfcurvature);\n        \n        //// shaded version\n        if(rp.x > 0.)\n        {\n            // diffuse \n        \tcolor = vec4(pow(d, 4.0)) * vec4(.5, .7, 0.95, 0.0);\n            color = mix(color, vec4(1.0), 0.15);\n            \n            // spec\n            vec3 H = normalize(-rd + lightDir);\n            color += pow(clamp(dot(H, g), 0.0, 1.0), 34.0) * .2;\n            \n            // rim\n            float R = 1.0 - clamp(dot(g, -rd), 0.0, 1.0);\n            R = pow(R, 2.4);\n            color += R * vec4(.0, 0.4, .6, 0.0) * .8;\n            \n            \n            // \"rust\" color from curvature\n            color += vec4(.6, .2, .0, 0.0) * pow(wfcurvature, 1.4) * 0.8;\n            \n\t\t\t//Bump mapping\n            color *= vec4( pow(dot(bump(rp, g), lightDir), 2.0));\n            color *= shadow(rp) * 0.7 + 0.3;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\t\n    if(iMouse.z > 0.0)\n    {\n        rotation = rotx((iMouse.y - iResolution.y * 0.5) * 0.01);\n        rotation *= roty((iMouse.x - iResolution.x * 0.5) * 0.01);\n        \n    }else\n    {\n    \trotation = rotx(iTime * 0.1) * roty(iTime * 0.2);\n    }\n    \n    fragColor = mix(vec4(1.0), vec4(0.2, 0.5, 0.95, 0.0), (uv.y + 0.5));\n    vec3 rd = normalize(vec3(uv, 0.45));\n    vec3 rp = vec3(0.0, 0.0, -1.1);\n    trace(rp, rd, fragColor);\n    if(abs(uv.x) < 0.002) fragColor = vec4(0.8);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldd3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 148], [149, 149, 169, 169, 296], [297, 297, 317, 317, 444], [512, 512, 535, 535, 674], [676, 676, 699, 699, 931], [934, 934, 985, 985, 1343], [1346, 1346, 1380, 1380, 1823], [1825, 1825, 1851, 1851, 2131], [2133, 2133, 2187, 2187, 3785], [3788, 3788, 3845, 3845, 4437]]}
{"id": "lddGWM", "name": "Holiday lights", "author": "ap", "description": "Made something while I was bored. Reminds me of Indian Diwali lights.", "tags": ["lights", "holiday"], "likes": 10, "viewed": 699, "published": "Public API", "date": "1450157891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nvec2 rand2(in vec2 p)\n{\n    return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n#define v4White vec4(1.0, 1.0, 1.0, 1.0)\n#define v4Black vec4(0.0, 0.0, 0.0, 1.0)\n#define v4Grey  vec4(0.5, 0.5, 0.5, 1.0)\n\n\nvec3 moonImage(vec2 loc)\n{\n    float moonRad = 0.3;\n    vec2 moonDiffVec = loc - vec2(0.0, 0.0);\n    float dist = length(moonDiffVec);\n    \n    return mix(\n    \tvec3(0.6, 0.6, 0.5),\n        vec3(0.0),\n        smoothstep(moonRad * 0.9, moonRad * 1.1, dist / moonRad));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    vec2 freq = vec2(5.0, 15.0);\n    vec2 gap = vec2(1.0/freq.x, 1.0/freq.y);\n    vec2 jitterrad = vec2((0.02 + 0.02 * (1.-uv.y)) * gap.x , 0.01 * gap.y);\n    float ballrad = 0.2 * gap.y;\n\n    vec2 param_pos = uv - vec2(0.5);\n  \n    vec2 closest_center = floor(param_pos * freq + vec2(0.5)) / freq;\n    \n    vec3 color = vec3(\n        rand(closest_center.x * 379.0 + closest_center.y * 0.0 + 333.0),\n        rand(closest_center.x * 379.0 + closest_center.y * 0.0 + 796.0),\n        rand(closest_center.x * 379.0 + closest_center.y * 0.0 + 221.0));\n    \n    color = color / max(max(color.x, color.y), max(color.z, 0.1));\n    \n    color = mix(color, vec3(1.0, 1.0, 0.5), 0.25);\n        \n    float black_or_white = 0.5 + 0.5 * sin(\n        2.0 * 3.14159 * \n        (rand((closest_center.x + 347.0) * (closest_center.y + 7.0 * 129.0)) + iTime * 0.5));\n    \n    black_or_white = pow(black_or_white, 10.0);\n    \n    float near_bottom = pow(1.0-uv.y, 3.0);\n\n    closest_center = closest_center + jitterrad * 1.0 *\n        sin((iTime * 0.8 + rand2(closest_center)) * 6.28 +\n        sin((iTime * 0.2 + rand2(closest_center.yx)) * 6.28) +\n        sin((iTime * 0.5 + rand2(closest_center.xx * 93.0 + 127.0)) * 6.28)) +\n        vec2((0.2 * near_bottom * gap.x) * sin(2.0*iTime + 2. * 6.28 * rand(closest_center.x)), 0.0);\n\n    vec2 distvec = param_pos - closest_center;\n    distvec.x /= (1.-black_or_white);\n    float dist = length(distvec); \n\n    float s = (dist * dist) / (ballrad * ballrad);\n\n    fragColor = mix(\n        mix(\n            vec4(color, 1.0), \n            v4Black, black_or_white), \n        mix(vec4(0.1,0.1,0.3,1.0), vec4(0.0,0.0,0.2,1.0), smoothstep(0.0,0.25,uv.y)), \n        smoothstep(ballrad*0.9, ballrad*1.1, dist));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 67], [69, 69, 92, 92, 187], [314, 314, 340, 340, 583], [585, 585, 642, 642, 2414]]}
{"id": "ldt3Dr", "name": "SDF Reflection/LightBounce Test", "author": "sagarpatel", "description": "A quick heck test to see how a naive implementation of light bouncing would look like.\nOutput is glitchy: won't attempt to fix here)", "tags": ["raymarching", "distancefield", "reflection", "sdf", "bounce", "lightbounce"], "likes": 7, "viewed": 1113, "published": "Public API", "date": "1449137342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 1.0\n// @sagzorz\n// HACKED REFLECTION / LIGHT BOUNCE TEST\n \n// enabling AA will kill light bounce\nconst bool isPseudoAA = false;\n// min is 1\nconst int lightBounceCount = 2;\n\n// Building on basics and creating helper functions\n// POUET toolbox\n// http://www.pouet.net/topic.php?which=7931&page=1&x=3&y=14\n\n// NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n// \n// @cabbibo's original SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n// my original hacked up shader --> https://www.shadertoy.com/view/4d33z4\n\n// this is a clean/from scratch re-implementation of my first shdaer/sdf,\n// which was based on @cabbibo's awesome SDF tutorial\n// also used functions from iq's super handy page about distance functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// resstructured to be closer to iq's Raymarching Primitives example\n// https://www.shadertoy.com/view/Xds3zN\n\n// NOW PROPERLY MARCHING THE RAY!\n// (was using silly hack in original version to compensate for twist artifacts)\n// Performs much better than old version\n\n// the sd functions below are the same as from iq's page (link above)\n// though when I wrote this version I derived from scratch as much as I could on my own \n// by thinking/sketching on paper etc. \n// The comments explain my interpretation of the funcs\n\n// for all signed distance functions sd*() below,\n// input p --> is ray position, where the object is at the origin (0,0,0)\n// output float is distance from ray position to surface of sphere\n//  positive means outside of sphere\n//  negative means ray is inside\n//  0 means its exactly on the surface\n\n\n// ~~~~~~~ silly function to access array memeber \n// because webgl needs const index for array acess\n// TODO :  FIX THIS, disgusting branching etc\n// THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);//vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n// ~~~~~~~ signed fistance fuction for sphere\n// input r --> is sphere radius\n// pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ~~~~~~~ signed distance function for box\n// input s -- > is box size vector (all postive values)\n//\n// the key to simply calcualting distance to surface to box is to first \n// force the ray position into the first octant (all positive values)\n// this massively simplifies the math and is ok since distance to surf\n// on a box is the same in the - or + direction on a given axis\n// simple to figure by once you sketch out 2D equivalent problem on papaer\n// 2D ex: distance to box of size (2,1) \n// for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n//\n// now that all the coordinates are \"normalized\"/positive, its much easier,\n// the next part is to figure out the diff between the box surface the and p\n// a bit like the sphere function were you do p - \"shape size\", but\n// you clamp the result to >0, done below by using max() with 0\n// i'm having trouble putting this into words corretcly, but it was really easy\n// to understand once I sketched out a rect and points on paper, \n// that was enough for me to be able to derive the 3D version \n//\n// the last part is to account for is p is insde the box, \n// in which case we need to return a negative value\n// for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n/*\n// Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*/\n\n// ~~~~~~~ signed distance function for torus\n// input t --> torus specs where:\n//  t.x = torus circumference\n//  t.y = torus thickness\n//  \n// think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n// first flatten the y axis of p (by using p.xz) and get the distance to \n// the torus circumference/core/radius which is flat on the y axis\n// then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n/*\n// IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*/\n\n// ~~~~~~~ signed distance function for plane\n//  input ps --> specs of plane\n//        ps.x --> size x\n//        ps.y --> size z\n// plane extends indefinately in x and z, \n// so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n// ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n// http://iquilezles.org/www/articles/smin/smin.htm\n// input d1 --> distance value of object a\n// input d1 --> distance value of object b\n// input k --> blend factor\n// output --> smoothed/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n// input o1 --> object 1 (dist and material color)\n// input 02 --> object 2 (dist and material color)\n// input bf --> blend factor\n// output --> blended dist, blended material color\n// TODO: FIX/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    // blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n// ~~~~~~~ domain deformation, twists the shape\n// input p --> original ray position\n// input t --> twist scale factor\n// output --> twisted ray position\n// \n// need more max itterations on ray march for stronger/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// ~~~~~~~ do Union / combine 2 sd objects\n// input vec2 --> .x is the distance, .y is the object ID\n// returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n// ~~~~~~~ do shape subtract, cuts d2 out of d1\n// by using  the negative of d2, were effectively comparing wrt to internal d\n// input d1 --> object/distance 1\n// input d2 --> object/distance 2\n// output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n// ~~~~~~~ map out the world\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    // results container\n    vec4 res;    \n    \n    // define objects\n        // sphere 1\n        // sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n        //  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iTime);\n        // to twist the torus (or any object), we actually distort p/space (domain) itself,\n        // this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        //  domain distortion correction:\n        //  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    // blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    //res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    return res;\n}\n\n// ~~~~~~~ cast/march ray through the word and see what it hits\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// in/out --> itterationRatio (used for AA),in/out cuz no more room in vec\n// output is vec3 where\n//  .x = distance travelled by ray\n//  .y = hit object's ID\n//  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    // variables used to control the marching process\n    const float maxMarchCount = 100.0;\n    float maxRayDistance = 50.0;\n    // making this more precise can also help with AA detection\n    // value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.001; // travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); // object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        // get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        // stop itterating/marching once either we've past max ray length \n        // or\n        // once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        // move ray forward by distance to closet object, see\n        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i/maxMarchCount;\n    }\n    \n    // if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n// ~~~~~~~ hardShadow, raymarches from shading point to light\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float hsT = 0.02; //2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    // no object hit on the way to light source\n    return 1.0;\n}\n\n// ~~~~~~~ softShadow, took pointers from iq's\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// and\n// https://www.shadertoy.com/view/Xds3zN\n//  input sp --> position of surface we are shading\n//  input lp --> light position\n//  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    // direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    // max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    // travelled distance by hard shadow ray\n    float ssT = 0.02;\n    // softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        // if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n// ~~~~~~~ ambientOcclusion\n// just cast from surface point in direction of normal to see if any hit\n// basic concept from:\n// http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    // range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n// ~~~~~~ calculate normal of closest objects surface given a ray position\n// input p --> ray position (calculated previously from ray cast position, no iteration now\n// output --> surface normal vector\n//\n// gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    // world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    //wPD = abs(0.05*sin(0.25*iTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    //vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    //vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    //vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    // doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    //diffVec += oN - n2;\n    //diffVec += oN - n3;\n    //diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n// ~~~~~~~ do gamma correction\n// from iq's pageon outdoor lighting:\n// http://www.iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// input c --> original color\n// output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0/2.2) );\n}\n\n// ~~~~~~~ do fog\n// from iq's pageon fog:\n// http://www.iquilezles.org/www/articles/fog/fog.htm\n// input c --> original color\n// input d --> pixel world distance\n// input fc1 --> fog color 1\n// input fc2 --> fog color 2\n// input fs -- fog specs>\n//       fs.x --> fog density\n//       fs.y --> fog color lerp exponent (iq's default is 8.0)\n// input cRD --> camera ray direction\n// input lRD --> light ray direction\n// output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n// ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n// input ro --> pixel's ray original position\n// input rd --> pixel's ray direction\n// in/out aaF --> antialiasing factor\n// out sP --> rendered surface position\n// out sR --> rendererd surface reflected ray\n// output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF, out vec3 sP, out vec3 sR)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n    \n    float lOR_X = 5.0;\n    float lOR_Y = 10.0;\n    float lOR_Z = 25.0;\n    float lORS = 0.25;\n    float lpX = lOR_X*cos(lORS*iTime);\n    float lpY = lOR_Y*sin(lORS*iTime);\n    float lpZ = lOR_Z*cos(lORS*iTime);\n    vec3 lightPos = vec3(lpX,abs(lpY),lpZ);\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    // hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        //objectColor = normalize(objectColor);\n        // calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        \n        // treating light as a point light (calculating normal based on pos)\n        float surf = clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            // AA RELATED STUFF\n            // visualize itteration count of pixels\n            //pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            // pseudo edge/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            //sEdge *= 1.0 - (t/200.0);\n\n            // TODO : better weighing for the 2 factors to narrow down on AA p\n            // gets affected by castRay precision variable\n            \n            //aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            // visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            // visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            //pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        // pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        sP = pos;\n        sR = reflect(normalize(rd),normal);\n        \n        return pixelData; \n    }    \n}\n\n\n// ~~~~~~~ generate camera ray direction, different for each frag/pixel\n// input fCoord --> pixel coordinate\n// input cMatric --> camera matrix\n// output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) / iResolution.y;\n        \n    // determines ray direction based on camera matrix\n    // \"lens length\" seems to be related to field of view / ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n// ~~~~~~~ render anti aliased, based on pixel's itteration/march count\n//          only effective for shape edges, doesn't fix surface col patterns\n// input fCoord --> pixel coordinate\n// input cPos --> camera position\n// input cMat --> camera matrix\n// output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec3 dumSP;\n    vec3 dumSR;\n    vec4 pData = render(cPos,rd,aaF,dumSP,dumSR);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    // controls blur amount/sample distance\n    float aaPD = 0.500;\n    // if requires AA, get color from nearby pixels and average out\n    //col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy,dumSP,dumSR).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy,dumSP,dumSR).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy,dumSP,dumSR).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy,dumSP,dumSR).xyz;\n                \n        /*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0/8.0;     \n        */\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        // used to visualize pixels that are getting AA\n        //col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n// ~~~~~~~ creates camera matrix used to transform ray point/direction\n// input camPos --> camera position\n// input targetPos --> look at target position\n// input roll --> how much camera roll\n// output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 6.3333;\n    float oOff = 0.00750;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iTime + oOff);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iTime + oOff);\n    vec3 camPos = vec3(camPosX, 2.015, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    // ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {       \n        float dum = 0.0;\n        vec3 renderedSurfPos;\n        vec3 rendererdSurfRefl;\n        for(int i = 0; i < lightBounceCount; i++)\n        {   \n            if(i == 0)\n            {\n                vec3 dumSR;                 \n                col = render(camPos,rd,dum,renderedSurfPos,rendererdSurfRefl).xyz;\n            }\n            else\n            {\n             \tfloat bounceAttenRatio = 0.01 + 0.5*(1.0 - float(i)/float(lightBounceCount));\n                vec3 bCol = render(renderedSurfPos,rendererdSurfRefl,dum,renderedSurfPos,rendererdSurfRefl).xyz;\n                //col += 0.133333*vec3(length(bCol));\n                col += bounceAttenRatio* bCol;\n            }\n                \n        }\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fragCoord.xy/iResolution.y,0,0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldt3Dr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1630, 1851, 1880, 1880, 2783], [2786, 2921, 2954, 2954, 2982], [2984, 4211, 4240, 4240, 4464], [4614, 5030, 5061, 5061, 5184], [5305, 5518, 5541, 5541, 5559], [5561, 5836, 5878, 5878, 5979], [5981, 6279, 6322, 6322, 6613], [6615, 6854, 6898, 6898, 7030], [7032, 7204, 7232, 7232, 7302], [7304, 7529, 7561, 7561, 7590], [7592, 7870, 7888, 7913, 9576], [9578, 9899, 9956, 10010, 11189], [11192, 11397, 11441, 11441, 12091], [12093, 12376, 12420, 12420, 13135], [13137, 13340, 13391, 13391, 13851], [13853, 14143, 14173, 14173, 14499], [14501, 14710, 14751, 14773, 15308], [15310, 15526, 15561, 15561, 15599], [15601, 16054, 16129, 16129, 16320], [16323, 16634, 16708, 16708, 19435], [19438, 19610, 19659, 19659, 19973], [19976, 20271, 20320, 20320, 22139], [22141, 22380, 22445, 22445, 22651], [22653, 22653, 22710, 22773, 24176]]}
{"id": "ldt3W8", "name": "My First Julia Set", "author": "kylefeng28", "description": "My first attempt at using GLSL/Shadertoy.", "tags": ["fractal", "juliaset"], "likes": 6, "viewed": 778, "published": "Public API", "date": "1449445631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by http://nuclear.mutantstargoat.com/articles/sdr_fract/\n\n// Define new coordinate system ranges\nvec2 xRange = vec2(-1.5, 1.5);\nvec2 yRange = vec2(-1.5, 1.5);\n\n// Define Julia set constants\nconst int nIter = 100; // Number of iterations\nvec2 c = vec2(-0.4, 0.6); // c = a + bi\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Transform to new coordinate system\n    vec2 z = fragCoord.xy / iResolution.xy;\n    z.x = z.x * (xRange[1] - xRange[0]) + xRange[0];\n    z.y = z.y * (yRange[1] - yRange[0]) + yRange[0];\n    \n    // Define r, g, b components\n    float r, g, b, a = 1.0;\n    \n    // Transform c somehow\n    c.x = -0.4 + 0.1 * cos(iTime / 2.0);\n    c.y = 0.6 + 0.1 * sin(iTime + 0.5);\n   \n    // Iterate\n    int i;\n    for (int i_ = 0; i_ < nIter; i_++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if ((z.x * z.x + z.y * z.y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n        \n        i = i_;\n    }\n \n    r = g = b = float(i) / float(nIter);\n    \n    // Set color\n\tfragColor = vec4(r, g, b, a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldt3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 291, 346, 388, 1100]]}
{"id": "ldt3zj", "name": "Shifting Rock", "author": "hanmaokun", "description": "A steal and composition of guil's \"Rocky Coast\" and Malhar's \"Shifting Islands\", with a view angle of looking straight down from up. I had to say I am no expert on CG, and don't really understand the alg inside, but this awesome community makes it easy :)", "tags": ["procedural", "3d", "sea", "rock"], "likes": 6, "viewed": 449, "published": "Public", "date": "1451034783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CHANGE_SPEED \t0.06\t\t\t/* terrain changing speed */\n\nconst float scope = 2.2;\n\nfloat dh = 0.;\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\n/*\n * shifting terrain model\n *\n * steal from Malhar's work: \"Shifting Islands\".\n * (https://www.shadertoy.com/view/MsBSDW)\n */\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec2 pos)\n{\n  vec3 v = vec3(pos * 0.6, iTime * CHANGE_SPEED);\n\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  float result = 50.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n\n  return result;\n}\n\n/*\n * main scene model.\n *\n * steal from guil's work: \"Rocky coast\".\n * (https://www.shadertoy.com/view/ltlGDX)\n */\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ )\n\t{\n        p=m2*p*f+.6;\n        f*=1.2;\n        res+=sin(p.x+sin(2. * p.y));\n\t}\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\tp *= 0.5;\n\tfloat f=1.;\n\tfloat r = 0.0;\n    for(int i = 0;i<8;i++){\n\t\tr += abs(snoise( p*f ))/f;\n\t    f *=2.;\n        p-=vec2(.01,.01)*r;\n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p )\n{\n\tfloat f = 1.;\n\tfloat r = 0.0;\n    for(int i = 0; i<8; i++){\n\t\tr += (1.-abs(noise( p*f -.12*iTime)))/f;\n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r/4.+.5;\n}\n\nfloat rocks(vec2 p){\n    return 1.35*fbmabs(p);\n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-.4*fbmabs(scope*p.xz);\n\tfloat d2 =p.y-.4*sea(scope*p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\n\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .05,//.008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\n\treturn sin(vec3(1.7,1.5,1)+1. + .45*fbmabs(p*4. - .02*iTime));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n/*\n * main entry.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n\n    vec3 li = normalize(vec3(-2., 2., -2.));\n\n    /*\n     * world coordinates calc.\n     * according to 'http://9bitscience.blogspot.jp/2013/07/raymarching-distance-fields_14.html';\n     * this is looking straight down from 'up'.\n     */\n\tvec3 right = vec3(1, 0, 0);\n\tvec3 front = vec3(0, 0, 1);\n\tvec3 ro = right * p.x + front * p.y;\n\tro.y += 1.0;\n\tvec3 rd = normalize(cross(right, front));\n\n\t/*\n\t * raymarching.\n\t */\n    float t = march(ro, rd);\n\n    if(t > -0.001)\n    {\n        if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n\n        float k=rocks(scope*pos.xz);\n\n        vec3 nor = normalRocks(scope*pos.xz);\n        float r = max(dot(nor, li), 0.05)/2.;\n        if(dh < 0. && dh > -.08) r+=.5*exp(20. * dh);\n\n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.08){\n        \tvec3 nor = normalSea(scope*pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.yz);\n        }\n\t    col = .1+col1;\n\n\t}\n\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldt3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 268, 289, 289, 338], [340, 340, 361, 361, 410], [412, 412, 434, 434, 474], [476, 476, 504, 504, 556], [558, 558, 582, 582, 2469], [2471, 2587, 2610, 2610, 2770], [2772, 2772, 2796, 2796, 2950], [2952, 2952, 2973, 2973, 3141], [3143, 3143, 3163, 3163, 3192], [3194, 3194, 3214, 3214, 3353], [3355, 3355, 3384, 3384, 3543], [3545, 3545, 3572, 3572, 3717], [3719, 3719, 3740, 3740, 3806], [3808, 3808, 3845, 3845, 4142], [4144, 4166, 4223, 4223, 5330]]}
{"id": "ldtGDn", "name": "hsv orbs", "author": "Tetane", "description": "Circle of dots using HSV color vector.", "tags": ["light", "hsv", "dots"], "likes": 22, "viewed": 620, "published": "Public", "date": "1449092133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\nconst float dotsnb = 30.0; // Number of dots\n\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\tvec2 m = iMouse.xy/mx;\n    \n    vec2 pos  = vec2(0.0); \t\t\t// Position of the dots\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat radius = 0.15;\t\t\t// Radius of the circle\n\tfloat intensity = 1.0/500.0;\t// Light intensity\n\t\n\tfor(float i = 0.0 ; i<dotsnb ; i++){\n\t\t\n\t\tpos = vec2(\tradius*cos(2.0*pi*i/dotsnb+iTime),\n\t\t\t   \t\tradius*sin(2.0*pi*i/dotsnb+iTime*2.0/3.0));\n\t\t\n\t\tcol += hsv2rgb(vec3(i/dotsnb, distance(uv,scrs/2.0 + pos)*(1.0/intensity), intensity/distance(uv,scrs/2.0 + pos)));\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 65, 90, 122, 273], [275, 275, 332, 332, 1001]]}
{"id": "ldtGDr", "name": "api-test", "author": "kalin", "description": "api-test", "tags": ["apitest"], "likes": 6, "viewed": 704, "published": "Public API", "date": "1449120866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float tau = 3.1415926535*2.0;\n\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a/tau,r);\n\t\n\t//get the color\n\tfloat xCol = (uv.x - (iTime / 3.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\n\t//fragColor = vec4(xCol);\n\t//return;\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\n\t// draw color beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = (0.7+0.5*cos(uv.x*10.0*tau*0.15*clamp(floor(5.0 + 10.0*cos(iTime)), 0.0, 10.0))) * abs(1.0 / (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\tfragColor = vec4(horBeam * horColour, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 916]]}
{"id": "ldtGR2", "name": "ChristmasTree", "author": "lovelyH", "description": "Christmas Tree.\nInsiprated by other similar shader, but I done it in different way.", "tags": ["2d", "lights"], "likes": 5, "viewed": 671, "published": "Public", "date": "1451045759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat getStar( vec2 uv, vec3 star ){\n\tif( 0.0 < star.z )\n\t\treturn 0.0;\n\telse\n\t\treturn 1.0 / (1.0 + 32.0*pow(2.0,-star.z)*length(uv-star.xy/-star.z) );\n}\n\nmat4 getMatrixIdentity(){\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 getMatrixTransform( float x, float y, float z ){\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\tx, y, z, 1.0\n\t);\n}\n\nmat4 getMatrixRotX( float l ){\n\tfloat sl= sin(l);\n\tfloat cl= cos(l);\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, cl ,-sl , 0.0,\n\t\t0.0, sl , cl , 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 getMatrixRotZ( float l ){\n\tfloat sl= sin(l);\n\tfloat cl= cos(l);\n\treturn mat4(\n\t\t cl, -sl, 0.0, 0.0,\n\t\t sl,  cl, 0.0 , 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/// projection & view matrix\n\tmat4 matrix= getMatrixIdentity()\n\t\t* getMatrixTransform( 0.0, 0.0,-2.5 )\n\t\t* getMatrixRotX( 0.4*3.14159 )\n\t\t* getMatrixRotZ( iTime )\n\t\t* getMatrixTransform( 0.0, 0.0,-1.0 )\n\t;\n\t\n\t/// screen coordiances\n\tvec2 uv= fragCoord / iResolution.xy - vec2(0.5,0.5);\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t//// retur variable\n\tvec3 r= vec3(0.0,0.0,0.0);\n\t\n\t/// geenrating lights\n\t/// chain\n\tfor( float hh=0.5;hh<2.0;hh+= 0.05){\n\t\tfloat h= 0.5*hh*hh;\n\t\tconst float sch= 2.5;\n\t\tconst float sch2= 4.5;\n\t\tfloat ch= sin(h*sch2+iTime*1.4);\n\t\tr += vec3( ch*ch, 0.1, 1.0-ch*ch) * getStar( uv, (matrix*vec4(sin(sch*3.14159*h)*(1.0-0.5*h),cos(sch*3.14159*h)*(1.0-0.5*h),h,1.0)).xyz );\n\t}\n\t/// tree\n\tfor( float scl= 0.0; scl<2.0;scl+=0.4 ){\n\t\tfloat sscl= sin(scl*3.14159);\n\t\tfloat cscl= cos(scl*3.14159);\n\t\tfor( float h=0.0;h<=2.0;h+= 0.3){\n\t\t\tfloat radius= 0.5*(1.0-0.5*h);\n\t\t\tr += vec3( 0.1, 0.5, 0.1) * getStar( uv, (matrix*vec4( sscl*radius, cscl*radius, h-0.1, 1.0)).xyz );\n\t\t}\n\t}\n\t/// star on top\n\tvec3 starColor= vec3( 0.8, 0.8, 0.1);\n\tr += starColor * getStar( uv, (matrix*vec4( -0.1, 0.0, 1.9, 1.0)).xyz );\n\tr += starColor * getStar( uv, (matrix*vec4(  0.1, 0.0, 1.9, 1.0)).xyz );\n\tr += starColor * getStar( uv, (matrix*vec4( -0.1, 0.0, 2.05, 1.0)).xyz );\n\tr += starColor * getStar( uv, (matrix*vec4(  0.1, 0.0, 2.05, 1.0)).xyz );\n\tr += starColor * getStar( uv, (matrix*vec4(  0.0, 0.0, 2.13, 1.0)).xyz );\n\tr += starColor * getStar( uv, (matrix*vec4(  0.0, 0.0, 2.0, 1.0)).xyz );\n\t\n\t\n\t/// return final color\n\tfragColor = vec4( r, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 153], [155, 155, 180, 180, 287], [289, 289, 342, 342, 443], [445, 445, 475, 475, 620], [622, 622, 652, 652, 798], [800, 800, 857, 887, 2417]]}
{"id": "ldtGz2", "name": "syltefar:Wobbly", "author": "syltefar", "description": "The shader I wrote for my first attempt at WebGL back in 2012. I copied a shader example and implemented some very basic and probably very buggy ray marching of a signed distance field, based on an explanation by Mikkel Gjl. ", "tags": ["sdf"], "likes": 4, "viewed": 182, "published": "Public", "date": "1451079115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The shader I wrote for my first attempt at WebGL back in 2012.\n// I copied a shader example and implemented some very basic and probably very\n// buggy ray marching of a signed distance field,\n// based on an explanation by Mikkel Gjl. \n\nprecision mediump float;\n\nfloat sphere( vec3 p ) { return length(p) - 1.0; }\nfloat box( vec3 p )\n{\n    return max(\n             max(\n               p.x * p.x - 0.4,\n\t           p.y * p.y - 0.4\n\t         ),\n\t       p.z * p.z - 0.4\n\t  );\n}\n\n// basic sdf stuff\nvec3 translate(vec3 p, vec3 v) { return p - v; } \nfloat or( float a, float b ) { return min(a,b); }\nfloat and( float a, float b ) { return max(a,b); }\n\nfloat sdf( vec3 p, float time) {\n    //vec3 c = vec3(8.0, 8.0, 8.0);\n    //vec3 v = p;//mod(p,c)-0.5*c;\n    float ripple = 0.05;\n    //return min( box(p), sphere(p));\n\n    //return box(translate(p, vec3(0., 0., 2.)));\n    //return and( box(p), sphere(p * 1.5) );\n\n    /*\n      return or(\n\t  sphere(translate(p, vec3(-0.5, 0., 2.))),\n\t  sphere(translate(p, vec3(+0.5, 0., 2.)))\n      );\n    */\n\n    // Wobbly\n    return distance(p, vec3(\n\t  0.0+sin(p.y* 20.0 * sin(time*2.) + time * 10.)*ripple * sin(time*5.) * 2.,\n\t  0.0+sin(p.x* 20.0 * sin(time*2.7) + time * 10.)*ripple * sin(time*3.) * 2.,\n\t  2.0)) - 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy * 2.2;\n    vec3 pos = vec3(uv.x-1.9, uv.y-1.1, 0.0);\n    vec3 direction = pos - vec3(0.0, 0.0, -1.0);\n\n    // ray marching\n    float d = 10.0;\n    for(int i =0; i < 256; i++) {\n\t  d = sdf(pos, iTime );\n\t  pos += direction * d;\n\t  if(d < 0.02 || pos.z > 100.0) break;\n    }\n\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    if(d<=0.02) {\n\n\t  // estimate normal based on finite difference approx of gradient\n\t  vec3 gradient = sdf(pos, iTime) - vec3(\n\t      sdf(pos + vec3(.001,.000,.000), iTime),\n\t      sdf(pos + vec3(.000,.001,.000), iTime),\n\t      sdf(pos + vec3(.000,.000,.001), iTime)\n\t      );\n      \t  vec3 normal = normalize( gradient );\n\n\t  // red diffuse light\n\t  vec3 l = normalize(vec3(0.5,-0.5,+0.5));\n\t  r = dot( normal, l ) * 1.0;\n\t  //r = normal.x * 0.5 + 0.5;\n\t  //g = normal.y * 0.5 + 0.5;\n\t  //b = normal.z * 0.5 + 0.5;\n\t  // green diffuse light\n\t  g = dot( normal, normalize(vec3(-0.4,0.4,+0.4))) * 0.2;\n\t  // blue diffuse light\n\t  b = dot( normal, normalize(vec3(0.9,-0.3,+0.4))) * 0.3;\n    }\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 269, 293, 293, 319], [320, 320, 341, 341, 480], [482, 501, 533, 533, 549], [551, 551, 581, 581, 600], [601, 601, 632, 632, 651], [653, 653, 685, 756, 1264], [1266, 1266, 1323, 1323, 2415]]}
{"id": "ls33Rf", "name": "fire cloud", "author": "DeMaCia", "description": "Perlin Noise simpleness test", "tags": ["perlinnoise"], "likes": 4, "viewed": 630, "published": "Public API", "date": "1451293913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat randomNoise(vec2 p)\n{\n\treturn fract(sin(p.x * (12.9898) + p.y * (4.1414)) * 43758.5453);\n}\n\n\nfloat smoothNoise(vec2 p)\n{//cross filter \n    \n  vec2 nn = vec2(p.x, p.y+1.);\n  vec2 ee = vec2(p.x+1., p.y);\n  vec2 ss = vec2(p.x, p.y-1.);\n  vec2 ww = vec2(p.x-1., p.y);\n  vec2 cc = vec2(p.x, p.y);\n\n  float sum = 0.;\n  sum += randomNoise(nn)/8.;\n  sum += randomNoise(ee)/8.;\n  sum += randomNoise(ss)/8.;\n  sum += randomNoise(ww)/8.;\n  sum += randomNoise(cc)/2.;\n\n  return sum;\n}\n\n\nfloat BINoise(vec2 p)\n{//Bilinear interpolation\n    \n    float tiles = 64.;\n    \n\tvec2 base = floor(p/tiles);\n    p = fract(p/tiles);\n    \n    vec2 f = smoothstep(0., 1., p);\n    \n\tfloat q11 = smoothNoise(base);\n\tfloat q12 = smoothNoise(vec2(base.x, base.y+1.));\n\tfloat q21 = smoothNoise(vec2(base.x+1., base.y));\n\tfloat q22 = smoothNoise(vec2(base.x+1., base.y+1.));\n\n\tfloat r1 = mix(q11, q21, f.x);\n\tfloat r2 = mix(q12, q22, f.x);\n\n\treturn mix (r1, r2, f.y);\n} \n\n\nfloat perlinNoise(vec2 p)\n {\n\tfloat total = 0., amplitude = 1.;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\ttotal += BINoise(p) * amplitude; \n        p *= 2.;\n\t\tamplitude *= .5;\n\t}\n\treturn total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float speed = 4.;\n    \n    float t = iTime * speed;\n        \n    vec2 d1 = vec2(t * 1.,t * .5);\n    vec2 d2 = vec2(t * 2.,t * -4.);\n    vec2 d3 = vec2(t * -6.,t * 8.);\n    \n\tfloat z = perlinNoise(fragCoord - d1);\n    float x = perlinNoise(fragCoord + d2);\n    float c = perlinNoise(fragCoord - d3);\n    \n    \n\tvec3 color1 = vec3(.5, .5, .0);\n\tvec3 color2 = vec3(.8, .8, .0);\n\tvec3 color3 = vec3(.0, .0, .0);\n\tvec3 color4 = vec3(.2, .2, .2);\n\tvec3 color5 = vec3(.0, .0, .6);\n\tvec3 color6 = vec3(.0, .6, .0);\n    \n\tfragColor = vec4(mix(color1, color2, z) +\n                     mix(color3, color4, x) -\n                     mix(color5, color6, c), \n                     1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls33Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 97], [100, 100, 127, 142, 480], [483, 483, 506, 530, 945], [949, 949, 977, 977, 1136], [1139, 1139, 1196, 1196, 1922]]}
{"id": "ls33RS", "name": "Tamby's Gears", "author": "TambakoJaguar", "description": "I wanted to draw stars, but I created gears instead, very easily. Then I improved it with textures and this is the result", "tags": ["test", "gears", "shading", "metal", "rotating", "polar"], "likes": 13, "viewed": 332, "published": "Public", "date": "1450389882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Tamby's gears\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\nconst float pi = 3.14159;\nconst float bs = 0.0015;\nconst float e = 0.07;\nconst float speed = 22.;\nconst float rc = 0.025;\n\nconst float aawidth = 0.9;\nconst int aasamples = 2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 overlay(vec3 col, float v)\n{\n   return mix(mix(vec3(0.), col, clamp(v*2., 0., 1.)), vec3(1.), clamp(v*2. - 1., 0., 1.));\n}\n\nvec4 gear(vec2 uv, vec2 center, float r, float nb, float t, float rs, float ph)\n{\n    // Basic contours\n\tuv-= center + vec2(0., 0.5*(0.55 - (iResolution.x-iResolution.y)/iResolution.x)); \n    float angle = atan(uv.x, uv.y);\n    float rot = rs*iTime;\n    float v = length(uv) + r*t*(smoothstep(e, 1.-e, sin(ph + angle*nb + rot)*0.5 + 0.5));    \n    float v1 = smoothstep(r, r+bs, v);  \n    float v2 = smoothstep(e, 1.-e, cos(ph + angle*nb + rot)*0.5 + 0.5); \n    \n    // Metal texture\n    vec2 uvr = rotateVec(uv*3.2, rot/nb) - center;\n    vec2 uv2 = uv*3.2 - center;\n    vec4 txt = texture(iChannel0,uvr);\n    \n    // Metallic reflection gradient\n    vec3 grad = vec3(0.2 + .3*smoothstep(-1.0, 0.5, uv2.y+0.5) -0.3*smoothstep(0.12, 0.31, uv2.y+1.1) + 0.6*smoothstep(0.15, 0.57, uv2.y+1.7) + 0.3*smoothstep(0.35, 0.55, uv2.y+1.) - 0.6*smoothstep(0.6, 0.95, uv2.y+1.1));\n    vec3 i = mix(mix(grad, txt.rgb, 0.28 + grad.x*0.2), vec3(1.), v1);\n    float v3 = 0.3 + 0.5*v2*smoothstep(r+0.005, r-0.005, v)*smoothstep(r-0.008, r-0.004, v) + 0.2*smoothstep(r, r-bs, v+0.008); \n    i = mix(overlay(i, v3), vec3(1.), v1);\n    \n    // Shadow\n    float vs = length(uv + (0.02, 0.02)) + 0.3*r*t*(smoothstep(e, 1.-e, sin(ph + atan(uv.x + 0.02, uv.y + 0.02)*nb + rot)*0.5 + 0.5));  \n    float sh = mix(1., 1. - 0.5*smoothstep(r, r-0.05, vs-0.008), v1);\n    \n    return vec4(i*vec3(sh), v1);\n}\n\nvec3 gears(vec2 fragCoord, vec2 of)\n{\n    vec2 uv = (fragCoord.xy + of) / iResolution.xx;\n    \n    // We have five gears\n    vec4 v = gear(uv, vec2(0.22, 0.34), 0.2, 20., 0.15, speed, 0.);\n    v*= gear(uv, vec2(0.498, 0.34), 0.1, 9., 0.3, -speed, 1.9);\n    v*= gear(uv, vec2(0.777, 0.34), 0.2, 20., 0.15, speed, 2.5);\n    v*= gear(uv, vec2(0.38, 0.14), 0.08, 7., 0.35, -speed, -0.8);\n    v*= gear(uv, vec2(0.64, 0.04), 0.15, 14., 0.22, -speed, 2.2);\n    \n    // Background\n    float v1 = v.a;\n    vec3 bg = mix(vec3(1.0), mix(vec3(1., 0.95, 0.9), 0.4+texture(iChannel1,uv*4.).rgb, 0.5), clamp(v1, 0., 1.));\n\n    return v.rgb*bg;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    // Antialiasing\n    vec3 vs = vec3(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= gears(fragCoord, vec2(ox, oy));\n       }\n    }\n    vec3 i = vs/vec3(aasamples*aasamples);\n    \n    fragColor.xyz = i;\n\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls33RS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 356, 396, 396, 526], [528, 528, 561, 561, 655], [657, 657, 738, 760, 2034], [2036, 2036, 2073, 2073, 2670], [2672, 2672, 2727, 2749, 3128]]}
{"id": "ls33WN", "name": "Visual illusion 1", "author": "834144373", "description": "Visual illusion.\noriginal shader by my [url]http://www.glslsandbox.com/e#29390.2[/url]", "tags": ["2d", "effect", "visualillusion"], "likes": 7, "viewed": 577, "published": "Public API", "date": "1449636669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Visual illusion.glsl\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//Created by 834144373 () 2015/12/8\n//Tags: 2D,visual illusion,effect\n//-----------------------------------------------------------------------------------------\n\n#define t iTime/15.\n#define q 0.77\n\nvoid mainImage(out vec4 o,in vec2 u) {\n\tvec2 uv = ( 2.*u.xy - iResolution.xy)/iResolution.y;\n\t\n\tfloat r; \n\t\n\tfloat rr = length(uv);\n\t\n\tr = length(uv)-t*sign(rr-q);\n\t\n\tr = sin(r*80.);\n\t\n\tr = smoothstep(-0.4,0.4,r);\n\t\t\n\to = vec4( r,r,r, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls33WN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 333, 371, 371, 576]]}
{"id": "ls33zX", "name": "Aqua Bubbles", "author": "BreakfastBrew", "description": "Bloop Bloop", "tags": ["blobs", "bubbles", "aqua"], "likes": 9, "viewed": 794, "published": "Public API", "date": "1451266634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 p) // Based off Las^Mercury and XT95 \"Flame\" shader I made this Aqua version.\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(tan(a+2.),tan(1.+a), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1,1,1), vec4(.0,-2.,.0,1.));\n\treturn d + (noise(p+vec3(.2,iTime*1.,.0)));\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(5.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.1;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1,-1,-1,1), vec4(-1,1,1,-1), p.y*.01+.9);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*4.,3.1));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls33zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 96, 96, 317], [319, 319, 351, 351, 388], [390, 390, 411, 411, 512], [514, 514, 535, 535, 581], [583, 583, 618, 618, 895], [897, 897, 954, 954, 1300]]}
{"id": "ls3GD8", "name": "squarepathways", "author": "vortex", "description": "Tiled motion, the two colors represent opposite direction.", "tags": ["tiles"], "likes": 23, "viewed": 230, "published": "Public", "date": "1449251459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float th=0.08;\nfloat pass=0.0;\nfloat C(vec2 x, vec2 c, float r, float dir)\n{\n    float r2=dot(x-c,x-c);\n    bool k=(r2>(r-th)*(r-th)&&r2<(r+th)*(r+th));\n    if (k&&abs(fract((atan((x-c).y,(x-c).x)/(2.0*3.1415927)*16.0*r\n                      +iTime*dir))-0.5)<0.2) pass=1.0;\n    return k?-1.0:1.0;\n}\n\nfloat L(vec2 x, vec2 c, vec2 d,float dir)\n{\n    float a=dot(x-c,d);\n    bool k=(a>-th&&a<th);\n    if (k&&abs(fract(dot(vec2(-d.y,d.x),x-c)*2.0-iTime*dir)-0.5)<0.2)\n        pass=1.0;\n    return k?-1.0:1.0;\n}\n\nfloat R(vec2 x)\n{\n    return fract(0.985*x.x+0.751*x.x*x.x\n        +1.241*x.y-0.541*x.y*x.y+0.412137*x.x*x.y+0.7532)>0.5?1.0:-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 x = (fragCoord.xy-3.0*iMouse.xy)/30.0+iTime*vec2(0.4,0.03);\n    vec2 X = floor(x);\n    float c=R(X);\n    float r=c*R(X+vec2(1,0));\n    float u=c*R(X+vec2(0,1));\n    float l=c*R(X+vec2(-1,0));\n    float d=c*R(X+vec2(0,-1));\n    \n    vec2 uv=x-X-vec2(0.5);\n    float a=c;\n    if (max(abs(uv.x),abs(uv.y))>0.47) a=-0.2;\n    if (r*l>0.0&&u*d>0.0&&u*r>0.0&&r<0.0)\n    {\n    \ta*=C(uv,vec2(0.0),0.25,-c);\n    }\n    else\n    {\n        if (r>0.0)\n        {\n            if      (u>0.0) a*=C(uv,vec2(0.5,0.5),0.25,c);\n            else if (l>0.0) a*=L(uv,vec2(0.0,0.25),vec2(0,1),c);\n\t\t\telse if (d>0.0) a*=C(uv,vec2(0.5,-0.5),0.75,-c);\n            else            a*=uv.x>0.0?\n                (L(uv,vec2(0.0,0.25),vec2(0,1),c)*\n                 L(uv,vec2(0.0,-0.25),vec2(0,-1),c))\n                :C(uv,vec2(0.0,0.0),0.25,-c);\n\t\t}\n        if (u>0.0)\n        {\n            if      (l>0.0) a*=C(uv,vec2(-0.5,0.5),0.25,c);\n            else if (d>0.0) a*=L(uv,vec2(-0.25,0.0),vec2(-1,0),c);\n\t\t\telse if (r>0.0) a*=C(uv,vec2(0.5,0.5),0.75,-c);\n            else            a*=uv.y>0.0?\n                (L(uv,vec2(0.25,0.0),vec2(1,0),c)*\n                 L(uv,vec2(-0.25,0.0),vec2(-1,0),c))\n                :C(uv,vec2(0.0,0.0),0.25,-c);\n\t\t}\n        if (l>0.0)\n        {\n            if      (d>0.0) a*=C(uv,vec2(-0.5,-0.5),0.25,c);\n            else if (r>0.0) a*=L(uv,vec2(0.0,-0.25),vec2(0,-1),c);\n\t\t\telse if (u>0.0) a*=C(uv,vec2(-0.5,0.5),0.75,-c);\n            else            a*=uv.x<0.0?\n                (L(uv,vec2(0.0,0.25),vec2(0,1),c)*\n                 L(uv,vec2(0.0,-0.25),vec2(0,-1),c))\n                :C(uv,vec2(0.0,0.0),0.25,-c);\n\t\t}\n        if (d>0.0)\n        {\n            if      (r>0.0) a*=C(uv,vec2(0.5,-0.5),0.25,c);\n            else if (u>0.0) a*=L(uv,vec2(0.25,0.0),vec2(1,0),c);\n\t\t\telse if (l>0.0) a*=C(uv,vec2(-0.5,-0.5),0.75,-c);\n            else            a*=uv.y<0.0?\n                (L(uv,vec2(0.25,0.0),vec2(1,0),c)*\n                 L(uv,vec2(-0.25,0.0),vec2(-1,0),c))\n                :C(uv,vec2(0.0,0.0),0.25,-c);\n\t\t}\n    }\n    fragColor=vec4(mix(vec3(0.5,0.7,0.6)+a*vec3(0.5,0.2,0.4),\n                       mix(vec3(0.99,0.1,0.4),vec3(0.88,0.99,0.1),c*0.5+0.5),pass),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 82, 82, 305], [307, 307, 350, 350, 513], [515, 515, 532, 532, 647], [649, 649, 706, 706, 2898]]}
{"id": "ls3GDM", "name": "2015/12/13", "author": "hughsk", "description": "Experimenting a little more with reflections and drawing backgrounds.", "tags": ["reflection", "grid", "sdf", "box", "spin", "environment", "ripple"], "likes": 30, "viewed": 1208, "published": "Public API", "date": "1449989520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GLSLIFY 1\n\nvec2 doModel(vec3 p);\n\nvec2 squareFrame_1540259130(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 calcRayIntersection_3557608877(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 90; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_3557608877(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_3557608877(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal_3997203925(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps ).x +\n                    v2 * doModel( pos + v2*eps ).x +\n                    v3 * doModel( pos + v3*eps ).x +\n                    v4 * doModel( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_3997203925(vec3 pos) {\n  return calcNormal_3997203925(pos, 0.002);\n}\n\nmat3 calcLookAtMatrix_1460171947(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_870892966(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_870892966(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_1460171947(origin, target, 0.0);\n  return getRay_870892966(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera_421267681(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame_1540259130(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_870892966(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\nhighp float random_2281831123(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat gaussianSpecular_529295689(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n// Originally sourced from:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdBox_1062606552(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat smin_1535977339(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fogFactorExp2_2315452051(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat doBox(vec3 p) {\n  p += vec3(0, 1, 0) * sin(iTime * 3.);\n  p.xz = rotate2D(p.xz, (iTime * 5. + sin(0.8 + iTime * 3.)) * 0.7);\n  p.xy = rotate2D(p.xy, (iTime * 5. + sin(0.8 + iTime * 3.)) * 0.5);\n\n  return sdBox_1062606552(p, vec3(0.3) - 0.05) - 0.05;\n}\n\nfloat doBoard(vec3 p) {\n  const float boardRound = 0.125;\n\n  float d;\n\n  d = p.y - max(-1.0, 2.5 - length(p.xz)) * (sin(length(p.xz) * 12. - iTime * 10. + sin(iTime * 3.) * 2.) * 0.5 + 0.5) * 0.1 + 1.0;\n  d = -smin_1535977339(-d, -sdBox_1062606552(p, vec3(2, 2.25, 2) - boardRound) + boardRound * 2., 0.06);\n  d = -smin_1535977339(-d, length(p + vec3(0, 1, 0) * sin(iTime * 3.)) - 0.5, 1.25);\n\n  return d;\n}\n\nvec2 doModel(vec3 p) {\n  p.xz = rotate2D(p.xz, iMouse.z <= 0.0 ? 0.4 : 5. * iMouse.x / iResolution.x);\n  p.y -= 1.25;\n\n  float d = 99999.0;\n  float id = 0.0;\n\n  d = min(doBoard(p), doBox(p));\n\n  return vec2(d, id);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n  return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) / denom;\n\n  return t;\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  float t = rd.y * 0.4 + 0.4;\n  vec3 grad = vec3(0.1, 0.05, 0.15) + palette(t\n    , vec3(0.55, 0.5, 0.5)\n    , vec3(0.6, 0.6, 0.5)\n    , vec3(0.9, 0.6, 0.45)\n    , vec3(0.03, 0.15, 0.25)\n  );\n\n  float d = intersectPlane(ro, rd, vec3(0, 1, 0), 8.);\n  if (d > 0.0) {\n    vec3 p = ro + rd * d;\n    float g = (1.0 - pow(abs(sin(p.x * 1.25) * cos(p.z * 1.25)), 0.06125));\n\n    grad += (1.0 - fogFactorExp2_2315452051(d, 0.04)) * vec3(0.5, 2.5, 1.9) * g * 0.18;\n  }\n\n  return grad;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n  vec2 uv = squareFrame_1540259130(iResolution.xy, fragCoord.xy);\n\n  float rotation = 0.9;\n  float height   = iMouse.z <= 0.0 ? 5.0 : (1.0 - iMouse.y / iResolution.y * 2.0) * 10.;\n  float dist     = 6.0;\n  orbitCamera_421267681(rotation, height, dist, iResolution.xy, ro, rd, fragCoord.xy);\n\n  vec3 color = bg(ro, rd);\n\n  vec2 t = calcRayIntersection_3557608877(ro, rd, 20., 0.001);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal_3997203925(pos);\n\n    vec3 ldir1 = normalize(vec3(-0.25, 1, -1));\n    vec3 ldir2 = normalize(vec3(0, -0.8, 1));\n\n    color = bg(pos, reflect(rd, nor)) + 0.05;\n    color += 2. * gaussianSpecular_529295689(ldir1, -rd, nor, 0.085);\n    color += 0.55 * gaussianSpecular_529295689(ldir2, -rd, nor, 0.15);\n\n  } else {\n    color = bg(ro, rd);\n  }\n\n  color.g = smoothstep(-0.09, 1.1, color.g);\n  color.r = smoothstep(0.0, 1.02, color.r);\n  color.b += 0.015;\n  color -= (dot(uv * 0.05, uv)) * vec3(0.5, 0.3, 0.6);\n  color += (uv.y * 0.5 + 0.5) * vec3(0.005, -0.05, 0.105) * 0.6;\n  color += random_2281831123(fragCoord.xy * 0.001 + sin(iTime)) * 0.04;\n\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 100, 100, 224], [226, 226, 318, 318, 709], [711, 711, 777, 777, 852], [854, 854, 903, 903, 1279], [1281, 1281, 1319, 1319, 1365], [1367, 1367, 1439, 1439, 1630], [1632, 1632, 1702, 1702, 1762], [1764, 1764, 1847, 1847, 1973], [1975, 1975, 2164, 2164, 2444], [2687, 2687, 2808, 2808, 2960], [2962, 3061, 3117, 3117, 3224], [3226, 3226, 3276, 3276, 3375], [3377, 3377, 3454, 3454, 3568], [3570, 3570, 3602, 3602, 3657], [3659, 3659, 3680, 3680, 3916], [3918, 3918, 3941, 3941, 4325], [4327, 4327, 4349, 4349, 4543], [4545, 4545, 4617, 4617, 4658], [4660, 4660, 4722, 4722, 4811], [4813, 4813, 4840, 4840, 5318], [5320, 5320, 5375, 5375, 6542]]}
{"id": "ls3GR2", "name": "_Fract0001x", "author": "Bagzy", "description": "Fist", "tags": ["test"], "likes": 4, "viewed": 242, "published": "Public", "date": "1450812098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define SC (250.0)\n\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat detailH( in vec2 x )\n{\n    float d = 0.0;//50.0*texture( iChannel2, x*0.03/SC, 0.0 ).x;\n    return d + 0.5*texture( iChannel2, x*2.0/SC, 0.0 ).x;\n}\n\nfloat detailM( in vec2 x )\n{\n    float d = 0.0;//50.0*texture( iChannel2, x*0.03/SC, 0.0 ).x;\n    return d;\n}\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    float de = detailH(x);\n\treturn SC*100.0*a - de;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn SC*100.0*a - detailH(x);\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*100.0*a;\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    // bounding plane\n    float tmin = 1.0;\n    float tmax = 1000.0*SC;\n#if 1\n    float maxh = 300.0*SC;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        // sky\t\t\n\t\tcol = vec3(0.3,.55,0.8)*(1.0-0.8*rd.y)*0.9;\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, vec3(0.7,0.75,0.8), pow( 1.0-max(rd.y,0.0), 8.0 ) );\n\t}\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        //nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        \n        // rock\n\t\tfloat r = texture( iChannel0, (7.0/SC)*pos.xz/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\n\t\t// snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y/SC + 25.0*fbm(0.01*pos.xz/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         // lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*20.0,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,0.80)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(light1,ref), 0.0, 1.0),16.0);\n        col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n\t\t// fog\n        //float fo = 1.0-exp(-0.000004*t*t/(SC*SC) );\n        float fo = 1.0-exp(-0.001*t/SC );\n        vec3 fco = 0.7*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n\n        // sun scatter\n\t\tcol += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t/SC));\n\t}\n\n    // gamma\n\tcol = pow(col,vec3(0.4545));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x/iResolution.y,1.0);\n\n    float time = iTime*0.15 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 11.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    \n//ro = vec3(0.0,0.0,0.0); ro += camPath(20.0 ); ro.y += terrainM( ro.xz ) + 4.0; cr = 0.0; ta = ro + vec3(0.0,0.0,-1.0);    \n    \n    // camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    // camera ray    \n\tvec3 rd = cam * normalize(vec3(s.xy,2.0));\n\n    vec3 col = render( ro, rd );\n    \n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri;\n    ro = camPath( 20.0 );\n    ro.y += terrainM( ro.xz ) + 2.0;\n    \n    fragColor = vec4( render( ro, fragRayDir ), 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "lssGRH", "previewfilepath": "https://soundcloud.com/retrotracker/tomas-danko-lotus", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/retrotracker/tomas-danko-lotus", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 48, 48, 487], [530, 530, 558, 558, 683], [685, 685, 713, 713, 794], [796, 796, 825, 825, 1121], [1123, 1123, 1152, 1152, 1427], [1429, 1429, 1458, 1458, 1721], [1723, 1723, 1796, 1796, 1985], [1987, 1987, 2030, 2051, 2310], [2312, 2312, 2353, 2353, 2594], [2596, 2596, 2624, 2624, 2697], [2700, 2700, 2721, 2721, 3004], [3006, 3006, 3061, 3061, 3238], [3240, 3240, 3279, 3279, 6347], [6349, 6349, 6406, 6406, 7201], [7203, 7203, 7297, 7297, 7448]]}
{"id": "ls3GWr", "name": "12 Bars", "author": "bendecoste", "description": "12 horizontal bars .. shift colors over time", "tags": ["bars"], "likes": 2, "viewed": 637, "published": "Public API", "date": "1448936138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int bars = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    for (int i = 0; i < bars; i += 1) {\n        float val = float(i) / float(bars);\n        if (uv.x > val) {\n            \n            float s = abs(sin(iTime * val));\n            float u = abs(cos(iTime * val));\n            float v = abs(sin(iTime));\n            \n            \n            fragColor = vec4(s, u, v, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 466]]}
{"id": "lsc3D4", "name": "Arcade: Pacman", "author": "4rknova", "description": "Pacman", "tags": ["pacman"], "likes": 5, "viewed": 848, "published": "Public API", "date": "1449619170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define EPS 5e-5\n\n#define SZ_PANE   30.0 // Resolution\n#define SZ_DOTS    4.0 // Dot size\n#define SZ_PMAN   16.0 // Pacman size\n#define DS_DOTS   32.0 // Dot distances\n#define SP_SCROLL 70.0 // Dot scrolling speed\n\nvoid bgnd(inout vec4 fb, vec2 uv, float t)\n{\n    fb = vec4(vec3(0),1);\n}\n\nvoid dots(inout vec4 fb, vec2 uv, float t)\n{\n    vec2 st = uv;\n \tst.x += t * SP_SCROLL;\n    vec2 p = vec2(2.5 * SZ_DOTS,0);\n    st.x =  mod(st.x, DS_DOTS);        \n    float r = length(st - p);    \n\tif(uv.x > -SZ_DOTS && r < SZ_DOTS) fb = vec4(1);\n    else fb = vec4(0,0,0,1);\n}\n\nvoid ghst(inout vec4 fb, vec2 uv, float t)\n{\n    vec2 p = vec2(-SZ_PMAN * 3., 0);\n    vec2  d = uv - p;\n    float r = length(d);\n    float sz_eye   = SZ_PMAN * .3;\n    vec2 dl = d - sz_eye * vec2(-.2, .7);\n    vec2 dr = d - sz_eye * vec2(2.1, .7);\n    vec2 pl = d - sz_eye * vec2(0.4, .7);\n    vec2 pr = d - sz_eye * vec2(2.7, .7);\n\n    float wv0 = cos(PI*d.x*.3);\n    float wv1 = cos(PI*d.x*.3+PI*.85);\n        \n         if (   length(pl*pl*pl) < sz_eye\n             || length(pr*pr*pr) < sz_eye )  fb = vec4(0,0,1,1);\n    else if (   length(dl) < sz_eye \n             || length(dr) < sz_eye)         fb = vec4(1);\n    else if (r < SZ_PMAN \n             && dot(d, vec2(0,1)) >= 0.)     fb = vec4(1,0,0,1);\n    else if (dot(d, vec2(0,-1)) > 0.\n            && abs(d.x) < SZ_PMAN\n\t\t\t&& abs(d.y) < SZ_PMAN *.9 - SZ_PMAN * .15 * (fract(t*3.) > .5 ? wv0 : wv1)) {\n        fb = vec4(1,0,0,1);\n    }\n}\n\n\nvoid pman(inout vec4 fb, vec2 uv, float t)\n{\n    float r = length(uv);\n    \n    if (r < SZ_PMAN)\n    {\n        t = t * PI * .25 * (SP_SCROLL*SZ_DOTS/(DS_DOTS));\n        if (dot(vec2(1,0), normalize(uv + vec2(SZ_PMAN * .4,0))) * sin(mod(t, PI)) < .75) {\n        \tfb = vec4(1,1,0,1);\n        } else fb = vec4(0,0,0,1);\n    }\n}\n\nvoid draw(inout vec4 fb, vec2 uv)\n{\n    float t = iTime;\n    uv = floor(uv * 2.);\n    \n    bgnd(fb, uv, t);\n    dots(fb, uv, t);\n    pman(fb, uv, t);\n    ghst(fb, uv, t);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float a = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n            * vec2(a, 1) * SZ_PANE;\n    \n    draw(fragColor, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3D4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 361, 405, 405, 433], [435, 435, 479, 479, 713], [715, 715, 759, 759, 1609], [1612, 1612, 1656, 1656, 1936], [1938, 1938, 1973, 1973, 2110], [2113, 2113, 2168, 2168, 2334]]}
{"id": "lsc3DH", "name": "Twisted Tubes", "author": "Shane", "description": "Using a randomly oriented, 3D Truchet block to produce some interlaced windy tubes.", "tags": ["3d", "raymarching", "truchet"], "likes": 51, "viewed": 1799, "published": "Public API", "date": "1449319737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Twisted Tubes\n    -------------\n    \n    Fabrice and JT's 2D truchet examples inspired me to dust off some of my old 3D Truchet code.\n    I used the standard 3D Truchet block (three toroids entering and exiting six cube faces) \n    that many seem to use, so the distance equation is similar to those used in the examples \n    already on this site, but it was written independently, so it differs here and there.\n    \n    I've used one of many techniques to rotate the blocks, and have deliberately used fewer \n    rotational combinations to give the windy tubes a less constricted look. It also simplifies \n    the code enough to afford some shadows, ambient occlusion and reflections.\n    \n    The process is pretty simple: In essence, you partition space into cubic blocks, render a \n    Truchet tile using three toroidal shapes (each designed to enter one cube face and exit another), \n    then randomly rotate each block. 3D Truchet tiling is one of those things that's so easy to \n    implement, once you get the hang of it, but can be painful on your first go.\n    \n    I'll release a more simplified example with less cost cutting and window dressing soon, for \n    anyone who might be interested. I might release something with some different tile \n    variations (4 spheres in four corners, etc) as well.\n    \n    By the way, I welcome any improvements, corrections, etc.\n    \n    Other 3D Truchet examples:\n    \n    I love this, and so do many others.\n    Truchet Tentacles - WAHa_06x36\n    https://www.shadertoy.com/view/ldfGWn\n    \n    Truchet tiling on a 3D simplex grid. It's one of those exceptionally good shaders that has \n    slipped under the radar. I'm going to do a version of this from scratch with the hope that\n    I can add something new. \n    Rainbow Spaghetti - mattz\n    https://www.shadertoy.com/view/lsjGRV\n    \n    2D Examples:\n    \n    TruchetFlip - jt // Simple, square tiling.\n    https://www.shadertoy.com/view/4st3R7\n    \n    truchet 2 - FabriceNeyret2 // Hexagonal 2D tiling. \n    https://www.shadertoy.com/view/4dS3Dc\n\tBased on:\n\thexagonal tiling - mattz\n\thttps://www.shadertoy.com/view/4d2GzV\n\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    //return p*p; // Rough sRGB to RGB.\n    p = p*sqrt(p);\n    return smoothstep(0., 1., p*1.35); // Fake color enhancing. Just for this example.\n}\n\n\n// Truchet block distance function. Not much to it, all things considered.\n//\n// For a decent visualization, refer to the following:\n// Truchet tiles in 2D and 3D\n// http://paulbourke.net/texture_colour/tilingplane/index.html#truchet\nfloat map(in vec3 p){\n\n    // Random cell (unit block) ID.\n    float rnd = fract(sin(dot(floor(p) + 41., vec3(7.63, 157.31, 113.97)))*43758.5453);\n\n    // Use the random cell ID to rotate the block. Note that not all combinations are covered.\n    // This was deliberate. Feel free to add more. Ie: p.yxz, p.xzy, etc.\n    // You could also spin the cell block like so: p.xy *= rotate(PI/2.*floor(rnd*3.99)), etc.\n    // p.xz *= rotate(PI/2.*floor(rnd2*3.99)), etc.\n    //\n    // There's a way to \"step\" this and get rid of the branching, but I tried it and it's slower.\n    // I'm still not sure why. If someone has a better way to do this, I'd be more than happy\n    // to hear about it.    \n    if (rnd>.75) p = 1. - p;\n    else if(rnd>.5) p = p.yzx;\n    else if(rnd>.25) p = p.zxy;\n     \n    // Ternary version of the above. I need a GPU expert to tell me whether it's faster, or slower, \n    // than the above. I've been told that it's mostly branchless, but all expressions get evaluated...\n    // All fascinating, I'm sure, but I'd just like to know whether I should use it or not. :)\n    //p = rnd>.75? 1. - p: rnd>.5? p.yzx : rnd>.25? p.zxy : p;\n\n    // Partition space into unit blocks. Note that \"fract(p)\" only is used, as opposed to \n    // \"fract(p)-0.5.\" This effectively shifts the torus directly off center so that it's \n    // partitioned down the middle by the cube wall. That's how you get the tiling effect.\n    p = fract(p); \n\n    // Draw three toroidal shapes within the unit block, oriented in such a way to form a 3D tile.\n    // It can be a little frustrating trying to get the orientaion right, but once you get the hang\n    // of it, it really is pretty simple. If you're not sure what's going on, have a look at the \n    // picture in the link provided above. By the way, the following differs a little from the\n    // standard torii distance equations on account of slight mutations, cost cutting, etc, but \n    // that's what it all essentially amounts to.  \n    \n    // Toroidal shape one.\n    vec3 q = p; // Not rotated.\n    q.xy = abs(vec2(length(q.xy), q.z) - .5) + .175; // The \"abs\" and \".125\" are additions, in this case.\n    rnd = dot(q.xy, q.xy); // Reusing the \"rnd\" variable. Squared distance.\n\n    // Toroidal shape two. Same as above, but rotated and shifted to a different part of the cube. \n    q = p.yzx - vec3(1, 1, 0); \n    q.xy = abs(vec2(length(q.xy), q.z) - .5) + .175;\n    rnd = min(rnd, dot(q.xy, q.xy)); // Minimum of shape one and two.\n    \n    // Toroidal shape three. Same as the two above, but rotated and shifted to a different part of the cube.\n    q = p.zxy - vec3(0, 1, 0);\n    q.xy = abs(vec2(length(q.xy), q.z) - .5) + .175;\n    rnd = min(rnd, dot(q.xy, q.xy)); // Minimum of of all three.\n            \n    return sqrt(rnd) - .35; // Taking the square root and setting tube radius... kind of.\n\n\t\n}\n\n// Very basic raymarching equation. I thought I might need to use something more sophisticated,\n// but it turns out that the Truchet blocks raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0.;\n    for(int i=0; i<64; i++){\n        float d = map(ro + rd*t);\n        if (d<.001*(t*.25 + 1.) || t>40.) break;\n        t += d*.75;\n    } \n    return t;\n}\n\n// The reflections are pretty subtle, so not much effort is being put into them. Only a few iterations.\nfloat refTrace(vec3 ro, vec3 rd){\n\n    float t = 0.;\n    for(int i=0; i<16; i++){\n        float d = map(ro + rd*t);\n        if (d<.002 || t>40.) break;\n        t += d;\n    } \n    return t;\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0, d0;\n    \n   for (float i=1.0; i<=AO_SAMPLES; i++){\n   \n      d0 = i/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        dist += clamp( h, 0.01, 0.2 ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    \n    // Ray origin, set off in the YZ direction. Note the \"0.5.\" It's an old lattice trick.\n    vec3 ro = vec3(0.0, iTime/2. + 0.5, iTime/2.);\n    vec3 lp = ro + vec3(0.2, 0.5, -0.5); // Light, near the ray origin.\n\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    vec3 sp = ro + rd*t; // Surface position.\n    vec3 sn = normal(sp); // Surface normal.\n    \n    vec3 ref = reflect(rd, sn); // Reflected ray.\n    \n    vec3 oCol = tex3D(iChannel0, sp, sn); // Texture color at the surface point.\n    \n    float sh = softShadow(sp + sn*.005, lp, 16.); // Soft shadows.\n    float ao = calculateAO(sp, sn)*.75 + .25; // Self shadows. Not too much.\n    \n    vec3 ld = lp - sp; // Light direction.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse component.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n    \n    float atten = 1.0 / (1.0 + lDist*.125 + lDist*lDist*.25); // Attenuation.\n \n    \n    // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much \n    // effort is being put in.\n    float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n    vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n    vec3 rsn = normal(rsp); // Normal at the reflected surface.\n    vec3 rCol = tex3D(iChannel0, rsp, rsn); // Texel at \"rsp.\"\n    float rLDist = length(lp - rsp);\n    float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse light at \"rsp.\"\n    float rSpec =pow(max(dot(reflect(-normalize(lp-rsp), rsn), -ref), 0.), 12.); // Diffuse light at \"rsp.\"\n    // Reflected color. Not accurate, but close enough.    \n    rCol = (rCol*(rDiff + vec3(.4, .25, .2)) + vec3(1., .6, .2)*rSpec)*1./(1. + rLDist*0.125 + rLDist*rLDist*.25); \n \n   \n\n    // Combining the elements above to light and color the scene.\n    vec3 col = oCol*(diff + vec3(.4, .25, .2)*ao) + vec3(1., .6, .2)*spec + rCol*0.5;\n    \n    // Shading the scene color, clamping, and we're done.\n    col = clamp(col*atten*sh*ao, 0., 1.);\n    \n    // Half hearted gamma correction.\n\tfragColor = vec4(sqrt(col), 1.0);\n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2145, 2299, 2349, 2349, 2687], [2690, 2924, 2945, 2982, 5784], [5786, 5973, 6003, 6003, 6177], [6179, 6283, 6316, 6316, 6473], [6475, 6547, 6572, 6681, 6839], [6842, 6925, 6959, 6959, 7192], [7195, 7410, 7454, 7571, 8648], [8651, 8651, 8707, 8884, 11432]]}
{"id": "lsc3DN", "name": "Outer brush : MdSGDm+lt2XRD", "author": "PeterVivo", "description": "Experimental painting stuff. \n\nI would like try shader programming ( work with JS , AS ), so i try to combine two shader and it is work :D \nBase idea is make a small drawing program with couple of animated brush.\n", "tags": ["paintmouseinteraction"], "likes": 2, "viewed": 148, "published": "Public", "date": "1449660556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// begining of my shader learning this is = https://www.shadertoy.com/view/MdSGDm + https://www.shadertoy.com/view/lt2XRD\n\nvec3 diskWithMotionBlur( vec3 col, in vec2 uv, in vec3 sph, in vec2 cd, in vec3 sphcol )\n{\n\tvec2 xc = uv - sph.xy;\n\tfloat a = dot(cd,cd);\n\tfloat b = dot(cd,xc);\n\tfloat c = dot(xc,xc) - sph.z*sph.z;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt( h );\n\t\t\n\t\tfloat ta = max( 0.0, (-b - h)/a );\n\t\tfloat tb = min( 1.0, (-b + h)/a );\n\t\t\n\t\tif( ta < tb ) // we can comment this conditional, in fact\n\t\t    col = mix( col, sphcol, clamp(2.0*(tb-ta),0.0,1.0) );\n\t}\n\n\treturn col;\n}\n\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\nvec4 hash4( float n ) { return fract(sin(vec4(n,n+1.0,n+2.0,n+3.0))*43758.5453123); }\n\nconst float speed = 8.0;\nvec2 getPosition( float time, vec4 id ) { return vec2(       0.9*sin((speed*(0.75+0.5*id.z))*time+20.0*id.x),        0.75*cos(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\nvec2 getVelocity( float time, vec4 id ) { return vec2( speed*0.9*cos((speed*(0.75+0.5*id.z))*time+20.0*id.x), -speed*0.75*sin(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\t\n\tvec3 col = vec3(0.2) + 0.05*p.y;\n\t\n\tfor( int i=0; i<16; i++ )\n\t{\t\t\n\t\tvec4 off = hash4( float(i)*13.13 );\n        vec3 sph = vec3( getPosition( iTime, off ), 0.02+0.1*off.x );\n        vec2 cd = getVelocity( iTime, off ) /24.0 ;\n\t\tvec3 sphcol = 0.7 + 0.3*sin( 3.0*off.z + vec3(4.0,0.0,2.0) );\n\t\t\n        col = diskWithMotionBlur( col, p, sph, cd, sphcol );\n\t}\t\t\n\n    col += (1.0/255.0)*hash3(p.x+13.0*p.y);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // ---- painter \n    \n    float distance = length( fragCoord.xy - iMouse.xy );\n\n    if( iMouse.z > 0.01 && distance < abs(sin(iTime)*200.0+50.0) ) discard;\n    \n    float pulse = 0.75 + 0.25 * sin( iTime );\n    \n    fragColor = vec4(col+cos( iResolution.x/ (iMouse.x+0.00001)),1.0) + vec4( sin( distance * pulse ), cos( distance * pulse ), pulse, 1.0 ) ;\t    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 123, 213, 213, 594], [597, 597, 620, 620, 676], [677, 677, 700, 700, 762], [789, 789, 830, 830, 957], [958, 958, 999, 999, 1126], [1128, 1128, 1185, 1185, 2076]]}
{"id": "lscGzf", "name": "Square Spring", "author": "gaz", "description": "twisted the cylinder of the torus cross-section.", "tags": ["spiral", "de"], "likes": 8, "viewed": 261, "published": "Public", "date": "1451310577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat deSpiral(in vec3 p)\n{\n    // transform\n    p.y -= 1.8;\n    p.yz *= rotate(1.0);\n    // twist\n    p.xy *= rotate(p.z * 3.5);\n    // project\n    vec3 p2 = vec3(p.xy, 0.0).xzy;\n    p2.yz *= rotate(0.25);\n    // torus\n    vec2 t = vec2(1.0, 0.15);\n    vec2 q = vec2(length(p2.xz)-t.x, p2.y);\n  \tfloat de = lengthN(q,6.0) - t.y;\n    // cut\n    de = max(abs(p.z) - 1.2, de);\n    return de;\n}\n\nfloat deGroud(in vec3 p)\n{\n    return p.y;\n}\n\nfloat map(in vec3 p)\n{    \n    return min(deSpiral(p),deGroud(p));\n}\n\nvec3 doColor(in vec3 p)\n{\n\tfloat d1 = deSpiral(p);\n    float d2 = deGroud(p);\n    if (d1 < d2){\n        return vec3(0.9, 0.6, 0.2);\n    } else {   \t\n    \treturn mix(0.6*texture(iChannel0, p.xz*0.15).xxx,\n    \t\tvec3(0.4,0.6,0.2), 0.3);\n    }\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.1+0.5*p.y*p.y);\n    vec3 ro = vec3(0.0, 3.0, 4.5);\n    vec3 rd = normalize(vec3(p, 2.0));\n    ro.xz *= rotate(iTime * 0.1);\n    rd = lookat(ro, vec3(0.0,2.0,0.0)) * rd;\n    float maxd = 20.0;\n    float t = 0.0, h;\n    for(int i = 0; i < 64; i++)\n    {\n        t += h = map(ro+rd*t);\n        if(h<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 pos = ro+t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tcol = doColor(pos);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(nor, li), 0.0, 1.0);\n        dif *= softshadow(pos, li);\n        col *= max(dif, 0.3);\n        col *= max(0.5+0.5*nor.y, 0.0);\n        col += pow(clamp(dot(reflect(rd, nor), li), 0.0, 1.0), 60.0);\n        col = mix( col, vec3(0.0), 1.0-exp( -0.01*t*t ) );\n\t\tcol = pow(col, vec3(0.8));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 80], [82, 82, 124, 124, 265], [267, 267, 305, 305, 363], [365, 365, 392, 409, 756], [758, 758, 784, 784, 802], [804, 804, 826, 826, 872], [874, 874, 899, 899, 1116], [1118, 1118, 1150, 1150, 1355], [1357, 1357, 1399, 1399, 1657], [1659, 1659, 1716, 1716, 2641]]}
{"id": "lscGzX", "name": "fork of bipolar complex [wip]", "author": "Flexi", "description": "still trying to resemble this animated gif: https://www.facebook.com/Minatrixx/posts/927595880662127", "tags": ["2d", "complexpolynomials", "polarcoordinates", "logarithmiczoom"], "likes": 16, "viewed": 300, "published": "Public", "date": "1451262276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589793238462643383279\n#define pi_inv 0.318309886183790671537767526745\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n  return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n   return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n          vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 wrap_flip(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n \nfloat border(vec2 domain, float thickness){\n   vec2 uv = fract(domain-vec2(0.5));\n   uv = min(uv,1.-uv)*2.;\n   return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n\treturn clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n\treturn 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 center, vec2 aspect, float radius, float sharpness){\n\treturn 0.5 - sigmoid( ( length( (uv - center) * aspect) - radius) * sharpness) * 0.5;\n}\n\nfloat lum(vec3 color){\n\treturn dot(vec3(0.30, 0.59, 0.11), color);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n\tvec2 uv = domain - center;\n\tfloat angle = atan(uv.y, uv.x);\n\tfloat d = length(uv);\n\treturn vec2( angle*n*pi2_inv + log(d)*spiral_factor,\n                -log(d)*zoom_factor + angle * pi2_inv) + pos;\n}\n\nvec2 mobius(vec2 domain, vec2 zero_pos, vec2 asymptote_pos){\n\treturn complex_div( domain - zero_pos, domain - asymptote_pos);\n}\n\n\nvec3 gear(vec2 domain, float phase, vec2 pos){\n\tfloat angle = atan(domain.y - pos.y, domain.x - pos.x);\n\tfloat d = 0.2 + sin((angle + phase) * 10.)*0.1;\n\tvec3 col = smoothcircle(domain, pos, vec2(1), d, 128.)*vec3(1.);\n\tcol = mix(col, vec3(1,0.8,0), smoothcircle(domain, pos, vec2(1), 0.05, 256.));\n\treturn col;\n}\n\nvec3 geartile(vec2 domain, float phase){\n\tdomain = fract(domain);\n\treturn \n\t\tgear(domain, -phase, vec2(-0.25,0.25)) + \n\t\tgear(domain, phase, vec2(-0.25,0.75)) + \n\t\tgear(domain, phase, vec2(1.25,0.25)) + \n\t\tgear(domain,- phase, vec2(1.25,0.75)) + \n\t\tgear(domain, -phase, vec2(0.25,-0.25)) + \n\t\tgear(domain, phase, vec2(0.75,-0.25)) + \n\t\tgear(domain, phase, vec2(0.25,1.25)) + \n\t\tgear(domain, -phase, vec2(0.75,1.25)) + \n\t\tgear(domain, phase, vec2(0.25,0.25)) + \n\t\tgear(domain, -phase, vec2(0.25,0.75)) + \n\t\tgear(domain, -phase, vec2(0.75,0.25)) + \n\t\tgear(domain, phase, vec2(0.75,0.75));\t\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// aspect-ratio correction\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tvec2 uv_correct = 0.5 + (uv -0.5)/ aspect.yx;\n\tvec2 mouse_correct = 0.5 + ( iMouse.xy / iResolution.xy - 0.5) / aspect.yx;\n\t\t\n\tfloat phase = iTime*0.5;\n\tfloat dist = 0.75;\n    vec2 uv_bipolar = uv_correct - 0.5;\n\tuv_bipolar = mobius(uv_correct, vec2(0.5 - dist*0.5, 0.5), vec2(0.5 + dist*0.5, 0.5));\n\tuv_bipolar = spiralzoom(uv_bipolar, vec2(0.), 4., -0.*pi, 0.8, vec2(-0.125,0.125)*phase);\n\tuv_bipolar = vec2(-uv_bipolar.y,uv_bipolar.x); // 90 rotation \n\n\tvec3 gear = geartile(uv_bipolar, -phase*1.);\n\t\n\tfragColor.xyz = mix( vec3(0), vec3(0.1,0.2,0.4), uv.y);\t\t\n\tfragColor.xyz = mix(fragColor.xyz, vec3(1), gear); // blend\n    \n    vec2 re_uv = fract(uv_bipolar);\n    \n\tre_uv = vec2(cos(re_uv.y * pi*0.5) * re_uv.x,\n                  sin(re_uv.y * pi*0.5) * re_uv.x);\n    float re_i = clamp(0., 1., 1. - abs(1.-re_uv.x - re_uv.y)*2.);\n    //fragColor.rg = vec2(0.);\n\t//fragColor.rg = fract(uv_bipolar);\n    //fragColor.rg = fract(re_uv);\n    //fragColor.b = 0.;\n    fragColor = mix(fragColor, vec4(1.,0.,0.,0.), border(re_uv+0.5, 0.05)*2.);\n\tfragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 187, 187, 291], [293, 293, 344, 344, 564], [566, 566, 590, 590, 634], [637, 637, 680, 680, 810], [812, 812, 860, 860, 922], [924, 924, 948, 948, 983], [985, 985, 1070, 1070, 1159], [1161, 1161, 1183, 1183, 1229], [1231, 1231, 1332, 1332, 1534], [1536, 1536, 1596, 1596, 1663], [1666, 1666, 1712, 1712, 1979], [1981, 1981, 2021, 2021, 2571], [2572, 2572, 2629, 2629, 3822]]}
{"id": "lsd3Dr", "name": "[Test]Bounce 2", "author": "Ultraviolet", "description": "pong !", "tags": ["bouncingball"], "likes": 1, "viewed": 128, "published": "Public", "date": "1449154506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{    \n    \n    p =  bbmax-(abs(bbmax-mod( p - bbmin, (bbmax-bbmin)*2.) - bbmin));\n    return;\n    \n    \n    p = bbmin + mod(p-bbmin, 2.0*(bbmax - bbmin));\n    if(p > bbmax)\n    \tp = bbmax - (p - bbmax);\n    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.1;\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 speed = normalize(vec2(1.0, sqrt(2.0))) * 0.5;\n    vec2 p0 = vec2(0.5, 0.5) + iTime*speed;\n    \n    BoxReflect(p0, vec2(radius), vec2(ratio-radius,1.0-radius));\n    \n    float d = length(uv-p0);\n    float dd = 0.0;\n    if(d < radius)\n        dd = 1.0;\n    \n\tfragColor = vec4(vec3(dd, 0.0, 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsd3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 273], [275, 275, 336, 336, 416], [418, 418, 475, 475, 904]]}
{"id": "lsd3RB", "name": "YinYang", "author": "BigWIngs", "description": "YinYang", "tags": ["yinyang"], "likes": 22, "viewed": 622, "published": "Public", "date": "1450660917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"YinYang\" by Martijn Steinrucken aka BigWings - 2015\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415\n\nfloat circle(vec2 uv, vec2 p, float size) {\n    float dist = length(uv-p);\n    float f = fwidth(dist)/4.;\n    float circle = smoothstep(size+f, size-f, dist);\n    \n    return circle;\n}\n\nfloat circle(vec2 uv, vec2 p, float size, float thickness) {\n    float dist = length(uv-p);\n    \n    float circle = smoothstep(thickness+fwidth(dist), thickness, abs(dist-size));\n    \n    return circle;\n}\n\nvec2 rotate(vec2 uv, vec2 p, float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, s, s, -c);\n    \n    uv -= p;\n    uv *= rot;\n    uv += p;\n    \n    return uv;\n}\n\nfloat yinyang(vec2 uv, vec2 p, float size, float angle) {\n   \tuv = rotate(uv, p, angle);\n    \n    float f = fwidth(uv.x);\n    float c = smoothstep(-f, f, uv.x-p.x);\n    c *= circle(uv, p, size);\n    float s2 = size*.5;\n    \n    c *= 1.-circle(uv, vec2(p.x, p.y+s2), s2);\n    c += circle(uv, vec2(p.x, p.y-s2), s2);   // this cause edgelines\n    c += circle(uv, p, size+0.001, 0.001);\n    \n    float s3 = s2*.25;\n    c += circle(uv, vec2(p.x, p.y+s2), s3);\n    c *= 1.-circle(uv, vec2(p.x, p.y-s2), s3); \n    \n    return clamp(c, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float grid = 4.;\n    float iGrid = 1./grid;\n     float t = iTime*2.;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv1 = uv-vec2(.5);\n    \n    uv.x-=.5;\n    uv.x *= aspect;\n    \n    uv.y-=0.5;\n   \tfloat zoom = 4.-cos(t*.05)*2.5;\n    uv *= zoom;\n   // uv *= 1.+length(uv)*.2;\n\tuv.y+=0.5;\n    \n    uv = rotate(uv, vec2(.0, 0.5), -t*0.01);\n    \n    \n    \n\tvec4 col = vec4(0.);\n    \n   \n    vec2 uv2 = mod(uv+vec2(iGrid)*.5, iGrid)*grid-0.5;\n    \n    float angle = atan(uv.x, uv.y-iGrid*2.);\n\tfloat dist = t+(uv.x*uv.y);//+pow(sin(t+angle), 4.);\n    dist = length(uv1);\n    col += yinyang(uv2, vec2(.0), .4, dist*20.+t);\n \n    vec4 bg = mix(vec4(1.), vec4(0.), dist);\n    \n    col = mix(bg, vec4(0.), col);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsd3RB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 217, 260, 260, 401], [403, 403, 463, 463, 607], [609, 609, 652, 652, 803], [805, 805, 862, 862, 1344], [1347, 1347, 1404, 1404, 2202]]}
{"id": "lsd3RX", "name": "HAPPY 2016!", "author": "BigWIngs", "description": "Happy 2016 my fellow shadertoyers! Use the mouse to rotate. Use the defines to change number of particles etc. It needs a pretty beastly GPU. But if you have one, then put fullscreen, and enjoy! ;)", "tags": ["bokeh", "fireworks", "sparkles", "2016", "newyears"], "likes": 73, "viewed": 2037, "published": "Public", "date": "1451514794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"HAPPY 2016!\" by Martijn Steinrucken aka BigWings - 2015\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n// Use these to change the effect\n\n// if you have a kick ass GPU then double both of these\n#define NUM_SPARKLES 75.\n#define NUM_SUB_SPARKLES 3.\n\n#define SUB_SPARKLE_CHANCE .4\n#define PRIMARY_PARTICLE_COLOR vec3(1., 0.8, 0.5)\n#define SECONDARY_PARTICLE_COLOR vec3(1., 0.5, 0.3)\n#define MOTION_BLUR_AMOUNT 0.04\n#define SLOW_MOTION_SPEED .05\n#define SLOWMO_CYCLE_DURATION 20.\n#define NORMAL_MOTION_SPEED .9\n#define DOF vec2(1., 1.5)\n#define MIN_CAM_DISTANCE 1.5\n#define MAX_CAM_DISTANCE 7.\n\n\n\n\nfloat CAMERA_DISTANCE;\n\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\nfloat DistSqr(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } \n\nconst vec3 up = vec3(0.,1.,0.);\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec4 Noise401( vec4 x ) { return fract(sin(x)*5346.1764); }\nvec4 Noise4( vec4 x ) { return fract(sin(x)*5346.1764)*2. - 1.; }\nfloat Noise101( float x ) { return fract(sin(x)*5346.1764); }\n\n#define MOD3 vec3(.1031,.11369,.13787)\n//  3 out, 1 in... DAVE HOSKINS\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\nmat4 CamToWorldMatrix(camera c) {\n\tvec3 x = c.left;\n    vec3 y = c.up;\n    vec3 z = c.forward;\n    vec3 p = c.p;\n    \n    return mat4( \n        x.x, x.y, x.z, 0.,\n        y.x, y.y, y.z, 0.,\n        z.x, z.y, z.z, 0.,\n        p.x, p.y, p.z, 1.\n    );\n}\nmat4 WorldToCamMatrix(camera c) {\n\tvec3 x = c.left;\n    vec3 y = c.up;\n    vec3 z = c.forward;\n    vec3 p = c.p;\n    \n   return mat4( \n        x.x, y.x, z.x, -dot(x, p),\n        x.y, y.y, z.y, -dot(y, p),\n        x.z, y.z, z.z, -dot(z, p),\n         0.,  0.,  0.,          0.\n    );\n}\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat within(vec2 v, float t) {\n\treturn (t-v.x) / (v.y-v.x);\n}\n\n\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler ) {\n    // by reinder. This is clever as two hamsters feeding three hamsters.\n    \n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec4 map( in vec3 p) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    \n    float t = iTime*.1;\n    vec2 fryInterval = vec2(2., 2.2);\n    float transition = saturate(within(fryInterval, p.y));\n    transition = smoothstep(0., 1., transition);\n    \n    vec3 pos = p*3.;\n    pos.y -= t;\n    \n    vec3 normal = normalize(vec3(p.x, 0., p.z));\n    \n    float newBump = tex3D(pos, normal, iChannel1).x*.003;\n    float burnedBump = tex3D(pos, normal, iChannel0).x*.05;\n    \n    float bump = mix(newBump, burnedBump, transition);\n    \n    float d = sdCapsule(p+bump*normal, vec3(0., -10., 0.), vec3(0., 10., 0.), .1);\n    \n    return vec4(d, bump, transition, 2.);\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd ) {\n    // returns a distance and a material id\n    \n    float dmin = 1.0;\n    float dmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float d = dmin;\n    float m = -1.0;\n    float b = 0.;\n    float t = 0.;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec4 res = map( ro+rd*d );\n        if( res.x<precis || d>dmax ) break;\n        d += res.x;\n        b = res.y;\n        t = res.z;\n\t    m = res.w;\n    }\n\n    if( d>dmax ) m=-1.0;\n    return vec4( d, b, t, m );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nvec4 render( in vec3 ro, in vec3 rd, out float d ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    vec4 res = castRay(ro,rd);\n    d = res.x;\t// distance\n    float b = res.y;\t// bump\n    float t = res.z;\t// transition\n\tfloat m = res.w;\t// mat id\n    if( m>0.5 )\n    {\n        vec3 pos = ro + d*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(0.05,0.08,0.10)+mix(.35, .1, t);\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \n        float fade = saturate(within(vec2(2., 3.), pos.y));\n        fade = smoothstep(0., 1., fade);\n        fade = mix(80., 0., fade);\n        vec3 afterGlow = pow(abs(b)*fade,2.) * vec3(1., .1, .02)*2.;\n        float whiteGlow = B(2.18, 2.45, .05, pos.y+b*10.);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += amb;\n        lin += dif;\n        \n\t\tcol = col*lin;\n        \n        col += afterGlow;\n\t\tcol += whiteGlow;\n    }\n\n\treturn vec4( saturate(col), saturate(m) );\n}\n\nfloat SineWave(vec2 pos, float phase, float frequency, float amplitude, float offset, float thickness, float glow) {\n\t\t// returns a sine wave band\n    \t// takes a position from -pi,-pi to pi, pi\n\t\t\t\t\n    float dist = abs(pos.y-(sin(pos.x*frequency+phase)*amplitude-offset));  // distance to a sine wave\n    return smoothstep(thickness+glow, thickness, dist);\n}\n\nvec3 background(ray r) {\n\tfloat x = atan(r.d.x, r.d.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.d.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    float t = iTime;\n    \n\tfloat band1 = SineWave(vec2(x, y), 0., 3., .25, 0., 0.001, .5);\n    \n    return  mix(vec3(.3, .02, 0.03), vec3(0.), band1);\n}\n\n\nvec3 sparkle(ray r, vec3 p, float size, vec3 color) {\n\tfloat camDist = length(cam.p-p);\n    float focus = smoothstep(DOF.y, DOF.x, abs(camDist-CAMERA_DISTANCE));\n    \n    vec3 closestPoint = ClosestPoint(r, p);\n    float dist = DistSqr(closestPoint, p)*10000.;\n   \n    size = mix(size*5., size, focus);\n    float brightness = size/dist;\n    brightness = clamp(brightness,0., 10.);\n    \n    float bokeh = smoothstep(.01, .04, brightness)*saturate(dist*.005+.4)*.15;\n    \n    brightness = mix(bokeh, brightness, focus);\n    return color * brightness;\n}\n\nvec3 sparkles(ray r, vec2 uv, float time, float timeFactor, float dist) {\n\tvec3 col = vec3(0.);\n    \n    float n2 = fract(sin(uv.x*123134.2345)*1231.234255);\n    float n3 = fract(sin((n2+uv.y)*234.978)*789.234);\n    \n    float motionBlur = (n3-.5)*timeFactor*MOTION_BLUR_AMOUNT;\n    \n    for(float i=0.; i<NUM_SPARKLES; i++) {\t\t\t\t\t\n    \tfloat t = time+(i/NUM_SPARKLES) + motionBlur;\n        float ft = floor(t);\n        t -= ft;\n        vec3 n = hash31(i+ft*123.324);\t\t\t// per particle noise / per cycle noise\n        \n        \n        vec3 pStart = vec3(0., 2.1+n.y*.15, 0.);\n        pStart.y -= t*t*.6;\t// gravity\n        pStart.y += t;\t\t// account for slow scroll down the stick\n        \n        vec3 pEnd = pStart + (n-.5) * vec3(1., .6, 1.)*4.;\n        vec3 p = mix(pStart, pEnd, t);\n       \t\n        if(length(p-cam.p)<dist) {\n            float size = mix(10., .5, smoothstep(0., .2, t)); // in the first 20% it gets smaller very fast\n            size *= smoothstep(1., .2, t);\t\t\t\t\t// in the remaining 80% it slowly fades out\n\n            if(t>n.z && abs(n.z-.55)<SUB_SPARKLE_CHANCE) {\n                for(float x=0.; x<NUM_SUB_SPARKLES; x++) {\n                    vec3 ns = hash31(x+i);\t\t\t// per particle noise\n                    vec3 sStart = mix(pStart, pEnd, n.z);\n                    vec3 sEnd = sStart + (ns-.5) *2.;\n                    float st = saturate(within(vec2(n.z, 1.), t));\n                    vec3 sp = mix(sStart, sEnd, st);\n\n                    size = mix(10., 0.5, smoothstep(0., .1, st));\t// explosion in the first 10%\n                    size *= smoothstep(1., .9, st);\t\t\t\t\t// fade over the next 90%\n\n                    col += sparkle(r, sp, size, SECONDARY_PARTICLE_COLOR);\n                }\n            } else\n                 col += sparkle(r, p, size, PRIMARY_PARTICLE_COLOR);\n        }\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n\t\n    float t=iTime;\n    \n    //float avg = (c.r+c.g+c.b)/3.;\n    //c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tfloat t = iTime;\n    float timeFactor = fract(t/SLOWMO_CYCLE_DURATION)>.5 ? SLOW_MOTION_SPEED : NORMAL_MOTION_SPEED;\n    t *= timeFactor;\n    \n    float turn = -m.x*pi*2.+iTime*.1;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rot = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    CAMERA_DISTANCE = mix(MIN_CAM_DISTANCE, MAX_CAM_DISTANCE, sin(iTime*.0765)*.5+.5);\n    vec3 pos = vec3(0., 0.4, -CAMERA_DISTANCE)*rot;\n   \t\n    CameraSetup(uv, pos, vec3(0., 2.3, 0.), 1.);\n    \n    vec3 bg = background(cam.ray);\n    float dist;\t\t\t\t\t\t\t\t\t\t// the distance of the current pixel from the camera\n    vec4 stick = render(cam.ray.o, cam.ray.d, dist);\n    dist += .08; // add some distance to make sure particles render on top of the stick when they first come to life\n    \n    vec3 col = mix(bg, stick.rgb, stick.a);\t// composite stick onto bg\n    \n    col += sparkles(cam.ray, uv, t, timeFactor, dist);\n    \n    col = Rainbow(col);\n    \n    fragColor = vec4(col, .1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsd3RX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[262, 880, 911, 911, 944], [945, 945, 976, 976, 1008], [1122, 1122, 1147, 1147, 1181], [1182, 1182, 1205, 1205, 1247], [1248, 1248, 1275, 1275, 1309], [1350, 1382, 1404, 1404, 1555], [1556, 1556, 1577, 1577, 1693], [1745, 2266, 2299, 2299, 2517], [2518, 2518, 2551, 2551, 2801], [2803, 2803, 2870, 2870, 3366], [3368, 3368, 3399, 3399, 3430], [3433, 3433, 3495, 3569, 3719], [3721, 3787, 3839, 3839, 3953], [3955, 3955, 3977, 4058, 4649], [4651, 4651, 4691, 4735, 5140], [5142, 5142, 5184, 5184, 5483], [5485, 5485, 5517, 5517, 5738], [5741, 5741, 5775, 5828, 5877], [5879, 5879, 5931, 5954, 7041], [7043, 7043, 7159, 7237, 7403], [7405, 7405, 7429, 7429, 7698], [7701, 7701, 7754, 7754, 8251], [8253, 8253, 8326, 8326, 10102], [10104, 10104, 10126, 10126, 10347], [10349, 10349, 10406, 10406, 11567]]}
{"id": "lsdGDH", "name": " sA.2 - wave", "author": "patu", "description": ".", "tags": ["2d", "music", "visualizer"], "likes": 16, "viewed": 867, "published": "Public API", "date": "1449612206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nvec4 getFreq(float f) {\n\tfloat fft  = texture( iChannel0, vec2(f, 0.25) ).x; \n\tfloat wave = texture( iChannel0, vec2(f, 0.75) ).x;\n\tvec3 col = vec3( fft, 4.0 * fft * (1.0 - fft), 1.0 - fft ) * fft;\n    return max(vec4(col, 1.0), 0.);\n}\n\n\n#define k iChannelTime[0] * 6.\n#define t iTime * 6.\n#define v 2.\n#define fov 50.\n#define PI 3.1415\n\nvoid mainImage( out vec4 c, in vec2 f ) {\n\t\n    vec2 uv = f.xy / iResolution.xy - .5;\n\tvec2 muv = uv;\n    \n    float volF = getFreq(uv.x + .5).r / v;\n    float volM = getFreq(.9).r / v;\n    float volL = getFreq( .25).r / v;\n    c = vec4(.5, 0., .2 + sin(k / 16.), 0.) / 4. - .2;\n\n    for (float i = 8.; i > 0.; i--) {    \t\n        \n        muv = uv * tan (radians (i * 4. + fov)/2.0);\n    \t\n        muv.y += sin(k + volL + muv.x * 43.) * volM / 2.;\n        muv.y += sin(2.3 * k + PI + 2. + muv.x * 127.) * volM / 4.;\n        muv.y += sin(PI + 3. + muv.x * 32. + k * 3.12) * volL / 4.;\n        \n    \tif (muv.y < 0.02 && muv.y > -0.02) {\n    \t\tc += max(\n                vec4(1. - i * .15) * (1. - abs(muv.y) * 50.),\n                .0\n            );\n    \t}\n        \n        c -= (muv.y - .5) / 24.;\n        \n    }\n    \n    uv += .5;\n    \n    c += vec4(abs(sin(uv.y * PI) / 5.)) + hash(uv * 5. + t / 100.).x / 12.;\n    c *= .2 + 0.6 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 4.);\n    \n}", "image_inputs": [{"id": "MtXSW7", "previewfilepath": "https://soundcloud.com/thekraftwerkdatabase/ruckzuck?in=thekraftwerkdatabase/sets/kraftwerk-kraftwerk-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thekraftwerkdatabase/ruckzuck?in=thekraftwerkdatabase/sets/kraftwerk-kraftwerk-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 61, 198], [200, 200, 223, 223, 435], [538, 538, 579, 579, 1535]]}
{"id": "lsdGRS", "name": "Android Movie", "author": "dr2", "description": "Family movies anyone (mouse enabled)?", "tags": ["raymarching", "lighting", "android", "cinema"], "likes": 17, "viewed": 811, "published": "Public API", "date": "1450549582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Android Movie\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define WALL_ILLUM   // (undefine to reduce workload)\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 sunDir, qHit, rmSize;\nvec2 scrnSize;\nfloat dstFar, tCur, rAngH, rAngL, rAngA, gDisp, scrnUp;\nint idObj, idObjMv;\nbool walk;\n\nvec3 BgColMv (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    col = mix (vec3 (0.6, 0.5, 0.3),\n       0.9 * (vec3 (0.1, 0.2, 0.4) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat ObjDfMv (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  hGap = 2.5;\n  bf = PrBox2Df (p.xz, vec2 (7. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  bFac = (ip.x == 0. && ip.y == 0.) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFar;\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = pp;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.)));\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 1; }\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 2; }\n  d = p.y + 1.;\n  if (d < dMin) { dMin = d;  idObjMv = 0;  qHit = p; }\n  return dMin;\n}\n\nfloat ObjRayMv (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDfMv (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNfMv (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDfMv (p + e.xxx), ObjDfMv (p + e.xyy),\n     ObjDfMv (p + e.yxy), ObjDfMv (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFar;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjColMv (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  if (idObjMv == 1) col = vec3 (0.65, 0.8, 0.2);\n  else if (idObjMv == 2) col = vec3 (0.8, 0.8, 0.);\n  else col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.5, 0.4),\n     (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  return col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n     0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n}\n\nfloat ObjSShadowMv (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 15; j ++) {\n    h = ObjDfMv (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 28.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 + (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nvec3 ShowSceneMv (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, refl;\n  int idObjT;\n  dstHit = ObjRayMv (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObjMv;\n    vn = ObjNfMv (ro);\n    col = ObjColMv (rd, vn, dstHit);\n    idObjMv = idObjT;\n    if (idObjMv > 0) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRayMv (ro, rd);\n      if (dstHit < dstFar) {\n        ro += rd * dstHit;\n\tc = ObjColMv (rd, ObjNfMv (ro), dstHit);\n      } else {\n        c = BgColMv (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= (0.8 + 0.2 * ObjSShadowMv (ro, sunDir));\n  } else {\n    col = BgColMv (ro, rd);\n  }\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, bf;\n  dMin = dstFar;\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = 10; }\n  d = 2. * rmSize.y - p.y;\n  if (d < dMin) { dMin = d;  idObj = 11; }\n  d = rmSize.x - abs (p.x);\n  if (d < dMin) { dMin = d;  idObj = 12; }\n  d = p.z + rmSize.z;\n  if (d < dMin) { dMin = d;  idObj = 13; }\n  d = - p.z + rmSize.z;\n  if (d < dMin) { dMin = d;  idObj = 14; }\n  bf = PrBox2Df (p.xz - vec2 (0., -1.), vec2 (7.5, 6.));\n  q = p;\n  q.xz = mod (q.xz + 1.5, 3.) - 1.5;\n  q.y -= 0.25 * rmSize.y;\n  qq = q;\n  qq.y -= 1.2;\n  d = max (PrSphDf (qq, 0.85), - qq.y);\n  qq = q;\n  qq.y -= 0.2;\n  d = min (d, PrERCylDf (qq.xzy, 0.9, 0.28, 0.7));\n  qq = q;\n  qq.x = abs (qq.x) - 0.4;\n  qq.y -= 1.9;\n  qq.xy = Rot2D (qq.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (qq.xzy, 0.06, 0.04, 0.2));\n  qq = q;\n  qq.x = abs (qq.x) - 1.05;\n  qq.y -= 1.1;\n  qq.yz = Rot2D (qq.yz, 0.1 + 0.85 * rAngA * (walk ? 0. : 1.));\n  qq.y -= -0.9;\n  d = min (d, PrERCylDf (qq.xzy, 0.2, 0.15, 0.6));\n  qq = q;\n  qq.x = abs (qq.x) - 0.4;\n  qq.y -= -0.8;\n  d = min (d, PrERCylDf (qq.xzy, 0.25, 0.15, 0.55));\n  qq = q;\n  qq.x = abs (qq.x) - 0.4;\n  qq -= vec3 (0., 1.6, 0.7);\n  d = min (d, PrSphDf (qq, 0.25));\n  d = max (bf, d);\n  if (d < dMin) { dMin = d;  idObj = 15; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BrickCol (vec2 p)\n{\n  vec2 q, iq;\n  q = p * vec2 (1./62., 1./31.);\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) q.x += 0.5;\n  q = smoothstep (0.02, 0.05, abs (fract (q + 0.5) - 0.5));\n  return (0.7 + 0.3 * q.x * q.y) * vec3 (0.6, 0.55, 0.5);\n}\n\nvec3 ObjCol (vec3 p)\n{\n  vec3 col;\n  if (idObj == 10) col = vec3 (0.2, 0.15, 0.1);\n  else if (idObj == 11) col = vec3 (0.8, 0.8, 0.9);\n  else if (idObj == 12) {\n    col = BrickCol (40. * p.zy);\n  } else if (idObj == 13) {\n    col = BrickCol (40. * p.xy);\n  } else if (idObj == 15) col = vec3 (0.6);\n  return col;\n}\n\nvec3 ScrnCol (vec2 w)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float f;\n  ro = TrackPath (tCur);\n  vd = normalize (vec3 (0., 0.3 * rmSize.y, 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (w / scrnSize.y, 3.));\n  return ShowSceneMv (ro, rd);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)),\n     step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ScrnProj (vec3 ro)\n{\n  vec3 vd, col;\n  vd = normalize (vec3 (0., 1., 3.5) * rmSize - ro);\n  ro += vd * (rmSize.z - ro.z) / vd.z;\n  ro.y -= rmSize.y + scrnUp;\n  if (abs (ro.x) < scrnSize.x && abs (ro.y) < scrnSize.y) {\n    col = ScrnCol (ro.xy);\n    col = HsvToRgb (vec3 (1., 0.5, 1.) * RgbToHsv (col));\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid SetState ()\n{\n  float tCyc, wkSpd;\n  wkSpd = 0.7;\n  tCyc = mod (wkSpd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (wkSpd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  rmSize = vec3 (12., 5., 12.);\n  scrnUp = 0.15 * rmSize.y;\n  scrnSize = vec2 (0.85, 0.8) * rmSize.xy;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 2., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir, scrCol, refFac;\n  float dHit;\n  int idObjT;\n  idObj = -1;\n  dHit = ObjRay (ro, rd);\n  ro += dHit * rd;\n  vn = ObjNf (ro);\n  col = vec3 (0.);\n  refFac = vec3 (1.);\n  if (idObj == 15) {\n    refFac = vec3 (0.8, 1., 0.8);\n    for (int j = 0; j < 3; j ++) {\n      refFac *= vec3 (0.8, 0.9, 0.8);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      idObj = -1;\n      dHit = ObjRay (ro, rd);\n      ro += dHit * rd;\n      if (idObj != 15) break;\n    }\n  }\n  idObjT = idObj;\n  vn = ObjNf (ro);\n  idObj = idObjT;\n  if (idObj == 14) {\n    vec2 w = ro.xy;\n    w.y -= rmSize.y + scrnUp;\n    col = (abs (w.x) < scrnSize.x && abs (w.y) < scrnSize.y) ? ScrnCol (w) :\n       vec3 (0.);\n  } else {\n    col = ObjCol (ro);\n#ifdef WALL_ILLUM\n    scrCol = (idObj != 10) ? ScrnProj (ro) : vec3 (0.);\n#else\n    scrCol = vec3 (0.);\n#endif\n    col *= 0.2 * (1. + scrCol * (1. + max (dot (vn,\n       normalize (vec3 (0., scrnUp, rmSize.z))), 0.)));\n  }\n  return clamp (refFac * col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  SetState ();\n  az = -2. * pi * max (mod (0.011 * tCur, 1.) - 0.1, 0.) / 0.9;\n  el = 0.1 * (cos (2. * az) - 1.);\n  if (mPtr.z > 0.) {\n    el += 1. * mPtr.y;\n    az += 8. * mPtr.x;\n  }\n  el = clamp (el, -0.5, 0.5);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = vec3 (0., rmSize.y, -0.99 * rmSize.z) * vuMat;\n  ro.xz = clamp (ro.xz, - 0.98 * rmSize.xz, 0.98 * rmSize.xz);\n  ro.y = clamp (ro.y - 0.2 * rmSize.y, 0.02 * rmSize.y, 1.98 * rmSize.y);\n  rd = normalize (vec3 (uv, 3.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGRS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 323, 347, 347, 394], [396, 396, 421, 421, 620], [622, 622, 643, 643, 782], [784, 784, 817, 817, 901], [903, 903, 936, 936, 963], [965, 965, 1007, 1007, 1058], [1060, 1060, 1114, 1114, 1303], [1305, 1305, 1335, 1335, 1409], [1541, 1541, 1574, 1574, 2109], [2111, 2111, 2135, 2135, 3483], [3485, 3485, 3520, 3520, 3698], [3700, 3700, 3723, 3723, 3939], [3941, 3941, 3976, 3976, 4303], [4305, 4305, 4351, 4351, 4696], [4698, 4698, 4737, 4737, 4950], [4952, 4952, 4978, 4978, 5719], [5721, 5721, 5758, 5758, 6458], [6460, 6460, 6482, 6482, 7740], [7742, 7742, 7775, 7775, 7951], [7953, 7953, 7974, 7974, 8182], [8184, 8184, 8208, 8208, 8443], [8445, 8445, 8467, 8467, 8759], [8761, 8761, 8784, 8784, 9134], [9136, 9136, 9160, 9160, 9481], [9483, 9483, 9507, 9507, 9643], [9645, 9645, 9670, 9670, 9994], [9996, 9996, 10014, 10014, 10648], [10650, 10650, 10685, 10685, 11681], [11683, 11683, 11739, 11739, 12679]]}
{"id": "lsdGWn", "name": "shader txt", "author": "gigatron", "description": "test from glslsandbox", "tags": ["testshader"], "likes": 5, "viewed": 227, "published": "Public", "date": "1449087132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.t));\n}\n\n//--- Letters ---\nvoid G(inout float df, vec2 uv)\n{\n\t\n\tdf = min(df, dfSemiArc(0.5, 0.125, uv));\n\tdf = min(df, dfQuad(vec2(0.000, 0.375), vec2(0.000, 0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\n\tdf = min(df, dfRect(vec2(0.250, 0.50), uv - vec2(0.0,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.250,-0.125), vec2(-0.125,0.125), vec2(0.250,0.125), vec2(0.250,-0.125), uv));\t\n}\n\nvoid L(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.25), uv - vec2(-0.625,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.625), vec2(-0.375,-0.375), vec2(0.250,-0.375), vec2(0.125,-0.625), uv));\t\n}\n\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n//---------------\n\n//--- From e#26829.0 ---\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n\n\nvec3 retrograd(float x0, float x1, vec2 uv)\n{\n\tfloat mid = -0.2;// + sin(uv.x*24.0)*0.01;\n\n\tvec3 grad1 = mix(vec3(0.60, 0.90, 1.00), vec3(0.05, 0.05, 0.40), linstep(mid, x1, uv.y));\n\tvec3 grad2 = mix(vec3(1.90, 1.30, 1.00), vec3(0.10, 0.10, 0.00), linstep(x0, mid, uv.y));\n\n\treturn mix(grad2, grad1, smoothstep(mid, mid + 0.008, uv.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy / iResolution.xy;\n    vec2 aspect = iResolution.xy/iResolution.y;\n   \n\t\n\tuv = (uv - aspect/2.0)*4.0;\n\n\tfloat dist = 1e6;\n\t\n\tfloat charSpace = 1.125;\n\t\n\tvec2 chuv = uv;\n\tchuv.x += charSpace * 1.5;\n\t\t\n\tG(dist, chuv); chuv.x -= charSpace;\n\tL(dist, chuv); chuv.x -= charSpace;\n\tS(dist, chuv); chuv.x -= charSpace;\n\tL(dist, chuv); chuv.x -= charSpace;\n\t\n\tfloat mask = smoothstep(4.0/iResolution.y,0.00,dist);\n\t\n\tvec3 textcol = retrograd(-0.75,0.50,uv + vec2(0.0,-pow(max(0.0,-dist*0.1),0.5)*0.2));\n\t\n\tvec3 backcol = mix(vec3(0,0,1),vec3(1,0,1),(uv.y/4.0)+0.5) * smoothstep(0.02,0.025,dist);\n\t\n\tvec2 gdef = vec2(uv.x / abs(uv.y),1.0 / (uv.y));\n\tgdef.y = clamp(gdef.y,-1e2,1e2);\n\t\n\tvec2 gpos = vec2(0.0,-iTime);\n\t\n\tgdef += gpos;\n\t\n\tvec2 grep = mod(gdef, vec2(1.0));\n\t\n\tfloat grid = max(abs(grep.x - 0.5),abs(grep.y - 0.5));\n\t\n\tfloat gs = length(gdef-gpos)*0.01;\n\t\n\tbackcol *= mix(smoothstep(0.46-gs,0.48+gs,grid), 1.0, step(0.0,uv.y));\n\t\n\tvec3 color = mix(backcol,textcol,mask);\n       \n    \n    \n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 102], [104, 104, 163, 163, 452], [454, 454, 488, 488, 554], [556, 574, 607, 607, 933], [935, 935, 968, 968, 1148], [1150, 1150, 1183, 1183, 1612], [1632, 1657, 1702, 1702, 1735], [1738, 1738, 1783, 1783, 2076], [2079, 2079, 2136, 2136, 3201]]}
{"id": "lsdGzf", "name": "holizontal line", "author": "masaki", "description": "holizontal line", "tags": ["line"], "likes": 4, "viewed": 427, "published": "Public API", "date": "1451464547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color2 =vec4(1. - ((uv.x + uv.y) / 2.),uv,1.);\n    vec2 pos = uv*20.-10.;\n\tfragColor = color2*(1./abs(2.*sin(pos.y+20.*sin(iTime))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 252]]}
{"id": "lst3Dr", "name": "2015/12/03", "author": "hughsk", "description": "Going overboard with (likely incorrect) reflections here :)", "tags": ["3d", "reflection", "sdf", "overkill"], "likes": 14, "viewed": 974, "published": "Public API", "date": "1449142243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GLSLIFY 1\n\nvec2 doModel(vec3 p);\n\nvec2 calcRayIntersection_1_3(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 30; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_1_3(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_1_3(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal_2_4(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps ).x +\n                    v2 * doModel( pos + v2*eps ).x +\n                    v3 * doModel( pos + v3*eps ).x +\n                    v4 * doModel( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_2_4(vec3 pos) {\n  return calcNormal_2_4(pos, 0.002);\n}\n\nvec2 squareFrame_4_1(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix_5_0(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_6_2(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_6_2(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_5_0(origin, target, 0.0);\n  return getRay_6_2(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera_7_5(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame_4_1(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_6_2(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_0_6(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_0_6(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_0_7(vec4 x) {\n     return mod289_0_6(((x*34.0)+1.0)*x);\n}\n\nfloat permute_0_7(float x) {\n     return mod289_0_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_0_8(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4_0_9(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_0_10(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_0_6(i);\n  float j0 = permute_0_7( permute_0_7( permute_0_7( permute_0_7(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_0_7( permute_0_7( permute_0_7( permute_0_7 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_0_11 = grad4_0_9(j0,   ip);\n  vec4 p1 = grad4_0_9(j1.x, ip);\n  vec4 p2 = grad4_0_9(j1.y, ip);\n  vec4 p3 = grad4_0_9(j1.z, ip);\n  vec4 p4 = grad4_0_9(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_0_8(vec4(dot(p0_0_11,p0_0_11), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_0_11 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_0_8(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_0_11, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nfloat smin_3_12(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 doModel(vec3 p) {\n  vec3 P = p;\n  \n  p.z += iTime * 2.0;\n  p.xzy = mod(p.xzy + 3.0, 6.0) - 3.0;\n  \n  float r  = 0.75;\n  float d  = length(p) - r;\n  float id = 0.0;\n  \n  d = smin_3_12(d, 10.0 - length(P), 3.95);\n\n  return vec2(d, id);\n}\n\nbool bounce(vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out vec3 col) {\n  vec2 t = calcRayIntersection_1_3(ro, rd);\n  bool hits = t.x > -0.5;\n  \n  if (hits) {\n    pos = ro + rd * t.x;\n    nor = calcNormal_2_4(pos);\n    col = vec3(0.75, 0.9, 1.25) * max(0.0, dot(nor, normalize(vec3(0, 1, 0))));\n  }\n  \n  return hits;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = vec3(0.0);\n  vec3 ro, rd;\n\n  float rotation = iMouse.z > 0.0 ? 5.0 * (1.0 - iMouse.x / iResolution.x) : iTime * 0.4;\n  float height   = iMouse.z > 0.0 ? 8.0 * (1.0 - iMouse.y / iResolution.y - 0.5) : sin(iTime * 0.5) * 2.0;\n  float dist     = 4.0;\n  orbitCamera_7_5(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n  \n  vec3 pos, nor, col;\n\n  for (int i = 0; i < 3; i++) {\n    if (!bounce(ro, rd, pos, nor, col)) break;\n    color += max(vec3(0.0), col) * pow(0.325, float(i));\n    ro = pos + nor * 0.01;\n    rd = reflect(rd, nor);\n  }\n\n  color = pow(color, vec3(0.4545));\n  color.r = smoothstep(-0.05, 1., color.r);\n  color.b = smoothstep(0., 0.9, color.b);\n  color.g = smoothstep(0., 0.925, color.g);\n  color = mix(color, color * length(color), 0.25);\n  color -= 0.1;\n  \n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lst3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 127, 127, 518], [520, 520, 579, 579, 647], [649, 649, 691, 691, 1067], [1069, 1069, 1100, 1100, 1139], [1141, 1141, 1192, 1192, 1316], [1318, 1318, 1383, 1383, 1574], [1576, 1576, 1640, 1640, 1700], [1702, 1702, 1779, 1779, 1892], [1894, 1894, 2077, 2077, 2344], [2346, 2735, 2760, 2760, 2809], [2811, 2811, 2838, 2838, 2887], [2889, 2889, 2915, 2915, 2959], [2961, 2961, 2989, 2989, 3033], [3035, 3035, 3067, 3067, 3119], [3121, 3121, 3155, 3155, 3207], [3209, 3209, 3245, 3245, 3507], [3509, 3583, 3612, 3612, 6178], [6180, 6180, 6224, 6224, 6323], [6325, 6325, 6347, 6347, 6565], [6567, 6567, 6640, 6640, 6887], [6889, 6889, 6944, 6944, 7792]]}
{"id": "lst3WH", "name": "Julia Set with chromatic ", "author": "FabriceNeyret2", "description": "variant from  kylefeng28's https://www.shadertoy.com/view/ldt3W8\nBecause I love chromatic abheration :-D", "tags": ["2d", "fractal", "juliaset", "small"], "likes": 9, "viewed": 912, "published": "Public API", "date": "1449489043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant from  kylefeng28's https://www.shadertoy.com/view/ldt3W8\n\n#define N 100.\n\nfloat J(vec2 z, vec2 c ) {\n    for (float i = 0.; i < N; i++) {\n        z = mat2(z,-z.y,z.x)*z + c;\n        if ( length(z) > 2.)  return i/N;       \n    }\n\treturn 1.;\n}\n\nvoid mainImage(out vec4 o, vec2 z) {\n    vec2 R = iResolution.xy;\n    z = (z+z-R)/R.y;\n    float t = iTime-8.7;\n    \n    vec2 c, E= 0.01*vec2(1,1);\n    c.x = -.4 + .1 * cos(t *.5);\n    c.y =  .6 + .1 * sin(t + .5);\n   \n    o = vec4(J(z,c), J(z,c+E), J(z,c+2.*E), 1 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lst3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 111, 111, 253], [255, 255, 291, 291, 525]]}
{"id": "lst3Wn", "name": "2d Starfield", "author": "gigatron", "description": "Lj 2d starfield", "tags": ["starfield"], "likes": 20, "viewed": 1085, "published": "Public", "date": "1449088087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand (in vec2 uv) { return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); }\nconst vec2 O = vec2(0.,1.);\nfloat noise (in vec2 uv) {\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\n#define DIR_RIGHT -1.\n#define DIR_LEFT 1.\n#define DIRECTION DIR_LEFT\n\n#define LAYERS 8\n#define SPEED 40.\n#define SIZE 5.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < LAYERS; layer++) {\n\t\tfl = float(layer);\n\t\ts = (400.-fl*20.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s + iTime*SPEED*DIRECTION - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(LAYERS));\n\t}\n\t \n    \n    \n    \n    \n    \n    \n    \n\tfragColor = vec4( vec3(stars), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lst3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 90], [119, 119, 145, 145, 245], [371, 371, 428, 428, 819]]}
{"id": "lstGR2", "name": "Mutant britney shit with arms", "author": "Gonzague", "description": "its a mutant shit, that got some arms, and the head of britney spears singing.", "tags": ["mutantshit", "witharms"], "likes": 0, "viewed": 415, "published": "Public", "date": "1451072759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 1\n\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdEllipsoid( in vec2 p, in vec2 c, in vec2 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(r.x,r.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length( pa - ba*h ), h );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n    vec3 w = normalize( cross( c-b, a-b ) );\n    vec3 u = normalize( c-b );\n    vec3 v = normalize( cross( w, u ) );\n\n    vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n    vec2 b2 = vec2( 0.0 );\n    vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n    vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n    vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    return vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec4( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.yzw, a.yzw, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( a, b, h ) + k*h*(1.0-h);\n}\n\n//---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    \n    const float sc = 1.0/1.0;\n    p -= vec3(0.05,0.12,-0.09);    \n\n    p *= sc;\n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float n = (log(r)/b - t)/(2.0*pi);\n\n    const float th = 0.11;\n    float nm = (log(th)/b-t)/(2.0*pi);\n\n    n = min(n,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5;\n    float d1 = sqrt( (r1-r)*(r1-r) + h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5;\n    float d2 = sqrt( (r2-r)*(r2-r) + h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n\n    float di = texture( iChannel2, vec2(t+r,0.5) ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r/0.4,t/3.14159);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d/sc;\n}\n\nvec3 opTwist( vec3 p, float k )\n{\n    float cx = -0.1;\n    p.x -= cx;\n    float  c = cos(k);\n    float  s = sin(k);\n    mat2   m = mat2(c,-s,s,c);\n    vec2   q = m*p.xz;\n    return vec3(q.x+cx,p.y,q.y);\n}\n\nvec2 snail( vec3 p, out vec4 matInfo )\n{\n    vec3 head = vec3(-0.05,1.8,-0.3);\n    \n    vec3 q = p;\n\n    // body\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.0,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    float d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n   d1 = smin( d1, d2, 0.03 );\n\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    //d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n    \n    //d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    // top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n//d3 = sdEllipsoid( sq, vec3(-0.3,0.2,0.3),  vec3(af) );\n     //d3 = smin( d3, sdEllipsoid( sq,vec3(-0.3,0.2,0.3), vec3(af) ), 0.05 );\n    //d3 = smax( d3, -sdEllipsoid( sq, vec3(-0.3,0.2,0.3), vec3(af) ), 0.02 );\n    //d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n\t\n    d1 = smin( d1, d3, 0.01 );    \n    \n    // bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    // bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float angle = 8.6;\n    angle = (angle / 180.0) * 3.14;\n    float co = 0.988771078;\n    float si = 0.149438132;\n    co = cos(angle);\n    si = sin(angle);\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    //d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    //d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    // disp\n    float dis = texture( iChannel1, 1.0*p.xy ).x * 1.3;\n    float dx = 3.5 + 12.0*(1.0-smoothstep(0.5,1.0,b1.y / 3.5));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);// + 1.0*sin(5.0*p.x)*sin(5.0*p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    d = smax( d, -d2, 0.02 );\n    \n    return d;\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    //--------------\n    vec2 res = snail( p, matInfo );\n   \n     \n    //---------------\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    //if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    //res = vec2(d4, 2.0);\n    //---------------\n    \n    // plant\n    //vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    //d4 = b3.x;\n    //d4 -= 0.04 - 0.02*b3.y;\n    //if( d4<res.x  ) { res = vec2(d4,3.0); }\n    \n    //----------------------------\n    \n    float d5 = mapLeaf( p );\n    if( d5<res.x ) res = vec2(d5,4.0);\n        \n    return res;\n}\n\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n                      e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n                      e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n                      e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    //---------------\n    \n    float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    float d = min( min(d1,d4), min(d2,d3) );\n    \n    return d;\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n                      e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n                      e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n                      e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n//=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n    float ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n        ap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n    ao /= 32.0;\n    \n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n    float occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.04, 0.1 );\n        if( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    vec2 britneyOffset = vec2(1.0, -0.5);\n    vec2 britneyTexOffset = vec2(0.3, -0.2);\n\tfloat britneyRadius = 0.3;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\tvec2 britneyScale = vec2(2.0, 2.0);\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\tint check = 0;\n\tvec3 britney = vec3(0.0);\n    if( m<1.5 ) // snail body\n    {\n\t\t\n\t\tvec2 texpos = (pos.xy * 2.0 + britneyOffset);\n        if (texpos.x >= 0.6 && texpos.x <= 1.2 && texpos.y >= 0.2 && texpos.y <= 0.9)\n\t\t\tcheck = 1;\n\t\tvec2 d8 = vec2(texpos.x - 0.9, texpos.y - 0.55);\n\t\tif (sqrt(d8.x * d8.x + d8.y * d8.y) >= britneyRadius)\n            check = 0;\n        float dis = texture( iChannel1, 5.0*pos.xy ).x;\n\t\tvec4 col0 = texture(iChannel0, (pos.xy + britneyTexOffset) * britneyScale);\n\t\t//if (col0.x <= 0.5 && col0.z <= 0.5)\n\t\t//\tcheck = 0;\n\t\tbritney = vec3(col0.xyz);\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.7,1.0), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*0.01;\n        \n        mateK = vec2( 60.0, 0.7 + 1.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n    else if( m<2.5 ) // shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );\n        \n        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n        \n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;\n    }\n    else if( m<3.5 ) // plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else //if( m<4.5 ) // leave\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        \n        mateD *= 0.8;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        //---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = sdEllipsoid( q.xz, vec2( 0.5, 0.20), 1.0*vec2(0.15,0.15) );\n        d2 = sdEllipsoid( q.xz, vec2( 0.8,-0.15), 0.5*vec2(0.15,0.15) );\n        d4 = sdEllipsoid( q.xz, vec2(-0.5,-0.20), 1.0*vec2(0.04,0.04) );\n        d1 = abs(d1);\n        d2 = abs(d2);\n        d4 = abs(d4);\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n    \n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float sha = calcSoftshadow( pos, sunDir, 20.0 ); \n    dif1 *= sha*fsha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    vec3 col = 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;\n\n    col *= mateD;\n\n    col += .4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS;\n  \n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y;\n    col += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0));        \n\n    col += mateE;\n\tif (check == 1)\n    {\n        col = mix(col, britney, 0.5);\n    }\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);\n    \n    // hide aliasing a bit\n    col = mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n    \n    return col;\n}\n\n//--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n    return res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n    return res;\n}\n\nvec3 background( in vec3 d )\n{\n    // cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    \n    vec3  col = vec3( 0.0 );\n    for( int i=0; i<200; i++ )\n    {\n        float h = float(i)/200.0;\n        float an = 25.0*2.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    \n    return col;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    //-----------------------------\n\n    vec3 col = background( rd );\n    \n    //-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    //-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    //-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    //-----------------------------\n\n    return pow( col, vec3(0.45) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    #if AA<2\n    \n        vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta, 0.0 );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd );\n    \n    #else\n\n        vec3 col = vec3(0.0);\n        for( int m=0; m<AA; m++ )\n        for( int n=0; n<AA; n++ )\n        {\n            vec2 rr = vec2( float(m), float(n) ) / float(AA);\n\n            vec2 p = (-iResolution.xy+2.0*(fragCoord.xy+rr))/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta, 0.0 );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n            col += render( ro, rd );\n        }    \n        col /= float(AA*AA);\n    #endif\n        \n    col = 1.05*col + vec3(0.0,0.0,0.04);\n        \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 55, 55, 91], [93, 93, 147, 147, 211], [213, 213, 267, 267, 322], [324, 324, 357, 357, 412], [414, 414, 466, 466, 589], [591, 591, 633, 633, 763], [765, 765, 796, 796, 883], [885, 949, 978, 978, 1004], [1005, 1005, 1052, 1052, 1530], [1532, 1532, 1581, 1581, 2018], [2020, 2020, 2061, 2061, 2156], [2158, 2158, 2196, 2196, 2327], [2328, 2328, 2366, 2366, 2501], [2503, 2503, 2544, 2544, 2639], [2641, 2641, 2679, 2679, 2773], [2775, 2854, 2878, 2878, 2920], [2922, 2922, 2945, 2945, 3005], [3007, 3007, 3043, 3043, 3307], [3309, 3417, 3465, 3465, 4924], [4926, 4926, 4959, 4959, 5130], [5132, 5132, 5172, 5172, 7473], [7479, 7479, 7507, 7507, 7643], [7645, 7645, 7673, 7673, 8412], [8414, 8414, 8458, 8458, 9105], [9107, 9107, 9159, 9159, 9462], [9464, 9541, 9579, 9579, 10404], [10406, 10406, 10455, 10455, 10633], [10635, 10635, 10692, 10692, 11015], [11017, 11094, 11136, 11136, 11474], [11476, 11476, 11519, 11519, 11870], [11872, 11872, 11929, 11929, 12228], [12278, 12278, 12363, 12363, 18923], [18925, 18925, 19044, 19044, 20106], [20108, 20156, 20264, 20264, 20557], [20559, 20559, 20672, 20672, 20966], [20968, 20968, 20998, 21019, 21510], [21513, 21513, 21552, 21588, 22385], [22387, 22387, 22442, 22442, 22632], [22634, 22634, 22691, 22691, 23912]]}
{"id": "lstGRB", "name": "Transparent 3D Noise", "author": "Shane", "description": "Raymarching some transparent 3D noise.", "tags": ["3d", "raymarching", "noise", "transparency", "volumetric"], "likes": 69, "viewed": 2246, "published": "Public API", "date": "1450743299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n    Transparent 3D Noise\n\t--------------------\n\n\tOn occasion, I use this simple transparent setup to visualize certain 3D algorithms.\n\tObviously, it wouldn't pass for proper transparency, but to be fair, it's not running \n\tat minus 2 frames per second either. :)\n\n\tHere, it's being used to render stock standard, smooth, 3D value noise.\n\n\tI'm using a variation on IQ's textureless version. It does the same thing, but is \n\twritten in a more succinct, self contained form. I couldn't say whether it's faster \n\tor not (probably not), but it's faster to cut and paste, so that's almost the same \n\tthing. :)\n\n\tSeriously, though, it's reasonably quick, but I'm hoping some clever soul might know \n\tof a way to improve it.\n\n\tIQ's really fast, textureless version is there as well, but it's commented out. If \n\tyou require more speed, that's the one to use.\n\n\tIn regard to the transparency itself, there are a bunch of variables that affect the\n\toverall look. Too many to mention, in fact. The easiest way to get accustomed to\n\tthem all is to change them and see what happens.\n\n\tRelated shaders:\n\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n\tVirtually the same thing, but with rounded cubes.\n\tTransparent Cube Field - Shane\n\thttps://www.shadertoy.com/view/ll2SRy\n\t\n*/\n\n\n\n// Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n/*\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, I have tried to better this formula with a textureless version, \n// but so far, nothing comes close. If you're after speed, this is the one\n// to use... or improve on, if you can. :)\n//\n// If not loaded, you need to load up the correct noise texture with this one. \n// It's important that the \"vFlip\" checkbox is unchecked, also.\nfloat noise3DTex( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n*/\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nfloat map(vec3 p){\n    \n    // One layer of noise at isolevel \"0.3\" - I have no idea whether that's the\n    // correct terminology. :)\n    return noise3D(p*2.) - .3;\n    \n    // Two layers. The texture based 3D algorithm does this with ease, even on\n    // slower machines, but the function based one starts having trouble. \n    // By the way, you need to load up the correct noise texture with the correct \n    // \"vFlip\" setting, if you wish to use this.\n    //return noise3DTex(p*2.)*.66 + noise3DTex(p*4.)*.34 - .4;\n\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n\t\n    // Unit direction ray. The last term is one of many ways to fish-lens the camera.\n    // For a regular view, set \"rd.z\" to something like \"0.5.\"\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5)); // Fish lens, for that 1337, but tryhardish, demo look. :)\n    \n    // There are a few ways to hide artifacts and inconsistencies. Making things go fast is one of them. :)\n    // Ray origin, scene color, and surface postion vector.\n    vec3 ro = vec3(0., iTime*1.5, iTime*1.5), col=vec3(0), sp;\n\t\n    // Swivel the unit ray to look around the scene.\n    // Compact 2D rotation matrix, courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.375);\n    rd.xz = mat2(a, -a.y, a.x)*rd.xz;    \n    rd.xy = mat2(a, -a.y, a.x)*rd.xy; \n    \n    \n    // Unit ray jitter is another way to hide artifacts. It can also trick the viewer into believing\n    // something hard core, like global illumination, is happening. :)\n    //rd *= 0.99 + hash33(rd)*0.02;\n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    vec3 rnd = hash33(rd+311.);\n    \n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Better to way to handle banding. Courtesy of Iapafoto.\n    t = .2*length(hash33(rd)); \n    \n    // Surface distance threshold. Smaller numbers gives a thinner membrane, but lessens detail... \n    // hard to explain. It's easier to check it out for yourself.\n    float thD = .025; // + smoothstep(-0.2, 0.2, sin(iTime*0.75 - 3.14159*0.4))*0.025;\n \n\t\n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(float i=0.; i<56.; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>23. || col.x > 1. || t>10.) break;\n        \n        // Current ray postion. Slightly redundant here, but sometimes you may wish to reuse\n        // it during the accumulation stage.\n        sp = ro+rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point on the noise surface.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. You could smoothly interpolate it, if you wanted.\n        //\n        // 1/.(1. + t*t*0.1) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d)*23./24.)/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            \n            // Add the accumulated surface distance value, along with some basic falloff (fog, if \n            // you prefer) using the camera to surface distance, \"t.\" If you wanted, you could\n            // add a light, and use the light position to ray position distance instead.\n            // There's a bit of color jitter there, too.\n            \n            //col += aD*aD*(3.-2.*aD)/(1. + t*t*0.125)*.1 + (fract(rnd + i*27.)-.5)*0.02;\n            \n            col += aD/(1. + t*t*0.1)*.1 + (fract(rnd + i*27.)-.5)*0.01;\n            \n            // The layer number is worth noting. Accumulating more layers gives a bit more glow.\n            // Lower layer numbers allow a quicker bailout. A lot of it is guess work.\n            layers++;  \n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit \n        // of knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.7, thD*.7); \n        \n\t\t\t    \n\t}\n    \n    // Clamping \"col\" above zero, but just to be safe.\n    col = max(col, 0.);\n    \n    // Mixing the greytone color with a firey orange vignette. There's no meaning\n    // behind it. I just thought the artsy greyscale was a little too artsy.\n    uv = abs(fragCoord.xy/iResolution.xy - .5); // Wasteful, but the GPU can handle it.\n    col = mix(col, vec3(min(col.x*1.5, 1.), pow(col.x, 2.5), pow(col.x, 12.)),\n               min( dot(pow(uv, vec2(4.)), vec2(1))*8., 1.));\n\n    \n\t// Mixing the vignette colors up a bit more.\n    col = mix(col, col.xzy, dot(sin(rd*5.), vec3(.166)) + 0.166);\n    \n\t// Presenting the color to the screen. Note that there's no gamma correction. It was a style\n    // choice - to give more contrast, but it's usually best to have it.\n\tfragColor = vec4( clamp(col, 0., 1.), 1.0 );\n    \n     \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1408, 1481, 1501, 1501, 1610], [2380, 3190, 3212, 3305, 4766], [4768, 4768, 4786, 4902, 5291], [5295, 5295, 5349, 5382, 10327]]}
{"id": "lstGWN", "name": "Page turning", "author": "TambakoJaguar", "description": "Drag your mouse over the image and you will see how the page is turning while moving.\nThere is a pseudo-shading with diffuse, specular and shadow.\nI needed time to tweak the formulas and its values.\nPlease tell me what you think.", "tags": ["test", "shadow", "curl", "fun", "pseudo3d", "page", "turning", "images"], "likes": 50, "viewed": 2595, "published": "Public", "date": "1450049230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Page Turning\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\nconst float pi = 3.14159;\nconst float twopi = 6.28319;\n\nconst float e0 = 0.018;\nconst float ppow = 2.0;\n\nconst float bcolorMix = 0.67;\nconst float maxBcolVal = 0.4;\n\nconst float diffint = 1.2;\nconst float ambientt = 0.1;\nconst float ambientb = 0.4;\n\nconst vec2 specpos = vec2(0.85, -0.2);\nconst float specpow = 5.;\nconst float specwidth = 0.4;\nconst float specint = 0.6;\n\nconst vec2 shadowoffset = vec2(0.07, -0.04);\nconst float shadowsmoothness = 0.012;\nconst float shadowint = 0.25;\n\nconst float aawidth = 0.7;\nconst int aasamples = 3;\n\nconst bool showpoints = false;\nconst bool colors = false;\nconst bool anim = true;\n\n//#define swap_x\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\nvec4 getPagebackColor()\n{\n    \n    float cn;\n    if (iMouse.x==0. && iMouse.y==0. && anim)\n        cn = floor(iTime/3.5);\n    else\n        cn = 1.0;\n    vec4 pagebackColor;\n    pagebackColor.r = maxBcolVal*random(cn + 263.714);\n    pagebackColor.g = maxBcolVal*random(cn*4. - 151.894);\n    pagebackColor.b = maxBcolVal*random(cn*7. + 87.548);\n    pagebackColor.a = 1.0;\n    return pagebackColor;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x*cos(angle) + vect.y*sin(angle);\n    float yr = vect.x*sin(angle) - vect.y*cos(angle);\n    return vec2(xr, yr);\n}\n\n// Curl function on the axis bottom left corner - corner of the sheet\nfloat pageFunction(float x, float e)\n{\n    return pow(pow(x, ppow) - e, 1./ppow);\n}\n\n// Derivate of the curl function for light calculations\nfloat pageFunctionDer(float x, float e)\n{\n    return pow(x, ppow - 1.)/pow(pow(x, ppow) - e, (ppow - 1.)/ppow);\n}\n\nvec4 turnPage(vec2 fragCoord)\n{\n\t// General calculations\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    float ratio = iResolution.x/iResolution.y;\n    \n    // As long as one doesn't click on the canvas, the animation runs\n    vec2 mpoint;\n    bool firstcycle;\n    \n    vec4 Mouse2 = iMouse;\n    #ifdef swap_x\n    Mouse2.x = iResolution.x - Mouse2.x;\n    #endif\n    \n    if (iMouse.x==0. && iMouse.y==0. && anim)\n    {\n        firstcycle = mod(iTime/3.5, 2.)<1.;\n        mpoint = vec2(mod(iTime/3.5, 1.)*iResolution.x*2.0, pow(mod(iTime/3.5, 1.), 2.5)*iResolution.y/1.2 + 8.*smoothstep(0., 0.07, mod(iTime/3.5, 1.)));\n    }\n    else\n    {\n        mpoint = Mouse2.xy;\n        firstcycle = true;\n    }\n    vec2 midmpoint = mpoint*0.5;\n    float mdist = distance(fragCoord, mpoint);\n    float e = e0*pow(mdist/iResolution.y, 2.) + 0.02*e0*smoothstep(0., 0.12, mdist/iResolution.y);\n    float angle = - atan(mpoint.x/mpoint.y) + pi*0.5;\n    \n    vec2 uv2 = uv;\n    #ifdef swap_x\n    uv2.x = ratio - uv2.x;\n    #endif\n    \n    vec2 uvr = rotateVec(uv2 - midmpoint/iResolution.yy, angle);\n    \n    float pagefunc = pageFunction(uvr.x, e);\n    vec2 uvr2 = vec2(pagefunc, uvr.y); \n    vec2 uvr3 = rotateVec(uvr2, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n    vec2 uvr2b = vec2(-pagefunc, uvr.y); \n    vec2 uvr3b = rotateVec(uvr2b, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n    #ifdef swap_x\n    uvr3b.x = ratio - uvr3b.x;\n    #endif\n        \n    vec4 i; \n    // Turned page\n    if (uvr.x>0. && uvr3b.y>0.)\n    {\n        vec2 uvcorr = vec2(ratio, 1.);\n        vec2 uvrcorr = rotateVec(uvcorr - midmpoint/iResolution.yy, angle);\n        float pagefunccorr = pageFunction(uvrcorr.x, e);\n        vec2 uvrcorr2 = vec2(-pagefunccorr, uvrcorr.y); \n        vec2 uvrcorr3 = rotateVec(uvrcorr2, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n    \n        float pagefuncder = pageFunctionDer(uvr.x, e);\n        float intfac = 1. - diffint*(1. - 1./pagefuncder);\n\n        if(uvr3.x>=0. || uvr3.y<=0.)\n        {\n            // Top of the turned page           \n        \tfloat mdists = distance(fragCoord, mpoint)*0.7 - 55.;\n        \tfloat es = e0*pow(mdists/iResolution.y, 2.) + 0.02*e0*smoothstep(0., 0.08, mdist/iResolution.y);\n        \tvec2 uvrs = rotateVec(uv2 - midmpoint/iResolution.yy - shadowoffset, angle);\n        \tfloat pagefuncs = pageFunction(uvrs.x + 0.015, es - 0.001);\n        \tvec2 uvr2s = vec2(pagefuncs, uvrs.y); \n        \tvec2 uvr3s = rotateVec(uvr2s, -angle) - vec2(1., -1.)*midmpoint/iResolution.yy;\n        \tfloat shadow = 1. - (1. - smoothstep(-shadowsmoothness, shadowsmoothness, uvr3s.x))*(1. - smoothstep(shadowsmoothness, -shadowsmoothness, uvr3s.y));\n            \n            float difft = intfac*(1. - ambientt) + ambientt;\n        \tdifft = difft*(shadow*shadowint + 1. - shadowint)/2. + mix(1. - shadowint, difft, shadow)/2.;\n            if (firstcycle)\n                i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture(iChannel0, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n            else\n                i = difft*(colors?vec4(1., 0.3, 0.3, 1.):texture(iChannel1, mod((uvr3b - uvrcorr3)/vec2(-ratio, 1.), 1.)));\n        }\n        else\n        {\n            // Bottom of the turned page\n            float diffb = intfac*(1. - ambientb) + ambientb;\n        \tfloat spec = pow(smoothstep(specpos.x - 0.35, specpos.x, intfac)*smoothstep(specpos.x + 0.35, specpos.x, intfac), specpow);\n        \tspec*= specint*pow(1. - pow(clamp(abs(uvr.y - specpos.y), 0., specwidth*2.), 2.)/specwidth, specpow);\n\t\t\tif (firstcycle)\n                i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture(iChannel0, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n            else\n                i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):mix(texture(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), getPagebackColor(), bcolorMix));\n            //i = diffb*(colors?vec4(0.3, 1.0, 0.3, 1.):texture(iChannel1, mod((uvr3 - uvrcorr3)/vec2(-ratio, 1.), 1.)), vec4(0.3, 0., 0., 1.));\n         \ti = mix(i, vec4(1.0), spec);\n        }\n    }\n    else\n    {\n        // \"Background\" with simple shadow\n\n        vec2 mpointbg = vec2(0.2, 0.01);\n        vec2 midmpointbg = mpointbg*0.5;\n        float mdistbg = distance(fragCoord, mpointbg);\n        float ebg = e0*pow(mdistbg/iResolution.y, 2.) + 0.01*e0*smoothstep(0., 0.12, mdistbg/iResolution.y);\n        float anglebg = 0.001; //- atan(mpointbg.x/mpointbg.y) + pi*0.5;\n        vec2 uvrbg = rotateVec(uv - midmpointbg/iResolution.yy, anglebg);\n        //float pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), clamp(uvrbg.x*5., 0., 1.));\n        float pagefuncbg;\n        if (uvrbg.x<0.15)\n           pagefuncbg = uvrbg.x;\n        else\n           pagefuncbg = mix(uvrbg.x, pageFunction(uvrbg.x, ebg), smoothstep(mpoint.x/iResolution.x + 0.1, mpoint.x/iResolution.x, uvrbg.x));\n        \n        vec2 uvr2bbg = vec2(-pagefuncbg, uvrbg.y); \n        vec2 uvr3bbg = rotateVec(uvr2bbg, -anglebg) - vec2(1., -1.)*midmpointbg/iResolution.yy;\n        vec2 uvcorrbg = vec2(ratio, 1.);\n        vec2 uvrcorrbg = rotateVec(uvcorrbg - midmpointbg/iResolution.yy, anglebg);\n        float pagefunccorrbg = pageFunction(uvrcorrbg.x, ebg);\n        vec2 uvrcorr2bg = vec2(-pagefunccorrbg, uvrcorrbg.y); \n        vec2 uvrcorr3bg = rotateVec(uvrcorr2bg, -anglebg) - vec2(1., -1.)*midmpointbg/iResolution.yy;       \n        float pagefuncderbg = pageFunctionDer(uvrbg.x, ebg);\n        float intfacbg = 1. - diffint*(1. - 1./pagefuncderbg);\n        float difftbg = intfacbg*(1. - ambientt) + ambientt;\n        \n        if (firstcycle) \n            i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture(iChannel1, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n        else\n            i = colors?difftbg*vec4(0.3, 0.3, 1., 1.):texture(iChannel0, mod((uvr3bbg - uvrcorr3bg)/vec2(-ratio, 1.), 1.));\n        float bgshadow = 1. + shadowint*smoothstep(-0.08+shadowsmoothness*4., -0.08, uvr3b.y) - shadowint;\n        \n        if (uvr3b.y<0.)\n           i*= bgshadow;\n    }\n    return i;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= turnPage(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec4 i = vs/vec4(aasamples*aasamples);    \n    \n    // Show the mouse points. Was only used for development\n    vec4 ocol; \n    if (showpoints)\n    {\n        float ratio = iResolution.x/iResolution.y;\n        vec2 mpoint = iMouse.xy;\n        vec2 midmpoint = iMouse.xy*0.5;\n        float mdist = distance(fragCoord, mpoint);\n        float midmdist = distance(fragCoord, midmpoint);\n        \n        ocol = mix(i, vec4(1., 0., 0., 1.), smoothstep(6., 4., mdist));\n        ocol = mix(ocol, vec4(1., 1., 0., 1.), smoothstep(6., 4., midmdist));\n    }\n    else\n        ocol = i;\n        \n    fragColor = ocol;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstGWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[819, 847, 871, 871, 919], [921, 921, 946, 946, 1318], [1320, 1320, 1360, 1360, 1495], [1497, 1567, 1605, 1605, 1650], [1652, 1708, 1749, 1749, 1821], [1823, 1823, 1854, 1879, 7889], [7892, 7892, 7947, 7967, 8887]]}
{"id": "lstGzS", "name": "Bay Bridge", "author": "mplanck", "description": "A beautiful bridge, a beautiful city.  \nUse mouse to control the moon.", "tags": ["distancemarch", "bay"], "likes": 43, "viewed": 3004, "published": "Public", "date": "1450674041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tested on Macbook Pro 15\"\n// tested on Windows OS 8.1 - 980 TITAN\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define BRIDGE_SURFACE_ID 1.\n#define ISLAND_SURFACE_ID 2.\n#define SKY_SURFACE_ID 3.\n#define WATER_SURFACE_ID 4.\n#define SUSPENSION_STRUTS_SURFACE_ID 5.\n#define BRIDGE_LIGHT_SURFACE_ID 6.\n#define MOON_SURFACE_ID 7.\n\n#define MOON_COLOR vec3(.91, .93, 1.)\n\n#define DIST_MARCH_STEPS 50\n#define DIST_MARCH_MAXDIST 44.\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_SURFACE_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n// **************************************************************************\n// DEFINES\n\n// Increase to 8 to anti-alias (and to warm up your GPU)\n#define NUM_AA_SAMPLES 8.\n\n// **************************************************************************\n// GLOBALS\n\nvec4  g_debugcolor  = vec4(0.);\nfloat g_time        = 0.;\nfloat g_exposure    = 1.;\nfloat g_focus       = .9;\nvec3  g_moonpos     = vec3(0.);\n\nvec3  g_camorigin   = vec3(0.);\nvec3  g_campointsat = vec3(0.);\n\n// **************************************************************************\n// MATH UTILITIES\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture ( iChannel0, (uv+ 0.5)/256.0, -100. ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n// Approximating a dialectric fresnel effect by using the schlick approximation\n// http://en.wikipedia.org/wiki/Schlick's_approximation. Returns a vec3 in case\n// I want to approximate a different index of reflection for each channel to\n// get a chromatic effect.\nvec3 fresnel(vec3 R, vec3 N, float eta)\n{\n    // assume that the surrounding environment is air on both sides of the \n    // dialectric\n    float ro = (1. - eta) / (1. + eta);\n    ro *= ro;\n    \n    float fterm = pow(max(0., 1. - dot(R, N)), 5.);  \n    return vec3(ro + ( 1. - ro ) * fterm); \n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddn = dot(rd, pn);\n    float intersected = 0.;\n\n    float t = REALLY_BIG_NUMBER;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is close to parallel to the given plane.\n    if (abs(rddn) > REALLY_SMALL_NUMBER) {\n        t = -dot(pn, (ro - po)) / rddn;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        } else {\n            t = REALLY_BIG_NUMBER;\n        }\n\n    }\n    return vec2(intersected, t);\n}\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere - no intersection takes place.  So there is gauranteed to be a tmin\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_sphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin);\n\n    float outside = step(sphr*sphr, dot(oro, oro));\n    return outside * vec3(hit, tmin, tmax);\n}\n\n// intersection for a sphere with a ray. Assumes intersecting from within the sphere\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\nvec3 intersect_isphere(vec3 ro,                 \n                      vec3 rd, \n                      float sphr,\n                      vec3 sphc)\n{\n\n    vec3 oro = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - sphr*sphr;\n    float discr = b*b - a*c; \n    \n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmax);\n\n    return vec3(hit, tmin, tmax);\n}\n\nfloat flow_noise( in vec3 p )\n{\n    vec3 q = p - vec3(0., .5 * g_time, 0.);\n    float f;\n    f  = 0.50000*noise( q ); q = q*3.02 -vec3(0., .5 * g_time, 0.);\n    f += 0.35000*noise( q ); q = q*3.03;\n    f += 0.15000*noise( q ); q = q*3.01;\n    return f;\n}\n\nfloat map4( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    \n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n    return f;\n}\n\n// overlay ca on top of ci and return ci\nvoid composite(inout vec4 ci, vec4 ca)\n{\n    // assume pre-multiplied alpha    \n    ci += ca * (1. - ci.a);\n}\n\nvec3 nearest_point_on_line( vec3 a, vec3 b, vec3 p)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / dot(ba, ba);\n    return a + t * ba;\n}\n\n\n// Given the float values, mix between them such that \n//  result=v1 at mod(x,4)=0,3\n//  result=v2 at mod(x,4)=1\n//  result=v3 at mod(x,4)=2\n\nfloat periodicmix(float v1, \n                 float v2, \n                 float v3, \n                 float x)\n{\n    float modx = mod(x, 3.);\n    return mix(v1, \n                mix(v2, \n                    mix(v3, \n                        v1,\n                        smoothstep(.5, .6, modx - 2.)), \n                    smoothstep(.5, .6, modx - 1.)), \n                smoothstep(.5, .6, modx));\n}\n\n// **************************************************************************\n// DISTANCE FUNC MATH\n\nfloat sphere_df( vec3 p, float r ) { return length( p ) - r; }\nfloat roundbox_df ( vec3 p, vec3 b, float r ) {return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.0))-r; }\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct CameraInfo\n{\n    vec3 camera_origin;\n    vec3 ray_look_direction;\n    mat3 camera_transform;\n    vec2 image_plane_uv;\n};\n\n#define INIT_CAMERA_INFO() CameraInfo(vec3(0.) /* camera_origin */, vec3(0.) /* ray_look_direction */, mat3(1.) /* camera_transform */, vec2(0.) /* image_plane_uv */)\n\nstruct SurfaceInfo\n{\n    float surface_id;\n    vec3 view_origin;\n    vec3 view_dir;\n    vec3 surface_point;\n    vec3 surface_normal;\n    vec2 surface_uv;\n    float surface_depth;\n    float shade_in_reflection;\n};\n#define INIT_SURFACE_INFO(view_origin, view_dir) SurfaceInfo(-1. /* surface_id */, view_origin, view_dir, vec3(0.) /* surface_point */, vec3(0.) /* surface_normal */, vec2(0.) /* surface_uv */, 0. /* surface_depth */, 0. /* shade_in_reflection */)\n\nstruct MaterialInfo\n{\n    vec3 bump_normal;\n    vec3 diffuse_color;\n    vec3 specular_color; \n    float specular_exponent; \n    float reflection_intensity;\n    vec3 emissive_color;\n};\n#define INIT_MATERIAL_INFO(surface_normal) MaterialInfo(surface_normal /* bump_normal */, vec3(0.) /* diffuse_color */, vec3(0.) /* specular_color */, 1. /* specular_exponent */, 1. /* reflection_intensity */, vec3(0.) /* emissive_color */)\n\n// **************************************************************************\n// SETUP WORLD\n    \nvoid setup_globals()\n{\n    // Way to globally control playback rate.\n    g_time = 1. * iTime;\n    //g_time = .2 * iMouse.x;\n    \n    g_exposure = 1.;    \n\n    // remap the mouse click ([-1, 1], [-1/AspectRatio, 1/AspectRatio])\n    vec2 click = iMouse.xy / iResolution.xx;  \n    click = 2.0 * click - 1.0;  \n    \n    g_camorigin = vec3(0.0, .1, 7.0);\n    \n    //float rotxang    = .4 * PI * click.y;\n    float rotxang    = .4 * PI * -0.0;\n    rotxang += -.02 * cos(.02 * g_time) - .03;\n    float cosrotxang = cos(rotxang);\n    float sinrotxang = sin(rotxang);\n    g_camorigin = rotate_xaxis(g_camorigin, cosrotxang, sinrotxang);\n    \n    //float rotyang    = PI * click.x;\n    float rotyang    = PI * .28;\n    rotyang += .05 * sin(.2 * g_time);\n    //float rotyang    = .1 * sin(.1 * g_time + PI_OVER_TWO) + TWO_PI * .71;\n    float cosrotyang = cos(rotyang);\n    float sinrotyang = sin(rotyang);    \n    g_camorigin = rotate_yaxis(g_camorigin, cosrotyang, sinrotyang);\n\n    g_campointsat = vec3(0., .55, 1.5);\n\n    // XXX: DUPLICATED from setup_camera\n    // would be nice to consolidate work, but laziness won.\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 click_uv = iMouse.xy / iResolution.xy - .5;\n    click_uv.y *= inv_aspect_ratio;\n\n    vec3 ray_click_dir = normalize( click_uv.x * ix + click_uv.y * iy + g_focus * iz );\n\n    vec3 result = intersect_isphere(g_camorigin, ray_click_dir, 40., g_camorigin);\n\n    if (iMouse.x + iMouse.y > 1.)\n    {\n   \t\tg_moonpos = g_camorigin + result.z * ray_click_dir;\n    }\n    else\n    {\n        g_moonpos = vec3(-28., 8., 3.);\n    }\n\n}\n\n\nCameraInfo setup_camera(vec2 aaoffset)\n{\n\n    float inv_aspect_ratio = iResolution.y / iResolution.x;\n    vec2 image_plane_uv = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    image_plane_uv.y *= inv_aspect_ratio;\n\n    // calculate the ray origin and ray direction that represents mapping the\n    // image plane towards the scene.  Assume the camera is facing y-up (0., 1.,\n    // 0.).\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_campointsat - g_camorigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // project the camera ray through the current pixel being shaded using the\n    // pin-hole camera model.\n    vec3 ray_look_direction = normalize( image_plane_uv.x * ix + image_plane_uv.y * iy + g_focus * iz );\n\n    return CameraInfo(g_camorigin, ray_look_direction, mat3(ix, iy, iz), image_plane_uv);\n\n}\n\n// **************************************************************************\n// MARCH WORLD\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\nvec2 scene_df( vec3 p )\n{\n    \n    // ground    \n    vec3 gp = p * vec3(.2, 1., .2) + vec3(0., 10., 0.) * (.5*map4(.2 * p)-.5) + vec3(7.2, 3.3, -2.);\n    vec2 ground_obj = vec2(sphere_df(gp, 2.9), ISLAND_SURFACE_ID);    \n\n    // moon\n    vec3 mp = p - g_moonpos;\n    float mdf = sphere_df(mp, 1.2);\n    \n    // bridge towers\n    vec3 bb = p;    \n    bb.x = mod(bb.x + 4., 8.); // repeat bridge struts\n    bb.x -= 4.;\n    \n    bb.z = abs(bb.z); // symmetric along the xy plane\n    bb.z -= .15; // separation of sides\n    \n    float bdf = roundbox_df( bb, vec3(.1, 2.5, .03), .01); // sides    \n    bdf = uniondf(bdf, roundbox_df( bb, vec3(.35, .12, .15), .01)); // bottom\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 2.45, -0.1), vec3(.11, .1, .3), .01)); // top    \n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., .92, -0.1), vec3(8., .02, .2), .01)); // bottom bridge\n    bdf = uniondf(bdf, roundbox_df( bb - vec3(0., 1.05, -0.1), vec3(8., .02, .2), .01)); // top bridge\n                 \n    // struts\n    vec3 cb = bb;\n    cb.y = mod(cb.y + .19, .38);\n    cb.y = abs(cb.y - .19);\n    \n    // mask out certain struts by moving them so far away, they\n    // would never be the closest object\n    float m = step(2.5, bb.y) + step(.95, bb.y) * step(bb.y, 1.3); \n    cb.y -= .15 + REALLY_BIG_NUMBER * m;\n    cb.yz *= mat2(-.707, -.707, .707, -.707); \n    bdf = uniondf(bdf, roundbox_df( cb, vec3(.03, 1., .03), .01)); // struts\n\n    // suspension cables\n    vec3 sp = p;    \n    sp.x = mod(sp.x, 8.); \n    sp.x -= 4.;\n    sp.z = abs(sp.z);\n    sp.z -= .15;\n    sp.y -= .09 * sp.x*sp.x;\n    bdf = uniondf(bdf, roundbox_df( sp - vec3(0., 1.1, 0.), vec3(8., .01, .01), .01)); // bridge\n        \n    // suspension hanging struts\n    vec3 tp = p;\n    tp.x = mod(tp.x + .05, .1);\n    tp.x -= .05;\n    tp.z -= .13;\n    float sdf = roundbox_df(tp - vec3(0., 1.06, 0.), vec3(.0, .089 * sp.x*sp.x + .02, .0), .005);\n    \n    // bridge warning light\n    float wldf = sphere_df(bb - vec3(0.0, 2.64, -.15), .03);\n        \n    vec2 bridge_obj = vec2(bdf, BRIDGE_SURFACE_ID); \n    vec2 suspension_obj = vec2(sdf, SUSPENSION_STRUTS_SURFACE_ID);        \n    vec2 light_obj = vec2(wldf, BRIDGE_LIGHT_SURFACE_ID); \n    vec2 moon_obj = vec2(mdf, MOON_SURFACE_ID);\n    \n    vec2 obj = ground_obj;\n    obj = mergeobjs(obj, bridge_obj);\n    obj = mergeobjs(obj, suspension_obj);\n    obj = mergeobjs(obj, light_obj);\n    obj = mergeobjs(obj, moon_obj);\n    return obj;\n}\n\nvec3 calc_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.01, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene_df(p + epsilon.xyy).x - scene_df(p - epsilon.xyy).x,\n        scene_df(p + epsilon.yxy).x - scene_df(p - epsilon.yxy).x,\n        scene_df(p + epsilon.yyx).x - scene_df(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvec2 intersect_water(vec3 ro, vec3 rd)\n{\n    return intersect_plane(ro, rd, vec3(0., 1., 0.), vec3(0., 0., 0.));\n}\n\nSurfaceInfo march_scene(vec3 ray_origin,\n                        vec3 ray_direction,\n                        float consider_water )\n{\n\n    SurfaceInfo surface = INIT_SURFACE_INFO(ray_origin, ray_direction);\n\n    vec2 water = consider_water * intersect_water(ray_origin, ray_direction);\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float total_t = 0.;\n    float curr_t = 0.;\n    \n    vec3 ro = ray_origin;\n    vec3 rd = ray_direction;\n    \n    for (int i=0; i < DIST_MARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || curr_t + total_t > DIST_MARCH_MAXDIST ) \n        {\n            break;\n        }        \n\n        vec3 p = ro + curr_t * rd;        \n        vec2 dfresult = scene_df( p );\n        \n        // calculate sky on it's own since it shifts with ray_origin\n        // and we don't want to consider it with calc_normal\n        vec2 sky_obj = vec2(-sphere_df(p, 35.), SKY_SURFACE_ID);\n        dfresult = mergeobjs(sky_obj, dfresult);\n\n        dist = dfresult.x;        \n        curr_t += dist;\n        surface.surface_id = dfresult.y;\n   \n        if ( water.x > .5 && curr_t > water.y )\n        {\n            surface.surface_id = WATER_SURFACE_ID;\n            curr_t = water.y;\n            break;\n        }   \n\n                                          \n    }\n    \n    surface.surface_point = ro + curr_t * rd;\n    total_t += curr_t;\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        vec3 n = vec3(0., 1., 0.);\n        vec3 u = normalize(-vec3(1., 0., 1.) * ray_origin);\n        vec3 v = cross(n, u);\n        surface.surface_uv = vec2(100., 10.) * vec2( dot(surface.surface_point, u), \n                                                    dot(surface.surface_point, v) );\n\n        n += u * (.2 * flow_noise(surface.surface_uv.xxy) - .1);\n        surface.surface_normal = normalize(n);\n       \n    }    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        surface.surface_normal = -rd;\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    else \n    {        \n        surface.surface_normal = calc_normal( surface.surface_point );\n        surface.surface_uv = surface.surface_point.xz;\n    }\n    \n            \n    surface.surface_depth = total_t;\n\n    return surface;\n}\n\n// **************************************************************************\n// SHADE WORLD\n\nvec3 light_from_point_light(SurfaceInfo  surface,\n                            MaterialInfo material,\n                            vec3 light_position,\n                            vec3 light_color,\n                           float falloff_with_distance,\n                           float specular_sharpen)\n{\n    vec3 light_direction = normalize(light_position - surface.surface_point);\n    vec3 light_reflection_direction = reflect(light_direction, material.bump_normal);\n    \n    // Phong reflection model\n    vec3 reflective_shading = material.specular_color * pow(max(0., dot(light_reflection_direction, surface.view_dir)), \n        material.specular_exponent * specular_sharpen);\n    \n    float ldist = length(surface.surface_point - light_position);\n    float dist_atten = 1./ldist;\n    vec3 diffuse_shading = material.diffuse_color * max(0., dot(light_direction, material.bump_normal)) * mix(1., dist_atten, falloff_with_distance);    \n    vec3 scene_color = light_color * (diffuse_shading + reflective_shading);\n \n    return scene_color;\n\n}\n\n\nvec4 shade_clouds(vec3 ro, vec3 rd, float depth)\n{\n    vec4 cloud_rgba = vec4(0.);\n    vec3 cn = normalize(ro);\n    float num_clouds = 0.;\n    \n    for (float i = 0.; i < 3.; i += 1.)\n    {\n        vec3 ch = intersect_isphere(ro, rd, 3.1 * i + 4.5, ro);\n        if (ch.x > .5 && ch.z < depth )\n        {\n            vec3 hp = ro + rd * ch.z;\n            vec3 hpo = nearest_point_on_line(ro, g_moonpos, hp);\n            vec3 uvhp = hp - vec3(-28., 9., 9.);\n            \n            uvhp *= 2.;\n            float height_s = smoothstep(1., 5., hp.y);\n            \n            float cloud_alpha = (.06 + .02 * i) * (.2 + .8 * smoothstep(.1, .9 - .25 * height_s, map4(vec3(1., .8, 0.) * uvhp.yxz + vec3(3. * i, 5. * i , .05 * g_time))));\n            cloud_alpha *= smoothstep(0.5, 1.5, hp.y) * smoothstep(2. + 1.8 * i, .0, hp.y);\n            vec3 cloud_color = 2. * vec3(.6,.8,1.+.1*i);\n            \n            vec3 halod = hp - hpo;\n            vec3 halo_color = .8 * MOON_COLOR * max(0., 4. - length(2. * halod));\n            cloud_color += .6 * pow(halo_color, vec3(2.));\n            composite(cloud_rgba, vec4(cloud_color * cloud_alpha, cloud_alpha));            \n            num_clouds += 1.;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    //g_debugcolor.rgb = vec3(num_clouds * .25);\n    //g_debugcolor.a = 1.;\n    return cloud_rgba;\n    //return vec4(0.);\n}\n\nvec3 shade_reflected_world(SurfaceInfo surface)\n{\n    vec4 scene_color = vec4(0.);\n    \n    MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n    if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_SURFACE_ID))\n    {\n\n        material.diffuse_color = .02 * vec3(.65, .62, .68);\n        material.specular_color = .5 * vec3(0.5, 0.6, 0.7);\n        material.specular_exponent = 30.;\n\n        material.emissive_color = vec3(.04, .03, .035);\n    } \n    else if (MATCHES_SURFACE_ID(surface.surface_id, BRIDGE_LIGHT_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        float i = abs(sin(g_time));\n        material.emissive_color = i*i * vec3(2., .05, .05);\n        material.reflection_intensity = 10.;\n        \n    }\n    else if (MATCHES_SURFACE_ID(surface.surface_id, SUSPENSION_STRUTS_SURFACE_ID))\n    {\n\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        material.specular_exponent = 1.;\n\n        vec3 dp = surface.surface_point.xyz;\n        dp.x = mod(dp.x + 4., 8.);\n        dp.x -= 4.;\n        \n        // pattern 1\n        float s = (.5 * cos(6. * dp.y * pow(abs(dp.x), .5) - 4. * g_time ) + .5);\n        float c1 = smoothstep(.3, 1., s);\n\n        // pattern 2\n        s = (.5 * cos(4. * dp.y * dp.x + mix(-1., 1., step(0., dp.x))* 5. * g_time ) + .5);\n        float c2 = smoothstep(.2, .8, s);\n           \n        // pattern 3\n        dp = surface.surface_point.xyz;\n        s = .5 * cos(2. * dp.x - 2.* g_time + 5. * 1. * sin(3. * dp.y + 1. * g_time)) + .5;\n        float c3 = smoothstep(.2, .9, s);\n        \n        float c = periodicmix(c1, c2, c3, .2 * g_time + .3 * dp.y);\n\n        // discrete lights\n        float l = mod(20. * dp.y, 1.);\n        c *= smoothstep(0.2, .5, l) * smoothstep(.8, .5, l);\n        \n        material.emissive_color = 2. * c * vec3(.9, .9, 1.);\n        material.reflection_intensity = 8.;\n\n    } \n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, ISLAND_SURFACE_ID))\n    {\n        vec3 surface_color = .05 * vec3(1., .5, .7);        \n\n        material.diffuse_color = surface_color;\n\n        material.emissive_color = .1 * surface_color;\n        material.specular_color = .1 * surface_color;\n        material.specular_exponent = 1.;\n\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, SKY_SURFACE_ID))\n    {\n        vec3 sky_color = .6 * vec3(0.15, 0.12, .12) * smoothstep(3., 0., surface.surface_point.y);        \n        float l = smoothstep(2., 0., surface.surface_point.y);\n        sky_color += .5 * vec3(0.2, 0.14, .12) * l * l;\n\t\tvec3 cn = surface.surface_point;\n        cn.z = floor(20. * cn.z) * .05;\n        float city_noise = noise(8. * cn.xzz);\n        sky_color += 2. * vec3(1., .8, .7) * smoothstep(.25 * city_noise - .05, -.06, surface.surface_point.y);\n        material.emissive_color = sky_color;\n    }\n    \n    else if (MATCHES_SURFACE_ID(surface.surface_id, MOON_SURFACE_ID))\n    {\n        material.diffuse_color = vec3(0.);\n        material.specular_color = vec3(0.);\n        \n        mat3 om = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                       -0.60, -0.48,  0.64 );\n\n        vec3 mp = 1.3 * om * (surface.surface_point - g_moonpos);\n\n        float moon = .1;\n        moon += .6 * smoothstep( 0.2,  .8, noise( .6 * (mp - vec3(1., 0., 0.)) ));\n        mp = 1.2 * om * mp; \n        moon += .5 * smoothstep( 0.2,  1., noise( .8 * (mp - vec3(1., 0., 0.))));\n        mp = 2.8 * om * mp; \n        moon += 0.300 * smoothstep( 0.1,  1.3, pow(noise( mp ), 3.0));    \n\n        moon *= .8 + .2 * smoothstep( 0.5,  0.7, noise( 1.7 * mp ));\n        moon *= .6 + .4 * noise( 30.5 * mp); \n        moon += 0.35 * pow(noise( 15.5 * mp), 6.);\n\n        material.emissive_color = moon * .6 * MOON_COLOR;\n        material.reflection_intensity = 4.;\n    }\n      \n    vec4 scene_rgba = vec4(0.05, .05, .08, 0.1);\n    vec3 em = material.emissive_color * mix(1., material.reflection_intensity, step(0.5, surface.shade_in_reflection));  \n    scene_rgba.rgb += em;\n    vec4 clouds_rgba = shade_clouds(surface.view_origin, surface.view_dir, surface.surface_depth);\n\n    vec3 lit_color = light_from_point_light(surface, \n                                            material, \n                                            g_moonpos, \n                                            MOON_COLOR, \n                                            0., \n                                            1.);\n\n\n    lit_color *= g_exposure;\n    clouds_rgba.rgb *= g_exposure;\n \n    composite(scene_rgba, clouds_rgba);\n    composite(scene_rgba, vec4(lit_color, 1.));\n        \n    return scene_rgba.rgb;\n}\n\n\nvec3 shade_world(SurfaceInfo surface)\n{\n\n    vec4 scene_color = vec4(0.);\n    \n    if (MATCHES_SURFACE_ID(surface.surface_id, WATER_SURFACE_ID))\n    {\n        MaterialInfo material = INIT_MATERIAL_INFO(surface.surface_normal);\n        \n        vec3 surface_color = vec3(.07,.08,.1) + mix(vec3(.18, .22, .35),\n                                 vec3(.21, .25, .38), \n                                 flow_noise(surface.surface_uv.xxy));\n\n        material.diffuse_color = .6 * surface_color;\n        material.emissive_color = .15 * surface_color;\n        material.specular_color = .5 * MOON_COLOR;\n        material.specular_exponent = 200.;\n        \n        SurfaceInfo refl_surface = march_scene( surface.surface_point, \n                                                reflect(surface.view_dir, \n                                                        surface.surface_normal), \n                                                0. );\n        \n        refl_surface.shade_in_reflection = 1.;\n        vec3 refl_color = shade_reflected_world( refl_surface );\n        \n        // fresnel like falloff to reflection\n        refl_color *= (.5 + .5 * smoothstep(0.3, 2.5, surface.surface_depth));\n\n        // loss of reflection with wave occlusion in the distance\n        refl_color *= (.5 + .5 * smoothstep(3., 1., surface.surface_depth));\n            \n\n        vec4 scene_rgba = vec4(0.);\n        \n        vec3 lit_color = light_from_point_light(surface, \n                                                material, \n                                                g_moonpos, \n                                                MOON_COLOR, \n                                                0., 1.);\n        \n        lit_color += .2 * refl_color;        \n        lit_color *= g_exposure;              \n        \n        scene_color = scene_rgba; \n        composite(scene_color, vec4(lit_color, 1.));\n\n    }\n    else\n    {\n        \n        scene_color.rgb = shade_reflected_world(surface);\n    }\n\n    return scene_color.rgb;\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // SETUP GLOBALS\n\n    setup_globals();\n\n    // ----------------------------------\n    // SETUP CAMERA\n\n    float denom = TWO_PI/max(1., NUM_AA_SAMPLES-1.);\n    vec3 scene_color = vec3(0.);\n\n    for (float aa = 0.; aa < NUM_AA_SAMPLES; aa += 1.) \n    {\n\n        vec2 aaoffset = step(.5, aa) * .5 * vec2( cos((aa-1.) * denom ),\n                                                  sin((aa-1.) * denom ) );\n\n        CameraInfo camera = setup_camera( aaoffset );\n        \n        // ----------------------------------\n        // SCENE MARCHING\n\n        SurfaceInfo surface = march_scene( camera.camera_origin,\n         camera.ray_look_direction, 1. );\n        \n        // ----------------------------------\n        // SHADING\n        \n        scene_color += shade_world( surface );\n        \n\n    }\n\n    scene_color /= NUM_AA_SAMPLES;\n\n    // ----------------------------------\n    // POST PROCESSING\n    \n    // Brighten\n    scene_color *= 1.5;\n  \n    // Gamma correct\n    scene_color = pow(max(vec3(0.), scene_color), vec3(.8));\n\n    // Contrast adjust - cute trick learned from iq\n    scene_color = mix( scene_color, vec3(dot(scene_color,vec3(0.333))), -.3 );\n      \n    // Color tint\n    scene_color *= vec3(1.1, .9, .9);\n    \n    // Horizontal vignette - inspired by iq\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    scene_color *= 0.2 + 0.8*pow( 8.0*uv.x*(1.0-uv.x), 0.1 );\n    \n    // Debug color - great debugging tool.  \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scene_color;\n    }\n\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "ldlGRH", "previewfilepath": "https://soundcloud.com/dgcmusi/lights-journey-instrumental", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/dgcmusi/lights-journey-instrumental", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1266, 1363, 1389, 1389, 1610], [1612, 1876, 1917, 2011, 2170], [2172, 2449, 2506, 2506, 2632], [2634, 2909, 2966, 2966, 3094], [3362, 3508, 3629, 3629, 4184], [4186, 4484, 4632, 4632, 5054], [5056, 5288, 5437, 5437, 5797], [5799, 5799, 5830, 5830, 6053], [6055, 6055, 6080, 6080, 6282], [6284, 6325, 6365, 6404, 6434], [6436, 6436, 6489, 6489, 6590], [6593, 6735, 6847, 6847, 7133], [7135, 7236, 7272, 7272, 7298], [7299, 7299, 7346, 7346, 7407], [8718, 8816, 8838, 8884, 10859], [10862, 10862, 10902, 10902, 11724], [11726, 11820, 11852, 11852, 11888], [11890, 11890, 11923, 11923, 11943], [11944, 11944, 11978, 11978, 11998], [11999, 11999, 12031, 12031, 12052], [12054, 12054, 12079, 12102, 14505], [14507, 14507, 14535, 14535, 14829], [14831, 14831, 14871, 14871, 14945], [14947, 14947, 15080, 15080, 17231], [17233, 17327, 17631, 17631, 18371], [18374, 18374, 18424, 18424, 19760], [19762, 19762, 19811, 19811, 24448], [24451, 24451, 24490, 24490, 26457], [26459, 26546, 26603, 26674, 28240]]}
{"id": "lt2SRc", "name": "Pyramid trip", "author": "rohtie", "description": "Watch in fullscreen. Focus on the middle point. After a little while, look somewhere else. You will see some interesting effects :)", "tags": ["trip"], "likes": 4, "viewed": 252, "published": "Public", "date": "1450312409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 col, in vec2 p) {\n\tp /= iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p.x *= iResolution.x / iResolution.y;    \n    \n    p *= iTime * 50.0;\n    \n\n    float result = max(abs(p.x), abs(p.y));\n    \n    float t =  1.0 + abs(sin(iTime)) * 5.0;\n    \n    result = mod(result, t);\n    \n    result = smoothstep(1.0, 0.95, result);\n    \n    col.rgb = vec3(result);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2SRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 378]]}
{"id": "Md33W7", "name": "Raymarching iterations", "author": "Necromurlok", "description": "Redder the more iterations", "tags": ["raymarchingiterations"], "likes": 2, "viewed": 105, "published": "Public", "date": "1450013365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Thanks to jlfwong for shadertoy tutorials :) */\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 512;\nconst float MIN_DIST = 1.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst float SPLIT_VIEWPORT = 1.0;\nconst float SCENE_TILE = 3.0;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint, float r) {\n//    float off = 1.0 + (sin(iTime + samplePoint.x * 25.0) + cos(iTime + samplePoint.y * 54.0)) * 0.01;\n    return length(samplePoint) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float st = (sin(iTime * 0.25) * SCENE_TILE * 0.5) + (SCENE_TILE * 1.15);\n    samplePoint = mod(samplePoint, st) - vec3(st * 0.5);\n//    samplePoint = vec3((mod(samplePoint, st) - vec3(st * 0.5)).xy, samplePoint.z);\n    float box = udBox(samplePoint, vec3(1.0, 0.5, 0.125));\n    float sphere = sphereSDF(samplePoint + vec3(0.5, 0.0, 0.0), 0.4);\n    sphere = min(sphere, sphereSDF(samplePoint + vec3(-0.5, 0.0, 0.0), 0.25));\n    return max(box, -sphere);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, out float iterations) {\n    float depth = start;\n    iterations = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n        iterations += 1.0;\n    }\n    return end;\n}\n            \nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n\nfloat shadow(vec3 ro, vec3 rd, vec3 lpos){\n    float t = 0.5;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = sceneSDF(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lpos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n//    float sh = shadow(p, normalize(p - light1Pos), light1Pos);\n    \n//    color -= vec3(0.25 - 0.25 * sh);\n//    color *= 1.0 / exp(length(p - eye) * 0.1);\n/*    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    */\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(120.0, iResolution.xy, mod(fragCoord * SPLIT_VIEWPORT, iResolution.xy));\n    \n    vec3 angle = vec3(iTime * 0.2, 0.0, sin(iTime * 0.1) * 1.25);\n    \n    mat3 m = fromEuler(angle);\n    dir = m * dir;\n    \n    vec3 eye = m * vec3(20.0 * sin(iTime * 0.075), 0.0, 30.0 * sin(iTime * 0.1));\n    float iterations;\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST, iterations);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.6, 0.9, 0.2);\n    vec3 K_d = vec3(0.6, 1.0, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n        \n    fragColor = (vec4(color /*+ estimateNormal(p) * 0.25*/, 1.0) +\n                 vec4(0.0125, 0.0, 0.0, 0.0) * iterations) *\n        \t\tpow((1.0 - (dist / MAX_DIST)), 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md33W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 580, 624, 728, 766], [768, 768, 799, 799, 837], [839, 1079, 1113, 1113, 1572], [1574, 1995, 2108, 2108, 2463], [2477, 2477, 2503, 2503, 2849], [2851, 3105, 3170, 3170, 3302], [3304, 3393, 3422, 3422, 3732], [3734, 4226, 4366, 4366, 4956], [4960, 4960, 5002, 5002, 5359], [5361, 5731, 5816, 5816, 6783], [6786, 6786, 6843, 6843, 7910]]}
{"id": "Md33zB", "name": "Rorschach test", "author": "zifnab", "description": "Mirrored and thresholded noise function to generate what looks like ink blots from the Rorschach test", "tags": ["noise", "inkblot", "rorschach"], "likes": 137, "viewed": 4436, "published": "Public", "date": "1450429026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n A noise function mirrored and thresholded to maximize the value at the center of the screen\n Combined with a second layer of noise to produce an ink on paper effect\n*/\n\nconst vec3 inkColor = vec3(0.01, 0.01, 0.1);\nconst vec3 paperColor = vec3(1.0, 0.98, 0.94);\n\nconst float speed = 0.0075;\nconst float shadeContrast = 0.55;\n\n//3D simplex noise from: https://www.shadertoy.com/view/XsX3zB\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t vec4 w, d;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f = 0.0;\t\n\tfloat frequency = 1.0;\n\tfloat amplitude = 0.5;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += simplex3d(p * frequency) * amplitude;\n\t\tamplitude *= 0.5;\n\t\tfrequency *= 2.0 + float(i) / 100.0;\n\t}\n\treturn min(f, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Setup coordinates\n    vec2 uv = 1.0 - fragCoord.xy / iResolution.xy;\n    vec2 coord = 1.0 - uv * 2.0;\n    uv.x = 1.0 - abs(1.0 - uv.x * 2.0);\n    vec3 p = vec3(uv, iTime * speed);\n    \n    //Sample a noise function\n    float blot = fbm(p * 3.0 + 8.0);\n    float shade = fbm(p * 2.0 + 16.0);\n    \n    //Threshold\n    blot = (blot + (sqrt(uv.x) - abs(0.5 - uv.y)));\n    blot = smoothstep(0.65, 0.71, blot) * max(1.0 - shade * shadeContrast, 0.0);\n    \n    //Color\n    fragColor = vec4(mix(paperColor, inkColor, blot), 1.0);\n    fragColor.rgb *= 1.0 - pow(max(length(coord) - 0.5, 0.0), 5.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md33zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 451, 473, 473, 670], [672, 672, 697, 697, 1297], [1299, 1299, 1318, 1318, 1545], [1547, 1547, 1604, 1628, 2202]]}
{"id": "Md3GRl", "name": "Amiga Copper Bounce", "author": "gigatron", "description": "Amiga demo ", "tags": ["amiga", "bars", "copper", "rasters"], "likes": 13, "viewed": 548, "published": "Public", "date": "1451595304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat barsize = 0.08;\nfloat cr=0.0; // color reduction ;\nvec2 position=vec2(0); \nvec3 color=vec3(0);\n\n\n    float r=1.0;\n    float g=1.0;\n    float b=0.0;\n\n\nvec3 mixcol(float value, float r, float g, float b)\n{\n\treturn vec3(value * r, value * g, value * b);\n}\n\nvoid bar(float pos, float r, float g, float b)\n{\n\t if ((position.y <= pos + barsize) && (position.y >= pos - barsize))\n\t\tcolor = mixcol(1.0 - abs(pos - position.y) / barsize, r, g, b);\n}\n\nfloat checkers(vec2 q)\n{\n    return mod(floor(q.x) + floor(q.y), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    position = ( gl_FragCoord.xy / iResolution.xy );\n\tposition = position * vec2(2.0) - vec2(1.0); \t\n\t\n\tfloat t = iTime;\n   \n   \n   \n   \n    if     (mod(0.1*t,2.) < 1.){r=1.0;g=1.0;b=1.0;}\n    if     (mod(0.2*t,2.) < 1.){r=1.0;g=0.0;b=0.0;}\n    if     (mod(0.3*t,2.) < 1.){r=1.0;g=0.0;b=1.0;}\n     \n\n    \n    float ps=0.5;\n    float bf=20.0;\n\t \n    \n    for(float i=0.0;i<0.9;i+=0.08){//  0.9/0.08 bars\n     cr-=0.1;\n     bar(ps*cos(t*3.8+bf*8.*i),r-cr,g-cr,b-cr);\n        \n    //bar(-0.1-p*abs(sin(t*3.+bf/6.*i)),r-cr,g-cr,b-cr);    \n    }\n    \t\n    \n    fragColor = vec4(vec3(color),1.0);\n    \n    //***** continue to add 2 rasters like amiga  ...\n    \n    float x=fragCoord.x;\n    float coppers = -t*5.0;\n    float rep = 128.;// try 8 16 32 64 128 256 ...\n    vec3 col2 = vec3(0.5 + 0.5 * sin(x/rep + 3.14 + coppers), 0.5 + 0.5 * cos (x/rep + coppers), 0.5 + 0.5 * sin (x/rep + coppers));\n    vec3 col3 = vec3(0.5 + 0.5 * sin(x/rep + 3.14 - coppers), 0.5 + 0.5 * cos (x/rep - coppers), 0.5 + 0.5 * sin (x/rep - coppers));\t\n    if ( q.y > 0.95 && q.y<0.956) fragColor = vec4 (vec3(col2), 1.0 ); // mac \n\tif ( q.y > 0.05 && q.y<0.056) fragColor = vec4 (vec3(col3), 1.0 );\n \n} \n\n ", "image_inputs": [{"id": "XsfGz4", "previewfilepath": "https://soundcloud.com/www-digitalista-de/dr-nobody-phalanx-2-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/www-digitalista-de/dr-nobody-phalanx-2-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3GRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 158, 211, 211, 260], [262, 262, 310, 310, 448], [450, 450, 474, 474, 522], [524, 524, 581, 581, 1808]]}
{"id": "Md3GW7", "name": "Donuts Time!", "author": "tom_D", "description": "It's my first ray marching!", "tags": ["donuts"], "likes": 3, "viewed": 180, "published": "Public", "date": "1450002686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* \t\t\t\t\t\t\t\t!!First RayMarching!!\n*/\n#define R iResolution\n#define T iTime\n\nvec3 ro;\nvec3 rd;\nvec3 light;\nvec3 dir;\nstruct RAY\n{\n    vec3 p;\n    float l;\n    float d;\n};\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n    \n    \nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n} \nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n    \nfloat plane(in vec3 p, vec4 n) \n{ \n    return dot(p, n.xyz) + n.w;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n    \nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}    \n\nfloat sphere(in vec3 p, vec4 s)\n{\n    return (length(p - s.xyz) - s.w);\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n \n  return length(q)-t.y;\n}\n\nfloat blob(float a, float b, float coef)\n{\n    return dot(a, b) / coef;\n}\n\nmat3 rotz(float c, float s)\n{\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nmat3 roty(float c, float s)\n{\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nmat3 rotx(float c, float s)\n{\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nvec3 setrotate(float angle, int y, vec3 p, int angle_true)\n{\t\n    float a;\n  \tif (angle_true == 0)\n\t a = radians(iTime * angle);\n    else if (angle_true == 1)\n         a = radians(angle);\n \tfloat c = cos(a);\n    float s = sin(a);\n    if (y == 0)\n        p *= rotx(c, s);\n    else if (y == 1)\n        p *= roty(c, s);\n    else if (y == 2)\n        p *= rotz(c, s);\n\treturn p;\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n /*float getSphere = sphere(p, vec4(setSphere, 2.)); */\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat scene(in vec3 p)\n{\t\n    vec3 res = vec3(0);\n    vec4 plan = vec4(0.,1.,0.,2.);\n    vec3 uv = vec3(0);     \t \t\n   \tres = p;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(60., 0, p, 0);\n   \n\tfloat last = sdTorus82(p, vec2(2., .4));\t\n    \n    p = setrotate(80., 0, p, 0);\n    float ret = sdTorus82(p, vec2(5., 0.4));\n    p = setrotate(90., 2, p, 0);\n    float a = sdTorus82(p, vec2(3., .5));\n    p = res;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(80., 1, p, 0);\n   \tp = setrotate(80., 0, p, 0);\n    float b = sdTorus82(p, vec2(6., .2));\n    p = res;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(40., 1, p, 0);\n    float c = sdTorus82(p, vec2(1., .2));\n    \n    p = res;\n    p.x += 17.0;\n    p.y += 0.0;\n    p.z += -6.0;\n    p = setrotate(0., 1, p, 1);\n    float sed = sdCappedCylinder(p, vec2(1.5, 5.0));\n    \n    p = res;\n    p.x += 17.0;\n    p.y += -5.0;\n    p.z += -6.0;\n    p = setrotate(90., 1, p, 1);\n   \tp = setrotate(-5., 0, p, 1);\n   \tfloat sedx = sdCappedCylinder(p, vec2(1.5, 5.0));\n    p = res;\n    float getPlane = plane(p, plan);\n    p = res;\n    p.x  += -14.0;  p.z += -6.0; \n    float mart = sdCappedCylinder(p, vec2(1.5, 5.0));\n    p = res;\n   \tp.x += -16.0;\n    p.z += -6.0;\n    p.y += -2.0;\n    p = setrotate(-30., 1, p, 1);\n    float mar = sdCappedCylinder(p, vec2(1.5, 3.0));\n     p = res;\n    p.x += -20.0;\n    p.z += -6.0;\n    p.y += -2.0;\n    p = setrotate(30., 1, p, 1);\n    float ma = sdCappedCylinder(p, vec2(1.5, 3.0));\n\tp = res;\n    p.x += -22.0;\n    p.z += -6.0;\n    float sma = sdCappedCylinder(p, vec2(1.5, 5.0));\n    \n    p = res;\n    p = setrotate(50., 0, p, 0);\n   \n    return (min(min(min(min(min(min(min(min(min(min(min(getPlane, last), ret), a), b), c), sedx), sed), mart), mar), ma), sma));\n}\n    \nRAY trace(float maxd)\n{\n    RAY r = RAY(ro, 2., .001);\n    for (int i = 0; i < 128; ++i)\n    {\n        if (abs(r.d) < .001 || r.l > maxd)\n            break;\n        r.l += r.d;\n        r.p = ro + rd * r.l;\n        r.d = scene(r.p);\n    }\n    return r;\n}\nvoid init(in vec2 uv)\n{\n    ro = vec3(0., 4.5, -10.5);\n    rd = normalize(vec3(uv, 1));\n    light = vec3(0, 2, -8);\n    dir = normalize(vec3(0, 0, -1));\n}\n    \nvoid mainImage(out vec4 C, in vec2 U)\n{\n    C.rgb = vec3(0);\n\tvec2 uv = 2. * U.xy / R.xy - 1.;\n    uv.x *= R.x / R.y;\n    init(uv);\n    RAY r = trace(100.);\n    if (r.l < 100.)\n    {\n       // light here\n        vec3 c = mix(vec3(0.,.001,.001), vec3(.001,.001,.001), vec3(-r.p.z));\n        vec3 e = vec3(.00001, 0, 0);\n        vec3 n = vec3(r.d) - vec3(scene(r.p - e.xyy), scene(r.p - e.yxy), scene(r.p - e.yyx));\n        float b = dot(normalize(n), normalize(light - r.p));\n        C.rgb = (b * c + 1.0 * pow(b, 42.)) * (1. - r.l * -55.09);\n   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3GW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 173, 216, 216, 276], [287, 287, 322, 322, 387], [389, 389, 424, 424, 489], [495, 495, 528, 528, 563], [565, 565, 610, 610, 650], [656, 656, 697, 697, 768], [774, 774, 807, 807, 847], [849, 849, 880, 880, 947], [949, 949, 991, 991, 1022], [1024, 1024, 1053, 1053, 1100], [1102, 1102, 1131, 1131, 1178], [1180, 1180, 1209, 1209, 1256], [1258, 1258, 1318, 1318, 1633], [1634, 1634, 1667, 1693, 1724], [1727, 1783, 1814, 1814, 1910], [1912, 1912, 1954, 1954, 2053], [2055, 2055, 2079, 2079, 3809], [3815, 3815, 3838, 3838, 4068], [4069, 4069, 4092, 4092, 4223], [4229, 4229, 4268, 4268, 4782]]}
{"id": "Mdc3Rf", "name": "copy candyCat's Line", "author": "xdlmost", "description": "copy", "tags": ["copy"], "likes": 1, "viewed": 107, "published": "Public", "date": "1451296496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float stripe(float interval,float uorv){\n    float a=interval;\n    float s=(uorv-floor(uorv/a)*a)/a;\n    if(s<=1./4.||s>=3./4.){\n       return 0.0;\n    }else{\n        return 1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat interval=0.08;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(stripe(interval,uv.x)*stripe(interval,uv.y)*(uv.y)*(1.-uv.x)*1.3,0,(1.-stripe(interval,uv.x)*stripe(interval,uv.y))*(1.-uv.y)*(uv.x)*0.3,1.0);\n    uv=-1.0+2.*uv;\n    for(int i=0;i<10;i++){\n        float y= uv.y+sin(uv.x*3.+iTime+float(i)*0.2)*0.5;\n        float ramx=0.05;\n        float r= abs(y)-ramx;\n        if(r<=0.){\n            fragColor=vec4(1.9,1.,1.5,1.)*(r)/-ramx;\n        }\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdc3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 186], [188, 188, 245, 245, 723]]}
{"id": "MdcGRS", "name": "ngWaves10", "author": "netgrind", "description": "squad", "tags": ["noise"], "likes": 3, "viewed": 350, "published": "Public API", "date": "1450378997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float spiral(vec2 pos, float spin, float freq, float phase){\n\tfloat a  = atan(pos.y,pos.x)+length(pos)*spin;\n    return sin(a*freq+phase);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float f = 0.;\n    float c = 0.;\n    /*for(float i = 0.; i<=1.;i+=.1){\n        for(float j = 0.;j<=1.;j+=.1){\n            f+=spiral(uv-vec2(i,j),iMouse.x*.1,10.,iTime+(i+j)*iMouse.y);\n            c++;\n        }\n    }*/\n    for(float i = 0.; i<=1.;i+=.01){\n        float x = mod(i*iMouse.y*.1,1.);\n        float y = i;\n        f+=spiral(uv-vec2(x,y),iMouse.x*.1,10.,iTime+(x+y)*iTime);\n        c++;\n    }\n   \n    f/=c;\n   \t//f+=.5;\n    //f = mod(abs(f),1.);\n    f = abs(f)*4.;\n\tfragColor = vec4(f,f,f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 140], [142, 142, 199, 199, 752]]}
{"id": "MdcGzB", "name": "Cup", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 5, "viewed": 134, "published": "Public", "date": "1450425929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x * b.y - b.x * a.y;\n}\n\n// from https://www.shadertoy.com/view/XsX3zf\nfloat deBezier(in vec2 p, in vec2 b0, in vec2 b1, in vec2 b2) \n{\n  b0 -= p; b1 -= p; b2 -= p;\t\n  float a = Cross(b0, b2), b = 2.0 * Cross(b1, b0), d = 2.0 * Cross(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = Cross(d0p, d20), bp = 2.0 * Cross(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0 ,1.0);\n  return length(mix(mix(b0, b1, t),mix(b1, b2, t), t));\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat deEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n    float si = sqrt( 1.0 - co*co ); \n    vec2 r = vec2( ab.x*co, ab.y*si );\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nfloat map(in vec3 p)\n{    \n    p.zx *= rotate(iTime * 0.5);\n    p.yz *= rotate(iTime * 0.3);\n    vec2 q = vec2(deBezier(p.xy, vec2(1.0, -0.2), vec2(1.5, 0.3),vec2(1.0, 0.5)), p.z);\n\tfloat a = 0.5 * length(q) - 0.05;\n    q = vec2(deEllipse(p.xz ,vec2(0.3, 0.5)), p.y);     \n    float b = deBezier(q, vec2(0.4, -0.5), vec2(0.8, -0.2),vec2(0.6, 0.7)) - 0.04;\n    q = vec2(length(p.xz), p.y); \n    float c = sdSegment(q, vec2(0.0, -0.5), vec2(1.0, -0.6)) - 0.04;\n    return min(min(a, b),c);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}/*\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat parallax(in vec3 p, in vec3 rd, in vec3 bb)\n{\n    float precis = 0.001;\n    if (any(greaterThan(abs(p), bb))) return udBox(p, bb) + precis;\n    const float steps = 200.0;\n    float t;\n    float len = length(bb) * 2.0;\n    for(float i = 0.0; i < steps; i++)\n    {\n        t = len * pow(i / steps, 2.0);\n        vec3 pos = p + rd * t;\n        if (udBox(pos, bb) > 0.0) break;\n        if (map(pos) < precis) break;\n    }   \n \treturn t;   \n}\n*/\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n      \t//h = parallax(ro + rd * t, rd, vec3(1.0));\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 col = mix(vec3(0.05, 0.03, 0.0), vec3(0.8), smoothstep(0.3, 2.5, length(p)));\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.7, 0.6, 0.2);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 100], [102, 102, 152, 152, 272], [274, 274, 311, 311, 347], [349, 395, 459, 459, 953], [955, 996, 1035, 1035, 2120], [2122, 2122, 2144, 2144, 2611], [2613, 2613, 2645, 2645, 2850], [2850, 3371, 3412, 3412, 3740], [3742, 3742, 3799, 3799, 4421]]}
{"id": "MdcGzj", "name": "YCbCr compression", "author": "paniq", "description": "influence of compressing color channels of YCbCr", "tags": ["ycbcr"], "likes": 7, "viewed": 686, "published": "Public API", "date": "1450795449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat3 rgb2ycbcr = mat3(\n    0.299, -0.168736, 0.5, \n    0.587, -0.331264, -0.418688,   \n    0.114, 0.5, -0.081312\n);\n\nconst mat3 ycbcr2rgb = mat3(\n    1.0, 1.0, 1.0,\n    0.0, -0.344136, 1.772, \n    1.402, -0.714136, 0.0\n);\n\n// simulating 8:4:4 compression ratio (16bit)\nvec3 compress_ycbcr_844 (vec3 rgb) {\n    vec3 ycbcr = rgb2ycbcr * rgb;\n    ycbcr.r = floor(ycbcr.r * 255.0 + 0.5) / 255.0;\n    ycbcr.gb += 0.5;\n    ycbcr.gb = floor(ycbcr.gb * 15.0 + 0.5) / 15.0;\n    ycbcr.gb -= 0.5;    \n    return ycbcr2rgb * ycbcr;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rgb = vec3(uv,0.5+0.5*sin(iTime));\n    if (uv.x > 0.5)\n        rgb = compress_ycbcr_844(rgb);\n\tfragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 275, 311, 311, 527], [530, 530, 587, 587, 762]]}
{"id": "MddGD8", "name": "pink tentacles", "author": "rrredwood", "description": "simple, unoptimized shader. Would love to learn how to make edges more anti-aliased.", "tags": ["pink", "tentacle"], "likes": 3, "viewed": 101, "published": "Public", "date": "1449464180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159265359\n\nfloat nsin (float x){\n  return (sin (x) +1.)/2.;\n}\n\nfloat ncos (float x){\n  return (cos (x) +1.)/2.;\n}\n\nfloat random (float x) { \n    return fract(sin(dot(vec2(x,.0),\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\nfloat noise (float x){\n  float i = floor(x);\n  float f = fract(x);\n  float y = random(i);\n  float u = f * f * (3.0 - 2.0 * f );\n  y = mix(random(i), random(i + 1.0), u);\n  return y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noisey2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 mix_colors(float k){\n  return mix( vec3(0.129, 0.180, 0.196), vec3(0.800, 0.529, 0.788), k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    float N = 20.0;//u_mouse.x/u_resolution.x*40.;\n    //float timer = fract(iTime/N);\n\n\n    st = (st-vec2(.5))*2.0;\n\n    float d = length(st);\n    float a = atan(st.y,st.x);\n    float nst = noisey2(st*10.04);\n\n    //first pass\n    float dfield = d * N + nsin(a)*20. + noisey2(vec2(d*3.0)+vec2(1000.0,1000.0))*10.0;\n    float alternating = mod(dfield + iTime*2.0,2.0);//dfield = fract(dfield);\n    alternating *= .01;\n    alternating = mod(alternating,.2);\n    float intensity =30.*alternating;\n    vec3 color1 = mix_colors(intensity);\n\n    //second pass\n    float dfield2 = d * N + nsin(a)*60. + noisey2(vec2(d*3.0)+vec2(500.0,100.0))*10.0;\n    float alternating2 = mod(dfield2 + iTime*4.0,6.0);\n    // Add the shape on the foreground\n    alternating2 *= .01;\n    alternating2 = mod(alternating2,.2);\n    float intensity2 =30.*alternating2;\n\n    vec3 color2 = mix_colors(intensity2);\n\n    color = min(color1, color2) + smoothstep(.9,1.0,color1);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 49, 49, 78], [80, 80, 101, 101, 130], [132, 132, 156, 156, 270], [271, 271, 293, 293, 454], [456, 456, 478, 478, 617], [619, 701, 725, 725, 1131], [1133, 1133, 1158, 1158, 1232], [1234, 1234, 1290, 1290, 2347]]}
{"id": "MddGRj", "name": "Rosetta", "author": "sixstring982", "description": "What secrets lie in the stone?", "tags": ["terrain", "menger", "euler"], "likes": 10, "viewed": 1420, "published": "Public", "date": "1451344509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**  Rosetta\n  *  sixstring982 - 2015\n  *\n  *  First shot at doing some iterative structures.\n  *  Got some help from iq's page on that topic.\n  */\n\n#define INFTY 1e20\n#define EPS 0.001\n\n#define NIGHT_COLOR vec3(0.05, 0.05, 0.125)\n#define DAY_COLOR vec3(0.25, 0.5, 0.75)\n#define FOG_START 3.0\n#define FOG_END 20.0\n\n#define PI 3.1415926535\n#define PIOVERTWO 1.57079632679\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat box3(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat box2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat heightAt(vec2 xz) {\n    return texture(iChannel0, (xz + vec2(1.0)) * 0.005).r - 0.04;\n}\n\nfloat plane(in vec3 p, in vec4 n) {\n    return dot(p, n.xyz) + n.w + \n        2.0 * heightAt(p.xz);\n}\n\nfloat opI(in float a, in float b) {\n    return max(a, b);\n}\n\nfloat opS(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opU(in float a, in float b) {\n    return min(a, b);\n}\n\nvec3 vectorField(in vec3 p) {\n    return vec3(-p.y * sin(iTime / 3.0), \n                -p.z * sin(iTime / 5.0), \n                 p.x * cos(iTime / 7.0));\n}\n\n#define EULER_ITERS 2\n#define LAMBDA 0.05\nvec3 euler(in vec3 p){\n    float lambda = mix(0.0, 8.0 * LAMBDA, 0.5 + 0.5 * sin(iTime / 11.0));\n    for (int i = 0; i < EULER_ITERS; i++) {\n        p = p + lambda * vectorField(p);\n    }\n    return p;\n}\n\n#define MENGER_ITERS 3\nfloat mengerSponge(in vec3 p) {\n    float d = box3(p, vec3(1.0));\n    float scale = 1.0;\n    \n    for (int i = 0; i < MENGER_ITERS; i++) {\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        r = euler(r);\n        \n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        \n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        d = max(d, c);\n    }\n    \n    return d;\n}\n\nfloat map(in vec3 ro) {\n    // d = opU(d, sphere(ro, 2.0));\n    float d = mengerSponge(ro);\n    d = opU(d, plane(ro, normalize(vec4(0.0, -1.0, 0.0, 1.0))));\n    return d;\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 e = vec2(EPS, 0.0);\n    return normalize(vec3(map(ro + e.xyy) - map(ro - e.xyy),\n                          map(ro + e.yxy) - map(ro - e.yxy),\n                          map(ro + e.yyx) - map(ro - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float maxDist) {\n    float d = EPS;\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        if (d < abs(EPS) ||\n            td > maxDist) {\n            break;\n        }\n        \n        d = map(ro);\n        ro += d * rd;\n        td += d;\n    }\n    \n    if (d < abs(EPS)) {\n        return td;\n    } else {\n        return INFTY;\n    }\n}\n\n#define LIGHT_COUNT 1\nbool light(in int idx, out vec3 lightPos) {\n    // Sun light\n    if (idx == 0) {\n        lightPos = vec3(1000.0,\n                        1000.0 * -sin(iTime * 0.01),\n                        1000.0 * cos(iTime * 0.01));\n        return true;\n        \n    // Rotating light        \n    } else if (idx == 1) {\n        lightPos = vec3(5.0 * sin(iTime),\n                        -1.0,\n                        5.0 * -cos(iTime));\n        return true;\n        \n    // Still light\n    } else if (idx == 0) {\n        lightPos = vec3(-3.0);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvec3 fogColor() {\n    vec3 lightPos;\n    if (light(0, lightPos) &&\n        lightPos.y < 0.0) {\n        lightPos = normalize(lightPos);\n        return mix(NIGHT_COLOR, DAY_COLOR, -lightPos.y);\n    }\n    return NIGHT_COLOR;\n}\n\nmat3 materialAt(in vec3 p, out float shininess) {\n    if (abs(p.x) <= 1.01 &&\n        abs(p.y) <= 0.999 &&\n        abs(p.z) <= 1.01) {\n        shininess = 1.0;\n        return mat3(vec3(0.3294 * p.x, 0.2235, 0.0274),\n                    vec3(0.7803, 0.5686 * p.y, 0.1137 * p.z),\n                    vec3(0.9921, 0.9411 * p.x, 0.8078 * p.y));\n    } else if (texture(iChannel1, p.xz * 0.01).r > 0.3) {\n        shininess = 1.0;\n        return mat3(0.5, 0.5, 0.5,\n                    1.0, 1.0, 1.0,\n                    1.0, 1.0, 1.0);\n    } else {\n        shininess = 1.0;\n        float amt = min(1.0, texture(iChannel1, p.xz * 0.01).g * 5.0);\n        return mat3(mix(vec3(0.5), texture(iChannel1, p.xz * 0.01).rgb * 0.2, amt),\n                    mix(vec3(1.0), texture(iChannel1, p.xz * 0.01).rgb * 0.7, amt),\n                    mix(vec3(1.0), texture(iChannel1, p.xz * 0.01).rgb * 0.8, amt));\n        \n    }\n}\n\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.0;\n    float delta = 0.5;\n    for (float i = 1.0; i <= 5.0; i++) {\n        float c = (1.0 / pow(2.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += c;//clamp(c, 0.0, 1.0);\n    }\n    \n    return 1.0 - k * s;\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float td) {\n    float shininess;\n    mat3 mat = materialAt(ro, shininess);\n    float fogAmt = 0.0;\n    vec3 N = normalAt(ro);\n    vec3 V = -rd;\n    float shadow = 0.25;\n\n    if (td > FOG_START) {\n        fogAmt = smoothstep(0.0, 1.0, (td - FOG_START) / (FOG_END - FOG_START));\n    }\n    \n    float diff = 0.0;\n    float spec = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n        vec3 lp;\n        if (light(i, lp)) {\n            vec3 L = normalize(lp - ro);\n            vec3 R = reflect(-L, N);\n            \n            float sd = march(lp, -L, 10000.0);\n            lp = lp - sd * L;\n            \n            if (length(lp - ro) < 0.01) {\n                shadow = max(shadow, 1.0);\n            }\n            \n            diff = clamp(diff + max(0.0, dot(L, N)), 0.0, 1.0);\n            spec = clamp(spec + max(0.0, pow(dot(R, V), shininess)), 0.0, 1.0);\n        }\n    }\n    \n    vec3 lit = vec3((diff + spec) * shadow);\n    vec3 color = mat[0] * occlusion(ro, N, 0.9) +\n                 mat[1] * diff +\n                 mat[2] * spec;\n    \n    return mix(color * shadow, fogColor(), fogAmt);\n}\n\n#if 1\n#define CAM_DIST 2.5\n#define CAM_SPEED 0.08\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float theta = iMouse.x * 0.02 + iTime * CAM_SPEED;\n    ro = vec3(CAM_DIST * sin(theta), \n              0.0, \n              CAM_DIST * -cos(theta));\n    ro = vec3(ro.x, heightAt(ro.xz) * 2.0, ro.z);\n    vec3 t = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    \n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#else\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = ballPos();\n    vec3 t = targetPos();\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    \n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    float td;\n    setupCamera(uv, ro, rd);\n    \n    td = march(ro, rd, FOG_END);\n    ro = ro + td * rd;\n    if (td < INFTY) {\n        fragColor = vec4(lighting(ro, rd, td), 1.0);\n    } else {\n        fragColor = vec4(fogColor(), 1.0);\n    }\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 372, 409, 409, 437], [439, 439, 473, 473, 569], [571, 571, 605, 605, 692], [694, 694, 719, 719, 787], [789, 789, 824, 824, 890], [892, 892, 927, 927, 951], [953, 953, 988, 988, 1013], [1015, 1015, 1050, 1050, 1074], [1076, 1076, 1105, 1105, 1233], [1277, 1277, 1299, 1299, 1480], [1505, 1505, 1536, 1536, 1999], [2001, 2001, 2024, 2060, 2173], [2175, 2175, 2202, 2202, 2418], [2420, 2420, 2475, 2475, 2806], [2830, 2830, 2873, 2890, 3422], [3424, 3424, 3441, 3441, 3647], [3649, 3649, 3698, 3698, 4557], [4559, 4559, 4610, 4610, 4882], [4884, 4884, 4936, 4936, 6027], [6917, 6917, 6974, 6974, 7346]]}
{"id": "MddGRS", "name": "Cloud shader", "author": "skaven", "description": "Some kind of schematic cloud.", "tags": ["cloud", "schematic"], "likes": 5, "viewed": 631, "published": "Public API", "date": "1450548342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec2 spherePos, vec2 pos, float radius)\n{\n    vec2 df = spherePos-pos;\n    return max((radius - sqrt(dot(df,df)))/radius,0.0);\n}\n\n\nvec2 rotate(vec2 xy, float angle)\n{\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(xy.x*cs-xy.y*sn, xy.y*cs + xy.x*sn);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\nfloat udBox( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat cloud(vec2 uv)\n{\n    float intensity = sphere(vec2(0.0), uv, 0.2);\n    \n    for (int i=0;i<10;i++)\n    {\n        float ifl = float(i);\n        vec2 sph = vec2(hash(ifl), hash(ifl+67.47))*0.3;\n    \tintensity = max(intensity, sphere(rotate(sph.xy,(hash(ifl+18.47)*0.3 + 0.05)*iTime) , uv, hash(ifl+119.47)*0.16+0.05));\n    }\n    intensity = min(intensity, uv.y*10.0);\n    intensity = max(intensity, (0.02-udBox(uv, vec2(0.5,0.01))) * 10.0);\n    \n    return intensity;\n}\n\nfloat cloudSat(vec2 uv)\n{\n    float intensity = cloud(uv);\n    \n    return mix( 0.0, 1.0, smoothstep(0.06, 0.1, intensity));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    uv *= 0.7;\n    uv.y += 0.175;\n    \n    \n    float occCloud = 0.0;\n    for (float y = -2.0; y<2.0;y+=0.5)\n    {\n        for (float x = -2.0; x<2.0;x+=0.5)\n        {\n            occCloud += cloud(uv*0.8 + vec2(x,y)*0.025 + vec2(0.08));\n        }\n\t}\n    occCloud = smoothstep(0.0,12.0,occCloud);\n    \n\n    vec3 skyColor = vec3(0.25,0.26,0.8);\n    vec3 col = mix(skyColor, skyColor*0.5, occCloud);\n        \n    col = mix(col, vec3(1.0), cloudSat(uv));\n    //col = vec3(occCloud);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 141], [144, 144, 179, 179, 288], [290, 290, 313, 313, 349], [352, 352, 383, 383, 421], [423, 423, 445, 445, 896], [898, 898, 923, 923, 1024], [1030, 1030, 1087, 1087, 1695]]}
{"id": "MddGWN", "name": "Particle Experiment 7", "author": "aiekick", "description": "Mouse.x => Zoom\nMouse.y => Particle Duration", "tags": ["experiment", "particle", "7"], "likes": 23, "viewed": 1441, "published": "Public API", "date": "1449788699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+5.;\n\tfloat z = 6.;\n\n\tconst int n = 100; // particle count\n    \n    vec3 startColor = vec3(0,0.64,0.2);\n\tvec3 endColor = vec3(0.06,0.35,0.85);\n    \n\tfloat startRadius = 0.84;\n\tfloat endRadius = 1.6;\n    \n\tfloat power = 0.51;\n\tfloat duration = 4.;\n    \n\tvec2 \n\t\ts = iResolution.xy,\n\t\tv = z*(2.*gl_FragCoord.xy-s)/s.y;\n    \n    // Mouse axis y => zoom\n\tif(iMouse.z>0.) v *= iMouse.y/s.y * 20.;\n    \n    // Mouse axis x => duration\n\tif(iMouse.z>0.) duration = iMouse.x/s.x * 10.;\n    \n\tvec3 col = vec3(0.);\n    \n\tvec2 pm = v.yx*2.8;\n    \n\tfloat dMax = duration;\n    \n\n    float evo = (sin(iTime*.01+400.)*.5+.5)*99.+1.;\n\t\n\tfloat mb = 0.;\n\tfloat mbRadius = 0.;\n\tfloat sum = 0.;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfloat d = fract(t*power+48934.4238*sin(float(i/int(evo))*692.7398));\n    \t \t\t\n\t\tfloat tt = 0.;\n\t\t\t\n        float a = 6.28*float(i)/float(n);\n\n        float x = d*cos(a)*duration;\n\n        float y = d*sin(a)*duration;\n        \n\t\tfloat distRatio = d/dMax;\n        \n\t\tmbRadius = mix(startRadius, endRadius, distRatio); \n        \n\t\tvec2 p = v - vec2(x,y);//*vec2(1,sin(a+3.14159/2.));\n        \n\t\tmb = mbRadius/dot(p,p);\n    \t\n\t\tsum += mb;\n        \n\t\tcol = mix(col, mix(startColor, endColor, distRatio), mb/sum);\n\t}\n    \n\tsum /= float(n);\n    \n\tcol = normalize(col) * sum;\n    \n\tsum = clamp(sum, 0., .4);\n    \n\tvec3 tex = vec3(1.);\n     \n\tcol *= smoothstep(tex, vec3(0.), vec3(sum));\n        \n\tfragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddGWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 195, 252, 252, 1684]]}
{"id": "Mdt3R2", "name": "Curious Reflection", "author": "jt", "description": "Discovered by accident while trying to write a function reflecting a particle-trajectory inside an octagon:\nthe particle is always reflected by the box but only mostly by the line:\nsometimes it \"tunnels\" through (if the angle is shallow?).\n", "tags": ["reflection", "mirror", "stateless", "loopless", "peculiar"], "likes": 8, "viewed": 202, "published": "Public", "date": "1451067788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Curious Reflection - written 2015 by JT\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Discovered by accident while trying to write a function reflecting a particle-trajectory inside an octagon:\n// the particle is always reflected by the box but only mostly by the line:\n// sometimes it \"tunnels\" through (if the angle is too shallow?).\n\n// original\n#define mirror(v) (1. - (2. * abs(2. * fract(((v) + 1.) / 4.) - 1.)))\n\nfloat ball(vec2 c, vec2 v)\n{\n    return step(.01, length(c - v));\n}\n\nfloat box(vec2 v)\n{\n    return 1. - step(1., max(abs(v.x), abs(v.y)));\n}\n\nfloat line(vec2 v)\n{\n    return smoothstep(.0, .01, abs(v.x - v.y));\n}\n\n#define Mat mat2(1,-1,1,1)\n#define Inv mat2(.5,.5,-.5,.5)\n\nvec2 T(vec2 v)\n{\n    //v = mirror(v);\n    v = Mat * v;\n    v = mirror(v);\n    v = Inv * v;\n    v = mirror(2.*v)/2.;\n    return v;\n}\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n\tvec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n    o = vec4(1);\n    o *= box(I);\n    o *= line(I);\n    o *= ball(T(vec2(sqrt(.3),sqrt(.2)) * iTime)*2., I);\n}\n\n/* with changes suggested by FabriceNeyret2\n#define mirror(v) ( 1. - 2. * abs(2. * fract((v + 1.) / 4.) - 1.))\n#define ball(c, v) step(.01, length(c-v))\n#define box(v) ( 1. - step(1., max(abs(v.x), abs(v.y))) )\n#define line(v) ( abs(v.x - v.y) * 100. )\n\n#define Mat mat2(1,-1,1,1)\n#define Inv .5*mat2(1,1,-1,1)\n\nvec2 T(vec2 v)\n{\n    //v = mirror(v);\n    v = Mat * v;\n    v = mirror(v);\n    v = Inv * v;\n    v = mirror(2.*v)/2.;\n    return v;\n}\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n\tvec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n    o = vec4(1);\n    o *= box(I);\n    o *= line(I);\n    o *= ball(T(vec2(sqrt(.3),sqrt(.2)) * iTime)*2., I);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdt3R2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[385, 468, 496, 496, 535], [537, 537, 556, 556, 609], [611, 611, 631, 631, 681], [742, 742, 758, 779, 873], [875, 875, 911, 911, 1069]]}
{"id": "Mdt3Rj", "name": "dueling plasma balls?", "author": "bpt", "description": "still learning by adjusting the fantastic shaders from others.", "tags": ["borrowed", "drifted", "tweaked"], "likes": 9, "viewed": 253, "published": "Public", "date": "1451007900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 what(vec2 p,float time,vec2 mouse,float a){\n\tvec4 dmin = vec4(1000.);\n\tvec2 z = (p-0.5)*vec2(1.7,1.0)*1.3;\n\tfloat w = .1 * p.x * p.y;\n\tvec2 op = 1.-p;\n\tvec2 mv = ((mouse-vec2(0.5))+vec2(1.-acos(op.x*w),1./acos(op.y*w)));\n\tfor( int i=0; i<8; i++ ){\n\t\tz = mv+vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y);\n\t\tmv /= ((dmin.x+dmin.y)*a);\n\t\tz += z*.5;\n\t\tdmin=min(dmin,vec4(abs(0.0+z.y+0.5*sin(z.x+time*5.)),abs(1.0+z.x+0.5*sin(z.y+time)),dot(z,z),length(fract(z)-0.5)));\n\t}\t\n\tvec3 color = vec3( mix(vec3(dot(dmin.rgb, -dmin.gba)), dmin.rgb, 1.0-dmin.a) );\n\tcolor = mix( color, vec3(1.00,1.00,0.00),  1.00-min(1.0,pow(dmin.z*1.00,0.15)));\n\tcolor = mix( color, vec3(0.00,1.00,1.00),  1.00-min(1.0,pow(1.0-dmin.x*0.25,18.20)));\n\tcolor = mix( color, vec3(-1.00,0.00,1.00),  1.00-min(1.0,pow(dmin.y*0.50,.1250)));\n\tcolor = mix( color, vec3(1.00,1.00,0.00),  1.00-min(1.0,pow(dmin.z*1.00,0.115)));\n\tcolor = 1.25 * color*color*color;\n\tcolor.r *= color.r;\n    return vec4(1.0-color.rgb*(0.5 + 0.5*pow(16.0*p.x*(1.0-p.x)*p.y*(1.0-p.y),1.5)),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime * 0.25;\n    fragColor = what( uv, t, vec2(0.5), -3.0 );\n    \n}\n\n// started with http://glslsandbox.com/e#29622.0 and drifted a bit\n// Created by inigo quilez - iq/2013 // glslsandbox mod by Robert Schtze - trirop/2015 - absurd tweaks by bpt\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdt3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 49, 49, 1027], [1029, 1029, 1086, 1086, 1219]]}
{"id": "Mdt3Wr", "name": "~ {{ O }} ~ (78) ~ {{ O }} ~", "author": "MrHenryBemis", "description": "THEE HYPER-ET MOSQUE GEMATRIA", "tags": ["light", "vortex", "interpolation"], "likes": 8, "viewed": 195, "published": "Public", "date": "1449108763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime sin(iTime*6.2)\n\n#define DTM 78.0\n\n#define D 8.0\n#define T 35.0\n#define M 35.0\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float scale = (sin(iTime)*.5+.5);\n    \n    float d;\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 33; i++)\n    {\n        vec2 p = vec2(cos(float(i)/33.0*PI*2.0+iTime), sin(float(i)/33.0*PI*2.0+iTime));\n    \n        d = length(uv-p)*0.7;\n        \n        \n    \tif(d <= 3.0)\n        {\n            col += (vec3(\n            sin(-iTime*PI*2.0+D+d*PI),\n            sin(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n            sin(-iTime*PI*2.0+2.0*PI/2.0+T+d*PI))*.5+.5)*sin(d*PI*DTM+iTime*DTM);\n        }\n    }\n    \n    d = length(uv)*2.2;\n    \n    col += vec3(\n    \tsin(-iTime*PI*3.0+D+d*PI),\n        sin(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n        sin(-iTime*PI*3.0+3.0*PI/2.0+T+d*PI));\n    \n\t\tfragColor = vec4(col, 1.0);\n}\n\n\n/*\n#define iTime iTime*.2\n\n#define DMT 134.0\n\n#define D 4.0\n#define M 40.0\n#define T 90.0\n\n#define PI 3.14159265359\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * MOD3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float scale = (sin(iTime)*.5+.5);\n    \n    float d = length(uv)*1.2;\n    \n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 2; i++)\n    {\n        vec2 p = hash21(float(i))*2.0-1.0;\n    \n        d = length(uv-p)*1.5;\n        \n        \n    \tif(d <= 1.0)\n        {\n            col += (vec3(\n            sin(-iTime*PI*2.0+D+d*PI),\n            sin(-iTime*PI*2.0+4.0*PI/3.0+M+d*PI),\n            sin(-iTime*PI*2.0+2.0*PI/3.0+T+d*PI))*.5+.5)*(sin(d*PI*DMT)*.5+.5);\n        }\n    }\n    \n    col = vec3(\n            sin(col.x*2.0+D),\n            sin(col.y*2.0+4.0*PI/3.0+M),\n            sin(col.z*2.0+2.0*PI/3.0+T))*.5+.5;\n    \n\t\tfragColor = vec4(col, 1.0);\n}\n*/", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdt3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 176, 176, 1003]]}
{"id": "MdtGDM", "name": "try raymarching", "author": "candycat", "description": "first try.", "tags": ["raymarching"], "likes": 18, "viewed": 1203, "published": "Public", "date": "1450192050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define PRECIS 0.001\n#define DMAX 30.0\n#define EDGE_WIDTH 0.4\n#define EDGE_SMOOTH 0.1\n\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\n//=============\n\nfloat fSphere(vec3 p) {\n    return length(p) - 0.6;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0))-0.2;\n}\n\nfloat fCylinder(vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat fTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//=============\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 pos) {\n    vec3 id = floor((pos+2.0)/4.0);\n    float rid = hash(dot(id, vec3(0.1, 0.4, 0.9)))+0.5;\n    pos = mod( pos+2.0, 4.0)-2.0;\n    pos = rotx(pos, iTime * 0.5 + id.x * id.y * 1.7 + sin(iTime));\n    pos = roty(pos, iTime * 0.5 + id.y * id.z * 1.7 + cos(iTime));\n    return vec2(fBox(pos, vec3(0.3)), rid);\n    return vec2(fTorus(pos, vec2(0.3, 0.4)), rid);\n    //return vec2(fCylinder(pos, vec3(0.1, 0.1, 0.3)), rid);\n    //return vec2(fSphere(pos), rid);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n                    map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n                         \tmap(pos + eps.yyx).x - map(pos - eps.yyx).x));\n}\n    \nvec2 render(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float id = -1.0;\n    float lastD = 0.0;\n    for (int i = 0; i < 50; i++) {\n       \tvec2 res = map(ro+t*rd);\n        t += res.x;\n        id = res.y;\n        if (res.x < PRECIS || t > DMAX) break; \n    }\n    \n    if (t > DMAX) id = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 marching(vec3 ro, vec3 rd) {\n    vec3 light = normalize(vec3(0.6, 0.8, -0.3));\n    float sun = dot(-rd, light);\n    sun = 0.5 * sun + 0.5;\n    vec3 bg = vec3(0.65,0.45,0.4)*sun+vec3(0.2, 0.2, 0.3);\n    vec3 col = bg;\n    \n    vec2 res = render(ro, rd);\n    if (res.y > -0.5) {\n        // lighting\n        vec3 nor = normal(ro+res.x*rd);\n        vec3 view = -rd;\n        \n        vec3 amb = vec3(0.05);\n        \n        float dif = dot(nor, light);\n        dif = dif * 0.5 + 0.5;\n        \n        vec3 h = normalize(light - rd);\n        float spec = pow(clamp(dot(nor, h), 0.0, 1.0), 50.0) * 0.9;\n        \n        float edge = clamp(dot(nor, view), 0.0, 1.0);\n        edge = mix(0.0, 1.0, smoothstep(EDGE_WIDTH-EDGE_SMOOTH, EDGE_WIDTH, edge));\n        \n        vec3 scol = vec3(0.3+hash(res.y*0.2),0.3+hash(res.y*0.4),0.3+hash(res.y*0.6));\n        col = amb + (dif + spec) * scol * pow(sun, 0.2) * edge;\n    }\n    \n    col = mix(col, bg, smoothstep(10.0, DMAX, res.x));\n    return col;\n}\n\nvec3 rotrd(vec3 rd, vec2 mouse) {\n    rd = rotx(rd,sin(iTime*0.12+sin(iTime*.5)*1.)+mouse.x*5.0);\n    rd = roty(rd,sin(iTime*0.2)*0.5+mouse.y*5.0);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p = -1.0 + 2.0 * p;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = -1.0 * 2.0 * mouse;\n    \n    vec2 delta = vec2(1.0/iResolution.y, 0.0);\n    vec3 ro, rd;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    ro = vec3(2.0, 2.0, 0.0) + iTime*2.0;\n    for (int i = -AA; i <= AA; i++) {\n        for (int j = -AA; j <= AA; j++) {\n            rd = normalize(vec3(p.xy+1.0/iResolution.y*vec2(i,j), 1.5));\n    \t\trd = rotrd(rd, mouse);\n    \t\tcol += marching(ro, rd);\n        }\n    }\n    col /= float((2*AA+1)*(2*AA+1));\n    \n    col *= clamp(1.0-length(p)*0.3,0.0,1.0);\n    \n    col = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 121, 121, 160], [162, 179, 202, 202, 232], [234, 234, 262, 262, 304], [306, 306, 339, 339, 373], [375, 375, 405, 405, 470], [472, 489, 517, 517, 605], [606, 606, 634, 634, 723], [725, 725, 745, 745, 1201], [1203, 1203, 1226, 1226, 1471], [1477, 1477, 1508, 1508, 1798], [1800, 1800, 1833, 1833, 2791], [2793, 2793, 2826, 2826, 2957], [2959, 2959, 3016, 3016, 3738]]}
{"id": "MdtGRB", "name": "Alien Swirl", "author": "xbe", "description": "Playing around with iterative function from sofiane benchaa shader: Illustrated Equations (https://www.shadertoy.com/view/MtBGDW).", "tags": ["procedural", "2d", "iterativefunction"], "likes": 17, "viewed": 915, "published": "Public API", "date": "1450621191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////////\n// Alien Swirl - xbe\n//\n// Inspired by shader from sofiane benchaa\n// https://www.shadertoy.com/view/MtBGDW\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FIELD 10.0\n#define ITERATIONMAX 16.\n#define TONE1 vec3(0.299,0.787,0.114)\n#define TONE2 vec3(0.587,0.299,0.114)\n\n\nvec2 SwirlEQ(vec3 p, float t, float it){\n\tvec2 fx = p.xy;\n    t *= 0.3;\n\tp = (abs(p*2.0));\n\tvec2 ab = vec2(2.0-p.x);\n    float i = 0.;\n    for(float i=0.; i < ITERATIONMAX; i++) {\n\t\tif (i >= it) break;\n\t\tab  += (p.xy) + cos(length(p));\n\t\tp.y += sin(ab.x - p.z - 0.5*t) * 0.5;\n\t\tp.x += sin(ab.y + t) * 0.5;\n\t\tp   -= (p.x+p.y);\n\t\tp   += sin(fx.x) * cos(fx.y);\n\t\tab  += vec2(p.y);\n\t}\n\tp   /= FIELD;\n\tfx.x = (p.x+p.x+p.y);\n\treturn fx;\n}\n\n////////////////////////////////////////////////////////\nvec3 computeColor(vec2 fx){\n\tvec3 color = vec3(TONE1);\n\tcolor -= (fx.x);\n    if (color.y < 0.) {\n        color *= -vec3(TONE2);\n    } else {\n\t\tcolor.b += color.g*1.5;\n    }\n\treturn clamp(color,(0.0),(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time  = iTime;\n\tfloat ratio = iResolution.y / iResolution.x;\n\tfragCoord.y *= ratio;\n\tvec2 position = ( fragCoord.xy / iResolution.xy ) - vec2(0.5,0.5 * ratio);\n\tvec3 p = position.yxy * FIELD;\n    vec2 a = SwirlEQ(p,time,8.);\n    vec2 b = 0.9 * SwirlEQ(p,time,10.);\n    vec2 c = 0.8 * SwirlEQ(p,time,12.);\n    float m = sin(0.333 * time);\n    vec2 d = mix(b, a, abs(m) - m);\n    d = mix(d, c, clamp(m, 0., 1.));\n\tvec3 color = computeColor(d);\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 395, 435, 435, 827], [829, 886, 913, 913, 1094], [1096, 1096, 1153, 1153, 1638]]}
{"id": "MdtGWH", "name": "Deep under the ice...", "author": "NegativeZero", "description": "Accidentally made an ice effect.", "tags": ["fractal"], "likes": 43, "viewed": 676, "published": "Public", "date": "1449483193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Based off of https://www.shadertoy.com/view/lslGWr\n\nconst int max_iterations = 32;\nconst vec3 a = vec3(-.5, -.4, -1.5);\n\nfloat field( vec3 p ) {\n    float strength = 5.0;\n    float prev = 0.;\n    float acc = 0.;\n    float tw = 0.;\n    for(int i = 0; i < max_iterations; i++) {\n        float mag = dot(p, p);\n        p = abs(p) / mag + a;\n        float w = exp(-float(i) / strength);\n        acc += w * exp(-strength * pow(abs(mag - prev), 2.));\n        tw += w;\n        prev = mag + w;\n    }   \n    return max(0., acc / tw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1. + 2. * fragCoord.xy / iResolution.xy;\n    vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 offset = vec2(sin(iTime), cos(iTime));\n    //vec2 offset = -1. + 2. * iMouse.xy / iResolution.xy;\n    \n    float frc = 0.;\n    for(int i = 0; i < 5; i++){\n        frc += field(vec3(uvs, frc) + vec3(2. * offset / float(i + 1), 0.));\n    }\n    \n\tfragColor = vec4(frc * frc * frc, frc * frc, frc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 123, 146, 146, 528], [530, 530, 587, 587, 1023]]}
{"id": "MlSSWV", "name": "Lovely Stars", "author": "yibojiang", "description": "lovely star inspired by Little Prince", "tags": ["star"], "likes": 28, "viewed": 1627, "published": "Public API", "date": "1450200755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159\nconst float indent = 0.06;\nfloat angular = 5.;\n\nfloat hash( float n )\n{\n  return fract( (1.0 + cos(n)) * 415.92653);\n}\n\nfloat noise2d( in vec2 x )\n{\n  float xhash = hash( x.x * 37.0 );\n  float yhash = hash( x.y * 57.0 );\n  return fract( xhash + yhash );\n}\n\n//steal from https://www.shadertoy.com/view/4tfGWr\nfloat drawStar(vec2 o, float size, float startAngle) {\n  vec2 q = o;\n  q *= normalize(iResolution).xy;\n//    float startAngle = -iTime / size*0.001;\n  //float startAngle=size*1000.;\n\n  mat4 RotationMatrix = mat4( cos( startAngle ), -sin( startAngle ), 0.0, 0.0,\n                              sin( startAngle ),  cos( startAngle ), 0.0, 0.0,\n                              0.0,           0.0, 1.0, 0.0,\n                              0.0,           0.0, 0.0, 1.0 );\n  q = (RotationMatrix * vec4(q, 0.0, 1.0)).xy;\n\n  float angle = atan( q.y, q.x ) / (2.*pi);\n\n\n  float segment = angle * angular;\n\n\n  float segmentI = floor(segment);\n  float segmentF = fract(segment);\n\n  angle = (segmentI + 0.5) / angular;\n\n  if (segmentF > 0.5) {\n\n    angle -= indent;\n  } else\n  {\n\n    angle += indent;\n  }\n  angle *= 2.0 * pi;\n\n  vec2 outline;\n  outline.y = sin(angle);\n  outline.x = cos(angle);\n\n  float dist = abs(dot(outline, q));\n\n  float ss = size * (1. + 0.2 * sin(iTime * hash(size) * 20. ) );\n  float r = angular * ss;\n\n\n\n  float star = smoothstep( r, r + 0.005, dist );\n\n\n  return star;\n}\n\nfloat drawFlare(vec2 o, float size) {\n  o *= normalize(iResolution).xy;\n  float flare = smoothstep(0.0, size, length(o) );\n  return flare;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n  vec3 color = mix(vec3(0.), vec3(0.1, 0.2, 0.4), uv.y );\n  float fThreshhold = 0.995;\n  float StarVal = noise2d( uv );\n  if ( StarVal >= fThreshhold )\n  {\n    StarVal = pow( (StarVal - fThreshhold) / (1.0 - fThreshhold), 6.0 );\n\n    color += vec3( StarVal );\n  }\n\n  for (int ii = 0; ii < 100; ii++) {\n    float i = float(ii);\n    float t0 = i * 0.1;\n\n    if (iTime > t0) {\n      float t = mod(iTime - t0, 5.5) ;\n      float size = 1. + 3.0 * hash(i * 10.); // sin(1.*t+(hash(i*10.)-0.5)*pi ) ;\n      //size=mix(4.0,0.0,t/5.5);\n      //          size=0.;\n\n      vec2 pos = uv - vec2( 0.5 + 0.25 * (hash(i) - 0.5) * t ,\n                            0.0 + (0.5 + 0.5 * hash(i + 1.) ) * t - .2 * t * t ) ;\n\n      color += mix(vec3(0.05, 0.05, 0.), vec3(.0), drawFlare(pos, 0.05 * size) );\n\n      color = mix( vec3(0.9 + hash(i), 0.9, 0.0), color ,\n                   drawStar(pos, 0.0005 * size, pi * hash(i + 1.) ) );\n\n    }\n  }\n  /*\n  color=mix( vec3(0.9,0.9,0.0),color ,drawStar(uv-vec2(0.2 ,0.7),0.0005 ) );\n  color=mix( vec3(0.9,0.9,0.0),color ,drawStar(uv-vec2(0.3 ,0.65),0.001 ) );\n  color=mix( vec3(0.9,0.7,0.0),color ,drawStar(uv-vec2(0.4 ,0.75),0.0015 ) );\n  color=mix( vec3(0.9,0.7,0.0),color ,drawStar(uv-vec2(0.5 ,0.5),0.001 ) );\n  color=mix( vec3(0.9,0.8,0.0),color ,drawStar(uv-vec2(0.6 ,0.66),0.002 ) );\n  color=mix( vec3(0.9,0.9,0.0),color ,drawStar(uv-vec2(0.7 ,0.55),0.0012 ) );\n  color=mix( vec3(0.9,0.9,0.0),color ,drawStar(uv-vec2(0.8 ,0.65),0.0008 ) );\n  */\n  fragColor = vec4( color, 1.0);\n  //fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 137], [139, 139, 167, 167, 274], [276, 327, 381, 381, 1407], [1409, 1409, 1446, 1446, 1549], [1554, 1554, 1611, 1611, 3219]]}
{"id": "Ms33WN", "name": "Visual illusion 2", "author": "834144373", "description": "Visual illusion\noriginal shader by my [url]http://www.glslsandbox.com/e#29392.0[/url]\n Loot at this for a 30 seconds,and then see other things,you will feel the illusion.:)", "tags": ["2d", "effect", "illusion", "visualillusion"], "likes": 5, "viewed": 667, "published": "Public API", "date": "1449637212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------------------------------------\n//Loot at this for a 30 seconds,and then see other things,you will feel the illusion.:)\n//-------------------------------------------------------------------------------------\n//\n//  Maybe I should call it \"Eye's Effect Shader \"\n//\tbecause you will find your eyes can write shader after you look at this\n\n//uncomment it to see everything small\n#define To_See_Everything_is_Big\n\n//speed\n#define speed 0.25\n\nvoid mainImage(out vec4 o,in vec2 u) {\n\tvec2 uv = ( 2.*u.xy - iResolution.xy)/iResolution.y;\n\t\n\tfloat r; \n\t\n\tfloat rr = length(uv);\n\n    #ifdef To_See_Everything_is_Big\n    \t#define t iTime*speed\n    #else\n    \t#define t -iTime*speed\n    #endif\t\n    r = (length(uv)+t+atan(uv.x,uv.y)*.2);\n\tr = sin(r*80.);\n\t\n\tr = smoothstep(-.4,.4,r);\n\t\t\n\to = vec4( r,r,r, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms33WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 494, 532, 532, 858]]}
{"id": "Ms3GRB", "name": "Tamby's Star Test", "author": "TambakoJaguar", "description": "I don't know if it counts as a small contribution for Christmas, but anyway, this is basic a test to create stars using polar coordinates.", "tags": ["2d", "test", "christmas", "gradient", "stars", "rotating", "polarcoordinates"], "likes": 4, "viewed": 268, "published": "Public", "date": "1450650017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Tamby's Star Test\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define TS(A,F) A*(0.5 + sin(iTime*F))\n#define TC(A,F) A*(0.5 + cos(iTime*F))\n\nconst float pi = 3.14159;\nconst float bs = 0.001;\nconst float bw = 0.006;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    float xr = vect.x*cos(angle) + vect.y*sin(angle);\n    float yr = vect.x*sin(angle) - vect.y*cos(angle);\n    return vec2(xr, yr);\n}\n\nfloat star(vec2 uv, vec2 center, float r1, float sf, float nb, float rs)\n{\n\tuv-= center + vec2(0., 0.5*(0.6 - (iResolution.x-iResolution.y)/iResolution.x)); \n    float alpha1 = mod(atan(uv.x, uv.y) + iTime*rs, 2.*pi/nb);\n    float alpha2 = mod(2.*pi/nb-atan(uv.x, uv.y) - iTime*rs, 2.*pi/nb);\n    float alpha = alpha1<pi/nb?alpha2:alpha1;\n    float f = sf*length(uv)*cos(alpha)/cos(pi/nb) - length(uv)*(sf-1.);\n    float v = smoothstep(r1 - bs, r1 + bs, f) + 0.5 - 0.5*smoothstep(r1 - 2.*bs - bw, r1 + bs - bw, f) + 0.2*pow(smoothstep(r1*0.9, r1*0.2, f), 0.2);\n\n    float f2 = length(uv);\n    float v2 = (1. - smoothstep(r1 - bs, r1 + bs, f2)) ;\n    \n    //return v + v2 -0.5*v3;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy / iResolution.xx;\n    \n    float v = star(uv, vec2(0.53, 0.21), 0.1, 1.2, 6., 1.);\n    v*= star(uv, vec2(0.175, 0.1), 0.03 + TS(0.02, 1.), 1.05, 5., -1.8);\n    v*= star(uv, vec2(0.19, 0.36), 0.05, 2. + TS(1.2, 0.7), 10., 1.7);\n    v*= star(uv, vec2(0.81, 0.05) + vec2(TC(0.03, 2.), TS(0.03, 2.)), 0.05, 5.25, 15., -0.5);\n    v*= star(uv, vec2(0.86, 0.32), 0.05, 1.6, 8., 3.5);\n    \n    fragColor.xyz = mix(pow(vec3(v), vec3(0.1 + TS(0.25, 0.4), 0.7, 4)), vec3(1. - 0.05*uv.y, 0.65+1.4*uv.y, 0.4 + 0.9*uv.y), v);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3GRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 338, 378, 378, 513], [515, 515, 589, 589, 1210], [1212, 1212, 1269, 1269, 1813]]}
{"id": "Ms3GW7", "name": "FullMoon", "author": "kuvkar", "description": "Trying to replicate a image from a book. can look around with mouse a littlebit. ", "tags": ["moon"], "likes": 7, "viewed": 231, "published": "Public", "date": "1450036875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lightDir = normalize(vec3(1.3, 2.1, -.2));\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n//////\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//////\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n/////////\n/////////\n/////////\nfloat map(in vec3 rp)\n{\n    float d = sdBox(rp, vec3(0.65, 0.03, 0.1));\n    d += abs(sin(rp.z)) * 2.;\n    d += abs(sin(rp.x)) * 0.2;\n    vec4 tx = texture(iChannel0, rp.xz * .2, -100.0);\n    d -= smoothstep(0.0, .3, tx.r) * 0.14;\n\n    tx = texture(iChannel0, rp.xy * .11, -100.0);\n    d -= smoothstep(0.0, .1, tx.r) * 0.24;\n\td = max(d, -sdBox(rp + vec3(.0, 0.3, 0.0), vec3(2.2, .25, 2.5)));\n    return d;\n}\n\nfloat mapBroadPhase(in vec3 rp)\n{\n    return sdBox(rp, vec3(1.9, .9, .35) * .5);\n}\n\nvec4 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    p *= 2.0;\n    vec4 c1 = texture(tex, p.xy, -100.0);\n    vec4 c2 = texture(tex, p.yz, -100.0);\n    vec4 c3 = texture(tex, p.xz, -100.0);\n    \n    vec4 color = abs(dot(n, vec3(0.0, 0.0, 1.0))) * c1;\n    color += abs(dot(n, \tvec3(1.0, 0.0, 0.0))) * c2;\n    color += abs(dot(n, \tvec3(0.0, 1.0, 0.0))) * c3;\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat shadow(in vec3 rp)\n{\n    const float dist = 0.1;\n    float d = 1.0;\n    rp += lightDir * dist * 1.5;\n    \n    for (int i = 1; i < 3; ++i)\n    {\n        float m = map(rp);\n        d = min(d, clamp(m / dist, 0.0, 1.0));\n        rp += lightDir * max(m * 2.0, 0.01);\n    }\n    return d;\n}\n\nconst float bumpiness = .08;\nvec3 bump(in vec3 rp, in vec3 g)\n{\n    rp *= .5;\n    vec2 off = vec2(0.00008, 0.0);\n    \n    float xy = tex3D(iChannel1, rp + off.xyy, g).r - tex3D(iChannel1, rp - off.xyy, g).r;\n    float zy = tex3D(iChannel1, rp + off.yyx, g).r - tex3D(iChannel1, rp - off.yyx, g).r;\n    mat3 bmat;\n    bmat[0] = cross(g, vec3(0.0, 1.0, 0.0));\n    bmat[1] = cross(bmat[0], g);\n    bmat[2] = g;\n    \n    vec3 bmg = -cross( normalize(vec3(.0, bumpiness, xy)), normalize(vec3(bumpiness, .0, zy)) );\n    return bmat * bmg;\n}\n\nfloat bumpiness2d = .23;\nfloat WaterSpeed = 0.01;\n\nvec3 bump2d(in vec3 rp)\n{\n    rp.xz += iTime * WaterSpeed;\n    rp *= 1.5;\n    vec2 off = vec2(.0001, 0.0);\n    \n    float xy = texture(iChannel2, rp.xz + off.xy, -100.0).r - texture(iChannel2, rp.xz - off.xy, -100.0).r;\n    float zy = texture(iChannel2, rp.xz + off.yx, -100.0).r - texture(iChannel2, rp.xz - off.yx, -100.0).r;\n    vec3 bmg = -cross( normalize(vec3(bumpiness2d, xy, .0)), normalize(vec3(0., zy, bumpiness2d)) );\n    return bmg;\n}\n\nvec3 grad(in vec3 rp)\n{\n    \n    vec2 off = vec2(0.005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nbool getPointBroadPhase(inout vec3 rp, in vec3 rd)\n{\n    vec3 ro = rp;\n    \n    for (int i = 0; i < 100; ++i)\n    {\n        float dist = mapBroadPhase(rp);\n        if(dist < 0.0)\n        {\n            return true;\n        }\n        rp += rd * max(dist, 0.01);\n        if(length(ro - rp) > 2.0) return false;\n    }\n    return false;\n}\n\nbool getPoint(inout vec3 rp, in vec3 rd, inout vec3 point, inout float closest)\n{\n    vec3 ro = rp;\n    bool hit = false;\n    closest = 99.0;\n    point = ro;\n    int steps = 50;\n    for (int i = 0; i < steps; ++i)\n    {\n        float dist = map(rp);\n        \n        if(dist < closest)\n        {\n            closest = dist;\n            point = rp;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist * 0.1, 0.005);\n        if(length(ro - rp) > 2.) break;\n    }\n    return hit;\n}\n\nvec4 waterColor = vec4(0.1, 0.2, 0.6, 0.0);\n\nvec4 getColor(in vec3 rp, in vec3 rd, float closest)\n{\n\tvec4 color = vec4(.0);\n    vec3 g = grad(rp);\n    vec4 mountainColor = vec4(1.0);\n    mountainColor -= tex3D(iChannel1, rp, g) * 0.5;\n    \n    mountainColor = mix(mountainColor, vec4(0.1, 0.1, 0.0, 0.0), 0.6) * .6;\n\tmountainColor = mix(mountainColor, vec4(.15, 0., 0., 0.0), smoothstep(-0.1, 0.01, rp.y));\n    mountainColor = mix(mountainColor, vec4(.5), smoothstep(.08, .5 + abs(sin(rp.x * 15.0)) * 0.06, rp.y));\n    mountainColor = mix(mountainColor, waterColor, 0.2);\n    \n    vec3 bgrad = bump(rp, g);\n    float d = dot(bgrad, lightDir);\n    d = clamp(d, 0.0, 1.0);\n    mountainColor = mix(mountainColor, mountainColor * d, 1.);\n\t\n    \n    vec3 H = normalize(lightDir -rd);\n    float bm = dot(H, bgrad);\n    bm = clamp(bm, 0.0, 1.0);\n    bm = pow(bm, 5.0) * .2;\n    mountainColor += bm;\n    \n    mountainColor *= shadow(rp);\n    \n    float reflCol = smoothstep(0., 1., texture(iChannel2, rp.xz * .5 + vec2(iTime * WaterSpeed), -100.0).r);\n    mountainColor += clamp(dot(vec3(0., -1.0, -.4), g), 0.1, 1.0) * waterColor * reflCol * 0.4;\n    \n    color = mix(color, mountainColor, smoothstep(0.001, 0.0, closest));    \n    \n    \n\treturn color;\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    float closest = 0.0;\n    vec3 point = vec3(0.0);\n    vec3 ro = rp;\n    \n    getPointBroadPhase(rp, rd);\n    //bool hit = false;\n    bool hit = getPoint(rp, rd, point, closest);\n    float colorAmount = 1.0;\n    \n    if(rp.y <= 0. && closest > 0.001)\n    {\n        rp = ro + (rd / dot(vec3(0.0, -1.0, 0.0), rd)) * ro.y;\n        color = mix(vec4(.0, 0.0, .3, 0.0), waterColor, smoothstep(0.0, .1, -rd.y));\n\t\t\n        \n        vec3 bm = bump2d(rp);\n        float bd = clamp(dot(lightDir, bm), 0.0, 1.0);\n        vec3 _rd = reflect(rd, bm);\n        \n        vec3 H = normalize(vec3(-0.4, .3, 1.0) - rd);\n        float sd = dot(H, bm);\n        sd = clamp(sd, 0.0, 1.0) * .95;\n        \n        float far = length(ro - rp);\n        color += mix(.0, pow(sd, 14.0), 1.) *  smoothstep(1.5, 0., far);;\n        \n        getPointBroadPhase(rp, _rd);\n        bool hit = getPoint(rp, _rd, point, closest);\n        rp = point;\n        colorAmount = .7;\n    }\n    else if(hit)\n    {\n        color = vec4(.0);\n\t    rp = point;\n    }else\n    {\n        color = mix(vec4(.0, 0.0, .3, 0.0), vec4(0.0), smoothstep(0.0, .4, rd.y));\n        vec3 moon = normalize(vec3(-.5, 0.25, 1.));\n        float md = clamp(dot(rd, moon), -0., 1.0);\n        md = pow(md, 120.0);\n        md = smoothstep(0.08, 0.1, md);\n        md *= mix(texture(iChannel0, rd.xy * 0.1, -100.0).r, 1.0, 0.6);\n        color += md * vec4(1., 1., 1., 0.0) * 1.1;\n        return;\n    }\n    \n    color += getColor(rp, rd, closest) * colorAmount;\n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    \n    mat3 m;\n    m[0] = r;\n    m[1] = u;\n    m[2] = f;\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n\n    \n    fragColor = vec4(0.0, 0.0, 0.2, 0.0);\n    vec3 rd = normalize(vec3(uv, .7));\n    vec3 rp = vec3(0.5 + cos(iTime * 0.2), .017, -2. + sin(iTime * .2) * 1.);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= vec2(0.5);\n    \n    if(iMouse.z > 0.0)\n    {\n        rp = roty(m.x * 5.0) * rp;\n    }\n    \n    rd = lookat(rp, vec3(0.0, 0.2 + sin(iTime) * 0.05, 0.0)) * rd;\n    trace(rp, rd, fragColor);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3GW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 68, 68, 195], [196, 196, 216, 216, 343], [344, 344, 364, 364, 491], [493, 577, 608, 608, 704], [706, 736, 759, 759, 1142], [1144, 1144, 1177, 1177, 1226], [1228, 1228, 1279, 1279, 1623], [1625, 1625, 1651, 1651, 1915], [1946, 1946, 1980, 1980, 2451], [2504, 2504, 2529, 2529, 2950], [2952, 2952, 2975, 2975, 3212], [3214, 3214, 3266, 3266, 3547], [3549, 3549, 3630, 3630, 4108], [4155, 4155, 4209, 4209, 5357], [5359, 5359, 5413, 5413, 6902], [6904, 6904, 6937, 6937, 7184], [7187, 7187, 7244, 7244, 7765]]}
{"id": "Ms3GzS", "name": "dot to grid", "author": "masaki", "description": "dot to grid", "tags": ["dot"], "likes": 14, "viewed": 643, "published": "Public API", "date": "1450371657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define STROKE 0.3\n#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 12.0* ((fragCoord.xy / iResolution.xy)-0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float freq1 =  0.5 * sin(t + uv.x*.125 + uv.y * .2) + 0.5;\n    float circle = smoothstep(freq1-STROKE, freq1, cos(uv.x * 2.0 *PI) *  cos(uv.y * 2.0 *PI))-\n        smoothstep(freq1,freq1+STROKE, cos(uv.x * 2.0 *PI) *  cos(uv.y * 2.0 *PI));  \n\tfragColor = vec4(circle*0.2, circle*0.3, circle,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3GzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 514]]}
{"id": "Msc3zf", "name": "Glowing Spheres", "author": "Xor", "description": "Simple 3D spheres test", "tags": ["3d", "glow", "xor"], "likes": 15, "viewed": 540, "published": "Public", "date": "1451322156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INTENSITY 1.0 //Between 0 and 1\nfloat sphere(vec3 d,vec3 p)\n{\n \treturn smoothstep(1.0-INTENSITY,1.0,1.0/length(cross(d,p)));   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy-0.5)*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 P = vec3(cos(iTime),sin(iTime),0.0)*8.0;\n    vec3 X = normalize(-P);\n    vec3 Y = normalize(cross(X,vec3(0.0,0.0,1.0)));\n    vec3 Z = normalize(cross(X,Y));\n    \n    vec3 R = normalize(mat3(X,Y,Z)*vec3(1.0,uv));\n    \n    vec3 S1 = vec3(cos(iTime*0.5),sin(iTime*0.5),0.0)*2.0;\n    vec3 S2 = vec3(0.0,cos(iTime*0.5),sin(iTime*0.5))*2.0;\n    vec3 S3 = vec3(sin(iTime*0.5),0.0,cos(iTime*0.5))*2.0;\n    \n\tfragColor = vec4(sphere(R,S1-P),\n                     sphere(R,S2-P),\n                     sphere(R,S3-P),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 69, 69, 137], [138, 138, 195, 195, 804]]}
{"id": "MscGRf", "name": "A moving Sin Line", "author": "xdlmost", "description": "A moving Sin Line", "tags": ["movingline"], "likes": 2, "viewed": 113, "published": "Public", "date": "1451289201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float r=0.05;\n    float t=abs(uv.y-0.5-0.2*sin((uv.x)*30.0+10.0*sin(iTime)));\n    \n    if(t<r){\n        fragColor=vec4(vec3(0.5+0.5*sin(iTime),0.5+0.5*sin(iTime*2.),0.5+0.5*sin(iTime*3.))*(r-t)/r,1);\n    }else{\n        fragColor=vec4(0,0,0,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 355]]}
{"id": "MscGRM", "name": "water simulation", "author": "qq456cvb", "description": "just a simulation of water, to be continued...", "tags": ["water"], "likes": 20, "viewed": 472, "published": "Public", "date": "1449793976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 lightDir = normalize(vec3(0, -0.3, -1));\nconst vec3 lightPos = vec3(0, 2, 4);\nconst float lightPow = 0.5;\n\nconst float ambientLightPow = 0.3;\nconst vec3 planePos = vec3(0, -1, 0);\nconst vec3 planeNormal = vec3(0, 1, 0);\n\nconst vec3 waterPos = vec3(0, 0, 0);\nconst vec3 waterNormal = vec3(0, 1, 0);\nconst float waterDirtiness = 0.4;\n\nconst vec3 white = vec3(1, 1, 1);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 skyColor = vec3(0.7, 1.0, 1.0);\nconst vec3 waterColor = vec3(176.0/255.0, 224.0/255.0, 230.0/255.0);\n\nconst int NUM_STEPS = 5;\nconst float EPSILON = 0.0001;\n\nconst vec3 refractLightDir = refract(lightDir, waterNormal, 1.0/1.5);\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    return pow(max(dot(reflect(e,n),-l),0.0),s);\n}\n\nfloat map(vec3 p)\n{\n    return p.y - 0.3*noise(p.xz+vec2(iTime));\n}\n\nfloat getHeight(vec3 ori, vec3 dir, out vec3 p)\n{\n\tfloat tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = vec3(0, 0, 0);\n        return 0.0;   \n    }\n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getNormal(vec3 p, float eps)\n{\n\tvec3 normal;\n    normal.y = map(p);\n    normal.x = map(vec3(p.x+eps, p.y, p.z)) - normal.y;\n    normal.z = map(vec3(p.x, p.y, p.z+eps)) - normal.y;\n    normal.y = eps;\n    return normalize(normal);\n}\n\nbool intersectPlane(out vec3 color, vec3 ori, vec3 dir)\n{\n\tfloat a = dot(dir, planeNormal);\n    if (a > 0.0) {\n        color = white;\n        return false;\n    } else {\n        float dToPlane = dot(ori-planePos, planeNormal);\n        vec3 intersectPt = ori+dir*abs(dToPlane/a);\n        if (fract((floor(intersectPt.x)+floor(intersectPt.z))/2.0) == 0.5)\n        {\n            color = black;\n            color += vec3(specular(planeNormal, refractLightDir, dir, 60.0));\n            color += ambientLightPow*white;\n            color = mix(color, waterColor, waterDirtiness);\n        } else {\n        \tcolor = black;    \n        }\n        return true;\n    }\n}\n\nbool intersectWater(out vec3 color, vec3 ori, vec3 dir)\n{\n\tfloat a = dot(dir, waterNormal);\n    if (a > 0.0) {\n        color = white;\n        return false;\n    } else {\n        \n                                   \n                                   \n        vec3 intersectPt, intersectNormal;\n        getHeight(ori, dir, intersectPt);\n        vec3 dist = intersectPt-ori;\n        intersectNormal = getNormal(intersectPt, dot(dist, dist)*EPSILON);\n        \n        vec3 refractColor, reflectColor;\n        \n        //plane\n        vec3 refractDir = refract(dir, intersectNormal, 1.0/1.5);\n        intersectPlane(refractColor, intersectPt, refractDir);\n        \n        // reflect\n        reflectColor = 80.0* vec3(specular(intersectNormal, lightDir, dir, 100.0));\n        \n        // fresnel\n        float r0 = pow((1.0-1.5)/(1.0+1.5), 2.0);\n        float fresnel = r0+(1.0-r0)*(pow(1.0-abs(dot(dir, intersectNormal)), 5.0));\n                                      \n        color = refractColor*(1.0-fresnel) + reflectColor*fresnel;\n        return true; \n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    vec3 ori = vec3(0, 2, 0);\n    vec3 dir = normalize(vec3(uv, 1.0));\n                         \n    vec3 color;\n    intersectWater(color, ori, dir)  ;             \n\tfragColor = vec4(mix(skyColor, color, \n                    smoothstep(0.0, -0.1, dir.y)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[652, 652, 674, 674, 754], [755, 755, 781, 781, 1082], [1085, 1085, 1131, 1131, 1186], [1188, 1188, 1207, 1207, 1255], [1257, 1257, 1306, 1306, 1857], [1859, 1859, 1894, 1894, 2095], [2097, 2097, 2154, 2154, 2752], [2754, 2754, 2811, 2811, 3814], [3818, 3818, 3875, 3875, 4204]]}
{"id": "MscGW4", "name": "Matrix89", "author": "trashrabbit", "description": ".", "tags": ["matrix"], "likes": 12, "viewed": 717, "published": "Public", "date": "1449600274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inputs:\n//  iChannel0: webcam image\n//  iChannel1: matrix characters image.\n//             should be a small b&w image with a single row of pixelated matrix-font characters.\n//             for example, a 64 x 16 image with a row of 8 x 16 pixel characters.\n\n\n#define N_CHARS 2.0    // how many characters are in the character image\n#define Y_PIXELS 24.0  // reduce input image to this many mega-pixels from top to bottom\n#define DROP_SPEED 0.5 // how fast the drips fall\n#define ASPECT 2.7     // aspect ratio of input webcam image relative to matrix characters\n#define MIN_DROP_SPEED 0.2    // range 0-1. is added to column speeds to avoid stopped columns.\n#define STATIC_STRENGTH 0.1   // range 0-1. how intense is the tv static\n#define SCANLINE_STRENGTH 0.4 // range 0-1. how dark are the tv scanlines\n#define NUM_SCANLINES 70.0    // how many scanlines in entire image\n#define GRADIENT_BLACK 0.2    // range 0-1. how dark do the darkest parts of the drip-gradients\n#define MATRIX_OPACITY 0.8    // range 0-1. matrix effect has this much solidity over original image\n\n// random functions adapted from https://www.shadertoy.com/view/lsXSDn                  \nfloat rand2d(vec2 v){\n    return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float x) {\n    return fract(sin(x) * 3928.2413);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // pixelate webcam image into mega-pixels\n    float xPix = floor(uv.x * Y_PIXELS * ASPECT) / Y_PIXELS / ASPECT;\n    float yPix = floor(uv.y * Y_PIXELS) / Y_PIXELS;\n    vec2 uvPix = vec2(xPix, yPix);\n    // ideally we should blur the input image to reduce flickering\n    vec4 pixelColor = texture(iChannel0, uvPix);\n\n    // compute uv within each mega-pixel\n    vec2 uvInPix = vec2(\n    \tmod(uv.x * Y_PIXELS * ASPECT, 1.0),\n    \tmod(uv.y * Y_PIXELS, 1.0)\n    );\n\n    // offset char image to appropriate char\n    float charOffset = floor(pixelColor.r * N_CHARS * 0.999) / N_CHARS;\n    uvInPix.x = uvInPix.x / N_CHARS + charOffset;\n    vec4 charColor = texture(iChannel1, uvInPix);\n    \n    // falling drip highlight\n    float highlightClock = -2.0 + yPix + iTime*DROP_SPEED + rand(xPix);\n    float highlight = mod(1.0 - max(0.0, highlightClock), 1.0);\n    highlight = mix(highlight, 1.0, GRADIENT_BLACK);\n    charColor *= highlight * 1.5;\n    \n\t// mixer controls where the original image is visible\n    // before the drips cover it\n    float mixer = clamp(highlightClock * 100.0, 0.0, 1.0);\n    \n    // multiply char images and webcam mega-pixels\n    float result = charColor.r * pixelColor.r;\n\n    // add scanlines\n    result *= 1.0 - SCANLINE_STRENGTH * (sin(uv.y * NUM_SCANLINES*3.14159*2.0)/2.0+0.5);\n    \n\t// map to a black->green->white gradient\n    vec4 greenResult = vec4(\n        max(0.0, result*3.0 - 1.2),\n        result*1.6,\n        max(0.0, result*3.0 - 1.5),\n        1.0\n    );\n        \n    // add tv static\n    float stat = rand2d(uv * vec2(0.0005, 1.0) + iTime * 0.1) * STATIC_STRENGTH;\n    greenResult += stat;\n    greenResult = mix(pixelColor, greenResult, MATRIX_OPACITY);\n    \n    // mix original image behind drips\n    vec4 origImage = texture(iChannel0, uv);\n    fragColor = mix(origImage, greenResult, mixer);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1074, 1163, 1184, 1184, 1255], [1257, 1257, 1278, 1278, 1318], [1320, 1320, 1375, 1375, 3259]]}
{"id": "MscGW7", "name": "Trigo 101", "author": "Senryoku", "description": "sinewave", "tags": ["sinewave"], "likes": 5, "viewed": 187, "published": "Public", "date": "1450012866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n// Starts the plot on a fixed absciss, comment to switch to start it on the circle. \n#define CurveFixedStart\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    uv.y -= 0.25;\n    uv *= 10.0;\n    \n    vec2 center = vec2(1.5, 0.0);\n    float circle = abs(distance(uv, center) - 1.0);\n    \n    float dot = abs(distance(uv - center, vec2(cos(iTime), sin(iTime))));\n    \n    float dot2 = abs(distance(uv - vec2(0.25, 0.0), vec2(0.0, sin(iTime))));\n    \n    float wave = 1.0;\n#ifdef CurveFixedStart\n    float wavestart = 3.0;\t\t\t\t\t\t// Start the curve on a fixed x\n#else\n    float wavestart = cos(iTime) + center.x;\t// Start the curve on the dot\n#endif\n    \n    if(uv.x > wavestart)\n    {\n        //if(mod((uv.x - iTime - wavestart), 0.2) < 0.15) // Dashed sin\n        {\n            uv.x -= iTime + wavestart + PI;\n            wave = abs(sin(uv.x) - uv.y);\n        }\n    }\n    \n    fragColor = vec4((wave < 0.05 ? (0.05 - wave) * 10.0 : 0.0) + \n        \t(circle < 0.05 ? (0.05 - circle) * 10.0 : 0.0) + \n        \t(dot < 0.1 ? (0.1 - dot) * 10.0 : 0.0));\n        \t//(dot2 < 0.1 ? (0.1 - dot2) * 10.0 : 0.0);\t// Tracks the value of sin(t)\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 130, 187, 187, 1246]]}
{"id": "MscGWN", "name": "Space Puppy Zebra", "author": "reza", "description": "Not sure what to call this. Its just me playing with Ray Marching a sphere, but doing it wrong and making beautiful things from mistakes. Enjoy! Code stolen from IQ. Thanks man! ", "tags": ["sdf", "glitch", "bw", "stripes", "reza"], "likes": 26, "viewed": 1471, "published": "Public API", "date": "1449628194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is me stealing many many many things from IQ, THANK YOU IQ, YOU ARE THE BEST!!!\n// Really this is just a glitchy bastardization of ray marching a space puppy sphere\n// Then I put some strips on it, because why not right?\n\n#define TWO_PI 6.2831853072\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\n\t\tfloat modValue = snoise( vec4( 1.0 * normalize( p ), 0.2 * iTime ) );\n    return length( p ) - ( s + 0.5 * modValue );\n\t\t// return length( p ) - s;\n}\n\nvec2 map( in vec3 pos )\n{\n    return vec2( sdSphere( pos, 1.0 ), 2.0 );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n\t\tfloat precis = 0.001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<1; i++ )\n    {\n\t    \tvec2 res = map( ro + rd*t );\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n\t    \tm = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.25, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3( 0.0, 0.0, 0.0 );\n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n\t\tfloat m = res.y;\n    if( m > -1.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = abs( calcNormal( pos ) );\n        col = vec3( 1.0 );\n        float rim = dot( vec3( 0.0, 0.0, 1.0 ), nor );;\n        float value = cos( rim * TWO_PI * 20.0 );\n//        col *= value > 0.7 ? 1.0 : 0.0;\n        col *= smoothstep(.5,.8, value );\t// thank you @iapafoto!\n    }\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\t// camera\n\tvec3 ro = vec3( 0.0, 0.0, -3.5 );\n\t// camera-to-world transformation\n\n    // ray direction\n\tvec3 rd = normalize( vec3( p.xy, 2.0 ) );\n    // render\n    vec3 col = render( ro, rd );\n\tcol = pow( col, vec3( 0.4545 ) );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 708, 729, 729, 778], [780, 780, 803, 803, 852], [854, 854, 876, 876, 916], [918, 918, 942, 942, 982], [984, 984, 1012, 1012, 1064], [1066, 1066, 1096, 1096, 1148], [1150, 1150, 1182, 1182, 1445], [1453, 1527, 1551, 1551, 4026], [4028, 4028, 4063, 4063, 4216], [4218, 4218, 4243, 4243, 4291], [4293, 4293, 4333, 4333, 4657], [4659, 4659, 4691, 4691, 4911], [4913, 4913, 4952, 4952, 5426], [5428, 5428, 5480, 5480, 5657], [5659, 5659, 5716, 5716, 6108]]}
{"id": "MscGz2", "name": "Peacock Feather", "author": "BigWIngs", "description": "My gf challenged me to make a peacock feather. Here is the result. I really wanna get rid of the aliasing at the bottom but its late :) You can change the number of strands with the define on 4. Watch fullscreen for less aliasing", "tags": ["2d", "feather"], "likes": 18, "viewed": 554, "published": "Public", "date": "1450859090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Peacock Feather\" by Martijn Steinrucken aka BigWings - 2015\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define NUMSTRANDS 150.\n#define PI 3.1415\n#define MOD3 vec3(.1031,.11369,.13787)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    // From Dave Hoskins\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat point(vec2 uv, vec2 p, float intensity) {\n\tuv -=p;\n    return intensity/dot(uv,uv);\n    //return distance(uv, p)*intensity;\n}\n\nfloat bandstep(float v, float c, float w) {\n\tfloat e1 = c-w;\n    float e2 = c+w;\n    float e = fwidth(v);\n    \n    float o = smoothstep(e1, e1+e, v); \n    o *= smoothstep(e2+e, e2, v);\n    \n    return o;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ) {\n    // From IQ\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return d;\n}\n\nfloat circ(vec2 uv, vec2 p, float sag) {\n\tuv -= p;\n    uv.x *= 1.+uv.y*sag;\n    return length(uv);\n}\n\nfloat circmask(vec2 uv, vec2 p, float sag, float start, float finish) {\n\tfloat c = circ(uv, p, sag);\n    \n    return smoothstep(start, finish, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t= iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x-=.5;\n    uv.x *= 16./9.;\n    \n    uv*=3.;\n    \n    float wiggle = sin(uv.y+t)*.1; \n    uv.x += wiggle;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 up = vec2(1., 0.);\n    vec2 p =  vec2(0., .0);\n    \n    vec2 v = p-uv;\n    float len = length(v);\n    float x = uv.y;\n    x = x*(x-1.);\n    float topStraight = 1.-smoothstep(1.75, 3., uv.y);\n    float bend = 1.- x*(1.-len*.5)*topStraight;\n    \n    v /= pow(len,bend);\n    \n    //v.y+=l;\n    \n    float c = abs(dot(up, v));\n    \n    float id = c*PI*NUMSTRANDS;\n    float featherLines = cos(id);\n    \n    //spalmer suggestion for anti aliasing\n    featherLines = mix(featherLines, .75, min(1., .44*fwidth(id)));\n    \n    id = floor(id/PI - PI*.5);\n    float sN = hash11(id*sign(uv.x));\n    \n    float outline1 = smoothstep(1., .95, c);\n    \n    c= featherLines*outline1;\n    \n    float outline2 = circ(uv, vec2(0., 1.4), 0.5)*.7;\n   \n    c *= smoothstep(1.5, 0.5, outline2);\n    float core = circ(uv, vec2(0., .95), 0.1)*.7;\n    core = smoothstep(.9, 0.3, core)*outline1*.9;\n    c = max(c, core);\n    \n    vec3 baseCol = vec3(.118, 1., .051);\n    vec3 eyeCol = vec3(.024, .118, .878);\n    vec3 eyeLightCol = vec3(.0, .89, .95);\n    vec3 brownCol = vec3(.965, .459, .384);\n    vec3 pupilCol = vec3(.1, .1, .12);\n    \n    vec3 col = baseCol;\n    float brownMask =  circmask(uv, vec2(0., 1.2+sN*.05*uv.y), 0.4, .95, .85);\n    col = mix(col, brownCol, clamp(0., 1., brownMask));\n    \n    float eyeMask = circmask(uv, vec2(0., 1.1+sN*.02), 0.4, .7, .65);\n    float eyeMask2 =  circmask(uv, vec2(0., .4+sN*.03), -0.1, 1., .98);\n    eyeMask *= eyeMask2;\n    col = mix(col, eyeLightCol, eyeMask);\n    \n    eyeMask = circmask(uv, vec2(0., 1.1+sN*.02), 0.4, .69, .6);\n    eyeMask2 = circmask(uv, vec2(0., .48+sN*.03), -0.1, .9, .88);\n    eyeMask *= eyeMask2;\n    col = mix(col, eyeCol, eyeMask);\n    \n    float cutMask = circ(uv*vec2(.75, 1.), vec2(0., .6), -0.6);\n    cutMask += line(uv, vec2(0., 3.), vec2(0., .0));\n    cutMask = smoothstep(.35, .25, cutMask);\n    \n    float pupilMask = circmask(uv, vec2(0., 1.1+sN*.05), 0.4, .5, .45);\n    pupilMask *= circmask(uv, vec2(0., .55+sN*.03), -0.1, .8, .78);\n    pupilMask *= 1.-cutMask;\n    col = mix(col, pupilCol, clamp(pupilMask, 0., 1.));\n    \n    float strandFade = circmask(uv, vec2(0.), 0., 0., 1.5);\n    col *= mix(1., sN+.25*strandFade, strandFade);\n    \n    col += clamp(sin(max(0.8, outline2+(sN+wiggle*10.)*.1)*15.), 0., 1.)*sN*strandFade;\t// highlights\n    \n    vec4 fg = vec4(col*c, c);\n    \n    float bgFade = uv.y/3.;\n    \n    vec4 bg = mix(vec4(eyeCol*.5, 0.), vec4(0.), 1.-bgFade);\n    fragColor = mix(bg, fg, fg.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[288, 398, 421, 446, 558], [560, 560, 607, 607, 691], [693, 693, 736, 736, 898], [900, 900, 947, 962, 1116], [1118, 1118, 1158, 1158, 1218], [1220, 1220, 1291, 1291, 1368], [1370, 1370, 1427, 1427, 4136]]}
{"id": "MscGzj", "name": "green void", "author": "bostelk", "description": "descend into the void.", "tags": ["sphere", "vr"], "likes": 6, "viewed": 253, "published": "Public", "date": "1450799705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// various functions from:\n// http://mercury.sexy/hg_sdf/\n// https://www.shadertoy.com/view/Xds3zN\n\n#define PI 3.14159265\n\nfloat fScene(in vec3 p);\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy) - fScene(pos-eps.xyy),\n\t    fScene(pos+eps.yxy) - fScene(pos-eps.yxy),\n\t    fScene(pos+eps.yyx) - fScene(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nmat3 persp(in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nfloat clamp01(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat fSphere(in vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat fScene(in vec3 p)\n{\n    p.z += iTime;\n    pMod3(p, vec3(3.0));\n    return fSphere(p, 0.5);\n}\n\nvec4 render(in vec3 ro, in vec3 rd)\n{\n    const float tMax = 100.0;\n    const float epsilon = 0.001;\n    \n    float t = 1.0;\n    \n    const vec3 bg = vec3(0);\n    vec3 col = bg;\n    \n    vec3 lightP = ro;\n    \n    for(int n = 0;n < 100; ++n)\n    {\n        vec3 p = ro + rd * t;\n        \n    \tfloat d = fScene(p);\n        \n        if (d > tMax) break;\n        if (d < epsilon)\n        {\n            vec3 light = normalize(lightP - p);\n            vec3 normal = calcNormal(p);\n            \n            // intensity of diffuse light\n            float diff = clamp01(dot(light, normal));\n            \n            // intensity of specular - phong\n            float shininess = 72.0;\n            vec3 reflection = reflect(light, normal);\n            float spec = pow(max(dot(rd, reflection), 0.0), shininess);\n             \n            float lightPower = 1.0 / (0.5 + length(lightP - p)*0.125);\n            \n            col = vec3(0,.1,0);\n            col += diff * vec3(0,0.8,0.0) * lightPower + spec * vec3(1,1,1) * lightPower;\n            break;\n        }\n\n        t += d;\n    }\n    \n    float fogStart = 10.0;\n    float fogDistance = length(rd * (fogStart - max(fogStart, t)));\n    float fogDensity = 0.18;\n    float fogAmount = 1.0 - exp( -fogDistance*fogDensity );\n    vec3  fogColor = vec3(0.);\n    col = mix( col, fogColor, fogAmount );\n    \n    col = pow(col, vec3(0.4545));\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(0.0,1.0,0.0);\n    \n    // mouse look\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 look = 100.0*normalize(vec3(sin(-m.x*PI), 0.7*m.y, cos(-m.x*PI)));\n    \n    mat3 ca = persp(ro,look,0.0);\n        \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.0) );\n\n\tfragColor = render(ro, rd);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 149, 181, 181, 408], [410, 410, 457, 457, 634], [637, 637, 665, 665, 702], [704, 704, 744, 744, 777], [779, 809, 846, 846, 938], [940, 940, 965, 965, 1038], [1040, 1040, 1077, 1077, 2446], [2448, 2448, 2505, 2505, 2942]]}
{"id": "Msd3DH", "name": "Binary system", "author": "Duke", "description": "Based on [url=https://www.shadertoy.com/view/ltjSWV]Binary star[/url] shader\nBlackhole based on this [url=http://glslsandbox.com/e#21204.0]Glslsandbox[/url] shader\nPress 1-2-3 to zoom in and zoom out.", "tags": ["binary", "sun", "star", "jet", "blackhole", "gargantua"], "likes": 30, "viewed": 1950, "published": "Public API", "date": "1449507791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Binary system\" by Duke\n// Based on \"Binary star\" https://www.shadertoy.com/view/ltjSWV shader \n// Blackhole based on this http://glslsandbox.com/e#21204.0 shader\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define DITHERING\n#define KEYBOARDZOOM\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float spin_speed=0.7;\n\nmat2 Spin(float angle){\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n// mass (and radius of the event horizon as well)\nconst float mass = .15;\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//-------------------------Noise--------------------------\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//-------------------------Disk---------------------------\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//-------------------------Star---------------------------\n// Noise Settings\n#define NoiseSteps 4\n#define NoiseAmplitude 0.08\n#define NoiseFrequency 48.0\n  \nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n    float value = 0.0;\n    float cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n    float fade;\n    float fOut = minFreq;\n    for(int i=NoiseSteps ; i>=0 ; i--)\n    {\n      if(fOut >= 0.5 * cutoff) break;\n      fOut *= 2.0;\n      value += abs(pn(position * fOut))/fOut;\n    }\n    fade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n    value += fade * abs(pn(position * fOut))/fOut;\n    return 1.0-value;\n}\n\nfloat SphereDist(vec3 position, vec3 rposition, float radius)\n{\n    return length(position - rposition) - radius;\n}\n\nfloat Star(vec3 position, vec3 rotdir, vec3 rposition, float radius)\n{\n    float distance;\n    float t=spin_speed*iTime;\n    float noise = Turbulence(vec3(Spin(t*0.25+rotdir.y*.81)*rotdir.zx*50.,rotdir.y*50.+t), 0.1, 1.5, 0.03) * NoiseAmplitude;\n    noise = clamp((abs(noise)),0.0,1.0);\n    distance = SphereDist(position, rposition, radius) - noise;\n    return distance;\n}\n\n//-------------------------Vortex-------------------------\nfloat ridged(float f){\n\treturn 1.0-2.0*abs(f);\n}\n\nfloat Vortex(vec3 q, vec3 rposition, float h, float invjet) // the isosurface shape function, the surface is at o(q)=0\n{\n    q += rposition;\n\tfloat t=spin_speed*iTime;\n\tif(q.y<0.0) return length(q.xyz*vec3(1.0,invjet,1.0))-5.75;\n    vec3 spin_pos=vec3(Spin(t-sqrt(q.y))*q.xz,q.y-t*5.0);\n\tfloat zcurve=pow(q.y,1.5)*0.03;\n\tfloat v=abs(length(q.xz)-zcurve)-5.5-clamp(zcurve*0.2,0.1,1.0)*pn(spin_pos*vec3(0.1,0.1,0.1))*5.0;\n\treturn max(v, q.y - h);\n}\n\n//-------------------------Map----------------------------\nvec2 map(vec3 p) {\n    \n    float t=spin_speed*iTime;\n\n    // system rotation\n    R(p.xy, pi*iTime*0.02);\n   \n    float StarD = Star(p,p,vec3(-1.0,6.5,0.0),2.5);\n    float VortexD = Vortex(p/0.02, vec3(45.0,-100.0,0.0), 80.0, 1.0)*0.02;\n    //---------------------------    \n    float Radius = 0.98;\n    //float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.125+p.z*.80)*p.xy*80.,p.z*40.-t)*6.0) * length(p) * 0.34; //old variant\n    float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * length(p) * 0.34;\n    float r = (sqrt(dot(p,p))/sqrt(2.0))*0.6;\n\tfloat a = atan(p.y, p.x);\n\tfloat dOffset = cos( (a+r*r*20.0)*2.-iTime*2.5) * .5 + .5;\n\tdOffset *= 1.0-r/Radius;\n\tDiskD += dOffset * .2;\n    //---------------------------\n    //float d4 = Star(p,p.yzx,vec3(0.0,0.0,0.0),0.05)*.8;\n    //---------------------------\n    vec3 q = p;\n    R(q.yz, -0.25*pi*2.);\n    float Jet1D = Vortex(q/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;\n    //---------------------------\n    q = p;\n    R(q.yz, 0.25*pi*2.);\n    float Jet2D = Vortex(q/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;\n    //---------------------------\n    vec2 result = vec2(smin(smin(VortexD,DiskD/*smin(DiskD,d4,0.1)*/,1.0),StarD,1.5), 1.0);\n    \n    result = vec2(min(min(Jet1D,Jet2D),result.x), step(min(Jet1D,Jet2D),result.x));\n    \n    return result;\n}\n\n//-------------------------Color palette------------------\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1550. + 1400.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n//-------------------------Main---------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // rd: direction of the ray\n    vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\n    #ifdef KEYBOARDZOOM\n    // keyboard control zoom\n    // Press 1-2-3 to zoom in and zoom out.\n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\tvec3 ro = vec3(0., 0., -11.+key*3.8);\n\n    R(rd.zy, -pi*3.35);\n    R(ro.zy, -pi*3.35);\n    \n    R(rd.yx, iMouse.x*0.008*pi);\n   \tR(ro.yx, iMouse.x*0.008*pi);  \n    #else\n    // mouse control zoom \n    vec3 ro = vec3(0., 0., -11.0 + iMouse.y * 0.022);\n    R(rd.yz, -0.0*0.01*pi*2.);\n\tR(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -0.0*0.01*pi*2.);\n\tR(ro.xz, iMouse.x*0.01*pi*2.);\n    #endif\n    \n    // ld, td: local, total density \n    // w: weighting factor\n    float ld=0., td=0., w;\n\n    // t: length of the ray\n    // d: distance function\n    float d=1., t=0.;\n   \n    // Distance threshold.\n    const float h = .1;\n   \n    // total color\n    vec3 tc = vec3(0.);\n   \n    #ifdef DITHERING\n    vec2 pos = ( fragCoord.xy / iResolution.xy );\n    vec2 seed = pos + fract(iTime);\n    t=(.4+0.2*rand(seed*vec2(1)));\n    #endif\n\n    // p: position on the ray\n    vec3 p = ro+t*rd;\n    \n    vec2 sc = vec2(0.0);\n    // rm loop\n    for (int i=0; i<48; i++) {\n\n      // Loop break conditions. \n      if(td>(1.0-1./200.) || d<0.001*t || t>22. ||  dot(p,p) > 125. || dot(p,p) < mass*mass) break;\n\n      // evaluate distance function\n      sc = map(p);\n      d = sc.x;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      // const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n\t       \n      // accumulate color and density\n      tc.x += (w*w + 1./50.) * sc.y * step(d, 0.55) * 3.0; // Jets color\n      tc.y += (w*w + 1./50.) * step(sc.y, h) * step(d, 1.95); // Star and disk color\n        \n      td += w +1./200.;\n\n\t  #ifdef DITHERING \n      d=abs(d)*(0.4+0.2*rand(seed*vec2(i)));\n      #endif         \n         \n      d = min(d, (length(p)-mass)*.5);\n        \n      // enforce minimum stepsize\n      d = max(d, 0.04); \n      \n      p += d*rd;\n\n      // step forward\n      t +=  max(d * 0.5, 0.02);\n        \n      // Approximated event horizon.\n\t  vec3 fieldDeriv = p * mass / pow(length(p),3.) / (2.*(1. - mass/length(p)));\n\t  rd = normalize(rd-d*fieldDeriv);\n\n    }\n    \n\t// Coloring\n\ttc = mix(firePalette(tc.y),vec3(0.0,0.0,tc.x),0.4)*2.0;\n\t    \n    // stars background\n    if (td>0.6) {fragColor = vec4(tc, 1.0); return;}\n    vec3 stars = vec3(pn(rd*500.0)*0.5+0.5);\n    vec3 col = vec3(0.0);\n    col = mix(col, vec3(0.8,0.9,1.0), smoothstep(0.95, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n    col = clamp(col, 0.0, 1.0);\n    tc += col; \n    \n    fragColor = vec4(tc, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3DH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 378, 401, 401, 463], [465, 540, 581, 581, 670], [672, 745, 768, 768, 981], [983, 990, 1009, 1009, 1073], [1075, 1075, 1095, 1166, 1237], [1239, 1299, 1324, 1324, 1361], [1363, 1363, 1388, 1388, 1453], [1455, 1455, 1485, 1485, 1581], [1583, 1740, 1817, 1817, 2219], [2221, 2221, 2284, 2284, 2336], [2338, 2338, 2408, 2408, 2711], [2713, 2772, 2794, 2794, 2820], [2822, 2822, 2942, 2942, 3268], [3270, 3329, 3347, 3347, 4819], [4821, 4950, 4976, 4976, 5300], [5302, 5361, 5418, 5453, 8399]]}
{"id": "Msd3Dn", "name": "LogarithmicSpiralTransform", "author": "jt", "description": "Transformation from screen-coordinates to logarithmic spiral with golden angle.", "tags": ["spiral", "logarithmic", "coordinatetransform"], "likes": 5, "viewed": 230, "published": "Public", "date": "1449104180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Logarithmic Spiral Transform - written 2015-12-02 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to FabriceNeyret2 for optimizations\nvoid mainImage( out vec4 O, vec2 I )\n{\n\tvec2 R = iResolution.xy;\n    I = (I+I-R)/R.y;\n    //I = (I+I-(I=iResolution.xy))/I.y; // NOT COMPATIBLE\n\n    I = vec2(0, iTime - log2(length(I))) + atan(I.y, I.x) / 6.283; // Thanks to FabriceNeyret2 for optimizations!\n    I.x = ceil(I.y) - I.x;\n\n    I.x *= 2.4; // approximation to golden angle pi*(3-sqrt(5))\n\n    O = vec4(fract(I),0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3Dn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 203, 241, 241, 584]]}
{"id": "Msd3Rj", "name": "xmas scene", "author": "bpt", "description": "basically borrowed everything except for layout and a crazy macro", "tags": ["xmas", "borrowed"], "likes": 1, "viewed": 123, "published": "Public", "date": "1451020836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n// WTF preprocessor - why no multi-line macros!!!!\n\n#define START_(PTYPE) ( vec3 pos, vec3 startPos, vec3 endPos, PTYPE startParam, PTYPE endParam, float startColor, float endColor ) {\n#define LINE_001\t\tvec2 res = vec2(1.,startColor);\n#define LINE_002(COUNT)\tfloat ddd = 1./(COUNT - 1.);\n#define LINE_003\t\tvec3 dPos = (endPos - startPos) * ddd;\n#define LINE_004(PTYPE)\tPTYPE dParam = (endParam - startParam) * ddd;\n#define LINE_005\t\tfloat dColor = (endColor - startColor) * ddd;\n#define LINE_006(COUNT) for ( int i = 0; i < COUNT; i++ ) {\n#define LINE_007(PRIM) \t    res = opU( res, vec2( PRIM( pos-startPos, startParam ), startColor ) );\n#define LINE_008        \tstartPos += dPos;\n#define LINE_009        \tstartParam += dParam;\n#define LINE_010         \tstartColor += dColor;\n#define LINE_011 \t\t}\n#define LINE_012    \treturn res;\n#define LINE_013 }\n\n#define MAKE_FN(PRIM,PTYPE,fCOUNT,COUNT) START_(PTYPE) LINE_001 LINE_002(fCOUNT) LINE_003 LINE_004(PTYPE) LINE_005 LINE_006(COUNT) LINE_007(PRIM) LINE_008 LINE_009 LINE_011 LINE_012 LINE_013\n\n//----------------------------------------------------------------------\n\nvec2 sdSphereLine_8 MAKE_FN(sdSphere,float,8.,8)\nvec2 sdSphereLine_4 MAKE_FN(sdSphere,float,4.,4)\nvec2 sdTorusLine_3 MAKE_FN(sdTorus,vec2,3.,3)\n\n//----------------------------------------------------------------------\n    \nvec2 sdPresent( vec3 pos, float size ) {\n    return pos.xy;\n}\n\nvec2 sdPerson( vec3 pos, vec3 feet, float height, float color ) {\n    return sdTorusLine_3( pos, feet, feet + vec3(0,height,0), vec2(0.2,0.1), vec2(0.02,0.1), color, color );\n}\n\nvec2 sdKid( vec3 pos, vec3 feet, float height, float color ) {\n    return sdPerson( pos, feet, height, color );\n}\n\nvec2 sdParent( vec3 pos, vec3 feet, float height, float color ) {\n    return sdPerson( pos, feet, height, color );\n}\n\nvec3 sdJumpingKidPath( vec3 base, float a, float b ) {\n    return base + vec3( b * cos( a + b ), max(0.,b*0.75*sin( a * 15.)), b * sin( a + b ) );\n}\n\nvec3 ellipsePath( vec3 base, float a, float b, float t ) {\n    return base + vec3( a * cos( t ), 0., b * sin( t ) );\n}\n\nvec3 sdTrainPath( vec3 pos, float t ) {\n    return pos + ellipsePath( vec3(0.,0.,0.), 0.4, 0.4, t );\n}\n\nvec2 sdTrainCar( vec3 pos, float t, float color ) {\n\treturn vec2( sdBox( sdTrainPath(pos,t), vec3( 0.05, 0.05, 0.05 ) ), color );\n}\n\nvec2 sdTrain( vec3 pos ) {\n    \n    float t = iTime * 0.75;\n    float s = 0.3;\n    \n    float k = 0.1 + sin( t * 10. ) * 0.1;\n\n    // smoke\n    vec2 res = sdSphereLine_4( sdTrainPath(pos,t+s*7.), vec3(0,0.1,0), vec3(0,0.25+k,0), 0.02, 0.04, 1., 10. );\n    \n    for ( int i = 0; i < 8; i++ ) {\n        \n\t\tres = opU( res, sdTrainCar( pos, t, 50.*t ) );\n        \n        t += s;\n        \n    }\n    \n    return res;\n}\n\n\nvec2 sdBPTScene( vec3 pos ) {\n\n    float t = iTime;\n    \n    // xmas tree\n    vec2 res = sdSphereLine_8( pos, vec3(0,0,0), vec3(0,1.125,0), 0.25, 0.1, 111., 111. );\n    \n    // train\n    res = opU( res, sdTrain( pos ) );\n    \n    // jumping kids\n   \tres = opU( res, sdKid( pos, sdJumpingKidPath( vec3(1,0,0), t, 0.2 ), 0.5, 150. ) ); // kid-1\n   \tres = opU( res, sdKid( pos, sdJumpingKidPath( vec3(-1,0,0), -t, 0.2 ), 0.5, 210. ) ); // kid-2\n    \n    // watching parents\n   \tres = opU( res, sdParent( pos, vec3(0.25,0,-1), 0.75, 160. ) ); // parent-1\n   \tres = opU( res, sdParent( pos, vec3(-0.25,0,-1), 0.75 + sin(t) * 0.05, 120. ) ); // parent-2\n\n    return res;\n    \n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 plane = vec2( sdPlane( pos), 1.0 ), res;\n    \n    res = opU( plane, sdBPTScene( pos ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0., 1., 0.) ) * 3.0;\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n      //  dif *= softshadow( pos, lig, 0.02, 2.5 );\n      //  dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        //lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Mds3zH", "previewfilepath": "https://soundcloud.com/marisdavis/john-lennon-happy-xmas-war-is", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/marisdavis/john-lennon-happy-xmas-war-is", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3Rj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 378, 403, 403, 418], [420, 420, 455, 455, 481], [483, 483, 514, 514, 601], [603, 603, 646, 646, 706], [708, 708, 753, 753, 793], [795, 795, 828, 828, 881], [883, 883, 919, 919, 1161], [1163, 1163, 1215, 1215, 1329], [1331, 1331, 1367, 1367, 1615], [1617, 1617, 1653, 1653, 1752], [1754, 1754, 1792, 1792, 1961], [1963, 1963, 2035, 2035, 2250], [2253, 2253, 2278, 2278, 2315], [2317, 2317, 2342, 2342, 2400], [2402, 2402, 2427, 2427, 2492], [2494, 2494, 2529, 2529, 2596], [2598, 2598, 2633, 2633, 2700], [2702, 2702, 2739, 2739, 2790], [2792, 2866, 2899, 2899, 2925], [2927, 2927, 2957, 2957, 2990], [2992, 2992, 3022, 3022, 3051], [3053, 3053, 3077, 3077, 3209], [4328, 4456, 4665, 4665, 4686], [4688, 4688, 4753, 4753, 4864], [4866, 4866, 4928, 4928, 4979], [4981, 4981, 5046, 5046, 5097], [5099, 5099, 5153, 5153, 5247], [5249, 5249, 5307, 5307, 5367], [5369, 5369, 5408, 5408, 5471], [5473, 5473, 5524, 5524, 5604], [5606, 5606, 5632, 5632, 6019], [6022, 6022, 6051, 6051, 6693], [6695, 6769, 6794, 6794, 6919], [6921, 6921, 6961, 6961, 7551], [7554, 7554, 7628, 7628, 7889], [7891, 7891, 7923, 7923, 8144], [8146, 8146, 8188, 8188, 8487], [8492, 8492, 8531, 8531, 10109], [10111, 10111, 10163, 10163, 10340], [10342, 10342, 10399, 10399, 10993]]}
{"id": "MsdGRS", "name": "first mapping test", "author": "RenoM", "description": "when i posted this texture https://www.shadertoy.com/view/4sdGzn, Shane suggested i map it onto a cylinder, learning 3d stuff now so here... :)\nalso implementd shadows into raymarching", "tags": ["raymarchingmappingshadows"], "likes": 36, "viewed": 1668, "published": "Public", "date": "1450575281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NB_OBJ 8\n#define T iTime\n#define PI 3.14159265\n#define EPS .01\n#define MAX 50.\n\nvec3 lp;\n\nvec2 rot(vec2 p, float t)\n{\n    vec2 s = vec2(cos(t), sin(t));\n    return p * mat2(s, -s.y, s.x);\n}\n\nfloat map(vec3 p, int id)\n{\n    if(id == 0) return length(p.xz) - 1.;\n    if(id == 1) return abs(p.y + 1.2);\n    if(id == 2) return abs(p.y - 2.2);\n    if(id == 3) return length(p-lp) - .1;\n    if(id == 4) return abs(p.z - 5.);\n    if(id == 5) return abs(p.z + 5.);\n    if(id == 6) return abs(p.x - 5.);\n    if(id == 7) return abs(p.x + 5.);\n    return MAX;\n}\n\nfloat march(vec3 ro, vec3 rd, out float d, int id)\n{\n    float t = .0;\n    for(int i = 0; i < 64; i++)\n    {\n        d = map(ro+t*rd, id);\n        if(d < EPS || t > MAX) break;\n        t += d;\n    }\n    return t;\n}\n\nint inter(vec3 ro, vec3 rd, out float t)\n{\n    int id = -1;\n    float d,l;\n    t = MAX;\n    for(int i = 0; i < NB_OBJ; i++)\n    {\n        l = march(ro, rd, d, i);\n        if(d < EPS && l < t)\n        {\n            t = l;\n            id = i;\n        }\n    }\n    return id;\n}\n\nvec3 normal(vec3 p, int id)\n{\n    vec2 q = vec2(0,EPS);\n    return normalize(vec3(map(p+q.yxx, id) - map(p-q.yxx, id),\n                          map(p+q.xyx, id) - map(p-q.xyx, id),\n                          map(p+q.xxy, id) - map(p-q.xxy, id)));\n}\n\nfloat hash12(vec2 p)\n{\n    return  fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat isInSuperellipse(vec2 uv, vec2 o, float r, float n)\n{\n    float res = pow(abs((uv.x - o.x) / r), n) + pow(abs((uv.y - o.y) / r), n);\n    return (res <= 1. ? sqrt(1. - res) : .0);\n}\n\nvec3 segrid(vec2 p)\n{\n    vec2 frac = fract(p);\n    p = floor(p);\n    float time = ceil(T);\n    float res = isInSuperellipse(frac, vec2(.5), .5, 4. * hash12(p));\n    vec3 hash = hash32(p);\n\tvec3 col = .7 * hash * res;\n    float h = floor(200. - hash12(p) * 200.);\n    if(floor(mod(T * 2.,50.)) == h) col *= 3.;\n    return col;\n}\n\nvec3 col(vec3 p, int id)\n{\n    if(id == 0) return segrid(60. * vec2(atan(p.z,p.x), p.y) / PI);\n    if(id == 1 || id == 2) return segrid(p.xz*15.);\n    if(id == 4 || id == 5) return segrid(p.xy*15.);\n    if(id == 6 || id == 7) return segrid(p.yz*15.);\n    return vec3(0);\n}\n\nvec3 shade(vec3 p, int id)\n{\n    if(id == 3) return vec3(1);\n    vec3 rd = normalize(p-lp);\n    float f;\n    f = inter(lp+rd, rd, f) != id ? .2 : 1.;\n    vec3 n = normal(p,id);\n    f *= max(.1,dot(n,-rd));\n    return f * col(p,id);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    lp = vec3(3.*cos(.8*T),.5,3.*sin(.8*T));\n\n    \n    vec2 R = iResolution.xy,\n         p = tan(.5236) * (U+U-R) / R.y;\n    vec3 ro = vec3(0,0,-4.9),\n         rd = normalize(vec3(p,1));\n    \n    ro.xz = rot(ro.xz, .8*T);\n    rd.xz = rot(rd.xz, .8*T);\n    \n    float t;\n    int id = inter(ro, rd, t);\n    \n    vec3 c = id == -1 ? vec3(0) : shade(ro+t*rd, id);\n    c *= 9. / (1.+t);\n    \n    O.xyz = clamp(c, .0, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 125, 125, 197], [199, 199, 226, 226, 558], [560, 560, 612, 612, 774], [776, 776, 818, 818, 1049], [1051, 1051, 1080, 1080, 1299], [1301, 1301, 1323, 1323, 1395], [1397, 1397, 1418, 1418, 1600], [1602, 1602, 1661, 1661, 1788], [1790, 1790, 1811, 1811, 2118], [2120, 2120, 2146, 2146, 2392], [2394, 2394, 2422, 2422, 2627], [2629, 2629, 2670, 2670, 3089]]}
{"id": "MsdGWn", "name": "Smoke noise", "author": "And390", "description": "A simple example of smoke-like curl noise. Based on simplex noise with FBM.", "tags": ["swirl", "perlin", "curl", "simplex"], "likes": 65, "viewed": 4794, "published": "Public", "date": "1449087573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int noiseSwirlSteps = 2;\nconst float noiseSwirlValue = 1.;\nconst float noiseSwirlStepValue = noiseSwirlValue / float(noiseSwirlSteps);\n\nconst float noiseScale = 2.;\nconst float noiseTimeScale = 0.1;\n\n\nfloat simplex(vec3 v);\nfloat getNoise(vec3 v);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat noise = getNoise(vec3(uv * noiseScale, iTime * noiseTimeScale));\n    noise = noise * noise * noise * noise * 2.0;  //more contrast\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n\n\nfloat fbm3(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result /= (1. + 1./2. + 1./4.);\n    return result;\n}\n\nfloat fbm5(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result += simplex(v * 8.) / 8.;\n    result += simplex(v * 16.) / 16.;\n    result /= (1. + 1./2. + 1./4. + 1./8. + 1./16.);\n    return result;\n}\n\nfloat getNoise(vec3 v) {\n    //  make it curl\n    for (int i=0; i<noiseSwirlSteps; i++) {\n    \tv.xy += vec2(fbm3(v), fbm3(vec3(v.xy, v.z + 1000.))) * noiseSwirlStepValue;\n    }\n    //  normalize\n    return fbm5(v) / 2. + 0.5;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 313, 313, 543], [547, 547, 567, 567, 727], [729, 729, 749, 749, 1000], [1002, 1002, 1026, 1047, 1229], [1231, 1623, 1644, 1644, 1693], [1695, 1695, 1716, 1716, 1765], [1767, 1767, 1789, 1789, 1829], [1831, 1831, 1859, 1859, 1911], [1913, 1913, 1938, 1938, 4079]]}
{"id": "MsdGz2", "name": "Alien cocoons", "author": "XT95", "description": "Trying to implement \"Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\" by Colin Barr Brisebois!\n", "tags": ["sss", "scattering", "translucency", "subsurface"], "likes": 132, "viewed": 6772, "published": "Public API", "date": "1451086242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by anatole duprat - XT95/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n\nconst float PI = 3.14159265359;\n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nfloat map( in vec3 p );\nmat3 lookat( in vec3 fw, in vec3 up );\nmat3 rotate( in vec3 v, in float angle);\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat noise(vec3 p);\nfloat smin( float a, float b, float k );\n\n\nvec3 lpos1,lpos2,lpos3;\n\n\n\n//Map\nfloat map( in vec3 p )\n{\n\tp.xz = mod(p.xz+100., 200.)-100.;\n\tfloat d = p.y+textureLod(iChannel0, p.xz*.05, 0.0).r*1.5;\n    d = min(d, length(p-lpos1)-1.);\n    d = min(d, length(p-lpos2)-1.);\n\n\tvec2 id = floor(p.xz/60.);\n\tp.xz = mod(p.xz, 60.)-30.;\n\tp = rotate(vec3(0.,1.,0.), p.y*.05*cos(iTime+sin(iTime*1.5+id.x*5.)+id.y*42.))*p;\n\td = min(d, smin(length(p-vec3(0.,12.,0.))-3.-noise(p*.3)*3., length(p-vec3(0.,7.,0.))-3.,4.)+textureLod(iChannel0, p.xz*.2, 0.0).r*.25);\n\n\tfloat branch = length( (rotate(vec3(.5,0.,.5), 1.2)*p-vec3(6.,0.,-6.)).xz)-.5;\n\tbranch = smin(branch, length( (rotate(vec3(-.5,0.,.5), 1.2)*p-vec3(6.,0.,6.)).xz)-.5,1.);\n\tbranch = smin(branch, length( (rotate(vec3(.5,0.,-.5), 1.2)*p-vec3(-6.,0.,-6.)).xz)-.5,1.);\n\tbranch = smin(branch, length( (rotate(vec3(-.5,0.,-.5), 1.2)*p-vec3(-6.,0.,6.)).xz)-.5,1.);\n\tbranch = max(branch, p.y-10.);\n\tbranch = branch-textureLod(iChannel0, p.xz*.1, 0.0).r*.25;\n\treturn smin(d, branch, 5.) ;\n}\n\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    return clamp(col,vec3(0.),vec3(1.));\n}\n\n//Shading\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd )\n{\t\t\n    float fog = pow(min( length(p-ro)/450., 1.),200.);\n\tp.xz = mod(p.xz+100., 200.)-100.;\n    \n    vec3 skyCol = skyColor(rd);\n    \n\tvec3 ldir1 = normalize(lpos1-p);\t\n\tvec3 ldir2 =  normalize(lpos2-p);\t\n\tvec3 ldir3 =  normalize(lpos3-p);\t\t\n\tfloat latt1 = pow( length(lpos1-p)*.15, 3. ) / (pow(texture( iChannel1, vec2(64./256.,0.25) ).x,2.)*2.+.1);\n\tfloat latt2 = pow( length(lpos2-p)*.15, 3. ) / (pow(texture(iChannel1, vec2(20./256.,0.25)).r*1.2,2.)*3.+.1);\n\tfloat latt3 = pow( length(lpos3-p)*.15, 2.5 ) / (pow(texture( iChannel1, vec2(128./256.,0.25) ).x,2.)*5.+.1);\n\n\tfloat thi = thickness(p,n, 10., 1.);\n\tfloat occ = pow( ambientOcclusion(p,n, 10., 1.), 5.);\n\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(n,ldir1),0.) ) / latt1;\n\tvec3 diff2 = vec3(.5,1.,.1) * (max(dot(n,ldir2),0.) ) / latt2;\n\tvec3 diff3 = vec3(1.,1.,1.) * (max(dot(n,ldir3),0.) ) / latt3;\n\n    vec3 col =  diff1*3. + diff2 + diff3;\n\n\tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+n), 0., 1.), 1.) + 1.;\n\tfloat trans2 =  pow( clamp( dot(-rd, -ldir2+n), 0., 1.), 1.) + 1. ;\n\tfloat trans3 =  pow( clamp( dot(-rd, -ldir3+n), 0., 1.), 1.) + 1. ;\n\n\tcol += vec3(1.,.2,.05) * (trans1/latt1 + trans2/latt2 + trans3/latt3)*thi + skyColor(vec3(0.,1.,0.))*(occ*.05) ;\n\n    col = mix(col, skyCol*.1, fog );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n    \n\t//define lights pos\n    lpos1 = vec3( cos(iTime*.25)*30., 12., 30.);\n\tlpos2 = vec3( cos(iTime*.4)*35., 15.+cos(iTime*.3)*5., sin(iTime*.5)*35.);\n\tlpos3 = vec3( 30., 12., -30.);\n    \n\t//camera ray\n    vec3 ro = vec3(cos(-iTime*.1+.75)*50.,13.+cos(iTime*.2+1.5)*5.,sin(-iTime*.1+.75)*50.);\n\tvec3 rd = normalize( vec3(v.x, v.y, 1.5-length(q*2.-1.)) );\n\trd = lookat( vec3(0.)-ro, vec3(0.,1.,0.))*rd;\n    \n\t//classic raymarching by distance field\n\tvec3 p = raymarche(ro, rd, vec2(1., 500.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, ro, rd);\n\t\n\t//Gamma correction\n    col = pow(col, vec3(1./2.2));\n    col = clamp(col,0.,1.) * (.5 + .5*pow( q.x*q.y*(1.-q.x)*(1.-q.y)*50., .5));\n    \n        \n    \n\tfragColor = vec4(col,1.0)*min(iTime*.25,1.);\n}\n\n\n    \n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane )\n{\n\tvec3 p = ro+rd*nfplane.x;\n\tfloat t = 0.;\n\tfor(int i=0; i<128; i++)\n\t{\n        float d = map(p);\n        t += d;\n        p += rd*d;\n\t\tif( d < 0.001 || t > nfplane.y )\n            break;\n            \n\t}\n\t\n\treturn p;\n}\n\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z)*.5+.5;\n}\nfloat smin( float a, float b, float k ) //Thx to iq^rgba\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat hash( float n )//->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - map( p + rd )) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 6;\n    const float nbIteInv = 1./float(nbIte);    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(-n)*l;\n        ao += (l + map( p + rd )) / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "lss3zH", "previewfilepath": "https://soundcloud.com/pandadubarchives/2007-2008-panda-dub-02", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/pandadubarchives/2007-2008-panda-dub-02", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdGz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[826, 832, 856, 856, 1782], [1785, 1785, 1814, 1814, 2232], [2234, 2244, 2304, 2304, 3583], [3586, 3586, 3643, 3643, 4496], [4505, 4505, 4564, 4564, 4781], [4783, 4783, 4809, 4809, 4975], [4978, 4978, 5017, 5017, 5129], [5131, 5131, 5172, 5172, 5522], [5524, 5524, 5566, 5566, 5809], [5810, 5810, 5868, 5868, 5961], [5964, 5964, 5994, 5994, 6032], [6033, 6033, 6065, 6065, 6168], [6169, 6169, 6214, 6214, 6306], [6308, 6308, 6386, 6386, 6923], [6926, 6926, 6997, 6997, 7314]]}
{"id": "Mst3D4", "name": "hexagonal truchet on GridClick", "author": "aiekick", "description": "based on [url=https://www.shadertoy.com/view/Xdt3D8]hexagonal truchet (408)[/url]  from shane\nClick on cell for fullscreen", "tags": ["mouse", "grid", "moire", "click", "shane"], "likes": 13, "viewed": 968, "published": "Public API", "date": "1449780056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on hexagonal truchet (408)  from shane : https://www.shadertoy.com/view/Xdt3D8\n*/\n\nvec2 gridSize = vec2(3.,3.);//grid size (columns, rows)\n    \nvec2 s,g,h,m;\nfloat z,t;\n\nfloat EncID(vec2 s, vec2 h, vec2 sz) // encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\nvec2 DecID(float id, vec2 sz) // decode id to coord // id:cellId / sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)/sz.x;\n    return vec2(cx,cy);\n}\nvec3 getcell(vec2 s, vec2 h, vec2 sz) // return id / uv\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    return vec3(id, h);\n}\n\nfloat shade(vec2 uv, float z, float pat, float den, float t)\n{\n\tuv /= z;\n\tuv.xy += t;\n    uv.x *= sign(cos(length(ceil(uv))*pat));\n    return cos(min(length(uv = fract(uv)), length(--uv))*3.14159*2.*floor(den)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tz = 3.;\n    t = iTime * 0.01;\n    s = iResolution.xy;\n    h = gl_FragCoord.xy;\n    g = h;\n    m = iMouse.xy;\n\t\n\tvec4 d = vec4(0);\n    vec3 cell = getcell(s,h,gridSize);\n\tif(iMouse.z>0.) {cell.x = EncID(s,m,gridSize);cell.yz = g;}\n\t\t\n\tvec2 p = cell.yz;\n\t\t\n\tif (cell.x == 0.) d += shade(cell.yz, 168., 111., 84., t); // ok\n\tif (cell.x == 1.) d += shade(cell.yz, 168., 111., 126., t*50.); // ok\n\tif (cell.x == 2.) d += shade(cell.yz, 84., 111., 84., t); // ok\n\tif (cell.x == 3.) d += shade(cell.yz, 84., 168., 40., t*200.); // ok\n\tif (cell.x == 4.) d += shade(cell.yz, 93., 123., 128., t*30.); // ok\n\tif (cell.x == 5.) d += shade(cell.yz, 57., 150., 128., t); // ok\n\tif (cell.x == 6.) d += shade(cell.yz, 87., 81., 124., t*100.); // ok\n\tif (cell.x == 7.) d += shade(cell.yz, 87., 81., 172., t*100.);//ok\n\tif (cell.x == 8.) d += shade(cell.yz, 66., 201., 46., t*50.);//ok\n\n\tfragColor = d;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mst3D4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[315, 374, 481, 481, 582], [583, 583, 663, 663, 762], [763, 763, 820, 820, 959], [961, 961, 1023, 1023, 1175], [1177, 1177, 1234, 1234, 2122]]}
{"id": "Xd33D4", "name": "536 // Planetary Shear", "author": "MrHenryBemis", "description": "/// 536 ///", "tags": ["light", "planet", "bending"], "likes": 12, "viewed": 348, "published": "Public", "date": "1449539386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.2, 0.25, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.6, 0.75, 0.6 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.536 + 2.536 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.536 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd33D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 164, 164, 690], [709, 709, 766, 766, 3230]]}
{"id": "Xd33D7", "name": "ShaderBasis0", "author": "racerxdl", "description": "ShaderBasis Example shader in https://github.com/DangerCenter/shaderbasis_cpp", "tags": ["test", "shaderbasis", "threesines"], "likes": 2, "viewed": 129, "published": "Public", "date": "1449935704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = 2. * (fragCoord.xy / iResolution.xy) - 1.;\n\tvec3 colour = vec3(0.0);\n\tfloat density = 0.15;\n\tfloat amplitude = 0.3;\n\tfloat frequency = 5.0;\n\tfloat scroll = 0.4;\n\n\tcolour += vec3(0.1, 0.05, 0.05) * (1.0 / abs((position.y + (amplitude * sin(((position.x-0.0) + iTime * scroll) *frequency)))) * density);\n\tcolour += vec3(0.05, 0.1, 0.05) * (1.0 / abs((position.y + (amplitude * sin(((position.x-0.3) + iTime * scroll) *frequency)))) * density);\n\tcolour += vec3(0.05, 0.05, 0.1) * (1.0 / abs((position.y + (amplitude * sin(((position.x-0.6) + iTime * scroll) *frequency)))) * density);\n\n\tfragColor = vec4( colour, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd33D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 693]]}
{"id": "Xd3GD4", "name": "Fires mod", "author": "merry", "description": "A single-line modification of \"Fires\" shader by xbe available at https://www.shadertoy.com/view/XsXSWS to add some smoke :) Nothing fancy, though.", "tags": ["procedural", "2d", "fire"], "likes": 80, "viewed": 3606, "published": "Public API", "date": "1449530407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////\n// Fire Flame shader\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// no defines, standard redish flames\n//#define BLUE_FLAME\n//#define GREEN_FLAME\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv;\n\tq.x *= 5.;\n\tq.y *= 2.;\n\tfloat strength = floor(q.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\tq.x = mod(q.x,1.)-0.5;\n\tq.y -= 0.25;\n\tfloat n = fbm(strength*q - vec2(0,T3));\n\tfloat c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );\n//\tfloat c1 = n * c * (1.5-pow(1.25*uv.y,4.));\n\tfloat c1 = n * c * (1.5-pow(2.50*uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n\n\tvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n\tcol= mix(col, pow(vec3(1.-clamp(c1, -1., 0.)) * pow(fbm(strength*q*1.25 - vec2(0,T3)),2.),vec3(2.)), .75-(col.x+col.y+col.z)/3.); // Just added this line!!! :)\n\t\n#ifdef BLUE_FLAME\n\tcol = col.zyx;\n#endif\n#ifdef GREEN_FLAME\n\tcol = 0.85*col.yxz;\n#endif\n\t\n\tfloat a = c * (1.-pow(uv.y,3.));\n\tfragColor = vec4( mix(vec3(0.),col,a), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3GD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 73, 94, 94, 213], [215, 215, 241, 241, 699], [701, 701, 721, 721, 951], [953, 1035, 1092, 1092, 1937]]}
{"id": "Xd3GRf", "name": "Optimized Ashima SimplexNoise3D", "author": "Makio64", "description": "Hello! I'm trying to optimize the ashima simplexNoise3D, I did some basic optim but can't find more, do you have suggestions? Thanks!\n\nOptimized2D Ashima : https://www.shadertoy.com/view/4sdGD8", "tags": ["noise", "noise3d", "simplexnoise", "ashima"], "likes": 33, "viewed": 1845, "published": "Public API", "date": "1451196159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = uv;\n    if(uv.x < .5){\n        pos*=20.;\n    } else {\n        pos*=0.5;\n    }\n    if(uv.y < .5){\n        pos*=5.;\n    } else {\n        pos*=20.;\n    }\n    float noise = snoise(vec3(-pos.x,pos.y,0.5*iTime));\n\tfragColor = vec4(vec3(noise),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3GRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1797, 1854, 1854, 2156]]}
{"id": "Xd3GRX", "name": "Audio Visualizer - Raymarching", "author": "Lallis", "description": "Beware of the audio volume from soundcloud!\nHad a lot of fun with this one. I redirected my audio output to the microphone channel so I could have my own music in shadertoy and it was pretty cool! Check the comments if you want to try out some stuff.", "tags": ["raymarching", "audio", "visualizer"], "likes": 26, "viewed": 1171, "published": "Public", "date": "1451120795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tIf you have any ideas please let me know in the comments! :)\n\tEspecially if you have a better idea for the frequency distribution.\n\tRight now it's MAXF/2^(x/2) where x is a frequency band numbered from 0 to 15.\n\tIt would probably be smart to include more than a single frequency over each band.\n\t\n*/\n//Enable dithering\n#define ENABLEDITHER\n\n//Enable rotation\n//#define ENABLEROT\n\n//Enable zooming with beat (sucks ass)\n//#define ENABLEBEAT\n\n//Show only the back wall without perspective\n//#define FLAT\n\n//Enable waveform\n#define ENABLEWAVE\n\n//Waveform amplitude; adjust according to audio source volume\n#define WAVEAMP 1.0\n\n//Height for gradient middle color; set to 1.0 for 2 color gradient\n#define GRADVAL 0.8\n\n#define time iTime\n\n\nconst vec3 Color1 = vec3(0.25,0.625,0.625);\nconst vec3 Color2 = vec3(0.25,0.25,1.00); // TEAL->BLUE->RED\nconst vec3 Color3 = vec3(1.00,0.25,0.25);\n\n//Some color combinations\n\n/*const vec3 Color1 = vec3(0.25,1.00,0.25);\nconst vec3 Color2 = vec3(0.75,0.50,0.25); // GREEN->YELLOW->RED\nconst vec3 Color3 = vec3(1.00,0.25,0.25);*/\n\n/*const vec3 Color1 = vec3(0.00,0.00,0.00);\nconst vec3 Color2 = vec3(0.70,0.55,0.25); // BLACK->YELLOW->WHITE\nconst vec3 Color3 = vec3(0.5);*/\n\n/*const vec3 Color1 = vec3(0.25,0.25,1.00);\nconst vec3 Color2 = vec3(0.25,0.625,0.625); // BLUE->TEAL->WHITE\nconst vec3 Color3 = vec3(0.5);*/\n\n\n/*const vec3 Color1 = vec3(0.75); // WHITE\n//const vec3 Color1 = vec3(0.25,0.50,1.00); // LIGHT BLUE\nconst vec3 Color2 = Color1;\nconst vec3 Color3 = Color1;*/\n\nfloat noise(vec2 p)\n{\n\treturn fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453);\n}\n\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nvec3 getCol(float v, vec3 col1, vec3 col2)\n{\n    v = clamp(v,0.0,1.0);\n    vec3 res = vec3(0.0);\n    for(int i = 0; i<3; i++)\n    {\n        res[i] = col1[i] + v * (col2[i] - col1[i]);\n    }\n    return res;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d = vec4(0.0);\n\t  \n    vec3 bgCol = vec3(0.125,0.125,0.125);\n    \n    #ifdef ENABLEWAVE\n    float waveF = texture(iChannel0, vec2((rp.x+1.8)/3.6, 0.75)).r;\n    float waveDist = udBox(rp-vec3(0.0,-waveF*WAVEAMP+WAVEAMP/2.0,0.25), vec3(1.8,0.02,0.001));\n    vec4 wave = vec4(vec3(0.3), waveDist);\n    #endif\n    \n    float backWallDist = udBox(rp-vec3(0.0,0.0,0.75), vec3(1.8, 1.1, 0.5));\n    vec4 backWall = vec4(bgCol, backWallDist);\n    \n    float edgeLeftDist = udBox(rp-vec3(1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\n    vec4 edgeLeft = vec4(bgCol, edgeLeftDist);\n    \n    float edgeRightDist = udBox(rp-vec3(-1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\n    vec4 edgeRight = vec4(bgCol, edgeRightDist);\n    \n    float edgeTopDist = udBox(rp-vec3(0.0,1.2,0.3725), vec3(2.0,0.1,1.0));\n    vec4 edgeTop = vec4(bgCol,edgeTopDist);\n    \n    float edgeBotDist = udBox(rp-vec3(0.0,-1.2,0.3725), vec3(2.0,0.1,1.0));\n    vec4 edgeBot = vec4(bgCol,edgeBotDist);\n    \n    d = edgeLeft.a > backWall.a ? backWall : edgeLeft;\n    d = edgeRight.a > d.a ? d : edgeRight;\n    d = edgeTop.a > d.a ? d : edgeTop;\n    d = edgeBot.a > d.a ? d : edgeBot;\n    \n    #ifdef ENABLEWAVE\n    d = wave.a > d.a ? d : wave;\n    #endif   \n\n    return d;\n    \n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   \n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat light(vec3 lp, vec3 rp, vec3 n, float pulse)\n{\n    return (1.5*(pulse+0.05)/pow(distance(lp,rp),2.0))*max(dot(normalize(lp-rp), n), 0.0)*0.25;\n}\n\nfloat drawLight(vec3 lp, vec3 rd, vec3 ro, float td, float pulse)\n{\n    float res = 0.0;\n    if(td > distance(lp,ro))\n    {\n\t\tfloat dlp = length(cross(lp-ro, lp-(ro+rd)))/length((ro+rd)-ro);\n\t\tres=max(exp(-dlp*64.0*((1.0-pulse)+0.5)),0.0);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = iMouse.x == 0.0 ? 0.5 : iMouse.x/iResolution.x;\n    m = 2.0*m-1.0;\n    vec3 col = vec3(0.00);\n    \n    float hArr[16];\n    for(int i = 0; i < 16; i++)\n    {\n     \thArr[i] = texture(iChannel0, vec2( 1.0/pow(2.0,float(i)*0.5)-0.001,0.25)).r;\n    }    \n    \n    float z = -0.5;\n    \n    #ifdef ENABLEROT\n    z = -2.0*(sin(time*0.25)*0.5+0.5);\n    #endif\n    #ifdef ENABLEBEAT\n    z += -2.0*hArr[14];\n    #endif\n    vec3 ro = vec3(0.0,0.0,z-2.0);\n    #ifdef FLAT\n    ro = vec3(p/vec2(1.0,1.25), z-2.0);\n    #endif\n    vec3 rd = normalize( vec3(p, z) - ro );\n    \n    vec3 ang = vec3( 0.0, 0.0 , 0.0);\n    #ifdef ENABLEROT\n    ang = vec3(1.54*sin(time*0.125)*0.25, 1.54*cos(time*0.25)*0.25, 0.0);\n    #endif\n    ro*=rot(ang);\n    rd*=rot(ang);\n    \n    vec3 rp = vec3(0.0);\n    \n    vec4 d = vec4(0.0);\n    float td = 0.5;\n\tfloat dMax = 25.0;\n    \n    for(int i = 0; i < 64; i++)\n    {\n        if(td >= dMax) break;\n        rp = ro+rd*td;\n     \td = map(rp);\n        if(d.a < 0.001)\n        {\n         \tbreak;   \n        }\n        td += d.a*0.75;\n    }\n    \n    vec3 lp[16];\n    \n    for(int i = 0; i < 16; i++)\n    {\n     \tlp[i] = vec3( (7.5-float(i))*0.2125, hArr[i]*2.0-1.0, 0.0);      \n    }\n    \n    float g = 1.0/(1.0-GRADVAL);\n    float r = 1.0/GRADVAL;\n    \n    vec3 lc[16];\n    \n    for(int i = 0; i < 16; i++)\n    {\n     \tlc[i] = getCol((hArr[i]-GRADVAL)*g, getCol(hArr[i]*r, Color1, Color2), Color3);    \n    }\n    \n    vec3 n = normal(rp);\n    if(d.a < 0.001)\n    {\t\t\t\n        \n        vec3 illumination = vec3(0.01);\n        \n        for(int i = 0; i < 16; i++)\n        {\n         \tillumination += lc[i] * light(lp[i], rp, n, hArr[i] );   \n        }\n      \n     \tcol = d.rgb*illumination;   \n    }\n    \n    for(int i = 0; i < 16; i++) \n    {\n     \tcol += lc[i] * drawLight(lp[i], rd, ro, td, hArr[i] );   \n    }\n\n    col = clamp(col, 0.0, 1.0);\n    \n    col = pow(col, vec3(0.45)); //gamma adjust\n    \n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018); //contrast\n    p.x/=iResolution.x/iResolution.y;\n    col *= smoothstep( 1.325, 0.825, abs(p.x) ); //dark edges\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\n    \n    #ifdef ENABLEDITHER\n    float dither = 4.0/256.0;\n\n   \tcol += (noise3D(vec3(p,fract(time)))*2.0-1.0)*dither;\n    #endif\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MsjGDG", "previewfilepath": "https://soundcloud.com/user2727940/deadmau5-strobe", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user2727940/deadmau5-strobe", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3GRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1355, 1515, 1536, 1536, 1601], [1603, 1603, 1626, 1626, 1699], [1702, 1702, 1722, 1722, 1985], [1987, 1987, 2031, 2031, 2194], [2196, 2196, 2227, 2227, 2265], [2267, 2267, 2286, 2286, 3512], [3514, 3514, 3536, 3536, 3759], [3761, 3761, 3813, 3813, 3911], [3913, 3913, 3980, 3980, 4176], [4178, 4178, 4235, 4235, 6700]]}
{"id": "Xd3Gz2", "name": "Dream Effect", "author": "GIBIR", "description": "I didn't do anything I just edit a litttle bit XT95 code\nthanks to XT95 :)\nhttps://www.shadertoy.com/view/MdX3zr\nhttps://www.shadertoy.com/view/4sSSWz\nhttps://gibir.net.tr", "tags": ["3d", "transparency"], "likes": 16, "viewed": 506, "published": "Public", "date": "1450732626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat sampleMusicA() { // https://www.shadertoy.com/view/llB3W1\n\treturn 0.5 * (\n\t\ttexture( iChannel0, vec2( 0.15, 0.05 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.05 ) ).x)*iTime;\n}\n\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(.2,.5,1.), vec4(0.,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,(iTime)*2.,.0)) + noise(p*3.)*.5) ; // noise(p+vec3(.0,iTime*2.,.0))\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<100; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < 20.)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(.1,1.5,0.,0.), mix(vec4(0.1,.1,1.,1.0),vec4(1.,.5,0.,1.0),p.w), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3Gz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 279], [281, 281, 313, 313, 350], [352, 352, 374, 415, 534], [537, 537, 558, 558, 715], [717, 717, 738, 738, 786], [788, 788, 823, 823, 1103], [1105, 1105, 1162, 1162, 1643]]}
{"id": "Xd3Gzs", "name": "first tunnel", "author": "nexor", "description": "first try on creating the old 3d tunnel effect", "tags": ["tunnel", "3dtunnel"], "likes": 14, "viewed": 284, "published": "Public", "date": "1451565525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sig(x) (2.*step(0.,x)-1.)\n#define ss(x,f) sig(x)*smoothstep(abs(f)+(sss),abs(f)-(sss),abs(x))\n\n#define rpt(x,m) (mod(x,m)-m*.5)\n#define pix(x,b) ((floor(x*float(b))+.5)/float(b))\n\n#define cos2(x) (2.*(cos(x)+1.))\n#define sin2(x) (2.*(sin(x)+1.))\n\nfloat time;\nvec2 resolution;\n\nconst float pi = 3.14159265359;\nconst float pi2 = pi*2.;\nconst float pih = pi*.5;\nfloat sq2;\nfloat sq2h;\nfloat sq3;\nfloat sq3h;\nfloat sq3t;\nconst float sss = 1e-3;\n\nvoid init()\n{\n    time = iTime;\n    resolution = iResolution.xy;\n    sq2h = sq2*.5;\n    sq3 = sqrt(3.);\n    sq3h = sq3*.5;\n    sq3t = 1./sq3;\n}\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.y *= resolution.y/resolution.x;\n\t return p;\n}\n\nmat2 rotmd(float a)\n{\n\t a=radians(a);\n\t float c=cos(a),s=sin(a);\n\t return mat2(c,-s,s,c);\n}\n\nmat2 rotmr(float a)\n{\n\t float c=cos(a),s=sin(a);\n\t return mat2(c,-s,s,c);\n}\n\nfloat saw(float x)\n{\n\t return abs(fract(x)*2.-1.);\n}\n\nfloat saw2(float x)\n{\n\t return abs(fract(x)*4.-2.)-1.;\n}\n\nfloat rct(vec2 p,float w,float h)\n{\n\tp=abs(p);\n\treturn ss(p.x,w)\n\t      *ss(p.y,h);\n}\n\nfloat rct(vec2 p, float s)\n{\n\treturn rct(p,s,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n\tvec2 glfc = fragCoord.xy;\n\tvec2 p = tr(glfc);\n\tvec2 q = p;\n\tvec3 col = vec3(0.);\n\tmat2 r = rotmr(time*.1);\n\n    p+=vec2(cos(time)*.2,sin(time*.7)*.5);\n    float a = atan(p.y,p.x);\n    float len = length(p);\n\n    q.x=1.5/len+.5*time;\n    q.y=a*6.+time*.3;\n    q.y/=pi;\n  \n    float v = .0\n    +(rct(rpt(q,1./8.),1./32.))\n \t*saw2(.5*(q.y+2.*saw(.5*q.x)))\n \t;\n \tv*=smoothstep(.0,.7,len);\n\n    col+=v*v;\n    col*=vec3(cos2(4.*q.x),cos2(4.*q.x+2.),sin2(q.x+q.y));\n    col*=exp(.7);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3Gzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 450, 463, 463, 593], [595, 595, 612, 612, 702], [704, 704, 725, 725, 795], [797, 797, 818, 818, 872], [874, 874, 894, 894, 926], [928, 928, 949, 949, 984], [986, 986, 1021, 1021, 1071], [1073, 1073, 1101, 1101, 1123], [1125, 1125, 1182, 1182, 1705]]}
{"id": "Xdc3DH", "name": "Moon & sky", "author": "Draedrus", "description": "An essai of what can be done here. Some functions here are inspired from their ones.", "tags": ["clouds", "sky", "stars", "moon"], "likes": 5, "viewed": 265, "published": "Public", "date": "1449221617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\n#define OCTAVES 8\n\nvec4 cRed = vec4(0.9, 0.5, 0.0, 1.0);\nvec4 cYellow = vec4(0.9, 0.9, 0.0, 1.0);\nvec4 cRing = vec4(1.0, 0.5, 0.4, 1.0);\nvec4 cViolet = vec4(0.5, 0.4, 1.0, 1.0);\n\n/**\n * noise inspired by common knowledge found in internet.\n **/\nfloat noise(float x)\n{\n    return fract(sin(x)*556858.4905705783);\n}\n\n// inspired from TDM code \"Seascape\"\nfloat smoothNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(noise(wx+0.0)     ,      noise(wx+1.0), f.x),\n                mix(noise(wx+0.0+winy), noise(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(noise(wx+0.0+winz)     ,      noise(wx+1.0+winz), f.x),\n                mix(noise(wx+0.0+winy+winz), noise(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n/**\n * This one is inspired by IQ code \"Clouds\" from this website.\n **/\nfloat perlin(vec3 V)\n{\n    float total = 0.0;\n    for(int i=1;i<OCTAVES+1;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat gaussianGlow(vec2 uv, vec2 c, float p)\n{\n    float d = length(uv-c);\n    return 4.01*pow(2.0, p*d);\n}\n\nvec4 renderMoon(vec2 uv, vec2 center, float gaussian)\n{\n    float d = length(uv-center);\n    float p = perlin(vec3(-uv*uv, -d));\n    vec4 color = vec4(gaussian)+vec4(0.0, 0.0, 0.2*(1.0-gaussian), 1.0);\n    if(gaussian>=0.9) {\n        color=vec4(1.0-smoothNoise(vec3(\n            p-0.2\n        ))\n                  )*(2.0-pow(log2(1.0+4.0*d),8.0));\n    }\n    return color;\n}\n\nvec4 render(vec2 uv, vec2 center)\n{\n    vec4 color = vec4(0.0);\n    float limit = 0.16;\n    float d = length(uv-center);\n    float tf = iTime;\n    float tf100 = iTime/100.0;\n    float tf1000 = iTime/1000.0;\n    float n = noise(d*cos(uv.x)*sin(uv.y));\n    d = d+0.01;\n    float gaussianG = gaussianGlow(uv, center, -16.0);\n\n    // moon\n    color = renderMoon(uv, center, gaussianG);\n    // clouds\n    float e = perlin(vec3(uv.x-tf100, uv.y, (uv.x-uv.y)+tf100));\n    color = mix(color, vec4(e)*vec4(0.6), d);\n    e = perlin(vec3(uv.x-tf1000, uv.y, (uv.x+uv.y)-tf1000));\n    color = mix(color, vec4(e)*vec4(0.42), d);\n    // stars\n    if(n>0.99 && d>0.15) {\n        color = mix(color, vec4(1.0),\n                    max(\n                        cos(noise(d+dot(uv, uv))*tf),\n                        0.0\n                    )*\n                    (\n                        max(cos(uv.x/tf+4.71), 0.0)*\n                        max(sin(uv.y/tf+4.71), 0.0)\n                        +0.5235\n                    )\n                   );\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / vec2(iResolution.x*0.6, iResolution.y);//iResolution.xy;\n    vec2 center = vec2(0.85, 0.5);\n    vec4 color = vec4(0.0);\n\n    color = mix(\n        \t\tmix(render(uv+vec2(-0.001, -0.001), center),\n                    render(uv+vec2(-0.001, 0.001), center), 0.5),\n        \t\tmix(render(uv+vec2(0.001, -0.001), center),\n                    render(uv+vec2(0.001, 0.001), center), 0.5),\n        \t\t0.5);\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 314, 336, 336, 382], [384, 421, 448, 448, 1004], [1006, 1078, 1100, 1100, 1265], [1267, 1267, 1313, 1313, 1374], [1376, 1376, 1431, 1431, 1749], [1751, 1751, 1786, 1786, 2802], [2804, 2804, 2861, 2861, 3303]]}
{"id": "Xdc3Rf", "name": "Simple graph plotter", "author": "waterhead", "description": "A very basic graph plotter, using a simple tangent calculation in order to draw the graph. In fact choosing a \"thickness\"-value being too big (try 20.0) will result in artifacts due to too much of the tangent being drawn.", "tags": ["1d", "graph", "fx", "function", "plot", "plotter"], "likes": 4, "viewed": 506, "published": "Public", "date": "1451224534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fn(in float x) {\n    // function to be plotted...\n    return 0.3 * sin(x * 9.0 + iTime * 9.0) / (0.41 *(0.1 + abs(x))) * 1.0;\n}\n\n\nfloat grid(in float step, in float position, in float pixelWidth) {\n    #define ALTERNATIONS 10.0\n\n    float   m           = mod(position, step),\n            distance    = min(m, step - m),\n            intensity   = clamp(0.75 * pixelWidth / distance, 0.0, 1.0),\n            alternation = mod(floor((position + 0.5 * step) / step), ALTERNATIONS);\n    \n    return intensity * (1.0 - (min(alternation, ALTERNATIONS - alternation) / (0.6 * ALTERNATIONS)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n                        // little eye candy, let's move in graph for better throwing up\n    float   timeScale   = 0.1,\n            time        = iTime * timeScale,\n            viewSize    = (0.7 + 0.5 * sin(time)) * 5.0,\n            centerX     = sin(time*2.31) * 5.0;\n    \n                        // defines the viewport bounds of the displayed graph\n    float   left        = -viewSize + centerX,\n            right       =  viewSize + centerX,\n            top         =  viewSize,\n            bottom      = -viewSize;\n\n                        // convert fragment's pixel position to graph space location\n    float   locationX   = left   + (right - left) * fragCoord.x / iResolution.x,\n            locationY   = bottom + (top - bottom) * fragCoord.y / iResolution.y;\n\n                        // calculate width of a pixel in graph space\n    float   pixelWidth  = (right - left) / iResolution.x;\n\n                        // calculate two points left and right of current graph space location\n    float   x1          = locationX - 0.1 * pixelWidth, y1 = fn(x1),\n            x2          = locationX + 0.1 * pixelWidth, y2 = fn(x2);\n\n                        // get distance from point at (locationX, locationY)\n                        // to tangent given by (x1, y1) and (x2, y2)\n    float   distance    = abs((y2 - y1) * locationX - (x2 - x1) * locationY + x2*y1 - y2*x1 ) /\n                          sqrt((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1));\n\n    float   thickness   = 1.75,\n            graphColor  = 0.8 * (1.0 - clamp(distance / (thickness * pixelWidth), 0.0, 1.0)),\n            gridColor   = 0.5 * grid(1.0, locationY, pixelWidth) +\n                          0.5 * grid(1.0, locationX, pixelWidth);\n    \n    fragColor = vec4(graphColor,\n                     graphColor + gridColor,\n                     graphColor,\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 55, 133], [136, 136, 203, 203, 591], [594, 594, 651, 739, 2496]]}
{"id": "Xdc3zS", "name": "Narves1", "author": "rohtie", "description": "Commercial I did for the Narves1 kiosk.\nhttp://i.imgur.com/34P4VNk.jpg", "tags": ["distancefields"], "likes": 5, "viewed": 356, "published": "Public", "date": "1450306394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat capsule ( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nbool distanceCmp(float distanceA, float distanceB, float eps) {\n    return distanceA > distanceB - eps && distanceA < distanceB + eps;\n}\n\nbool distanceCmp(float distanceA, float distanceB) {\n    return distanceCmp(distanceA, distanceB, 0.05);\n}\n\nvec2 map (vec3 point) {      \n    float material = 0.0;\n    \n    float t = 0.1 + sin(iTime * 0.001) * 50000.0;\n    float ti = 1.5 - sin(iTime) * 0.5;\n    float j = 1.12;\n    point.zx *= mat2(-sin(j), cos(j), cos(j), sin(j));\n    \n    point.zy *= mat2(-sin(ti), cos(ti), cos(ti), sin(ti));\n    \n    float body = capsule(point, vec3(0.0, 1.0, 0.0), vec3(0.0, -2.0, 0.0), 0.5);\n    \n    float mouth = smin(\n        capsule(point, vec3(-0.3, 0.35, 0.4), vec3(-0.1, 0.17, 0.5), 0.09),\n        capsule(point, vec3(0.3, 0.35, 0.4), vec3(0.1, 0.17, 0.5), 0.09),\n        0.2);\n    \n    vec3 q = point;\n    q.x += sin(q.y * 5.0) * 0.175;\n    float bodyDeco = capsule(q, vec3(0.0, -0.5, 0.5), vec3(0.0, -2.0, 0.5), 0.11);\n    \n    \n    point.x = abs(point.x);\n    \n    vec3 brow_point = point;\n    brow_point.y -= sin(point.x * 5.0) * 0.175;\n    float brows = capsule(brow_point, vec3(0.1, 0.8, 0.5), vec3(0.3, 0.7, 0.4), 0.05);\n    \n    \n    float eyes = length(point - vec3(0.2, 0.6, 0.5)) - 0.1;\n    \n    float pupils = length(point - vec3(0.2, 0.6, 0.6)) - 0.075;\n    \n    float arms = smin(\n        capsule(point, vec3(0.4, -0.3, 0.0), vec3(0.7, -0.75, 0.7), 0.21),\n        capsule(point, vec3(0.5, -0.75, 1.3), vec3(0.7, -0.75, 0.9), 0.21),\n        0.15);\n    \n    float fingers = min(capsule(point, vec3(0.6, -0.65, 1.1), vec3(0.2, -0.4, 1.1), 0.12),\n                        min(capsule(point, vec3(0.6, -0.65, 1.1), vec3(0.2, -0.4, 1.8), 0.09),\n                            min(capsule(point, vec3(0.4, -0.7, 1.5), vec3(0.4, -0.7, 1.8), 0.09),\n                                capsule(point, vec3(0.4, -0.8, 1.4), vec3(0.4, -0.9, 1.7), 0.09))));\n    \n    float composite = smin(body, eyes, 0.1);\n    composite = smin(composite, mouth, 0.07);\n    composite = smin(composite, arms, 0.15);\n    composite = min(composite, pupils);\n    composite = smin(composite, bodyDeco, 0.06);\n    composite = smin(composite, brows, 0.04);\n    composite = smin(composite, fingers, 0.2);\n    \n    \n    float distance = composite + \n        texture(iChannel0, point.xx * point.yy * point.zz *\n                             mat2(-sin(t), cos(t),\n                                  cos(t), sin(t))).r * (0.05) ;\n    \n    if (distanceCmp(distance, body)) {\n        material = 1.0;\n    }\n    else if (distanceCmp(distance, pupils, 0.02)) {\n        material = 4.0;\n    }\n    else if (distanceCmp(distance, eyes, 0.1)) {\n        material = 2.0;\n    }\n    else if (distanceCmp(distance, min(mouth, bodyDeco))) {\n        material = 3.0;\n    }\n\n    return vec2(distance, material);\n}\n\nvec2 intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n    \n    float distance = 0.0;\n\n    float currentDistance = 1.0;\n    \n    vec2 result;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        result = map(rayOrigin + rayDirection * distance);\n        currentDistance = result.x;\n        \n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return vec2(-1.0, 0.0);\n    }\n\n    return vec2(distance, result.y);\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy).x,\n        map(point + extraPolate.yxy).x,\n        map(point + extraPolate.yyx).x\n    ) - map(point).x);\n}\n\nvec3 light = normalize(vec3(5.0, 5.0, 5.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n    point.x *= iResolution.x / iResolution.y;\n    \n    vec2 p = point;\n    \n    vec3 cameraPosition = vec3(-0.5, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n    \n    vec2 result = intersect(cameraPosition, rayDirection);\n    \n    float distance = result.x;\n    float material = result.y;\n    \n    vec3 col = vec3(0.0);\n\n    if (result.x > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        if (material == 1.0) {\n            col += vec3(0.5, 0.21, 0.2);\n        }\n        else if (material == 2.0) {\n            col += vec3(0.5);\n        }\n        else if (material == 3.0) {\n            col += vec3(0.6, 0.0, 0.0);\n        }\n        else if (material == 4.0) {}\n        else {\n            col += vec3(0.5, 0.21, 0.2);\n        }\n        \n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n        \n        float att = clamp(1.0 - length(light - point) / 5.0, 0.0, 1.0); att *= att;\n        col *= att;\n        \n    }\n    else {\n        col = vec3(0.3 + p.x * 0.04, 0.05 + p.x * p.y * 0.2, smoothstep(0.2, 0.7 + sin(p.y * 52.0 * iTime), (length(p) - 1.0))) * 1.5;\n    }\n    \n    col *= 1.5;\n\n    color.rgb = col;\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 134], [136, 136, 187, 187, 314], [316, 316, 379, 379, 452], [454, 454, 506, 506, 560], [562, 562, 585, 585, 3109], [3111, 3111, 3163, 3163, 3779], [3781, 3781, 3809, 3809, 4022], [4070, 4070, 4118, 4118, 5543]]}
{"id": "XdcGDH", "name": "warp dance", "author": "Dain", "description": "iq's prims shader \n\nplaying around with warping space w/ normal.  \nSome of the shapes have a separate local warp applied(box, torus, sphere).\n", "tags": ["primitives"], "likes": 5, "viewed": 317, "published": "Public", "date": "1449305058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvec3 GetOffset(){\n    return vec3(0.0,0.0,0.0);\n}\nfloat max_element(vec3 a){\n    return max(max(a.x, a.y), a.z);\n}\n\n//sin warve warping based on normal\nvec3 NormalSinPowWarp(vec3 pos, float freq, float amp, float power) {\n    vec3 dir = normalize(pos);\n\tvec3 warp = abs(sin(dir*freq));\n\tfloat mw = max_element(warp);\n\tmw = pow(mw, power);\n\treturn pos - dir * mw * amp;\n}\nvec3 NormalSinPowWarpOffset(vec3 pos, vec3 offset, float freq, float amp, float power) {\n\treturn NormalSinPowWarp(pos + offset, freq, amp, power) - offset;\n}\nvec3 NormalSinPowWarpTest(vec3 pos, float freq, float amp, float power) {\n\treturn NormalSinPowWarpOffset(pos, GetOffset(), freq, amp, power);\n}\n\n    \nfloat taxicab_norm(vec3 a) {\n\tvec3 pa =  abs(a);\n    return pa.x + pa.y + pa.z;\n}\n\nfloat saturate(float a)//why is this not built in..sigh\n{\n  return clamp(a, 0.0, 1.0);   \n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    p = NormalSinPowWarpTest(p, 15.0, -0.1, 3.0);\n    return (length(p)-s)*0.25;\n}\n\nfloat tetrahedron(vec3 p, float r) {\n    vec3 o = p / sqrt(3.0);\n    float p1 = -o.x+o.y-o.z;\n    float p2 =  o.x-o.y-o.z;\n    float p3 = -o.x-o.y+o.z;\n    float p4 =  o.x+o.y+o.z;    \n\tfloat s = max(max(max(p1,p2),p3),p4);\n    \n\treturn s-r*1.0/sqrt(3.0);\n}\n\n// 3D distance of XYZ cross diagonal plane\nfloat octahedronG(vec3 p, float r) {\n    return tetrahedron(p, r);\n    vec3 o = abs(p);\n\tfloat s = o.x+o.y+o.z;\n\treturn (s-r)/sqrt(3.0);\n}\n\n//not euclidean, gotta slow down ray stepper to see it\nfloat Octahedron(vec3 p, float r){\n\treturn taxicab_norm(p) - r;\n}\n\nfloat OctahedronConservative(vec3 p, float r){\n    float s = sdSphere(p, r);\n    \n    float o = Octahedron(p,r)*.5;\n    \n    //we will begin switching from sphere to oct when we are within r of the sphere\n    float nearOct = s  * (1.0/r);\n    \n    float l =  saturate(nearOct);\n    return mix(o, s, l);\n}\n\n\nfloat length_n(vec3 p, vec3 power, float downpo){\n    return pow(abs(pow(p.x, power.x)) + abs(pow(p.y, power.y)) + abs(pow(p.z, power.z)), 1.0 /downpo);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 ah =  (normalize(p));\n    ah = abs(sin(ah*15.0));\n   float ahm = max(max(ah.x, ah.y), ah.z);\n   //  ahm = sin(ahm);\n    ahm = pow(ahm, 1.0);\n   \n  vec3 d = abs(p) - b - ahm*b;\n  return (max(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)))*0.125;\n}\n/*\n\nfloat sdPyramid(vec3 p, vec3 b){\n\tconst auto frac = saturate((p.y + yv)*number(b.y));\n\t\n\t//lerp the box lengths\n\tauto bx = lerp(number(x), number(topX), frac);// x * (number(1.f) - frac) + (x*capsize)*frac;\n\tauto bz = lerp(number(z), number(topZ), frac); // z * (number(1.f) - frac) + (z*capsize)*frac;\n\n\t//now do standard box algorithm\n\tauto b = vec3(bx, yv, bz);\n\treturn sdBox(p, b);\n}\n*/\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n     p = NormalSinPowWarpTest(p, 3.0, 0.1, 10.0);\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    //tyre look?\n   p = NormalSinPowWarpTest(p, 13.0, 0.051, 10.0);\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat smoothWave(float v, float m){\n  float o = sin(v/m);\n  return o*m + m*.5;//broken but it looks cool\n // return (o*m + m)*.5;//actual smooth \n}\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n   // float sound = texture(iChannel0,vec2(0.0,0.0)).x*3.0;\n    float eh =  iTime + 55.0;\n    float time = eh;//iTime + 35.0;\n    float freq = smoothWave(time*5.0, 10.0);\n    float amp = smoothWave((time+ 8238.0)*0.14, 0.5);\n    float power = smoothWave((time+ 1238.0)*0.33, 5.0)+1.0;\n    //apply global warp\n     pos = NormalSinPowWarpTest(pos, freq, amp,power);\n    \n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n   \tres.x *= .48;\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<150; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -.5+3.5*cos(0.1*time + 6.0*mo.x), 5.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 378, 395, 395, 427], [428, 428, 454, 454, 492], [494, 530, 599, 599, 748], [749, 749, 837, 837, 906], [907, 907, 980, 980, 1050], [1057, 1057, 1085, 1085, 1138], [1140, 1140, 1197, 1197, 1231], [1233, 1233, 1258, 1258, 1273], [1275, 1275, 1310, 1310, 1393], [1395, 1395, 1431, 1431, 1652], [1654, 1697, 1733, 1733, 1835], [1837, 1892, 1926, 1926, 1957], [1959, 1959, 2005, 2005, 2263], [2266, 2266, 2315, 2315, 2420], [2423, 2423, 2454, 2454, 2710], [2711, 3107, 3150, 3150, 3260], [3262, 3262, 3307, 3307, 3347], [3349, 3349, 3382, 3399, 3503], [3505, 3505, 3541, 3541, 3783], [3785, 3785, 3837, 3837, 3951], [3953, 3953, 3989, 3989, 4237], [4239, 4239, 4275, 4275, 4374], [4376, 4376, 4414, 4414, 4583], [4585, 4585, 4657, 4657, 4872], [4875, 4875, 4900, 4900, 4937], [4939, 4939, 4964, 4964, 5022], [5024, 5024, 5049, 5049, 5114], [5116, 5116, 5151, 5151, 5218], [5220, 5220, 5255, 5255, 5322], [5324, 5324, 5361, 5361, 5412], [5414, 5488, 5521, 5521, 5547], [5549, 5549, 5579, 5579, 5612], [5614, 5614, 5644, 5644, 5673], [5675, 5675, 5699, 5699, 5831], [5833, 5833, 5868, 5868, 5980], [5981, 6055, 6080, 6140, 8621], [8623, 8623, 8663, 8663, 9254], [9257, 9257, 9331, 9331, 9592], [9594, 9594, 9626, 9626, 9847], [9849, 9849, 9891, 9891, 10190], [10195, 10195, 10234, 10234, 11820], [11822, 11822, 11874, 11874, 12051], [12053, 12053, 12110, 12110, 12703]]}
{"id": "XdcGzB", "name": "2D Noise Contours", "author": "Shane", "description": "Using a numerical gradient to produce smooth \"fract\" contours on 2D simplex-based noise... I'm having difficulty describing this one. :)", "tags": ["gradient", "simplex", "fract", "smooth"], "likes": 27, "viewed": 1826, "published": "Public API", "date": "1450361697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\t2D Noise Contours\n\t-----------------\n\n\tUsing a numerical gradient to produce smooth \"fract\" contours on 2D simplex-based noise.\n\n\tTaking a regular function value (noise, Voronoi, plasma, etc), then appying something like \n\t\"fract(value*5.)\" can give it some interesting contour-like variance. The problem, of \n\tcourse, is pretty severe antialising. Here's an attempt to rectify that without resorting \n\tto expensive methods.\t\n\n\tThe contour lines are relatively smooth and concise, regardless of the shape of the curve. \n\tThere are probably better ways to go about it (I'd be happy to hear about any), but this \n\tmethod works pretty well.\n\n\tIn addition, I've written a reasonaly simple 2D simplex-related noise algorithm to accompany\n\tthis. It probably doesn't adhere to strict simplex noise standards, but it looks the part, \n\tand is artifact\tfree -- as far as I can tell, so it's good enough for me. :) It also provides \n\ta good basis for cheap 3D simplex related noise.\n\n\tI wrote the simplex-like algorithm off the top of my head ages ago, so I wouldn't take it \n\ttoo seriously. For what I'm assuming is more reliable, concisely written, 2D simplex noise, \n\trefer to this example:\n\n\tSimplified Simplex Noise - Makio64\n\thttps://www.shadertoy.com/view/4sdGD8\n\n    See IQ's distance estimation example for a good explanation regarding the gradient related\n\tcontour snippet:\n\n    Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    There's an accompanying articles, which is really insightful here:\n    http://www.iquilezles.org/www/articles/distance/distance.htm\n\n\tAnother, more simple, example, concentrating more on the contours.\n\tSmooth, Defined Contours - Shane\n\thttps://www.shadertoy.com/view/Md33RB\n\n*/\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(2097152, 262144)*n);\n    return cos(p*6.283 + iTime*2.);\n    //return abs(fract(p+ iTime*.5)-.5)*4.-1.; // Snooker.\n    //return abs(cos(p*6.283 + iTime*2.))*2.-1.; // Bounce.\n\n}\n\n\n// For all intents and purposes, this is low quality, 2D simplex noise. I've skipped a few steps, \n// so don't want to give people the impression that this is a computer science quality algorithm.\n// Therefore, I've named it simplesque2D... Terrible name, I know. :)\n//\n// Essentially, you're taking a square grid, converting it to a skewed triangular grid, assigning \n// random values to the vertices via some random gradient vectors, then shading the triangles in \n// using a falloff factor. It's a very simple - not to mention, clever - concept (Ken Perlin's a \n// clever guy), but a little fiddly to code first time around.\n//\n// By the way, the 3D version follows virtually the same concept, just with a few extra steps.\n//\n// Credits: Ken Perlin, the creator of simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified.\" IQ, other \"ShaderToy.com\" people, Brian Sharpe (does interesting \n// work), etc.\n//\n// My favorite simplex-related write up: \"Simplex Noise, keeping it simple.\" - Jasper Flick?\n// http://catlikecoding.com/unity/tutorials/simplex-noise/\n//\nfloat simplesque2D(vec2 p){\n    \n    vec2 s = floor(p + (p.x + p.y)*.3660254); // Skew the current point.\n    p -= s - (s.x + s.y)*.2113249; // Vector to unskewed base vertice.\n    \n    // Clever way to perform an \"if\" statement to determine which of two triangles we need.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: step(p.x, p.y);\n    \n    vec2 ioffs = vec2(1. - i, i); // Vertice offset, based on above.\n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - ioffs + .2113249, p2 = p - .5773502; \n    \n    // Vector to hold the falloff value of the current pixel with respect to each vertice.\n    vec3 d = max(.5 - vec3(dot(p, p), dot(p1, p1), dot(p2, p2)), 0.); // Range [0, 0.5]\n    \n    d *= d*d*12.; //(2*2*2*1.5) \n    //d *= d*d*d*36.;\n    \n    // I've seen it done this way before, and it gives a good range, but gradients look a \n    // little strange to me... I guess it's down to aesthetic opinion.\n    //d = d*d*d*(6.*d*d - 15.*d + 10.); // Quintic smoothing.\n    //d /= dot(d, vec3(1));\n    \n    // Determining the weighted contribution of each random gradient vector for each point...\n    // Something to that effect, anyway.\n    vec3 w = vec3(dot(hash22(s), p), dot(hash22(s +  ioffs), p1), dot(hash22(s + 1.), p2)); \n    \n    // Combining the vectors above to produce a simplex noise value. Explaining why the vector \"d\" \n    // needs to be cubed (at least) could take a while, but it's falloff related and ties in with \n    // differentiation. If you take out one of the \"d\"s, you'll see that it needs to be cubed to work.\n    return .5 + dot(w, d); // Range [0, 1]... Hopefully. Needs more attention.\n\n}\n\n/* \n// Short smooth value noise version, to keep Fabrice happy. ;-)\nfloat n(vec2 p) {\n    vec2 ip = fract(p); p -= ip; p *= p*(3.- p - p); \n    vec4 h = fract(sin(vec4(0, 7, 27, 34) + ip.x*7. + ip.y*27.)*5e5);\n\t//h = sin(h*6.283 + iTime)*.5 + .5;\n\treturn dot(vec2(1. - p.y, p.y), vec2(1. - p.x, p.x)*mat2(h));\n}\n*/\n \n\n// Standard smooth 2D value noise. Based on IQ's original.\n// This one is self contained, so there's no need for an outside hash function.\nfloat valueNoise2D(vec2 p) {\n\t\n\tvec2 f = fract(p); // Fractional cell position.\n    \n    f *= f*(3. -2.*f);// Smooth step\n    //f = f*f*f*(10. + f*(6.*f - 15.)); // Smoother smooth step.\n    //f = (1. - cos(f*3.14159265))*.5; // Cos smooth step\n\t\n    // Random values for all four cell corners.\n\tvec4 h = fract(sin(vec4(0, 41, 289, 330) + dot(floor(p), vec2(41, 289)))*43758.5453);\n\th = sin(h*6.283 + iTime)*.5 + .5; // Animation.\n\t//h = abs(fract(h+iTime*.125) - .5)*2.; // More linear animation.\n\t\n    // Interpolating the random values to produce the final value.\n\treturn dot(vec2(1. - f.y, f.y), vec2(1. - f.x, f.x)*mat2(h));\n    \n}\n\n// 2D function we'll be producing the contours for. \nfloat func2D(vec2 p){\n    \n    //return valueNoise2D(p*6.)*.66 + valueNoise2D(p*12.)*0.34;\n    \n    return simplesque2D(p*4.)*.66 + simplesque2D(p*8.)*0.34;\n    \n}\n\n// Smooth fract function. A bit hacky, but it works. Handy for all kinds of things.\n// The final value controls the smoothing, so to speak. Common sense dictates that \n// tighter curves, require more blur, and straighter curves require less. The way \n// you do that is by passing in the function's curve-related value, which in this case\n// will be the function value divided by the length of the function's gradient.\n//\n// IQ's distance estimation example will give you more details:\n// Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n// There's an accompanying article, which is really insightful, here:\n// http://www.iquilezles.org/www/articles/distance/distance.htm\nfloat smoothFract(float x, float sf){\n \n    x = fract(x);\n    \n    return min(x, x*(1.-x)*sf);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) / iResolution.y;\n\n    // Standard epsilon, used to determine the numerical gradient. \n    vec2 e = vec2(0.001, 0); \n\n    // The 2D function value. In this case, it's a couple of layers of 2D simplex-like noise.\n    // In theory, any function should work.\n    float f = func2D(uv); // Range [0, 1]\n    \n    // Length of the numerical gradient of the function above. Pretty standard. Requires two extra function\n    // calls, which isn't too bad.\n    float g = length( vec2(f - func2D(uv-e.xy), f - func2D(uv-e.yx)) )/(e.x);\n   \n    // Dividing the function by the length of its gradient. Related to IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    g = f/max(g, 0.001);\n    //g = 0.5/max(g, 0.001); // A constant numerator seems to work, too, but I'll stick to the formula.\n    \n    // This is the crux of the shader. Taking a function value and producing some contours. In this case,\n    // there are six. If you don't care about aliasing, it's as simple as: c = fract(f*6.);\n    // If you do, and who wouldn't, you can use the following method. For a quick explanation, refer to the \n    // \"smoothFract\" function.\n    //\n    // For a very good explanation, see IQ's distance estimation example:\n    // Ellipse - Distance Estimation - https://www.shadertoy.com/view/MdfGWn\n    //\n    // There's an accompanying articles, which is really insightful, here:\n\t// http://www.iquilezles.org/www/articles/distance/distance.htm\n    float c = smoothFract(f*6., g*iResolution.y/4.); // Range [0, 1]\n    //float c = fract(f*6.); // Aliased version, for comparison.\n    \n    // Convert \"c\" above to the greyscale color.\n    vec3 col = vec3(c);\n    \n    // Color in a couple of the 6 contours above. Not mandatory, but it's pretty simple, and an interesting \n    // way to pretty up functions. I use it all the time.\n    f *= 6.;\n    \n    // You could almost ignore the \"tx\" business. It's just a subtle, higher frequency pattern to overlay \n    // the two colors with. Made up on the spot.\n    float tx = smoothstep(0.0, 0.8, (func2D((uv + (1. - c)*.01)*vec2(12., 48.)))); // Range: [0, 1]\n    if(f>2. && f<3.) col *= vec3(1., 0.0, 0.02)*(tx); // Red.\n    else if(f>4. && f<5.) col *= vec3(0.15, 0.05, 1)*(tx); // Blue.\n    else col *= abs(tx - .5)*.4 + .8; // White.\n   \n    /*\n    // Other things to try. Each require textures. Be sure to comment out the four line block above too.\n    // Organic 1 texture.\n    vec3 tx3 = texture(iChannel0, uv*4. + (1.-c)*.05).xyz; tx3 *= tx3;\n    if(f>2. && f<3.) col *= tx3;\n    if(f>4. && f<5.) col *= tx3.zyx;\n\t*/\n   \n    /*\n    // Organic 1 texture.\n    vec3 tx3 = texture(iChannel0, uv*4. + (1.-c)*.05).xyz; tx3 *= tx3;\n    float tx = dot(tx3, vec3(.299, .587, .114));\n    if(f>2. && f<3.) col *= pow(min(vec3(1.5, 1, 1)*tx, 1.), vec3(1, 3, 8.))*1.3;\n    if(f>4. && f<5.) col *= vec3(tx*tx*tx, tx*tx, tx)*1.3; \n    */\n     \n    \n\t// Since we have the gradient related value, we may as well use it for something. In this case, we're \n    // adding a bit of highlighting. It's calculated for the contourless noise, so doesn't match up perfectly,\n    // but it's good enough. Comment it out to see the texture on its own. \n    col += min(g*g*g*g*.1, 1.)*(1.-col);\n    \n    //col = vec3(g/1.5); // Just the gradient. Looks like plastic wrap.\n\t\n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0 );\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1736, 1768, 1789, 1879, 2119], [2122, 3215, 3242, 3242, 4875], [5195, 5334, 5362, 5362, 5970], [5972, 6025, 6046, 6115, 6188], [6190, 6882, 6919, 6919, 6983], [6986, 6986, 7043, 7070, 10519]]}
{"id": "Xdd3D7", "name": "Visual sorbet", "author": "ap", "description": "Simple program to bleach your eyes after watching something for a long time.", "tags": ["balls", "jitter"], "likes": 14, "viewed": 758, "published": "Public API", "date": "1450142820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nvec2 rand2(in vec2 p)\n{\n    return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n#define v4White vec4(1.0, 1.0, 1.0, 1.0)\n#define v4Black vec4(0.0, 0.0, 0.0, 1.0)\n#define v4Grey  vec4(0.5, 0.5, 0.5, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    float freq = 10.0;\n    float gap = 1.0/freq;\n    float ballrad = 0.3 * gap;\n    float jitterrad = 0.2 * gap;\n\n    vec2 param_pos = fract(uv + vec2(iTime / 10.0, 0.0));\n\n    param_pos = uv;\n\n    vec2 closest_center = floor(param_pos * freq + vec2(0.5)) / freq;\n\n    float black_or_white = 0.5 + 0.5 * sin(\n        2.0 * 3.14159 * \n        (rand((closest_center.x + 347.0) * (closest_center.y +129.0)) + iTime * 1.0));\n\n    closest_center = closest_center + jitterrad * 1.0 *\n        sin((iTime * 0.8 + rand2(closest_center)) * 6.28 +\n        sin((iTime * 0.2 + rand2(closest_center.yx)) * 6.28) +\n        sin((iTime * 0.5 + rand2(closest_center.xx * 93.0 + 127.0)) * 6.28)\n           );\n\n    float dist = length(param_pos - closest_center);  \n\n    float s = (dist * dist) / (ballrad * ballrad);\n\n    fragColor = mix(\n        mix(\n            mix(v4White, v4Black, 0.0), \n            mix(v4Black, v4White, 0.0), black_or_white), \n        mix(v4White, v4Black, 0.5), \n        smoothstep(ballrad*0.95, ballrad*1.05, dist));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdd3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 23, 67], [69, 69, 92, 92, 187], [313, 313, 370, 370, 1439]]}
{"id": "Xdd3Rj", "name": "Volumetric fractal nexus", "author": "public_int_i", "description": "volumetric glowing version of my dynamic fractal nexus shader.", "tags": ["fractal", "volumetric", "nexus"], "likes": 2, "viewed": 160, "published": "Public", "date": "1450968382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n\n\n//Click and move mouse to control camera direction\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 86\n#define EPSILON .01\n#define NORMAL_EPSILON .012\n\n#define VIEW_DISTANCE 64.\n\n\n#define pi 3.141592\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\n\nfloat df(in vec3 rp) {\n    vec3 p = rp+vec3(0.,4.,0.);\n    \n    for (int i = 0; i < 4; i++) {\n        float t = iTime*.003+float(i)*.14;\n        p.xy = rot(abs(p.xy),t+float(i)*.24);\n        p.zx = abs(rot(p.zx,t+float(i)*.194));\n    }\n    \n    vec3 lp = p;\n    lp.xy = rot(lp.xy, iTime*.04);\n    lp = mod(abs(lp),20.)-10.;\n    vec3 lp2 = abs(mod(abs(p),5.)-2.5)-1.;\n    for (int i = 0; i < 4; i++) {\n        float t = .24+iTime*.024+float(i)*.14;\n        lp2.xy = rot(abs(lp2.xy),t+float(i)*.24);\n        lp2.zx = abs(rot(lp2.zx,t+float(i)*.194));\n    }\n    return max( -sdBox(lp, vec3(8.)),\n        \tmin(sdTorus(lp2,vec2(1.,.2)), udBox(lp2, vec3(.3,.6,.9))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n\n    float time = iTime+143.;\n  \n    vec2 mxy = (iMouse.xy/iResolution.xy);\n    mxy.y -= 1.;\n    mxy *= 6.28;\n    if (iMouse.w < 1.) {\n        mxy = vec2(time*.1-2.4,-2.9);\n    }\n    cameraRotation = vec2(-mxy.x-1.71,mxy.y/4.+2.4);//x = yaw ,   y = pitch\n    cameraLocation = vec3(sin(time*.001-.084)*100.,\n                          0.,\n                          cos(time*.001397)*100.);\n\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n    rp += rd*3.;\n\n    vec4 c = vec4(0.);\n    float s = 0.;\n    for (int i = 0; i < 86; i++) {\n        vec3 p = rp+rd*s+vec3(0.,4.,0.);\n    \n        for (int k = 0; k < 4; k++) {\n            float t = time*.003+float(k)*.14;\n            p.xy = rot(abs(p.xy),t+float(k)*.24);\n            p.zx = abs(rot(p.zx,t+float(k)*.194));\n        }\n\n        vec3 lp = p;\n        lp.xy = rot(lp.xy, time*.04);\n        vec3 fp = floor(lp/20.);\n        lp = mod(abs(lp),20.)-10.;\n        vec3 lp2 = abs(mod(abs(p),5.)-2.5)-1.;\n        for (int k = 0; k < 4; k++) {\n            float t = .24+time*.024+float(k)*.14;\n            lp2.xy = rot(abs(lp2.xy),t+float(k)*.24);\n            lp2.zx = abs(rot(lp2.zx,t+float(k)*.194));\n        }\n        \n        float d = max( -sdBox(lp, vec3(8.)),\n                min(sdTorus(lp2,vec2(1.,.2)), udBox(lp2, vec3(.3,.6,.9)))),\n            d2 = max( -sdBox(lp+.02, vec3(8.)),\n                min(sdTorus(lp2+.02,vec2(1.,.2)), udBox(lp2+.02, vec3(.3,.6,.9))));\n    \n        float lighting = .2+max(0., (d2-d)/.02)*.8;\n        float alpha = max(0., 1.-d/2.)*.014*lighting;\n    \tc += vec4(normalize(abs(cos(fp))+abs(cos(fp.yzx+1.3927)))*alpha, alpha);\n        if (c.w > .99) break;\n        \n        s += d*.4;\n    }\n    \n    fragColor = vec4(c.xyz, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdd3Rj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[424, 460, 493, 493, 558], [559, 559, 590, 590, 628], [629, 629, 660, 660, 756], [762, 762, 797, 797, 882], [886, 886, 908, 908, 1549], [1552, 1552, 1609, 1609, 3521]]}
{"id": "Xdd3RS", "name": "Mystique", "author": "Harha", "description": "Circles bouncing around on my screen turned into this weirdness.\n\nJust a short playaround session. Music is a module by a soundcloud user called \"Chiptune\", who is apparently ReZ now that I did a bit of research.", "tags": ["fft", "audio", "weird", "fourier"], "likes": 15, "viewed": 1138, "published": "Public API", "date": "1450457525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define t iTime\n\nbool circle(in float r, in vec2 o, in vec2 v)\n{\n    return (length(o - v) <= r) ? true : false;\n}\n\nvec4 freq(in float f){\n\tfloat fft  = texture(iChannel0, vec2(f, 0.25)).x; \n\tvec3 col = vec3(fft, 4.0 * fft * (1.0 - fft), 1.0 - fft) * fft;\n    return max(vec4(col, 1.0), 0.0);\n}\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n\tvec2 uv = (f.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    c = vec4(0.0);\n    vec2 o = vec2(cos(PI * t) * 0.2, sin(PI * t * 0.33) * 0.2);\n    for (float w = 0.0; w < 1.0; w += 0.1)\n    {\n    \tfloat a = 0.25 + freq(length(uv) * 0.25).r * 0.25;\n\t\tc += smoothstep(0.0, 1.0, a * abs(sin(PI * t + 1.0)) * vec4(cos(PI * w * t), sin(w), tan(w), 1.0) * vec4(circle(a, o, uv / w)));\n    }\n}", "image_inputs": [{"id": "MssGz8", "previewfilepath": "https://soundcloud.com/chiptune/positive-waves-extended", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/chiptune/positive-waves-extended", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdd3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 89, 89, 139], [141, 141, 163, 163, 319], [321, 321, 360, 360, 772]]}
{"id": "Xdd3W7", "name": "Flame Ascending", "author": "dr2", "description": "Great balls of fire are born here", "tags": ["raymarching", "fire", "architecture"], "likes": 9, "viewed": 755, "published": "Public API", "date": "1450114905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Flame Ascending\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    a *= 0.5;\n    p *= 4. * mr;\n  }\n  return f;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  return length (p) - r;\n}\n\nfloat PrCapsShDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  p.z -= h * clamp (p.z / h, -1., 1.);\n  s = length (p);\n  return max (s - rEx, rIn - s);\n}\n\nfloat PrFlatDiskDf (vec3 p, float w, float r)\n{\n  p.x -= w * clamp (p.x / w, -1., 1.);\n  return length (p.xy) - r;\n}\n\nfloat PrFlatCylShDf (vec3 p, float w, float rIn, float rEx, float h)\n{\n  float s;\n  p.x -= w * clamp (p.x / w, -1., 1.);\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nint idObj;\nvec3 sunDir, fBallPos, qHit;\nfloat dmRad, dmLen, dmUpRad, dmUpLen, psgLen, psgWid, psgHt, capRad, wThk, udBase,\n   fBallRad, tCur, tCyc, capPos, ltFac, qLenH, qAngH;\nconst float dstFar = 20.;\nconst int idDm = 1, idDmUp = 2, idPsg = 3, idFlor = 4, idCol = 5, idHot = 6,\n  idArch = 7;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dc, dm, dr;\n  dMin = dstFar;\n  q = p;\n  qLenH = length (q.xz);\n  qAngH = atan (q.z, - q.x) / (2. * pi);\n  dr = (q.y > dmLen) ? abs (fract (18. * (atan (q.y - dmLen, qLenH) /\n     (2. * pi) - 0.25)) - 0.5) : 2. * abs (abs (q.y / dmLen - 0.5) - 0.5);\n  dr = wThk * clamp (4. * min (dr, abs (fract (8. * qAngH) - 0.5)) - 0.1, 0., 0.25);\n  dm = max (PrCapsShDf (q.xzy, dmRad - wThk + dr, dmRad - dr, dmLen),\n     max (0.14 * dmRad - length (p.xz), - q.y));\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * qAngH) + 0.5) / 4.);\n  qq = q;\n  q.x += dmRad - wThk;\n  d = max (PrFlatCylShDf (q.yzx, psgHt, psgWid - 1.3 * wThk,\n     psgWid - 0.9 * wThk, wThk), - q.y); \n  if (d < dMin) { dMin = d;  idObj = idArch;  qHit = q; }\n  q.x += psgLen;\n  dc = PrFlatDiskDf (q.yzx, psgHt, psgWid - wThk);\n  dr = wThk * clamp (min (4. * abs (fract ((q.x - 0.5 * psgLen) /\n     (0.95 * psgLen)) - 0.5),\n     8. * abs (fract ((q.y + psgHt) / (1.95 * psgHt)) - 0.5)) - 0.2, 0., 0.25);\n  d = max (max (PrFlatCylShDf (q.yzx, psgHt, psgWid - wThk, psgWid - dr, psgLen),\n     dmRad - 0.5 * wThk - qLenH), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idPsg;  qHit = q; }\n  q = p;\n  d = max (dm, - dc);\n  if (d < dMin) { dMin = d;  idObj = idDm;  qHit = q; }\n  q.y -= udBase;\n  d = max (max (PrCapsShDf (q.xzy, dmUpRad - wThk, dmUpRad, dmUpLen), - q.y),\n     0.05 * dmRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idDmUp;  qHit = q; }\n  q = p;\n  d = PrCylDf (q.xzy, 6. * dmRad, 0.01 * dmLen);\n  d = max (d, capRad - qLenH);\n  q.y -= capPos;\n  d = min (d, PrCylDf (q.xzy, capRad, 0.05 * dmLen));\n  if (d < dMin) { dMin = d;  idObj = idFlor;  qHit = qq; }\n  q = p;\n  q.y -= - 0.2 * dmLen;\n  d = max (PrCylDf (q.xzy, capRad, 0.2 * dmLen), 0.99 * capRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idHot; }\n  q = p;\n  q.y -= dmLen;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * qAngH) + 0.5) / 8.);\n  q.xy -= - vec2 (dmRad - 2. * wThk, 0.5 * dmLen);\n  d = PrCapsDf (q.xzy, 0.035 * dmRad, 0.5 * dmLen);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  return (d >= 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, f, ri, t;\n  p = ro + dHit * rd - fBallPos;\n  dp = 0.033 * fBallRad * rd;\n  ri = 0.9 / fBallRad;\n  t = 3. * tCur;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 20. * p;   q.y -= t;\n    f = Fbm3 (q);\n    q = 35. * p;   q.y -= 1.9 * t;\n    f += Fbm3 (q);\n    s = length (p);\n    g += max (0.075 * max (1. - s * ri, 0.) * (f - 1.1), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nbool ChkInside ()\n{\n  vec3 q;\n  bool isIn;\n  isIn = false;\n  if (idObj == idDm) {\n    q = qHit;\n    q.y -= dmLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmRad - 0.3 * wThk);\n  } else if (idObj == idDmUp) {\n    q = qHit;\n    q.y -= dmUpLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmUpRad - 0.01 * wThk);\n  } else if (idObj == idPsg) {\n    q = qHit;\n    q.y -= psgHt;\n    isIn = (((q.y < 0.) ? abs (qHit.z) : length (q.yz)) < psgWid - 0.9 * wThk);\n  } else if (idObj == idFlor) {\n    isIn = (abs (qHit.z) < psgWid &&\n       abs (qHit.x) < dmRad + 2. * psgLen - wThk || qLenH < dmRad);\n  } else if (idObj == idCol || idObj == idHot || idObj == idArch) isIn = true;\n  return isIn;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.021;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.5);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.3 + 0.7 * clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 ro, bool inside)\n{\n  vec3 col, colEx, colIn, colFrmIn, colFrmEx;\n  vec2 u;\n  float spec, d, f;\n  spec = 0.7;\n  col = vec3 (0.);\n  colEx = vec3 (0.8, 0.8, 0.85);\n  colIn = vec3 (0.1, 0.1, 0.4);\n  colFrmIn = vec3 (0.8, 0.8, 0.5);\n  colFrmEx = vec3 (1., 1., 0.);\n  if (idObj == idDm) {\n    if (inside) {\n      d = ((qHit.y < dmLen) ? qLenH :\n\t length (qHit - vec3 (0., dmLen, 0.))) - dmRad + 0.77 * wThk;\n      col = colIn;\n      if (d > 0.) {\n        if (qHit.y < dmLen) {\n\t  u = vec2 (1.5 * (fract (4. * qAngH + 0.5) - 0.5), qHit.y / dmLen - 0.6);\n\t  u *= u;\n\t  col = mix (col, vec3 (0.5, 0.7, 0.1), SmoothBump (0.01, 0.025, 0.005,\n\t     abs (80. * dot (u, u) - 0.14) - 0.005));\n\t}\n      } else col = colFrmIn;\n    } else col = colEx;\n  } else if (idObj == idDmUp) {\n    if (inside) col = colIn;\n  } else if (idObj == idPsg) {\n    if (inside) col = vec3 (0.3, 0.3, 1.);\n    else col = colEx;\n  } else if (idObj == idFlor) {\n    if (inside) {\n      f = SmoothBump (0.7, 1.1, 0.1, Fbm2 (17. * ro.xz));\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (0.2, 0.3, 0.6), f);\n      spec = 1. - 0.95 * f;\n    }\n  } else if (idObj == idHot) {\n    col = vec3 (1., 0., 0.) * (0.3 + 0.7 * Noiseff (50. * tCur));\n  } else if (idObj == idCol) {\n    col = vec3 (0.5, 0.7, 0.1) * (0.7 +\n       0.3 * sin (pi * mod (20. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5 +\n         qHit.y / dmLen), 1.)));\n  } else if (idObj == idArch) {\n    col = vec3 (0.5, 0.7, 0.1);\n  }\n  return vec4 (col, spec);\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w;\n  float f;\n  vec2 e = vec2 (0.01, 0.);\n  w = 0.5 * ro.xz;\n  f = Fbm2 (w);\n  vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.1, f - Fbm2 (w + e.yx)));\n  col = mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    ro += sd * rd;\n    col = GrndCol (ro, rd);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, col, vn, flmCol, ltDir, ltVec;\n  vec4 objCol;\n  float dstHit, dstFbHit, fIntens, f, ltDist;\n  int idObjT;\n  bool isIn, isRefl;\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  roo = ro;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  isRefl = false;\n  if (dstHit < dstFar) {\n    idObjT = idObj;\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    isIn = ChkInside ();\n    objCol = ObjCol (ro, isIn);\n    if (isIn) {\n      if (idObj == idFlor) {\n        f = fract (5. * qLenH / dmRad) - 0.15;\n\tif (abs (f) < 0.04) {\n          vn.xz -= 20. * f * ro.xz / qLenH;\n\t  vn = normalize (vn);\n\t}\n      }\n      ltVec = fBallPos - ro;\n      ltDist = length (ltVec);\n      ltDir = (fBallPos - ro) / ltDist;\n      f = max (dot (vn, ltDir), 0.);\n      col = objCol.rgb * (0.1 + vec3 (1., 0.8, 0.8) * f * (0.1 + 0.9 * f) +\n\t vec3 (1., 0., 0.7) * objCol.a *\n\t pow (max (0., dot (ltDir, reflect (rd, vn))), 128.));\n      if (idObj != idHot) col *= (0.01 + 0.99 * ltFac) /\n         (1. + 0.5 * pow (ltDist, 4.));\n    } else {\n      if (idObj == idDm && qHit.y > dmLen &&\n         length (qHit - vec3 (0., dmLen, 0.)) - dmRad < -0.23 * wThk ||\n\t idObj == idDmUp) {\n\tisRefl = true;\n\tcol = BgCol (ro, reflect (rd, vn));\n      } else if (idObj == idFlor) {\n\tcol = GrndCol (ro, rd);\n      } else {\n\tcol = objCol.rgb * (0.3 +\n\t   0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n\t   0.7 * max (0., max (dot (vn, sunDir), 0.)) +\n\t   objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n      }\n    }\n  } else col = BgCol (ro, rd);\n  col *= ObjAO (ro, vn);\n  if (! isIn && ! isRefl && dstHit < dstFar) col *= ObjSShadow (ro, sunDir);\n  if (dstFbHit < min (dstHit, dstFar)) {\n    fIntens = (dstFbHit < dstFar) ? FBallLum (roo, rd, dstFbHit) : 0.;\n    f = clamp (0.7 * fIntens, 0., 1.);\n    f *= f;\n    flmCol = 1.5 * (0.7 + 0.3 * Noiseff (20. * tCur)) *\n       mix (vec3 (1., 0.1, 0.1), vec3 (1., 1., 0.5), f * f);\n    col = mix (col, flmCol, ltFac * min (fIntens * fIntens, 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid SetConfig ()\n{\n  float tIn, tm;\n  dmRad = 1.2;\n  dmLen = 1.3;\n  dmUpRad = 0.17 * dmRad;\n  dmUpLen = 0.08 * dmLen;\n  psgLen = 0.4 * dmRad;\n  psgHt = 0.55 * dmLen;\n  psgWid = 0.22 * dmLen;\n  capRad = 0.3 * dmRad;\n  wThk = 0.06;\n  udBase = dmLen + sqrt (dmRad * dmRad - dmUpRad * dmUpRad) - wThk;\n  fBallRad = 0.25;\n  tCyc = 15.;\n  tIn = mod (tCur / tCyc, 1.);\n  capPos = -0.04 * dmLen - 0.3 * dmLen * SmoothBump (0.05, 0.15, 0.05, tIn);\n  ltFac = SmoothBump (0.15, 0.95, 0.05, tIn);\n  fBallPos = vec3 (0.);\n  tm = 0.07;\n  fBallPos.y = fBallRad + capPos + (dmLen + dmRad - fBallRad) *\n     ((tIn > tm) ? (tIn - tm) / (1. - tm) : (tm - tIn) / tm);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float ti[6], a, rHi, rLo, trkCyc;\n  ti[0] = 0.;\n  ti[1] = ti[0] + 0.05;\n  ti[2] = ti[1] + 0.2;\n  ti[3] = ti[2] + 0.5;\n  ti[4] = ti[3] + 0.2;\n  ti[5] = ti[4] + 0.05;\n  trkCyc = 4. * tCyc;\n  a = floor (t / trkCyc);\n  t = fract (t / trkCyc);\n  if      (t < ti[1]) a += 0.25 * (t - ti[0]) / (ti[1] - ti[0]);\n  else if (t < ti[2]) a += 0.25;\n  else if (t < ti[3]) a += 0.25 + 0.5 * (t - ti[2]) / (ti[3] - ti[2]);\n  else if (t < ti[4]) a += 0.75;\n  else if (t < ti[5]) a += 0.75 + 0.25 * (t - ti[4]) / (ti[5] - ti[4]);\n  rHi = 3.5 * dmRad;\n  rLo = 0.8 * dmRad;\n  p = vec3 (0., 0.8 * psgHt, - rHi + (rHi - rLo) * SmoothBump (0.15, 0.85, 0.1, t));\n  p.xz = Rot2D (p.xz, pi * a);\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec2 canvas, uv;\n  vec3 ro, rd, vd, u;\n  float f, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  SetConfig ();\n  ro = TrackPath (tCur);\n  vd = mix (vec3 (- ro.x, 0.3 * dmLen, - ro.z), fBallPos - ro, \n    smoothstep (-0.5, 0., 1. - length (ro.xz) / dmRad));\n  vd = normalize (vd);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  a = 0.011 * 2. * pi * tCur;\n  sunDir = normalize (vec3 (cos (a), 3. + cos (0.55 * a), sin (a)));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdd3W7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 270, 294, 294, 344], [346, 346, 370, 370, 417], [419, 419, 443, 443, 682], [684, 684, 709, 709, 855], [857, 857, 882, 882, 1081], [1083, 1083, 1109, 1109, 1429], [1431, 1431, 1452, 1452, 1591], [1593, 1593, 1614, 1614, 1836], [1838, 1838, 1880, 1880, 1931], [1933, 1933, 1976, 1976, 2042], [2044, 2044, 2102, 2102, 2205], [2207, 2207, 2254, 2254, 2323], [2325, 2325, 2395, 2395, 2522], [2524, 2524, 2554, 2554, 2628], [2630, 2630, 2687, 2687, 2770], [3067, 3067, 3089, 3089, 5165], [5167, 5167, 5200, 5200, 5377], [5379, 5379, 5400, 5400, 5610], [5612, 5612, 5664, 5664, 5803], [5805, 5805, 5852, 5852, 6293], [6295, 6295, 6314, 6314, 6991], [6993, 6993, 7030, 7030, 7238], [7240, 7240, 7272, 7272, 7469], [7471, 7471, 7507, 7507, 8961], [8963, 8963, 8996, 8996, 9406], [9408, 9408, 9439, 9439, 9913], [9915, 9915, 9950, 9950, 12042], [12044, 12044, 12063, 12063, 12694], [12696, 12696, 12722, 12722, 13419], [13421, 13421, 13477, 13477, 14169]]}
{"id": "XddGD4", "name": "All my shaders (so far)", "author": "RenoM", "description": "all 9 of my shaders so far\nclick on the menu in the bottom left to change shader", "tags": ["interactive"], "likes": 12, "viewed": 300, "published": "Public", "date": "1449684019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n     Use the mouse to click in the bottom left menu\n*/\n\n#define C(A,B,C) if(p.x==(A).x&&p.y==(A).y&&T>float(B)){if(B==16&&T>81.||B==61&&T>70.)return false;float d=distance(f,vec2(.5));if(d<=.5){pl=C;pl=B==int(T)&&abs(f.x-.5)<=.2&&abs(f.y-.5)<=.2?1.-pl:pl;return true;}}\n\n#define T (mod(iTime,55.)*2.)\nmat4 g[3];\n\nvec2 coord(float x, float n)\n{\n    float s=.0;\n    for(float i=4.;i>=0.;i--)\n    {\n        if(x>=n)\n        {\n            x-=n;\n            s+=pow(2.,i);\n        }\n        n*=.5;\n    }\n    return vec2(x,s);\n}\n\nvec4 convert(float x)\n{\n    vec4 s;\n    vec2 co=coord(x,524288.); s.x=co.y;\n    co=coord(co.x,16384.); s.y=co.y;\n    co=coord(co.x,512.); s.z=co.y;\n    co=coord(co.x,16.); s.w=co.y;\n\treturn s;\n}\n\nbool move(vec2 p, out float pl)\n{\n    g[0]=mat4(102916.,167024.,540849.,109098.\n             ,462342.,363985.,509392.,571500.\n             ,174417.,176689.,477775.,573006.\n             ,443949.,606768.,607794.,538156.);\n    g[1]=mat4(474544.,508338.,510546.,411055.\n             ,410030.,506223.,411972.,331044.\n             ,526627.,398662.,203172.,429124.\n             ,103523.,100456.,70730.,74857.);\n    g[2]=mat4(76938.,109707.,143436.,43179.\n             ,208009.,73897.,113807.,112720.\n             ,209098.,205066.,81038.,144429.\n             ,79043.,200932.,198883.,169507.);\n    vec2 f=fract(p);\n    p=ceil(p);\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<4;j++)\n        {\n            for(int k=0;k<4;k++)\n            {\n                int nb=2*k+8*j+32*i;\n                vec4 conv=convert(g[i][j][k]);\n                C(conv.xy,nb,.0) C(conv.zw,nb+1,1.)\n            }\n        }\n    }\n    return false;\n}\n\nvec3 white(vec2 p)\n{\n    p=2.*fract(p)-1.;\n    float r=length(p);\n    vec3 c=1.3*vec3(.6,.45,.15);\n    if(r<1.)\n    {\n        float f=smoothstep(1.,.9,r);\n        c=mix(c,vec3(.7,.7,.6),f);\n        c*=1.2-r/5.;\n        f=smoothstep(.98,.0,length(p-vec2(.2,.24)));\n        c+=f*.4;\n    }\n    return c;\n}\n\nvec3 black(vec2 p)\n{\n    p=2.*fract(p)-1.;\n    float r=length(p);\n    vec3 c=vec3(.6,.45,.15);\n    if(r<1.)\n    {\n        float f=smoothstep(1.,.85,r);\n        c=mix(c,vec3(0),f);\n        f=smoothstep(.0,.98,r);\n        c=mix(c,vec3(0,0,.2),1.-f);\n        f=smoothstep(.98,.0,length(p-vec2(.2,.24)));\n        c+=f*.7;\n    }\n    return c;\n}\n\nvec3 board(vec2 p)\n{\n    if(p.x>=.5&&p.x<18.5&&p.y>=.5&&p.y<18.5)\n    {\n        float d;\n        vec2 f=fract(p);\n        if(distance(p,vec2(9.5))<=.15\n         ||distance(p,vec2(3.5,9.5))<=.15\n         ||distance(p,vec2(9.5,3.5))<=.15\n         ||distance(p,vec2(3.5,3.5))<=.15\n         ||distance(p,vec2(15.5,9.5))<=.15\n         ||distance(p,vec2(9.5,15.5))<=.15\n         ||distance(p,vec2(15.5,15.5))<=.15\n         ||distance(p,vec2(3.5,15.5))<=.15\n         ||distance(p,vec2(15.5,3.5))<=.15)\n            return vec3(0);\n        if(abs(.5-f.x)<=.07||abs(.5-f.y)<=.07)\n            return mix(vec3(0),vec3(.6,.45,.15),smoothstep(.0,.07,min(abs(.5-f.x),abs(.5-f.y))));\n    }\n    return p.x>=-.5&&p.x<19.5&&p.y>=-.5&&p.y<19.5?vec3(.6,.45,.15):vec3(.1);\n}\n\nvec3 shusaku(vec2 U)\n{\n    vec2 R=iResolution.xy,\n         p=11.*(U+U-R)/R.y+9.5;\n    float pl;\n    vec3 c=board(p);\n    if(move(p,pl))c=pl==1.?white(p):black(p);\n    vec2 q=(p+22.)/24.;\n    return sqrt(q.x*q.y)*.8*c;\n}\n\n#define SCALE 20.\n#define SPEED 9.\n#define FREQUENCY .3\n\nfloat d;\n#define X(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\n\nvec3 CircleWave(vec2 U, vec2 F)\n{\n    vec2 p = SCALE*(U+U/F)/F.y,\n         f = fract(p);\n    p=floor(p);\n    float t=(p.x+p.y)*FREQUENCY\n           +iTime*SPEED;\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\n    return vec3(X(f)*D(f,o));\n}\n\n#define TAU 6.283185\n#define A(a) if(a>.25)a=.5-a;\n#define B(a,b) sqrt(max(.0,1.-a*length(uv-vec2(b))))\n#define R (iResolution.xy)\n\nvec2 rot(vec2 uv,float theta)\n{\n    vec2 t=vec2(cos(theta),sin(theta));\n    return uv*mat2(t,-t.y,t.x);\n}\n\nvec3 image(vec2 uv,bool inv,out float d)\n{\n    uv.x*=R.x/R.y;\n    d=length(uv);\n    uv/=4.5*sin(iTime)+5.5;\n    uv=rot(uv,mod(iTime,TAU));\n    if(inv)\n        uv*=pow(.4/length(uv),2.);\n    uv=mod(abs(uv),.5);\n    A(uv.x) A(uv.y)\n    return vec3(B(4.,.0)+B(1./(sqrt(0.125)-.25),.25));\n}\n\nvec3 icg(vec2 U, vec2 F)\n{\n    vec2 uv=2.*U/F-1.;\n    float d;\n    // split screen\n    return uv.x<.0?image(2.*uv+vec2(1,0),false,d):image(uv-vec2(.5,0),true,d)*min(d,1.);\n    // full screen\n    \t// before inversion\n    //return image(2.*uv,false,d);\n    \t// after inversion\n    //return image(uv,true,d)*min(d,1.);\n}\n\n#define scale 25.\n\nfloat superellipse(vec2 uv,vec2 o,float r,float n)\n{\n    float res=pow(abs((uv.x-o.x)/r),n)+pow(abs((uv.y-o.y)/r),n);\n    return res<=1.?sqrt(1.-res):.0;\n}\n\nvec3 putPixel(vec2 uv)\n{\n    return superellipse(fract(uv),vec2(.5),.5,3.5)*vec3(.1,.9,.07);\n}\n\nvec3 mpb(vec2 U, vec2 F)\n{\n    vec2 uv=(2.*U-F)/F.y*scale,\n        fuv=floor(uv)+.5,\n          t=vec2(sin(iTime),cos(iTime))*scale/2.,\n         o1=vec2(0,t.x),\n         o2=vec2(1.7*t.x,0),\n         o3=2.*t.yx;\n    vec3 l=vec3(distance(o1,fuv),distance(o2,fuv),distance(o3,fuv)),\n    \t g=scale*vec3(.5/(l.x*l.x),1./(l.y*l.y),.75/(l.z*l.z));\n    return g.x+g.y+g.z>10./scale?putPixel(uv):vec3(0);\n}\n\nconst float lim=1000.;\n\nbool isPrime(float n)\n{\n    n=floor(n);\n    if(n==2.)return true;\n    if (n==1.||mod(n,2.)==.0)return false;\n    for(float i=3.;i<=6000.;i+=2.)\n    {\n        if(i*i>n)\n            break;\n        if(mod(n,i)==.0)\n            return false;\n    }\n    return true;\n}\n\nvec3 pv(vec2 U, vec2 F)\n{\n    vec2 u=floor(150.*U/F.y);\n\tfloat n=(u.x+u.y+1.)*(u.x+u.y+2.)/2.-u.y;\n    return vec3(0,isPrime(n)&&n<500.*iTime,0);\n}\n\n#define size 33.\n\nfloat hash12(vec2 p)\n{\n    return  fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec3 rsug(vec2 U, vec2 F)\n{\n\tvec2 uv = U/F.y;\n    uv *= size;\n    float d=length(uv);\n    uv *= pow(size/d, 2.);\n    vec2 frac = fract(uv);\n    uv = floor(uv);\n    vec3 col = vec3(.0);\n    float time = ceil(iTime);\n    float res = superellipse(frac, vec2(.5), .5, 4. * hash12(uv * time));\n    vec3 hash = hash32(uv);\n\tcol = mod(time, 2.) == .0 ? hash * res : (1. - hash) * res;\n    return col*d/size;\n}\n\nvec2 sFract(vec2 x) // sFract function by Shane\n{\n\tx = fract(x);\n\treturn min(x, x*(1.-x)*16.); // The last term controls falloff.\n}\n\nvec3 snc(vec2 U, vec2 F)\n{\n    vec2 p=abs(U+U-F)/F.y;   \n    float b=length(p*=length(p)),\n          a=length(--p),\n          t=iTime;    \n    p*=20.*(p+1.)*abs(sin((a-t)/2.)*sin(b+t/4.))+abs(sin(a*b+2.*t/3.));\n    return length(sFract(p))*(1.-b)*(.5+.5*sin(t/vec3(3,7,17)));\n}\n\n#define PI 3.14159265\n#define Z(a,b) 1.-abs(2.*(a-b.x)/(b.y-b.x)-1.)\n#define S(op,a,b) l=vec2(op(uv.x+iTime*a))+vec2(-eps,eps);if(uv.y>l.x&&uv.y<l.y)b+=Z(uv.y, l);\n#define s sin(iTime)\n#define eps (.1+.25*s*s)\n\nvec3 sci(vec2 U, vec2 F)\n{\n\tvec2 uv=3.*U/F-1.5,l;\n    uv.x*=2.*F.x/F.y;\n    uv*=pow(5./length(uv),2.);\n    vec3 c=vec3(0);\n    S(sin,.25,c.r)\n    S(sin,.5,c.g)\n    S(sin,.75,c.b)\n    S(cos,.25,c.rg)\n    S(cos,.5,c.rb)\n    S(cos,.75,c.gb)\n    return min(c,1.);\n}\n\nfloat fbm(vec2 p)\n{\n    mat2 m=mat2(.8,.6,-.6,.8);\n    p/=300.;\n    float f=.5*texture(iChannel0,p).x; p*=m*2.02;\n    f+=.25*texture(iChannel0,p).x; p*=m*2.03;\n    f+=.125*texture(iChannel0,p).x; p*=m*2.01;\n\tf+=.0625*texture(iChannel0,p).x;\n    return f/.9375;\n}\n\nvec3 marble(vec2 U, vec2 F)\n{\n    vec2 p=U/R.y,q=(U+U-F)/F.y;\n    vec3 c=vec3(.1);\n    float r=length(q),\n          r2=length(p),\n          a=atan(p.y,p.x);\n    if(r<.8)\n    {\n        c=vec3(.1,.2,.8);\n        float f=fbm(p*5.);\n        c=mix(c,vec3(.3,.9,.1),f);\n        a+=.9*fbm(3.*p)+.1*fbm(30.*p);\n        f=smoothstep(.0,.8,fbm(vec2(6.*r2,20.*a)));\n        c=mix(c,vec3(1),f);\n        f=fbm(vec2(r2*7.,a*12.));\n        c=mix(c,vec3(.9,.3,.2),f);\n        f=smoothstep(.9,.0,r);\n        c*=f;\n        f=smoothstep(.5,.0,length(q-vec2(.3,.4)));\n        c+=vec3(.9,.8,.7)*.8*f;\n        f=smoothstep(.75,.8,r);\n        c=mix(c,vec3(.1),f);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r=iResolution.xy/8.,\n         s2=r/3.;\n    vec3 c=vec3(0);\n    if(U.x<r.x && U.y<r.y)\n    {\n        c=U.x<s2.x?(U.y<s2.y?board(11.*(U+U-s2)/s2.y+9.5):U.y<2.*s2.y?CircleWave(vec2(U.x,U.y-s2.y),s2):icg(vec2(U.x,U.y-2.*s2.y),s2)):\n          U.x<2.*s2.x?(U.y<s2.y?mpb(vec2(U.x-s2.x,U.y),s2):U.y<2.*s2.y?pv(U-s2,s2):rsug(vec2(U.x-s2.x,U.y-2.*s2.y),s2)):\n          U.y<s2.y?snc(vec2(U.x-2.*s2.x,U.y),s2):U.y<2.*s2.y?sci(vec2(U.x-2.*s2.x,U.y-s2.y),s2):marble(U-2.*s2,s2);\n    }\n    else if(iMouse.x<R.x && iMouse.y<R.y)\n    {\n        c=iMouse.x<s2.x?(iMouse.y<s2.y?shusaku(U):iMouse.y<2.*s2.y?CircleWave(U,R):icg(U,R)):\n          iMouse.x<2.*s2.x?(iMouse.y<s2.y?mpb(U,R):iMouse.y<2.*s2.y?pv(U,R):rsug(U,R)):\n          iMouse.y<s2.y?snc(U,R):iMouse.y<2.*s2.y?sci(U,R):marble(U,R);\n    }\n    O.xyz=c;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 316, 346, 346, 524], [526, 526, 549, 549, 720], [722, 722, 755, 755, 1645], [1647, 1647, 1667, 1667, 1949], [1951, 1951, 1971, 1971, 2290], [2292, 2292, 2312, 2312, 3044], [3046, 3046, 3068, 3068, 3265], [3438, 3438, 3471, 3471, 3669], [3803, 3803, 3834, 3834, 3908], [3910, 3910, 3952, 3952, 4196], [4198, 4198, 4224, 4224, 4515], [4536, 4536, 4588, 4588, 4691], [4693, 4693, 4717, 4717, 4787], [4789, 4789, 4815, 4815, 5185], [5211, 5211, 5234, 5234, 5473], [5475, 5475, 5500, 5500, 5622], [5642, 5642, 5664, 5664, 5736], [5738, 5738, 5759, 5759, 5941], [5943, 5943, 5970, 5970, 6345], [6347, 6347, 6396, 6396, 6478], [6480, 6480, 6506, 6506, 6757], [6970, 6970, 6996, 6996, 7231], [7233, 7233, 7252, 7252, 7495], [7497, 7497, 7526, 7526, 8159], [8161, 8161, 8202, 8202, 9005]]}
{"id": "XddGW4", "name": "001[F]", "author": "pawsiem", "description": "My first shader", "tags": ["first"], "likes": 2, "viewed": 102, "published": "Public", "date": "1449668338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool squircle(in vec2 center,in vec2 position,in float power,in float size){\n    return(\n        pow(abs(center.x-position.x),power) + \n        pow(abs(center.y-position.y),power)\n        < pow(size,power));\n}\n\nfloat zo(float time){\n\treturn sin(time)*0.5+0.5;\n}\nvec3 grey(float time){\n    float v = zo(time*6.);\n    return vec3(v,v,v);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 star = vec2(100,100);\n    if(squircle(iResolution.xy*0.5,fragCoord.xy,0.3,100.0)){\n        if(squircle(iResolution.xy*0.5,iMouse.xy,0.3,100.)){\n            fragColor = vec4(1.,0.,0.,1.);\n        }else{\n        \tfragColor = vec4(grey(iTime)*0.2+0.75,1);\n        }\n    }else if(squircle(iResolution.xy*0.5,fragCoord.\n                      xy\n                      +sin(fragCoord.x*50.0+iTime)*cos(fragCoord.y*50.0+iTime)*90.0\n                      +cos(fragCoord.y*50.0+iTime)*cos(fragCoord.x*50.0+iTime)*sin(iTime*1.5)*150.0\n                      ,7.0,150.0)){\n        fragColor = vec4(0.8+0.2*sin(iTime/20.),uv,1.0);\n    }else{\n        fragColor = vec4(uv,1.0,1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 209], [211, 211, 232, 232, 261], [262, 262, 284, 284, 337], [338, 338, 395, 395, 1128]]}
{"id": "XddGWN", "name": "boxything", "author": "lycium", "description": "kinda lame, but oh well it was fun", "tags": ["boxes"], "likes": 4, "viewed": 502, "published": "Public API", "date": "1449714055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float FoldedRadicalInverse2(int n)\n{\n\tfloat inv_base = 0.5;\n\tfloat inv_base_i = inv_base;\n\tfloat val = 0.0;\n\tint offset = 0;\n\n\tfor (int i = 0; i < 8; ++i)\n\t{\n\t\tint div = (n + offset) / 2;\n\t\tint digit = (n + offset) - div * 2;\n\t\tval += float(digit) * inv_base_i;\n\t\tinv_base_i *= inv_base;\n\t\tn /= 2;\n\t\toffset++;\n\t}\n\n\treturn val;\n}\n\nfloat boxything(vec2 p, float t)\n{\n    int returnval = 1;\n\n    const int num_squares = 32;\n    const float inv_num_squares = 1.0 / float(num_squares);\n    for (int i = 0; i < num_squares; i++)\n    {\n\t    float t_sin = sin(t + float(i) * 6.283185307179586476925286766559 * 0.1531);\n        float a = t_sin * 1.0 + 0.0;//(i + 1.0) * 6.283185307179586476925286766559 * inv_num_squares;\n\n        int imod2 = i - ((i / 2) * 2);\n        float i_offset = float(i) + float(imod2) * inv_num_squares * 4.0;\n        float r = 1.0 / ((float(i_offset) + 1.0) * inv_num_squares);\n\n        vec2 x_basis = vec2( cos(a), sin(a));\n        vec2 y_basis = vec2(-sin(a), cos(a));\n        \n        float u = dot(p, x_basis) * r;\n        float v = dot(p, y_basis) * r;\n\n        returnval = (abs(u) < 1.0 && abs(v) < 1.0) ? returnval : imod2;\n    }\n\n    return float(returnval);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 pixel_scale = vec2(1.5 / iResolution.x);\n\n   \tfloat s = 0.0;\n    const int samples = 34;\n    const float norm = 1.0 / float(samples);\n\tfor (int z = 0; z < samples; z++)\n    {\n        float u = float(z) * norm;\n\t\tfloat a = u * 21.0 * 6.283185307179586476925286766559;\n        float r0 = sqrt(u);\n        float r = r0 * 1.5;\n        vec2 aa = vec2(cos(a), sin(a)) * r;\n        float w = 1.0 - r0;\n        \n\t\tfloat t0 = FoldedRadicalInverse2(z);\n        float t = iTime * 0.5 + u * 0.033333 * 2.0;\n\n\t\ts += boxything((fragCoord - iResolution.xy * 0.5 + aa) * pixel_scale, t) * w;\n    }\n    s *= norm * 2.5;\n    \n\tvec3 c_b = vec3(0.9, 0.5, 0.1) * 1.4;\n\tvec3 c_t = vec3(0.3, 0.2, 0.5) * 1.5;\n\n    vec3 c_w = vec3(1.3, 1.2, 1.9) * 1.0;\n\n    vec3 c = mix(c_t, c_b, fragCoord.y / iResolution.y);\n    c = mix(c, c_w, s);\n    \n    float gamma = 1.0 / 0.5;\n    float gamma_r = pow(c.x, gamma) * 1.12;\n    float gamma_g = pow(c.y, gamma) * 1.22;\n    float gamma_b = pow(c.z, gamma) * 1.31;\n    fragColor = vec4(gamma_r, gamma_g, gamma_b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 328], [330, 330, 364, 364, 1186], [1188, 1188, 1243, 1243, 2282]]}
{"id": "Xdt3Dn", "name": "SunflowerTransformWithGaps", "author": "jt", "description": "Tweaking the sunflower-transform [url]https://www.shadertoy.com/view/Mdd3R7[/url] to resemble the vogel-distribution more closely by skipping patches. (Although now it doesn't fill the plane anymore)", "tags": ["spiral", "sunflower", "loopless", "coordinatetransformation"], "likes": 2, "viewed": 195, "published": "Public", "date": "1449012999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sunflower Transform With Gaps - written 2015-12-01 by Jakob Thomsen\n// (a modification of https://www.shadertoy.com/view/Mdd3R7\n//  skipping patches to resemble the vogel-distribution more closely)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat circ(vec2 v)\n{\n    return 1. - smoothstep(.4, .5, length(fract(v)-.5));\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    float b = sqrt(2.);\n\tvec2 R = iResolution.xy; \n    I = mix(8., 64., (0.5+0.5*cos(iTime*.1))) * (I+I-R)/R.y;\n    //I = mix(8., 64., (0.5+0.5*cos(iTime*.1))) * (I+I-(I=iResolution.xy))/I.y; // NOT COMPATIBLE\n\n    //I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 2./3.1415926 );\n    I = vec2(0, length(I)) + atan(I.y, I.x) / 6.283; // Thanks to FabriceNeyret2 for optimizations!\n    float Q = I.x = ceil(I.y) - I.x;\n    I.x *= b;\n    float q = fract(I.x);\n    I.x *= I.x;\n\n    //O = vec4(fract(I),0,1) * step(q,(.5/b)/Q);\n    O = vec4(circ(I)) * step(q,(.5/b)/Q);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdt3Dn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 289, 309, 309, 368], [370, 370, 408, 408, 977]]}
{"id": "Xdt3R2", "name": "sin cos wave light", "author": "DeMaCia", "description": "simpleness sin cos wave", "tags": ["wave", "sin", "cos"], "likes": 11, "viewed": 678, "published": "Public API", "date": "1450939649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 color = vec4(uv,\n                      .5+.5*sin(iTime),\n                      1.);\n    \n    vec4 color2 = vec4(1. - ((uv.x + uv.y) / 2.),\n                       uv,\n                       1.);\n    \n    vec2 pos = uv*2.-1.;\n    \n    color *= abs(1./(sin(pos.y + sin(pos.x + iTime)*.7)*sin(iTime*.5)*20.));\n    \n    color += color2 * abs(1./(sin(pos.y + cos(pos.x*.5 + iTime)*.8)*10.));\n   \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdt3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 525]]}
{"id": "Xdt3W7", "name": "multishape dance", "author": "public_int_i", "description": "an interesting shape dancing to music", "tags": ["raymarch", "distance", "function", "soundcloud"], "likes": 8, "viewed": 555, "published": "Public API", "date": "1450184625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n//thanks to XT95 for the ambient occlusion function\n\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 86\n#define EPSILON .01\n#define NORMAL_EPSILON .012\n\n#define VIEW_DISTANCE 64.\n\n#define pi 3.141592\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\nstruct light {\n    vec3 position, color;\n    float size;\n};\n    \n\n//#define global_illumination 1\n#define gi_background 1\n#define gi_trace_iter 16\nconst float global_illumination_strength = .3,\n    \t\tglobal_illumination_reach = 16.;\n\nconst vec3 ambient = vec3(0.25);\n\n\n#define nLights 3\n\n#if nLights != 0\nlight lights[nLights];\n#endif    \n\nvoid initLights() {\n    #if nLights != 0\n    lights[0] = light(vec3(30.,-30.,10.),\n                      vec3(1.,.7,.85)*max(0., texture(iChannel0,vec2(.0,.25)).x*1.5-.5),\n                      70.);\n    \n    lights[1] = light(vec3(-30.,-20.,10.),\n                      vec3(0.75,.95,.83)*max(0., texture(iChannel0,vec2(.4,.25)).x*1.5-.5),\n                      70.);\n    \n    lights[2] = light(vec3(0.,-20.,-30.),\n                      vec3(0.75,.83,.95)*max(0., texture(iChannel0,vec2(.8,.25)).x*1.5-.5),\n                      70.);\n\t#endif\n}\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat ground(in vec3 rp) {\n    return abs(rp.y-5.);\n}\n\nfloat mainObject(in vec3 rp) {\n \t\n    vec3 p = rp+vec3(0.,4.,0.);\n    float ts1 = texture(iChannel0, vec2(0.25,0.25)).x,\n          ts2 = texture(iChannel0,vec2(0.05,.25)).x;\n    \n    p.xy = rot(abs(p.xy), iTime*.1);\n    p.zx = rot(abs(p.zx), iTime*.4689-ts1*1.);\n    p.zy = rot(abs(p.zy), iTime*.6344-ts2*4.);\n        \n    return min(sdTorus(p,vec2(7.,1.)), udBox(p, vec3(3.,5.+ts2*4.,4.)));\n}\n\n\nfloat df(in vec3 rp) {\n\n    return min(ground(rp),mainObject(rp));\n}\nfloat df_hq(in vec3 rp) {\n\treturn df(rp);\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\n\nmaterial mat(vec3 rp) {\n    material m;\n    \n    if (mainObject(rp) < EPSILON) {\n\t\tm = material(vec3(.74,.54,.65), //diffuse\n                     vec3(.74,.54,.65), //specular\n                  \t vec3(0.), //emissive\n                    0.0,//metallic\n                     0.9);//roughness\n    }\n    \n    if (ground(rp) < EPSILON) {\n        m = material(vec3(1.), //diffuse\n                     vec3(0.), //specular\n                     vec3(0.), //emissive\n                     0.,//metallic\n                     0.9);//roughness\n    }\n    \n    return m;\n}\n\n\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n        \n        //rd = normalize(rd+vec3(.01,-.001,0.)*d);\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    return normalize(d+cos(p*245.245-d*cos(p*9954.345)*3532.423)*amount);\n}\n//ambient occlusion function is XT95's from https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(in vec3 rp, in vec3 norm) {\n    float sum = 0., s = 0.;\n    vec3 lastp;\n    \n    for (int i = 0; i < 32; i++) {\n        vec3 p = rp+randomHemiRay(norm,lastp,.4)*s;\n        sum += max(0., (s-df(p))/(s*s));//randomHemiRay(norm,rp,.5)*s);\n        lastp = p;\n        s += .2;\n    }\n    \n    return clamp(1.-sum*.05, 0., 1.);\n}\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0., penumbraSize-d)*float(s>penumbraSize*4.);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh/penumbraIntensity);\n}\n\nvec3 background(in vec3 rd) {\n\tvec3 c = vec3(0.);\n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        c += lights[i].color*max(0., dot(rd, normalize(lights[i].position)))*.6;\n    }\n    #endif\n    return c;\n}\nvec3 background_gi(in vec3 rd) {\n    return background(rd);\n}\n\nvec3 locateSurface(in vec3 rp) {    \n    vec3 sp = rp;\n    for (int i = 0; i < 3; i++) {\n        float sd = abs(df(rp));\n        if (sd < EPSILON) return sp;\n        sp += normal2(sp)*sd*.5;\n    }\n    return sp;\n}\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = ambient*ao;\n    spec = vec3(0.);\n        \n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        vec3 lightVec = lights[i].position-td;\n        float lightAtten = length(lightVec);\n        lightVec = normalize(lightVec);\n        float shadow = softShadowTrace(sd, lightVec, lightAtten, 0.3, 1.5);\n        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;\n        \n    \tdif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;\n        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lights[i].color;\n    }\n\t#endif\n    \n    //dif *= .5+ao*.5;\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 reflDir = reflect(rd,norm);\n\n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n\n    return (1.-m.metallic)*lightDif*m.diffuse +\n        \t(.5+m.metallic*.5)*lightSpec*m.specular +\n        \tm.emissive ;\n}\nvec3 giTrace(in vec3 rp, in vec3 rd) {\n    float s = 0., d;\n    for (int k = 0; k < gi_trace_iter; k++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON) break;\n        s += d;\n    }\n    if (d < EPSILON) {\n        vec3 hp = rp+rd*s;\n        return shadeNoReflection(hp, rd, normal(hp), mat(hp))*max(0.,1.-s/global_illumination_reach);\n    }\n    #ifdef gi_background\n    return background_gi(rd);\n    #endif\n    return vec3(0.);\n}\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n    #ifdef global_illumination\n    vec3 ray = norm;\n    vec3 majorAxis = abs(ray);\n    if (majorAxis.x > majorAxis.y) {\n        if (majorAxis.x > majorAxis.z) {\n            majorAxis = vec3(1.,0.,0.);\n            if (ray.x == 1.) ray = vec3(0.999,0.001,0.0);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    } else {\n        if (majorAxis.y > majorAxis.z) {\n            majorAxis = vec3(0.,1.,0.);\n            if (ray.y == 1.) ray = vec3(0.,0.999,0.001);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    }\n    \n    vec3 rayRight = normalize(cross(majorAxis,ray))*.5;\n    vec3 rayUp = normalize(cross(ray,rayRight))*.5;\n\n    vec3 gi = giTrace(sd, norm);\n    gi += giTrace(sd, normalize(norm+rayRight));\n    gi += giTrace(sd, normalize(norm-rayRight));\n    gi += giTrace(sd, normalize(norm+rayUp));\n    gi += giTrace(sd, normalize(norm-rayUp));\n    dlc += gi*global_illumination_strength;\n    #endif\n    \n    vec3 slc = vec3(0.);\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = 1.-max(0., dot(-rd,norm));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n\n    initLights();\n    \n  \n    vec2 mxy = (iMouse.xy/iResolution.xy);\n    mxy.y -= 1.;\n    mxy *= 6.28;\n    if (iMouse.w < 1.) {\n        mxy = vec2(iTime*.2,-3.9);\n    }\n    cameraRotation = vec2(-mxy.x-1.71,mxy.y/4.+2.4);//x = yaw ,   y = pitch\n    cameraLocation = vec3(sin(mxy.x)*30.,\n                          -6.,\n                          cos(mxy.x)*30.);\n\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n    rp += rd*5.;\n    \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    #ifndef PATH_TRACE\n    fragColor = vec4(mix(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)), background(rd), max(0.,itd/VIEW_DISTANCE)),1.);\n\t#else\n    \n    #endif\n}", "image_inputs": [{"id": "lds3R8", "previewfilepath": "https://soundcloud.com/rlgrime/core-rl-grime", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/rlgrime/core-rl-grime", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdt3W7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[576, 850, 869, 869, 1394], [1396, 1432, 1465, 1465, 1530], [1531, 1531, 1562, 1562, 1600], [1607, 1607, 1642, 1642, 1727], [1730, 1730, 1756, 1756, 1783], [1785, 1785, 1815, 1815, 2178], [2181, 2181, 2203, 2203, 2249], [2250, 2250, 2275, 2275, 2293], [2341, 2341, 2367, 2367, 2528], [2531, 2531, 2556, 2556, 2735], [2738, 2738, 2761, 2761, 3295], [3299, 3391, 3446, 3446, 3728], [3730, 3730, 3789, 3789, 3865], [3866, 3948, 3998, 3998, 4293], [4295, 4295, 4411, 4411, 4756], [4758, 4758, 4787, 4787, 4982], [4983, 4983, 5015, 5015, 5044], [5046, 5046, 5078, 5078, 5259], [5260, 5260, 5378, 5378, 6031], [6033, 6074, 6151, 6151, 6486], [6487, 6487, 6525, 6525, 6918], [6919, 6919, 6981, 6981, 8938], [8941, 8941, 8998, 8998, 10016]]}
{"id": "Xdt3z2", "name": "wave light", "author": "masaki", "description": "wave light", "tags": ["wave"], "likes": 6, "viewed": 644, "published": "Public API", "date": "1450972857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y -= 0.5;\n    float wave1 = 1.0 - pow(abs(sin(uv.x * 1.0 +t) *0.3 + uv.y),0.1);\n    float wave2 = 1.0 - pow(abs(sin(uv.x * 4.0 +t) *0.15 + uv.y),0.1);\n    float wave3 = 1.0 - pow(abs(sin(uv.x * 2.0 +t*1.8) *0.1 + uv.y),0.12);\n    float wave4 = 1.0 - pow(abs(sin(uv.x * 13.0 +t*5.1) *0.22 + uv.y),0.12);\n    vec3 color = vec3(wave1,wave1*0.7,wave1*0.8)\n       + vec3(wave2*0.5,wave2,wave2*0.9)\n       + vec3(wave3*0.2,wave3*0.7,wave3)\n       + vec3(wave4,wave4*.1,wave4*0.85);\n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdt3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 637]]}
{"id": "XdtGRj", "name": "DOT01 - HelloDot", "author": "Makio64", "description": "DOT01 - HelloDot", "tags": ["dotcolorcircle"], "likes": 0, "viewed": 151, "published": "Public", "date": "1450868385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Easing from gslify\nfloat exponentialIn(float t) {return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));}\nfloat exponentialOut(float t) {return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);}\n\nvec3 color(vec3 col, vec2 center, float radius, vec2 uv){\n    float rx = iResolution.x/iResolution.y;\n    float d = distance(vec2(center.x*rx,center.y),uv);\n    float v = smoothstep( 0., radius, d );\n    return col * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //base\n\tvec2 uv = fragCoord.xy/iResolution.yy;\n\tvec3 col = vec3(.95);\n    vec3 col2 = vec3(0.1);\n    float rx = iResolution.x/iResolution.y;\n    \n    //push somecolor on it\n    col2 += 1.1*color(vec3(.3,abs(sin(iTime))*.4,.5),vec2(.5,.6),.6, uv);\n    col2 += 1.1*color(vec3(abs(cos(iTime/3.))*.5,.2,.2), vec2(sin(iTime/2.)*.3+.5,cos(iTime)*.5+.6), 1., uv);\n    col2 += 1.8*color(vec3(.45,abs(cos(iTime/3.))*.05+.4,.15), vec2(.7,.5), 1.2, uv);\n    col2 += .5*color(vec3(.2,.2,.15), vec2(cos(iTime/2.),.7), 1.2, uv);\n    col2 += .8*color(vec3(.25,.25,.25+sin(iTime/4.)*.2), vec2(cos(iTime/2.)+.3,.5), 1.2, uv);\n    \n    //basic\n    float d = distance(vec2(.5*rx,.5+sin(iTime/4.)*.05),uv);\n    float v = smoothstep( .3, 1., d );\n    float e = exponentialOut(v);\n    e = exponentialOut(e);\n    e = e*e*e*e*e*e*e*e;\n    //*\n    e = exponentialOut(e);\n    e = exponentialOut(e);\n    e = exponentialOut(e);\n\t//*/\n    col *= e;\n    col += col2*.8;\n    col *= col+.1;\n    col = min(vec3(1.),col);\n\tfragColor = vec4(col,1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 51, 51, 101], [102, 102, 133, 133, 182], [184, 184, 241, 241, 405], [407, 407, 464, 475, 1490]]}
{"id": "XljXzc", "name": "[Test] Segment Distance", "author": "Ultraviolet", "description": "This shader implements a distance to a segment.", "tags": ["test", "distance", "segment"], "likes": 4, "viewed": 123, "published": "Public", "date": "1449154549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{\n    p = bbmin + mod(p-bbmin, 2.0*(bbmax - bbmin));\n    if(p > bbmax)\n    \tp = bbmax - (p - bbmax);\n    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\n\nfloat PointSegDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    float s = 1.0;//sign(dot(p-p0, normal(p0, p1)));\n    vec2 d = p1 - p0;\n    \n    float t = dot(p - p0, d) / dot(d, d);\n\n    if(t > 1.0)\n        return length(p1 - p) * s;\n    if(t < 0.0)\n        return length(p0 - p) * s;\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return length(proj-p) * s;\n}\n\nfloat PointSegDistance2(in vec2 p, in vec2 p0, in vec2 p1)\n{\n    vec2 px0 = p-p0, p10 = p1-p0;\n    /*\n    float h = clamp(dot(px0, p10) / dot(p10, p10), 0.0, 1.0);\n    return length(px0 - p10*h);\n\t//*/\n    \n    float l10 = length(p10);\n    p10 /= l10;\n    float dh= abs(cross(vec3(px0,0.), vec3(p10,0.)).z);\n    float dt= max(0.,max(-dot(px0,p10), -l10+dot(px0,p10)));\n    \n    return length(vec2(dh,dt));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    \n    vec2 p0 = vec2(0.5, 0.5);\n    vec2 p1 = vec2(1.0, 0.2);\n    \n    p0 = p0 + p0 * iTime * 0.5;\n    p1 = p1 + p1 * iTime * 0.5;\n    \n    BoxReflect(p0, vec2(0.0), vec2(ratio, 1.0));\n    BoxReflect(p1, vec2(0.0), vec2(ratio, 1.0));\n    \n    float d = PointSegDistance2(uv, p0, p1);\n    \n\t//fragColor = vec4(vec3(d), 1);\n\t//fragColor = vec4(vec3(sin(d*50.0)), 1);\n\tfragColor = vec4(vec3(sin(d*50.0), sin(d*40.0), sin(d*30.0)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 171], [173, 173, 234, 234, 314], [317, 317, 367, 367, 666], [668, 668, 728, 728, 1075], [1077, 1077, 1134, 1134, 1666]]}
{"id": "Xs33R2", "name": "Magic Particles V2", "author": "TambakoJaguar", "description": "A new version of my Magic Particles.\nSpeed and stability are improved, but if you still have difficulties, please give me your browser and OS, maybe GPU model as well. Thanks!\n\nAny idea to optimize the code is also welcome.", "tags": ["2d", "colors", "random", "star", "particles", "sinus", "movement"], "likes": 56, "viewed": 1873, "published": "Public", "date": "1450729198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Magic particles\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n\n// ToDo:\n// * Min/Max hue\n// * Min/max saturation\n// * Hue time factor\n// * Main Particle color\n// * Sparkling particles\n// * Gravity\n// * Motion blur\n\n#define twopi 6.28319\n// Please be careful, setting complexity > 1 may crash your browser!\n// 1: for mac computers\n// 2: for computers with normal graphic card\n// 3: for computers with good graphic cards\n// 4: for gaming computers\n#define complexity 1\n\n// General particles constants\n#if complexity == 1\nconst int nb_particles = 90;                                  // Number of particles on the screen at the same time. Be CAREFUL with big numbers of particles, 1000 is already a lot!\n#elif complexity == 2\nconst int nb_particles = 160;\n#elif complexity == 3\nconst int nb_particles = 280;\n#elif complexity == 4\nconst int nb_particles = 500;\n#endif\nconst vec2 gen_scale = vec2(0.60, 0.45);                      // To scale the particle positions, not the particles themselves\nconst vec2 middlepoint = vec2(0.35, 0.15);                    // Offset of the particles\n\n// Particle movement constants\nconst vec2 gravitation = vec2(-0., -4.5);                     // Gravitation vector\nconst vec3 main_x_freq = vec3(0.4, 0.66, 0.78);               // 3 frequences (in Hz) of the harmonics of horizontal position of the main particle\nconst vec3 main_x_amp = vec3(0.8, 0.24, 0.18);                // 3 amplitudes of the harmonics of horizontal position of the main particle\nconst vec3 main_x_phase = vec3(0., 45., 55.);                 // 3 phases (in degrees) of the harmonics of horizontal position of the main particle\nconst vec3 main_y_freq = vec3(0.415, 0.61, 0.82);             // 3 frequences (in Hz) of the harmonics of vertical position of the main particle\nconst vec3 main_y_amp = vec3(0.72, 0.28, 0.15);\t              // 3 amplitudes of the harmonics of vertical position of the main particle\nconst vec3 main_y_phase = vec3(90., 120., 10.);\t              // 3 phases (in degrees) of the harmonics of vertical position of the main particle\nconst float part_timefact_min = 6.;                           // Specifies the minimum how many times the particle moves slower than the main particle when it's \"launched\"\nconst float part_timefact_max = 20.;                          // Specifies the maximum how many times the particle moves slower than the main particle when it's \"launched\"\nconst vec2 part_max_mov = vec2(0.16, 0.16);                   // Maxumum movement out of the trajectory in display units / s\n\n// Particle time constants\nconst float time_factor = 1.0;                                // Time in s factor, <1. for slow motion, >1. for faster movement\nconst float start_time = 2.5;                                  // Time in s needed until all the nb_particles are \"launched\"\nconst float grow_time_factor = 0.15;                          // Time in s particles need to reach their max intensity after they are \"launched\"\n#if complexity == 1\nconst float part_life_time_min = 0.8;                         // Minimum life time in s of a particle\nconst float part_life_time_max = 1.6;                         // Maximum life time in s of a particle\n#elif complexity == 2\nconst float part_life_time_min = 1.0;\nconst float part_life_time_max = 2.2;\n#elif complexity == 3\nconst float part_life_time_min = 1.1;\nconst float part_life_time_max = 3.2;\n#elif complexity == 4\nconst float part_life_time_min = 1.2;\nconst float part_life_time_max = 4.0;\n#endif\n\n// Particle intensity constants\nconst float part_int_div = 40000.;                            // Divisor of the particle intensity. Tweak this value to make the particles more or less bright\nconst float part_int_factor_min = 0.1;                        // Minimum initial intensity of a particle\nconst float part_int_factor_max = 3.2;                        // Maximum initial intensity of a particle\nconst float part_spark_min_int = 0.25;                        // Minimum sparkling intensity (factor of initial intensity) of a particle\nconst float part_spark_max_int = 0.88;                        // Minimum sparkling intensity (factor of initial intensity) of a particle\nconst float part_spark_min_freq = 2.5;                        // Minimum sparkling frequence in Hz of a particle\nconst float part_spark_max_freq = 6.0;                        // Maximum sparkling frequence in Hz of a particle\nconst float part_spark_time_freq_fact = 0.35;                 // Sparkling frequency factor at the end of the life of the particle\nconst float mp_int = 12.;                                     // Initial intensity of the main particle\nconst float dist_factor = 3.;                                 // Distance factor applied before calculating the intensity\nconst float ppow = 2.3;                                      // Exponent of the intensity in function of the distance\n\n// Particle color constants\nconst float part_min_hue = -0.13;                             // Minimum particle hue shift (spectrum width = 1.)\nconst float part_max_hue = 0.13;                              // Maximum particle hue shift (spectrum width = 1.)\nconst float part_min_saturation = 0.5;                        // Minimum particle saturation (0. to 1.)\nconst float part_max_saturation = 0.9;                        // Maximum particle saturation (0. to 1.)\nconst float hue_time_factor = 0.035;                          // Time-based hue shift\nconst float mp_hue = 0.5;                                     // Hue (shift) of the main particle\nconst float mp_saturation = 0.18;                             // Saturation (delta) of the main particle\n\n// Particle star constants\nconst vec2 part_starhv_dfac = vec2(9., 0.32);                 // x-y transformation vector of the distance to get the horizontal and vertical star branches\nconst float part_starhv_ifac = 0.25;                          // Intensity factor of the horizontal and vertical star branches\nconst vec2 part_stardiag_dfac = vec2(13., 0.61);              // x-y transformation vector of the distance to get the diagonal star branches\nconst float part_stardiag_ifac = 0.19;                        // Intensity factor of the diagonal star branches\n\n// Particle motion blur constants\n//#define motion_blur\nconst float mb_time = 0.02;                                   // Time shift of the motion blur in s\nconst int mb_nb_samples = 2;                                  // Number of steps (let number of samples to 1 unless you have a quite powerful GPU)\n\n// Variables\nfloat pst;\nfloat plt;\nfloat runnr;\nfloat time2;\nfloat time3;\nfloat time4;\n\n// From https://www.shadertoy.com/view/ldtGDn\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z*(0.63*hsv.y*(cos(twopi*(hsv.x + vec3(0.0, 2.0/3.0, 1.0/3.0))) - 1.0) + 1.0);\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n// Gets the time at which a paticle is starting its \"life\"\nfloat getParticleStartTime(int partnr)\n{\n    return start_time*random(float(partnr*2));\n}\n\n// Harmonic calculation, base is a vec4\nfloat harms(vec3 freq, vec3 amp, vec3 phase, float time)\n{\n   float val = 0.;\n   for (int h=0; h<3; h++)\n      val+= amp[h]*cos(time*freq[h]*twopi + phase[h]/360.*twopi);\n   return (1. + val)/2.;\n}\n\n// Gets the position of a particle in function of its number and the time\nvec2 getParticlePosition(int partnr)\n{  \n   // Particle \"local\" time, when a particle is \"reborn\" its time starts with 0.0\n   float part_timefact = mix(part_timefact_min, part_timefact_max, random(float(partnr*2 + 94) + runnr*1.5));\n   float ptime = (runnr*plt + pst)*(-1./part_timefact + 1.) + time2/part_timefact;   \n   vec2 ppos = vec2(harms(main_x_freq, main_x_amp, main_x_phase, ptime), harms(main_y_freq, main_y_amp, main_y_phase, ptime)) + middlepoint;\n   \n   // Particles randomly get away the main particle's orbit, in a linear fashion\n   vec2 delta_pos = part_max_mov*(vec2(random(float(partnr*3-23) + runnr*4.), random(float(partnr*7+632) - runnr*2.5))-0.5)*(time3 - pst);\n   \n   // Calculation of the effect of the gravitation on the particles\n   vec2 grav_pos = gravitation*pow(time4, 2.)/250.;\n   return (ppos + delta_pos + grav_pos)*gen_scale;\n}\n\n// Gets the position of the main particle in function of the time\nvec2 getParticlePosition_mp()\n{\n   vec2 ppos = vec2(harms(main_x_freq, main_x_amp, main_x_phase, time2), harms(main_y_freq, main_y_amp, main_y_phase, time2)) + middlepoint;\n   return gen_scale*ppos;\n}\n\n// Gets the rgb color of a particle in function of its intensity and number\nvec3 getParticleColor(int partnr, float pint)\n{\n   float hue;\n   float saturation;\n\n   saturation = mix(part_min_saturation, part_max_saturation, random(float(partnr*6 + 44) + runnr*3.3))*0.45/pint;\n   hue = mix(part_min_hue, part_max_hue, random(float(partnr + 124) + runnr*1.5)) + hue_time_factor*time2;\n    \n   return hsv2rgb(vec3(hue, saturation, pint));\n}\n\n// Gets the rgb color the main particle in function of its intensity\nvec3 getParticleColor_mp( float pint)\n{\n   float hue;\n   float saturation;\n   \n   saturation = 0.75/pow(pint, 2.5) + mp_saturation;\n   hue = hue_time_factor*time2 + mp_hue;\n\n   return hsv2rgb(vec3(hue, saturation, pint));\n}\n\n// Main function to draw particles, outputs the rgb color.\nvec3 drawParticles(vec2 uv, float timedelta)\n{  \n    // Here the time is \"stetched\" with the time factor, so that you can make a slow motion effect for example\n    time2 = time_factor*(iTime + timedelta);\n    vec3 pcol = vec3(0.);\n    // Main particles loop\n    for (int i=1; i<nb_particles; i++)\n    {\n        pst = getParticleStartTime(i); // Particle start time\n        plt = mix(part_life_time_min, part_life_time_max, random(float(i*2-35))); // Particle life time\n        time4 = mod(time2 - pst, plt);\n        time3 = time4 + pst;\n       // if (time2>pst) // Doesn't draw the paricle at the start\n        //{    \n           runnr = floor((time2 - pst)/plt);  // Number of the \"life\" of a particle\n           vec2 ppos = getParticlePosition(i);\n           float dist = distance(uv, ppos);\n           //if (dist<0.05) // When the current point is further than a certain distance, its impact is neglectable\n           //{\n              // Draws the eight-branched star\n              // Horizontal and vertical branches\n              vec2 uvppos = uv - ppos;\n              float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);\n              float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);\n              // Diagonal branches\n              vec2 uvpposd = 0.707*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n              float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);\n              float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);\n              // Initial intensity (random)\n              float pint0 = mix(part_int_factor_min, part_int_factor_max, random(runnr*4. + float(i-55)));\n              // Middle point intensity star inensity\n              float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);\n              // One neglects the intentity smaller than a certain threshold\n              //if (pint0*pint1>16.)\n              //{\n                 // Intensity curve and fading over time\n                 float pint = pint0*(pow(pint1, ppow)/part_int_div)*(-time4/plt + 1.);\n                \n                 // Initial growing of the paricle's intensity\n                 pint*= smoothstep(0., grow_time_factor*plt, time4);\n                 // \"Sparkling\" of the particles\n                 float sparkfreq = clamp(part_spark_time_freq_fact*time4, 0., 1.)*part_spark_min_freq + random(float(i*5 + 72) - runnr*1.8)*(part_spark_max_freq - part_spark_min_freq);\n                 pint*= mix(part_spark_min_int, part_spark_max_int, random(float(i*7 - 621) - runnr*12.))*sin(sparkfreq*twopi*time2)/2. + 1.;\n\n                 // Adds the current intensity to the global intensity\n                 pcol+= getParticleColor(i, pint);\n              //}\n           //}\n        //}\n    }\n    // Main particle\n    vec2 ppos = getParticlePosition_mp();\n    float dist = distance(uv, ppos);\n    //if (dist<0.25)\n    //{\n        // Draws the eight-branched star\n        // Horizontal and vertical branches\n        vec2 uvppos = uv - ppos;\n        float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);\n        float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);\n        // Diagonal branches\n        vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n        float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);\n        float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);\n        // Middle point intensity star inensity\n        float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);\n        \n        if (part_int_factor_max*pint1>6.)\n        {\n            float pint = part_int_factor_max*(pow(pint1, ppow)/part_int_div)*mp_int;\n            pcol+= getParticleColor_mp(pint);\n        }\n    //}\n    return pcol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    \n    // Background gradient\n    vec3 pcolor = vec3(0., (0.6 - uv.y)/6., (1. - uv.y)/5.);\n    //vec3 pcolor = texture(iChannel0,uv).rgb*0.4;\n    \n    // Motion blur loop\n    #ifdef motion_blur\n    for (int s=0; s<mb_nb_samples; s++)\n       pcolor+= drawParticles(uv, float(s)*mb_time/float(mb_nb_samples-1));\n    pcolor/= vec3(mb_nb_samples);\n    #else\n       pcolor+= drawParticles(uv,0.);\n    #endif\n       \n    // We're done!\n    fragColor = vec4(pcolor, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33R2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[6686, 6732, 6757, 6789, 6918], [6920, 6948, 6972, 6972, 7020], [7022, 7081, 7121, 7121, 7170], [7172, 7212, 7270, 7270, 7409], [7411, 7485, 7523, 7607, 8345], [8347, 8413, 8444, 8444, 8613], [8615, 8691, 8738, 8738, 9051], [9053, 9122, 9161, 9161, 9345], [9347, 9406, 9452, 9565, 13525], [13527, 13527, 13582, 13582, 14092]]}
{"id": "Xs33RS", "name": "diffuese1", "author": "mactkg", "description": "day1", "tags": ["work"], "likes": 1, "viewed": 429, "published": "Public API", "date": "1450288400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 100. * (abs(sin(iTime))+0.2);\n    float offsetX = 40.*sin(iTime+10.);\n    float offsetY = 30.*cos(iTime+10.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float b = (pow((fragCoord.x + offsetX - iResolution.x/2.), 2.) +\n        \t\t\tpow((fragCoord.y +offsetY - iResolution.y/2.), 2.))/pow(r, 2.);\n    \n\tfragColor = vec4(0.8, b*0.7 + 0.3, b*0.2 + 0.8,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 433]]}
{"id": "Xs33RX", "name": "basic sin wave", "author": "masaki", "description": "simple sin wave", "tags": ["wave"], "likes": 4, "viewed": 583, "published": "Public API", "date": "1451147531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = PI *(uv*2.-1.);\n    vec4 color =vec4(0.2, 0.6, 1., 1.)* abs(sin(20.*pos.y + 20.*sin(pos.x + iTime)));\n   \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 271]]}
{"id": "Xs33Wn", "name": "SunFlower/Vogel spiral", "author": "FabriceNeyret2", "description": "a variant of jt's https://www.shadertoy.com/view/Mdd3R7\nJust changing the spacing of dots along the spiral.", "tags": ["spiral", "short"], "likes": 16, "viewed": 1231, "published": "Public API", "date": "1448937772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a variant of jt's https://www.shadertoy.com/view/Mdd3R7\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\nvec2 pos;\n\nfloat a = .6;  // * (sqrt(5.)-1.)*2.;\n\nvec2 invtrans(vec2 v) {\n     v.x = ceil(v.y)-sqrt(v.x/a);\n     v.y -= v.x;\n     return v.y*sin(6.283*v.x+vec2(1.57,0));\n}\n\nvec4 circ(vec2 v) {\n    float s = 1.-smoothstep(.0, .1, abs(fract(v.y)-.5));\n    v = pos-invtrans(floor(v+.5)-vec2(0,.5));\n    return smoothstep(.4,.5,length(v)) - .3*vec4(0,1,1,0)*s;\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n\tvec2 R = iResolution.xy; \n    pos = I = 18.* (I+I-R)/R.y;\n\n    a = (.5+.5*cos(.1*iTime))*2.47;\n    \n    I = vec2(0, length(I)) + atan(I.y, I.x) / 6.283;\n    I.x = ceil(I.y) - I.x;\n    I.x *= I.x *a; // * (sqrt(5.)-1.)*2.;\n\n    O = circ(I);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 157, 180, 180, 278], [280, 280, 299, 299, 465], [467, 467, 505, 505, 748]]}
{"id": "Xs3GD7", "name": "004.2[F] Wooden texture (noise)", "author": "pawsiem", "description": "Just for fun, wooden texture:)", "tags": ["noise", "texture", "wooden"], "likes": 3, "viewed": 143, "published": "Public", "date": "1449934367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//@Shane\nfloat sFract(float x)\n{\n\nx = fract(x);\n// The last term is a smoothing factor, of sorts.\nreturn min(x, x*(1.-x)*12.);\n\n}\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\nvec4 wood(float x){\n    vec3 color = vec3(0.439, 0.200, 0.);\n    float m =mod(x,3.5);\n    float wood = sFract(pow(m-1.8,2.))+0.26;\n    return m<0.1?vec4(0.03):vec4(color-vec3(0.157, 0.102, 0.075)*wood,1.);\n}\nvoid mainImage( out vec4 o, in vec2 p )\n{\n\tp=p/iResolution.xy*10.+iMouse.xy/5.;\n    p.x+=iTime/2.;\n    o=wood(p.y+noise(p)/1.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 32, 32, 129], [130, 130, 151, 191, 328], [330, 330, 356, 356, 723], [724, 724, 743, 743, 931], [932, 932, 973, 973, 1062]]}
{"id": "Xs3GD8", "name": "Rotating dist map", "author": "hamoid", "description": "Rotating distance map", "tags": ["learning", "polar"], "likes": 2, "viewed": 151, "published": "Public", "date": "1449165227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 toCartesian(in float radius, in float angle) {\n\treturn vec2(0.5, 0.5) + \n        radius * vec2(sin(angle), cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    \n    float r, g, b;\n\n    float t = iTime * 3.0;\n    float t0 = 6.28 * texture(iChannel0, vec2(0.2)).r;\n    float t1 = 6.28 * texture(iChannel0, vec2(0.5)).r;\n    float t2 = 6.28 * texture(iChannel0, vec2(0.8)).r;\n\n    vec2 p0 = toCartesian(0.35, t0);\n    vec2 p1 = toCartesian(0.25, t1);\n    vec2 p2 = toCartesian(0.45, t2);\n        \n\tfloat d = distance(st, p0) + \n        distance(st, p1) + \n        distance(st, p2);\n    r = abs(sin(d * 15.0 + t));\n    g = abs(sin(d * 15.3 + t));\n    b = abs(sin(d * 15.6 + t));\n    \n\tfragColor = vec4(vec3(r, g, b),1.0);\n    \n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 126], [127, 127, 184, 184, 795]]}
{"id": "Xs3GRB", "name": "HG SDF in WebGL", "author": "tomkh", "description": "Simple test/port of <a href=\"http://mercury.sexy/hg_sdf\"  class=\"regular\" target=\"_blank\">Mercury's SDF library</a> to WebGL.<br/>To make it clear: the library is done by Mercury team for OpenGL 4+, not me, and this is just an unofficial port.", "tags": ["sdf", "lib", "hg"], "likes": 93, "viewed": 3555, "published": "Public", "date": "1450313698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n\n\n\n//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations = 160;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .02;\n\nconst float cam_dist = 5.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)\n{\n   vec3 fog_color = sky_color(ray_dir, light_dir);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -.003 :\n      .5; //iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y*.5) * -.003 :\n      .6; //iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir));\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat fField(vec3 p)\n{\n#if 0 // Do some domain repetition\n   p.xz = -p.xz;\n   vec2 q = pModMirror2(p.xz,vec2(4.5));\n#endif\n   float dodec = fDodecahedron(p-vec3(-2.25,.5,-1.),.7);\n   float box = fBox(p-vec3(0,-.1,0),vec3(1));\n   float sphere = length(p-vec3(1.+sin(iTime*.25)*.2,.8,1))-1.;\n   float d;\n   float r = 0.3;\n   float n = 4.;\n   d = fOpUnionStairs(box,sphere,r,n);\n   return min(d,dodec);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GRB.jpg", "access": "shaders20k", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[1494, 1533, 1553, 1553, 1578], [1580, 1580, 1604, 1604, 1619], [1621, 1621, 1643, 1643, 1658], [1660, 1660, 1682, 1682, 1697], [1699, 1699, 1724, 1724, 1745], [1748, 1788, 1808, 1808, 1833], [1835, 1835, 1855, 1855, 1890], [1892, 1892, 1912, 1912, 1957], [1959, 1959, 1979, 1979, 2004], [2006, 2006, 2026, 2026, 2061], [2063, 2063, 2083, 2083, 2128], [2133, 2686, 2718, 2718, 2743], [2745, 2819, 2875, 2875, 2917], [2919, 2970, 3003, 3015, 3043], [3045, 3081, 3109, 3109, 3190], [3192, 3249, 3283, 3283, 3309], [3311, 3311, 3340, 3340, 3421], [3424, 3444, 3468, 3468, 3527], [3529, 3633, 3654, 3654, 4027], [4029, 4074, 4122, 4122, 4196], [4198, 4251, 4293, 4293, 4387], [4389, 4473, 4517, 4517, 4620], [4622, 4694, 4743, 4743, 4780], [4782, 4807, 4867, 4867, 4938], [4940, 5039, 5071, 5071, 5132], [5134, 5267, 5297, 5297, 5378], [5380, 5421, 5465, 5465, 5705], [5707, 5744, 5784, 5784, 5848], [5850, 5946, 5995, 5995, 6494], [8402, 8425, 8470, 8470, 8582], [8584, 8584, 8631, 8631, 8793]]}
{"id": "Xs3GWN", "name": "ellipse on 3D patch", "author": "FabriceNeyret2", "description": "Solves perspective projection of ellipse on a 3D bilinear patch. red dot = 2D ellipse centroid.\nThis also corresponds to a pixel footprint on surface or texture parameterization.", "tags": ["perspective"], "likes": 5, "viewed": 1041, "published": "Public API", "date": "1449554389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTROID 1 // set 0 if too costly ( red dot 2D ellips center: is the costliest part !)\n#define STRIP true // alternate flat at strippy projected ellipse\n#define Z 1.       // Zoffset. 1 : high perspective.  10 or 100: orthographic (far view)\n#define eps 1e-5\n\nvoid mainImage( out vec4 o,  vec2 p )\n{\n\tvec2 R = iResolution.xy, uv, uv2;\n    p = 1.1/Z * (p+p-R) / R.y; \n    //vec2 m = (2.*iMouse.xy-R)/R.y;\n    \n    bool deg, swap, lin;\n    float t = iTime, d, W=1.,H=1., Y=0.,\n        \n    // --- quadrilateral bilinear patch  \n        \n         za=0., zb=2.+2.5*cos(t),      zc=0., zd=2.+2.5*sin(t);   // full bilinear case \n      // za=0., zb=2.+2.5*sin(t),      zc=0., zd=2.+2.5*sin(t);   // linear case\n      // za=0., zb=2.+s2.5*in(t)+1e-4, zc=0., zd=2.+2.5*sin(t);   // strangely, hard case = close to linear\n      // za=0., zb=3.+2.*cos(t),       zc=0., zd=zc;  W=sin(t);   // rotation\n\tza += Z; zb += Z; zc += Z; zd += Z; \n    // p *= 4.; p.y += Y = 1.; Y*=Z;        // offset in height \n    vec3 A = vec3(-W,-H+Y, za),\n         B = vec3( W,-H+Y, zb),\n         C = vec3(-W, H+Y, zc),\n         D = vec3( W, H+Y, zd);\n    \n    // --- solve sys3x3: bilin(uv) = (xe,ye,1)*Z  ( equivalent to intersec ray - patch ) \n    \n    // eliminates Z, sys2x2: L12 -= (xe,ye).L3 \n    A.xy -= p*A.z; \n    B.xy -= p*B.z; \n    C.xy -= p*C.z; \n    D.xy -= p*D.z; \n    vec3 AB = B-A, AC = C-A, CD = D-C, ABCD = CD-AB; // bilin = A + u.AB + v.AC +uv.ABCD = 0\n\t\n    if (lin = length(ABCD.xy) < eps) { // no uv: the system is indeed linear !\n\t    A.z  = cross(A ,AC).z; // eliminates v -> gives u\n    \tAB.z = cross(AB,AC).z;\n        uv.x = -A.z/AB.z;\n        uv.y = -A.y/AC.y -AB.y/AC.y*uv.x; // inject u in L2 -> gives v\n        uv2 = uv;        \n    }\n    else {   // full bilinear system.  eliminates uv -> sys1: Az + u.ABz + v.ACz = 0  \n    \tA.z  = cross(A ,ABCD).z;\n    \tAB.z = cross(AB,ABCD).z;\n    \tAC.z = cross(AC,ABCD).z;\n\n    \tif (deg = abs(AC.z)<eps) { // v eliminated as well ! -> gives u\n    \t    o-=o++; return; // <><><> does this case exist ?\n    \t    //uv.x = -A.z/AB.z;\n    \t    //uv.y = -A.y/AC.y -AB.y/AC.y*uv.x; // inject u in L2 -> gives v\n    \t    //uv2 = uv;\n    \t    //if (abs(AC.y)<eps) d=-1.; // really unlucky\n    \t}\n    \telse { // full normal bilinear system.\n    \t\tfloat e = -A.z/AC.z, f = -AB.z/AC.z, // ->  v = e + u.f\n    \t\t// inject v in L2 -> P2(u): a.u^2 + b.u + c = 0    -> solve P2(u) then v\n    \t\t    a = ABCD.y*f, b = ABCD.y*e + AC.y*f + AB.y, c = AC.y*e + A.y;\n    \t\t    d = b*b-4.*a*c;\n    \t\tif (lin = abs(a)<eps)  // <><><> better to use bigger eps: near-lin is unstable\n                uv2.x = uv.x  = -c/b; // no parabolic term\n            else {\n\t\t\t    uv.x  = (-b+sqrt(d))/a/2.;\n    \t\t\tuv2.x = (-b-sqrt(d))/a/2.;\n    \t\t}\n    \t\tuv.y  = e + f*uv.x;\n    \t\tuv2.y = e + f*uv2.x;\n    \t}\n    }\n    \n    // --- select valid solution and display\n    \n    uv  = 2.*uv -1.;\n    uv2 = 2.*uv2-1.;\n    if ( swap = abs(uv.x)>1. || abs(uv.y)>1.) uv = uv2;\n    float l = length(uv);\n\n    // o = texture(iChannel0,.5+.5*uv); return;\n    \n    if  (d<0.) o = vec4(.2,0,0,1); // red: ray didn't intersect the support twisted surface\n    else if ( abs(uv.x)>1. || abs(uv.y)>1.) o = vec4(.5,.5,1,1); // out of patch bounds\n    else {\n\t     o = vec4(step(l,1.));                        // circles in patch coords\n\t     if (STRIP&& fract(t/11.)<.5) o *= .5+.5*cos(60.*l);  // striped circles in patch coords\n         o.b += smoothstep(.95,1.,max(cos(63.*uv.x),cos(63.*uv.y)));  // grid in patch coords\n         if ( deg )  o.r += .5*(1.-o.r);  // red tint if degenerate solution\n         if ( swap ) o.g += .3*(1.-o.g);  // green tint if second root was chosen\n         if ( lin )  o.b += .5*(1.-o.b);  // blue tint if one on linear solutions\n    }\n    \n    // --- draw the 2D vs 3D ellipse centerd\n    \n    A = vec3(-W,-H+Y, za), B = vec3( W,-H+Y, zb), C = vec3(-W, H+Y, zc), D = vec3( W, H+Y, zd);\n    AB = B-A, AC = C-A, CD = D-C, ABCD = CD-AB; // bilin = A + u.AB + v.AC +uv.ABCD\n#define bilin(u,v) ( A + (u)*AB + (v)*AC +(u)*(v)*ABCD )\n    \n    // draw a blue dot at the middle of the grid\n    vec3 P1 = bilin(.5,.5);\n    l = smoothstep (.05, .04, Z*length(P1.xy/P1.z - p));\n    o = mix(o,vec4(0,0,1,1), l);\n    \n#if CENTROID   \n    // I don't want to solve eigenvectors of a 5x5 system in GLSL-ES !\n    // Let's try other methods. Here, iteratively find the long axis.\n    vec3 P0 = A+.5*AB;   // initial A point\n    float a0=0., a1=0., da=.1, u,v,  lM=0.; int j=0;\n    for (int i=0; i<400; i++) { // dichotomy would do faster\n        a1 += da;\n        u = .5+.5*sin(a1), v = .5-.5*cos(a1); // turn B point as long as farther\n        P1 = bilin(u,v);\n        l = length(P1.xy/P1.z - P0.xy/P0.z); // projected distance \n        if (l<lM) // decreasing !\n            if (j==0) { a1 -= da; da=-da; j++; continue; } // if first step: wrong direction\n            else {      //  not first step: we just passed the locally maximal length\n            \ta1 -= da;   //   backtrack to the maximum\n            \tu = .5+.5*sin(a1), v = .5-.5*cos(a1);\n                P1 = bilin(u,v);\n            \tvec3 P=P0; P0=P1; P1=P;// now optimize A side (indeed, swap A and B)\n            \tfloat aa=a0; a0=a1;  a1=aa; \n                da *= .9; // allowed to decrease the loop from 2000. step was 0.005 , then\n                j=0; // restart iterations\n            }\n        else { lM=l; j++; } // the distance still increases\n    }\n    // draw a red dot at the middle\n    l = smoothstep (.05, .04, Z*length( (P0.xy/P0.z+P1.xy/P1.z)/2. - p));\n    o = mix(o,vec4(1,0,0,1), l);\n    // draw diameter\n#define line(a,b) 1e-3/Z / length( clamp( dot(p-a,r=b-a)/dot(r,r), 0.,1.) *r - p+a )\n    vec2 a=P0.xy/P0.z,b=P1.xy/P1.z,r; o.bg-= line(a,b) ;\n#endif\n\n#if 0 // bug inside\n    // exact solution from http://math.stackexchange.com/questions/1566904/partial-solving-of-ellipse-from-5-points\n    vec3 E = mix(A,B,.2929), F = mix(A,C,.2929); // 1-1/sqrt(2)\n    A/=A.z, B/=B.z, C/=C.z, D/=D.z, E/=E.z, F/=F.z; \n#define tan3(A,B) vec3( -(B-A).y, (B-A).x, -cross(A,B).z )\n    vec3 TA = tan3(A,B), TB = tan3(B,C), TC = tan3(C,D), TD = tan3(D,A), TE = tan3(E,F);\n    float m1 = dot(cross(TA,TC),TE)*dot(cross(TB,TD),TE),\n          m2 = dot(cross(TA,TD),TE)*dot(cross(TB,TC),TE);\n    vec3 V11 = cross(TA,TD), V12 = cross(TB,TC),\n         V21 = cross(TA,TC), V22 = cross(TB,TD),\n         O = m1* (V11*V12.z + V11.z*V12 )\n            -m2* (V21*V22.z + V21.z*V22 ); \n    l = smoothstep (.05, .04, Z*length( O.xy/O.z - p));\n    o = mix(o,vec4(0,1,0,1), l);\n#endif    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 307, 307, 6543]]}
{"id": "Xsc3Rf", "name": "Warpring", "author": "haptix", "description": "Experimentation", "tags": ["raymarching", "torus", "distortion"], "likes": 4, "viewed": 288, "published": "Public API", "date": "1451230850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float torus(vec3 pos, vec2 t)\n{\n\tvec2 q = vec2(length(pos.xz) - t.x, pos.y);\n\treturn length(q) - t.y;\n}\n\nvec3 twist(vec3 pos, float t)\n{\n    float c = cos(t * pos.x);\n    float s = sin(t * pos.x);\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.xz, pos.y);\n}\n\nvec3 bend(vec3 pos, float t)\n{\n    float c = cos(t * pos.z);\n    float s = sin(t * pos.z);\n    mat2  m = mat2(c, -s , s, c);\n    return vec3(m * pos.xy, pos.z);\n}\n\nfloat distfunc(vec3 pos)\n{\n    vec3 bent = bend(pos, 0.45 * sin(.66 * iTime));\n    vec3 twisted = twist(bent, 0.1 * cos(iTime));\n    return torus(twisted, vec2(7.0, 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(5. * sin(iTime), 5. * cos(iTime), 14.);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 50.0;\n    const float EPSILON = 0.005;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir*.5;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal * 0.9));\n        float specular = pow(diffuse, 100.0);\n\t\t\n        vec3 color = vec3(sin(twist(pos, pos.x).y) * cos(pos.z * 0.075 * sin(0.2 * iTime)) * 0.25 + (diffuse + 0.2 * specular),\n                          cos(twist(pos, pos.y).z) * cos(pos.x * 0.075 * sin(0.3 * iTime)) * 0.5 + (diffuse + 0.2 * specular),\n                          sin(twist(pos, pos.z).x) * cos(pos.y * 0.075 * sin(0.7 * iTime)) * 0.25 + (diffuse + 0.2 * specular));\n\n\n        fragColor = vec4(color.zyx, 1.0);\n    }\n    else\n        fragColor = vec4(0., .1, .2, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 103], [105, 105, 136, 136, 267], [269, 269, 299, 299, 431], [433, 433, 459, 459, 606], [608, 608, 665, 665, 2518]]}
{"id": "Xsc3W8", "name": "Chapter 6 - color 2", "author": "hamoid", "description": "Learning from the book of shaders", "tags": ["color", "learning"], "likes": 2, "viewed": 107, "published": "Public", "date": "1449163910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0, \n                     0.0, \n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float t1 = uv.x + iTime;\n    float t2 = uv.y - iTime;\n    float r = abs(sin(t1 * 0.332) + sin(t2 * 2.21)) / 2.0;\n    float g = abs(sin(t2 * 0.773) + sin(t1 * 3.53)) / 2.0;\n    float b = abs(sin(t1 * 0.817) + sin(t2 * 4.71)) / 2.0;\n\tfragColor = vec4(hsb2rgb(vec3(r, g, b)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 260], [261, 261, 318, 318, 646]]}
{"id": "Xsc3WM", "name": "004[F] Wooden texture trying", "author": "pawsiem", "description": "I try create a wooden texture. :) \nYou can use mouse to change position:)", "tags": ["texture", "wood"], "likes": 2, "viewed": 110, "published": "Public", "date": "1449870791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 wood(float x){\n    vec3 color = vec3(0.439, 0.200, 0.);\n    float m =mod(x,3.5);\n    float wood = fract(pow(m-1.8,2.))+0.26;\n    return m<0.1?vec4(0.03):vec4(color-vec3(0.157, 0.102, 0.075)*wood,1.);\n}\nfloat desert(vec2 p){\n    return sin(p.x)/11.+sin(p.x+p.y*0.5)/5.+sin(p.y)/13.;\n}\nvoid mainImage( out vec4 o, in vec2 p )\n{\n\tp=p/iResolution.xy*10.+iMouse.xy/5.;\n    p.x+=iTime/2.;\n    o=wood(p.y+desert(p));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 206], [207, 207, 228, 228, 288], [289, 289, 330, 330, 416]]}
{"id": "Xsc3z2", "name": "Water Wave Ripples", "author": "DeMaCia", "description": "Circular ripples extend from the mouse click position.\n\nthanks for  https://www.shadertoy.com/view/ldSSD1", "tags": ["waves", "ripples", "distortion"], "likes": 21, "viewed": 2968, "published": "Public API", "date": "1450753336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float waveStrength = 0.02;\n    float frequency = 30.0;\n    float waveSpeed = 5.0;\n    vec4 sunlightColor = vec4(1.0,0.91,0.75, 1.0);\n    float sunlightStrength = 5.0;\n    float centerLight = 2.;\n    float oblique = .25; \n        \n    vec2 tapPoint = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float modifiedTime = iTime * waveSpeed;\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 distVec = uv - tapPoint;\n    distVec.x *= aspectRatio;\n    float distance = length(distVec);\n    \n    float multiplier = (distance < 1.0) ? ((distance-1.0)*(distance-1.0)) : 0.0;\n    float addend = (sin(frequency*distance-modifiedTime)+centerLight) * waveStrength * multiplier;\n    vec2 newTexCoord = uv + addend*oblique;    \n    \n    vec4 colorToAdd = sunlightColor * sunlightStrength * addend;\n    \n\tfragColor = texture(iChannel0, newTexCoord) + colorToAdd;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 979]]}
{"id": "XscGzj", "name": "Non Vero", "author": "warlock", "description": "Good old times ;)", "tags": ["line", "unreal"], "likes": 5, "viewed": 205, "published": "Public", "date": "1450777977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r iResolution\n#define t iTime\n// thanks iq ;)\nfloat l( in vec2 p, in float x1, in float y1, in float x2, in float y2 )\n{\n    float c = sin((5. + t) * .5);\n    vec2 a = vec2( x1 * c, y1 ) * 1.5;\n    vec2 b = vec2( x2 * c, y2 ) * 1.5;\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    float d = length( pa - ba*h );\n    \n    return clamp(((1. - d)-.985)*100., 0., 1.);\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n\tvec2 uv = f / r.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= r.x / r.y;\n    p.y = - p.y;\n \n    vec3 colour = vec3(0);\n    vec3 ucolour = vec3(.8, .2, 0.);\n    \n    \n    float c = 0.;\n\t\n    // u logo start\n    c = max(c, l(p,.321,.226,.419,.271));\n    c = max(c, l(p,.270,.193,.321,.226));\n    c = max(c, l(p,.251,.175,.270,.193));\n    c = max(c, l(p,.237,.158,.251,.175));\n    c = max(c, l(p,.226,.138,.237,.158));\n    c = max(c, l(p,.217,.115,.226,.138));\n    c = max(c, l(p,.210,.058,.217,.115));\n    c = max(c, l(p,.211,.045,.210,.058));\n    c = max(c, l(p,.215,.038,.211,.045));\n    c = max(c, l(p,.222,.035,.215,.038));\n    c = max(c, l(p,.363,.023,.222,.035));\n    c = max(c, l(p,.277,-.010,.363,.023));\n    c = max(c, l(p,.223,-.043,.277,-.010));\n    c = max(c, l(p,.217,-.053,.223,-.043));\n    c = max(c, l(p,.218,-.060,.217,-.053));\n    c = max(c, l(p,.228,-.065,.218,-.060));\n    c = max(c, l(p,.243,-.070,.228,-.065));\n    c = max(c, l(p,.345,-.075,.243,-.070));\n    c = max(c, l(p,.243,-.125,.345,-.075));\n    c = max(c, l(p,.226,-.138,.243,-.125));\n    c = max(c, l(p,.213,-.153,.226,-.138));\n    c = max(c, l(p,.207,-.168,.213,-.153));\n    c = max(c, l(p,.207,-.183,.207,-.168));\n    c = max(c, l(p,.211,-.198,.207,-.183));\n    c = max(c, l(p,.220,-.211,.211,-.198));\n    c = max(c, l(p,.230,-.223,.220,-.211));\n    c = max(c, l(p,.272,-.258,.230,-.223));\n    c = max(c, l(p,.212,-.256,.272,-.258));\n    c = max(c, l(p,.182,-.258,.212,-.256));\n    c = max(c, l(p,.148,-.266,.182,-.258));\n    c = max(c, l(p,.113,-.278,.148,-.266));\n    c = max(c, l(p,.073,-.298,.113,-.278));\n    c = max(c, l(p,.029,-.328,.073,-.298));\n    c = max(c, l(p,-.026,-.268,.029,-.328));\n    c = max(c, l(p,-.085,-.226,-.026,-.268));\n    c = max(c, l(p,-.097,-.226,-.085,-.226));\n    c = max(c, l(p,-.102,-.228,-.097,-.226));\n    c = max(c, l(p,-.103,-.233,-.102,-.228));\n    c = max(c, l(p,-.099,-.251,-.103,-.233));\n    c = max(c, l(p,-.098,-.256,-.099,-.251));\n    c = max(c, l(p,-.100,-.261,-.098,-.256));\n    c = max(c, l(p,-.113,-.268,-.100,-.261));\n    c = max(c, l(p,-.274,-.343,-.113,-.268));\n    c = max(c, l(p,-.289,-.346,-.274,-.343));\n    c = max(c, l(p,-.287,-.353,-.289,-.346));\n    c = max(c, l(p,-.270,-.368,-.287,-.353));\n    c = max(c, l(p,-.236,-.391,-.270,-.368));\n    c = max(c, l(p,-.187,-.416,-.236,-.391));\n    c = max(c, l(p,-.124,-.436,-.187,-.416));\n    c = max(c, l(p,-.050,-.451,-.124,-.436));\n    c = max(c, l(p,.034,-.451,-.050,-.451));\n    c = max(c, l(p,.120,-.439,.034,-.451));\n    c = max(c, l(p,.197,-.409,.120,-.439));\n    c = max(c, l(p,.261,-.371,.197,-.409));\n    c = max(c, l(p,.315,-.328,.261,-.371));\n    c = max(c, l(p,.355,-.286,.315,-.328));\n    c = max(c, l(p,.381,-.251,.355,-.286));\n    c = max(c, l(p,.394,-.226,.381,-.251));\n    c = max(c, l(p,.395,-.211,.394,-.226));\n    c = max(c, l(p,.391,-.195,.395,-.211));\n    c = max(c, l(p,.383,-.180,.391,-.195));\n    c = max(c, l(p,.369,-.168,.383,-.180));\n    c = max(c, l(p,.319,-.133,.369,-.168));\n    c = max(c, l(p,.396,-.060,.319,-.133));\n    c = max(c, l(p,.410,-.040,.396,-.060));\n    c = max(c, l(p,.422,-.023,.410,-.040));\n    c = max(c, l(p,.429,-.005,.422,-.023));\n    c = max(c, l(p,.469,.175,.429,-.005));\n    c = max(c, l(p,.491,.103,.469,.175));\n    c = max(c, l(p,.501,.025,.491,.103));\n    c = max(c, l(p,.499,-.048,.501,.025));\n    c = max(c, l(p,.491,-.100,.499,-.048));\n    c = max(c, l(p,.478,-.148,.491,-.100));\n    c = max(c, l(p,.460,-.195,.478,-.148));\n    c = max(c, l(p,.438,-.241,.460,-.195));\n    c = max(c, l(p,.412,-.283,.438,-.241));\n    c = max(c, l(p,.381,-.321,.412,-.283));\n    c = max(c, l(p,.339,-.366,.381,-.321));\n    c = max(c, l(p,.292,-.404,.339,-.366));\n    c = max(c, l(p,.240,-.436,.292,-.404));\n    c = max(c, l(p,.184,-.461,.240,-.436));\n    c = max(c, l(p,.125,-.481,.184,-.461));\n    c = max(c, l(p,.064,-.494,.125,-.481));\n    c = max(c, l(p,.000,-.499,.064,-.494));\n    c = max(c, l(p,-.058,-.494,.000,-.499));\n    c = max(c, l(p,-.115,-.484,-.058,-.494));\n    c = max(c, l(p,-.172,-.466,-.115,-.484));\n    c = max(c, l(p,-.225,-.444,-.172,-.466));\n    c = max(c, l(p,-.274,-.416,-.225,-.444));\n    c = max(c, l(p,-.319,-.381,-.274,-.416));\n    c = max(c, l(p,-.360,-.343,-.319,-.381));\n    c = max(c, l(p,-.289,-.283,-.360,-.343));\n    c = max(c, l(p,-.285,-.023,-.289,-.283));\n    c = max(c, l(p,-.286,.130,-.285,-.023));\n    c = max(c, l(p,-.291,.153,-.286,.130));\n    c = max(c, l(p,-.300,.175,-.291,.153));\n    c = max(c, l(p,-.315,.195,-.300,.175));\n    c = max(c, l(p,-.334,.213,-.315,.195));\n    c = max(c, l(p,-.359,.228,-.334,.213));\n    c = max(c, l(p,-.390,.241,-.359,.228));\n    c = max(c, l(p,-.414,.206,-.390,.241));\n    c = max(c, l(p,-.430,.170,-.414,.206));\n    c = max(c, l(p,-.434,.153,-.430,.170));\n    c = max(c, l(p,-.434,.138,-.434,.153));\n    c = max(c, l(p,-.430,.128,-.434,.138));\n    c = max(c, l(p,-.393,.090,-.430,.128));\n    c = max(c, l(p,-.356,.065,-.393,.090));\n    c = max(c, l(p,-.405,.000,-.356,.065));\n    c = max(c, l(p,-.427,-.048,-.405,.000));\n    c = max(c, l(p,-.432,-.095,-.427,-.048));\n    c = max(c, l(p,-.423,-.236,-.432,-.095));\n    c = max(c, l(p,-.419,-.266,-.423,-.236));\n    c = max(c, l(p,-.457,-.195,-.419,-.266));\n    c = max(c, l(p,-.472,-.160,-.457,-.195));\n    c = max(c, l(p,-.493,-.080,-.472,-.160));\n    c = max(c, l(p,-.499,.000,-.493,-.080));\n    c = max(c, l(p,-.498,.043,-.499,.000));\n    c = max(c, l(p,-.492,.088,-.498,.043));\n    c = max(c, l(p,-.469,.170,-.492,.088));\n    c = max(c, l(p,-.453,.208,-.469,.170));\n    c = max(c, l(p,-.434,.246,-.453,.208));\n    c = max(c, l(p,-.412,.281,-.434,.246));\n    c = max(c, l(p,-.344,.273,-.412,.281));\n    c = max(c, l(p,-.286,.253,-.344,.273));\n    c = max(c, l(p,-.237,.223,-.286,.253));\n    c = max(c, l(p,-.125,.130,-.237,.223));\n    c = max(c, l(p,-.039,.145,-.125,.130));\n    c = max(c, l(p,-.035,.140,-.039,.145));\n    c = max(c, l(p,-.092,.075,-.035,.140));\n    c = max(c, l(p,-.097,.065,-.092,.075));\n    c = max(c, l(p,-.100,.050,-.097,.065));\n    c = max(c, l(p,-.115,-.095,-.100,.050));\n    c = max(c, l(p,-.113,-.108,-.115,-.095));\n    c = max(c, l(p,-.105,-.123,-.113,-.108));\n    c = max(c, l(p,-.058,-.160,-.105,-.123));\n    c = max(c, l(p,-.015,-.185,-.058,-.160));\n    c = max(c, l(p,.000,-.183,-.015,-.185));\n    c = max(c, l(p,.010,-.175,.000,-.183));\n    c = max(c, l(p,.020,-.163,.010,-.175));\n    c = max(c, l(p,.029,-.150,.020,-.163));\n    c = max(c, l(p,.045,-.098,.029,-.150));\n    c = max(c, l(p,.041,.080,.045,-.098));\n    c = max(c, l(p,.021,.133,.041,.080));\n    c = max(c, l(p,-.009,.193,.021,.133));\n    c = max(c, l(p,-.003,.195,-.009,.193));\n    c = max(c, l(p,.058,.143,-.003,.195));\n    c = max(c, l(p,.072,.138,.058,.143));\n    c = max(c, l(p,.083,.133,.072,.138));\n    c = max(c, l(p,.093,.135,.083,.133));\n    c = max(c, l(p,.311,.266,.093,.135));\n    c = max(c, l(p,.350,.286,.311,.266));\n    c = max(c, l(p,.327,.318,.350,.286));\n    c = max(c, l(p,.299,.346,.327,.318));\n    c = max(c, l(p,.237,.393,.299,.346));\n    c = max(c, l(p,.208,.409,.237,.393));\n    c = max(c, l(p,.184,.419,.208,.409));\n    c = max(c, l(p,.168,.424,.184,.419));\n    c = max(c, l(p,.156,.421,.168,.424));\n    c = max(c, l(p,.144,.414,.156,.421));\n    c = max(c, l(p,.133,.404,.144,.414));\n    c = max(c, l(p,.088,.343,.133,.404));\n    c = max(c, l(p,.080,.341,.088,.343));\n    c = max(c, l(p,.038,.383,.080,.341));\n    c = max(c, l(p,-.015,.416,.038,.383));\n    c = max(c, l(p,-.088,.431,-.015,.416));\n    c = max(c, l(p,-.256,.426,-.088,.431));\n    c = max(c, l(p,-.188,.461,-.256,.426));\n    c = max(c, l(p,-.115,.486,-.188,.461));\n    c = max(c, l(p,-.038,.499,-.115,.486));\n    c = max(c, l(p,.000,.501,-.038,.499));\n    c = max(c, l(p,.074,.494,.000,.501));\n    c = max(c, l(p,.144,.479,.074,.494));\n    c = max(c, l(p,.211,.454,.144,.479));\n    c = max(c, l(p,.272,.419,.211,.454));\n    c = max(c, l(p,.329,.376,.272,.419));\n    c = max(c, l(p,.378,.326,.329,.376));\n    c = max(c, l(p,.419,.271,.378,.326));\n    // u logo finish\n    \n    c = clamp(c, 0., 1.) + exp(c) * .625;\n    colour = ucolour * c * c;\n    \n\tvec3 tex = vec3(dot(texture(iChannel0,uv).rgb, vec3(.292, .594, .114)) * .25);\n    \n    float vnt = 1.0 - length(uv - vec2(.5));\n    \t  vnt = smoothstep(.1, 1., vnt);\n    \n    o = vec4(mix(tex,colour,c), 1.) * vnt;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 54, 128, 128, 427], [429, 429, 470, 470, 8775]]}
{"id": "XscGzl", "name": "Dynamic, improved Perlin noise", "author": "mw", "description": "3D Perlin noise", "tags": ["3d", "noise", "perlin", "implementation"], "likes": 9, "viewed": 692, "published": "Public", "date": "1451525890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\n * Linearly Re-maps a value from one range to another\n */\nfloat map(float value, float old_lo, float old_hi, float new_lo, float new_hi)\n{\n\tfloat old_range = old_hi - old_lo;\n    if (old_range == 0.0) {\n\t    return new_lo; \n\t} else {\n\t    float new_range = new_hi - new_lo;  \n\t    return (((value - old_lo) * new_range) / old_range) + new_lo;\n\t}\n}\n\n/**\n * The canonical GLSL hash function\n */\nfloat hash(float x)\n{\n\treturn fract(sin(x) * 43758.5453123);\n}\n\n/** \n * Nothing is mathematically sound about anything below: \n * I just chose values based on experimentation and some \n * intuitions I have about what makes a good hash function\n */\nvec3 gradient(vec3 cell)\n{\n\tfloat h_i = hash(cell.x);\n\tfloat h_j = hash(cell.y + pow(h_i, 3.0));\n\tfloat h_k = hash(cell.z + pow(h_j, 5.0));\n    float ii = map(fract(h_i + h_j + h_k), 0.0, 1.0, -1.0, 1.0);\n    float jj = map(fract(h_j + h_k), 0.0, 1.0, -1.0, 1.0);\n\tfloat kk = map(h_k, 0.0, 1.0, -1.0, 1.0);\n    return normalize(vec3(ii, jj, kk));\n}\n\n/**\n * Perlin's \"ease-curve\" fade function\n */\nfloat fade(float t)\n{\n   \tfloat t3 = t * t * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    return (6.0 * t5) - (15.0 * t4) + (10.0 * t3);        \n}    \n\n/**\n * The meat of it:\n *\n * It helps to visualize the unit cube:\n *\n *      (0,1,1)----------------(1,1,1)\n *        /|                     /|\n *       / |                    / |\n *      /  |                   /  |\n *     /   |                  /   |\n * (0,1,0)-+--------------(1,1,0) |\n *    |    |                 |    |\n *    |    |                 |    |\n *    |    |                 |    |\n *    | (0,0,1)--------------+-(1,0,1)\n *    |   /                  |   /\n *    |  /                   |  /\n *    | /                    | /\n *    |/                     |/ \n * (0,0,0)----------------(1,0,0)\n */\nfloat noise(in vec3 coord)\n{\n    vec3 cell = floor(coord);\n    vec3 unit = fract(coord);\n   \n    vec3 unit_000 = unit;\n    vec3 unit_100 = unit - vec3(1.0, 0.0, 0.0);\n    vec3 unit_001 = unit - vec3(0.0, 0.0, 1.0);\n    vec3 unit_101 = unit - vec3(1.0, 0.0, 1.0);\n    vec3 unit_010 = unit - vec3(0.0, 1.0, 0.0);\n    vec3 unit_110 = unit - vec3(1.0, 1.0, 0.0);\n    vec3 unit_011 = unit - vec3(0.0, 1.0, 1.0);\n    vec3 unit_111 = unit - 1.0;\n\n    vec3 c_000 = cell;\n    vec3 c_100 = cell + vec3(1.0, 0.0, 0.0);\n    vec3 c_001 = cell + vec3(0.0, 0.0, 1.0);\n    vec3 c_101 = cell + vec3(1.0, 0.0, 1.0);\n    vec3 c_010 = cell + vec3(0.0, 1.0, 0.0);\n    vec3 c_110 = cell + vec3(1.0, 1.0, 0.0);\n    vec3 c_011 = cell + vec3(0.0, 1.0, 1.0);\n    vec3 c_111 = cell + 1.0;\n\n    float wx = fade(unit.x);\n    float wy = fade(unit.y);\n    float wz = fade(unit.z);\n \n    float x000 = dot(gradient(c_000), unit_000);\n\tfloat x100 = dot(gradient(c_100), unit_100);\n\tfloat x001 = dot(gradient(c_001), unit_001);\n\tfloat x101 = dot(gradient(c_101), unit_101);\n\tfloat x010 = dot(gradient(c_010), unit_010);\n\tfloat x110 = dot(gradient(c_110), unit_110);\n\tfloat x011 = dot(gradient(c_011), unit_011);\n\tfloat x111 = dot(gradient(c_111), unit_111);\n   \n    // (0,0,0) - (1,0,0)\n    // (0,0,1) - (1,0,1)\n    // (0,1,0) - (1,1,0)\n    // (0,1,1) - (1,1,1)\n    float y0 = mix(x000, x100, wx);\n    float y1 = mix(x001, x101, wx);\n    float y2 = mix(x010, x110, wx);\n    float y3 = mix(x011, x111, wx);\n    \n\tfloat z0 = mix(y0, y2, wy);\n    float z1 = mix(y1, y3, wy);\n    \n    return mix(z0, z1, wz);\n}\t\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float freq = 1.0 / 64.0;\n    if (iMouse.y != 0.0) {\n    \tfreq = 1.0 / iMouse.y;\n    }\n\n    float blendAmount = 0.0;\n  \tif (iMouse.x != 0.0) {\n    \tblendAmount = iMouse.x / iResolution.x;\n    } \n    \n    vec3 coord = vec3(fragCoord.xy, float(iFrame) * 0.75);\n    float v = noise(coord * freq);\n    \n    float v_0 = map(v, -1.0, 1.0, 0.0, 1.0);\n    float v_1 = 1.0 - abs(v);\n    float v_p = mix(v_0, v_1, blendAmount);\n\n\tfragColor = vec4(v_p, v_p, v_p, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 63, 143, 143, 352], [354, 398, 419, 419, 460], [462, 646, 672, 672, 994], [996, 1043, 1064, 1064, 1197], [1203, 1811, 1839, 1839, 3382], [3385, 3385, 3440, 3440, 3903]]}
{"id": "Xsd3W7", "name": "Balleidoscope", "author": "DrLuke", "description": "Deep", "tags": ["raymarching", "balls", "kaleidoscope"], "likes": 10, "viewed": 1344, "published": "Public API", "date": "1450115217", "time_retrieved": "2021-10-01T00:00:00", "image_code": " #define MARCHLIMIT 70\n\nvec3 camPos = vec3(0.0, 0.0, -1.0);\nvec3 ld = vec3(0.0, 0.0, 1.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nvec3 right = vec3(1.0, 0.0, 0.0);\nvec3 lightpos = vec3(1.5, 1.5, 1.5);\n\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 range(vec3 p)\n{\n\n    // Sphere with Radius\n    vec3 spherepos = vec3(0.0, 0.0, 0.0);\n    float radius = log(sin(iTime*0.1)*0.05+1.0)+0.1;\n\t\n    //float anim = floor(cos(iTime*0.4)+1.0);\n    float anim = smoothstep(0., .1, cos(iTime*0.4)+1.0);\n    \n    //float anim2 = floor(-cos(iTime*0.4)+1.0);\n    float anim2 = smoothstep(0., .1, -cos(iTime*0.4)+1.0);\n    \n    float xampl = sin(iTime*1.3)*0.4*anim;\n    float yampl = sin(iTime*1.3)*0.4-(anim2*0.3);\n    \n    p.x += cos((max(-2.0+p.z-camPos.z,0.)))*xampl-xampl;\n    p.y += sin((max(-2.0+p.z-camPos.z,0.)))*yampl;\n    \n    \n    p = mod(p + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    spherepos = mod(spherepos + vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0)) - vec3(0.5,0.5,0.5);\n    \n    vec3 diff = p - spherepos;\n    \n    vec3 normal = normalize(diff);\n\n    \n    return vec4(normal, length(diff)-radius);\n}\n\nvec3 lerp(vec3 a, vec3 b, float p)\n{\n    p = clamp(p,0.,1.);\n \treturn a*(1.0-p)+b*p;   \n}\n\n\nvec4 march(vec3 cam, vec3 n)\n{\n    \n    float len = 1.0;\n    vec4 ret;\n    \n    for(int i = 0; i < MARCHLIMIT; i++)\n    {\n        ret = range(camPos + len*n)*0.5;\n\t\tlen += ret.w;\n    }\n    \n\treturn vec4(ret.xyz, len);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float colorangle = 0.;\n    \n\tvec2 uv = (fragCoord.xy*2.0) / iResolution.xy - vec2(1, 1);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float rotangle = iTime*0.08;\n    vec2 newuv;\n    newuv.x = uv.x*cos(rotangle)-uv.y*sin(rotangle);\n    newuv.y = uv.x*sin(rotangle)+uv.y*cos(rotangle);\n    uv = newuv;\n    \n    camPos = vec3(0.5, 0.5, iTime*1.0);\n\n    //ld = normalize(vec3(0.0, sin(iTime*0.8)*0.1, cos(iTime*0.8)*0.5));\n    float zoom = 0.6;\n    vec3 n = normalize(vec3(sin(uv.x*3.1415*zoom),sin(uv.y*3.1415*zoom) ,ld.z*cos(uv.x*3.1415*zoom)*cos(uv.y*3.1415*zoom)));\n    vec4 rangeret = march(camPos, n);\n    float d = log(rangeret.w / 1.0 + 1.0);\n    vec3 normal = rangeret.xyz;\n    \n    vec3 p = camPos + n*d;\n    float angle = acos(dot(normal, n)/length(normal)*length(n));\n    \n\tfragColor = vec4(hsv2rgb_smooth(lerp(vec3(d*0.1 + (colorangle + iTime)*0.01 + atan(uv.y/uv.x)*3.1415 , 2.0, max(1.0 - log(d),0.0)),vec3(d*0.1 + ((colorangle + iTime)+120.0)*0.01 , 2.0, max(1.0 - log(d),0.0)),cos(angle/10.0))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 228, 262, 262, 440], [442, 442, 462, 489, 1318], [1320, 1320, 1356, 1356, 1409], [1412, 1412, 1442, 1442, 1631], [1634, 1634, 1691, 1691, 2719]]}
{"id": "Xsd3Wn", "name": "test particles", "author": "WQS33", "description": "implicit surface particle ", "tags": ["particles"], "likes": 5, "viewed": 239, "published": "Public", "date": "1449004119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PARTICLE_NUMBER 50\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat wave(vec3 p, float q)\n{\n    float dis =length(p);\n    float X = p.y- sin(dis-iTime)*q;\n    return X;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat blob7(float d1, float d2, float d3, float d4, float d5, float d6, float d7)\n{\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6)+exp(-k*d7))/k;\n}\n\nfloat blob4(float d1, float d2, float d3, float d4)\n{\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4))/k;\n}\n\nfloat smin( float a, float b )\n{\n\t//if( gUseMin ) return min(a,b);\n\t\n\t\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(in vec3 pos){\n    vec2 res=opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.45 ), 16.9 ) );\n    res =opU( res,\n            vec2( sdSphere(    pos-vec3( 2.0,0.25, 1.2), 0.35 ), 26.9 ));\n    res =opU( res,\n            vec2( sdSphere(    pos-vec3( 2.0,0.75, 0.6), 0.51 ), 16.9 ));\n    return res;\n}\n\nfloat bolbmap(in vec3 pos){\n\n   //float res = blob4(sdPlane(pos),sdSphere(    pos-vec3( 0.0,0.25+sin(iTime*0.3), 0.0+sin(-iTime*0.2)), 0.45 ),sdSphere(    pos-vec3( 2.0+sin(iTime*0.1),0.25, 1.0), 0.15 ),\n                //sdSphere(    pos-vec3( 2.0,1.25+sin(iTime*0.3), 0.3), 0.51 ));\n    float res = blob4(wave(pos, 0.2),sdSphere(    pos-vec3( 0.0,0.25+abs(sin(iTime*0.4))-3.0, 0.0), 0.45 ),sdSphere(    pos-vec3( 2.0+sin(iTime*0.1),0.25, 1.0), 0.15 ),\n                sdSphere(    pos-vec3( 2.0,1.25+sin(iTime*0.3), 0.3), 0.51 ));\n    return res;\n}\n\n\n\n\nvec2 castRayBolb(in vec3 ro, in vec3 rd){\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    float h = bolbmap( ro+rd*t );\n        if( h<precis || t>tmax ) break;\n        t += h;\n\t    //m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    m=0.5;\n    return vec2( t, m );\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = bolbmap( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 calBlobNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    bolbmap(pos+eps.xyy) - bolbmap(pos-eps.xyy),\n\t    bolbmap(pos+eps.yxy) - bolbmap(pos-eps.yxy),\n\t    bolbmap(pos+eps.yyx) - bolbmap(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = bolbmap( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res =castRayBolb(ro,rd);\n    //vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calBlobNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\t//col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.70) );\n        col =  vec3(0.4,0.4,0.90) ;\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0003*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 15.0 + iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p=-1.0+2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    //\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 64, 64, 90], [91, 91, 120, 120, 199], [201, 201, 226, 226, 241], [243, 243, 273, 273, 306], [308, 308, 391, 391, 506], [508, 508, 561, 561, 643], [645, 645, 677, 711, 824], [826, 826, 848, 848, 1182], [1184, 1184, 1211, 1468, 1734], [1739, 1739, 1780, 1780, 2106], [2108, 2108, 2145, 2145, 2463], [2465, 2465, 2507, 2507, 2808], [2811, 2811, 2843, 2843, 3064], [3066, 3066, 3101, 3101, 3334], [3337, 3337, 3389, 3389, 3566], [3568, 3568, 3642, 3642, 3905], [3907, 3907, 3946, 3946, 5472], [5474, 5474, 5531, 5531, 6180]]}
{"id": "Xsd3Wr", "name": "Voronoi sea", "author": "dmmn", "description": "Click and drag to move", "tags": ["voronoi"], "likes": 6, "viewed": 412, "published": "Public API", "date": "1449062559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\nfloat fbm( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn sqrt(d.xx); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nfloat getDepth(vec2 pos, vec2 uv) {\n    vec2 cellSmall = cellular(vec3(pos, iTime * .2));\n\tfloat facets = cellSmall.y;\n    float depth = .2 + 1. - facets;\n    depth = pow(depth, 2.);\n    depth += fbm(pos * 10.) * .1;\n    //depth *= (.7 + pow(length(sin(pos * .5)), 4.) * .3) * pow(length(uv * .6 + .4), 5.);\n    return depth;\n}\n\nvec4 getBump (vec2 pos, vec2 uv) {\n    vec2 size = vec2(2.0,0.0);\n    vec3 off = vec3(-1,0,1);\n    size *= .02; \n    off *= .05;\n    \n    float s11 = getDepth(pos, uv);\n    float s01 = getDepth(pos + off.xy, uv);\n    float s21 = getDepth(pos + off.zy, uv);\n    float s10 = getDepth(pos + off.yx, uv);\n    float s12 = getDepth(pos + off.yz, uv);\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    vec4 bump = vec4( cross(va,vb), s11 );\n    return bump;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 pos = uv * 3. + (iMouse.xy * 10. / iResolution.xy);\n    \n    vec4 bump = getBump(pos, uv);\n    \n    //vec4 texture = texture(iChannel0, pos * .1 + (bump.yz * 2. - .5) * .1);\n    //vec3 color = vec3(texture.r) * 1.;\n    \n    vec3 color = vec3(noise(bump.yz * 2. - 1.));\n    color += pow(dot(bump.xyz, vec3(1.)), 1.) * .3;\n    color *= .9 + (.7 + pow(length(sin(pos * .5)), 4.) * .3) * pow(length(uv * .6 + .4), 5.) * .2;\n    color *= bump.w;\n    color *= distance(vec2(0.), uv);\n    \n    fragColor = vec4(color, bump.w * .8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [92, 92, 113, 113, 317], [359, 359, 382, 382, 582], [801, 848, 870, 870, 915], [1134, 1477, 1500, 1500, 6342], [6344, 6344, 6379, 6379, 6671], [6673, 6673, 6707, 6707, 7175], [7178, 7178, 7235, 7235, 7861]]}
{"id": "XsdGRj", "name": "Shape vumeter", "author": "gigatron", "description": "shape function is imported from glslsandbox .. mixed French Flag ...\nOk shader mixing demo.. so on computer the posibility is 2e65536 combination i think now ! . the next generation of computer is Quantum temporal multi-vec .. 2e(65536*16384); ", "tags": ["shape", "vumeter"], "likes": 0, "viewed": 145, "published": "Public", "date": "1450878305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI (3.14159265358979323)\nfloat rand (in vec2 uv) { return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); }\nconst vec2 O = vec2(0.,1.);\nfloat noise (in vec2 uv) {\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\n#define DIR_RIGHT -1.\n#define DIR_LEFT 1.\n#define DIRECTION DIR_LEFT\n\n#define LAYERS 8\n#define SPEED 60.\n#define SIZE 5.\n\n\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\nfloat dfSemiArc2(float rma, float rmi, vec2 uv)\n{\n\treturn min(abs(length(uv) - rma) - rmi, uv.x+4.0);\n}\n\n\n\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.t));\n}\n\n//--- Letters ---\nvoid G(inout float df, vec2 uv)\n{\n\t\n\tdf = min(df, dfSemiArc(0.5, 0.125, uv));\n\tdf = min(df, dfQuad(vec2(0.000, 0.375), vec2(0.000, 0.625), vec2(0.250, 0.625), vec2(0.25, 0.375), uv));\n\tdf = min(df, dfRect(vec2(0.250, 0.50), uv - vec2(0.0,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.250,-0.125), vec2(-0.125,0.125), vec2(0.250,0.125), vec2(0.250,-0.125), uv));\t\n}\n\nvoid I(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.280,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,0.40)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.45,-0.625)));\n}\n\n//\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.1,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.50,-0.20)));\n   \n}\n\n\nvoid T(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.550,-0.625)));\n    df = min(df, dfRect(vec2(0.700, 0.25), uv - vec2(-0.8,0.38)));\n    \n \n   \n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.0,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-0.95,0.38)));\n   df = min(df, dfRect(vec2(0.200, 0.60), uv - vec2(-0.600,-0.10)));\n    df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.95,-0.10)));\n    \n  //  df = min(df, dfRect(vec2(0.450, 0.25), uv - vec2(-0.80,-0.10)));\n\n   df = min(df, dfQuad(vec2(-0.900,-0.100), vec2(-0.600,-0.100), vec2(-0.350,-0.625), vec2(-0.550,-0.625), uv));\n   \n   \n}\n\nvoid OO(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.20,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.750,-0.625)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,0.38)));\n    df = min(df, dfRect(vec2(0.550, 0.25), uv - vec2(-1.10,-0.625)));\n   \n}\n\nvoid N(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-1.30,-0.625)));\n    df = min(df, dfRect(vec2(0.200, 1.25), uv - vec2(-0.650,-0.625)));\n   df = min(df, dfQuad(vec2( -1.300,.625), vec2(-1.000,0.625), vec2(-0.450,-0.625), vec2(-0.650,-0.625), uv));\n}\n\n\n\n\n\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n//---------------\n\n//--- From e#26829.0 ---\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n \n\n\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n// s is for scale, r is for rotation// supershape from glslsandbox !\nfloat supershape(vec2 p, float m, float n1, float n2, float n3, float a, float b, float s, float r) {\n\tfloat ang = atan(p.y * iResolution.y, p.x * iResolution.x) + r;\n\tfloat v = pow(pow(abs(cos(m * ang / 4.0) / a), n2) + pow(abs(sin(m * ang / 4.0) / b), n3), -1.0 / n1);\n\treturn 1. - step(v * s * iResolution.y, length(p * iResolution.xy)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy/iResolution.xy)-.5;\n    \n    float time=iTime;\n    \n    float snd=texture(iChannel0,p/1000.).x;\n    vec4 color=vec4(0.2);\n    color += supershape(p - vec2(0.0, 0), 8.0, 1.0, 8.0, 4.0, 1.0, 1.0, 0.01+snd/8., sin(time));\n    // include texture ... computer code no limit !\n    color *= 0.8-texture(iChannel1,p+time*0.2);\n    \n    \n    vec3 c = vec3(1.0, 0.0, 0.);\n\tif(p.x < -0.166)\n\t\tc = vec3(0, 0.0, 0.874);\n\telse if(p.x > -0.50 && p.x < 0.166) \n\t\tc = vec3(1.0, 1.0, 1.0);\n        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv=p;\n    \n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < LAYERS; layer++) {\n\t\tfl = float(layer);\n\t\ts = (400.-fl*20.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s + iTime*SPEED*DIRECTION - fl*100.,uv.y*s),iResolution.x)),18.)) * (fl/float(LAYERS));\n\t}        \n        \n  // logo !\n    float t=time*2.0;\n    float bf=1.4;\n\tuv = (uv - uv/2.0)*16.0*abs(sin(t*0.2+bf/12.));\n\n\tfloat dist = 1e6;\n\t\n\tfloat charSpace = 1.025;\n\t\n\tvec2 chuv = uv;\n\tchuv.x += charSpace * 3.0;\n    \n    G(dist, chuv-vec2(-0.0,abs(sin(t*2.+bf/6.)))); chuv.x -= charSpace;\n    \n    I(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*2.0)))); chuv.x -= charSpace;\n    G(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*3.0)))); chuv.x -= charSpace;\n    A(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*4.0)))); chuv.x -= charSpace;\n    T(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*5.0)))); chuv.x -= charSpace;\n    R(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*6.0)))); chuv.x -= charSpace;\n    OO(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*7.0)))); chuv.x -= charSpace;\n    \n\tN(dist, chuv-vec2(0.0,abs(sin(t*2.+bf/6.*8.0)))); chuv.x -= charSpace;\n\n\t\n\tfloat mask = smoothstep(8.0/iResolution.y,0.008,dist);\n    \n       \n    \n    \n        vec3 textcol =  vec3(.2);\n    \t  \n    \n    \t fragColor = vec4(-1.+color);\n         if(s>0.00)fragColor += 2.*vec4( vec3(stars), 1.0 );\n\t\t fragColor += vec4(c,1.0);\n         fragColor += vec4(2.*textcol*mask,1.0);\n    // and you have a nice demo with mixing glsl.. so we can mix all shadertoy's  !!\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "MdlGzH", "previewfilepath": "https://soundcloud.com/user-115435970/unreal2", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/user-115435970/unreal2", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 58, 58, 122], [151, 151, 177, 177, 277], [402, 402, 450, 450, 504], [506, 506, 555, 555, 609], [613, 613, 672, 672, 961], [963, 963, 997, 997, 1063], [1065, 1083, 1116, 1116, 1441], [1443, 1443, 1476, 1476, 1684], [1686, 1690, 1723, 1723, 2003], [2006, 2006, 2039, 2039, 2187], [2189, 2189, 2222, 2222, 2694], [2696, 2696, 2730, 2730, 3012], [3014, 3014, 3047, 3047, 3298], [3304, 3304, 3337, 3337, 3766], [3786, 3811, 3856, 3856, 3889], [3895, 3895, 3930, 3930, 4015], [4017, 4086, 4187, 4187, 4429], [4432, 4432, 4489, 4489, 6525]]}
{"id": "XsdGRX", "name": "Learning Sine Wave", "author": "mordof", "description": "An example of creating a simple sine wave.", "tags": ["learning", "sinewaves"], "likes": 1, "viewed": 345, "published": "Public", "date": "1451334590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x;\n    float y = fragCoord.y;\n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    \n    float desiredX = iResolution.x / 2.0;\n    float desiredY = iResolution.y / 2.0;\n    bool whiteBG = true;\n    \n    if( abs(x - desiredX) < 0.6 || abs(y - desiredY) < 0.6 ) {\n        color = vec4(0.0,0.0,0.0,0.0);\n        whiteBG = false;\n    }\n   \n    float desiredWaveWidth = 128.0;\n    float wavesOnScreen = iResolution.x / desiredWaveWidth;\n    float gradientWidth = 5.0;\n    float sinWaveHeight = 130.0;\n    float sinWaveSpeedMultiplier = 2.5;\n    float sinWaveWidth = iResolution.x / (3.141592 * wavesOnScreen);\n        \n    float xInWidth = x / sinWaveWidth;\n    float sinWaveMovementModifier = 0.0;\n    // uncommenting the sinWaveMovementModifier below will cause\n    // the sin wave to move horizontally across the screen.\n    sinWaveMovementModifier = iTime * sinWaveSpeedMultiplier;\n    \n    float sinx = sin(sinWaveMovementModifier + xInWidth);\n    float sinxPositive = (sinx + 1.0) / 2.0;\n                     \n   \tfloat yInHeight = sinWaveHeight * sinxPositive;\n    float centerScreenOffset = (iResolution.y / 2.0) - sinWaveHeight / 2.0;\n    \n    float siny = yInHeight + centerScreenOffset;\n    \n    float distance = abs(siny - y);\n\n    if(distance < gradientWidth){\n        if(whiteBG == true){\n        \tcolor.g = (distance / gradientWidth);\n        \tcolor.b = (distance / gradientWidth);\n        } else {\n            color.r = 1.0 - (distance / gradientWidth);\n        }\n    }\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1576]]}
{"id": "XsdGW7", "name": "tet2cube", "author": "gyabo", "description": "Study.", "tags": ["raymarching", "cineshader"], "likes": 2, "viewed": 5093, "published": "Public API", "date": "1450108021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.google.co.jp/search?q=TGM2&num=50&espv=2&biw=1920&bih=921&source=lnms&tbm=isch&sa=X&ved=0ahUKEwjdgvid2NvJAhUBkpQKHcnvCo0Q_AUIBygB\n\nvec2 rot(vec2 p, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn vec2(c * p.x + -s * p.y, s * p.x + c * p.y);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*475458.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return max(res * 1.2, 0.6);\n}\n\nvec4 map(vec3 p) {\n\tvec3 sz = vec3(0.9);\n\tfloat ph = 0.0;\n\tfloat id = mod(p.z * 0.5, 2.0);\n\tfloat id2 = mod(p.x * 0.5, 2.0);\n\tif(id > 1.0) ph += 1.3;\n\tif(id2 > 1.0) ph += 1.3;\n\tp.y += sin(ph + iTime * 4.0) * 0.2;\n\tfloat lift = 0.2 - float(int(mod(p.z * 0.5, 3.0))) * 0.3;\n\tlift += 0.2 - float(int(mod(p.x * 0.5, 4.0))) * 0.4;\n\tp.y += lift;\n\t\n\tp.xz = mod(p.xz, 2.0) - 1.0;\n\tvec3 ret = p;\n\tret.xz = rot(ret.xz, 1.3);\n\tfloat t = length(max(abs(p) - vec3(sz), 0.0)) - 0.1;\n\treturn vec4(p, t);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n  map(pos+eps.xyy).w - map(pos-eps.xyy).w, \n  map(pos+eps.yxy).w - map(pos-eps.yxy).w, \n  map(pos+eps.yyx).w - map(pos-eps.yyx).w );\n  return normalize(nor);\n}\n\n\n#define MAX_ITE 256\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 pos = vec3(0.0, 10.5, 0.5);\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\n\tdir.yz = rot(dir.yz, 1.4);\n\tdir.xz = rot(dir.xz, -0.5 + iTime * 0.1);\n\t\n\tfloat t = 0.0;\n\tvec4 temp = vec4(0.0);\n\tint count = 0;\n\tfor(int i = 0 ; i < MAX_ITE; i++) {\n\t\ttemp = map(t * dir + pos);\n        if(abs(temp.w) < 0.01) break;\n\t\tt += temp.w * 0.1;\n        count++;\n\t}\n\n\tvec3 ip = t * dir + pos;\n\tfloat col = ((1.0 - (t * 0.01))) - temp.w;\n\tvec3 N = calcNormal(ip);\n\tvec3 L = normalize(vec3(3,2,3));\n\tfloat D = max(0.3, dot(L, N));\n    {\n        vec3 dir = L;\n        float t = 0.0;\n        int count = 1;\n        for(int i = 0 ; i < 32; i++) {\n            vec4 temp = map(t * dir + ip);\n            if(temp.w < 0.001) break;\n            t += temp.w * 0.75;\n            count++;\n        }\n        D *= clamp(length(t * dir + ip - ip), 0.05, 1.0);\n    }\n\tfloat gz = noise((temp.xyz) * 45.0) * noise(temp.xyz * 15.0) * noise(temp.xyz * 10.0);\n    gz = smoothstep(0.0, 0.9, gz);\n\tfragColor = vec4(vec3(col) * D * vec3(3.5, 1.2, 1.0).zyx * gz, 1.0);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0 / 2.2));\n    //fragColor = vec4(vec3(col) + map(ip + 0.333).w, 1.0);\n    fragColor.a = 1.0 / t;\n    \n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 145, 172, 172, 258], [260, 260, 283, 283, 323], [326, 326, 352, 352, 773], [775, 775, 793, 793, 1265], [1267, 1267, 1299, 1299, 1516], [1540, 1540, 1597, 1597, 2870]]}
{"id": "XsdGWM", "name": "3D kissing-Schottky 2", "author": "soma_arc", "description": "We use a new distance estimation(DE) to render the orbit-spheres of a kissing-Schottky group.\nThis \"kissing-Schottky DE\" algorithm is devised by Kazushi Ahara, Meiji university. See also https://www.shadertoy.com/view/MtjXDh", "tags": ["fractal", "kleiniangroups"], "likes": 2, "viewed": 202, "published": "Public", "date": "1450058665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\nconst vec3  cPos = vec3(0.0, 0.0, 750.0);\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nconst vec3 spherePos1 = vec3(300, 300, 300);\nconst vec3 spherePos2 = vec3(300, -300, 300);\nconst vec3 spherePos3 = vec3(-300, 300, 300);\nconst vec3 spherePos4 = vec3(-300, -300, 300);\nconst vec3 spherePos5 = vec3(300, 300, -300);\nconst vec3 spherePos6 = vec3(300, -300,-300);\nconst vec3 spherePos7 = vec3(-300, 300, -300);\nconst vec3 spherePos8 = vec3(-300, -300, -300);\nconst float sphereR = 300.;\n\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n      a.x * a.x * r + c,\n      a.y * a.x * r + a.z * s,\n      a.z * a.x * r - a.y * s,\n      a.x * a.y * r - a.z * s,\n      a.y * a.y * r + c,\n      a.z * a.y * r + a.x * s,\n      a.x * a.z * r + a.y * s,\n      a.y * a.z * r - a.x * s,\n      a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nvec3 sphereInverse(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat loopNum = 0.;\nconst vec3 ROTATION = vec3(1.0, 0.5, 0.5);\nconst float r2 = sphereR * sphereR;\nfloat DE(vec3 pos){\n  pos = rotate(pos, radians(iTime * 10.0), ROTATION);\n  float dr = 1.;\n  bool cont = false;\n  for(int i = 0 ; i < ITERATIONS ; i++){\n    cont = false;\n    if(distance(pos, spherePos1) < sphereR){\n      vec3 diff = (pos - spherePos1);\n      dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos1, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos2) < sphereR){\n        vec3 diff = (pos- spherePos2);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos2, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos3) < sphereR){\n        vec3 diff = (pos- spherePos3);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos3, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos4) < sphereR){\n        vec3 diff = (pos- spherePos4);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos4, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos5) < sphereR){\n        vec3 diff = (pos- spherePos5);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos5, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos6) < sphereR){\n        vec3 diff = (pos- spherePos6);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos6, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos7) < sphereR){\n        vec3 diff = (pos- spherePos7);\n         dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos7, sphereR);\n      cont = true;\n      loopNum++;\n    }else if(distance(pos, spherePos8) < sphereR){\n      vec3 diff = (pos- spherePos8);\n      dr *= r2 / dot(diff, diff);\n      pos = sphereInverse(pos, spherePos8, sphereR);\n      cont = true;\n         loopNum++;\n    }\n      \n      if(cont == false) break;\n  }\n\n//  return (length(pos) - 424.26) / abs(dr) * 0.08;\n     return (length(pos) - 219.62) / abs(dr) * 0.08;\n}\n\nvec3 getNormal(vec3 p){\n  float d = 0.01;\n  return normalize(vec3(\n      DE(p + vec3(  d, 0.0, 0.0)) - DE(p + vec3( -d, 0.0, 0.0)),\n      DE(p + vec3(0.0,   d, 0.0)) - DE(p + vec3(0.0,  -d, 0.0)),\n      DE(p + vec3(0.0, 0.0,   d)) - DE(p + vec3(0.0, 0.0,  -d))\n  ));\n}\n\nconst int MARCHING_LOOP = 800;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\n\n  float dist;\n  float rLen = 0.0;\n  vec3  rPos = cPos;\n\n  float numMarch = 0.;\n  for(int i = 0; i < MARCHING_LOOP; i++){\n    dist = DE(rPos);\n    rLen += dist;\n    rPos = cPos + ray * rLen;\n    numMarch++;\n    if(dist < 0.1) break;\n  }\n\n  if(dist < 0.1){\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(lightDir, normal), 0.1, 1.0);        \n    fragColor = vec4(vec3(diff), 1.0);\n  }else{\n    fragColor = vec4(0.,0.,0.,1.);\n  }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGWM.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 739, 783, 783, 1180], [1182, 1182, 1242, 1242, 1361], [1489, 1489, 1508, 1508, 3531], [3533, 3533, 3556, 3556, 3801], [3834, 3834, 3891, 3891, 4495]]}
{"id": "XsdGzj", "name": "Volcanic with SSAA", "author": "pyrite", "description": "iq's interesting Volcanic demo with 4x ssaa added to the left side of the screen.\nPlay with the 'cordis' or 'corner distance' parameter on line 272", "tags": ["procedural", "raymarching", "distancefield", "iq", "msaa"], "likes": 4, "viewed": 623, "published": "Public", "date": "1450914885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture( iChannel0, (uv+ vec2(0.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture( iChannel0, (uv+ vec2(1.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture( iChannel0, (uv+ vec2(0.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture( iChannel0, (uv+ vec2(1.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( h<(0.001*t) || t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d;\n    d  = 0.5000*noise( q ); q = q*2.02;\n    d += 0.2500*noise( q ); q = q*2.03;\n    d += 0.1250*noise( q ); q = q*2.01;\n    d += 0.0625*noise( q );\n\t\t\n\td = d - 0.55;\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );\n\tres.xyz *= 0.25;\n\tres.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );\n\t\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tif( t>tmax || sum.w>0.95 ) break;//continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    // sky\t \n\tvec3 col = vec3(0.32,0.36,0.4) - rd.y*0.4;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n    col *= 0.9;\n\n\tvec3 bcol = col;\n    \n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.6*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        // lighting\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 1.0;\n\n\t\tcol = vec3(0.8);\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n\n        // surface shading/material\t\t\n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\t\tvec3 verde = vec3(1.0,0.9,0.2);\n\t\tverde *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*verde, hh );\n\t\t\n\t\tfloat vv = smoothstep( 0.0, 0.8, nor.y )*smoothstep(0.0, 0.1, pos.y-0.8 );\n\t\tverde = vec3(0.2,0.45,0.1);\n\t\tverde *= texture( iChannel2, 30.0*pos.xz ).xyz;\n\t\tverde += 0.2*texture( iChannel2, 1.0*pos.xz ).xyz;\n\t\tvv *= smoothstep( 0.0, 0.5, texture( iChannel2, 0.1*pos.xz + 0.01*nor.x ).x );\n\t\tcol = mix( col, verde*1.1, vv );\n\t\t\n        // light/surface interaction\t\t\n\t\tcol = lin * col;\n\t\t\n\t\t// atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n\n\t// sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)/(0.0+0.4),0.0,1.0);\n\t\n    // smoke\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n    // gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \n    \n    return col;\n}\n\nvec3 renderAA(in vec3 ro, in mat3 cam, in vec2 s){\n    float cordis = 0.5;\n    \n    vec3 col;\n    col = vec3(0,0,0);\n    \n    vec3 rdaa1 = cam * normalize(vec3(s.x-cordis/iResolution.x,s.y-cordis/iResolution.y,1.0));\n    col += 0.25*vec3(render(ro,rdaa1));\n    vec3 rdaa2 = cam * normalize(vec3(s.x-cordis/iResolution.x,s.y+cordis/iResolution.y,1.0));\n    col += 0.25*vec3(render(ro,rdaa2));\n    vec3 rdaa3 = cam * normalize(vec3(s.x+cordis/iResolution.x,s.y-cordis/iResolution.y,1.0));\n    col += 0.25*vec3(render(ro,rdaa3));\n    vec3 rdaa4 = cam * normalize(vec3(s.x+cordis/iResolution.x,s.y+cordis/iResolution.y,1.0));\n    col += 0.25*vec3(render(ro,rdaa4));\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n\tfloat time = 2.7+iTime + off;\n//time =35.0;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t//ta.y *= 0.3 + 0.25*cos(0.11*time);\n\tta.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t// camera2world transform\n    mat3 cam = setCamera( ro, ta, roll );\n\n    // ray    \n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = cam * normalize(vec3(p.xy,1.0));\n\t\n    vec3 col = vec3(0,0,0);\n     if(fragCoord.x>iResolution.x/2.0+1.0){\n    \tcol = render( ro, rd );\n    }else if (fragCoord.x<iResolution.x/2.0-1.0){\n        col = renderAA(ro,cam,p);\n    }\n    \n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= 1.3*vec3(1.06,1.1,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGzj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 156, 182, 182, 818], [822, 822, 848, 848, 998], [1000, 1000, 1053, 1053, 1197], [1199, 1272, 1294, 1294, 1492], [1620, 1620, 1650, 1650, 1911], [1913, 1913, 1946, 1946, 2045], [2047, 2047, 2096, 2096, 2317], [2319, 2319, 2363, 2363, 2630], [2678, 2678, 2709, 2709, 3193], [3195, 3195, 3268, 3268, 3767], [3769, 3769, 3834, 3834, 4105], [4107, 4107, 4132, 4132, 4221], [4223, 4223, 4275, 4275, 4452], [4454, 4454, 4490, 4503, 6791], [6793, 6793, 6843, 6843, 7482], [7484, 7484, 7541, 7541, 8632]]}
{"id": "XsdGzX", "name": "black moon", "author": "DeMaCia", "description": "diffuse simpleless test", "tags": ["noise", "moon", "diffuse"], "likes": 2, "viewed": 559, "published": "Public API", "date": "1451372151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat randomNoise(vec2 p)\n{\n\treturn fract(sin(p.x * (12.9898) + p.y * (4.1414)) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 p)\n{//cross filter \n    \n\tvec2 nn = vec2(p.x, p.y+1.);\n\tvec2 ee = vec2(p.x+1., p.y);\n\tvec2 ss = vec2(p.x, p.y-1.);\n\tvec2 ww = vec2(p.x-1., p.y);\n\tvec2 cc = vec2(p.x, p.y);\n\n\tfloat sum = 0.;\n\tsum += randomNoise(nn)/8.;\n\tsum += randomNoise(ee)/8.;\n\tsum += randomNoise(ss)/8.;\n\tsum += randomNoise(ww)/8.;\n\tsum += randomNoise(cc)/2.;\n\n\treturn sum;\n}\n\n\nfloat BINoise(vec2 p)\n{//Bilinear interpolation\n    \n    float tiles = 64.;\n    \n\tvec2 base = floor(p/tiles);\n    p = fract(p/tiles);\n    \n    vec2 f = smoothstep(0., 1., p);\n    \n\tfloat q11 = smoothNoise(base);\n\tfloat q12 = smoothNoise(vec2(base.x, base.y+1.));\n\tfloat q21 = smoothNoise(vec2(base.x+1., base.y));\n\tfloat q22 = smoothNoise(vec2(base.x+1., base.y+1.));\n\n\tfloat r1 = mix(q11, q21, f.x);\n\tfloat r2 = mix(q12, q22, f.x);\n\n\treturn mix (r1, r2, f.y);\n} \n\n\nfloat perlinNoise(vec2 p)\n {\n\tfloat total = 0., amplitude = 1.;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\ttotal += BINoise(p) * amplitude; \n        p *= 2.;\n\t\tamplitude *= .5;\n\t}\n\treturn total;\n}\n\n\nfloat diffuseSphere(vec2 p,vec2 c, float r,vec3 l)\n{\n    float px = p.x - c.x;\n    float py = p.y - c.y;\n    float sq = r*r - px*px - py*py;\n    if(sq<0.)\n    {\n    \treturn 0.;\n        //return smoothstep(-.1,0.,sq);\n    }\n    \n\tfloat z = sqrt(sq);\n\tvec3 normal = normalize(vec3(px, py, z));\n\tfloat diffuse = max(0., dot(normal, l));\n\treturn diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 pos = (fragCoord.xy/iResolution.xy)*2.-1.;\n    pos.x *= iResolution.x/iResolution.y;\n\tfloat t = iTime;\n    \n    //mouse\n    //vec2 mousePos = (iMouse.xy/iResolution.xy)*2.-1.;\n    //mousePos.x *= iResolution.x/iResolution.y;\n    \n\t//Diffuse\n    float r = .5;\n    vec3 vp = vec3(sin(t*.2), cos(t*.2), sin(t*.2));\n    vec3 vl = normalize(vp);\n    vec2 pc = vec2(sin(t*.2)*.8, cos(t*.2)*.25);\n\tfloat diffuse = diffuseSphere(pos,pc,r,vl);\n\n\t//Noise\n    float nSpeed = 4.;\n\tvec2 p = pos*215.1 + t * nSpeed;\n\tfloat noise = perlinNoise(p);\n\n\tfragColor = vec4(vec3(diffuse*noise), 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 97], [99, 99, 126, 141, 467], [470, 470, 493, 517, 932], [936, 936, 964, 964, 1123], [1126, 1126, 1178, 1178, 1478], [1480, 1480, 1537, 1537, 2133]]}
{"id": "Xst3D7", "name": "Basic Raytracing", "author": "pbobak", "description": "My first go at making a raytracer, thanks to: https://www.youtube.com/watch?v=9g8CdctxmeU", "tags": ["raytracer", "basic", "colours"], "likes": 2, "viewed": 174, "published": "Public", "date": "1450140503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float intersectSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0\n\t// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0 *dot(oc, rd);\n    float c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - 4.0 *c;\n    if(h <0.0) return -1.0; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n    float t = (-b - sqrt(h))/ 2.0;\n    return t;\n}\n\nvec3 normalSphere(in vec3 pos, in vec4 sph)\n{\n    //sphere center at (l, m, n) radius r\n    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )\n    return (pos - sph.xyz)/sph.w;\n}\n\nfloat intersectPlane(in vec3 ro, in vec3 rd)\n{\n    //equation of a plane, y=0 = ro.y+t*rd.y\n    // t = -ro.y/rd.y\n    return -ro.y/rd.y;\n}\n\nvec3 normalPlane(in vec3 pos)\n{\n\t// normal of plane\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvec4 sph1 = vec4(0.0, 0.4, 0.0, 0.4);//sphere center\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n    resT = 1000.0;\n    float id = -1.0;\n    float tSphere = intersectSphere(ro, rd, sph1);\n    float tPlane = intersectPlane(ro, rd);\n    if (tSphere > 0.0)\n    {\n        id = 1.0;\n        resT = tSphere;\n    }\n    if (tPlane > 0.0 && tPlane < resT)\n    {\n        id = 2.0;\n        resT = tPlane;\n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(0.57703));\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\n    // ray origin & direction\n    vec3 rayOrigin = vec3(0.0, 0.5, 3.0);\n    vec3 rayDirection = normalize(vec3( (-1.0 +2.0*uv) *vec2(1.78, 1.0), -1.0));\n    \n    // moving & transforming\n    //sph1.x = 0.5 * sin(iTime);\n    //sph1.y = sph1.w + 0.5 * cos(iTime * uv.x);\n    \n\t// intersections\n    float t;\n    float id = intersect(rayOrigin, rayDirection, t);\n    \n    vec3 baseColor = vec3(uv,0.5+0.5*sin(iTime));\n    vec3 color = baseColor;\n    //vec3 color = vec3(0.05);\n    if (id > 0.5 && id < 1.5)\n    {\n        // hit the sphere\n        vec3 position = rayOrigin + t * rayDirection;\n        vec3 normal = normalSphere(position, sph1);\n        float diffuse = clamp(dot(normal, light), 0.0, 1.0);\n        float ambient = 0.5 + 0.5 * normal.y;\n        color = (baseColor * diffuse * ambient) +\n            (vec3(0.7, 0.7, 0.7)*ambient * vec3(0.7));\n    }\n    else if (id > 1.5)\n    {\n        // hit the plane\n        vec3 position = rayOrigin + t * rayDirection;\n        vec3 normal = normalPlane(position);\n        float amb = smoothstep(0.0, 3.0* sph1.w, length(position.xz-sph1.xz));\n        vec3 pureColor = vec3(sqrt(baseColor.x), baseColor.y, baseColor.z);\n        color = vec3(amb* 0.5 * pureColor);\n    }\n    \n    // color = color * 0.5*sin(iTime);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 382, 674], [676, 676, 721, 828, 864], [866, 866, 912, 979, 1004], [1006, 1006, 1037, 1057, 1091], [1130, 1146, 1203, 1203, 1528], [1530, 1530, 1587, 1587, 2969]]}
{"id": "Xst3RS", "name": "transition from dot to square", "author": "masaki", "description": "transition from dot to square", "tags": ["dot"], "likes": 10, "viewed": 705, "published": "Public API", "date": "1450452690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define STROKE 0.1\n#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 12.0* ((fragCoord.xy / iResolution.xy)-0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float freq1 =  0.5 * sin(.5 * t + uv.x*.125) + 0.5;\n    float circle = smoothstep(freq1-STROKE, freq1, cos(uv.x * 2.0 *PI) *  cos(uv.y * 2.0 *PI));  \n\tfragColor = vec4(vec3(circle),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 405]]}
{"id": "Xst3WN", "name": "V~V~V 135 V~V~V", "author": "MrHenryBemis", "description": ".o.o.o.o.o. speak to it ; 135 .o.o.o.o.o.", "tags": ["life", "mutation", "creature"], "likes": 22, "viewed": 737, "published": "Public", "date": "1449714166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//made by Kali thx bruh\n#define monster cos((iTime+135.)*.2)\n\nmat2 r(float a) {\n    float se=sin(a), co=cos(a);\n    return mat2(se,co,co,-se);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 xy = uv*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    xy.x*=iResolution.x/iResolution.y;\n\tvec2 p=xy*.61356;\n    vec3 c=vec3(0.);\n\tfloat b=.2135,a=3.135;\n    p.x=abs(p.x);\n    for (int i=0; i<22; i++) {\n\t\tfloat l=1.13525+cos(iTime*15.135)*.1355;\n        float t=monster+sin(iTime*a)*b;\n        c+=max(0.,1.-length(p))*texture(iChannel0,p+2.2+vec2(0.,iTime*3.)*.12).xyz*l*.135;\n        p.x=abs(p.x); p=p*1.35-vec2(.3,0.);\n        p*=r(t);\n\t\ta*=0.9135;\n\t\tb*=1.135;\n    }\n    c+=abs(p.y)*.001355*vec3(.7,.1358,.9);\n    c+=abs(p.x)*.001355*vec3(.9,.7,.8);\n    fragColor = vec4(pow(c,vec3(1.5)),1.);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 79, 79, 144], [147, 147, 204, 204, 852]]}
{"id": "Xst3zj", "name": "Fast SSAA + Outlining test", "author": "pyrite", "description": "Thanks iq for the SSAA code from your spherical harmonics demo.", "tags": ["ssaa"], "likes": 3, "viewed": 345, "published": "Public", "date": "1450933958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Austin Kootz - pyrite/2015\n// SSAA implentation created by iq/2013. (Many thanks!)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four spheres colored by surface location. For\n// reference and fun.\n\n\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 2\n\n\nfloat sphere(in vec3 ro, in vec3 sp, in float sr){\n    return length(ro-sp)-sr;\n}\n\nfloat elipse(in vec3 ro, in vec3 e1, in vec3 e2, in float er){\n    return (length(ro-e1)+length(ro-e2))/2.0 - (er+1.0)*length(e1-e2)/2.0;\n}\n\nfloat map(in vec3 ro){\n    \n    return min(sphere(ro, vec3(0.0,0.0,0.0),1.0+0.5*sin(3.0*iTime)),\n               min(sphere(ro,vec3(-2,0.0,0.0),1.0), \n                   min(sphere(ro,vec3(0.0,-2,0.0),1.0),\n                       sphere(ro,vec3(0.0,0.0,-2),1.0)\n                      )\n                  )\n              );\n}\n\nvec3 scene(in vec3 ro,in vec3 rd){\n    vec3 col = vec3(0);\t\t// initialize color return value\n    float rv = map(ro);\t\t//ray value\n    float rm = rv; \t\t\t//tracker for minimum ray value\n    float ow = 0.1; \t\t//outline width\n    for (int s =0; s<100; s++){\n       \trm = min(rv,rm);\n       \tro += rd*rv*0.9;\n        rv = max(map(ro),0.009);\n        if (rv<0.01){\n            float edge = map(ro);\n            //color based on suface location\n            col = vec3(ro.x,ro.y,ro.z)*0.25;\n            break;\n        }\n        //check if a ray has passed through an outline region\n        if (rv>rm && rm<ow){\n            break;\n        }\n    }\n    if (rm < ow && rm<rv){\n    col += 0.0;\n    } else {\n        col += 0.9;\n    }\n\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // camera\n    float an = 0.5*iTime - 5.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(3.0*an),6.0*cos(an),6.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {   \n        //create p for ray based on AA settings\n        vec3 p = vec3((-iResolution.xy + 2.0*(fragCoord.xy-0.5+(vec2(float(m),float(n))+0.5)/float(AA))) / iResolution.y,2.0);\n    \t\n        \n        //create view ray from vector p\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.z*ww );\n        \n        //render scene\n        vec3 col = scene(ro,rd);\n        \n        //vignette\n        col -= 0.2*length(p.xy);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3zj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[260, 313, 363, 363, 394], [396, 396, 458, 458, 535], [537, 537, 559, 559, 860], [862, 862, 896, 896, 1605], [1608, 1608, 1665, 1665, 2599]]}
{"id": "Xst3zS", "name": "raymarch test 4", "author": "megaloler", "description": "more testing, more experimenting, more learning\ni'm playing with shapes and spherical lenses! :3", "tags": ["test", "raymarch", "lens", "experiment", "sphere", "camera", "learning", "shapes", "geometry", "spherical"], "likes": 10, "viewed": 259, "published": "Public", "date": "1450482408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846264338327\n\nfloat dSphere(vec3 p, vec3 p2, float r)\n{\n    return distance(p, p2) - r;\n}\n\nfloat dPlane(vec3 p, vec3 p2, vec3 n)\n{\n    return dot(n, (p - p2));\n}\n\nfloat dBox(vec3 p, vec3 p2, vec3 r)\n{\n    vec3 d = abs(p - p2) - r;\n    return length(max(vec3(0.0), d)) + min(0.0, max(max(d.x, d.y), d.z));\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubtract(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat map(vec3 p)\n{\n    float d = dBox(p, vec3(2.0, 0.0, 2.0), vec3(0.5, 0.5, 0.5));\n    d = opUnion(d, dBox(p, vec3(0.0, 0.0, 2.0), vec3(0.5, 0.5, 0.5)));\n    d = opUnion(d, dPlane(p, vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0)));\n    d = opUnion(d, dSphere(p, vec3(-2.0, 0.0, 4.0), 1.0));\n    d = opSubtract(d, dSphere(p, vec3(-1.9, 0.2, 3.5), 0.8));\n    d = opSubtract(d, dBox(p, vec3(sin(0.0) * 2.0, -1.25, cos(0.0)), vec3(0.5, 0.5, 0.5)));\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 e = vec3(0.00001, 0.0, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat shadow(vec3 p, vec3 lp, float k)\n{\n    vec3 dir = normalize(lp - p);\n    float ld = distance(p, lp);\n    float e = 0.00001;\n    const int maxIts = 32;\n    float res = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < maxIts; i++)\n    {\n        if(t > ld) break;\n        vec3 pp = p + dir * t;\n        float d = map(pp);\n        if(d <= e) return 0.0;\n        res = min(res, k * d / t);\n        t += d;\n    }\n    return res;\n}\n\nvec3 light(vec3 p, vec3 lp, vec3 col, float i, float k)\n{\n    vec3 n = normal(p);\n    vec3 dir = normalize(lp - p);\n    float dp = dot(n, dir);\n    float d = distance(lp, p);\n    float at = pow(d, 2.0);\n    float s = shadow(p, lp, k);\n    return col * max(0.0, dp) * i * s / at;\n}\n\nvec3 lighting(vec3 p)\n{\n    vec3 l = vec3(0.1, 0.1, 0.1);\n    l += light(p, vec3(2.0, 1.0, -2.0), vec3(1.0, 0.95, 0.7), 10.0, 8.0);\n    l += light(p, vec3(-4.0, 2.0, 2.0), vec3(0.7, 0.85, 1.0), 10.0, 4.0);\n    return l;\n}\n\nvec3 castRay(vec3 ro, vec3 rd)\n{\n    float e = 0.00001;\n    const int maxIts = 128;\n    float t = 0.0;\n    for(int i = 0; i < maxIts; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d <= e) return p;\n        t += d;\n    }\n    return vec3(0.0);\n}\n\nvec4 interpolate(vec4 v1, vec4 v2, float weight)\n{\n    vec4 d = v2 - v1;\n    vec4 o = d * weight;\n    return v1 + o;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec4 skyCol = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 sceneCol = vec4(1.0, 1.0, 1.0, 1.0);\n    float fogNear = 2.0;\n    float fogFar = 12.0;\n    \n    vec3 p = castRay(ro, rd);\n    if(p == vec3(0.0)) return skyCol;\n    vec4 col = sceneCol;\n    col *= vec4(lighting(p), 1.0);\n    float d = length(p);\n    if(d > fogNear)\n    {\n        float fogRng = fogFar - fogNear;\n        float fogOff = d - fogNear;\n        float fogPrc = fogOff / fogRng;\n        col = interpolate(col, skyCol, fogPrc);\n    }\n    return col;\n}\n\nvec2 pix2unit(vec2 coord)\n{\n    coord /= iResolution.xy;\n    coord *= 2.0;\n    coord -= 1.0;\n    float ratio = iResolution.x / iResolution.y;\n    coord.x *= ratio;\n    return coord;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 coord = pix2unit(fragCoord.xy);\n    vec2 mouse = pix2unit(iMouse.xy);\n    \n    /*vec3 camPos = vec3(-sin(-mouse.x * PI * 0.5), 0.0, -cos(-mouse.x * PI * 0.5));\n    vec3 camXDir = vec3(cos(-mouse.x * PI * 0.5), 0.0, -sin(-mouse.x * PI * 0.5));\n    vec3 camYDir = vec3(0.0, 1.0, 0.0);\n    float focalLength = 1.0;\n    \n    vec3 ro = camPos;\n    vec3 forward = normalize(cross(camXDir, camYDir));\n    vec3 px = camXDir * coord.x;\n    vec3 py = camYDir * coord.y;\n    vec3 pz = forward* focalLength;\n    vec3 pixPos = px + py + pz;\n    vec3 rd = normalize(pixPos - ro);*/\n    \n    // spherical lens!\n    vec3 ro = vec3(sin(iTime) * 4.0, sin(iTime / 1.824)*0.6 + 0.4, cos(iTime) * 4.0 + 4.0);\n    \n    vec3 pxp = ro + normalize(vec3(sin(coord.x + mouse.x * 3.0 - 4.0 + iTime), sin(coord.y + mouse.y * 3.0 - 3.5), cos(coord.x + mouse.x * 3.0 - 4.0 + iTime) * cos(coord.y + mouse.y * 3.0 - 3.5)));\n    vec3 rd = normalize(pxp - ro);\n    \n    fragColor = render(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 85, 85, 119], [121, 121, 160, 160, 191], [193, 193, 230, 230, 336], [338, 338, 373, 373, 399], [401, 401, 439, 439, 466], [468, 468, 507, 507, 533], [535, 535, 554, 554, 993], [995, 995, 1016, 1016, 1235], [1237, 1237, 1277, 1277, 1665], [1667, 1667, 1724, 1724, 1947], [1949, 1949, 1972, 1972, 2170], [2172, 2172, 2204, 2204, 2447], [2449, 2449, 2499, 2499, 2567], [2569, 2569, 2600, 2600, 3113], [3115, 3115, 3142, 3142, 3298], [3300, 3300, 3355, 3355, 4329]]}
{"id": "XstGD8", "name": "/-// //-/", "author": "MrHenryBemis", "description": "^O- O -O^", "tags": ["linear", "mandala", "quadrisymmetry"], "likes": 9, "viewed": 231, "published": "Public", "date": "1449350605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// https://www.shadertoy.com/view/lsBSDz\n#define iTime iTime*.005\n#define TAU 6.13513530135\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float k = clamp(dot(ap, ab)/dot(ab, ab), 0.0, 2.0);\n    return smoothstep(0.0, 8.5/iResolution.y, length(ap - k*ab) - 0.00135);\n}\n\nfloat shape(vec2 p, float angle) {\n    float d = 135.0;\n    vec2 a = vec2(1.0, 0.0), b;\n    vec2 rot = vec2(cos(angle), sin(angle));\n    \n    for (int i = 0; i < 7; ++i) {\n        b = a;\n        for (int j = 0; j < 66; ++j) {\n        \tb = vec2(b.x*rot.x - b.y*rot.y, b.x*rot.y + b.y*rot.x);\n        \td = min(d, segment(p,  a, b));\n        }\n        a = vec2(a.x*rot.x - a.y*rot.y, a.x*rot.y + a.y*rot.x);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cc = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n        \n    float col = shape(abs(cc), cos(0.02135*(iTime+22.0))*TAU);\n    col *= 1.35 + 1.35*pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.135);\n    \n    \n\tfragColor = vec4(vec3(pow(col, 1.35)),1.35);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 143, 182, 182, 358], [360, 360, 394, 394, 786], [788, 788, 845, 845, 1153]]}
{"id": "XstGWr", "name": "Gaussian kernel blob", "author": "igore", "description": "Gaussian kernel blob", "tags": ["blob", "gaussian", "kernel"], "likes": 2, "viewed": 160, "published": "Public", "date": "1449046648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float gaussk(vec2 p1, vec2 p2)\n{\n    vec2 d = p2 - p1;\n    return exp(-dot(d, d) / 0.0185);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 p1 = vec2(0.5 + 0.1 * sin(0.25*iTime), 0.40);\n    vec2 p2 = vec2(0.5 + 0.1 * cos(0.25*iTime + 1.0), 0.55);\n    float val = -0.005 + 2.0*gaussk(uv, p1) + 8.0*gaussk(uv, p2);    \n\tfragColor = mix(vec4(1.0),\n                    vec4(0.5 + 0.4*sin(0.50*iTime), 0.5+0.35*sin(0.01*iTime+1.0), 0.5+0.45*cos(0.20*iTime), 1.0),\n                    1000.0*val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 93], [95, 95, 152, 152, 561]]}
{"id": "XstGz2", "name": "Interlace for performance", "author": "104", "description": "Drawing every other pixel each frame, using discard. I would expect a performance increase but I don't. Any ideas why?", "tags": ["interlace"], "likes": 4, "viewed": 398, "published": "Public", "date": "1450955597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// i want to use 'discard' to only draw half the pixels for each frame.\n// so I draw every other pixel each frame, occasionally changing parity\n// to draw the others. The result is a sort of interlacing effect.\n\n// I would expect this to almost double the framerate for shaders,\n// but actually I don't find much performance change at all. No idea why.\n\n\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    // copy & paste this to the top of any shader to apply the interlace effect.\n    //-------------------------------------------\n    {\n        const float interval = 80.;//milliseconds per parity change. normally should be once per frame\n        const float interlaceSize = 4.;//pixels; should be divisible by 2\n        // is this pixel allowed to draw this frame?\n        vec2 z2 = sign(sin(i/interlaceSize * 6.2831853));\n        float z = clamp(z2.x*z2.y,0.,1.);// creates a checkerboard pattern; think xor pattern\n        float parity = sign(fract(iTime*1000./interval)-.5)*.5+.5;\n        // parity is 0 or 1\n        if(z == parity)\n        {\n            discard;\n            return;\n        }\n    }\n    //-------------------------------------------\n\n    \n    \n    // the actual effect I want to display\n    i=(i-.5*(o.xy=iResolution.xy))/o.y;\n\to=i.xyyy+1.-length(i+mod(i.x+i*i.yx+iTime*.2,.1));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 356, 392, 523, 1295]]}
{"id": "XtlGzr", "name": "bizr 7", "author": "kukas", "description": "bizr", "tags": ["bizr"], "likes": 5, "viewed": 1801, "published": "Public", "date": "1449176432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy/2.0) / iResolution.x;\n    vec3 color = vec3(0.0);\n    float lines = 600.0;\n    float gap = 6.0;\n    float speed = 0.010;\n    const float num = 8.0;\n    for(float i=0.0; i<num; i++){\n        float angle = iTime*(i+1.0)*speed;\n    \tfloat c = floor(mod((cos(angle)*uv.x+sin(angle)*uv.y)*lines, gap));\n        if(c==0.0)\n        {\n            color += 1.0;\n        }\n    }\n    //vec3 color = vec3(0.0);\n\tfragColor.rgb = 1.0-color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 526]]}
