{"id": "4dGBDG", "name": "Voronoi Reflection", "author": "nr4", "description": "Some geometry tricks with voronoi distances", "tags": ["raymarching", "voronoi"], "likes": 1, "viewed": 88, "date": "1530122567", "time_retrieved": "2024-06-20T19:14:49.746324", "image_code": "/*\n * Voronoi Reflection\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1., 0.);\n\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n\nmat3 rot(vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nfloat norm(vec2 x)\n{\n    return length(x);\n}\n\n/* compute voronoi distance and closest point.\n * x: coordinate\n * return value: vec3(distance, coordinate of control point)\n */\nvec3 vor(vec2 x)\n{\n    vec2 y = floor(x);\n   \tfloat ret = 1.;\n    \n    //find closest control point. (\"In which cell am I?\")\n    vec2 pf=c.yy, p;\n    float df=10., d;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            d = norm(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    \n    //compute voronoi distance: minimum distance to any edge\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            vec2 o = p - pf;\n            d = norm(.5*o-dot(x-pf, o)/dot(o,o)*o);\n            ret = min(ret, d);\n        }\n    \n    return vec3(ret, pf);\n}\n\nvec2 scene(vec3 x)\n{\n    x = rot(5.e-1*iTime*c.yyx)*x-c.yxy;\n    \n    vec3 w = vor(6.*x.xy),\n    \tv = vor(6.*x.xy)+.3*vor(12.*x.xy)+.1*vor(24.*x.xy);\n    \n    return vec2(min(abs(length(2.+1.*2.1+(rot(3.e-1*vec3(1.4,1.5,2.)*iTime)*x.xyy).xy-.2)-5.), \n                    1./length(x)*abs(x.x))-2.4-.05*v.x-.1+abs(x.z), rand(w.yz));\n}\n\nconst float dx = 1.e-5;\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(\n        scene(x+dx*c.xyy).x-s, \n        scene(x+dx*c.yxy).x-s, \n        scene(x+dx*c.yyx).x-s\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5, s = c.yy;\n    \n    //raymarching\n    vec3 o = 3.*c.yyx, t = 2.*c.yxy, d = normalize(t-o), r = c.xyy, u = cross(d, r), x = c.yyy, \n        ro = o + uv.x * r + uv.y * u;\n    \n    float depth = 0.;\n    \n    for(int i=0; i<100; ++i)\n    {\n        x = ro + depth * d;\n        s = scene(x);\n        if(s.x < 1.e-4) break;\n        if(depth > 1000.) \n        {\n\t\t\tfragColor = c.yyyx;\n            return;\n        }\n        depth += s.x;\n    }\n    \n    //colorize\n    vec3 n = normal(x), l = c.xxx, re = normalize(reflect(-l, n)), v = normalize(x-ro),\n        col;\n    if(s.y == 1.)\n        col = .3*c.xyy+.3*c.xyy*dot(l,n)+.7*c.xxy*pow(abs(dot(re,v)), 4.);\n\telse\n    \tcol = .1*c.yyx+.1*c.yyx*dot(l,n)+c.yxx*pow(abs(dot(re,v)), 4.);\n\n    col = abs(.7*rot(vec3(1.1,1.2,1.3)*iTime+s.y)*col);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 872, 890, 890, 1099], [1101, 1101, 1121, 1121, 1145], [1147, 1276, 1294, 1294, 2135], [2137, 2137, 2157, 2157, 2470], [2496, 2496, 2517, 2517, 2674], [2676, 2676, 2733, 2733, 3598]]}
{"id": "4dGBDm", "name": "oldschool amiga", "author": "t2k", "description": "based off https://www.shadertoy.com/view/lty3zc, just made it low-res", "tags": ["oldschoolamiga"], "likes": 2, "viewed": 140, "date": "1528996667", "time_retrieved": "2024-06-20T19:14:53.570815", "image_code": "/*\nAn amiga intro with Glenz cube & scrolltext.\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nLighting stuff: https://www.shadertoy.com/view/MdGXWG by Shane\nOriginal tentative of glenz: https://www.shadertoy.com/view/ldlSW2 by rix\nFonts: https://www.shadertoy.com/view/4s3XDn by Andre\n\n*/\n\nvec3 cubevec;\nvec2 coord;\n\n#define scrolltext BOLD H_ e_ l_ l_ o_  _ s_ h_ a_ d_ e_ r_ t_ o_ y_  _ _exclam _exclam  _ T_ h_ i_ s_  _ i_ s_  _ a_ n_  _ a_ t_ t_ e_ m_ p_ t_  _ t_ o_  _ r_ e_ n_ d_ e_ r_  _ a_  _ _1 _9 _9 _3  _ o_ l_ d_  _ s_ c_ h_ o_ o_ l_  _ a_ m_ i_ g_ a_  _ i_ n_ t_ r_ o_  _ w_ i_ t_ h_  _ a_  _ G_ l_ e_ n_ z_  _ c_ u_ b_ e_  _ a_ n_ d_  _ a_  _ t_ e_ x_ t_  _ s_ c_ r_ o_ l_ l_ e_ r_  _ _dot _dot _dot _dot  _ G_ r_ e_ e_ t_ i_ n_ g_ s_  _ t_ o_  _ I_ q_ _comma  _ S_ h_ a_ n_ e_ _comma  _ S_ h_ a_ u_ _comma  _ P_ _und M_ a_ l_ i_ n_ _comma  _ r_ i_ x_ _comma  _ A_ n_ d_ r_ e_  _ a_ n_ d_  _ o_ t_ h_ e_ r_ s_  _ I_  _ f_ o_ r_ g_ o_ t_  _ _dot _dot _dot  _ E_ O_ T_  _ _dot _dot _dot \n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n#define _ cp+=.5;\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n#define crlf uv.y += 2.0; cp = 0.;\n\n// the test scroller\nvec3 Scroller(vec2 fragCoord )\n{\n    float ms = float(iMouse.w>0.);\n    float scale = 1.5;\n    vec2 mouseOffs = vec2(0);\n\tvec2 uv = (fragCoord+mouseOffs-.5*iResolution.xy) / iResolution.x * 22.0 * scale;\n    uv.x+=8.*iTime;\n    uv.x-=290.;\n    uv.y-=0.55;\n    uv.x=mod(uv.x,150.)-30.;\n  \n    float px = 22.0/iResolution.x*scale;\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0.,0.,0.,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n    uv.x += 10.1;\n\n    uv.x=uv.x+0.5*sin(uv.y+2.*iTime);\n    uv.y = mod(uv.y,2.0)-1.;\n    scrolltext\n    float weight  = 0.05;\n    return vec3(mix(us.rgb,vec3(0.5),smoothstep(weight-px,weight+px, x)));\n}\n\n\n// Sinus bars function\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\n// Render the bars calling 3 CalcSines() and adding rgb componants\nvec3 Bars(vec2 f)\n{\n    vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.10, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.10, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.10, 1.0);\n    return color;\n}\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n    p=Twist(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones\n// return color index 0 or 1 if color1 or color2\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n//Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(vec2(320,180)*(fragCoord/iResolution.xy))/(vec2(320,180)/iResolution.xy);\n    float x = fragCoord.x;\n    float pat = iTime*5.0;\n    float Step = 1.0;\n    float Distance = 0.0;\n    float Near = -1.0;\n    float Far = -1.0;\n    vec3 lightPos = vec3(1.5, 0, 0);\n    vec2 kp = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*kp;\n    vec4 m = iMouse / iResolution.xxxx;\n    float hd=-1.;\n    float ay=0.1;\n      \n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n            \t\tif(hd<0.) hd=Distance;\n                    if( Near < 0.0 ) Near = Far;\n            \t\tif(m.z<=0.0) Distance += 0.05; else break;\n                }\n        }\n\n    vec3 Color=Bars(fragCoord);\n    \n    if( Near > 0.0 )\n    \t{\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            \n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n\n    vec3 rainbow = vec3(0.5 + 0.5 * sin(kp.x*8. + 3.14 + pat), 0.5 + 0.5 * cos (kp.x*8. + pat), 0.5 + 0.5 * sin (kp.x*8. + pat));\n    if (kp.y > ay && kp.y < ay+0.006 || kp.y > (1.-ay) && kp.y < 1.-ay+0.006 ) Color = rainbow;\n    if(kp.y>1.-ay+0.006 || kp.y<0.1) Color=vec3(0.20,0.17,0.35);\n    \n    if(kp.y<ay)\n    \t{\n        vec3 cc = Scroller(fragCoord);\n        if(cc!=vec3(0.5)) Color=rainbow;\n        }\n    \n    \n    // Presenting color to the screen\n    fragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": "lsBSz3", "previewfilepath": "https://soundcloud.com/ziphoid/03-ziphoid-comic-bakery", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ziphoid/03-ziphoid-comic-bakery", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1137, 1173, 1173, 1298], [1300, 1350, 1387, 1387, 1546], [1547, 1547, 1566, 1566, 1620], [1621, 1621, 1640, 1640, 1871], [1872, 1872, 1891, 1891, 1961], [1962, 1962, 1981, 1981, 2045], [2047, 2071, 2090, 2090, 2340], [2341, 2341, 2360, 2360, 2427], [2428, 2428, 2447, 2447, 2686], [2687, 2687, 2706, 2706, 2744], [2745, 2745, 2764, 2764, 2947], [2948, 2948, 2967, 2967, 3130], [3131, 3131, 3150, 3150, 3298], [3299, 3299, 3318, 3318, 3427], [3428, 3428, 3447, 3447, 3500], [3501, 3501, 3520, 3520, 3592], [3593, 3593, 3612, 3612, 3766], [3767, 3767, 3786, 3786, 3807], [3808, 3808, 3827, 3846, 4003], [4004, 4004, 4023, 4023, 4113], [4114, 4114, 4133, 4133, 4154], [4155, 4155, 4174, 4174, 4257], [4258, 4258, 4277, 4277, 4316], [4317, 4317, 4336, 4336, 4554], [4555, 4555, 4574, 4574, 4836], [4837, 4837, 4856, 4856, 4994], [4995, 4995, 5014, 5014, 5043], [5044, 5044, 5063, 5063, 5136], [5137, 5137, 5156, 5156, 5287], [5288, 5288, 5307, 5307, 5372], [5373, 5373, 5392, 5392, 5501], [5502, 5502, 5521, 5521, 5680], [5682, 5694, 5713, 5713, 5938], [5940, 5940, 5959, 5959, 6222], [6223, 6223, 6242, 6242, 6543], [6544, 6544, 6563, 6563, 6841], [6842, 6842, 6861, 6861, 7087], [7088, 7088, 7107, 7107, 7311], [7312, 7312, 7331, 7331, 7766], [7767, 7767, 7786, 7786, 7944], [7945, 7945, 7964, 7964, 8121], [8122, 8122, 8141, 8141, 8400], [8401, 8401, 8420, 8420, 8616], [8617, 8617, 8636, 8636, 8773], [8774, 8774, 8793, 8793, 9042], [9043, 9043, 9062, 9062, 9261], [9262, 9262, 9281, 9281, 9348], [9349, 9349, 9368, 9368, 9597], [9598, 9598, 9617, 9617, 9802], [9803, 9803, 9822, 9822, 10106], [10107, 10107, 10126, 10126, 10400], [10401, 10401, 10420, 10420, 10556], [10557, 10557, 10576, 10576, 10751], [10752, 10752, 10771, 10771, 10844], [10845, 10845, 10864, 10864, 10995], [10996, 10996, 11015, 11015, 11096], [11097, 11097, 11116, 11116, 11301], [11302, 11302, 11321, 11321, 11494], [11496, 11496, 11516, 11516, 11720], [11721, 11721, 11741, 11741, 12014], [12015, 12015, 12035, 12035, 12209], [12210, 12210, 12230, 12230, 12420], [12421, 12421, 12441, 12441, 12793], [12794, 12794, 12814, 12814, 13109], [13110, 13110, 13130, 13130, 13251], [13252, 13252, 13272, 13272, 13434], [13435, 13435, 13455, 13455, 13736], [13737, 13737, 13757, 13757, 13835], [13837, 13847, 13868, 13868, 13919], [13920, 13920, 13942, 13942, 14013], [14014, 14014, 14037, 14037, 14117], [14118, 14118, 14143, 14143, 14371], [14372, 14372, 14394, 14394, 14535], [14536, 14536, 14559, 14559, 14601], [14602, 14602, 14625, 14625, 14703], [14704, 14704, 14729, 14729, 14869], [14870, 14870, 14893, 14893, 14990], [14991, 14991, 15012, 15012, 15145], [15146, 15146, 15167, 15167, 15225], [15226, 15226, 15247, 15247, 15398], [15399, 15399, 15420, 15420, 15475], [15476, 15476, 15495, 15495, 15585], [15586, 15586, 15605, 15605, 15642], [15643, 15643, 15664, 15664, 15843], [15844, 15844, 15864, 15864, 16257], [16258, 16258, 16277, 16277, 16347], [16348, 16348, 16368, 16368, 16426], [16427, 16427, 16449, 16449, 16612], [16613, 16613, 16636, 16636, 16676], [16677, 16677, 16699, 16699, 16947], [16948, 16948, 16971, 16971, 17011], [17013, 17013, 17063, 17063, 17109], [17110, 17110, 17162, 17162, 17199], [19599, 19620, 19652, 19652, 20267], [20270, 20293, 20419, 20419, 20615], [20617, 20684, 20703, 20703, 21025], [21027, 21056, 21076, 21076, 21226], [21228, 21337, 21359, 21359, 21632], [21634, 21722, 21745, 21745, 21853], [21855, 21875, 21904, 21904, 22098], [22101, 22101, 22158, 22158, 24559]]}
{"id": "4dGBRy", "name": "4d raytracer", "author": "GrayVoid", "description": "This is a basic raytracer that operates in four dimensional space.\n\nLighting, reflections, etc, all is calculated in 4d.\n", "tags": ["raytracer", "reflections", "4d"], "likes": 3, "viewed": 1081, "date": "1529224428", "time_retrieved": "2024-06-20T19:14:55.395351", "image_code": "//Copyright 2018, GrayVoid\n\nstruct Sphere{\n    vec4 pos;\n    float radius;\n    vec3 color;\n};\n    \nstruct Plane{\n    vec4 pos;\n    vec4 n;\n};\n    \nstruct RayHit{\n    vec3 color;\n    vec4 n;\n    float dist;\n};\n    \nstruct Viewer{\n    vec4 pos;\n    vec4 right;\n    vec4 up;\n    vec4 forward;\n};\n    \nstruct Ray{\n    vec4 start;\n    vec4 dir;\n};\n    \nfloat maxDistance = 100000.0;\n\nfloat fogDist = 50.0;\nvec3 fogColor = vec3(0.0, 0.0, 0.0);\n\nvec3 applyFog(in vec3 col, float dist){\n    float fogBlend = clamp(dist/fogDist, 0.0, 1.0);\n    return mix(col, fogColor, fogBlend);    \n}\n\nRayHit mixRayHits(in RayHit a, in RayHit b, float factor){\n    return RayHit(\n        mix(a.color, b.color, factor),\n        mix(a.n, b.n, factor),\n        mix(a.dist, b.dist, factor)\n    );\n}\n\nRayHit selectClosest(in RayHit a, in RayHit b){\n    float mixFactor = float(b.dist < a.dist);\n    RayHit result = RayHit(\n        mix(a.color, b.color, mixFactor),\n        mix(a.n, b.n, mixFactor),\n        min(a.dist, b.dist)\n    );\n    return result;\n}\n\n\nvec3 sceneColor(in vec4 point){\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 colorPos = fract(point.xyz);// - vec3(0.5, 0.5, 0.5));\n    color.xyz = step(vec3(0.5), colorPos);\n    return color;\n}\n\nRayHit rayVsPlane(in Ray ray, in Plane plane){\n    RayHit result = RayHit(vec3(0.0, 0.0, 0.0), -ray.dir, maxDistance);\n    RayHit defaultResult = result;\n    \n    float planeDot = dot(ray.dir, -plane.n);\n    float normalDist = dot(ray.start - plane.pos, plane.n);\n    float t = normalDist / planeDot;\n    result.dist = t;\n    result.n = plane.n;\n    result.color = sceneColor(ray.start + ray.dir * t);//vec3(1.0, 1.0, 1.0);\n    //return result;\n    return mixRayHits(defaultResult, result, float(\n        (planeDot > 0.0) && (t > 0.0)\n    ));\n\t    \n    \n    return result;\n}\n\nRayHit rayVsSphere(in Ray ray, in Sphere sphere){\n    RayHit defaultResult = RayHit(fogColor, -ray.dir, maxDistance);\n    \n    //pythogorean solution\n    vec4 sphereDiff = sphere.pos - ray.start;\n    float sphereDist = dot(sphereDiff, ray.dir);\n    float spherePerpDist = sqrt(dot(sphereDiff, sphereDiff) - sphereDist * sphereDist);\n    \n    float dt2 = sphere.radius * sphere.radius - spherePerpDist * spherePerpDist;\n    float dt = sqrt(dt2);\n    \n    float t = sphereDist - dt;//no need for t2, as we haven no refractions\n    vec4 hitPos = ray.start + ray.dir * t;\n    vec4 sphereNormal = clamp(normalize(hitPos - sphere.pos), -1.0, 1.0);\n    RayHit sphereHit = RayHit(\n        sphere.color,\n        //sphereNormal.xyz * 0.5 + 0.5,\n        //clamp(sphereNormal.xyz * 0.5 + 0.5, 0.0, 1.0),\n        sphereNormal,\n        t\n    );\n    //sphereHit.color = sphereHit.n.xyz * 0.5 + 0.5;\n    return mixRayHits(\n        defaultResult, sphereHit, float((spherePerpDist < sphere.radius) && (t > 0.0))\n    );\n    \n    \n    //return result;\n}\n\nRay makeRay(in vec2 fragCoord, in Viewer viewer){\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    Ray result = Ray(\n        viewer.pos,\n        viewer.forward + viewer.right * uv.x + viewer.up * uv.y\n    );\n    result.dir = normalize(result.dir);\n    return result;\n}\n\nconst int numMovingSpheres = 3;\n\nstruct Orbit{\n    float period;\n    float radius;\n    vec4 origin;\n    vec4 xVec;\n    vec4 yVec;\n};\n    \nstruct SphereConfig{\n    Orbit orbit;\n    vec3 color;\n    float radius;\n};\n\nconst float pi = 3.14159265359;\n//const float epsilon = 0.0001;\n\nvec4 getOrbitPos(in Orbit orbit){\n    \n    float angle = fract(iTime/orbit.period) * pi * 2.0;\n    \n    return orbit.origin \n        + cos(angle) * orbit.radius * orbit.xVec \n        + sin(angle) * orbit.radius * orbit.yVec;\n        \n}\n\nstruct SceneConfig{\n    Orbit sunOrbit;\n    SphereConfig spheres[numMovingSpheres];\n    //Orbit orbits[numMovingSpheres];\n};\n    \nconst vec4 zero4 = vec4(0.0, 0.0, 0.0, 0.0);\n    \nSceneConfig sceneConfig = SceneConfig(\n    Orbit(15.0, 1.0, vec4(0.0, 5.0, 0.0, 0.0), vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0)),\n    SphereConfig[numMovingSpheres](\n    \tSphereConfig(Orbit(3.0, 1.0, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0)), \n                     vec3(0.25, 1.0, 0.25), 0.25),\n    \tSphereConfig(Orbit(5.0, 1.5, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0)), \n                     vec3(0.25, 0.25, 1.0), 0.25),\n    \tSphereConfig(Orbit(7.0, 2.0, zero4, vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0)), \n                     vec3(1.0, 0.25, 0.25), 0.5)\n    )\n);\n\nstruct Scene{\n    vec4 sunPos;\n    Plane plane;\n    Sphere mainSphere;\n    Sphere spheres[numMovingSpheres];\n};\n\nScene makeScene(in SceneConfig sceneConfig){\n    Scene scene;\n    scene.plane = Plane(vec4(0.0, -1.7, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0));\n    scene.mainSphere = Sphere(vec4(0.0, 0.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0)); \n    \n    for(int i = 0; i < numMovingSpheres; i++){\n        vec4 pos = getOrbitPos(sceneConfig.spheres[i].orbit);\n        scene.spheres[i].pos = pos;\n        scene.spheres[i].color = sceneConfig.spheres[i].color;\n        scene.spheres[i].radius = sceneConfig.spheres[i].radius;\n    }\n    scene.sunPos = getOrbitPos(sceneConfig.sunOrbit);\n    return scene;\n}\n\n\nRayHit rayCastBase(in Ray ray, in Scene scene){\n    RayHit result = RayHit(fogColor, -ray.dir, maxDistance);\n    result = selectClosest(result, rayVsPlane(ray, scene.plane));\n    result = selectClosest(result, rayVsSphere(ray, scene.mainSphere));\n    for(int i = 0; i < numMovingSpheres; i++){\n    \tresult = selectClosest(result, rayVsSphere(ray, scene.spheres[i]));\n    }\n    return result;\n}\n\nfloat getLightFactor(in vec4 lightPos, in vec4 worldPos, in vec4 worldNormal, in Scene scene){\n    vec4 diff = lightPos - worldPos;\n    float lightDist = length(diff);\n    vec4 lightDir = normalize(diff);\n    float lightDot = clamp(dot(lightDir, worldNormal), 0.0, 1.0);\n    \n    //shadow\n    Ray lightRay = Ray(scene.sunPos, -lightDir);\n    RayHit lightHit = rayCastBase(lightRay, scene);    \n    \n    const float shadowBias = 0.01;\n    \n    return lightDot * float((lightHit.dist + shadowBias) > lightDist);\n}\n\nconst int maxSurfaceHits = 4;\n\n\nvec3 rayCastScene(in Ray originalRay, in Scene scene){\n    const vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n    vec3 finalColor = vec3(0.0);\n    \n    Ray curRay = originalRay;\n    float baseFogDist = 0.0;\n  \tfloat subRayMultiplier = 1.0;\n    \n    for (int i = 0; i < maxSurfaceHits; i++){    \n    \tRayHit curHit = rayCastBase(curRay, scene);\n\n    \tfloat rayDot = clamp(dot(-curRay.dir, curHit.n), 0.0, 1.0);\n   \t\tfloat fresnSimple = 1.0 - rayDot;\n    \tfresnSimple = mix(0.1, 1.0, fresnSimple * fresnSimple);\n        //fresnSimple = 0.5;    \n    \n    \tvec3 baseColor = curHit.color;\n    \tvec4 worldPos = curHit.dist * curRay.dir + curRay.start;\n    \tvec4 worldNormal = curHit.n;\n    \n    \tfloat lightFactor = getLightFactor(scene.sunPos, worldPos, worldNormal, scene);\n        \n        vec3 curFinalColor = vec3(0.0);\n        curFinalColor += baseColor * ambientColor;\n        curFinalColor += baseColor * lightFactor;\n        curFinalColor = applyFog(curFinalColor, curHit.dist + baseFogDist);\n            \n        finalColor = mix(finalColor, curFinalColor, subRayMultiplier);\n    \t//finalColor += addedLight * subRayMultiplier;\n        \n    \tconst float bounceBias = 0.001;\n    \tvec4 reflected = reflect(curRay.dir, curHit.n);\n    \tvec4 curPos = curRay.start + curRay.dir * curHit.dist;\n    \tRay nextRay = Ray(curPos + reflected * bounceBias, reflected);            \n        baseFogDist += curHit.dist + bounceBias;\n        \n        subRayMultiplier *= fresnSimple;\n        curRay = nextRay;\n        //break;\n    }\n    \n    return finalColor;\n    //return applyFog(finalColor, curHit.dist);\n}\n\nvec4 getCurViewerPosition(){\n    const float timePeriod = 30.0;\n    \n    const int numPositions = 7;\n    vec4 positions[numPositions] = vec4[numPositions](\n        vec4(-3.0, 1.0, -3.0, 0.0),\n        vec4(3.0, 1.0, -3.0, 0.0),\n        vec4(3.0, 1.0, -3.0, -3.0),\n        vec4(3.0, 1.0, 0.0, -3.0),\n        vec4(0.0, 1.0, 0.0, -3.0),\n        vec4(0.0, 0.0, 0.0, -3.0),\n        vec4(-3.0, 1.0, -3.0, 0.0)\n    );\n    \n    float lerpScale = 4.0;\n    \n    float fracPeriod = fract(iTime/timePeriod);\n    float curPosFloat = fracPeriod * float(numPositions);\n    int curPos = int(floor(curPosFloat)) % numPositions;\n    float curLerp = fract(curPosFloat);\n    curLerp = clamp(curLerp * lerpScale, 0.0, 1.0);\n    int nextPos = (curPos + 1) % numPositions;\n    return mix(positions[curPos], positions[nextPos], curLerp);\n    \n}\n\nvec4 planeProjectNormalize(vec4 v, vec4 n){\n    return normalize(v - n *dot(v, n));\n}\n\nViewer makeViewer(){\n    vec4 target = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    Viewer result = Viewer(\n        vec4(0.0, 0.0, -3.0, 0.0),\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0)\n    );\n    \n    result.pos = getCurViewerPosition();\n    result.forward = normalize(target - result.pos);\n    result.up = planeProjectNormalize(result.up, result.forward);\n    result.right = planeProjectNormalize(result.right, result.forward);\n    result.right = planeProjectNormalize(result.right, result.up);\n    return result;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    Scene scene = makeScene(sceneConfig);\n    Viewer viewer = makeViewer();\n        \n    Ray ray = makeRay(fragCoord, viewer);\n\n    vec3 col = rayCastScene(ray, scene);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 439, 478, 478, 577], [579, 579, 637, 637, 771], [773, 773, 820, 820, 1026], [1029, 1029, 1060, 1060, 1225], [1227, 1227, 1273, 1273, 1801], [1803, 1803, 1852, 1852, 2836], [2838, 2838, 2887, 2887, 3171], [3419, 3452, 3485, 3485, 3687], [4603, 4603, 4647, 4647, 5184], [5187, 5187, 5234, 5234, 5580], [5582, 5582, 5676, 5676, 6093], [6127, 6127, 6181, 6181, 7719], [7721, 7721, 7749, 7749, 8540], [8542, 8542, 8585, 8585, 8627], [8629, 8629, 8649, 8649, 9199], [9201, 9201, 9258, 9350, 9581]]}
{"id": "4dGBWw", "name": "Spherical gaussians, pt2", "author": "mmerchante", "description": "Part 2, aka can I fake ring lights with a negative gaussian as core? I'm interested in building a cone that preserves the same integration properties as gaussians. It seems to work for specular, but the diffuse approximation fails a bit. ", "tags": ["raymarching", "convolution", "rendering", "gaussian", "integration", "sphericalgaussians", "ringlight"], "likes": 5, "viewed": 347, "date": "1528957883", "time_retrieved": "2024-06-20T19:14:57.025667", "image_code": "/* \n * Spherical gaussians test, pt.2\n * aka, can I generate a ring light?\n */\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_STEPS 100\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define MAX_DISTANCE 20.0\n#define MIN_DISTANCE 1.0\n#define EPSILON .001\n#define EPSILON_NORMAL .001\n\n// ---------------------------------------------------------\n\n// All SG math taken from \n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\nstruct SG\n{\n    vec3 Amplitude;\n    vec3 Axis;\n    float Sharpness;\n};\n    \nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n    float cosAngle = dot(dir, sg.Axis);\n    return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));\n}\n\nSG SGProduct(in SG x, in SG y)\n{\n    vec3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness);\n    float umLength = length(um);\n    float lm = x.Sharpness + y.Sharpness;\n \n    SG res;\n    res.Axis = um * (1.0f / umLength);\n    res.Sharpness = lm * umLength;\n    res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f));\n \n    return res;\n}\n\nvec3 SGIntegral(in SG sg)\n{\n    float expTerm = 1.0f - exp(-2.0f * sg.Sharpness);\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness) * expTerm;\n}\n \nvec3 ApproximateSGIntegral(in SG sg)\n{\n    return 2.0 * 3.141592 * (sg.Amplitude / sg.Sharpness);\n}\n\n// Equals to the integral of the product of two SGs\nvec3 SGInnerProduct(in SG x, in SG y)\n{\n    float umLength = length(x.Sharpness * x.Axis + y.Sharpness * y.Axis);\n    vec3 expo = exp(umLength - x.Sharpness - y.Sharpness) *x.Amplitude * y.Amplitude;\n    float other = 1.0f - exp(-2.0f * umLength);\n    return (2.0f * 3.141592 * expo * other) / umLength;\n}\n\nfloat SGSharpnessFromThreshold(in float amplitude, in float epsilon, in float cosTheta)\n{\n    return (log(epsilon) - log(amplitude)) / (cosTheta - 1.0f);\n}\n\nSG CosineLobeSG(in vec3 direction)\n{\n    SG cosineLobe;\n    cosineLobe.Axis = direction;\n    cosineLobe.Sharpness = 2.133f;\n    cosineLobe.Amplitude = vec3(1.17f);\n    return cosineLobe;\n}\n\nvec3 SGIrradianceInnerProduct(in SG lightingLobe, in vec3 normal)\n{\n    SG cosineLobe = CosineLobeSG(normal);\n    return max(SGInnerProduct(lightingLobe, cosineLobe), 0.0f);\n}\n\nvec3 SGIrradianceFitted(in SG lightingLobe, in vec3 normal)\n{\n    float muDotN = dot(lightingLobe.Axis, normal);\n    float lambda = lightingLobe.Sharpness;\n \n    float c0 = 0.36f;\n    float c1 = 1.0f / (4.0f * c0);\n \n    float eml = exp(-lambda);\n    float em2l = eml * eml;\n    float rl = 1.0 / lambda;\n \n    float scale = 1.0f + 2.0f * em2l - rl;\n    float bias  = (eml - em2l) * rl - em2l;\n \n    float x  = sqrt(1.0f - scale);\n    float x0 = c0 * muDotN;\n    float x1 = c1 * x;\n \n    float n = x0 + x1;\n \n    float y = clamp(muDotN, 0.0, 1.0);\n    \n    if(abs(x0) <= x1)\n        y = (n * n) / x;\n \n    float result = scale * y + bias; \n    return result * ApproximateSGIntegral(lightingLobe);\n}\n\nvec3 SGDiffuseInnerProduct(in SG lightingLobe, in vec3 normal, in vec3 albedo)\n{\n    vec3 brdf = albedo / 3.141592;\n    return SGIrradianceFitted(lightingLobe, normal) * brdf;\n}\n\nSG DistributionTermSG(in vec3 direction, in float roughness)\n{\n    SG distribution;\n    distribution.Axis = direction;\n    float m2 = roughness * roughness;\n    distribution.Sharpness = 2.0 / m2;\n    distribution.Amplitude = vec3(1.0f / (3.141592 * m2)); \n    return distribution;\n}\n\nSG WarpDistributionSG(in SG ndf, in vec3 view)\n{\n    SG warp; \n    warp.Axis = reflect(-view, ndf.Axis);\n    warp.Amplitude = ndf.Amplitude;\n    warp.Sharpness = ndf.Sharpness;\n    warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); \n    return warp;\n}\n\nfloat GGX_V1(in float m2, in float nDotX)\n{\n    return 1.0f / (nDotX + sqrt(m2 + (1.0 - m2) * nDotX * nDotX));\n}\n \nvec3 SpecularTermSGWarp(in SG light, in vec3 normal, in float roughness, in vec3 view, in vec3 specAlbedo)\n{\n    SG ndf = DistributionTermSG(normal, roughness);\n    SG warpedNDF = WarpDistributionSG(ndf, view);\n \n    vec3 result = SGInnerProduct(warpedNDF, light);\n \n    vec3 warpDir = warpedNDF.Axis;\n    float m2 = roughness * roughness;\n    \n    // I'm still not sure I understand this, it's obscuring a lot of the fresnel contribution :/\n    float nDotL = saturate(dot(normal, warpDir));\n    result *= nDotL;\n    \n    float nDotV = saturate(dot(normal, view));\n    vec3 h = normalize(warpedNDF.Axis + view);\n \n    result *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV);\n    \n    float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5.0);\n    result *= specAlbedo + (1.0f - specAlbedo) * powTerm;\n    \n    return max(result, 0.0f);\n}\n\n// ---------------------------------------------------------\n\nSG GetLightSG()\n{\n    float t = iTime * .5;\n    float height = .15;\n    vec3 p = vec3(cos(t), height, sin(t));\n    \n\tSG light;\n\tlight.Axis = normalize(p);\n    light.Sharpness = 10.0;\n    light.Amplitude = pow(vec3(2.5, 1.5, 1.05), vec3(2.2)) * .35;\n    return light;\n}\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n\nCamera GetCamera(vec2 uv, float zoom, float time)\n{\n    float dist = 2.35 / zoom;\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 p = vec3(0.0, 0.0, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nfloat sdf(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);\n\tfloat dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);\n\tfloat dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{    \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec3 c0 = texture(iChannel0, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel0, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel0, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    SG lightSG = GetLightSG();    \n    SG innerSG = lightSG;\n    \n    // Play with these two\n    innerSG.Sharpness *= 1.8;\n    float innerAmplitude = 1.2;\n    \n    if(isect.sdf < EPSILON)\n    {\n        vec3 normal = sdfNormal(p, EPSILON_NORMAL);\n        vec3 diffuse = pow(vec3(.85, .15, .05), vec3(2.2)) * .3;\n        vec3 specular = pow(vec3(1.0, .9, .85), vec3(2.2)) * .5;\n\n        float roughness = mix(.025, .2, cos(iTime) * .5 + .5);\n        vec3 diff = SGDiffuseInnerProduct(lightSG, normal, diffuse);\n        vec3 spec = SpecularTermSGWarp(lightSG, normal, roughness, -camera.direction, specular);        \n        \n        diff -= innerAmplitude * SGDiffuseInnerProduct(innerSG, normal, diffuse);\n        spec -= innerAmplitude * SpecularTermSGWarp(innerSG, normal, roughness, -camera.direction, specular);\n        \n        spec = max(spec, vec3(0.0));\n        diff = max(diff, vec3(0.0));\n        \n        return spec + diff;\n    }\n    else\n    {\n     \tvec3 background = vec3(0.0);\n                \n        background += EvaluateSG(lightSG, camera.direction);\n        background -= innerAmplitude * EvaluateSG(innerSG, camera.direction);\n        \n        return background;\n    }\n}\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\n\t\toutData.totalDistance += outData.sdf;\n                \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nvec3 filmic(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    \n    if(abs(uv.y) > .8)\n        return;\n    \n    Camera camera = GetCamera(uv, 0.35, iTime * .25);\n    Intersection isect = Raymarch(camera);\n    vec3 color = Render(camera, isect, uv);    \n    \n    color = max(color, vec3(0.0));\n        \n\tvec3 vignette = mix(vec3(1.0, .8, .96) * .1, vec3(1.3), (1.0 - smoothstep(.0, 2.1, length(uv))));\n    vignette *= vignette;\n\t\n    \n\tvec3 whiteScale = 1.0f / filmic(vec3(6.2f));\n    color.rgb = filmic(color.rgb * 24.0 * vignette);    \n    color.rgb = clamp(color.rgb * whiteScale, vec3(0.0), vec3(1.0));\n    color = pow(color, vec3(.45454));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[343, 536, 576, 576, 683], [685, 685, 717, 717, 1068], [1070, 1070, 1097, 1097, 1222], [1225, 1225, 1263, 1263, 1324], [1326, 1378, 1417, 1417, 1683], [1685, 1685, 1774, 1774, 1840], [1842, 1842, 1878, 1878, 2030], [2032, 2032, 2099, 2099, 2207], [2209, 2209, 2270, 2270, 2906], [2908, 2908, 2988, 2988, 3085], [3087, 3087, 3149, 3149, 3369], [3371, 3371, 3419, 3419, 3633], [3635, 3635, 3678, 3678, 3747], [3750, 3750, 3858, 3858, 4582], [4584, 4646, 4663, 4663, 4914], [5133, 5133, 5184, 5184, 5680], [5682, 5682, 5701, 5701, 5731], [5733, 5733, 5772, 5772, 6008], [6010, 6010, 6042, 6042, 6319], [6321, 6321, 6378, 6378, 7643], [7645, 7645, 7683, 7683, 8127], [8129, 8129, 8150, 8150, 8259], [8261, 8261, 8318, 8318, 9039]]}
{"id": "4dGBWy", "name": "2d obj (space ship form)", "author": "morimea", "description": "Mouse left click will stop rotation\n\ncolored version of [url]https://www.shadertoy.com/view/XdGBWy[/url]", "tags": ["sdfart"], "likes": 8, "viewed": 415, "date": "1530150988", "time_retrieved": "2024-06-20T19:14:57.037835", "image_code": "// License - CC0 or use as you wish\n\n//using\n//https://www.shadertoy.com/view/Xllcz7\n//https://www.shadertoy.com/view/ldfGWH\n\n#define SS(x, y, z) smoothstep(x, y, z)\n#define S(U, v)       SS(-(2.0*fwidth(U.x))/1.0, (2.0*fwidth(U.x))/1.0, v)\n#define C(U,P,r)   S ( U, r - length(U-(P)) )\n#define CC(U,P,r,t) (1.-S(U,abs(r - length(U-(P))) - t))\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n//colors\n\n//black\n#define m0 vec3(.23921) \n//red\n#define m1 vec3(.82352,.35294,.34901) \n//blue\n#define m2 vec3(.41176,.53333,.78431)\n//pink\n#define m3 vec3(.78431,.49411,.70196)\n//green\n#define m4 vec3(.19607,.79215,.56078)\n\nfloat model_hline1(vec2 uv){\n    float n;\n    n=S(uv,uv.y- .22);\n    return n;\n}\n\nfloat model_hline2(vec2 uv){\n    float n;\n    n=S(uv,uv.y+ .4);\n    return n;\n}\n\nfloat model_hline3(vec2 uv){\n    float n;\n    n=S(uv,uv.y- .23);\n    return n;\n}\n\nfloat model_top(float hline,vec2 uv){\n    float n;\n    n=C(uv, vec2(.0, .08), .38);\n    return n*hline;\n}\n\nfloat model_bot(float hline,vec2 uv){\n    float n;\n    uv.x=abs(uv.x);\n    n=S(uv,-uv.x * 1.2 + uv.y* .2 + .105) ;\n    n=max(n*(1.-hline),n*C(uv, vec2(-.35, -.038), .55));\n    n=min(n,model_hline2(uv));\n    return n;\n}\n\nfloat model_decor_c1(float ll1,vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=CC(uv, vec2(.0, .49), .06,0.001);\n    n=n*ll1;\n    return n;\n}\n\nfloat model_decor_c2(vec2 uv){\n\tfloat n;\n    n=CC(uv, vec2(.0, .49), .073,0.008);\n    return n;\n}\n\nfloat model_decor_c3(float hline,float h3,float ll1,vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=CC(uv, vec2(-.06, .209), .20,0.001);\n    n=n*ll1*hline*h3;\n    return n;\n}\n\nfloat model_decor_c31(vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=1.-C(uv, vec2(.0, .49), .06);\n    return n;\n}\n\nfloat model_decor_c32(vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=1.-C(uv, vec2(-.06, .209), .20);\n    return n;\n}\n\n\nfloat model_decor_ll1(float hline,vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=S(uv,uv.x- .005);\n    return n;\n}\n\nfloat model_decor_l1(float hline,float ll1,float c1,float c2,vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=(1.-S(uv,abs(uv.x-0.005)- .001))*c1*c2*hline;\n    return n;\n}\n\nfloat model_decor_l2(float h3,vec2 uv){\n\tfloat n;\n    n=(1.-S(uv,abs(uv.x+0.21)- .006));\n    n+=(1.-S(uv,abs(uv.x+0.18)- .002));\n    n*=h3;\n    return n;\n}\n\nfloat model_decor_l3(vec2 uv){\n\tfloat n;\n    n=(1.-S(uv,abs(uv.x)- .001))*(1.-step(.121,uv.y))*1.2;\n    uv.x=abs(uv.x);\n    n=max(n,1.-S(uv,abs(-uv.x * 1.2 + uv.y* 1.52 - .183)- .002));\n    return n;\n}\n\nfloat model_decor_l4(float c2,vec2 uv){\n\tfloat n;\n    uv.x=abs(uv.x);\n    n=1.-S(uv,abs(uv.y- .23)- .001);\n    n*=c2;\n    return n;\n}\n\nfloat c4(vec2 uv){\n    uv*=1./0.02;\n    float r = length( uv );\n    return mix( 0., 0.9-0.84*pow(r,4.0), 1.0-smoothstep(0.74,0.95,r) );\n}\n\nfloat c5(vec2 uv){\n    uv*=1./0.02;\n    float r = length( uv );\n    return mix( 0., 0.9-0.84*pow(r,4.0), 1.0-smoothstep(0.74,0.95,r) );\n}\n\nvec3 model_decor_l5(float ccd,vec2 uv){\n\tfloat n;\n    float lxn=S(uv,(-uv.x * 1.2 - uv.y* 1.52 + .02));\n    float c1=C(uv, vec2(-.055, .059), .020);\n    float c4=c4(uv-vec2(-.055, .059));\n    float c5=c5(uv-vec2(.050, -.031));\n    float c2=C(uv, vec2(.050, -.031), .020);\n    uv.x=abs(uv.x);\n    float lxn1=S(uv,-uv.x * 1.2 + uv.y* 1.52 + .283) ;\n    float lxn2=S(uv,-uv.x * 1.2 + uv.y* 1.52 + .233) ;\n    float lxn10=S(uv,-uv.x * 1.2 + uv.y* .1 + .075) ;\n    float lxn20=S(uv,-uv.x * 1.2 + uv.y* .1 + .05) ;\n    n=(1.-S(uv,abs(-uv.x * 1.2 + uv.y* 1.52 + .283)- .0015))*(lxn1*lxn10);\n    n=max(n,(1.-S(uv,abs(-uv.x * 1.2 + uv.y* 1.52 + .233)- .0015))*(lxn2*lxn20));\n    n=max(n,(1.-S(uv,abs(-uv.x * 1.2 + uv.y* .1 + .05)- .001))*(lxn2*lxn20));\n    n=max(n,(1.-S(uv,abs(-uv.x * 1.2 + uv.y* .1 + .075)- .001))*(lxn1*lxn10));\n    n*=lxn;\n    vec3 res=n*m4*2.;\n    return res*(1.-c1)*(1.-c2)+max(c1*(m2)*(1.-c4*ccd)*2.,c1*m4)+max(c2*(m2)*(1.-c5*ccd)*2.,c2*m2);\n}\n\n//animation dots\n//https://www.shadertoy.com/view/Xllcz7\n#define rand(p)  fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453+(iTime/2.8))\nfloat model_ani_dots(vec2 uv )\n{\n    float num = 100.;\n    uv *= num;\n    return smoothstep(.5,.8, 1. -length(fract(uv.xy) - .5)) * rand(floor(uv)/num);\n}\n//-----\n\nvec3 model_decor(float hline,vec2 uv){\n    float n;\n    float ll1=model_decor_ll1(hline,uv);\n    float h3=model_hline3(uv);\n    float c1=model_decor_c31(uv);\n    float c2=model_decor_c32(uv);\n    float cv1=model_decor_c2(uv);\n    vec3 cc1=cv1*m2;\n   \tn=max(n,model_decor_c1(ll1,uv));\n    n=max(n,model_decor_c3(hline,h3,ll1,uv));\n    n=max(n,model_decor_l1(hline,ll1,c1,c2,uv));\n    vec3 cc3=model_decor_l2(h3,uv)*m2*2.;\n    n=max(n,model_decor_l4(c2,uv));\n    float ccd=model_ani_dots(uv);\n    vec3 cc2=model_decor_l5(ccd,uv);\n    float mx1=1.-step(0.014,(max(abs(uv.x - 0.185), abs(uv.y*.315 - 0.096))));\n    float mx2=1.-step(0.025,(max(abs(uv.x + 0.0355), abs(uv.y*.458 - 0.117))));\n    return cc1*(1.-n)*3.+n*m3*2.+cc2+cc3+ccd*mx1*m2*3.+ccd*mx2*m1*3.;\n}\n\nfloat c1(vec2 uv){\n    uv.y+=-0.09;\n    uv*=2.5;\n    float r = length( uv );\n    return mix( 0., 0.9-0.84*pow(r,4.0), 1.0-smoothstep(0.94,0.95,r) );\n}\n\nfloat c2(vec2 uv){\n    \n    uv.x=abs(uv.x);\n    float di=(1.-S(uv,-uv.x * 1.2 + uv.y* 1.52 - .183));\n    float ssx=(smoothstep(-0.02,0.125,-uv.x * 1.2 + uv.y* .2 + .1505));\n    uv.y+=-0.168;\n    uv*=3.8;\n    uv.x+=0.309;\n    float r = length( uv );\n    r = (1.-ssx)*di+r*(1.-di);\n    float ret=mix( 0., 0.9-0.84*pow(r,4.0), (1.0-smoothstep(0.94,0.95,r))*(1.-di)+ssx*di);\n    return ret;\n}\n\nfloat c3(float hline,vec2 uv){\n    float n;\n    uv.x=abs(uv.x);\n    uv.y+=-0.25;\n    uv.x+=0.01;\n    uv*=7.05;\n    float r = length( uv );\n    return mix( 0., 0.9-0.84*pow(r,4.0), 1.0-smoothstep(0.64,0.95,r) )*hline;\n    return n;\n}\n\nvec3 eng_ani(vec2 uv)\n{\n\tfloat t = abs(1.0 / (uv.y * 50.0));\n\tt *= abs(1.0 / (uv.x * 50.0));\n\treturn  min(vec3(1.),t * smoothstep(0.03,0.,abs(uv.x))*m3*cos(cos(iTime)))*smoothstep(-0.2,0.,uv.y);\n}\n\n//stars background\n//https://www.shadertoy.com/view/ldfGWH\n\nfloat random(vec2 ab) \n{\n\tfloat f = (cos(dot(ab ,vec2(21.9898,78.233))) * 43758.5453);\n\treturn fract(f);\n}\n\nfloat noise(in vec2 xy) \n{\n\tvec2 ij = floor(xy);\n\tvec2 uv = xy-ij;\n\tuv = uv*uv*(3.0-2.0*uv);\n\t\n\n\tfloat a = random(vec2(ij.x, ij.y ));\n\tfloat b = random(vec2(ij.x+1., ij.y));\n\tfloat c = random(vec2(ij.x, ij.y+1.));\n\tfloat d = random(vec2(ij.x+1., ij.y+1.));\n\tfloat k0 = a;\n\tfloat k1 = b-a;\n\tfloat k2 = c-a;\n\tfloat k3 = a-b-c+d;\n\treturn (k0 + k1*uv.x + k2*uv.y + k3*uv.x*uv.y);\n}\n\nvec3 background_stars(vec2 fragCoord )\n{\n    float time = 24.0;\n\t\n\tvec2 position = (fragCoord.xy);\n\n\tfloat color = pow(noise(fragCoord.xy), 40.0) * 20.0;\n\n\tfloat r1 = noise(fragCoord.xy*noise(vec2(sin(time*0.01))));\n\tfloat r2 = noise(fragCoord.xy*noise(vec2(cos(time*0.01), sin(time*0.01))));\n\tfloat r3 = noise(fragCoord.xy*noise(vec2(sin(time*0.05), cos(time*0.05))));\n\t\t\n\treturn vec3(color*r1, color*r2, color*r3);\n}\n//-----\n\nvec3 model(vec2 uv){\n    float n;\n    vec2 ouv=uv;\n    if(!(iMouse.z>0.5))uv*= MD(iTime/10.); //mouse\n    float h1=model_hline1(uv);\n    float mb=model_bot(h1,uv);\n    float mt=model_top(h1,uv)*c1(uv);\n    float c2x=c2(uv);\n    n=(mt*(1.-mb)+mb*c2x);\n    vec3 colxm=n*m0;\n    vec3 colxd1=(model_decor(h1,uv))*n;\n    vec3 colxd2=model_decor_l3(uv)*mb*c2x*m2*2.;\n    vec3 colbx=c3(h1,uv)*m4*(1.-mb)*(.5+7.*((sin(2.-cos(iTime/1.)))));\n    vec3 eng=eng_ani(vec2(abs(uv.x)-0.2,uv.y-0.23))*(1.-h1);\n    eng+=eng_ani(vec2(abs(uv.x)-0.25,uv.y-0.23))*(1.-h1);\n    vec3 resx=colxm+max(colxd1,colxd2)+colbx;\n    if(!(resx.r>0.))resx = (background_stars(vec2((ouv.x*(1./(iResolution.x / iResolution.y))+0.5)*iResolution.x,(ouv.y+0.5)*iResolution.y)));\n    resx+=eng;\n    return resx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    fragColor = vec4(0.);\n    fragColor = vec4(model(uv),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[576, 623, 651, 651, 703], [705, 705, 733, 733, 784], [786, 786, 814, 814, 866], [868, 868, 905, 905, 973], [975, 975, 1012, 1012, 1193], [1195, 1195, 1235, 1235, 1334], [1336, 1336, 1366, 1366, 1433], [1435, 1435, 1496, 1496, 1607], [1609, 1609, 1640, 1640, 1722], [1724, 1724, 1755, 1755, 1840], [1843, 1843, 1886, 1886, 1956], [1958, 1958, 2028, 2028, 2126], [2128, 2128, 2167, 2167, 2283], [2285, 2285, 2315, 2315, 2486], [2488, 2488, 2527, 2527, 2621], [2623, 2623, 2641, 2641, 2760], [2762, 2762, 2780, 2780, 2899], [2901, 2901, 2940, 2940, 3859], [3861, 4000, 4032, 4032, 4154], [4155, 4164, 4202, 4202, 4922], [4924, 4924, 4942, 4942, 5074], [5076, 5076, 5094, 5094, 5464], [5466, 5466, 5496, 5496, 5698], [5700, 5700, 5723, 5723, 5896], [5898, 5958, 5982, 5982, 6064], [6066, 6066, 6092, 6092, 6443], [6445, 6445, 6485, 6485, 6863], [6864, 6873, 6893, 6893, 7646], [7648, 7648, 7705, 7705, 7872]]}
{"id": "4dGfDy", "name": "Mickey Couse", "author": "Saineni", "description": "The mouse ", "tags": ["mickeymouse"], "likes": 2, "viewed": 79, "date": "1530192773", "time_retrieved": "2024-06-20T19:14:57.037835", "image_code": "float circle(vec2 uv, vec2 position, float radius, float blur) {\n    uv -=0.5;\t\t\t\t\t\t\t\t\t\t// position of the circle || to make (0,0) center of the screen \n    uv.y*=iResolution.y/iResolution.x;\t\t\t\t//to make it a circle \n    float d = length(uv-position);\n    float c = smoothstep(radius,radius-blur,d);\t\t//if(d<radius){d=1} else{d=0} and also adds blur on the edges\n    return c;\n}\n\nfloat oval(vec2 uv, vec2 position, float radius, float blur) {\n    uv -=0.5;\t\t\t\t\t\t\t\t\t\t// position of the circle || to make (0,0) center of the screen \n    float d = length(uv-position);\n    float c = smoothstep(radius,radius-blur,d);\t\t//if(d<radius){d=1} else{d=0} and also adds blur on the edges\n    return c;\n}\n\nfloat verticalOval(vec2 uv, vec2 position, float radius, float blur, float thickness) {\n    uv -=0.5;\n    uv.x*= uv.y+thickness;\n    uv.y*=iResolution.y/iResolution.x;\t\t\t\t// position of the circle || to make (0,0) center of the screen \n    float d = length(uv-position);\n    float c = smoothstep(radius,radius-blur,d);\t\t//if(d<radius){d=1} else{d=0} and also adds blur on the edges\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = fragCoord/iResolution.xy;\n      \n    float c = circle(uv,vec2(0.),.1,.003);\n    float c2 =  circle(uv,vec2(.1),.06,.003);\n    float c3 =  circle(uv,vec2(-.1,.1),.06,.003);\n    float c4 =  oval(uv,vec2(0.,-.08),.04,.005);\n    float c5 =  oval(uv,vec2(0.025,-0.06),.04,.05);\n    float c6 =  verticalOval(uv,vec2(-0.1,.025),.04,.005,2.5);\n    float c7 =  verticalOval(uv,vec2(0.1,.025),.04,.005,2.5);\n    float c8 =  oval(uv,vec2(-0.05,0.07),.015,0.006);\n    float c9 =  oval(uv,vec2(0.03,0.07),.015,.006);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 sumAppear = vec3 (c+c2+c3+c5+c8+c9-c6-c7-c4);\n    vec3 makeAppear = col * sumAppear ;\n    \n    fragColor = vec4(makeAppear,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 64, 64, 379], [381, 381, 443, 443, 693], [695, 695, 782, 782, 1092], [1094, 1094, 1151, 1151, 1871]]}
{"id": "4dGfDz", "name": "Loop - Revolta Vermelha", "author": "SincroB", "description": "Apenas um loop com seno e coseno", "tags": ["loop", "vermelho"], "likes": 2, "viewed": 63, "date": "1528228735", "time_retrieved": "2024-06-20T19:14:57.037835", "image_code": "float getFunctional(vec2 uv) {\n    float sine = 5.0 * sin(uv.x*10.0-iTime*2.0) + 2.0 * cos(uv.y * 25.0 + iTime * 2.0);\n    float mult = sine * uv.y*2.0+0.05 * 2.0 - uv.y*2.0+0.05;\n    return mult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 a = uv*2.0 - 1.0;\n\ta *= 10.0;\n\tvec2 line = vec2(a.x, a.y);\n    line.x += getFunctional(uv);\n\tline.x /= 0.025;\n\tvec3 p = vec3(abs(line.x));\n\tp *= vec3(0.85,0.1,0.1);\n\tfragColor = vec4(p,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 30, 30, 198], [200, 200, 257, 257, 498]]}
{"id": "4dGfWh", "name": "Black and white grid", "author": "mitjaprelovsek", "description": "undulating black and white rectangles", "tags": ["grid", "blackandwhite"], "likes": 1, "viewed": 156, "date": "1528468761", "time_retrieved": "2024-06-20T19:14:57.262058", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Inputs\n    float gridRows=5.0;\n    float gridCols=9.0;\n    float brightness=0.5;\n    float movingSpeed=1.0;\n    float waveSize=0.2;\n    float angle = 0.5;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //We find out in which grid the pixel is\n    int pixCol=int(uv.x*gridCols);\n    int pixRow=int(uv.y*gridRows);\n    \n    // Time varying pixel color\n    vec3 col = brightness + brightness*cos(iTime*movingSpeed+vec3(pixRow,pixRow,pixRow)/gridRows/waveSize*angle+vec3(pixCol,pixCol,pixCol)/gridCols/waveSize*(1.0-angle));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 70, 709]]}
{"id": "4dGfzc", "name": "The Wobbs", "author": "t3knomanser", "description": "The wobblers!", "tags": ["wobble", "palette"], "likes": 2, "viewed": 60, "date": "1529697959", "time_retrieved": "2024-06-20T19:14:57.455933", "image_code": "int pick_rule(vec2 uv, int space) {\n    return int(sin(distance(uv, vec2(0.5, 0.5))) * float(space) * 10.) % space;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 iPalette[4];\n    iPalette[0] = vec3(0x17, 0x3E, 0xA6) / 255.;\n    iPalette[1] = vec3(0xA5, 0x0E, 0x0E) / 255.;\n    iPalette[2] = vec3(0xE3, 0x74, 0x00) / 255.;\n    iPalette[3] = vec3(0x0D, 0x65, 0x2D) / 255.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tint p = pick_rule(uv * sin(iTime + uv.x), iPalette.length());\n    int q = pick_rule(uv * cos(iTime + uv.y), iPalette.length());\n    \n    float m = smoothstep(-1., 1.,\n                           sin(uv.x * uv.y / sin(uv.x))\n                           );\n    \n    vec3 col = mix(iPalette[p], iPalette[q], m);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 35, 35, 117], [119, 119, 176, 176, 859]]}
{"id": "4dKBWW", "name": "Glyphs", "author": "JabberSnatch", "description": "Ancient civilisation writings sliding around", "tags": ["abstract"], "likes": 3, "viewed": 86, "date": "1528899181", "time_retrieved": "2024-06-20T19:14:58.007563", "image_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nvec2 NDC(vec2 frag_coord)\n{\n\treturn (frag_coord / iResolution.xy) * 2.0 - 1.0;\n}\n\nvec2 VerticalAspectCoordinates(vec2 frag_coord)\n{\n\tvec2 ndc = NDC(frag_coord);\n\tvec2 aspect_factor = vec2(iResolution.x / iResolution.y, 1.0);\n\treturn ndc * aspect_factor;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p)-b, 0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udRoundSegment(vec3 p, vec3 start, vec3 end, float r)\n{\n\tvec3 extent = (end - start) * 0.5;\n\tvec3 center = (end + start) * 0.5;\n\treturn udRoundBox(p - center, extent, r);\n}\n\n\nfloat object(vec3 p, float r)\n{\n\tfloat distance = udRoundSegment(p, vec3(0.25, 0.25, 0.0), vec3(0.25, 0.75, 0.0), r);\n\tdistance = min(distance, udRoundSegment(p, vec3(0.75, 0.25, 0.0), vec3(0.75, 0.75, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.25, 0.0), vec3(0.5, 0.5, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.5, 0.0), vec3(0.75, 0.5, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.75, 0.0), vec3(0.5, 0.75, 0.0), r));\n\treturn distance;\n}\n\nfloat rand_object(vec3 p, float rand_seed)\n{\n\tfloat points[3] = float[3](0.18, 0.5, 0.82);\n\tfloat radius = 0.11;\n\tfloat segment_p = 0.5;\n\n\tfloat rand_state = rand_seed;\n\tfloat distance = 1. / 0.;\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tdistance = min(distance, sdSphere(p - vec3(points[i], points[j], 0.0), radius));\n\t\t}\n\t}\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfloat constant_point = points[i/2];\n\t\tint start_index = int(mod(float(i), 2.0));\n\t\tvec2 start = vec2(points[start_index], constant_point);\n\t\tvec2 end = vec2(points[start_index + 1], constant_point);\n\t\tif (rand_state < segment_p)\n\t\t{\n\t\t\tdistance = min(distance, udRoundSegment(p, vec3(start, 0.0), vec3(end, 0.0), radius));\n\t\t}\n\t\telse if (rand_state > segment_p)\n\t\t{\n\t\t\tdistance = min(distance, udRoundSegment(p, vec3(start.yx, 0.0), vec3(end.yx, 0.0), radius));\n\t\t}\n\t\trand_state = rand(rand_state);\n\t}\n\treturn distance;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n\tfloat scale = 15.0;\n\tvec3 glyph_color = vec3(0.67, 0.65, 0.42);\n\tvec3 background_color = vec3(0.05, 0.04, 0.03);\n\n\tvec2 local_coord = VerticalAspectCoordinates(frag_coord);\n\tvec3 world_position = vec3(local_coord * scale + vec2(0.5), 0.0) + vec3(vec2(iTime), 0.0);\n\tvec3 floor_wp = floor(world_position);\n\n\tfloat distance = 1.0;\n\tdistance = rand_object(fract(world_position.xyz), rand(floor_wp.xy));\n\n\tfloat intensity = sin((iTime + rand(floor_wp.xy) * 4.0) * (rand(floor_wp.yx) + 0.5));\n#if 1\n\tintensity = max(0.0, -distance * 15.0) * intensity;\n#else\n\tif (distance > 0.0)\n\t{\n\t\tintensity = 0.0;\n\t}\n#endif\n\n\tintensity = clamp(intensity, 0.0, 1.0);\n\tfrag_color = vec4(mix(abs(distance) * background_color * 20.0, glyph_color, intensity), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dKBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 58], [60, 60, 80, 80, 146], [149, 149, 176, 176, 229], [231, 231, 280, 280, 404], [407, 407, 450, 450, 490], [492, 492, 525, 525, 550], [552, 552, 613, 613, 730], [733, 733, 764, 764, 1242], [1244, 1244, 1288, 1288, 2152], [2154, 2154, 2211, 2211, 2957]]}
{"id": "4dKfDW", "name": "Circle tendrils", "author": "noby", "description": "A variation.", "tags": ["2d", "noise", "perlin", "circle", "antialiasing", "simplex"], "likes": 15, "viewed": 224, "date": "1528893934", "time_retrieved": "2024-06-20T19:14:58.007563", "image_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat simplex(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy));\n  vec3 x0 =   v - i + dot(i, C.xxx);\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n  i = mod(i, 289.0); \n  vec4 p = permute(permute(permute(i.z+vec4(0,i1.z,i2.z,1))+i.y+vec4(0,i1.y,i2.y,1))+i.x+vec4(0,i1.x,i2.x,1));\n  float n_ = 1.0/7.0;\n  vec3  ns = n_ * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = 1.0/sqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col = 0.0;\n    for(int i = 0; i < 30; i++)\n    {\n        // coordinates\n        vec2 uv = -1.0+2.0*fragCoord/iResolution.xy;\n        uv.x *= iResolution.x/iResolution.y;\n        \n        float scale = 3.0+3.0*pow(0.5+0.5*cos(iTime*0.41),2.0);\n        uv *= pow(1.015+mix(0.03, 0.0, scale/10.0), float(i));\n        float rf = length(fwidth(uv));\n        \n\t\tuv+=iTime*0.02;\n        \n        // rotate\n        float a = (iTime)*0.19;\n        uv *= mat2(cos(a),sin(a),-sin(a),cos(a));\n\n        // zoom\n        uv *= scale;\n\n        // repeat & pattern\n        float repeat = 1.75+1.25*(0.5+0.5*sin(1.0+iTime*0.61));\n        float r = pow(0.5+0.5*simplex(vec3( round(0.5+uv/repeat)*(1.0/scale), 0.05*float(i)+iTime*0.77)),3.0);\n        uv = mod(uv,repeat)-repeat/2.0;\n\n        float aa = 1.8*scale*rf*sqrt(r);\n        \n        float shape = pow(uv.x,2.0)+pow(uv.y,2.0);\n        col += (smoothstep(r-aa,r, shape)-smoothstep(r,r+aa, shape))/(pow(float(1+i),1.0));        \n    }\n    \n    fragColor = vec4(pow(col, 1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dKfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 58], [59, 59, 81, 81, 1531], [1533, 1533, 1590, 1590, 2619]]}
{"id": "4dKfW1", "name": "Voronoi tiles", "author": "Veggiebob", "description": "An animated, real-time voronoi diagram.", "tags": ["voronoi", "noise"], "likes": 2, "viewed": 108, "date": "1528675489", "time_retrieved": "2024-06-20T19:14:58.505176", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    uv.x*=aspect;\n    const int numPoints = 25;\n    float[numPoints] pointsx = float[numPoints](\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.);\n    float[numPoints] pointsy = pointsx;\n    float d = 100000.;\n    float ld = d;\n    for(int i = 0; i<numPoints; i++){\n        float j = float(i);\n        pointsx[i] = snoise(vec2(iTime*0.01+j))+mouse.x*aspect;\n        pointsy[i] = snoise(vec2(iTime*0.01+j+1.))+mouse.y;\n        float dist = length(vec2(pointsx[i], pointsy[i])-uv);\n        if(dist<d){ ld = d; d = dist;}\n    }\n    vec3 col = vec3(d);\n    float edge = 0.03;\n    float diff = abs(ld-d);\n    if(diff<edge){col = vec3(0.0, sqrt(diff/edge)*0.0, 0.);} else { col = vec3(0., d, 0.); }\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dKfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 203], [204, 204, 228, 228, 1734], [1735, 1735, 1792, 1792, 2744]]}
{"id": "4dKfWD", "name": "mandelbrot fork from iq", "author": "flimshaw", "description": "trying to grok more of iq's nuggets, i'm pretty sure it was this one I started with https://www.shadertoy.com/view/lsX3W4", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 78, "date": "1528993740", "time_retrieved": "2024-06-20T19:14:58.510619", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nprecision highp float;\n#define STEPS 256\n\n\n\nvoid mainImage( out vec4 f, in vec2 p )\n{\n    float n = 0.;\n    vec2 c = (2.*p - iResolution.xy/iResolution.y)*2.0-1.;\n    c *= .01;\n    c.x -= .5;\n    float t = (sin(-iTime*.05)+1.)*20. + 0.02;\n    c *= .00125 * t;\n    c -= vec2(1.394, 0.0055);// + sin(vec2(1.,.2) + iTime) * .01;\n\tvec2 z = vec2(0.0);\n    \n    for( int i=0; i<STEPS; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + c;\n        if(length(z)>4.) break;\n        n++;\n    }\n    \n    //f = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(dot(z,z)))) );\n    vec4 col = vec4(3,4,11,0);\n    //float g = n - log2(log2(dot(z,z)));\n    float cc = (n - log2(dot(z,z)));\n    f = vec4(.5 + .5*cos(iTime+col + .05*cc));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dKfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 168, 209, 209, 858]]}
{"id": "4dVBWW", "name": "Animated Voronoise", "author": "AustinSpafford", "description": "Trying out animating iq's voronoise example: https://www.shadertoy.com/view/Xd23Dh\n\nThe click+drag controls from the original voronoise example can still be used, and I recommend trying out ENABLE_WATER_CAUSTICS_MODE.", "tags": ["voronoise"], "likes": 7, "viewed": 201, "date": "1528880213", "time_retrieved": "2024-06-20T19:14:59.025806", "image_code": "//#define ENABLE_WATER_CAUSTICS_MODE\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n    \n    //vec2 noiseTexelSize = (vec2(1.0) / iChannelResolution[0].xy);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {            \n        vec2 g = vec2( float(i),float(j) );\n        \n        /* Original static-params.\n        vec3 cellParams = hash3(p + g);\n\t\t*/\n        \n        /* Aborted buggy attempt to use a noise texture.\n        float animationScalar = (0.5 * iTime);\n        float animationFract = fract(animationScalar);\n        vec2 paramsOrigin = (13.0 * (p + g));\n        vec2 baseParamsIndex = (paramsOrigin + vec2(floor(animationScalar), 0.0));                            \n        vec3 startSeedSample = texture(iChannel0, (baseParamsIndex + vec2(0.5)) * noiseTexelSize).xyz;\n        vec3 endSeedSample = texture(iChannel0, ((baseParamsIndex + vec2(1.0, 0.0)) + vec2(0.5)) * noiseTexelSize).xyz;\n        vec3 cellParams = smoothstep(startSeedSample, endSeedSample, vec3(animationFract));\n        //cellParams = texture(iChannel0, ((paramsOrigin + vec2(animationScalar, 0.0)) + vec2(0.5)) * noiseTexelSize).xyz;\n\t\t*/\n        \n        // Straightforward sin waves.\n        vec3 cellParamSpeeds = mix(vec3(0.05), vec3(0.6), hash3(p + g));\n        vec3 cellParams = smoothstep(-1.0, 1.0, sin(cellParamSpeeds * (iTime + 200.0)));\n        cellParams.xy = mix(vec2(0.1), vec2(0.9), cellParams.xy); // Avoid overly sharp edges my ensuring a minimum distance between the cell-centers.\n\t\t\n\t\tvec3 o = cellParams*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xx;\n    vec2 uv = fragCoord.xy / 800.0;\n\n    vec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tif( iMouse.z>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n    \n    vec3 color = vec3(f);\n    \n    #ifdef ENABLE_WATER_CAUSTICS_MODE\n    {    \n        // Add more octaves.\n        f = mix(f, iqnoise(41.0*uv + vec2(1000.0), p.x, p.y), 0.33);\n        //f = mix(f, iqnoise(57.0*uv, p.x, p.y), 0.33);\n\n        // Highlight the intersections between the octaves.\n        f = pow(f, 2.0);\n\n        // Add a bluish tint while keeping white highlights by filtering out some of the low-end on the red/green channels.\n        // Also add small hot-spot highlights, by slightly clamping at the ceiling.\n        float high_end_clamp = 0.95;\n        color = vec3(\n            smoothstep(0.25, high_end_clamp, f),\n            smoothstep(0.1, high_end_clamp, f),\n            smoothstep(0.0, high_end_clamp, f));\n\t}\n    #endif\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 38, 60, 60, 211], [213, 213, 259, 259, 1995], [1997, 1997, 2054, 2098, 3193]]}
{"id": "4dVfR3", "name": "Refraction mapping", "author": "setchi", "description": "Refraction mapping", "tags": ["raymarching", "refraction"], "likes": 26, "viewed": 1051, "date": "1529810999", "time_retrieved": "2024-06-20T19:14:59.025806", "image_code": "#define PI 3.141592654\n\nconst float EPS = 1e-2;\nconst float EPS_N = 1e-3;\nfloat OFFSET = EPS * 300.0;\n\nfloat TIME;\n\nvec3 rotateX(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nvec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 1.0 / 7.0; // N=7\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y + 3.5;\n}\n\nfloat udBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat dGlass(vec3 p) {\n    float t = TIME * 1.9;\n    float it = mod(floor(t), 4.);\n    float ft = smoothstep(0.3, 0.9, fract(t));\n    float nt = step(it, 0.) - step(it, 1.);\n\n    p.yx += snoise(p * 1. + vec3(t, -t, 0)) * sin(fract(t) * PI) * nt * 0.2;\n    float torus = sdTorus(rotateX(p, PI / 2.), vec2(.5, .2));\n    float sphere = sdSphere(p, .6);\n    float box = udBox(rotateY(rotateX(p, PI / 4.), PI / 4.), vec3(0.4), 0.05);\n\n    if (it == 0.)\n        return mix(box, sphere, ft);\n    if (it == 1.)\n        return sphere;\n    if (it == 2.)\n        return mix(sphere, torus, ft);\n    if (it == 3.)\n        return mix(torus, box, ft);\n}\n\nfloat map(vec3 p) {\n    float b = sdPlane(p);\n    float c = dGlass(p);\n    return min(b, c);\n}\n\nfloat rand(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat box_size(vec2 st, float n) {\n    st = (floor(st * n) + 0.5) / n;\n    float offs = rand(st) * 5.;\n    return (1. + sin(TIME * 3. + offs)) * 0.5;\n}\n\nfloat box(vec2 st, float size) {\n    size = 0.5 + size * 0.5;\n    st = step(st, vec2(size)) * step(1.0 - st, vec2(size));\n    return st.x * st.y;\n}\n\nvec3 pattern(vec2 p) {\n    float n = 1.;\n    vec2 st = fract(p * n);\n    float size = box_size(p, n);\n    return vec3(box(st, size)) * 0.5;\n}\n\nvec2 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        float res = map(ro + ray * t);\n        if (res < 0.005) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec3 eps = vec3(e, 0.0, 0.0);\n\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 render(vec2 p) {\n    vec3 ro = vec3(6., 2.5, 6.);\n    vec3 ta = vec3(0);\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 10.0));\n\n    vec3 fresnel = vec3(0, 0, 0);\n\n    for (int i = 0; i < 2; i++) {\n        // marching loop\n        vec2 res = intersect(ro, ray);\n\n        // hit check\n        if (res.y <= -0.5) {\n            return vec3(1.0);\n        }\n        \n        vec3 pos = ro + ray * res.x;\n        vec3 nor = normal(pos, 0.008);\n\n        if (dGlass(pos) > 0.005) {\n            vec3 col = vec3(0);\n            col += pattern(pos.xz);\n            col += fresnel;\n            return col + vec3(0.001, 0.002, 0.004) * res.x;\n        }\n\n        if (i == 0 && dot(-ray, nor) < 0.5) {\n            float a = 1. - dot(-ray, nor) * 2.;\n            fresnel = mix(fresnel, vec3(0., 0.8, 0.8), a);\n        }\n\n        float eta = 0.9;\n        ray = normalize(refract(ray, nor, eta));\n        ro = pos + ray * OFFSET;\n    }\n}\n\nvec3 aaRender(vec2 p) {\n  vec3 col = vec3(0.0);\n  const int iter = 4;\n\n  for (int i = 1; i <= iter; i++) {\n    float fi = float(i);\n    vec2 offset = (vec2(step(fi, 2.), mod(fi, 2.)) - .5) * 0.0015;\n    col += render(p + offset);\n  }\n\n  return col / float(iter);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  TIME = iTime;\n  vec3 color = aaRender(uv) + 0.2;\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[116, 116, 151, 151, 266], [268, 268, 303, 303, 417], [419, 419, 441, 441, 486], [487, 487, 515, 515, 565], [567, 567, 589, 589, 2324], [2326, 2326, 2349, 2349, 2373], [2375, 2375, 2413, 2413, 2460], [2462, 2462, 2495, 2495, 2523], [2525, 2525, 2556, 2556, 2630], [2632, 2632, 2654, 2654, 3270], [3272, 3272, 3291, 3291, 3366], [3368, 3368, 3389, 3389, 3459], [3461, 3461, 3495, 3495, 3612], [3614, 3614, 3646, 3646, 3761], [3763, 3763, 3785, 3785, 3904], [3906, 3906, 3941, 3941, 4131], [4133, 4133, 4165, 4165, 4378], [4380, 4380, 4427, 4427, 4615], [4617, 4617, 4638, 4638, 5572], [5574, 5574, 5597, 5597, 5838], [5840, 5840, 5895, 5895, 6068]]}
{"id": "4dVfzW", "name": "Orleans", "author": "Plento", "description": "code heavily based around IQ's raymarching primitives https://www.shadertoy.com/view/Xds3zN. Not much to say about this other than I think it looks cool.", "tags": ["raymarch"], "likes": 21, "viewed": 394, "date": "1528841051", "time_retrieved": "2024-06-20T19:15:00.001647", "image_code": "\n#define MAX_STEPS 512\n#define CLOSE_CLIP 0.1\n#define FAR_CLIP 100.0\n#define EPSILON 0.0001\n\nmat2 rotmat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 mouse()\n{\n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n\treturn m;\n}\n\nfloat sdSphere(vec3 rayPos, float radius)\n{\n \treturn length(rayPos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 k,float t)\n{\n\treturn vec2(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\n}\n\nvec2 map(vec3 pos)\n{\n \t\n    vec3 b = vec3(0.9 , 4.5, 0.70);\n    float p = sin(pos.z * 0.1) * 2.0;\n  \n    pos = vec3(rotate(pos.xy, p), pos.z);\n    \n    pos.y += iTime * 1.2;\n    pos = mod(pos, b) -0.5 * b;\n    \n    pos.x *= sin(length(pos * 1.8) * 2.0) * 1.4;\n    \n    float boxScale = 0.4;\n    \n    vec2 result = vec2(sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(boxScale)), 1.0);\n  \n    return result;\n}\n\n\n\nvec2 sdScene(vec3 pos)\n{\n    \n    vec2 scene = map(pos);\n    \n    return scene;\n    \n}\n\nvec2 raymarch(vec3 rayStartPos, vec3 ray_direction)\n{\n    float depth = CLOSE_CLIP;\n \t\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec2 result = sdScene(rayStartPos + ray_direction * depth);\n            \n        if(abs(result.x) < EPSILON)\n            return vec2(depth, result.y);\n        \n        depth += result.x;\n        \n        if(depth > FAR_CLIP)\n            return vec2(FAR_CLIP, 0.0);;\n        \n    }\n    \n    return vec2(FAR_CLIP, 0.0);\n}\n\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{  \n    vec3 n;\n    vec2 dn = vec2(smoothness, 0.0);\n    \n    float d = sdScene(ray_hit_position).x;\n    \n    n.x = sdScene(ray_hit_position + dn.xyy).x - d;\n    n.y = sdScene(ray_hit_position + dn.yxy).x - d;\n    n.z = sdScene(ray_hit_position + dn.yyx).x - d;\n    \n    return normalize(n);\n}\n\n\nfloat softshadow( vec3 ray_origin, vec3 ray_direction, float mint, float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<8; i++ )\n    {\n\t\tfloat h = map( ray_origin + ray_direction * t ).x;\n        \n        res = min( res, 8.0*h/t );\n        \n        t += clamp( h, 0.02, 0.10 );\n        \n        if( h<0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(vec3 ray_pos, vec3 ray_direction)\n{\n \t   \n    vec2 result = raymarch(ray_pos, ray_direction);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n   \tfloat d = result.x;\n    float m = result.y;\n    \n    vec3 pos = ray_pos + d * ray_direction;\n    \n    vec3 nrml = normal(pos, 0.001);\n    float occ = calcAO( pos, nrml ); // ambient occlusion\n    \n   \n    vec3  lig = normalize( vec3(-0.5, 0.5, -0.5) ); // sunlight\n   \n    if(m == 1.0)\n        col = vec3(0.3, 0.3, 0.45);\n    \n    vec3 lin = vec3(0.0);\n    vec3 ref = reflect( ray_direction, nrml ); // reflected ray\n   \n\tfloat amb = clamp( 0.5 + 0.5 * nrml.y, 0.0, 1.0 ); // ambient light\n    float dif = clamp( dot( nrml, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n    float spec = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n    float fre = pow( clamp(1.0 + dot(nrml,ray_direction),0.0,1.0), 2.0 ); // fresnel\n    float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n    \n    dif *= softshadow( pos, lig, 0.3, 4.5 );\n    dom *= softshadow( pos, ref, 0.3, 2.5 ) ;\n    \n    lin += 2.30 * dif * vec3(1.00,0.80,0.55) ;\n    lin += 2.00 * spec * vec3(1.00,0.90,0.70) * dif ;\n    lin += 0.20 * amb * vec3(0.40,0.60,1.00) * occ ;\n    lin += 0.45 * fre * vec3(1.00,1.00,1.00) * occ ;\n    lin += 0.20 * dom * vec3(0.40,0.60,1.00) ;\n   \n    col = col * lin;\n    \n    vec3 fogCol =  mix(vec3(.7, .7, .9), vec3(.5, 1, 1.2), ray_direction.y*.5 + .5);\ncol = mix( col, fogCol, 1.0 - exp( -0.00035*d*d*d ) );\n    //col = mix( col, vec3(0.6,0.9,1.0), 1.0 - exp( -0.00035*d*d*d ) );\n    \n    return vec3( clamp(col, 0.0, 1.0));    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n   \n    vec3 camera = vec3(0.0, 0.0, 0.0);\n    camera.z += iTime * 3.0;\n    //camera.y = mouse().y * 20.0;\n    vec3 ray_direction = normalize(vec3(uv, 2.0));\n   \n    //ray_direction.xz *= rotmat(-mouse().x * 10.0);\n    //ray_direction.yz *= rotmat(mouse().y * 10.0);\n    \n    vec3 col = render(camera, ray_direction);\n    \n    float o = smoothstep(0.99, 0.2, length(uv));\n  \n    fragColor = vec4(col, 1.0) ;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVfzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[93, 93, 115, 115, 167], [169, 169, 183, 183, 281], [283, 283, 326, 326, 362], [364, 364, 395, 395, 482], [484, 484, 513, 513, 587], [589, 589, 609, 609, 987], [991, 991, 1015, 1015, 1077], [1079, 1079, 1132, 1132, 1535], [1538, 1538, 1592, 1592, 1884], [1887, 1887, 1968, 1968, 2282], [2284, 2284, 2326, 2326, 2625], [2627, 2627, 2674, 2674, 4247], [4250, 4250, 4307, 4307, 4796]]}
{"id": "4dyBWK", "name": "Vorostripes", "author": "mlkn", "description": "Having fun with voronoi.", "tags": ["2d", "voronoi", "distance"], "likes": 5, "viewed": 359, "date": "1530380640", "time_retrieved": "2024-06-20T19:15:00.389564", "image_code": "#define EPSILON .00001\n\n// https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// https://www.shadertoy.com/view/llG3zy\nvec4 voronoi( in vec2 x )\n{\n    bool isStripes = true;\n    float moveDir = mod(floor(x.y), 2.0) > 0.5 ? 1.0 : -1.0;\n    if (isStripes) {\n        float speedMult = floor(x.y + 1.0) * 0.3;\n    \tx.x += iTime * moveDir * speedMult ;\n    }\n    \n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 closestPoint;\n    float id;\n\n    float minDist = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash( n + cell );\n        \n        vec2 r = cell - f + (0.5+0.5*sin(iTime+6.2831*point));\n        float dist = dot(r,r);\n\n        if( dist < minDist )\n        {\n            minDist = dist;\n            closestPoint = r;\n            id = point.x + point.y;\n        }\n    }\n\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    minDist = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash( n + cell );\n        if (isStripes) {\n           point = mix(hash( n + cell ), vec2(n + cell) * 0.1, moveDir > 0.0 ? 0.0 : 1.0);\n        }\n\t\tvec2 r = cell - f + (0.5+0.5*sin(iTime+6.2831*point));\n\n        if( dot(closestPoint-r,closestPoint-r) > EPSILON ) // skip the same cell\n        minDist = min( minDist, dot( 0.5*(closestPoint+r), normalize(r-closestPoint) ) );\n    }\n\n    return vec4( minDist, closestPoint, id );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    \n    vec4 voro = voronoi( (10.0 + sin(iTime*0.1)*8.0)*p);\n    float dist = voro.x;\n\n    vec2 gb = 0.5 + 0.5*cos(vec2(voro.w+iTime*0.3, voro.w * sin(iTime * 0.2))*6.2831 );\t\n\t\n    fragColor.rgb = vec3(1.0 - step(dist, 0.1), gb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyBWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 65, 86, 86, 177], [179, 220, 247, 247, 1655], [1657, 1657, 1714, 1714, 2008]]}
{"id": "4dyfRd", "name": "Fake reflections", "author": "JohanFlod", "description": "Trying to replicate some old Amiga demo scene effects. Playing around with shaders for fun. ", "tags": ["2d", "circles"], "likes": 2, "viewed": 174, "date": "1529948895", "time_retrieved": "2024-06-20T19:15:00.389564", "image_code": "\nvec2 st; //2D plane\nvec3 col; //Color palette\nfloat xPosition;\nfloat yPosition1;\nfloat yPosition2;\nfloat yPosition3;\nfloat radius;\n\nvoid col_bg(){col = vec3(0.2,0.2,0.2);}\n\nvoid rotate (float deg)\n{\n\tfloat rad = radians(deg);\n\tmat2 rotamat = mat2(cos(rad),sin(rad),-sin(rad),cos(rad));\n\tst = rotamat * (st);\n}\n\nbool isellipse(float x_center, float y_center, float radius1, float radius2)\n{\n    bool result = false;\n    \n    if (sqrt( radius1*pow(st.x - x_center,2.0) \n             + radius2*pow(st.y - y_center,2.0)\n            ) < radius1 * radius2\n        )result = true;\n        \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 circle_position1;\n    vec2 circle_position2;\n    vec2 circle_position3;\n    \n    vec3 col1 = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    vec3 col3 = vec3(0.0);\n    st = fragCoord/iResolution.xy;\n    st*=5.0;\n\tcircle_position1.x = 2.5+1.5*(sin(1.5*iTime));\n    // offset in x for second sphere \n    circle_position2.x = 2.5+1.5*(sin(1.5*iTime+1.2));\n    // offset in x for third sphere\n    circle_position3.x = 2.5+1.5*(sin(1.5*iTime+2.4));\n\t\n    circle_position1.y  = 2.5+0.5*(sin(2.*iTime));\n    // offset in y for second sphere \n    circle_position2.y = 2.5+0.5*(sin(2.*iTime+1.2));\n    // offset in y for second sphere \n    circle_position3.y = 2.5+0.5*(sin(2.*iTime+2.4));\n    \n    float radius = 1.15;\n\n    float radius2 = radius*0.5;\n    \n    \n    \n    float lowerLimit = 0.0;\n    float upperLimit = 1.5;\n    \n    \n    float color = 1.0;\n    \n    col = vec3(0.2,0.2,0.2);\n  \n    \n    if (st.y < upperLimit && st.y > lowerLimit){\n        color = distance(st.y,upperLimit);\n        float perc = (color - lowerLimit) / (upperLimit - lowerLimit);\n        col = vec3(perc);\n              \n    }\n   \n \n    if(isellipse(circle_position1.x, circle_position1.y , radius, radius2))\n    {\n        \n    \tcol1 = vec3(1.0,vec2(0.0));\n    }\n    \n    // reflection of red \"sphere\"\n    if(isellipse(circle_position1.x, 1.2-0.5*circle_position1.y, radius, radius2))\n    {\n        float colour = 0.2;\n    \tcol1 = vec3(colour,0.0,0.0);\n    }\n    if(isellipse(circle_position2.x, circle_position2.y , radius, radius2))\n    {\n        float colour = 1.0;\n    \tcol2 = vec3(0.0,colour,0.0);\n    }\n    if(isellipse(circle_position2.x, 1.2-0.5*circle_position2.y , radius, radius2))\n    {\n        float colour = 0.2;\n    \tcol2 = vec3(0.0,colour,0.0);\n    }\n    if(isellipse(circle_position3.x, circle_position3.y , radius, radius2))\n    {\n        float colour = 1.0;\n    \tcol3 = vec3(0.0,0.0,colour);\n    }\n    if(isellipse(circle_position3.x, 1.2-0.5*circle_position3.y , radius, radius2))\n    {\n        float colour = 0.2;\n    \tcol3 = vec3(0.0,0.0,colour);\n    }\n\n   \n\t\n\tfragColor = vec4(col1+col+col2+col3,0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[10, 133, 147, 147, 172], [174, 174, 199, 199, 310], [312, 312, 390, 390, 604], [610, 610, 667, 667, 2770]]}
{"id": "4dyfzw", "name": "SDF Castle", "author": "selenologist", "description": "Super inefficient distance function raycaster. My GPU can almost go 60fps fullscreen, which is amazing considering the amount of pointless duplication involved in evaluating the SDF functions constantly", "tags": ["raycasting", "sdf"], "likes": 1, "viewed": 123, "date": "1527921790", "time_retrieved": "2024-06-20T19:15:02.195757", "image_code": "/*Uses code from:\n * https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n * http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n * http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n * probably elsewhere\n * possibly breaking licenses here; I just wanna make pretty graphics, man\n *\n * contains unused code - leaving it because it might be useful\n *\n * when marching steps are exhausted, the last closest material is chosen.\n * This causes a trippy blur around the edges of objects and allows for a lower step count.\n*/\n\nprecision highp float; // possibly numerically unstable with 16-bit floats?\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nfloat key(int keyid){\n    return texelFetch(iChannel2, ivec2(keyid,0),0).x;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nconst int MAX_MARCHING_STEPS = 48;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 512.0; // increase to draw further, I don't think there are actually drawbacks to increasing this? unless shaders can work-steal\nconst float EPSILON = 0.0001; // used to derive the gradient to get the normal, maybe mess with this\n\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat boxSDF(vec3 p, vec3 dim) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - dim;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sphSDF(vec3 p) { // sphere\n    return length(p) - 1.0;\n}\n\nfloat cylSDF(vec3 p){ // cylinder\n  vec2 d = abs(vec2(length(p.xz),p.y)) - 1.0;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat uni(const float a, const float b){ // union\n    return min(a,b);\n}\nfloat sub(const float a, const float b){ // subtract\n    return max(a,-b);\n}\nfloat its(const float a, const float b){ // InTerSection because I can't call it \"int\"\n    return max(a,b);\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n#define sca(__f, __p, __s)   ( __f(__p *      (1. / __s))         * __s )\n#define scaXZ(__f, __p, __s) ( __f(__p * vec2((1. / __s),1.).xyx) * min(1., __s) )\n\nvec3 rotateY(float theta, vec3 p) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return (mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    ) * vec4(p, 1.0)).xyz;\n}\n\n// a rotatable box used to cut the arrow slots on the towers\nfloat plank(vec3 p, float theta){\n\treturn boxSDF(rotateY(theta, p), vec3(1.1, 0.1, 0.1));\n}\n\nconst float PI = 3.141592653589793;\nfloat castletowerSDF(vec3 p){\n    vec3 p2 = p - vec2(0., 1.05).xyx; // move cutouts up to cut them from the tower\n    float cutouts =\n        uni(uni(plank(p2,0.)   , plank(p2, PI/2.)),\n        \tuni(plank(p2,PI/4.), plank(p2, PI/4.*3.)));\n    cutouts = uni(cutouts, its(boxSDF(p2, vec3(1.0,0.2,1.0)), sca(cylSDF,p2,0.75)));\n    return sub(cylSDF(p),\n               cutouts);\n}\n\nfloat corner_inner(vec3 p){\n    return castletowerSDF(p - vec2(4., 0.).xyx);\n}\n\nfloat corner(vec3 p){\n    return scaXZ(corner_inner,p, 0.125); // spread out space to fit a whole tower in one corner\n}\n\nfloat four(vec3 p){\n    vec3 rpt = mod(p, 1.0);\n    return corner(vec3(rpt.x, p.y, rpt.z));\n}\n\nfloat castletowersSDF(vec3 p){\n    return its(four(p), cubeSDF(p)); // clip to unit cube\n}\n\nfloat drawbridgeSDF(vec3 p){ //drawbridge hole\n    vec3 ps = p + vec3(0.,0.3,0.6); // move drawbridge cut down and forwards\n    return sca(cylSDF,ps.xzy * vec2(1.,0.6).xxy,0.21);\n}\n\nfloat castlewallsSDF(vec3 p){\n    const vec2 o          = vec2(0.1, 0.0);\n    const vec3 bodydims   = vec3(0.5, 0.35, 0.45);\n    const vec3 cutoutdims = bodydims.zyz; // for inner hollow cutout\n    float mainwall = sub(boxSDF(p, bodydims.xyx),\n                         boxSDF(p-o.yxy, cutoutdims));\n    \n\tconst vec3 grid = vec2(0.025,0.2).yyx;\n    vec3 gridp = rep(p, vec2(0.15, 4.).xyx) + vec2(0., 1.5).xyx; // magic trial-and-error constants\n    float gridcutout =\n        uni(\n            uni(boxSDF(gridp.xyz, grid), boxSDF(gridp.zyx, grid)),\n            drawbridgeSDF(p));\n    return sub(mainwall, gridcutout);\n}\n\nfloat terrainSDF(vec3 p){ // called by shortestDistanceToSurface()\n    float scale = 0.5; // range [0,1.0]\n    float sstep = smoothstep(.5, 2., length(p.xz));\n    scale *= sstep;\n    \n    float height = noise(vec3(p.xz, iTime * 0.3)) * scale;\n    return (p.y*0.5) * (1.-scale) + height;\n}\n\nfloat castleSDF(vec3 p) {\n    p -= vec2(0.,0.35).xyx;\n    return uni(castlewallsSDF(p), castletowersSDF(p));\n}\n\nfloat objectSDF(vec3 p) { // called by shortestDistanceToSurface()\n    return castleSDF(p);\n}\n\nfloat sceneSDF(vec3 p){ // called by normal calculator\n    return uni(objectSDF(p), terrainSDF(p));\n}\n\n/**\n * Return a vec2 containing the shortest distance from the eyepoint to the scene surface along\n * the marching direction, and the type of material at that point.\n * .y =\n *   -1 when depth or march limit hit\n *    0 when grass\n *    1 when stone\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    const float start = MIN_DIST;\n    const vec2    end = vec2(MAX_DIST, -1.0);\n    float depth = start;\n    float odist, tdist;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3      p = eye + depth * marchingDirection;\n        odist = objectSDF(p);\n        tdist = terrainSDF(p);\n        float  dist = min(odist,tdist);\n        if (dist < EPSILON) {\n\t\t\tbreak; // close to surface, stop iterating\n        }\n        depth += dist; // maybe this accumulator should be error-compensated\n        if (depth >= end.x) {\n            return end; // beyond end, hit nothing\n        }\n    }\n    float  type = step(odist - tdist,0.);\n    return vec2(depth,type); // out of steps, hit nothing; still return closest material\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phong(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n           vec3 lightPos, vec3 lightColor, vec3 N) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightColor * (k_d * dotLN);\n    }\n    return lightColor * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 triplanar(vec3 wPos, const vec3 wNorm){\n    vec3 blend = normalize(max(abs(wNorm), 0.001));\n\n    wPos *=3.;\n    vec3 x = texture(iChannel0, wPos.zy).xyz;\n    vec3 y = texture(iChannel0, wPos.xz).xyz;\n    vec3 z = texture(iChannel0, wPos.xy).xyz;\n\n    return x * blend.x + y * blend.y + z * blend.z;\n}\nfloat triplanarTerrain(vec3 wPos, const vec3 wNorm){\n    vec3 blend = normalize(max(abs(wNorm), 0.001));\n\n    wPos *=3.;\n    float x = texture(iChannel1, wPos.zy).x;\n    float y = texture(iChannel1, wPos.xz).y;\n    float z = texture(iChannel1, wPos.xy).z;\n\n    return x * blend.x + y * blend.y + z * blend.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float phase = fract(iTime * 0.04) * 2.0 * PI;\n    \n    // direction from eye position to frustrum front (i.e. like CRT screen)\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(cos(phase) * 4., 2. + sin(phase*0.5)*4.0, sin(phase) * 4.);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dist = shortestDistanceToSurface(eye, worldDir);\n    \n    if (dist.y < -0.5) {\n        // Didn't hit anything\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist.x * worldDir;\n    \n    vec3 N = estimateNormal(p);\n    \n    const vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = triplanar(p, N);\n    if(dist.y < 0.8){\n        // when grass\n        K_d = vec3(0.2, 0.8, 0.25) * triplanarTerrain(p, N);\n    }\n    const vec3 K_s = vec3(0.3, 0.2, 0.1);\n\t\n    float shininess = 6.;\n    \n    const vec3 l = vec3(5.0, 3.0, 0.);\n    vec3 lightpos = sin(phase)\n        \t\t\t* l.xyy\n        \t\t\t+ l.zxz;\n    const vec3 lightcolor = vec3(1.0, 0.9, 0.9);\n    \n    vec3 color = 0.5 * K_a + phong(K_d, K_s, shininess, p, eye, lightpos, lightcolor, N);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyfzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[594, 752, 773, 773, 829], [831, 831, 853, 853, 898], [899, 899, 919, 919, 964], [965, 965, 983, 983, 1022], [1024, 1024, 1044, 1044, 1535], [1629, 1853, 1876, 2027, 2464], [2466, 2466, 2498, 2649, 3070], [3072, 3072, 3094, 3104, 3134], [3136, 3136, 3157, 3169, 3270], [3272, 3272, 3312, 3321, 3344], [3345, 3345, 3385, 3397, 3421], [3422, 3422, 3462, 3508, 3531], [3533, 3533, 3561, 3561, 3590], [3750, 3750, 3785, 3785, 3989], [3991, 4052, 4085, 4085, 4143], [4181, 4181, 4210, 4210, 4557], [4559, 4559, 4586, 4586, 4637], [4639, 4639, 4660, 4660, 4758], [4760, 4760, 4779, 4779, 4853], [4855, 4855, 4885, 4885, 4945], [4947, 4947, 4975, 4993, 5127], [5129, 5129, 5158, 5158, 5746], [5748, 5748, 5773, 5814, 6036], [6038, 6038, 6063, 6063, 6148], [6150, 6150, 6175, 6216, 6243], [6245, 6245, 6268, 6299, 6346], [6348, 6720, 6786, 6786, 7515], [7518, 7518, 7583, 7583, 7715], [7717, 7717, 7746, 7746, 8056], [8058, 8058, 8172, 8172, 8722], [8724, 9051, 9100, 9135, 9361], [9363, 9363, 9407, 9407, 9668], [9669, 9669, 9721, 9721, 9979], [9982, 9982, 10039, 10039, 11344]]}
{"id": "4l2cWG", "name": "neon scadrial", "author": "raziel", "description": "This started as something else entirely and became an area light with random patterns illuminating some fog and terrain. Ray-marching using stuff meant for path-tracing, probably riddled with mistakes, but oh well ... pretty light ^_^", "tags": ["reflection", "terrain", "light", "volumetric", "fog", "scattering", "sampling", "transmittance", "area", "bit", "integration", "density", "angular", "equi"], "likes": 15, "viewed": 411, "date": "1528647086", "time_retrieved": "2024-06-20T19:15:04.304957", "image_code": "// --- This started as something else entirely and became an area light with random patterns illuminating some fog and terrain. \n// --- Ray-marching using stuff meant for path-tracing, probably riddled with mistakes, but oh well ...\n// --- Thanks to iq for all the ray-marching signed distance fields, noise and terrain rendering resources\n// --- http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n// --- Thanks to SebH for volumetric rendering resources\n// --- http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n// --- Solid Angle for the cool article on equi-angular sampling and sjb for example implementation\n// ---  https://www.solidangle.com/research/egsr2012_volume.pdf\n// --- Thanks to ferris from logicoma and this amazing intro https://www.youtube.com/watch?v=9r8pxIogxZ0 for inspiration\n\nfloat rand(vec2 p)\n{\n    p = 50.0 * fract(p * 0.3183099);\n    return fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat rand(float p)\n{\n    return fract(sin(p) * 54897.3451289);\n}\n\nvec2 smoothstepd(float e0, float e1, float x)\n{\n    if (x < e0)\n        return vec2(0.0, 0.0);\n    if (x > e1)\n        return vec2(1.0, 0.0);\n    \n    float t = (x - e0) / (e1 - e0);\n    float td = 1.0 / (e1 - e0);\n    return vec2(3.0 * t * t - 2.0 * t * t * t, 6.0 * t * (1.0 - t) * td);\n}\n\nfloat valueNoise(in vec2 p)\n{\n    vec2 X = floor(p);\n    vec2 x = fract(p);\n    \n    vec2 fn = x * x * x * (6.0 * x * x - 15.0 * x + 10.0);\n    float u = fn.x;\n    float v = fn.y;\n    \n    float a = rand(X + vec2(0.0, 0.0));\n    float b = rand(X + vec2(1.0, 0.0));\n    float c = rand(X + vec2(0.0, 1.0));\n    float d = rand(X + vec2(1.0, 1.0));\n    \n    float n = (b - a) * u + (c - a) * v + (a - b - c + d) * u * v + a;\n    return 2.0 * n - 1.0;\n}\n\nvec3 valueNoiseD(in vec2 p)\n{\n    vec2 X = floor(p);\n    vec2 x = fract(p);\n    \n    vec2 fn = x * x * x * (6.0 * x * x - 15.0 * x + 10.0);\n    vec2 dfn = 30.0 * x * x * (x * x - 2.0 * x + 1.0);\n    float u = fn.x;\n    float v = fn.y;\n    float du = dfn.x;\n    float dv = dfn.y;\n    \n    float a = rand(X + vec2(0.0, 0.0));\n    float b = rand(X + vec2(1.0, 0.0));\n    float c = rand(X + vec2(0.0, 1.0));\n    float d = rand(X + vec2(1.0, 1.0));\n    \n    float n = 2.0 * ((b - a) * u + (c - a) * v + (a - b - c + d) * u * v + a) - 1.0;\n    float dnu = 2.0 * du * ((b - a) + (a - b - c + d) * v);\n    float dnv = 2.0 * dv * ((c - a) + (a - b - c + d) * u);\n    return vec3(n, dnu, dnv);\n}\n\nconst mat2 fbmRot2 = mat2(0.8, 0.6,\n                         -0.6, 0.8);\n\nconst mat2 fbmRot2T = mat2(0.8, -0.6,\n                          0.6, 0.8);\n\nvec3 fbm9D(in vec2 x)\n{\n\tfloat freq = 1.98;\n    float noise = 0.0;\n    float ampl = 0.8;\n    float scale = 0.49;\n    vec2 deriv = vec2(0.0);\n    mat2 m = mat2(1.0, 0.0, 0.0, 1.0);\n    for (int i = 0; i < 9; ++i)\n    {\n        vec3 res = valueNoiseD(x);  \n        deriv += ampl * m * res.yz;\n        noise += ampl * res.x / (1.0 + dot(deriv, deriv));\n        ampl *= scale;\n        x = freq * fbmRot2 * x;\n        m = freq * fbmRot2T * m;\n    }\n    return vec3(noise, deriv);\n}\n\nfloat fbm3D(in vec2 x)\n{\n\tfloat freq = 2.15;\n    float noise = 0.0;\n    float ampl = 1.8;\n    float scale = 0.45;\n    for (int i = 0; i < 3; ++i)\n    {\n        float res = valueNoise(x);  \n        noise += ampl * res;\n        ampl *= scale;\n        x = freq * fbmRot2 * x;\n    }\n    return noise;\n}\n    \nstruct SceneData\n{\n    int materialID;\n    float sdf;\n};\n    \nstruct MarchResult\n{\n    float t;\n    int materialID;\n};\n    \nconst vec3 DirectionalLightColor = vec3(1.0, 1.0, 1.0) * 0.9;\nconst vec3 DirectionalLightDirection = normalize(vec3(-2.0, -1.8, -1.0) - vec3(5.0, -5.0, 5.0 * 2.0));\nconst vec3 AreaLightColor = vec3(1.0);//vec3(0.909, 0.65, 0.090);//vec3(0.349, 0.909, 0.729);\nconst vec3 AreaLightPosition = vec3(0.0, 0.55, 2.25);\nconst vec3 AreaLightNormal = vec3(0.0, 0.0, -1.0);\nconst vec3 AreaLightSize = vec3(0.732, 0.705, 0.00);\n    \nSceneData intersectBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    SceneData data;\n    data.sdf = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    data.materialID = 1;     \n    return data;\n}\n\nvec3 getLightIntensity(in vec3 p)\n{\n    int counter = int((iTime * 5.0)) & 255;\n    int shift = int(p.y * 32.0) & 11 + int(p.x * 32.0) & 7;\n    int on = (counter >> shift) & 1;\n    return vec3(float(on), float(1 - on), 1.0) * 10.0;\n}\n\nmat3 getRotation()\n{\n    float th =(cos(iTime * 2.1)) * 3.14159265 * 0.25; \n    float c = cos(th);\n    float s = sin(th);\n    mat3 roty = mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n    mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, 0.8, -0.6, 0.0, 0.6, 0.8);\n    return rotx * roty;\n}\n\nvoid sampleAreaLight(in vec2 uv, out vec3 lightPosition, out vec3 lightIntensity)\n{\n    vec3 normal = transpose(getRotation()) * AreaLightNormal;\n    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    vec3 bitangent = normalize(cross(normal, tangent));\n    float u = (0.5 - uv.x) * AreaLightSize.x * 2.0;\n    float v = (uv.y - 0.5) * AreaLightSize.y * 2.0;\n    lightPosition = AreaLightPosition + u * tangent + v * bitangent;\n    lightIntensity = getLightIntensity(lightPosition);  \n}\n\nfloat densityVoumetricFog(in vec3 p)\n{\n    float res = clamp(fbm3D(p.xz * 0.01 - (iTime * 1.5 - 1.54)) * 0.25 - p.y * 0.02, 0.0, 1.0);\n\n    float fog = (res * 0.8 + 0.1);\n    fog = pow(fog, 2.0);\n    return fog * 15.0;\n}\n\nfloat rayMarchToAreaLight(in vec3 ro, in vec3 rd)\n{\n    const float numStep = 4.0;\n    float shadow = 1.0;\n  \tfloat stepDist = length(rd - ro) / numStep;\n    vec3 dir = normalize(rd - ro);\n    for(float i = 0.5; i < numStep; i += 1.0)\n    {\n        vec3 pos = ro + dir * (i / (numStep));\n        shadow *= exp(-densityVoumetricFog(pos * 253.0) * stepDist);\n    }\n    return shadow;\n}\n\nvoid integrateVolumetricFog(in vec3 p, \n                           in vec3 V,\n                           in float density,\n                           in float d,\n                           inout float transmittance, \n                           inout vec3 inscatteredLight,\n                           in vec2 fragCoord)\n{\n    // --- sample a random position on the area light\n    transmittance *= exp(-density * d);\n    float g = 0.2;\n    float u = rand(rand(fragCoord.x * p.x + fragCoord.y + d * 1.5) + 46984.4363);\n    float v = rand(rand(fragCoord.y * p.y + fragCoord.x + d * 2.5) + 3428.532546);\n    vec3 lightPos;\n    vec3 lightCol;\n    sampleAreaLight(vec2(u, v), lightPos, lightCol);\n    vec3 L = (lightPos - p);\n    float G = (dot(normalize(L), transpose(getRotation()) * AreaLightNormal)) / dot(L, L);\n    float areaPdf = 1.0 / (AreaLightSize.x * AreaLightSize.y);\n    float shadow = rayMarchToAreaLight(p, lightPos);\n    float phaseHG = (1.0 / (4.0 * 3.14)) * ((1.0 - g * g) / (pow((1.0 + g * g - 2.0 * g * max(dot(normalize(L), V), 0.0)), 3.0 / 2.0)));\n    inscatteredLight += density * transmittance * lightCol * G * phaseHG * d * (1.0 / areaPdf) * shadow;\n}\n\nvoid integrateVolumetricFogFromSampledPosition(in vec3 p, \n                           in vec3 V,\n                           in float density,\n                           in float d,\n                           inout vec3 inscatteredLight,\n                           in vec3 lightPos,\n                           in vec3 lightCol,\n                           in float xPdf)\n{\n    // same integration as above, but position on the ray is given by equi-angular sampling\n    float trans = exp(-density * d);\n    float g = 0.2;\n    vec3 L = (lightPos - p);\n    float G = (dot(normalize(L), transpose(getRotation()) * AreaLightNormal)) / dot(L, L);\n    float areaPdf = 1.0 / (AreaLightSize.x * AreaLightSize.y);\n    float shadow = rayMarchToAreaLight(p, lightPos);\n    float phaseHG = (1.0 / (4.0 * 3.14)) * ((1.0 - g * g) / (pow((1.0 + g * g - 2.0 * g * max(dot(normalize(L), V), 0.0)), 3.0 / 2.0)));\n    inscatteredLight += density * trans * lightCol * G * phaseHG  * (1.0 / areaPdf) * (1.0 / xPdf) * shadow;\n}\n\nSceneData intersectTerrain(in vec2 p)\n{\n    p *= 0.4;\n    vec3 res = fbm9D(p);\n    res.x *= 0.8;\n    res.x = res.x + smoothstep(-0.112, 0.1, res.x) * 0.8;\n    res.x *= 0.4;\n    SceneData data;\n    data.sdf = res.x;\n    data.materialID = 0;\n    return data;\n}\n\nvec4 normalTerrain(in vec2 p)\n{\n   \tp *= 0.4;\n    vec3 res = fbm9D(p);\n    res *= 0.8;\n    vec2 mdf = smoothstepd(-0.112, 0.1, res.x);\n    res.x = res.x + mdf.x * 0.8;\n    res.yz = res.yz + mdf.y * 0.8 * res.yz;\n    res.x *= 0.4;\n    res.yz *= 0.4;\n    \n    return vec4(res.x, normalize(vec3(-res.y, 1.0, -res.z)));\n}\n\nSceneData unite(SceneData sd0, SceneData sd1)\n{\n    if (sd0.sdf < sd1.sdf)\n        return sd0;\n    else\n        return sd1;\n}\n\nMarchResult raymarchScene(in vec3 ro, in vec3 rd, out vec4 scattering, in vec2 fragCoord)\n{\n    float tmin = 0.0;\n    float tmax = 50.0;\n    float t = tmin;\n    float prevt = t;\n    float d = 0.0, eps = 0.0;\n    float prevd = d;\n    float density = 0.0;\n    float transmittance = 1.0;\n    float stp = 0.0;\n    vec3 inscatteredLight = vec3(0.0);\n    vec3 inscatteredLightFromEquiAngularSampling = vec3(0.0);\n    MarchResult result;\n    int stepsEquiAngularSampling = 0;\n    \n    for (int i = 0; i < 300; ++i)\n    {\n        eps = t * 0.001;\n        vec3 p = ro + t * rd;    \n          \n        density = (densityVoumetricFog(p * 253.0));\n        integrateVolumetricFog(p, rd, density, stp, transmittance, inscatteredLight, fragCoord);\n        if (stepsEquiAngularSampling < 32)\n        {\n            float u = rand(rand(fragCoord.x * iResolution.y + fragCoord.y + d * 1.5) + iTime + 1234.32598);\n            float v = rand(rand(fragCoord.y * iResolution.x + fragCoord.x + d * 2.5) + iTime * 2.0 + 6234.32598);\n            vec3 lightPos;\n            vec3 lightCol;\n            sampleAreaLight(vec2(u, v), lightPos, lightCol);\n\n            float x0 = rand(rand(fragCoord.y * iResolution.y + fragCoord.x + d * 3.5 + iTime) + 236526.436346);\n            // --- equi-angular sampling\n            float DT = dot(lightPos - ro, rd);\n            float D = length(ro + DT * rd - lightPos);\n            float tha = atan(0.0 - DT, D);\n            float thb = atan(length(tmax - ro) - DT, D);\n            float tsampled = D * tan(mix(tha, thb, x0));\n            float pdf = D / ((thb - tha) * (D * D + tsampled * tsampled));\n            float x = DT + tsampled;\n            vec3 sampledPos = ro + x * rd;\n            \n        \tfloat densityFromSampledPos = (densityVoumetricFog(sampledPos * 253.0));\n        \tintegrateVolumetricFogFromSampledPosition(sampledPos, rd, densityFromSampledPos, x, inscatteredLightFromEquiAngularSampling, lightPos, lightCol, pdf); \n        \tstepsEquiAngularSampling++;        \n        }\n        \n        SceneData res = intersectTerrain(p.xz);\n        float h = res.sdf;\n        d = p.y - h;\n        \n        vec3 prot = getRotation() * (p - AreaLightPosition);\n        SceneData lightPlane = intersectBox(prot, AreaLightSize);\n        SceneData terrain;\n        terrain.sdf = d;\n        terrain.materialID = res.materialID;\n        SceneData scene = unite(terrain, lightPlane);\n        d = scene.sdf;\n        result.materialID = scene.materialID;\n        if (d < eps)\n            break;        \n        \n        stp = d * 0.32;\n        prevt = t;\n        prevd = d;\n        t += stp;\n        if (t > tmax)\n            break;\n    }\n    if (t > tmax)\n        t = -1.0;\n    else\n        t = mix(prevt, t, d/prevd);\n    \n    inscatteredLightFromEquiAngularSampling *= 1.0 / float(stepsEquiAngularSampling); \n    scattering = vec4(inscatteredLight + inscatteredLightFromEquiAngularSampling, transmittance);\n    result.t = t;\n    return result;\n}\n\nvec4 renderScene(in vec3 ro, in vec3 rd, in vec2 fragCoord)\n{\n    vec4 res = vec4(0.0);\n    vec4 scattering = vec4(0.0);\n    MarchResult m = raymarchScene(ro, rd, scattering, fragCoord);\n    if (m.t > 0.0)\n    {\n        vec3 p = ro + m.t * rd;\n        vec3 N = normalTerrain(p.xz).yzw;\n        \n        if (m.materialID == 0)\n        {\n            int numSteps = 256;\n            int actualSteps = 0;\n            vec3 normal = transpose(getRotation()) * AreaLightNormal;\n            vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n            vec3 bitangent = normalize(cross(normal, tangent));\n            for (int i = 0; i < numSteps; ++i)\n            {\n                vec3 R = reflect(rd, N);\n                float x0 = rand(rand(fragCoord.y * iResolution.y + p.x * p.y * 6543623.22355) +  float(i) * 3428.532546);\n                float x1 = rand(rand(fragCoord.x * iResolution.y +  p.z * p.y * 2124435.5346) + float(i) * 9067.214721);\n                float x2 = rand(rand(fragCoord.x * iResolution.x +  p.z * p.x * 352445.3466) + float(i) * 6797.745721);\n                R = normalize(R + vec3(x0, x1, x2));\n                if (dot(R, N) > 0.0)\n                {\n                \tfloat it = -dot(p - AreaLightPosition, normal) / dot(R, normal);\n                \tif (it > 0. && it < AreaLightPosition.z)\n                \t{\n\t                    vec3 hit = p + it * R;\n\t                    float x = dot(hit, tangent);\n\t                    float y = -dot(hit, bitangent);\n                    \tif (AreaLightPosition.x - AreaLightSize.x < x && x < AreaLightPosition.x + AreaLightSize.x\n                            && AreaLightPosition.y - AreaLightSize.y < y && y < AreaLightPosition.y + AreaLightSize.y)\n                        {\n                            vec3 lightPosition = AreaLightPosition + x * tangent + y * bitangent;\n\t                        res.xyz += (getLightIntensity(lightPosition)) * (1.0 / float(numSteps));\n                \t    }\n                \t}\t\n                }\n            }     \n        }\n        else if (m.materialID == 1)\n        {\n            res.xyz = getLightIntensity(p);\n        }\n        \n        res.xyz = res.xyz * scattering.w + scattering.rgb;\n        res.w = 1.0;\n    }\n    else\n        res = vec4(scattering.xyz, 1.0);\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 fragCoord)\n{        \n    vec4 scene = renderScene(ro, rd, fragCoord);\n    vec3 color = scene.rgb;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xi[5];\n    xi[0] = vec2(0.0, 0.0);\n    xi[1] = vec2(0.25, 0.0);\n    xi[2] = vec2(-0.25, 0.0);\n    xi[3] = vec2(0.0, 0.25);\n    xi[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec3 cp = vec3(0.0, 0.5, 6.0);\n    vec3 cu = normalize(vec3(0.0, 0.8, -0.2));\n    vec3 cr = vec3(1.0, 0.0, 0.0);\n    vec3 cf = normalize(cross(cu, cr));\n    float fl = 2.1;\n    \n    vec3 color = vec3(0.0);\n    const int nx = 1;\n    for (int i = 0; i < nx; ++i)\n    {\n        vec2 c_ss = (fragCoord.xy + xi[i]) / iResolution.xy;\n        vec2 c_cs = 2.0 * c_ss - 1.0;\n        c_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 rd = normalize(cf * fl + cr * c_cs.x + cu * c_cs.y);\n        color += render(cp, rd, fragCoord);\n    }\n    color /= float(nx);\n    color = pow(color, vec3(1.25, 1.0, 1.0));\n   \tcolor = color / (color + 1.0);\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 853, 873, 873, 955], [957, 957, 978, 978, 1022], [1024, 1024, 1071, 1071, 1314], [1316, 1316, 1345, 1345, 1764], [1766, 1766, 1795, 1795, 2451], [2603, 2603, 2626, 2626, 3079], [3081, 3081, 3105, 3105, 3379], [3712, 3931, 3971, 3971, 4137], [4139, 4139, 4174, 4174, 4372], [4374, 4374, 4394, 4394, 4649], [4651, 4651, 4734, 4734, 5150], [5152, 5152, 5190, 5190, 5372], [5374, 5374, 5425, 5425, 5757], [5759, 5759, 6079, 6133, 6928], [6930, 6930, 7300, 7392, 7932], [7934, 7934, 7973, 7973, 8192], [8194, 8194, 8225, 8225, 8511], [8513, 8513, 8560, 8560, 8638], [8640, 8640, 8731, 8731, 11596], [11598, 11598, 11659, 11659, 13891], [13893, 13893, 13949, 13949, 14059], [14061, 14061, 14118, 14118, 15055]]}
{"id": "4lSBzw", "name": "binary tree structure", "author": "tylerbata", "description": "Visualize a binary tree.  Attempting to create a tree.", "tags": ["tree"], "likes": 1, "viewed": 121, "date": "1528243423", "time_retrieved": "2024-06-20T19:15:04.802211", "image_code": "\n\nvec4 rand(float x) {\n    return texture( iChannel0, vec2(x, float(int(x/256.0)) + 0.5) );\n}\n\nfloat sdCircle( vec2 p, float s ) {\n    return length(p)-s;\n}\n\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat line(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = dFdy(uv).y;\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n\n\nfloat tree(vec2 p, vec2 start, vec2 dim, int maxSteps) {\n    \n    vec2 samp = start;\n    float d = 100.0;\n    float delta = dim.x;\n    for(int i = 0; i < maxSteps; i++) {\n        vec2 oldSamp = samp;\n        delta *= 0.5;\n        if(p.x > samp.x)\n            samp.x += delta;\n        else\n            samp.x -= delta;\n        samp.y += dim.y / float(maxSteps);\n        d = min(d,line(p, oldSamp, samp, vec2(2.0), 0.0));\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float t = tree(uv, vec2(0.5,0.0), mouse, 6);\n    \n    //t = line(uv, vec2(0.0), mouse, vec2(5.0), 0.0);\n    \n    \n    vec3 col = vec3(uv,0.5+0.5*sin(iTime));\n    if(t <= 0.0)col = vec3(1.0);\n    \n    \n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2, 2, 22, 22, 93], [95, 95, 130, 130, 156], [159, 159, 182, 182, 211], [212, 212, 235, 235, 264], [265, 265, 290, 290, 319], [321, 321, 410, 460, 1559], [1561, 1645, 1711, 1711, 1886], [1890, 1890, 1946, 1946, 2331], [2334, 2334, 2391, 2391, 2733]]}
{"id": "4s3fWl", "name": "Worbley Noise", "author": "SugarRushLux", "description": "awdwad", "tags": ["awdawd"], "likes": 0, "viewed": 87, "date": "1528272559", "time_retrieved": "2024-06-20T19:15:05.105315", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\tpos -= .5;\n    pos.x *= iResolution.x/iResolution.y;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    float t2 = t*0.2;\n    \n    mat2 r1 = mat2(1.0, 2.0,\n                   0.1, 0.0);\n    mat2 r2 = mat2(2.0, 0.0,\n                   0.0, 2.0);\n    mat2 r3 = mat2(cos(t2), -sin(t2),\n                   sin(t2), cos(t2));\n    mat2 r4 = mat2(sin(t2), -cos(t2),\n                   cos(t2), sin(t2));\n    \n    pos.y *= 3.0;\n    pos.xy *= 1.5;\n    \n    // Time varying pixel color\n    \n    pos.xy = pos.xy * r3;\n    pos.xy += pos.xy * r2;\n    float f = cos(sin(pos.x * 0.5 + t) * pos.y * 0.5 + t);\n    \n    pos.xy += pos.xy * -r4;\n    pos.xy += pos.xy * r1;\n    float f1 = sin(cos(pos.x * 0.5 + t) * pos.y * 0.5 + t);\n   \n    \n    float rd = length(uv);\n    vec3 colr = vec3(f);\n    vec3 colb = vec3(f1);\n    vec3 col = vec3((f - f1) + f);\n    vec3 green = vec3(0.2, 1.0, 0.0);\n    vec3 green1 = vec3(length(uv), 0.0, 0.0);\n    vec3 green2 = green + green1;\n    vec3 col2 = col * green2;\n    vec3 bg = vec3(rd, 1.0, 0.0);\n    vec3 fg = vec3(rd - 0.6, 1.0 - rd, 0.0);\n    \n    vec3 col3 = mix(bg, fg, col);\n         \n    \n\n    // Output to screen\n    fragColor = vec4(col3, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s3fWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 1404]]}
{"id": "4sGBWW", "name": "Fire Shader Learning Test", "author": "crocidb", "description": "Just some test I'm doing.\n\nThe SNOISE function I grabbed from here: https://www.shadertoy.com/view/lsf3RH", "tags": ["fire"], "likes": 11, "viewed": 231, "date": "1529018847", "time_retrieved": "2024-06-20T19:15:05.487082", "image_code": "// SNOISE function from: https://www.shadertoy.com/view/lsf3RH\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat noise(vec2 uv, float baseres)\n{\n    float n = 0.0;\n    for (int i = 0; i < 7; i++)\n    {\n        float v = pow(2.0, float(i));\n        n += (1.5 / v) * snoise(vec3(uv + vec2(1.,1.) * (float(i) / 17.), 1), v * baseres);\n    }\n    \n    \n    return clamp((1.0 - n) * .5, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    // Tweaking vars\n    vec4 color = vec4(0.925, 0.291, 0.023, 1.0);\n    vec2 tiling = vec2(1.0, .6);\n    vec2 speed1 = vec2(0.05, -0.32);\n    vec2 speed2 = vec2(-0.10, -0.39);\n    float ss_min = 0.2;\n    float ss_max = ss_min + 0.5;\n    float noise_sz = 8.0f;\n    \n    // Tiled UV\n    vec2 tuv = vec2(mod(uv.x * tiling.x, 1.0), mod(uv.y * tiling.y, 1.0));\n    \n    // Samplings\n    vec2 uv1 = tuv + (speed1 * iTime);\n    vec2 uv2 = tuv + (speed2 * iTime);\n    \n    // Mask\n    vec2 uvt = vec2(uv.x, pow(1.0 - uv.y, 2.2));\n    vec2 nuvt = (uvt * 2.0) - 1.0;    \n    float v = 1. - length(nuvt);\n    v = ((v * .6) + (pow(v, 4.3) * 4.55));\n    \n    float samplings = noise(uv1, noise_sz) * noise(uv2, noise_sz);\n    float mask = pow(v, 1.2) * samplings;\n    float amask = smoothstep(ss_min, ss_max, mask);\n\n    // Output to screen\n    fragColor = color + (color * pow((1.0 - uv.y), 3.0) * .3);\n    fragColor += samplings * .3;\n    fragColor *= (2. * amask);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sGBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 63, 97, 97, 621], [623, 623, 660, 660, 907], [909, 909, 966, 966, 1972]]}
{"id": "4sGfWy", "name": "Simple isosurface / blob", "author": "ma77os", "description": "Blobs", "tags": ["2d", "blob", "isosurface"], "likes": 3, "viewed": 120, "date": "1530156908", "time_retrieved": "2024-06-20T19:15:05.487082", "image_code": "// The MIT License\n// Copyright © 2020 André Mattos\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat circle(vec2 uv, vec2 pos, float r){\n\n    pos = uv-pos;\n    float d = length(pos);\n    //return smoothstep(r, r-0.1, d);\n    return r/d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float c1 = circle(uv, vec2(sin(iTime)*0.05, 0.), 0.1);\n    float c2 = circle(uv, vec2(sin(iTime*1.3)*-0.05, 0.), 0.1);\n    float c3 = circle(uv, vec2(0., sin(iTime*1.2)*0.05), 0.1);\n    vec3 circle1 = c1 * vec3(1.0, 0.3, 0.8);\n    vec3 circle2 = c2 * vec3(0.0, 1.0, 0.);\n    vec3 circle3 = c3 * vec3(0.0, 0.3, 1.);\n    vec3 col = circle1+circle2+circle3;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4sGfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1080, 1121, 1121, 1223], [1225, 1225, 1282, 1332, 1851]]}
{"id": "4sGfzt", "name": "Bars of colour", "author": "jimmypw", "description": "Animated bars of colour", "tags": ["colour"], "likes": 0, "viewed": 73, "date": "1529918640", "time_retrieved": "2024-06-20T19:15:05.638486", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy -= 0.5;\n    \n    vec3 col = vec3(0);\n\n    // Colour displayed\n    vec3 ncol =vec3(sin(iTime / 2.),sin(iTime),sin(iTime * .2));\n    \n    vec3 bumpmap = vec3(sin((uv.x + sin(iTime/50.)*5.) * 20.));\n    \n    //bumpmap + ncol\n    bumpmap += ncol;   \n\n    // Output to screen\n    fragColor = vec4(bumpmap,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sGfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 465]]}
{"id": "4sKBRD", "name": "Orthographic Sphere Shadows", "author": "ChrisK", "description": "This started as a 2D thing with circles that became progressively more 3D as it developed.\n\nLight #1 can be controlled with the mouse.", "tags": ["spheres", "shadows"], "likes": 2, "viewed": 434, "date": "1528584725", "time_retrieved": "2024-06-20T19:15:06.772055", "image_code": "//spheres and coloured lights from an orthographic projection, with analytical antialiasing and shadows.\n\n\n\n#define NUMBER_OF_SPHERES   20\n#define NUMBER_OF_LIGHTS    7\n#define SURFACE_BRIGHTNESS\t0.01\n\n\n//Disable SIMPLESCENE for performance gains in scenes with a greater numbers of lights and spheres\n#define SIMPLESCENE\n\n\nstruct light {\n\tvec3 pos;\n    vec3 col;\n};\n\n//hsl to rgb conversion adapted from https://gist.github.com/mjackson/5311256\nfloat hue2rgb( float p, float q, float h ) {\n\th = fract(h);\n    if(h<0.1616) return p+(q-p)*6.0*h;\n    else if(h<0.5) return q;\n    else if(h<0.666) return p+(q-p)*(0.666-h)*6.0;\n    else return p;\n}\n\n\nvec3 hsltorgb( vec3 hsl ) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n\tfloat q = l<0.5 ? l*(1.0+s) : l+s-l*s;\n    float p = 2.0*l-q;\n    float r = hue2rgb(p, q, h+0.333);\n    float g = hue2rgb(p, q, h);\n    float b = hue2rgb(p, q, h-0.333);\n    return vec3(r,g,b);\n}\n    \n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash( float p ) {\n   vec3 p3 = fract(vec3(p) * vec3(0.1031,0.1030,0.0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 getnearestpointonlinesegment( vec3 pa, vec3 pb, vec3 t) {\n    vec3 l = pb-pa;\n    float h = clamp( dot(t-pa,l)/dot(l,l), 0.0, 1.0 );\t\n    return pa+l*h;\n}\n\n\nvec2 orbit( float r, float s, float p ) {\n    r *= sin(iTime*p);\n    s *= iTime;\n    return vec2( sin(s)*r, cos(s)*r );\n}\n\n\nfloat distancetocoverage( float d ) {\n    return clamp(d*iResolution.y, 0.0, 1.0);\n}\n\n\nfloat circle( vec2 uv, vec2 p, float r ) {\n    float d = r-distance(uv,p);\n    return distancetocoverage(d);\n}\n\n\nfloat sphereshadow( vec3 uv, vec3 lp, vec3 cp, float cr ) {\n\tvec3 np = getnearestpointonlinesegment(uv, lp, cp);\n    float d = cr-distance(np,cp);\n  \treturn distancetocoverage(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 center = vec2(0.5*(iResolution.x/iResolution.y), 0.5);\n    \n    vec3 spheres[NUMBER_OF_SPHERES];\n    for (int i = 0; i<spheres.length(); i++ ) {\n        vec3 h = hash(float(i+500));\n        float px = h.x * iResolution.x/iResolution.y;\n        float py = h.y;\n        float r = mix(0.025, 0.1, h.z);\n    \tspheres[i] = vec3( px, py, r );\n    }\n    \n    light lights[NUMBER_OF_LIGHTS];\n    for (int i = 0; i<lights.length(); i++ ) {\n        vec3 h = hash(float(i+200));\n        float d = mix(0.25, 0.8, h.x);\t\t\t\t\t\t\t\t//orbital distance\n        float s = mix(0.12, 0.5, abs(h.y*2.0-1.0))*sign(h.y-0.5);\t//orbital speed\n        float p = mix(0.1, 0.35, h.z);\t\t\t\t\t\t\t\t//occilation speed\n        lights[i].pos = vec3(center+orbit(d,s,p), 0.101+sin(iTime+float(i))*0.1);\n\n        //vec3 hc = hash(float(i)+157.0);\n        //lights[i].col = hc*hc*hc;\n\t\tvec3 hsl = vec3( (float(i)+iTime*0.5)/float(NUMBER_OF_LIGHTS), 0.95, 0.2 );\n        lights[i].col = hsltorgb( hsl );\n    }\n    if(iMouse.w>0.0) lights[0].pos.xy=iMouse.xy/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    \n    \n    \n    #ifdef SIMPLESCENE\n    \n    \n    \n    for ( int i = 0; i<lights.length(); i++ ) {\n        //get ground lighting\n        float f = dot(normalize(lights[i].pos-vec3(uv,0.0)), vec3(0.0,0.0,1.0));\t//Lambertian reflection from floor\n        for ( int j = 0; j<spheres.length(); j++ ) {\n            f *= 1.0 - sphereshadow( vec3(uv,0.0), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n            if (f==0.0) break;\n        }\n        \n        float c = 0.0;\t\t\t//sphere lighting\n        float pz = 0.0;\t\t\t//height of pixel above floor plane\n        int id = -1;\t\t\t//index of sphere under pixel (-1 if there is none)\n        \n        //get sphere lighting\n        for ( int j = 0; j<spheres.length(); j++ ) {\n            if (distance(lights[i].pos, vec3(spheres[j].xy,0.0)) < spheres[j].z) {\n                break;\t//light is inside sphere\n            }\n            float p = distance(uv, spheres[j].xy);\n            float cz = sqrt(spheres[j].z*spheres[j].z-p*p);\t\t\t//height of pixel on sphere\n            if ( cz>pz ) {\n            \tpz = cz;\n                id = j;\n            \tvec3 nor = normalize(vec3(uv-spheres[j].xy, pz));\t//sphere normal\n        \t\tvec3 rd = normalize(lights[i].pos-vec3(uv,pz));\t\t\t//light ray direction (from surface to light)\n                float r = max(dot(rd, nor),0.0);\t\t\t\t\t//Lambertian reflection\n        \t\tc = r * circle(uv, spheres[j].xy, spheres[j].z);\t//multiply by circle coverage\n            }\n        }\n        \n        //if pixel is on a sphere, search for shadows cast on sphere\n        if ( id!=-1 && c>0.0 ) {\n        \tfor ( int j = 0; j<spheres.length(); j++ ) {\n                c *= 1.0 - sphereshadow( vec3(uv, pz), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n        \t}\n        }\n        \n        col += ( (f + c) * SURFACE_BRIGHTNESS / pow(distance(vec3(uv, pz), lights[i].pos),2.0) ) * lights[i].col;\n    }\n    \n    \n    \n    #else\n    \n    \n    \n    int id = -1;\t\t\t\t\t\t//index of sphere under pixel (-1 if there is none)\n    float pz = 0.0;\t\t\t\t\t\t//height of pixel above floor plane\n    for (int i = 0; i<spheres.length(); i++ ) {\n        vec2 sr = spheres[i].xy-uv;\n        float cz = spheres[i].z*spheres[i].z - dot(sr, sr);\t\t//(pixel height on spheres[i]) ^ 2\n        if ( cz>pz*pz ) {\n        \tpz = sqrt(cz);\n            id = i;\n        }\n    }\n    \n    float coverage = 0.0;\t\t\t\t//sphere coverage of pixel\n    vec3 nor = vec3(0.0,0.0,1.0);\t\t//surface normal\n    if (id!=-1) {\n    \tcoverage = circle(uv, spheres[id].xy, spheres[id].z);\n        nor = normalize( vec3(uv-spheres[id].xy, pz) );\n    }\n    \n    for ( int i = 0; i<lights.length(); i++ ) {      \n        //get shadow coverage\n        float illumination = 1.0;\n        for ( int j = 0; j<spheres.length() && illumination>0.0; j++ ) {\n        \tillumination *= 1.0 - sphereshadow( vec3(uv,pz), lights[i].pos, vec3(spheres[j].xy,0.0), spheres[j].z );\n        }\n        \n        //pz = mix(0.0, pz, coverage);\n        //nor = mix( vec3(0.0,0.0,1.0), nor, coverage );\n        //nor = normalize(nor);\n        \n        vec3 rv = lights[i].pos-vec3(uv,pz);\n        vec3 rd = normalize(rv);\t\t\t\t\t//light ray direction (from surface to light)\n        float gr = max(rd.z,0.0) * (1.0-sphereshadow(vec3(uv,0.0),lights[i].pos,vec3(spheres[id].xy,0.0),spheres[id].z)); //Lambertian reflection from ground plane\n        //float gr = max(rd.z,0.0) * (1.0-coverage);\n        float sr = max(dot(rd, nor),0.0) * coverage;\t//Lambertian reflection from sphere surface\n        \n        float f = gr + sr;\n        f *= illumination * SURFACE_BRIGHTNESS / dot(rv,rv);\n        col += f * lights[i].col;\n    }\n    \n    \n    #endif\n    \n    col *= 2.0;\n    \n    //filmic tone mapping -- http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    col = max(col-0.004, 0.0);\n    col = (col*(6.2*col+0.5))/(col*(6.2*col+1.7)+0.06);\n    \n    col += (hash(uv.x*uv.y*iTime*1000.0)-0.5) / 128.0;\t\t//grain\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKBRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[368, 446, 490, 490, 645], [648, 648, 675, 675, 935], [942, 983, 1005, 1005, 1139], [1142, 1142, 1204, 1204, 1301], [1304, 1304, 1345, 1345, 1425], [1428, 1428, 1465, 1465, 1512], [1515, 1515, 1557, 1557, 1625], [1628, 1628, 1687, 1687, 1809], [1812, 1812, 1869, 1869, 6943]]}
{"id": "4sKBWW", "name": "Amiga-style dots", "author": "sigvec", "description": "classic demo effect (WIP)", "tags": ["oldskool"], "likes": 3, "viewed": 230, "date": "1528950817", "time_retrieved": "2024-06-20T19:15:07.147730", "image_code": "#define PI 3.1415926536\n#define NUM_DOTS_IN_RING 64\n#define MAGIC_CONST ((2.0*PI)/float(NUM_DOTS_IN_RING))\n#define DOT_SIZE 0.1\n#define NUM_RINGS 64\n#define RING_SCALE 0.05\n#define EPSILON 0.00001\n#define BASE_SIZE 0.001\n#define SPEED 8.0\n\nfloat circ( vec2 uv, vec2 cPos, float cSize )\n{\n    return 1.0-smoothstep(0.0, cSize, length(uv-cPos))/cSize;\n}\n\nfloat ring( vec2 uv, vec2 rPos, float rSize )\n{\n    //center ourselves about the ring\n    vec2 myPos = uv - rPos;\n    \n    //some polar fun\n    float angle = atan(myPos.y, myPos.x);\n    \n    float c = MAGIC_CONST;\n    float nearestAngle = c*round(angle/c);\n    //return vec3(nearestAngle/(2.0*PI));\n    vec2 nearestDotPos;\n    nearestDotPos.x = cos(nearestAngle)*rSize;\n    nearestDotPos.y = sin(nearestAngle)*rSize;\n\n    float dotSize = DOT_SIZE;\n    return circ(myPos, nearestDotPos, dotSize);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float col;\n    \n    for(int i = NUM_RINGS+1; i > 0; i--) {\n        float fi = float(i);\n        float scaledTime = SPEED*iTime;\n        float scale = mod(scaledTime, 1.0);\n        float size = (fi+scale)*RING_SCALE+BASE_SIZE;\n        float ringNum = scale+fi;\n        float move = (iTime+ringNum/16.0);\n        col = ring(uv, vec2(cos(move*0.7)*1.5, sin(cos(move)*2.5)*0.5), size);\n        //float col = ring(uv, vec2(0.0), size);\n        if(col > EPSILON) {\n            float colRange = mod((scaledTime-fi), 8.0);\n            col /= 1.0+float(colRange < 4.0);\n            break;\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKBWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[240, 240, 287, 287, 351], [353, 353, 400, 438, 850], [857, 857, 914, 950, 1736]]}
{"id": "4sKfDR", "name": "Interactive SDF visualizer", "author": "greendolph", "description": "Example of unions, intersections, and subtractions on simple signed distance fields", "tags": ["sdf", "visualization", "distance"], "likes": 3, "viewed": 230, "date": "1528332551", "time_retrieved": "2024-06-20T19:15:07.820400", "image_code": "/*\n * This shader displays a simple scene built using union, intersect, and subtract\n * operations on signed distance fields. \n */\n\nconst int line_dist = 15;\n\n// defines the distance to the surface of a square\n// based on an example from this fantastic article: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat sdf_square(vec2 p, vec2 o, float s)\n{\n    vec2 d = abs(p - o) - vec2(s, s);\n    float inside = min(max(d.x, d.y), 0.0);\n    float outside = length(max(d, 0.0));\n    return inside + outside;\n}\n\n// defines the distance to the surface of a circle\n// distance from p to origin minus radius\nfloat sdf_circle(vec2 p, vec2 o, float r)\n{\n    return length(p - o) - r;\n}\n\n// pick the closer of two items\nfloat sdf_union(float a, float b) \n{    \n    return min(a, b);\n}\n\n// pick the further of two items\nfloat sdf_intersect(float a, float b)\n{\n    return max(a, b);\n}\n\n// intersect an item and an inside-out item\nfloat sdf_sub(float a, float b)\n{\n    return max(a, -b);\n}\n\n// percent of screen size\nvec2 svec(float x, float y)\n{\n    return iResolution.xy * vec2(x, y);\n}\n\nfloat psize(float percent)\n{\n    return iResolution.x * percent;\n}\n\nfloat get_world(vec2 p)\n{\n    // small circle in bottom right\n    float a = sdf_circle(p, svec(0.1, 0.1), psize(0.1));\n\n    // medium circle in center top\n    float b = sdf_circle(p, svec(0.5, 0.7), psize(0.2));\n    \n    // small circle at center of b\n    float b2= sdf_circle(p, svec(0.5, 0.7), psize(0.05));\n\n    // square that moves in a circle around b\n    float c = sdf_square(p, svec(0.5 + sin(iTime) / 10.0, 0.7 + cos(iTime) / 10.0), psize(0.15));\n\n    // large circle centered to right of screen\n    float d = sdf_circle(p, svec(1.1, 0.5), psize(0.3));\n\n    // large circle at bottom right of screen\n    float e = sdf_circle(p, svec(1.1, 0.0), psize(0.3));\n\n    return\n        sdf_union(\n            a,\n            sdf_union(                \n                sdf_intersect(\n                    sdf_sub(b, b2), \n                    c\n                ),                                    \n                sdf_sub(d, e)\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n\n    float world = get_world(fragCoord);\n    \n    // subtract a square at mouse from world\n    world = \n        sdf_sub(\n            world,\n            sdf_square(p, iMouse.xy, 30.0)\n        );\n\n    // normalize distance to fit within canvas\n    float dcolor = pow( world / iResolution.x, 0.3);\n    \n    // pick a cool looking background color\n\tvec4 bg = vec4(dcolor, 0.0, 1.0 - dcolor, 1.0);\n    \n    // if inside an object\n    if (world < 0.0)     \n        fragColor = vec4(0.6, 0.1, 0.1, 1.0); // red!\n    \n    // if on a line of constant distance from the nearest surface (+ animation!)\n    else if (int(world) % line_dist == line_dist - (int(iTime * 20.0) % line_dist) - 1)  \n        fragColor = vec4(bg.x / 1.2, bg.y / 1.2, bg.z / 1.2, 1.0);    \n    \n    // otherwise, draw the cool looking background color\n    else    \n        fragColor = bg;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[159, 335, 378, 378, 532], [534, 627, 670, 670, 702], [704, 736, 772, 772, 800], [802, 835, 874, 874, 898], [900, 944, 977, 977, 1002], [1004, 1030, 1059, 1059, 1101], [1103, 1103, 1131, 1131, 1169], [1171, 1171, 1196, 1232, 2122], [2124, 2124, 2181, 2181, 3058]]}
{"id": "4sKfDW", "name": "Animated Checkerboard", "author": "mitjaprelovsek", "description": "A simple animated checkerboard base on 2 colors. Inspired by https://www.shadertoy.com/view/llsyDH.", "tags": ["checkerboard"], "likes": 0, "viewed": 81, "date": "1528895016", "time_retrieved": "2024-06-20T19:15:07.820603", "image_code": "// variables for the grid size\nfloat numX = 8.0;\nfloat numY = 5.0;\nvec4 color1=vec4(1.,0.,1.,1.);\nvec4 color2=vec4(0.,1.,1.,1.);\nfloat animateSpeed=.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float total = (floor(uv.x * numX) + floor(uv.y * numY));\n    \n    float mixFactor=0.;\n\tif(animateSpeed!=0.){\n    \tmixFactor=sin(iTime*animateSpeed)/2.+0.5;\n    }\n    if (mod(total, 2.0) == 0.0){fragColor = mix(color1,color2,mixFactor);}\n    else{fragColor = mix(color2,color1,mixFactor);}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 153, 210, 210, 548]]}
{"id": "4sKfDz", "name": "Raining Columns", "author": "ircss", "description": "A shader to try to imitate this effect https://twitter.com/archillect/status/1004244037153542145", "tags": ["procedural", "grids"], "likes": 7, "viewed": 266, "date": "1528382576", "time_retrieved": "2024-06-20T19:15:08.226573", "image_code": "\nfloat rand(float Seed){\n    \n    return fract(sin(Seed*4124213.)*37523.);\n}\n\nfloat rand(vec2 Seed){\n    \n    return fract(sin(dot(Seed, vec2(241512.,5124.632))*5124.124));\n}\n\nfloat randInRange(float id, vec2 range){\n    \n    id = rand(id);\n    return range.x + id * (range.y-range.x);\n}\n\n\nvoid AddPannedGrid( inout vec4 FragCol, vec2 uv, vec4 GridColor,\n                   vec2 panningSpeedRange, float gridSize, float seedDiff){\n    \n\n    float verticalStretch = 1.;\n    vec2 st = uv;\n    \n    // This value tells you the index of the columns and rows. You might have \n    // to recalculate it if you pan something\n    vec2 gridID = floor ( vec2(uv.x * gridSize, uv.y *verticalStretch));\n    \n    \n    // Paning the texture\n    \n    uv.y+= rand(gridID.x+14. +seedDiff) +randInRange(gridID.x+seedDiff, panningSpeedRange)*iTime;\n    \n    // divide the uv so that it creates the grid\n    uv = fract ( vec2(uv.x * gridSize , uv.y *verticalStretch));\n   \n    \n    // Shading the grids\n    float diagonal = smoothstep(0.,0.05, uv.y - uv.x*.1*st.y);\n\n    vec3 temp = vec3((1.-uv.x)*pow((1.0-uv.y)*1.2,4.))*diagonal;\n    \n    \n    // Applying the alpha and the fin color addtiv on top\n    FragCol.xyz += GridColor.a * GridColor.xyz*temp;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Compensating for aspect ration\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 finalColor = vec4(0.);\n    \n    // Adding the efect Additiv\n\tAddPannedGrid(finalColor, uv, vec4(0.4,0.7,1.,0.5), vec2(.4,.7), 13., 123.);\n    AddPannedGrid(finalColor, uv, vec4(0.4,0.7,1.,0.9), vec2(.4,.7), 10.,45.26);\n    AddPannedGrid(finalColor, uv, vec4(0.4,0.7,1.,0.2), vec2(.4,.9), 16.,53.1);\n    \n    // Output to screen\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 24, 24, 76], [78, 78, 100, 100, 174], [176, 176, 216, 216, 287], [290, 290, 430, 430, 1238], [1241, 1241, 1298, 1348, 1840]]}
{"id": "4sVBDm", "name": "李明杰VIP", "author": "leneer", "description": "李明杰VIP", "tags": ["vdj"], "likes": 4, "viewed": 363, "date": "1529118451", "time_retrieved": "2024-06-20T19:15:08.226573", "image_code": "vec3 bgColor = vec3(0.01, 0.45, 0.1);\nvec3 rectColor = vec3(0.01, 0.3, 0.1);\n\n//noise background\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\n//rectangles\nconst float total = 60.;//number of rectangles\nconst float minSize = 0.03;//rectangle min size\nconst float maxSize = 0.08-minSize;//rectangle max size\nconst float yDistribution = 0.5;\n\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv )\n{\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    \n\tf = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv )\n{\n    float velocity = iTime/1.6;\n    float intensity = sin(uv.x*3.+velocity*2.)*1.1+1.5;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    //rb = sqrt(rb); \n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp)+1.2;\n\n    //bazooca line\n    //rz *= sin(uv.x*.5+velocity*.8);\n\n\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n\nfloat rectangle(vec2 uv, vec2 pos, float width, float height, float blur) {\n    \n    pos = (vec2(width, height) + .01)/2. - abs(uv - pos);\n    pos = smoothstep(0., blur , pos);\n    return pos.x * pos.y; \n   \n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //bg\n    vec3 color = bg(uv)*(2.-abs(uv.y*2.));\n    \n    //rectangles\n    float velX = -iTime/8.;\n    float velY = iTime/10.;\n    for(float i=0.; i<total; i++){\n        float index = i/total;\n        float rnd = random(vec2(index));\n        vec3 pos = vec3(0, 0., 0.);\n        pos.x = fract(velX*rnd+index)*4.-2.0;\n        pos.y = sin(index*rnd*1000.+velY) * yDistribution;\n        pos.z = maxSize*rnd+minSize;\n        vec2 uvRot = uv - pos.xy + pos.z/2.;\n    \tuvRot = rotate2d( i+iTime/2. ) * uvRot;\n        uvRot += pos.xy+pos.z/2.;\n        float rect = rectangle(uvRot, pos.xy, pos.z, pos.z, (maxSize+minSize-pos.z)/2.);\n\t    color += rectColor * rect * pos.z/maxSize;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[203, 402, 424, 424, 496], [498, 498, 524, 524, 846], [848, 848, 873, 873, 1135], [1137, 1137, 1156, 1156, 1644], [1647, 1647, 1722, 1722, 1856], [1858, 1858, 1886, 1886, 1972], [1974, 1974, 2031, 2031, 2849]]}
{"id": "4sVBz3", "name": "loopless dots along ellipse", "author": "FabriceNeyret2", "description": "in a fragment shader, regular patterns can generally be done loopless: each pixel determine on which feature it lays (or not).\n(Note that if patterns can superimpose, then one has not only to consider the central feature but also its direct neighborhs) .", "tags": ["tuto", "loopless"], "likes": 6, "viewed": 440, "date": "1529826030", "time_retrieved": "2024-06-20T19:15:08.438711", "image_code": "// elliptic variant of https://shadertoy.com/view/XsVBz3\n\n#define S(v,r)  smoothstep ( 3./R.y, 0., length(v)-r ) // antialiased draw\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) ) // from https://www.shadertoy.com/view/ll2cDc\n\n#define rot(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;                           // normalized coordinates\n    \n    float r = .5,                                    // circle radius\n          n = 1.+30.*(.5+.5*sin(iTime)),             // number of dots\n          h = exp2(cos(iTime*1.7));                  // vertical circle stretch\n    U.y *= h;                                        // -> ellipse\n    \n    float l = length(U),                             // polar coordinates\n          a = atan(U.y,U.x),\n    \n     u = r * ( fract( a*n/6.283 ) - .5 ) / (n/6.283),// local coordinates in\n     v = l - r,                                      // cells along the circle\n     i = floor( a*n/6.283 );                         // dot number\n    \n    vec2 V = vec2(u,v) * rot(-a);                    // unstretch local coords\n    V.x /= h;\n    \n    O = S( V, .03 ) * hue(i/n);                      // draw blobs\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 301, 339, 339, 1248]]}
{"id": "4sVfDw", "name": "chrome spheres over checkerboard", "author": "halcy", "description": "as god intended\n\nlower LEVELS, OVERSAMPLE_PIX and OVERSAMPLE_TEX to make rendering quicker. make them larger to make it prettier.", "tags": ["raytracing"], "likes": 7, "viewed": 657, "date": "1529110876", "time_retrieved": "2024-06-20T19:15:09.457067", "image_code": "// Various knobs to twiddle\n#define LEVELS 8\n#define OVERSAMPLE_PIX 4\n#define OVERSAMPLE_PIX_WIDTH 0.001\n#define OVERSAMPLE_TEX 16\n#define LARGE_NUMBER 900000.0\n\nbool is_vr = false;\nvec3 vr_ori = vec3(0.0);\nvec3 vr_ray = vec3(0.0);\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768) * n); \n}\n\n// Trefoil knot positions\nvec3 trefoil(float t) {\n\treturn vec3(\n        sin(t) + 2.0 * sin(2.0 * t),\n        cos(t) - 2.0 * cos(2.0 * t),\n        -sin(3.0 * t)\n    );\n}\n\n// Ray-sphere and ray-plane intersections \nfloat sphere_intersect(vec3 pos, float radius, vec3 eye, vec3 ray) {\n    vec3 pos_to_eye = eye - pos;\n    float ray_dot_dir = dot(ray, pos_to_eye);\n    float determ = ray_dot_dir * ray_dot_dir - dot(pos_to_eye, pos_to_eye) + radius * radius;\n    if(determ < 0.0 || -ray_dot_dir - sqrt(determ) < 0.0) {\n    \treturn LARGE_NUMBER;   \n    }\n    return -ray_dot_dir - sqrt(determ);\n}\n\nfloat xzplane_intersect(float height, vec3 eye, vec3 ray) {\n    float determ = (height - eye.y) / ray.y;\n    if(determ <= 0.0) {\n    \treturn LARGE_NUMBER;   \n    }\n    return determ;\n}\n\n\n\n// View setup\nvoid camera(vec2 coords, out vec3 eye, out vec3 ray) {\n    // Calculate an eye position\n    eye = vec3(sin(iTime) * 0.5, sin(iTime * 0.3) * 0.5 + 0.5, iTime * 16.0);\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 lookat = vec3(0.0, 0.0, iTime * 16.0 + 2.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    ray = normalize(pixelpos - eye);\n}\n\n// Raytrace the scene\nvec3 sphere_pos(vec3 eye, float spherenum) {\n\tvec3 trefoil_offset = trefoil(3.14 * 2.0 * spherenum / 7.0 + iTime).xzy * 0.7;\n\treturn eye + trefoil_offset + vec3(0.0, -1.0, 4.0);\n}\n\nvec4 trace(vec3 eye, vec3 ray) {\n    float plane_hit = xzplane_intersect(-2.0, eye, ray);\n    float hit_dist = plane_hit;\n    \n    vec3 sphere_c_a = sphere_pos(eye, 1.0);\n\tfloat sphere_hit_a = sphere_intersect(sphere_c_a, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_a);\n    \n    vec3 sphere_c_b = sphere_pos(eye, 2.0);\n\tfloat sphere_hit_b = sphere_intersect(sphere_c_b, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_b);\n    \n    vec3 sphere_c_c = sphere_pos(eye, 3.0);\n\tfloat sphere_hit_c = sphere_intersect(sphere_c_c, 0.5, eye, ray);\n    hit_dist = min(hit_dist, sphere_hit_c);\n    \n    float hit_obj = -1.0;\n    hit_obj = hit_dist == plane_hit ? 1.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_a ? 2.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_b ? 3.0 : hit_obj;\n    hit_obj = hit_dist == sphere_hit_c ? 4.0 : hit_obj;\n    hit_obj = hit_dist == LARGE_NUMBER ? -1.0 : hit_obj;\n    \n    return(vec4(eye + ray * hit_dist, hit_obj));\n}\n\n// Colour a non-hit\nvec3 background(vec3 dir) {\n    float rotval = atan(dir.x + 0.5, dir.y) + iTime * 0.1;\n    float noiseval = mod(atan(dir.y, dir.z), 0.1);\n    noiseval = rand(vec2(rotval, noiseval)) > 0.5 ? 1.0 : 0.8;\n    float dirs = mod(rotval + 0.08, 0.4);\n    float diry = mod(rotval, 0.2) < 0.04 ? 1.0 : abs(mod(rotval, 0.2) - 0.12) * 5.0;\n    //return texture(iChannel0, 2.0 * vec2((dir.x + 0.5) / 2.0, dir.y)).rgb;\n    if(dirs > 0.2) {\n    \treturn vec3(diry, 0.0, diry) * noiseval;\n    }\n    else {\n        return vec3(0.0, diry, diry) * noiseval;\n    }\n}\n\n// Colour anything whatsoever\nvec3 shade(vec3 pos, vec3 dir, float hit_obj, vec3 stack_color) {\n    if(hit_obj == 1.0) {\n        return vec3(mod(floor(pos.x) + floor(pos.z), 2.0));\n    }\n    if(hit_obj == LARGE_NUMBER) {\n    \treturn background(dir);\n    }\n   \treturn stack_color;\n}\n\n// Oversample textures\nvec3 shade_supersample(vec3 pos, vec3 dir, float hit_obj, vec3 stack_color) {\n    vec3 ddx_a = pos - dFdx(pos);\n    vec3 ddy_a = pos - dFdy(pos);\n\tvec3 ddx_b = pos + dFdx(pos);\n    vec3 ddy_b = pos + dFdy(pos);\n    \n    vec3 shade_sum = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_TEX; i++) {\n    \tvec2 samp_off = vec2(\n            rand(vec2(length(pos * 1000.0), 2000.0 * float(i))),\n\t\t\trand(vec2(length(pos * 7000.0), 3700.0 * float(i)))\n        );\n        vec3 samp_pos_x = mix(ddx_a, ddx_b, abs(samp_off.x)) * 0.5;\n        vec3 samp_pos_y = mix(ddy_a, ddy_b, abs(samp_off.y)) * 0.5;\n        shade_sum += shade(samp_pos_x + samp_pos_y, dir, hit_obj, stack_color);\n    }\n    return(shade_sum / float(OVERSAMPLE_TEX));\n}\n\n// One pixel\nvec3 pixel(vec2 coords) {\n\tvec4 hit[LEVELS];\n    vec3 ray[LEVELS];\n    vec3 eye;\n    \n   \tcamera(coords, eye, ray[0]);\n    if(is_vr) {\n    \teye = vr_ori;\n        ray[0] = vr_ori;\n    }\n    hit[0] = trace(eye, ray[0]);\n    \n    // Trace all hits\n    for(int i = 1; i < LEVELS; i++) {\n        // Hit sphere?\n        if(hit[i - 1].w >= 2.0 && hit[i - 1].w < LARGE_NUMBER) {\n\t\t\tvec3 sphere_c = sphere_pos(eye, hit[i - 1].w  - 1.0);            \n            vec3 sphere_n = normalize(hit[i - 1].xyz - sphere_c);\n           \tray[i] = reflect(ray[i - 1], sphere_n);\n            hit[i] = trace(hit[i - 1].xyz + sphere_n * 0.1, ray[i]);\n        }\n        else {\n         \thit[i].w = LARGE_NUMBER;\n        }\n    }\n    \n    // Shade\n    vec3 stackColor = vec3(0.1);\n    for(int i = LEVELS - 1; i >= 0; i--) {\n        vec3 dir = ray[0];\n        if(i != 0) {\n            dir = ray[i - 1];   \n        }\n        stackColor = shade_supersample(hit[i].xyz, dir, hit[i].w, stackColor);\n    }\n    return stackColor;\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_PIX; i++) {\n        vec2 offset =  hash33(vec3(coords.x, coords.y, float(i))).xy;\n    \tfragColor.rgb += pixel(coords + offset * OVERSAMPLE_PIX_WIDTH);\n    }\n    fragColor.rgb /= float(OVERSAMPLE_PIX);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    is_vr = true;\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(0.0);\n    for(int i = 0; i < OVERSAMPLE_PIX; i++) {\n        vec2 offset =  hash33(vec3(coords.x, coords.y, float(i))).xy;\n    \tfragColor.rgb += pixel(coords + offset * OVERSAMPLE_PIX_WIDTH);\n    }\n    fragColor.rgb /= float(OVERSAMPLE_PIX);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[233, 302, 322, 322, 389], [390, 390, 410, 410, 516], [518, 544, 567, 567, 686], [688, 731, 799, 799, 1109], [1111, 1111, 1170, 1170, 1295], [1299, 1313, 1367, 1400, 1885], [1887, 1909, 1953, 1953, 2088], [2090, 2090, 2122, 2122, 3056], [3058, 3078, 3105, 3105, 3623], [3625, 3655, 3720, 3720, 3906], [3908, 3931, 4008, 4008, 4653], [4655, 4668, 4693, 4693, 5665], [5667, 5676, 5731, 5731, 6093], [6095, 6095, 6189, 6189, 6569]]}
{"id": "4sVfWR", "name": "Andromeda's Jewel", "author": "wyatt", "description": "got inspired by trirop's awesome shader(s) https://www.shadertoy.com/view/MsScWD\nI didnt use Runge-Kutta integration because im just not that fancy\nI think i nailed the colors (happy accident), but not the lighting or the stars", "tags": ["fluid", "planet", "gas"], "likes": 52, "viewed": 1526, "date": "1528320506", "time_retrieved": "2024-06-20T19:15:09.457067", "image_code": "#define pi 3.14159265359\n//this noise stuff is from iq thanks\nfloat hash (vec2 v) {\n    v = floor(v);\n    return fract(67.3249*sin(17.1234*length(v-vec2(34.14,123.))));\n}\nfloat noise (vec2 v) {\n    vec4 n = vec4(floor(v),ceil(v));\n    vec4 h = vec4(hash(n.xy),hash(n.zy),hash(n.xw),hash(n.zw));\n    return mix(mix(h.x,h.y,v.x-n.x),mix(h.z,h.w,v.x-n.x),v.y-n.y);\n}\nmat2 r (float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(s,-c,c,s);\n}\nfloat no (vec2 v) {\n    float c = 0.;\n    for (int i = 1; i < 10; i++) {\n        v = 2.*r(0.2944*pi)*v;\n        c += 0.2*noise(v)/(1.+length(sin(0.5*v)));\n    }\n    return c;\n}\n// flow stuff is from trirop https://www.shadertoy.com/view/MsScWD very cool\nvec2 ff (vec2 v) {\n    \tfloat n = 1.+0.5*noise(v);\n\t\treturn \n\t        sign(v.y-0.5)*50.*vec2(n*sin(1.4*v.y),0.)/(v.y+3.5)+\n\t        .1*vec2(sin(-12.*v.y*n),cos(13.*v.x))+\n\t        1.8*vec2(cos(-6.*v.y),sin(4.*v.x))+\n\t        1.2*vec2(sin(-1.4*v.y),cos(1.5*v.x))+\n\t        2.0*vec2(sin(-.5*v.y),cos(.6*v.x))+\n\t        0.8*vec2(sin(-.2*v.y),cos(.2*v.x*n))\n\t     ;}\nbool star = false;\nvec2 mouse;\nvoid sphere (inout vec3 p, inout vec3 d) {\n\tfloat r = .7, dp = dot(d,p), pp = dot(p,p), det = dp*dp+r*r-pp;\n    if (det < 0.) star = true;\n    float x = -dp+sqrt(det);\n    p = (p+d*x);\n    d = reflect(normalize(p),d);\n}\n\nvec3 surface (vec2 uv) {\n\tvec3 col = 0.*vec3(7.-abs(uv.y))*no (uv);\n    for (int i = 0; i < 45; i++) {\n\t\tuv += 0.01*(2.+1.5*sin(.1*iTime))*ff(uv);\n    }\n    float j = no(0.1*uv*pi);\n    vec3 c = sin(j*vec3(1,2,3));\n    col += abs(mix(c*c*c,vec3(j),abs(1.-uv.y/7.5)));\n    return col;\n}\nvec3 stars (vec2 v) {\n\treturn vec3(pow(1.35*no(0.1*iTime+5.*mouse+3.*v/dot(v,v)),7.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 uv = (2.*U-iResolution.xy)/iResolution.y;\n   \tfloat q = 1.2+0.1*min(17.,iTime);\n    vec3 p = vec3(0,0,-q);\n    vec3 d = normalize(vec3(uv,4.));\n    mouse = iMouse.xy/iResolution.xy;\n    p.yz = r(-mouse.y+0.7*pi)*p.yz;\n    d.yz = r(-mouse.y+0.7*pi)*d.yz;\n    p.zx = r(mouse.x+0.25*pi)*p.zx;\n    d.zx = r(mouse.x+0.25*pi)*d.zx;\n    vec3 col;\n    sphere(p,d);\n    if (star) {\n        col = stars(uv);\n    } else {\n    \tcol = 0.8*surface(8.*vec2(atan(d.z,d.x)+0.01*iTime*min(iTime,17.),acos(d.y)));\n        float sh = dot(d,normalize(vec3(1,0,-1)));\n        col *= sh+0.4;\n    }\n    float l = length(uv-vec2(0.2,0))*q;\n    col = col+.09*vec3(0.5,0.7,1.)*(uv.x+0.5)*exp(-0.01*l*l*l*l)*q;\n    fragColor = vec4(col,1);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[25, 62, 83, 83, 170], [171, 171, 193, 193, 363], [364, 364, 382, 382, 445], [446, 446, 465, 465, 622], [623, 700, 718, 718, 1062], [1094, 1094, 1136, 1136, 1313], [1315, 1315, 1339, 1339, 1600], [1601, 1601, 1622, 1622, 1689], [1690, 1690, 1739, 1739, 2464]]}
{"id": "4sVfWw", "name": "random octree", "author": "abje", "description": "A 3d version of [url=https://www.shadertoy.com/view/MlsXDf]random quadtree[/url]\n[url=https://www.shadertoy.com/view/XdyfRy]With shadows[/url]", "tags": ["voxel", "octree"], "likes": 57, "viewed": 2082, "date": "1529078667", "time_retrieved": "2024-06-20T19:15:09.457067", "image_code": "#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n#define detail 5\n#define steps 300\n#define time iTime*0.5\n#define maxdistance 30.0\n\n//#define drawgrid\n#define fog\n//#define borders\n#define blackborders\n//#define raymarchhybrid 100\n#define objects\n#define emptycells 0.5\n#define subdivisions 0.95 //should be higher than emptycells\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define sqr(a) (a*a)\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n#ifdef objects\n    if (p.x==0.0&&p.y==0.0) {\n        return 0;\n    }\n#endif\n    \n    float val = rnd(vec4(p,size));\n    \n    if (val < emptycells) {\n        return 0;\n    } else if (val < subdivisions) {\n        return 1;\n    } else {\n        return 2;\n    }\n    \n    return int(val*val*3.0);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)*ird;\n    \n    return hit;\n}\n\nfloat map(vec3 p, vec3 fp) {\n    p -= 0.5;\n    \n    vec3 flipping = floor(hash33(fp)+0.5)*2.0-1.0;\n    \n    p *= flipping;\n    \n    vec2 q = vec2(abs(length(p.xy-0.5)-0.5),p.z);\n    float len = length(q);\n    q = vec2(abs(length(p.yz-vec2(-0.5,0.5))-0.5),p.x);\n    len = min(len,length(q));\n    q = vec2(abs(length(p.xz+0.5)-0.5),p.y);\n    len = min(len,length(q));\n    \n    \n    return len-0.1666;\n}\n\nvec3 findnormal(vec3 p, float epsilon, vec3 fp)\n{\n    vec2 eps = vec2(0,epsilon);\n    \n    vec3 normal = vec3(\n        map(p+eps.yxx,fp)-map(p-eps.yxx,fp),\n        map(p+eps.xyx,fp)-map(p-eps.xyx,fp),\n        map(p+eps.xxy,fp)-map(p-eps.xxy,fp));\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    \n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.y;\n    float size = 1.0;\n    \n    vec3 ro = vec3(0.5+sin(time)*0.4,0.5+cos(time)*0.4,time);\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    //if the mouse is in the bottom left corner, don't rotate the camera\n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 ird = 1.0/max(abs(rd),0.001);\n    vec3 mask;\n    bool exitoct = false;\n    int recursions = 0;\n    float dist = 0.0;\n    float fdist = 0.0;\n    int i;\n    float edge = 1.0;\n    vec3 lastmask;\n    vec3 normal = vec3(0.0);\n    \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if octree cell is empty\n    // - repeat if i did not hit a cube\n    for (i = 0; i < steps; i++)\n    {\n        if (dist > maxdistance) break;\n        \n        //i go up a level\n        if (exitoct)\n        {\n            \n            vec3 newfro = floor(fro/(size*2.0))*(size*2.0);\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n        }\n        else\n        {\n            //checking what type of cell it is: empty, full or subdivide\n            int voxelstate = getvoxel(fro,size);\n            if (voxelstate == 1 && recursions > detail)\n            {\n                voxelstate = 0;\n            }\n            \n            if(voxelstate == 1&&recursions<=detail)\n            {\n                //if(recursions>detail) break;\n\n                recursions++;\n                size *= 0.5;\n\n                //find which of the 8 voxels i will enter\n                vec3 mask2 = step(vec3(size),lro);\n                fro += mask2*size;\n                lro -= mask2*size;\n            }\n            //move forward\n            else if (voxelstate == 0||voxelstate == 2)\n            {\n                //raycast and find distance to nearest voxel surface in ray direction\n                //i don't need to use voxel() every time, but i do anyway\n                vec3 hit = voxel(lro, rd, ird, size);\n\n                /*if (hit.x < min(hit.y,hit.z)) {\n                    mask = vec3(1,0,0);\n                } else if (hit.y < hit.z) {\n                    mask = vec3(0,1,0);\n                } else {\n                    mask = vec3(0,0,1);\n                }*/\n                mask = vec3(lessThan(hit,min(hit.yzx,hit.zxy)));\n                float len = dot(hit,mask);\n    #ifdef objects\n                if (voxelstate == 2) {\n    #ifdef raymarchhybrid\n                    //if (length(fro-ro) > 20.0*size) break;\n                    vec3 p = lro/size;\n                    if (map(p,fro) < 0.0) {\n                        normal = -lastmask*sign(rd);\n                        break;\n                    }\n                    float d = 0.0;\n                    bool hit = false;\n                    float e = 0.001/size;\n                    for (int j = 0; j < raymarchhybrid; j++) {\n                        float l = map(p,fro);\n                        p += l*rd;\n                        d += l;\n                        if (l < e || d > len/size) {\n                            if (l < e) hit = true;\n                            d = min(len,d);\n                            break;\n                        }\n                    }\n                    if (hit) {\n                        dist += d*size;\n                        ro += rd*d*size;\n                        normal = findnormal(p,e,fro);//(lro-0.5)*2.0;\n                        break;\n                    }\n    #else\n                    break;\n    #endif\n                }\n    #endif\n\n                //moving forward in ray direction, and checking if i need to go up a level\n                dist += len;\n                fdist += len;\n                lro += rd*len-mask*sign(rd)*size;\n                vec3 newfro = fro+mask*sign(rd)*size;\n                exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n                fro = newfro;\n                lastmask = mask;\n            }\n        }\n#ifdef drawgrid\n        vec3 q = abs(lro/size-0.5)*(1.0-lastmask);\n        edge = min(edge,-(max(max(q.x,q.y),q.z)-0.5)*80.0*size);\n#endif\n    }\n    ro += rd*dist;\n    if(i < steps && dist < maxdistance)\n    {\n    \tfloat val = fract(dot(fro,vec3(15.23,754.345,3.454)));\n#ifndef raymarchhybrid\n        vec3 normal = -lastmask*sign(rd);\n#endif\n        vec3 color = sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n    \tfragColor = vec4(color*(normal*0.25+0.75),1.0);\n        \n#ifdef borders\n        vec3 q = abs(lro/size-0.5)*(1.0-lastmask);\n        edge = clamp(-(max(max(q.x,q.y),q.z)-0.5)*20.0*size,0.0,edge);\n#endif\n#ifdef blackborders\n        fragColor *= edge;\n#else\n        fragColor = 1.0-(1.0-fragColor)*edge;\n#endif\n    } else {\n        #ifdef blackborders\n                fragColor = vec4(edge);\n        #else\n                fragColor = vec4(1.0-edge);\n        #endif\n    }\n#ifdef fog\n    fragColor *= 1.0-dist/maxdistance;\n#endif\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[418, 479, 498, 498, 568], [570, 640, 662, 662, 771], [773, 816, 850, 850, 1145], [1147, 1198, 1250, 1250, 1342], [1344, 1344, 1372, 1372, 1744], [1746, 1746, 1795, 1795, 2024], [2026, 2026, 2081, 2081, 7489]]}
{"id": "4syBDR", "name": "exam_iesmins", "author": "sandis_i", "description": "exam", "tags": ["exam"], "likes": 2, "viewed": 133, "date": "1528204946", "time_retrieved": "2024-06-20T19:15:09.457067", "image_code": "\nfloat plakne(vec3 p)\n{\nvec3 q = fract(p) * 2.0 - 1.0;\n\nreturn length(q) - 0.01;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\nfloat t = 0.60;\nfor (int i=0; i < 15; ++i) {\n\tvec3 p = o + r * t;\n\tfloat d = plakne(p);\n\tt +=d * 0.5;\n}\nreturn t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \nvec2 koord = fragCoord.xy / iResolution.xy;\n\nkoord = koord * 2.0 - 1.0;\n\nvec3 r = normalize(vec3(koord, 0.3));\n\nfloat the = iTime * 0.50;\n    \nr.xz *=mat2(cos(the), -sin(the), sin(the), cos(the));\n\nvec3 o = vec3 (iTime, 0.0, 0.0 );\n\nfloat t = trace(o, r);\n\nfloat fog = 1.0 / (1.0 + t * t * 0.1);\n \nvec3 fc = vec3(fog);\n    fc.r = 0.1;\n\nfragColor = vec4(fc,10.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 23, 23, 82], [84, 84, 113, 113, 229], [230, 230, 287, 287, 654]]}
{"id": "4syBzy", "name": "Budding Circles", "author": "rkibria", "description": "A fractal-ish sort of thing.", "tags": ["fractal"], "likes": 2, "viewed": 97, "date": "1529251565", "time_retrieved": "2024-06-20T19:15:09.457067", "image_code": "#define N (10)\n#define OFFSET (1.0 + SHRINK)\n\nfloat circle(in vec2 uv, in vec2 pos, in float r)\n{\n    float d = length(uv - pos);\n    return smoothstep( 1./iResolution.x, 0., abs( d - r ) ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    \n    float t = iTime * 1.25;\n\n    uv.y += 0.05;\n    \n    vec2 pos = vec2(0);\n    float r = 0.1;\n    vec2 m = vec2(1., 0.);\n\n    vec3 centers[N];\n\tfloat c = 0.;\n    \n    float SHRINK = 0.05 + 0.51 * (0.5 + 0.5 * sin(t));\n\n    for( int i = 0; i < N; i++)\n    {\n        c = max( c, circle(uv, pos, r) );\n\n        centers[i] = vec3(pos, r);\n\n        pos += OFFSET * r * m;\n        r *= SHRINK;\n    }\n\n    m = vec2(-m.y, m.x);\n    for( int k = 0; k < N-1; k++)\n    {\n        for( int i = 0; i < N; i++)\n        {\n            vec3 stored = centers[i];\n            vec2 pos = stored.xy;\n            float r = stored.z;\n\n            c = max( c, circle(uv, pos + OFFSET * r * m, r * SHRINK ) );\n            c = max( c, circle(uv, pos - OFFSET * r * m, r * SHRINK ) );\n            c = max( c, circle(uv, pos - OFFSET * r * vec2(-m.y, m.x), r * SHRINK ) );\n\n            pos += OFFSET * r * m;\n            r *= SHRINK;\n            centers[i] = vec3(pos, r);\n        }\n        m = vec2(-m.y, m.x);\n    }\n    fragColor = vec4(sqrt(max(c, 0.))); // Approximate gamma correction.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syBzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 97, 97, 193], [195, 195, 252, 252, 1386]]}
{"id": "4syfDG", "name": "Simple 2D Particles", "author": "ma77os", "description": "Simple 2D Particles", "tags": ["particles"], "likes": 5, "viewed": 213, "date": "1530149390", "time_retrieved": "2024-06-20T19:15:09.935874", "image_code": "// The MIT License\n// Copyright © 2020 André Mattos\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define PI 3.14159265359\n#define TOTAL_PARTICLES 80\n\nstruct Particle {\n    float radius;\n    vec2 pos;\n    vec2 vel;\n    vec3 color;\n};\n\n// function to create a circle\nfloat createCircle(vec2 uv, vec2 pos, float r){\n    float d = length(pos - uv);\n    \n    // smoothstep to correct aliasing\n    return smoothstep(r, r-d*0.05, d);\n}\n\n\nvec3 updateParticles(vec2 uv){\n    \n    vec3 c = vec3(0.0);\n    for(int i = 0; i < TOTAL_PARTICLES; i++){\n        float t = iTime * float (i)*0.5;\n\t\tParticle p = Particle(0.1, vec2(0.0, 0.0), vec2(0.0, 0.0), vec3(0.1, 1.0, 1.0));\n    \tp.pos.x = sin(t*0.1) * 0.3 + cos(t * 0.07) * 0.3;\n        p.pos.y = cos(t*0.13) * 0.3 + sin(t * 0.09) * 0.3;\n        \n        p.radius = sin(t*0.23)*0.02+0.03;\n        p.color = vec3(0., 0., 0.);\n        p.color.rb = vec2(sin(t*0.13)*0.5+0.5);\n        \n        c += vec3(createCircle(uv, p.pos, p.radius)) * p.color;\n        \n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \t\n    // remapping coordinates from (0 <> 1) to (-0.5 <> -0.5)\n    uv -= .5;\n    \n    // adjusting screen ratio to distorted image\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 c = updateParticles(uv);\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1217, 1248, 1295, 1295, 1411], [1414, 1414, 1444, 1444, 2001], [2003, 2003, 2060, 2110, 2447]]}
{"id": "4syfDR", "name": "I messed up!", "author": "Flopine", "description": "Bored at work.", "tags": ["3d", "raymarching", "fractal"], "likes": 10, "viewed": 258, "date": "1528209298", "time_retrieved": "2024-06-20T19:15:10.566276", "image_code": "//Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui and XT95 for teaching me <3 cookie collective rulz\n\n#define ITER 64.\n#define PI 3.141592\n#define STP 3\n\nfloat g = 0.; \n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\n// iq's palette http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*(t+d)));}\n\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p.x = abs(p.x) - d.x;\n    p.y = abs(p.y)-d.y;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\n\nfloat box (vec3 p, vec3 c)\n{\n    float per = 8.;\n    p.x = mod(p.x-per/2., per)-per/2.;\n    return length(max(abs(p)-c,0.));\n}\n\n\nfloat cyl(vec2 p, float r)\n{return length(p)-r;}\n\n\nfloat prim1 (vec3 p)\n{\n    p.xy *= rot(iTime);\n    p.yz *= rot(iTime);\n    float c = min(cyl(vec2(p.x+sin(p.y*0.8),p.z), 0.2), cyl(vec2(p.y, p.z+cos(p.x)), 0.2));\n    float bs = box(p, vec3(1.));\n    return stmin(c, bs, 0.8, 5.);\n        \n}\n\n\nfloat fractal(vec3 p)\n{\n    float prim = prim1(p);\n    for (int i=0; i<STP; i++)\n    {\n\n        p.yz = mo(p.yz, vec2(2.));\n        p.xy = mo(p.xy, vec2(2.));\n        p.xy -= 2.;\n        prim = stmin(prim,prim1(p), 0.9, 5.);       \n    }\n    return prim;\n}\n\n\nfloat SDF (vec3 p)\n{\n    p = abs(p);\n    float d = fractal(p);\n    g += 0.01/(0.01+d*d);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-15.); vec3 p = ro;\n    vec3 dir = normalize(vec3 (uv, 1.));\n    \n    float shad = 0.;\n    \n    for (float i =0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p+=d*dir*0.7;\n    }\n    \n    float t = length(ro-p);\n    \n    vec3 pal = palette(length(uv),\n                      vec3(0.5),\n                      vec3(0.5),\n                      vec3 (1.2),\n                      vec3(0.1,0.2,0.3));\n    \n    vec3 c = mix(vec3(shad), pal,abs(uv.x+uv.y*0.5));\t\n    // glow from lsdlive, originally from balkhan : https://www.shadertoy.com/view/4t2yW1\n\tc += g*0.08;\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 182, 202, 202, 245], [248, 248, 297, 297, 402], [404, 481, 537, 537, 570], [573, 573, 599, 599, 697], [700, 700, 730, 730, 750], [753, 753, 781, 781, 879], [882, 882, 910, 910, 930], [933, 933, 955, 955, 1173], [1176, 1176, 1199, 1199, 1431], [1434, 1434, 1454, 1454, 1538], [1541, 1541, 1598, 1648, 2483]]}
{"id": "4syfDw", "name": "fixed step 1", "author": "xinux", "description": "fixed step test", "tags": ["step"], "likes": 7, "viewed": 185, "date": "1528984924", "time_retrieved": "2024-06-20T19:15:10.566276", "image_code": "// thx to hg (http://mercury.sexy/hg_sdf)\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 scene(vec3 p)\n{\n    pR(p.zx, floor(iTime * 0.5));\n    \n    p.y += iTime * 0.001;\n    \n    pR(p.yz, iTime * 0.2);\n    pR(p.zx, iTime * -0.4);\n    \n    p *= 2.5 + sin(iTime / 3.);\n    vec3 cell = floor(p);\n    p = fract(p + 0.5) - 0.5;\n    \n    float grid = length(p - clamp(p, -0.1, 0.1));\n    vec3 gridc = vec3(step(0.11, grid * 0.2)) * 0.01;\n    \n    pR(p.xy, iTime * 3.);\n    float cube = 1. / length(p - clamp(p, -0.1, 0.1)) * 0.0004;\n    vec3 cubec = min(vec3(cube), p);\n    \n    vec3 c = max(gridc, cubec);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n    vec3 c = vec3(0.15);\n    \n    for(float z = 0.; z < 0.5; z += 1. / 250.)\n    {\n        c += scene(vec3(uv, z));\n    }\n    c = clamp(c, 0., 1.);\n    \n    float inv = mod(floor((iTime + 1.0) * 0.5), 2.);\n    c = (1.0 - c) * inv + c * (abs(inv - 1.0));\n    \n    c -= smoothstep(0.55, 1.3, abs(uv.x)) * 0.2; // vignette x\n    c -= smoothstep(0.17, 0.7, abs(uv.y)) * 0.2; // vignette y\n    c += sin(iTime * 0.4) * 0.08; // ambience\n    c -= step(0.35, abs(uv.y)); // letterbox\n    \n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [{"id": "MtSGRz", "previewfilepath": "https://soundcloud.com/mujuice/motherland", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mujuice/motherland", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 42, 74, 74, 116], [118, 118, 138, 138, 650], [652, 652, 707, 707, 1288]]}
{"id": "4syfRc", "name": "LAB and RGB Comparison", "author": "Squiggle", "description": "Just wanted to be able to visualize how blending changes between the two color spaces. LAB on the left, RGB on the right. Drag mouse to control hue.", "tags": ["colors", "rgb", "lab"], "likes": 4, "viewed": 744, "date": "1529690719", "time_retrieved": "2024-06-20T19:15:10.572382", "image_code": "// LAB/RGB converstions - https://code.google.com/archive/p/flowabs/\n// HSV/RGB conversion - http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2xyz( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    return 100.0 * tmp *\n        mat3( 0.4124, 0.3576, 0.1805,\n              0.2126, 0.7152, 0.0722,\n              0.0193, 0.1192, 0.9505 );\n}\n\nvec3 xyz2lab( vec3 c ) {\n    vec3 n = c / vec3( 95.047, 100, 108.883 );\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab(vec3 c) {\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 lab2xyz( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb( vec3 c ) {\n    vec3 v =  c / 100.0 * mat3( \n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n    );\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb(vec3 c) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float h = cos(iTime*0.3);\n    if( iMouse.z > 0.0 ){\n        h = iMouse.x/iResolution.x;\n    }\n    \n   \tvec3 col = vec3(0.0);\n    vec3 hue = hsv2rgb( vec3(h,1.0,1.0) );\n    \n    if( uv.x > 0.5 ){\n        //RGB\n        col = mix( vec3(1.0), hue, (uv.x - 0.5) * 2.0 );\n        col = mix( vec3(0.0), col, uv.y);\n    }\n    else{\n        //LAB\n        hue = rgb2lab(hue);\n        col = mix( rgb2lab(vec3(1.0)), hue, uv.x * 2.0 );\n        col = mix( rgb2lab(vec3(0.0)), col, uv.y );\n        //col.x = uv.y;\n     \tcol = lab2rgb(col);\n    }\n    \n    //gamma correction\n    //col = pow(col, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 150, 174, 174, 580], [582, 582, 606, 606, 1027], [1029, 1029, 1051, 1051, 1188], [1190, 1190, 1214, 1214, 1602], [1604, 1604, 1628, 1628, 2077], [2079, 2079, 2101, 2101, 2209], [2211, 2211, 2233, 2233, 2402], [2404, 2404, 2461, 2461, 3165]]}
{"id": "4syfRV", "name": "Folie Numerique", "author": "Flopine", "description": "Experimentation done at La Villette in Paris.", "tags": ["raymarching", "glow", "cookiecollective"], "likes": 19, "viewed": 544, "date": "1529483124", "time_retrieved": "2024-06-20T19:15:11.269248", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui, XT95 and Coyhot for teaching me <3 \n// Cookie collective rulz\n\n\n#define PI 3.141592\n#define ITER 64.\n#define MAT_TUN 0.\n#define MAT_SPHE 1.\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// iq's palette http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos(2.*PI*(c*t+d));\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p.x = abs(p.x)-d.x;\n    p.y = abs(p.y)-d.y;\n    if (p.y>p.x) p.xy = p.yx;\n    return p;\n}\n\nfloat stmin(float a, float b, float k ,float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat cyl(vec2 p, float r)\n{return length(p)-r;}\n\nfloat box(vec3 p, vec3 c)\n{\n    p.xz *= rot(iTime);\n    return length(max(abs(p)-c,0.));\n}\n\nfloat sphe(vec3 p, float r)\n{return length(p)-r;}\n\nfloat prim1(vec3 p)\n{\n    float per = 5.;\n    p.xy = mo(p.xy, vec2(10.));\n   p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= 2.;\n    p.xz *= rot(p.y*0.8);\n    return stmin(cyl(p.xz, 0.3), box(vec3(p.x,mod(p.y-per/2.,per)-per/2., p.z),vec3(1.)), 0.8, 5.);\n}\n\nvec2 mat_min(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\nvec2 tunnel (vec3 p)\n{\n        p.xy *= rot(p.z*0.2+iTime*0.5);\n    float s = prim1(p);\n    for (int i = 0; i<8; i++)\n    {\n        p.xy *= rot(PI/4.);\n        p.z -= 8.;\n        s = min(s, prim1(p));\n    }\n    return vec2(s, MAT_TUN);\n}\n\nvec2 prim2 (vec3 p)\n{\n    p.z += cos(p.x + iTime);\n    p.x += sin(p.y+iTime*2.);\n    p.y -= sin(p.z*2.+iTime*3.);\n    return vec2(sphe(p,5.), MAT_SPHE);\n}\n\nfloat g = 0.;\n\nvec2 SDF(vec3 p)\n{\n    vec2 d = mat_min(tunnel(p), prim2(p));\n     // glow from lsdlive, originally from balkhan : https://www.shadertoy.com/view/4t2yW1\n    g += 0.01/(0.01+d.x*d.x);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-20.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,0.7+length(uv)));\n    \n    float shad = 0.;\n    vec3 c = vec3(0.);\n    for (float i = 0.; i<ITER; i++)\n    {\n\t\tvec2 d = SDF(p);\n        if (d.x<0.001)\n        {\n            shad = i/ITER;\n            if (d.y == MAT_SPHE) c = vec3(1.-shad)*vec3(1.,0.,.8);\n            if (d.y == MAT_TUN) c = vec3(1.-shad)*vec3(0.,0.1,1.5);\n            break;\n        }\n        p+=d.x*rd*0.5;\n    }\n    \n    float t = length(ro-p);\n    vec3 pal = palette (length(uv),\n                       vec3(0.8,0.5,0.),\n                       vec3(0.5),\n                       vec3 (.2),\n                       vec3(0.,0.,0.5));\n    \n    c = mix(c, pal, 1.-exp(-0.002*t*t))+g*(0.02+p.z*0.01);\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 205, 235, 235, 359], [361, 438, 494, 494, 531], [533, 533, 552, 552, 595], [597, 597, 623, 623, 717], [719, 719, 768, 768, 875], [877, 877, 905, 905, 925], [927, 927, 954, 954, 1017], [1019, 1019, 1048, 1048, 1068], [1070, 1070, 1091, 1091, 1318], [1320, 1320, 1350, 1350, 1400], [1402, 1402, 1424, 1424, 1638], [1640, 1640, 1661, 1661, 1794], [1811, 1811, 1829, 1829, 2009], [2011, 2011, 2068, 2118, 3012]]}
{"id": "4syfWw", "name": "Slovakia flag", "author": "po1nt", "description": "Flag of Slovak Republic", "tags": ["slovakiaflag"], "likes": 1, "viewed": 323, "date": "1528962227", "time_retrieved": "2024-06-20T19:15:11.269248", "image_code": "vec2 RES = vec2(1920,1080);\n\nconst float PI_x_2 = 6.28318530718;\n\n// From: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 step = floor(uv*RES) / RES;\n    \n    float changeRate = rand(step);\n    \n    vec3 col = mix(vec3(1,0,0), vec3(1,1,1), uv.x);\n    col.xy *= cos(vec2(col.y, col.z) * PI_x_2) + .9;\n    \n    vec3 col_t = 2.0 * cos(changeRate*iTime) * col;\n\n    fragColor = vec4(col_t, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[66, 151, 171, 171, 243], [245, 245, 302, 302, 628]]}
{"id": "4syfzV", "name": "Cocon", "author": "Flopine", "description": "It was supposed to be a nice and warm cocoon... And then life... ^^\"", "tags": ["raymarching", "beat", "underwater", "twisted"], "likes": 12, "viewed": 389, "date": "1529499017", "time_retrieved": "2024-06-20T19:15:11.978421", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui, XT95 and Coyhot for teaching me <3\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// from: https://beta.observablehq.com/@mattdesl/heartbeat-function\nfloat beat (float value, float intensity, float frequency) \n{\n    float v = atan(sin(value * 3.14 * frequency) * intensity);\n    return (v + 3.14 / 2.) / 3.14;\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// iq's palette http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a+b*cos(2.*PI*(c*t+d));\n}\n    \n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\n\n// iq's formula http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat prim1(vec3 p)\n{\n    return sdCapsule(p, vec3(0.,-1.5,0.), vec3(0.,1.5,0.), 1.4+p.y*0.3);\n}\n\nfloat cocoon(vec3 p)\n{\n    \n    vec3 pp = p;\n    p.x += sin(p.y*0.7);\n    p *= 0.4+beat(iTime,.5,2.);\n    float cap = prim1(p);\n    \n    p.xz *= rot(iTime);\n    p.xz *= rot(p.y*0.5);\n    p.xz = moda(p.xz, 2.*PI/3.);\n   \tp.x -= (2.-abs(p.y-1.)*0.3);\n    float branch1 = cyl(p.xz, 0.4);\n    \n    p = pp;\n\n    p.xy *= rot(PI/3.);\n    p.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch2 = cyl(p.xz, 0.3+abs(p.y)*0.03);\n    \n    p = pp;\n\n    p.xy *= rot(-PI/3.);\n    p.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch3 = cyl(p.xz, 0.1+abs(p.y)*0.03);\n    \n    return smin(branch3,smin(branch2,smin(cap,branch1,3.), 3.),3.);\n}\n\n\nfloat g = 0.;\n\nvec4 SDF (vec3 p)\n{\n    vec4 d = vec4(cocoon(p),p);\n     // glow from lsdlive, originally from balkhan : https://www.shadertoy.com/view/4t2yW1\n    g += 0.01/(0.01+d.x*d.x);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    uv += texture(iChannel1, uv*0.3+iTime*0.1).r *0.08;\n    \n    vec3 ro = vec3(0.001,1.,-6.); vec3 p = ro;\n    vec3 dir = normalize(vec3 (uv,1.));\n    float shad = 0.;\n    vec3 c = vec3(0.);\n    \n    vec3 pal = palette(length(uv),\n                      vec3(0.2),\n                      vec3(0.2),\n                      vec3(-.12),\n                      vec3(0.5,0.,0.2));\n    \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p).x;\n        if(d<0.001)\n        {\n            shad = i / ITER;\n            c = texture(iChannel0, SDF(p).yz*0.2).xyz\n                *vec3(shad)*3.\n                *vec3(length(p.z)*0.8,0.1,0.5) \n                + g*0.008*length(uv)*0.6;\n            break;\n        }\n        else c = pal;\n        p+= d*dir*0.6;\n    }\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 165, 185, 185, 228], [230, 230, 271, 271, 342], [344, 412, 473, 473, 573], [575, 575, 606, 606, 730], [732, 809, 865, 865, 902], [909, 909, 938, 938, 958], [961, 1044, 1096, 1096, 1223], [1226, 1226, 1247, 1247, 1322], [1324, 1324, 1346, 1346, 2102], [2120, 2120, 2139, 2139, 2308], [2310, 2310, 2367, 2417, 3325]]}
{"id": "4syfzy", "name": "Fade Effect", "author": "YiubunAuyeung", "description": "post-process", "tags": ["fade"], "likes": 5, "viewed": 137, "date": "1529247190", "time_retrieved": "2024-06-20T19:15:12.123858", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    float grey = dot(col, vec3(1,1,1)) / 3.0;    \n    vec3 img = texture(iChannel1, uv).rgb;\n    \n    vec2 uv0 = (uv*2.0 - 1.0) * 0.5;\n    float length0 = sqrt(dot(uv0, uv0));\n    float time = fract(iTime / 2.0) * 25.0;\n    float mask = 1.0 - clamp(length0 * 20.0 - (time*(grey*0.5+0.5)),0.0,1.0);\n        \n    // Output to screen\n    fragColor.rgb = (1.0-mask) * img + mask*vec3(1.0,1.0,1.0);\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 642]]}
{"id": "4tBBDm", "name": "RC terrain1", "author": "vchizhov", "description": "Something I did as a prototype for a rendering competition. Pretty much all lighting effects are fake.", "tags": ["procedural", "raymarching", "terrain", "fbm"], "likes": 0, "viewed": 129, "date": "1528906347", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "/*\n*`\tHashing function - produces noise\n*\n*\tThe idea is: float rnd = fract(bigseed*sin(smallerseed*x));\n*\tSmall changes in x produce big changes in the result,\n*\tsnce we are taking the fractional part we get big jumps in the result\n*\twhich looks kinda like noise\n*\tThe idea behind it is similar to a linear congruential generator:\n*\tXn+1 = (a*Xn+c) mod m\n*\tWe can rewrite our hash as: c = 0, Xn+1 = ((a*sin(b*Xn)) mod m)/m\n*\t\n*\t@param n:\tSome value (can be a coordinate or whatever)\n*\t@return:\tPseudo-random number in [0,1)\n*\n*/\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// rotation matrix for the fractal brownian motion\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n// inverse (in this case transpose) of the rotation matrix\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n\n/*\n*\tValue noise with analytical derivative\n*\n*\tOriginally from: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n*\tThe quintic interpolation was proposed by Ken Perlin in: https://mrl.nyu.edu/~perlin/paper445.pdf\n*\tAdditional info:\n*\thttps://thebookofshaders.com/11/\n*\thttps://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1\n*\tFor perlin noise, see:\n*\thttp://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm\n*\n*\t@param x:\tSome point in 3d space\n*\t@return:\tThe first component has the value of the noise at location x,\n*\t\t\t\tthe last 3 are used to store the gradient\n*/\nvec4 noised( in vec3 x )\n{\n    // grid: take the whole part of x for grid point\n    // take the fractional part for interpolation\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    // derivative of the quintic polynomial\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    // build a seed from the coordinates\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    // compute the values for the noise at the 8 vertices of the noise grid\n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    // interpolation coefficients\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    // vec4.x = value, vec4.yzw = gradient (non-normalized normal)\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n/*\n*\n*\tFractal brownian motion\n*\n*\tUsed to create terrain structures from smoothed noise (value/perlin/vornoi/simplex)\n*\n*\tOriginally from here: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n*\tMore info on fbm: https://thebookofshaders.com/13/\n*\t\n*\t@param x: \tSome point in 3d space at which we want to evaluate the terrain\n*\t@return:\tA 4d vector with first component the value, and last 3 components the gradient\n*/\n// this should be called fbmd_7 actually since I use only 7 octaves\nvec4 fbmd_8( in vec3 x )\n{\n    // starting frequency\n    float f = 1.92;\n    // amplitude attenutation factor\n    float s = 0.5;\n    // accumulate the noise values here\n    float a = 0.0;\n    // starting amplitude\n    float b = 0.5;\n    // accumulate the derivatives here\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\t\t\t\t // attenuate amplitude\n        x = f*m3*x;\t\t\t // increase frequency and rotate the kernel to reduce axial bias\n        m = f*m3i*m;\t\t // used for the derivative\n    }\n    // first component has the value of the fbm, last 3 have the gradient\n\treturn vec4( a, d );\n}\n\n// same thing as the hash above, this time without sin and has 2 coordinates\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n// 2d value noise (billinear interpolation)\nfloat valueNoise(vec2 p)\n{\n    // whole part\n    vec2 w = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    // quintic smoothstep - smoother(1st and 2nd order derivatives = 0 at x=0,x=1)\n    // suggested by Ken Perlin: https://en.wikipedia.org/wiki/Smoothstep\n    vec2 u = f*f*f*(f*(f*6.0f - 15.0f) + 10.0f);\n\t\n    // value noise grid vertices\n    float a = hash1(w);\n    float b = hash1(w+vec2(1.0f, 0.0f));\n    float c = hash1(w+vec2(0.0f, 1.0f));\n    float d = hash1(w+vec2(1.0f, 1.0f));\n\n    // perform bilinear interpolation\n    float bilinear = a + (b - a)*u.x + (c - a)*u.y + (a - b - c + d)*u.x*u.y;\n    return bilinear;\n}\n\n// 2d value noise with derivatives - just applying the chain rule to get the x and y partial derivatives\nvec3 valueNoiseD(vec2 p)\n{\n\t// whole part\n    vec2 w = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    // quintic smoothstep - smoother(0 1st and 2nd order derivatives at x=0,x=1)\n    // suggested by Ken Perlin: https://en.wikipedia.org/wiki/Smoothstep\n    vec2 u = f*f*f*(f*(f*6.0f - 15.0f) + 10.0f);\n\n    float a = hash1(w);\n    float b = hash1(w+vec2(1.0f, 0.0f));\n    float c = hash1(w+vec2(0.0f, 1.0f));\n    float d = hash1(w+vec2(1.0f, 1.0f));\n\tfloat k0 = a;\n\tfloat k1 = b-a;\n\tfloat k2 = c-a;\n\tfloat k3 = a-b-c+d;\n    // perform bilinear interpolation\n    float bilinear = k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n\tvec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n\tvec2 bilinearD = vec2((k1 + k3*u.y)*du.x, (k2+k3*u.x)*du.y);\n    return vec3(bilinear,bilinearD);\n}\n\n\n// more fbm\nconst int fbm_octaves = 4;\nconst float fbm_a = 0.5f;\nconst float fbm_f = 2.0f;\n\n// 2d fbm\nfloat fbm(in vec2 p)\n{\n    float sum = 0.0f;\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n\tconst float ampDamp = fbm_a;\n\tconst float freqAtt = fbm_f;\n    float shift = 100.0f;\n    p *= frequency;\n    for (int i = 0; i < fbm_octaves; ++i)\n    {\n        sum += amplitude*valueNoise(p);\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mat2(0.8f, 0.6f, -0.6f, 0.8f)*p*freqAtt;\n    }\n\n    return sum;\n}\n\n// 2d fbm with derivatives - once again - applying the chain rule to get the derivatives\n// the matrix multiplication is to reduce the axial bias\nvec3 fbmd(in vec2 p)\n{\n\tfloat sum = 0.0f;\n\tvec2 d = vec2(0.0f, 0.0f);\n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n\tconst float ampDamp = fbm_a;\n\tconst float freqAtt = fbm_f;\n    float shift = 100.0f;\n    p *= frequency;\n\t// used to reduce axial bias\n\tconst mat2 mRot = mat2(0.8f, 0.6f, -0.6f, 0.8f);\n\t// the transpose of mRot\n\tconst mat2 mRotTranspose = mat2(0.8f, -0.6f, 0.6f, 0.8f);\n\t// we'll accumulate the powers of the transpose of mRot here\n\t// in the beginning this is the identity matrix\n\tmat2 m = mat2(1.0f, 0.0f, 0.0f, 1.0f);\n    for (int i = 0; i < fbm_octaves; ++i)\n    {\n\t\tvec3 ns = valueNoiseD(p);\n        sum += amplitude*ns.x;\n\t\td += amplitude*m*ns.yz;\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mRot*p*freqAtt;\n\t\tm = freqAtt*mRotTranspose*m;\n    }\n\n    return vec3(sum,d);\n}\n\n\nfloat fbm9(in vec2 p)\n{\n    float sum = 0.0f;\n    float amplitude = 0.15f;\n    float frequency = 0.8f;\n\tconst float ampDamp = 0.55f;\n\tconst float freqAtt = 1.9f;\n    float shift = 100.0f;\n    p *= frequency;\n    for (int i = 0; i < 9; ++i)\n    {\n        sum += amplitude*(2.0f*valueNoise(p)-1.0f);\n        amplitude *= ampDamp;\n        // rotation to reduce axial bias\n        p = mat2(0.8f, 0.6f, -0.6f, 0.8f)*p*freqAtt;\n    }\n\n    return sum;\n}\n\n\nconst float terrainScale = 0.15f;\nconst float terrainHeight = 4.0f;\n\n// how we define the terrain\nfloat terrainMap(in vec2 p)\n{\n    float anim = 1.5*(0.5+0.5*abs(sin(iTime*0.5)));\n    return terrainHeight*fbm(anim*terrainScale*p);\n}\n\n// normals from analytic derivatives\n// the other option is calculating the derivatives numerically, but that requires evaluating\n// terrainMap at least 2 times(forward differences, and the known value at the point we're in)\nvec3 terrainNormal(in vec2 p)\n{\n#if 0\n\tvec3 fd = terrainHeight*terrainScale*fbmd(terrainScale*p);\n\t// we have the implicit surface y = f(x,z) => F(x,y,z) = y-f(x,z) = 0\n\t// then the normal is given by the gradient: (dF/dx, dF/dy, dF/dz)\n\treturn normalize(vec3(-fd.y, 1.0f, -fd.z));\n#else\n\tvec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(p-e.xy) - terrainMap(p+e.xy),\n                           2.0*e.x,\n                           terrainMap(p-e.yx) - terrainMap(p+e.yx) ) );\n#endif\n}\n\n// try to find an intersection with the terrain\nfloat raymarchTerrain(in vec3 o, in vec3 rd, float mint, float maxt)\n{\n\t// starting step size\n\tconst float startingDelta = 0.2f;\n\t// step size scaling with t\n\tconst float scalingDelta = 0.01f;\n\t// near and far radius\n\t//const float mint = 0.0f;\n    //const float maxt = 20.0f;\n\t\n\t// used for linear interpolation (better intersection)\n\t// last y\n\tfloat ly = 0.0f;\n\t// last terrain y\n\tfloat lh = 0.0f;\n\t// integrate over the ray path\n\tfloat delta = startingDelta;\n\tfor(float t = mint; t<maxt; t+= delta)\n\t{\n\t\t// current sample point on ray\n\t\tvec3 p = o+t*rd;\n\t\t// evaluate terrain height\n\t\tfloat h = terrainMap(p.xz);\n\t\t// if the ray point is beneath the terrain - find the intersection (incorrect if we start inside the terrain)\n\t\tif(p.y<h)\n\t\t{\n\t\t\t// linearly interpolate the last point and the current one, to estimate\n\t\t\t// the ray-terrain intersection\n\t\t\tfloat resT = t-delta + delta*(lh-ly)/(p.y-ly-h+lh);\n\t\t\treturn resT;\n\t\t}\n\t\t// record the last ray sample y and terrain y\n\t\tly = p.y;\n\t\tlh = h;\n\t\t// rescale delta for a speedup\n\t\tdelta = startingDelta + t*scalingDelta;\n\t}\n\treturn -1.0f;\n}\n\nconst vec3 sunDir = normalize(vec3(-0.6f, 0.4f, 0.6f));\n\n// You're not interested in this atm\nfloat terrainShadow(in vec3 o, in vec3 rd)\n{\n\tconst float mint = 0.01f;\n    float t = mint;\n\tfloat res = 1.0f;\n\tfor( int i=0; i<32; i++ )\n    {\n        vec3  pos = o + t*rd;\n        float  env = terrainMap( pos.xz );\n        float hei = pos.y - env;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 1.0+t*0.1, 50.0 );\n    }\n\t\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 fogCol = vec3(0.4,0.6,1.15);\n    return mix( col, fogCol, 1.0-exp(-0.00005*t*t*t) );\n}\n\n\nfloat raytraceWater(in vec3 o, in vec3 rd)\n{\n    const float waterHeight = 0.5f;\n    float t = (waterHeight-o.y)/rd.y;\n    float resT = t<0.0f? -1.0f : t;\n    return resT;\n}\n\n/*\n*\tAn abomination that serves to replace random\n*\n*\t@param seed: some seed\n*\n*\t@return: \"random\" number in [0,1)\n*/\nfloat hashAO(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n/*\n*\tComputes ambient occlusion\n*\n*\t@param p: \t\t\tSome intersection points which we want to calculate ambient occlusion for\n*\t@param n: \t\t\tThe normal at this point\n*\t@param aoRadius:\tRadius of occlusion\n*\t@param seed:\t\tA seed for the abomination \"sampling random numbers\"\n*\n*\t@return:\t\tOcclusion coefficient in [0,1], 0 - totally occluded, 1 - totally non-occluded\n*/\n#define AO_SAMPLES 16\nfloat ao(in vec3 p, in vec3 n, float aoRadius)\n{\n    float seed = hashAO( dot( p.xy*p.yz, vec2(12.9898, 78.233)+float(iTime) ) );\n    float occ = 0.0;\n    // integration of the hemisphere - we take AO_SAMPLES number of samples\n    for(int k=1;k<AO_SAMPLES;++k)\n    {\n        // in your implementation u and v would look like this:\n        // u = random();\n        // v = random();\n        // the abomination you see here is because this is glsl code:\n        float u = hashAO( 78.233 + seed + float(k)*92.13);\n    \tfloat v = hashAO( 10.873 + seed + float(k)*35.00);\n        \n        // the next part generates a cosine distributed direction in the upper hemisphere\n        // given a normal, ofr more information: http://amietia.com/lambertnotangent.html\n        // you can simply use your code from the homework - you don't need to use this one\n        // it's just good since it doesn't require you to build a coordinate frame\n        float a = 6.2831853 * v;\n        u = 2.0*u - 1.0;\n        vec3 dir = normalize(n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\n        // note that since I generate a cosine distributed direction,\n        // the pdf is = cos(theta)/pi\n        // we want to find the visibility integral from here:\n        // https://en.wikipedia.org/wiki/Ambient_occlusion\n        // the cosine term cancel out, with the pdf, also the pi from the pdf cancels out\n        // with the 1/pi in front of the integral from the wikipedia article\n        \n        // this is the part where you check whether this ray intersects anything \n        // in a given radius - if it does - increment the occlusion count\n        // if it doesn't - do nothing\n    \tif(raymarchTerrain(p,dir,0.01,aoRadius)>0.0)\n        {\n            ++occ;\n        }\n    }\n    // occ/AO_SAMPLES would be the occlusion\n    // I want the oposite, so I subtract it from 1\n    return 1.0-occ/float(AO_SAMPLES);\n}\n\n\nvec4 renderTerrain(in vec3 o, in vec3 rd)\n{\n\tvec3 col = vec3(0.0f);\n\t// find intersection between the ray and the terrain (if there is no intersection: t==-1.0f)\n\tfloat t = raymarchTerrain(o, rd, 0.01, 20.0);\n\tif(t>0.0f)\n\t{\n        // You're also not interested in this atm\n\t\t// intersection position\n\t\tvec3 pos = o+rd*t;\n\t\tvec3 nor = terrainNormal(pos.xz);\n        float anim = 1.5*(0.5+0.5*abs(sin(iTime*0.5)));\n\t\tnor = normalize( nor + 0.8*(1.0-abs(nor.y))*0.8*fbmd_8( anim*pos*0.3*vec3(1.0,0.2,1.0) ).yzw );\n\t\tvec3 green = vec3(0.3f, 0.3f, 0.0f);\n\t\tvec3 desert = vec3(0.18,0.11,0.10)*.75;\n\t\tvec3 interm = mix( desert, green, smoothstep(0.7,0.9,nor.y) );\n\t\tfloat w = (o+t*rd).y/(1.5f*terrainHeight);\n\t\tfloat diff = max(0.0f, dot(sunDir, nor));\n\t\t//if(diff>0.001f) diff *= terrainShadow(pos+nor*0.01f, sunDir);\n\t\tvec3 lin = 1.0*5.0*vec3(1.0,0.9,0.8)*diff;\n\t\tcol = interm*w;\n\t\tcol *= lin;\n        col = fog(col, t);\n\t\t\n        //vec3 pos = o+rd*t;\n        //float ambientTerm = ao(pos, terrainNormal(pos.xz), 3.0);\n        //col = vec3(ambientTerm);\n\t}\n\treturn vec4(col, t);\n}\n\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\n\n    // clouds\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm9( uv*0.002 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.4*dl );\n    }\n    \n\t// sun glare    \n    float sun = clamp( dot(sunDir,rd), 0.0, 1.0 );\n    col += 0.8*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 renderWater(in vec3 o, in vec3 rd)\n{\n    vec3 col = vec3(0.0f);\n    float tw = raytraceWater(o,rd);\n    if(tw>0.0f)\n    {\n        col = vec3(0.3f, 0.48f, 1.0f);\n        vec3 pos = o+rd*tw;\n        vec3 ref = reflect(rd, vec3(0.0f, 1.0f, 0.0f));\n        float diff = sunDir.y;\n        col *= diff;\n        vec3 spec = vec3(pow(max(0.0f, dot(ref, sunDir)),10.0));\n        col += spec;\n        vec3 bon = normalize(ref-vec3(0.0f, 0.4f+0.02f*(2.0f*rand(pos.xz)-1.0f), 0.0f));\n        vec4 rf = renderTerrain(pos+vec3(0.0f, 0.2f, 0.0f), bon);\n        if(rf.w>0.0f) col *= rf.xyz;\n        else\n        {\n            col *= 1.0f*mix(col, vec3(1.8f), (0.5f*fbm9( pos.xz*7.0f )+0.5f));\n        }\n        \n        col = fog(col, tw);\n    }\n    return vec4(col, tw);\n}\n\n\nvec3 render(in vec3 o, in vec3 rd)\n{\n\tvec3 col = renderSky(o,rd);\n    vec4 waterCol = renderWater(o,rd);\n    vec4 terrCol = renderTerrain(o, rd);\n    if(waterCol.w>0.0f && terrCol.w>0.0f)\n    {\n        if(waterCol.w<terrCol.w)\n        \tcol = waterCol.xyz;\n        else\n            col = terrCol.xyz;\n    }\n    else if(waterCol.w>0.0f)\n        col = waterCol.xyz;\n    else if(terrCol.w>0.0f)\n        col = terrCol.xyz;\n        \n\t// equivalent to col = terrCol.w==1.0f ? terrCol.xyz : col;\n\t\n\treturn col;\n}\n\n#define PI 3.14159265359f\nvec3 render(vec2 ndc, float aspectRatio)\n{\n\t// camera origin\n    vec3 o = vec3(0.0f, 5.0f, -6.0f);\n\t// camera horizontal field of view\n    const float fov = 2.0f*PI / 3.0f;\n    const float scaleX = tan(fov / 2.0f);\n\t// camera right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f)*scaleX;\n\t// camera forward vector\n    vec3 forward = vec3(0.0f, 0.0f, 1.0f);\n\t// camera up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f)*scaleX*aspectRatio;\n\t// ray direction\n    vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\n    return render(o, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = 2.0f*fragCoord.xy / iResolution.xy-1.0f;\n\tvec3 col = render(ndc, 1.0);\n    \n    // approximate gamma correction\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 529, 553, 553, 604], [979, 1629, 1655, 1758, 3043], [3045, 3547, 3573, 3599, 4395], [4397, 4474, 4497, 4497, 4574], [4576, 4620, 4646, 4664, 5260], [5262, 5367, 5393, 5408, 6130], [6225, 6235, 6257, 6257, 6678], [6680, 6826, 6848, 6848, 7669], [7672, 7672, 7695, 7695, 8118], [8190, 8219, 8248, 8248, 8353], [8355, 8580, 8611, 8611, 9075], [9077, 9125, 9195, 9218, 10219], [10278, 10315, 10359, 10359, 10720], [10722, 10722, 10756, 10756, 10852], [10855, 10855, 10899, 10899, 11028], [11030, 11148, 11174, 11174, 11217], [11219, 11608, 11656, 11656, 13505], [13508, 13508, 13551, 13551, 14585], [14588, 14588, 14630, 14657, 15102], [15104, 15104, 15124, 15124, 15191], [15193, 15193, 15234, 15234, 15955], [15958, 15958, 15994, 15994, 16462], [16490, 16490, 16532, 16550, 17028], [17030, 17030, 17087, 17087, 17263]]}
{"id": "ldGBRd", "name": "Rotating Point Cube", "author": "Zeppelin7", "description": "A cube made up of points with a camera rotating around it.", "tags": ["cube", "rotating", "point"], "likes": 3, "viewed": 420, "date": "1529961797", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "float distLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nfloat drawPoint(vec3 ro, vec3 rd, vec3 p) {\n    p -= .5; // move cube to center of screen\n    float d = distLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(iTime), 2., -3.*cos(iTime)); // ray origin\n    \n    vec3 lookAt = vec3(0.);\n    \n    float zoom = 1.3;\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro; // ray dir.\n    \n    float t = iTime;\n    \n    float d = 0.;\n    \n    d += drawPoint(ro, rd, vec3(0., 0., 0.));\n    d += drawPoint(ro, rd, vec3(0., 0., 1.));\n    d += drawPoint(ro, rd, vec3(0., 1., 0.));\n    d += drawPoint(ro, rd, vec3(0., 1., 1.));\n    d += drawPoint(ro, rd, vec3(1., 0., 0.));\n\td += drawPoint(ro, rd, vec3(1., 0., 1.));\n    d += drawPoint(ro, rd, vec3(1., 1., 0.));\n    d += drawPoint(ro, rd, vec3(1., 1., 1.));\n    \n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 42, 42, 93], [95, 95, 138, 138, 268], [270, 270, 327, 327, 1206]]}
{"id": "ldGfDW", "name": "Loading Dots", "author": "AlphaRogue", "description": "Simple loading shader", "tags": ["2d", "loading", "dots"], "likes": 1, "viewed": 116, "date": "1528888034", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "#define RADIUS .025\n#define STEP 2.\n#define BLUE vec3(.11, .15, .2)\n#define WHITE vec4(1., .98, .9, 1.)\n#define RED vec3(.6, .09, .08)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 lM = vec2(max(iResolution.x, iResolution.y), min(iResolution.x, iResolution.y));\n\tvec2 pos = (fragCoord -.5 * lM) / lM.x;\n    \n    pos.x += RADIUS;\n    \n    fragColor = WHITE;\n    \n    if (abs(pos.x - RADIUS) > STEP * RADIUS * 3. || abs(pos.y) > RADIUS * 3.) return;\n    \n    float alpha = sin(iTime * 4. + floor((pos.x / (STEP * RADIUS)) / 2.)) * .5 + .5;\n    pos = vec2(mod(pos.x, RADIUS * 2. * STEP) - RADIUS, pos.y + min(alpha, .5) / 25.);\n    \n    float dist = length(pos);\n    if (dist < RADIUS)\n        fragColor = mix(WHITE, vec4(mix(RED, BLUE, alpha), 1.), smoothstep(RADIUS, RADIUS * .93, dist));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[136, 136, 191, 191, 806]]}
{"id": "ldGfDz", "name": "Raymarch (Glim)", "author": "Glim888", "description": "Raymarch", "tags": ["raymarch"], "likes": 0, "viewed": 66, "date": "1528302506", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "#define ITERATIONS 25\n#define MAX_INTERSECTION_DIST 0.001\n#define MAX_DIST 5000.0\n#define SUN_RAD 2.0\n\nvec3 sun_pos;\n// Ray\nstruct ray_t {\n \tvec3 o;\n \tvec3 d;    \n};\n\n// Sphere Object\nstruct sphere_t{\n\tvec3 pos;\n    vec3 col;\n    float rad;\n};\n\nmat3 rot3D (float rad) {\n  return mat3 (cos(rad), 0.0, sin(rad),\n               0.0\t   , 1.0, 0.0     ,\n               -sin(rad),0.0, cos(rad)); \n}\n\nfloat distance_from_sphere(vec3 pos, sphere_t sphere) {\n \treturn length(pos - sphere.pos) - sphere.rad;  \n}\n\nvec3 raymarch (ray_t ray, sphere_t sphere) {\n    \n    vec3 current_pos;\n    float way_done = 0.0;\n    float dist_to_sphere;\n    \n    for (int i=0; i<ITERATIONS; ++i) {\n        \n       current_pos = ray.o + ray.d*way_done;\n        \n       dist_to_sphere = distance_from_sphere(current_pos, sphere); \n        \n        if (dist_to_sphere < MAX_INTERSECTION_DIST) {\n            \n            float shading = 0.0;\n            \n            if (sun_pos != sphere.pos) {\n               shading = dot (normalize(sun_pos), normalize(current_pos-sphere.pos));\n            }else{\n               shading = 1.0;\n            }\n            \n        \treturn vec3(sphere.col.r * shading+0.1,\n                        sphere.col.g * shading+0.1,\n                        sphere.col.b * shading+0.1);  \n        }\n        \n        if (way_done > MAX_DIST) break;\n        \n        way_done += dist_to_sphere;\n        \n    }\n    \n    return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera Position\n    vec3 camera \t= vec3(0.0,0.0,-4.0);            \n       \n    ray_t ray \t\t= ray_t(camera,vec3(uv, 1.));\n    \n    sphere_t sphere[2];\n    \n    sphere[0] = sphere_t(vec3(0.0,-1.0, 1.0),vec3(0.5, 0.5, .5), 2.0);\n    sphere[1] = sphere_t(vec3(sin(iTime)*SUN_RAD, 2.5, 1.+cos(iTime)*SUN_RAD),vec3(1.0, 1.0, .0), 1.0);\n    \n    sun_pos = sphere[1].pos;\n    \n    vec3 col = vec3 (0.0);\n    \n    for (int i=0; i<sphere.length(); i++) \n    \tcol += raymarch(ray, sphere[i]);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[167, 245, 269, 269, 392], [394, 394, 449, 449, 501], [503, 503, 547, 547, 1430], [1433, 1433, 1490, 1540, 2159]]}
{"id": "ldGfzc", "name": "Walk into the light", "author": "rkibria", "description": "Glowy portal thing.", "tags": ["2d"], "likes": 3, "viewed": 115, "date": "1529785670", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "float star(in vec2 uv, in float t)\n{\n    float phi = atan(uv.y, uv.x);\n    float d = length(uv)\n        * (1. \n           + 0.15 * sin( phi * 4. + 0.2 * t) \n           + 0.1 * sin( 1.2 * phi * 10. + 0.6 * t) \n           + 0.2 * sin( phi * phi * 2. + 0.4 * t) \n          ) * 7.7 * ( 1. + 0.1 * sin(t) );\n    d = log(d*d);\n    return 0.7 * d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n\n    float t = 1.4 * iTime;\n    float d = 0.5 * min(star(uv, t), star(uv, t - 2.1));\n    d = (1. + 0.1 * sin(t)) * min(d, star(uv, t - 3.1));\n    \n    fragColor = vec4( sqrt( smoothstep(1., 0., d) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 342], [344, 344, 401, 401, 669]]}
{"id": "ldKBDy", "name": "Wet Plasma", "author": "_polymath", "description": "Combining two others just to see if I can", "tags": ["plasma", "water"], "likes": 3, "viewed": 521, "date": "1530362376", "time_retrieved": "2024-06-20T19:15:15.033341", "image_code": "#define SPEED 8.0\n#define HEIGHT 0.05\n#define WAVELENGTH -100.0\n#define DIEOFF 0.6\n#define DROPS 40.0\n#define TIMEDIEOFF 0.6\n#define DISTANCEDIEOFF 38.2\n#define DROPFRQ 5000.0\n#define PROPSPEED 3.0\n\nvec4 plasma( vec2 uv )\n{\n    float d = 0.0;\n    for (float i = 0.0; i < 200.0; ++i) {\n        float j = max(0.0, 3.14 - distance(uv, vec2(\n            sin(i + iTime * mod(i * 2633.2363, 0.42623)) * 12.0,\n            cos(i  * 0.617 + iTime * mod(i * 36344.2363, 0.52623)) * 12.0\n        )));\n        d += cos(j);\n     }\n    float r = cos(d * 6.0) * 0.5 + 0.5;\n    float g = cos(d * 3.0) * 0.5 + 0.5;\n    return vec4(r, g, max(r, g), 1.0);\n}\n\nfloat h(vec2 uv) {\n    float h = 0.0;\n    for (float i = 0.0; i < DROPS; ++i) {\n        vec2 c = vec2(\n            mod(cos(i * 343.7345), 0.001) * 1000.0,\n            mod(cos(i * 634.3634), 0.001) * 1000.0 * iResolution.y / iResolution.x);\n        float d = distance(uv, c);\n        float t = mod(cos(i * 734.6345), 0.001) * DROPFRQ;\n        t = mod(t - iTime, DROPFRQ / 1000.0);\n        if (t * PROPSPEED< d) continue;\n        h -= HEIGHT * sin(d*WAVELENGTH + SPEED*iTime) * t\n                        * pow(d*DISTANCEDIEOFF,-TIMEDIEOFF * t);\n     }\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float n = h(uv),\n        d = h(uv - 0.00001) - n;\n    \n    fragColor = plasma((uv + n)* 6.0 ) + min(0.1,max(-0.1, d * 10000.0)) * 0.5;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKBDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[199, 199, 223, 223, 638], [640, 640, 658, 658, 1205], [1207, 1207, 1264, 1264, 1449]]}
{"id": "ldKBRt", "name": "Eternal Commute", "author": "tdhooper", "description": "Placed 3rd in the 2018 Nova wild compo (as an animated gif, check out [url]https://giphy.com/gifs/7J4WFr2AAN0vGVXTgZ[/url] if it's running slowly)", "tags": ["escher", "knot", "train", "trefoil", "underground", "nova", "london", "graffiti", "tfl"], "likes": 83, "viewed": 1681, "date": "1530050396", "time_retrieved": "2024-06-20T19:15:21.088239", "image_code": "\nfloat time;\n\n// --------------------------------------------------------\n// Utilities\n// hg_sdf https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Don't round corners when distance is reduced\nfloat fBoxy(vec2 p, vec2 s) {\n    return vmax(abs(p) - s);\n}\n\nfloat smin(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b) {\n    return smin(a, b, .0);\n}\n\nfloat smax(float a, float b) {\n    return smax(a, b, 0.);\n}\n\n\n// --------------------------------------------------------\n// Bezier\n// IQ https://www.shadertoy.com/view/ldj3Wh\n// Modified to return the closest point instead of\n// the distance\n// --------------------------------------------------------\n\nvec4 bezierPoint(vec3 A, vec3 B, vec3 C, vec3 pos)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec4 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec3 qos = A + (c + b*t)*t;\n        res = vec4(qos, t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec3 qos = A + (c + b * t.x) * t.x;\n        float dis = dot(qos - pos, qos);\n        res = vec4(qos, t.x);\n\n        qos = A + (c + b * t.y) * t.y;\n        float dis2 = dot(qos - pos, qos);\n        if( dis2 < dis ) {\n            res = vec4(qos, t.y);\n            dis = dis2;\n        }\n\n        qos = A + (c + b * t.z) * t.z;\n        dis2 = dot(qos - pos,qos);\n        if (dis2 < dis) {\n            res = vec4(qos, t.z);\n        }\n    }\n    \n    return res;\n}\n\n\n// --------------------------------------------------------\n// Trefoil\n//\n// This is a lot of code to create a simple trefoil knot,\n// however the usual method (helix in polar-coordinate space)\n// produces a tube with a lot of distortion in the centre.\n//\n// Instead, I'm constructing it from bezier curves, which have\n// been calculated with a ThreeJS/CanonJS app that finds a\n// 'tight' knot as described in this paper (1), see \n// https://github.com/tdhooper/trefoil-bezier\n//\n// I've reduced the number of individual curves that need to\n// be evaluated, from 15 to 9, by repeating space around\n// the knot's centre and plane. You can see these visualised\n// in the app.\n//\n// (1) Ropelength of tight polygonal knots\n//     Justyna Baranska, Piotr Pieranski, Eric J. Rawdon\n//     https://arxiv.org/abs/physics/0409108\n// --------------------------------------------------------\n\nfloat switchBezier(vec3 p, vec4 a, vec4 b) {\n    return length(p - a.xyz) - length(p - b.xyz);\n}\n\nstruct Curve {\n    vec3 position;\n    vec3 tangent;\n    vec3 normal;\n    vec3 binormal;\n    float t;\n};\n\nstruct CurvePart {\n    vec4 bez;\n    vec3 tangent;\n    vec3 normal;\n    float offset;\n};\n\n// 14\nvec3 a0 = vec3(-0.5669088543444947, -0.23671635305770958, 0.3195550470325173);\nvec3 b0 = vec3(-0.21879767215820162, -0.40033356387104035, 0.281874024845266);\nvec3 c0 = vec3(0, -0.40033356387104035, 0);\nvec3 aTan0 = vec3(0.9022064407419169, -0.38757768574492396, -0.1892275767334432);\nvec3 cTan0 = vec3(0.613494495153403, 0.0002619034153996805, -0.7896989526541569);\nvec3 aNor0 = vec3(-0.3077045475610546, -0.8858362163188649, 0.34729254133673104);\nvec3 cNor0 = vec3(0.00016067630912024614, -0.9999999657032999, -0.0002068248599310844);\n// 0\nvec3 a1 = vec3(0, -0.40033356387104035, 0);\nvec3 b1 = vec3(0.21879767215820162, -0.40033356387104035, -0.281874024845266);\nvec3 c1 = vec3(0.5669088543444947, -0.23671635305770958, -0.3195550470325173);\nvec3 aTan1 = vec3(0.613494495153403, 0.0002619034153996805, -0.7896989526541569);\nvec3 cTan1 = vec3(0.902206440741908, 0.38757768574494417, -0.18922757673344437);\nvec3 aNor1 = vec3(0.00016067630912024614, -0.9999999657032999, -0.0002068248599310844);\nvec3 cNor1 = vec3(0.307704565929649, -0.8858362318233614, -0.3472924855147808);\n// 1\nvec3 a2 = vec3(0.5669088543444947, -0.23671635305770958, -0.3195550470325173);\nvec3 b2 = vec3(0.9150200365307877, -0.0730991422443788, -0.3572360692197686);\nvec3 c2 = vec3(0.9444049957885698, 0.24455937521789314, -0.1786180346098843);\nvec3 aTan2 = vec3(0.902206440741908, 0.38757768574494417, -0.18922757673344437);\nvec3 cTan2 = vec3(0.14311311393143017, 0.8728591195545045, 0.4665143020652047);\nvec3 aNor2 = vec3(0.307704565929649, -0.8858362318233614, -0.3472924855147808);\nvec3 cNor2 = vec3(0.9651563914319037, -0.018749617671540965, -0.2610011339349261);\n// 5\nvec3 a3 = vec3(-0.34669903629988125, 0.20016678193552043, 0);\nvec3 b3 = vec3(-0.4560978723789819, 0.010682439557619071, -0.281874024845266);\nvec3 c3 = vec3(-0.48845680241143064, -0.3725992929638091, -0.3195550470325173);\nvec3 aTan3 = vec3(-0.3067472913765029, -0.531301816894778, -0.7896989797368913);\nvec3 cTan3 = vec3(-0.11545113752095092, -0.9751225133799538, -0.1892276902165235);\nvec3 aNor3 = vec3(-0.8660198797752173, 0.500009567669747, -0.000008534097960699594);\nvec3 cNor3 = vec3(-0.9210193666153568, 0.17643446721607253, -0.3472667635948305);\n// 6\nvec3 a4 = vec3(-0.48845680241143064, -0.3725992929638091, -0.3195550470325173);\nvec3 b4 = vec3(-0.5208157324438795, -0.7558810254852374, -0.3572360692197686);\nvec3 c4 = vec3(-0.2604078662219397, -0.940158405422784, -0.1786180346098843);\nvec3 aTan4 = vec3(-0.11545113752095092, -0.9751225133799538, -0.1892276902165235);\nvec3 cTan4 = vec3(0.6843619980972525, -0.5603684330860392, 0.4665146029451097);\nvec3 aNor4 = vec3(-0.9210193666153568, 0.17643446721607253, -0.3472667635948305);\nvec3 cNor4 = vec3(-0.49883011384191744, -0.8264741169516885, -0.26097710921340667);\n// 7\nvec3 a5 = vec3(-0.2604078662219397, -0.940158405422784, -0.1786180346098843);\nvec3 b5 = vec3(1.377036685388269e-16, -1.1244357853603304, 0);\nvec3 c5 = vec3(0.26040786622193884, -0.9401584054227843, 0.1786180346098843);\nvec3 aTan5 = vec3(0.6843619980972525, -0.5603684330860392, 0.4665146029451097);\nvec3 cTan5 = vec3(0.684361998097279, 0.5603684330859919, 0.4665146029451278);\nvec3 aNor5 = vec3(-0.49883011384191744, -0.8264741169516885, -0.26097710921340667);\nvec3 cNor5 = vec3(0.4988300815201652, -0.8264741202403052, 0.2609771605784677);\n// 8\nvec3 a6 = vec3(0.26040786622193884, -0.9401584054227843, 0.1786180346098843);\nvec3 b6 = vec3(0.5208157324438776, -0.7558810254852383, 0.3572360692197686);\nvec3 c6 = vec3(0.4884568024114297, -0.37259929296381017, 0.3195550470325173);\nvec3 aTan6 = vec3(0.684361998097279, 0.5603684330859919, 0.4665146029451278);\nvec3 cTan6 = vec3(-0.1154511375209849, 0.9751225133799435, -0.18922769021655528);\nvec3 aNor6 = vec3(0.4988300815201652, -0.8264741202403052, 0.2609771605784677);\nvec3 cNor6 = vec3(0.9210193440053495, 0.17643447537181506, 0.34726681941733095);\n// 9\nvec3 a7 = vec3(0.4884568024114297, -0.37259929296381006, 0.3195550470325173);\nvec3 b7 = vec3(0.4560978723789819, 0.010682439557618061, 0.281874024845266);\nvec3 c7 = vec3(0.34669903629988125, 0.2001667819355199, 0);\nvec3 aTan7 = vec3(-0.1154511375209849, 0.9751225133799435, -0.18922769021655528);\nvec3 cTan7 = vec3(-0.30674729137653417, 0.5313018168947605, -0.7896989797368906);\nvec3 aNor7 = vec3(0.9210193440053495, 0.17643447537181506, 0.34726681941733095);\nvec3 cNor7 = vec3(0.8660198557765797, 0.5000096092349068, 0.000008571384490341227);\n// 10\nvec3 a8 = vec3(0.34669903629988125, 0.2001667819355199, 0);\nvec3 b8 = vec3(0.23730020022078058, 0.38965112431342175, -0.281874024845266);\nvec3 c8 = vec3(-0.07845205193306419, 0.6093156460215194, -0.3195550470325173);\nvec3 aTan8 = vec3(-0.30674729137653417, 0.5313018168947605, -0.7896989797368906);\nvec3 cTan8 = vec3(-0.7867551988977671, 0.5875449230132569, -0.1892279589507877);\nvec3 aNor8 = vec3(0.8660198557765797, 0.5000096092349068, 0.000008571384490341227);\nvec3 cNor8 = vec3(0.6133085148535106, 0.709419711040007, -0.34724103904362313);\n\nfloat sepa;\nfloat sepR = 0.465;\n\n// Curve closest to the center\nCurvePart bezierInner(vec3 p) {\n    vec4 bez, bezPart;\n    vec3 a, b, c,\n        aTan, cTan, aNor, cNor,\n        tan, nor;\n    float offset;\n\n    a = a0;\n    b = b0;\n    c = c0;\n    aTan = aTan0;\n    cTan = cTan0;\n    aNor = aNor0;\n    cNor = cNor0;\n    bezPart = bezierPoint(a, b, c, p);\n    bez = bezPart;\n    tan = mix(aTan, cTan, bez.w);\n    nor = mix(aNor, cNor, bez.w);\n    offset = 0.;\n\n    a = a1;\n    b = b1;\n    c = c1;\n    aTan = aTan1;\n    cTan = cTan1;\n    aNor = aNor1;\n    cNor = cNor1;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 1.;\n    }\n\n    a = a2;\n    b = b2;\n    c = c2;\n    aTan = aTan2;\n    cTan = cTan2;\n    aNor = aNor2;\n    cNor = cNor2;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 2.;\n    }\n\n    sepa = length(p - bez.xyz) - sepR;\n\n    return CurvePart(\n        bez,\n        tan,\n        nor,\n        offset\n    );\n}\n\n// Curve that loops around the outside\nCurvePart bezierOuter(vec3 p) {\n    vec4 bez, bezPart;\n    vec3 a, b, c,\n        aTan, cTan, aNor, cNor,\n        tan, nor;\n    float offset;\n\n    a = a3;\n    b = b3;\n    c = c3;\n    aTan = aTan3;\n    cTan = cTan3;\n    aNor = aNor3;\n    cNor = cNor3;\n    bezPart = bezierPoint(a, b, c, p);\n    bez = bezPart;\n    tan = mix(aTan, cTan, bez.w);\n    nor = mix(aNor, cNor, bez.w);\n    offset = 0.;\n\n    a = a4;\n    b = b4;\n    c = c4;\n    aTan = aTan4;\n    cTan = cTan4;\n    aNor = aNor4;\n    cNor = cNor4;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 1.;\n    }\n\n    float sepd = length(p - bez.xyz) - sepR;\n\n\n    a = a5;\n    b = b5;\n    c = c5;\n    aTan = aTan5;\n    cTan = cTan5;\n    aNor = aNor5;\n    cNor = cNor5;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 2.;\n    }\n\n    a = a6;\n    b = b6;\n    c = c6;\n    aTan = aTan6;\n    cTan = cTan6;\n    aNor = aNor6;\n    cNor = cNor6;\n    bezPart = bezierPoint(a, b, c, p);\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 3.;\n    }\n\n    float sepc = 1e12;\n\n    a = a7;\n    b = b7;\n    c = c7;\n    aTan = aTan7;\n    cTan = cTan7;\n    aNor = aNor7;\n    cNor = cNor7;\n    bezPart = bezierPoint(a, b, c, p);\n\n    sepc = min(sepc, length(p - bezPart.xyz) - sepR);\n\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 4.;\n    }\n\n    a = a8;\n    b = b8;\n    c = c8;\n    aTan = aTan8;\n    cTan = cTan8;\n    aNor = aNor8;\n    cNor = cNor8;\n    bezPart = bezierPoint(a, b, c, p);\n\n    sepc = min(sepc, length(p - bezPart.xyz) - sepR);\n\n    if (switchBezier(p, bez, bezPart) > 0.) {\n        bez = bezPart;\n        tan = mix(aTan, cTan, bez.w);\n        nor = mix(aNor, cNor, bez.w);\n        offset = 5.;\n    }\n\n    float sepb = length(p - bez.xyz) - sepR;\n    sepa = max(sepa, sepb);\n    sepc = max(sepc, sepd);\n    sepa = min(sepa, sepc);\n\n    return CurvePart(\n        bez,\n        tan,\n        nor,\n        offset + 6.\n    );\n}\n\nCurve TrefoilCurve(vec3 p) {\n\n    vec4 bez, bezPart;\n    \n    float side = 0.;\n    float tFlip = 1.;\n\n    float cell = 0.;\n\n    float repetitions = 3.;\n    float angle = TAU / repetitions;\n\n\n    if (p.z > 0.) {\n        p.z *= -1.;\n        p.y *= -1.;\n        pR(p.xy, angle / -2.);\n        side = 1.;\n        tFlip = -1.;\n    }\n    pR(p.xy, angle / -2.);\n    cell = pModPolar(p.xy, repetitions);\n    pR(p.xy, angle / 2.);\n\n    float outer = 0.;\n\n    CurvePart curve = bezierInner(p);\n    CurvePart outerCurve = bezierOuter(p);\n\n    if (switchBezier(p, curve.bez, outerCurve.bez) > 0.) {\n        outer = 1.;\n        curve = outerCurve;\n    }\n\n    float an = cell * angle;\n\n    mat3 m = mat3(\n        cos(an), -sin(an), 0,\n        sin(an), cos(an), 0,\n        0, 0, 1\n    );\n\n    mat3 m2 = mat3(\n        cos(angle / -2.), -sin(angle / -2.), 0,\n        sin(angle / -2.), cos(angle / -2.), 0,\n        0,0,-1\n    );\n    mat3 m3 = mat3(1,0,0,0,-1,0,0,0,1);\n\n    if (side > 0.) {\n        m = m * m2 * m3;\n    }\n\n    float parts = 24.;\n\n    float sectionCurveOffset;\n\n    vec3 tangent = curve.tangent;\n    vec3 normal = curve.normal;\n    vec3 binormal = cross(tangent, normal);\n\n    normal *= -1.;\n\n    if (side > 0.) {\n        binormal *= -1.;\n    }\n\n    tangent = normalize(tangent);\n    binormal = normalize(binormal);\n    normal = normalize(normal);\n\n    float flip = -1. + side * 2.;\n    cell = mod(cell * flip, 3.);\n    float offset = cell * 5. + side * 7.;\n    float t = (offset - (curve.bez.w + curve.offset) * flip);\n    t = mod(t / 15., 1.);\n\n    vec3 position = curve.bez.xyz;\n\n    return Curve(\n        position * m,\n        curve.tangent * m,\n        normal * m,\n        binormal * m,\n        t\n    );\n}\n\nvoid pModTrefoil(inout vec3 p, float len) {\n    Curve curve = TrefoilCurve(p);\n    float x = dot(p - curve.position, curve.normal);\n    float y = dot(p - curve.position, curve.binormal);\n    float z = curve.t;\n    p = vec3(x, y, z);\n    p.z -= 0.0666;\n    p.z *= len;\n}\n\n\n// --------------------------------------------------------\n// Materials, well, actually just colours\n// --------------------------------------------------------\n\nvec3 TRAIN_MAT = vec3(.9,.5,.5);\nvec3 CHANNEL_MAT = vec3(.15);\nvec3 SLEEPER_MAT = vec3(.2);\nvec3 RAIL_MAT = vec3(.25);\nvec3 PLATFORM_MAT = vec3(.5);\nvec3 MIND_THE_GAP_MAT = vec3(1.,1.,0.);\n\nvec3 TRAIN_RED = vec3(1,.025,.125);\nvec3 TRAIN_GREY = vec3(.4);\nvec3 TRAIN_ROOF = vec3(.6);\nvec3 TRAIN_WINDOW = vec3(.5,.9,1.);\nvec3 TRAIN_WHITE = vec3(1);\nvec3 TRAIN_BLUE = vec3(0,0,.7);\nvec3 TRAIN_UNDERCARRIDGE = vec3(.1);\n\nvec3 STAIR_BASE_MAT = vec3(.1);\nvec3 STEP_MAT = vec3(.3);\nvec3 STEP_TOP_MAT = vec3(.5);\nvec3 STEP_YELLOW_MAT = vec3(1.,1.,0.);\nvec3 HANDRAIL_MAT = vec3(.7);\n\n\n// --------------------------------------------------------\n// Model\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 material;\n    vec2 uv;\n    float underStep;\n    int id;\n};\n\nModel opU(Model a, Model b) {\n    if (a.dist < b.dist) {\n        return a;\n    }\n    return b;\n}\n\nModel mTrain(vec3 p, float width, float height, float index) {\n    p.z *= -1.;\n\n    float d = 1e12;\n    float len = 1.2;\n\n    vec3 pp = p;\n\n    p /= height * 4.;\n    p.y *= sign(p.x);\n    p.y -= mix(.75, .25, sign(p.x) * .5 + .5);\n    p.z += (index - 1.) * len * 4.;\n    vec2 uv = p.zy;\n\n    p = pp;\n    p.x = abs(p.x);\n    pp = p;\n\n    float isFront = max(0., sign(p.z));\n    float frontWidth = .12;\n    float backWidth = .08;\n    float innerLength = (len * 2.) - backWidth * 2.;\n    float frontDoorOffset = frontWidth - backWidth;\n\n    d = p.x - width;\n\n    // Slanted side\n    p.xy -= vec2(width, height * .45);\n    d = max(d, dot(p.xy, normalize(vec2(1.,-.175))));\n    p = pp;\n\n    // Round top\n    float topRadius = width * 1.1;\n    p.y += height - topRadius;\n    float top = length(p.xy) - topRadius;\n    top = min(top, -p.y);\n    d = smax(d, top, .005);\n    p = pp;\n\n    // Blue bar\n    float blueStripe = step(0., p.y - height + .03);\n    vec3 color = mix(TRAIN_WHITE, TRAIN_BLUE, blueStripe);\n\n    float form = d;\n    float thinOffset = .025;\n    float thin = form + thinOffset;\n    d = thin;\n\n    // Roof setup\n    float roofPane = p.y + height * .8;\n\n    // Carridge setup\n    float carridgeCrop = max(-p.z - innerLength / 2., p.z - innerLength / 2. + frontDoorOffset);\n    d = smax(d, carridgeCrop, .01);\n\n    // Side doors\n    float sideDoorWidth = .17 / 2.;\n    float spacing = innerLength / 3.;\n    p.z -= spacing / 2.;\n    float cell = pMod1(p.z, spacing);\n    float isFrontDoor = max(0., cell);\n    p.z += frontDoorOffset * isFrontDoor;\n    p.z = abs(p.z);\n    p.z -= sideDoorWidth - .001;\n    float sideDoorMask = fBox2(p.yz, vec2(1., sideDoorWidth));\n    float sideDoors = smax(form, sideDoorMask, thinOffset * 1.5);\n    sideDoors = smax(sideDoors, -roofPane, .01);\n    sideDoors = max(sideDoors, carridgeCrop);\n    float sideDoorEdge = sideDoorMask + .01;\n    vec3 sideDoorColor = mix(TRAIN_RED, TRAIN_WHITE, isFrontDoor);\n    sideDoorColor = mix(sideDoorColor, TRAIN_BLUE, blueStripe * isFrontDoor);\n    float windowFrameOffset = .007;\n    p.y += .028;\n    p.z += .025;\n    float sideDoorWindow = fBox2(p.yz, vec2(height * .42, sideDoorWidth * .3)) - .005;\n    sideDoorColor = mix(sideDoorColor, TRAIN_WINDOW, 1. - step(0., sideDoorWindow));\n    p = pp;\n    color = mix(color, sideDoorColor, step(0., d - sideDoors));\n    d = min(d, sideDoors);\n    p = pp;\n\n    // Side windows\n    p.y = abs(p.y);\n    float sideWindow = p.y - .04;\n    sideWindow = smax(sideWindow, -sideDoorMask + windowFrameOffset * 2., .01);\n    pMod1(p.z, spacing);\n    p.z = abs(p.z);\n    sideWindow = smax(sideWindow, -(p.z - windowFrameOffset * 2.), .01);\n    color = mix(color, TRAIN_WINDOW, 1. - step(0., sideWindow));\n    p = pp;\n\n    // Roof\n    float roof = smax(form, roofPane, .01);\n    roof = smax(roof, carridgeCrop, .01);\n    color = mix(color, TRAIN_ROOF, step(0., d - roof));\n    d = min(d, roof);\n\n    // Front\n\n    p.z = abs(p.z);\n    p.z -= len;\n    float frontRadius = width * 3.;\n    float endcap = length(p.xz + vec2(0,frontRadius)) - frontRadius;\n    endcap *= .5;\n    p = pp;\n\n    p.z -= len;\n    float front = smax(form, endcap, .03);\n    front = smax(front, -(p.z + frontWidth), .01);\n    color = mix(color, TRAIN_RED, step(0., d - front));\n    d = min(d, front);\n    p = pp;\n\n    // Back\n    p.z += len;\n    float back = smax(form, endcap, .03);\n    back = smax(back, (p.z - backWidth), .01);\n    vec3 backColor = mix(TRAIN_WHITE, TRAIN_BLUE, blueStripe);\n    color = mix(color, backColor, step(0., d - back));\n    d = min(d, back);\n    p = pp;\n\n    // Front grey\n    p.z = abs(p.z);\n    p.z -= len - .05;\n    float grey = form + .01;\n    grey = max(grey, -p.z);\n    p.y -= height * .48;\n    p.x -= width * .3;\n    if (isFront > 0.) {\n        grey = smax(grey, dot(p.xy, normalize(vec2(.3,1))), .02);\n        grey = max(grey, p.y);\n    }\n    color = mix(color, TRAIN_GREY, step(0., d - grey));\n    p = pp;\n\n    // Front door\n    vec2 doorWH = vec2(width * .22, height * 1.7);\n    vec2 doorXY = vec2(0, height);\n\n    // - Inset\n    p.z = abs(p.z);\n    p.xy -= doorXY;\n    p.z -= len;\n    d = smax(d, -fBox(p, vec3(doorWH, .01)), .01);\n\n    // - Template\n    float door = fBox2(p.xy, doorWH);\n    p = pp;\n\n    // Window\n    float windowBottom = mix(.02, -.01, isFront);\n    float windowOffset = .0125;\n    float window = max(door + windowOffset, p.y - windowBottom);\n    p = pp;\n\n    float window2Offset = .02;\n    float window2 = max(-door + window2Offset, p.y - .02);\n    p.xy -= vec2(doorWH.x + window2Offset, windowBottom + .01);\n    window2 = max(window2, dot(p.xy, normalize(vec2(-.7,1))));\n\n    p = pp;\n    window2 = max(window2, -(p.y + doorWH.y - doorXY.y - windowOffset + .005));\n    window2 = smax(window2, grey + .02, .01);\n    window = min(window, window2);\n    color = mix(color, TRAIN_WINDOW, 1.-step(0., window));\n\n    // Undercarridge\n\n    float baseHeight = .025;\n    p.y -= height;\n    d = smax(d, p.y, 0.);\n\n    p.y -= baseHeight / 2.;\n    float undercarridge = fBox2(p.xy, vec2(width - baseHeight, baseHeight / 2.));\n    p.z = abs(p.z);\n    undercarridge = max(undercarridge, endcap);\n    color = mix(color, TRAIN_UNDERCARRIDGE, step(0., d - undercarridge));\n    d = min(d, undercarridge);\n    p = pp;\n\n    Model train = Model(d, color, uv, .2, 1);\n    return train;\n}\n\nbool pastThreshold = false;\nfloat lastSide = 1.;\n\nModel mTrainSide(vec3 p, float curveLen, float radius) {\n    \n    vec3 pp = p;\n    float d = 1e12;\n    vec3 color = CHANNEL_MAT;\n\n    float trainSize = .175;\n\n    // Impossible Channel\n    // Carves through beyond the other side of a thi turface,\n    // as if it had depth.\n\n    p.x = abs(p.x);\n    d = -p.y - .001;\n\n    float threshold = fBox2(p.xy + vec2(0,.003), vec2(radius, .002));\n    float side = sign(threshold);\n    if (side != lastSide) {\n        pastThreshold = true;\n    }\n    lastSide = side;\n\n    float gap = .01;\n    float channelWidth = trainSize + gap;\n    float channelDepth = .09;\n\n    if (pastThreshold) {\n        float cut = fBox2(p.xy, vec2(channelWidth, channelDepth));\n        d = max(d, -cut);\n    }\n\n    // Platform\n\n    p.x = abs(p.x);\n    p.x -= radius;\n    float platform = fBox2(p.xy, vec2(radius - channelWidth,.005)) - .005;\n    color = mix(color, PLATFORM_MAT, step(0., d - platform));\n    d = min(d, platform);\n    p = pp;\n\n    p.x = abs(p.x);\n    p.x -= mix(radius, channelWidth, .5);\n    pMod1(p.z, curveLen * 2./3. / 10.);\n    float mindTheGap = fBox2(p.xz, vec2(0., .125)) - .015;\n    color = mix(color, MIND_THE_GAP_MAT, 1. - step(0., mindTheGap));\n    p = pp;\n\n\n    // Sleepers\n\n    p.x = abs(p.x);\n    float sleeperSize = curveLen / 80.;\n    float sleeperHeight = .02;\n    pMod1(p.z, sleeperSize);\n    p.y -= channelDepth;\n    float sleepers = fBox(p, vec3(channelWidth * .66, sleeperHeight, sleeperSize / 4.));\n    color = mix(color, SLEEPER_MAT, step(0., d - sleepers));\n    d = min(d, sleepers);\n    p = pp;\n\n\n    // Rails\n\n    p.x = abs(p.x);\n    float railHeight = .01;\n    p.x = abs(p.x);\n    p.x -= channelWidth * .4;\n    p.y -= channelDepth - sleeperHeight - railHeight;\n    float rail = fBox2(p.xy, vec2(railHeight));\n    color = mix(color, RAIL_MAT, step(0., d - rail));\n    d = min(d, rail);\n    p = pp;\n\n\n    Model track = Model(d, color, vec2(0), 0., 2);\n\n    p.z += curveLen * .14;\n    p.z += time * (curveLen * 5. / 6.);\n    float c = floor(p.z / curveLen * 2. + .5);\n    c = mod(c, 2.);\n    if (time > .85) {\n        c += 1.;\n    }\n    pMod1(p.z, curveLen / 2.);\n    float trainHeight = trainSize * .8;\n    p.y += trainHeight;\n    Model train = mTrain(p, trainSize, trainHeight, c);\n    p = pp;\n\n    Model model = opU(track, train);\n\n    if ( ! pastThreshold) {\n        model.dist = max(model.dist, p.y);\n    }\n\n    return model;\n}\n\nModel mStairSide(vec3 p, float curveLen, float radius) {\n    vec3 pp = p;\n    float d = p.y;\n\n    float stairSize = curveLen / 60.;\n    p.z += time * stairSize * 2. * -3.;\n\n    pMod1(p.z, stairSize);\n\n    float stairRadius = stairSize * .9;\n    float handrailWidth = .1;\n    float stairWidth = radius - handrailWidth;\n\n    vec3 color = STAIR_BASE_MAT;\n\n    // Step\n    p.z -= stairSize / 2.;\n    pp = p;\n    pR(p.yz, (30./180.) * PI);\n    float steps = length(p.yz) - stairRadius;\n    steps = smax(steps, p.y, .02);\n    vec3 stepColor = STEP_TOP_MAT;\n\n    float warning = -fBox2(p.xz, vec2(stairWidth - .01, stairRadius - .02));\n    warning = -(abs(p.z) - stairRadius + .025);\n    stepColor = mix(stepColor, STEP_YELLOW_MAT, 1.-step(0., warning));\n\n    p.y += .01;\n    vec3 edgeColor = mix(STAIR_BASE_MAT, STEP_MAT, smoothstep(stairRadius * -.6, 0., p.y));\n    stepColor = mix(stepColor, edgeColor, 1.-step(0., p.y));\n    p = pp;\n\n    // Dummy\n    p.z -= stairSize;\n    steps = min(steps, length(p.yz) - stairRadius);\n\n    // Limit width\n    steps = max(steps, p.x - stairWidth);\n\n    color = mix(color, stepColor, step(0., d - steps));\n    d = min(d, steps);\n    p = pp;\n\n    p.x -= radius;\n    float handrailHeight = .14;\n    float handrail = fBox2(p.xy, vec2(handrailWidth, handrailHeight));\n    vec3 handrailColor = mix(STAIR_BASE_MAT, HANDRAIL_MAT, smoothstep(0., handrailHeight * 2., p.y));\n    handrailColor = mix(handrailColor, HANDRAIL_MAT, step(0., p.x + handrailWidth * .75));\n    color = mix(color, handrailColor, step(0., d - handrail));\n    d = min(d, handrail);\n    p = pp;\n\n    d = max(d, -p.y);\n    return Model(d, color, vec2(0), .2, 3);\n}\n\nbool AO_PASS = false;\n\nModel fModel(vec3 p) {\n\n    float curveLen = 14.;\n    pModTrefoil(p, curveLen);\n    pR(p.xy, -time * PI * 2.);\n\n    float radius = .28;\n    float outer = length(p.xy) - radius;\n    float eps = .02;\n\n    // Overstep can happen when we're past one part of the curve,\n    // but still moving torards another part. Avoid this by stepping\n    // to the inside edge of the curve tube\n    float d = -outer + eps * 2.;\n\n    // Don't model the whole train/track/stairs when we're outside the trefoil\n    if ( ! AO_PASS) {\n        if (outer > eps) {\n            return Model(outer, vec3(.2), vec2(0), 0., 0);\n        }\n    } else {\n        // Disable the shortcut and overstep hack\n        // when calculating ambient occlusion\n        d = 1e12;\n    }\n\n    p.y -= .05;\n    Model model = mTrainSide(p, curveLen, radius);\n    p.x = abs(p.x);\n\n    // Don't model the stars when we're in the 'impossible channel'\n    // that the tracks carve\n    if ( ! pastThreshold) {\n        Model stair = mStairSide(p, curveLen, radius);\n        model = opU(model, stair);\n    }\n\n    // Cut the geometry to remain inside the trefoil tube\n    model.dist = max(model.dist, outer);\n\n    // Apply the overstep hack\n    model.dist = min(model.dist, d);\n\n    return model;\n}\n\nfloat focalLength;\n\nModel map(vec3 p) {\n    pR(p.xy, .39 * PI * 2. + time * PI * 2. * 2./3.);\n\n    float scale = focalLength;\n    p *= scale;\n    Model model = fModel(p);\n    model.dist /= scale;\n    return model;\n}\n\n\n// --------------------------------------------------------\n// NOVA graffiti\n// --------------------------------------------------------\n\nfloat fNova(vec2 p, float weight) {\n\n    float d = 1e12;\n    vec2 p2 = p;\n    vec2 p3 = p;\n    float arrow;\n\n    // N\n    p3 = p;\n    d = min(d, fBoxy(p, vec2(.6, .5)));\n    p.x -= .1;\n    pR45(p);\n    d = max(d, fBoxy(p, vec2(1., .6)));\n    p = p3;\n    p.x += .03;\n    d = max(d, -fBoxy(p - vec2(.2, .5), vec2(weight/2.,.6)));\n    d = max(d, -fBoxy(p + vec2(.2, .5), vec2(weight/2.,.6)));\n    p = p2;\n\n    // O\n    p.x -= .9;\n    p2 = p;\n    float O = fBoxy(p, vec2(.5,.6));\n    pR45(p);\n    O = max(O, vmax(abs(p)) - .55);\n    O = max(O, -d + weight);\n    d = min(d, O);\n    p = p2;\n\n    p += vec2(.25,-.2);\n    p3 = p;\n    p.y *= 1.25;\n    pR45(p);\n    arrow = vmax(p);\n    p = p3;\n    arrow = max(arrow, fBoxy(p, vec2(.1, 1.)));\n    d = max(d, -arrow + weight);\n    d = min(d, arrow);\n    p = p2;\n    d = min(d, fBoxy(p - vec2(-.1,-.4), vec2(.25,.15)));\n    d = max(d, -p.y - .5);\n\n    // V\n    p.x -= .8;\n    p2 = p;\n    p.y += .95;\n    p.x = abs(p.x);\n    pR(p, -.42);\n    float V = p.x;\n    p = p2;\n    V = max(V, abs(p.y) - .6);\n    p.y -= .6;\n    p.x -= .025;\n    V = max(V, -fBoxy(p, vec2(weight/2., .75)));\n    p = p2;\n    p.x -= .075;\n    p.y -= .3;\n    V = max(V, -vmax(p * vec2(1,-1)));\n    d = max(d, -V + weight);\n    d = min(d, V);\n    p = p2;\n\n    // A\n    p.x -= .75;\n    p2 = p;\n    p.y += .1;\n    float A = fBoxy(p, vec2(.45, .4));\n    p = p2;\n    A = max(A, -V + weight);\n    d = min(d, A);\n    p = p2;\n\n    p -= vec2(-.3, .2);\n    arrow = abs(p.y) - .125;\n    p.y -= .05;\n    pR45(p);\n    pR(p, -.3);\n    arrow = max(arrow, -p.x * 1.5);\n    d = max(d, -arrow + weight);\n    d = min(d, arrow);\n    p = p2;\n    p.x -= .3;\n    d = min(d, fBoxy(p, vec2(.15, .3)));\n    p = p2;\n    d = max(d, p.x- .45);\n    pR45(p);\n    d = max(d, p.x - .43);\n\n    p = p2;\n    d = max(d, -fBoxy(p + vec2(-.05,.23), vec2(.1, weight/2.)));\n\n    return d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    float rayLength;\n    vec3 rayDirection;\n};\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    AO_PASS = true;\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 drawNova(vec3 col, vec2 uv) {\n    float scale = .3;\n    uv *= -1.;\n    uv /= scale;\n    uv.y -= .5;\n    uv.x /= 1.4;\n    uv.x += 1.2;\n\n    vec2 uv2 = uv;\n    pR(uv2, PI * .25);\n    vec2 warp = sin((uv2 + .25 + time) * 5.) * .1;\n    uv += warp;\n\n    float d = fNova(uv, .133);\n    float dOffset = fNova(uv - vec2(.05,-.1), .133);\n\n    d *= scale;\n    dOffset *= scale;\n\n    col = mix(col, vec3(.3), smoothstep(.005, .0, d - .02));\n    col = mix(col, vec3(.0), smoothstep(.005, .0, dOffset + .01));\n\n    // Outline\n    d = max(d - .04, -d + .01);\n    col = mix(col, TRAIN_WHITE, smoothstep(.005, .0, d));\n\n    return col;\n}\n\nvec3 render(Hit hit, vec3 col) {\n    if ( ! hit.isBackground) {\n        float ao = calcAO(hit.pos, hit.normal);\n        col = hit.model.material;\n\n        if (hit.model.id == 1) {\n            col = drawNova(col, hit.model.uv);\n        }\n\n        vec3 diffuse = mix(vec3(.5,.5,.6) * 1., vec3(1), ao);\n        col *= diffuse;\n    }\n    return col;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 3.;\nconst float INTERSECTION_PRECISION = .0001;\nconst int NUM_OF_TRACE_STEPS = 150;\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - model.underStep);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(\n        model,\n        pos,\n        isBackground,\n        normal,\n        rayOrigin,\n        rayLength,\n        rayDirection\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nfloat backgroundMap(vec2 uv) {\n    float scale = 1.5;\n    float repeat = 3.55;\n\n    uv.y *= -1.;\n    uv /= scale;\n\n    vec2 uv2 = uv;\n    uv.x += time * repeat;\n    vec2 uv3 = uv;\n\n    pMod1(uv.x, repeat);\n    uv.x += 1.2;\n\n    pR(uv3, PI * .5);\n    uv3 -= time * repeat;\n\n    vec2 warp = vec2(0);\n    warp += sin((uv3 / repeat * PI * 1.) * 2.) * .2;\n    warp *= sin(uv2.x * PI * 1.5 + PI / 2.) * .5 + .5;\n    warp += sin(uv2 * PI + PI / 2.) * .1;\n\n    uv += warp;\n\n    float d = fNova(uv, .06) * scale;\n\n    return smoothstep(-0.01, .0, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = iTime;\n    time *= .25;\n    time = mod(time, 1.);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    p.y *= -1.; // Last minute adjustment, put the train on top\n    p.y -= .03;\n\n    vec3 camPos = vec3(-1.,0,.25) * .95;\n    vec3 camTar = vec3(0,-.0025,0);\n    vec3 camUp = vec3(0,0,1);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    focalLength = 18.191446;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 bg = mix(vec3(1), TRAIN_WINDOW, 1. - backgroundMap(p));\n\n    Hit hit = raymarch(camPos, rayDirection);\n    vec3 color = render(hit, bg);\n\n    color = pow(color, vec3(1.,.9,.8)); // Brighten and tint a little blue\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n\n    fragColor = vec4(color,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[14, 286, 318, 318, 363], [365, 365, 390, 390, 433], [435, 435, 475, 475, 608], [610, 610, 660, 660, 1080], [1082, 1082, 1102, 1102, 1130], [1132, 1132, 1152, 1152, 1190], [1192, 1192, 1220, 1220, 1307], [1309, 1309, 1338, 1338, 1425], [1427, 1475, 1504, 1504, 1535], [1537, 1537, 1576, 1576, 1667], [1669, 1669, 1708, 1708, 1800], [1802, 1802, 1832, 1832, 1861], [1863, 1863, 1893, 1893, 1922], [1925, 2167, 2219, 2219, 3628], [3631, 4514, 4558, 4558, 4610], [9817, 9848, 9879, 9879, 11006], [11008, 11047, 11078, 11078, 13443], [13445, 13445, 13473, 13473, 15153], [15155, 15155, 15198, 15198, 15424], [16165, 16395, 16424, 16424, 16491], [16493, 16493, 16555, 16555, 21798], [21850, 21850, 21906, 21906, 24238], [24240, 24240, 24296, 24296, 25897], [25922, 25922, 25944, 25944, 27163], [27185, 27185, 27204, 27204, 27380], [27383, 27521, 27556, 27556, 29377], [29666, 29707, 29749, 29749, 30070], [30072, 30072, 30106, 30106, 30698], [30700, 30700, 30732, 30732, 31047], [31050, 31388, 31414, 31414, 31678], [31680, 31680, 31728, 31728, 32560], [32562, 32562, 32612, 32612, 32755], [32757, 32757, 32787, 32787, 33300], [33302, 33302, 33357, 33357, 34134]]}
{"id": "ldKfDm", "name": "Art : Recamán's sequence", "author": "Gijs", "description": "Recamán's sequence", "tags": ["recamnssequence"], "likes": 8, "viewed": 138, "date": "1529237871", "time_retrieved": "2024-06-20T19:15:21.088239", "image_code": "const int N = 70;\nconst int S[N] = int[N](0 , 1 , 3 , 6 , 2  , 7 , 13 , 20 , 12 , 21 , \n                        11, 22, 10, 23, 9  , 24, 8  , 25 , 43 , 62 ,\n                        42, 63, 41, 18, 42 , 17, 43 , 16 , 44 , 15 , \n                        45, 14, 46, 79, 113, 78, 114, 77 , 39 , 78 , \n                        38, 79, 37, 80, 36 , 81, 35 , 82 , 34 , 83 , \n                        33, 84, 32, 85, 31 , 86, 30 , 87 , 29 , 88 , \n                        28, 89, 27, 90, 26 , 91, 157, 224, 156, 225);\n\nfloat semi_circle_dis(vec2 p, vec2 m, float r){\n    float p_dis = abs(distance(p,m)-r);\n    float l_dis = distance(p,m-vec2(r,0));\n    float r_dis = distance(p,m+vec2(r,0));\n    if(p.y>m.y) return p_dis;\n    return min(l_dis,r_dis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 sp = ((fragCoord*2.-vec2(0,iResolution.y))/iResolution.y)*(cos(iTime*.5)+1.1)*30.;\n    float MinRes = min(iResolution.y,iResolution.x);\n\tfloat  LineEpsilon =  30./MinRes;\n    float dis = 1e20;\n    \n    for(int i=0;i<N-1;i++){\n        vec2  mp = vec2(float(S[i]+S[i+1])*.5,0);\n        float r =  float(abs(S[i]-S[i+1]))*.5;\n        dis = min(\n            dis,\n            semi_circle_dis(\n                bool(i&1) ? sp : sp*vec2(1,-1),\n                mp,\n                r\n            )\n        );\n        \n    }\n   fragColor += smoothstep(1.,0.,LineEpsilon/dis);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[508, 508, 555, 555, 742], [744, 744, 800, 800, 1376]]}
{"id": "ldKfDw", "name": "floral2", "author": "lennyjpg", "description": "fasdfasdfas", "tags": ["asdfasd"], "likes": 1, "viewed": 350, "date": "1529157733", "time_retrieved": "2024-06-20T19:15:21.088239", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy,\n    f = (uv - 0.5) * 2.5;\n    f.x *= iResolution.x/iResolution.y;\n    float angle = atan(f.x,f.y),\n     t = iTime * .3,\n     d = length(f) - t;\n    float r = sin(fract(cos(d*3.7))*10.);  \n    float c = smoothstep(r-.3, r+.3, cos(angle*5.));\n    O = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 49, 49, 349]]}
{"id": "ldKfWy", "name": "Fireplace", "author": "_polymath", "description": "I feel like you probably are expected to do a fire one?", "tags": ["fire"], "likes": 2, "viewed": 408, "date": "1530355792", "time_retrieved": "2024-06-20T19:15:21.088239", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float flameWidth = 0.06,\n        numberOfFlames = 500.0,\n        swayAmount = 0.4,\n        swaySpeed = 0.2,\n        moveSpeed = 0.2,\n        patchHeight = 0.4,\n        redness = 2.0,\n        yellowness = 0.8,\n        whiteness= 0.5;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x * 1.4 - 0.4;\n    \n    float h = 0.0;\n    \n    for (float i = 0.0; i < numberOfFlames; ++i) {\n        // how far across is this flame?\n        float xx = mod(i * 744.44, 1.0) * mod(i * 434.64, 1.0);\n        // make them move\n        xx += cos(iTime * 0.4632 * mod(1324.34 * i, 0.2) + 412.523 * i) * moveSpeed;\n        // make them wave from side to side\n        xx += sin(uv.y * swayAmount) * cos(i * 64534.34) * swaySpeed;\n        // combine them all\n        h += max(0.0,\n           (1.0 - uv.y)\n                * (flameWidth - abs(x - xx))\n                 * max(0.0, cos((uv.y - iTime) * (mod(1324.34 * i, 10.5) + patchHeight)))\n        );\n    }  \n    \n    fragColor = vec4(h * redness, h * yellowness, h * whiteness, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1137]]}
{"id": "ldKfz3", "name": "Dancing Molecules", "author": "trickysteady", "description": "WIP", "tags": ["particles"], "likes": 6, "viewed": 549, "date": "1529890076", "time_retrieved": "2024-06-20T19:15:21.088239", "image_code": "// starting from MlSXR1\nprecision highp float;\n\nfloat ball(vec2 p, float fx, float fy, float ax, float ay) \n{\n    float t = iTime * 0.5;\n    vec2 r = vec2(p.x + cos(t * fx) * ax, p.y + sin(t * fy) * ay);\t\n    return 0.05 / length(r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\t\n    p.x\t*= iResolution.x / iResolution.y;\n\n    float col = 0.2;\n    float a = 1.;\n    float b = 2.;\n    float c = 0.1;\n    float d = 0.2;\n    for (int i = 0; i < 10;i++)\n    {\n    \tcol += ball(p, a, b, c, d);\n        a += 0.01;\n        b = tan(a * 4.);\n        c += 0.1;\n        d = tan(c * 4.);\n    }\t\n    fragColor = vec4(col * .94, col * .31, col * .14, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 48, 109, 109, 235], [237, 237, 292, 292, 731]]}
{"id": "ldKfzm", "name": "Pokemon Pikachu 3D", "author": "lzjseed", "description": "Pokemon ball & Pikachu", "tags": ["3d", "celshading", "nintendo", "pikachu", "pokemon", "tooney"], "likes": 8, "viewed": 460, "date": "1528184149", "time_retrieved": "2024-06-20T19:15:21.094306", "image_code": "#define mul(a,b) ((b)*(a))\n#define saturate(a) clamp(a,0.0,1.0)\n\n\nstruct ObjectData\n{\n    float     distance;\n    float     materialId;\n    mat4      world2LocalMatrix;\n};\n\n#define Degree2Raduis(a) ((a) * 3.1415926 / 180.0)\n#define Raduis2Degree(a) ((a) * 180.0 / 3.1415926)\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 p)\n{\n    return vec2(rand(p.xy),rand(p.yx));\n}\n\nfloat SmoothStep_WithPower(float x,float dist,float pownum)\n{\n    return clamp(pow(x / dist,pownum),0.0,1.0);\n}\n\nfloat max2(vec2 a)\n{\n    return max(a.x,a.y);\n}\n\nfloat min2(vec2 a)\n{\n    return min(a.x,a.y);\n}\n\nfloat max3(vec3 a)\n{\n    return max(a.x,max(a.y,a.z));\n}\n\nfloat min3(vec3 a)\n{\n    return min(a.x,min(a.y,a.z));\n}\n\nfloat max4(vec4 a)\n{\n    return max(a.x,max(a.y,max(a.z,a.w)));\n}\n\nfloat min4(vec4 a)\n{\n    return min(a.x,min(a.y,min(a.z,a.w)));\n}\n\nvec3 RGBtoHSV(vec3 arg1)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 P = mix(vec4(arg1.bg, K.wz), vec4(arg1.gb, K.xy), step(arg1.b, arg1.g));\n    vec4 Q = mix(vec4(P.xyw, arg1.r), vec4(arg1.r, P.yzx), step(P.x, arg1.r));\n    float D = Q.x - min(Q.w, Q.y);\n    float E = 1e-10;\n    return vec3(abs(Q.z + (Q.w - Q.y) / (6.0 * D + E)), D / (Q.x + E), Q.x);\n}\n\nvec3 HSVtoRGB(vec3 arg1)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 P = abs(fract(arg1.xxx + K.xyz) * 6.0 - K.www);\n    return arg1.z * mix(K.xxx, clamp(P - K.xxx,0.0,1.0), arg1.y);\n}\n\nvoid sincos(float a,out float si,out float co)\n{\n    si = sin(a);\n    co = cos(a);\n}\n\nmat3 FromQuaternion(vec4 q)\n{\n    mat3 m;\n    vec2 a;\n    sincos(q.w,a.x,a.y);\n\n    m[0] = vec3(a.y + q.x*q.x*(1.0-a.y), q.x*q.y*(1.0-a.y), q.y*a.x);\n    m[1] = vec3(q.x*q.y*(1.0-a.y), a.y + q.y*q.y*(1.0-a.y), -q.x*a.x);\n    m[2] = vec3(-q.y*a.x, q.x*a.x, a.y);\n    \n    return m;\n}\n\nvec3 RotateQuaternion(vec3 p,vec4 q)\n{\n    return mul(FromQuaternion(q),p);\n}\n\nmat3 FromEuler(vec3 ang) \n{   \n    vec2 a1,a2,a3;\n    sincos(Degree2Raduis(ang.x),a1.x,a1.y);\n    sincos(Degree2Raduis(ang.y),a2.x,a2.y);\n    sincos(Degree2Raduis(ang.z),a3.x,a3.y);\n\n    mat3 m;\n    m[0] = vec3(a3.y*a2.y,-a3.x*a2.y,a2.x);\n    m[1] = vec3(a3.x*a1.y + a1.x*a2.x*a3.y,a3.y*a1.y - a1.x*a2.x*a3.x,-a1.x*a2.y);\n    m[2] = vec3(a1.x*a3.x - a1.y*a2.x*a3.y,a3.y*a1.x + a1.y*a2.x*a3.x,a1.y*a2.y);\n    return m;\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang,vec3 scale)\n{   \n    mat3 rot = FromEuler(ang);\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    return mul(rot,p);\n}\n\nvec3 RotateEuler(vec3 p,vec3 ang)\n{\n    return mul(FromEuler(ang),p);\n}\n\nfloat Noise(vec2 v)\n{\n    vec2 i = floor(v);\n    vec2 t = fract(v);\n    vec2 u  = t*t*(3.0-2.0*t);\n\n    return mix(mix(rand(i + vec2(0.0,0.0)),rand(i + vec2(1.0,0.0)),u.x),\n                mix(rand(i + vec2(0.0,1.0)),rand(i + vec2(1.0,1.0)),u.x),\n                u.y);\n}\n\nmat3 SetCamera(vec3 ro,vec3 ta)\n{\n    vec3 rz = normalize(ta - ro);\n    vec3 p = vec3(0.0, 1.0, 0.0);\n    vec3 rx = normalize(cross(rz,p));\n    vec3 ry = normalize(cross(rz,rx));\n\n    return mat3(-rx,ry,rz);\n}\n\n//Union\nfloat OpU(float o1,float o2)\n{\n    return min(o1,o2);\n}\n\n//Smooth Union\nfloat OpSU(float o1,float o2,float k)\n{\n    float h = clamp( 0.5+0.5*(o2-o1) / k, 0.0, 1.0 );\n    return mix( o2, o1, h ) - k*h*(1.0-h);\n}\n\n//Smooth Intersection\nfloat OpSI(float o1,float o2,float k)\n{\n    return -OpSU(-o1,-o2,k);\n}\n\n//subtract\nfloat OpS(float o1,float o2)\n{\n    return max(o1,-o2);\n}\n\n//Intersection\nfloat OpI(float o1,float o2)\n{   \n    return max(o1,o2);\n}\n\n//Union\nvec2 OpU2(vec2 o1,vec2 o2)\n{\n    return o1.x < o2.x ? o1 : o2;\n}\n\nObjectData OpU_OD(ObjectData o1,ObjectData o2)\n{\n    if(o1.distance < o2.distance)\n    {\n        return o1;\n    }\n    return o2;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max3(d),0.0) + length(max(d,0.0));\n}\n\nfloat udBox(vec3 p,vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p,vec3 b,float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCapsule( vec3 p,vec2 h)\n{\n    float  d = p.y;\n    d = clamp(d,-h.y,h.y);\n    p.y -= d;\n    return length(p) - h.x;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max2(d),0.0) + length(max(d,0.0));\n}\n\n//x:outter radius \n//y:half height \n//z:inner radius\nfloat sdSphericalShell(vec3 p,vec3 h)\n{\n    float d = length(p);\n    float t = smoothstep(0.0,h.y,abs(p.y));\n    return mix(max(d - h.x,-(d - (h.x - h.z))),OpS(sdCappedCylinder(p,h.xy),sdCappedCylinder(p,h.xy-vec2(h.z,0))),t);\n}\n\nfloat sdSphericalShell2(vec3 p,vec3 h)\n{\n    float d = length(p);\n    float t = smoothstep(0.0,h.y,p.y);\n    return mix(d - h.x,sdCappedCylinder(p,h.xy),t);\n}\n\nfloat sdCosCurve(vec3 p,vec2 h,vec3 c)\n{   \n    p.x += c.x*cos(p.y / h.y * 3.1415926 * c.y);\n    p.z -= c.z*c.x*cos(p.y / h.y * 3.1415926);\n    p.y -= c.z*c.x*sin(p.y / h.y * 3.1415926);\n    return sdCapsule(p,h);\n}\n\nfloat sdHalfSphere( vec3 p, vec2 h )\n{\n    return mix(sdCappedCylinder(p,h),length(p) - h.x,p.y < 0.0 ? 1.:0.);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nmat4 invMaterix(mat4 m)\n{\n    mat4 m2;\n    mat3 m3;\n    m3[0] = m[0].xyz;\n    m3[1] = m[1].xyz;\n    m3[2] = m[2].xyz;\n    \n    mat3 m1 = transpose(m3);\n\n    vec3 t = mul(m1,vec3(m[0].w,m[1].w,m[2].w));\n\n    m2[0] = vec4(m1[0],-t.x);\n    m2[1] = vec4(m1[1],-t.y);\n    m2[2] = vec4(m1[2],-t.z);\n    m2[3] = vec4(0.0,0.0,0.0,1.0);\n\n    return m2;\n}\n\n\nmat4 trs(vec3 translate,vec3 angle,vec3 scale)\n{\n    mat3 rot = FromEuler(angle);\n    mat4 mat;\n\n    rot[0] *= 1.0/scale.x;\n    rot[1] *= 1.0/scale.y;\n    rot[2] *= 1.0/scale.z;\n\n    mat[0] = vec4(rot[0],translate.x);\n    mat[1] = vec4(rot[1],translate.y);\n    mat[2] = vec4(rot[2],translate.z);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n\n    return mat;\n}\n\nvec3 mulMat(mat4 mat,vec3 p)\n{\n    vec4 p2 = mul(mat,vec4(p.xyz,1.0));\n    return p2.xyz;\n}\n\nmat4 transMat(mat4 mat,vec3 t)\n{\n    mat[0].w += t.x;\n    mat[1].w += t.y;\n    mat[2].w += t.z;\n    return mat;\n}\n\nmat4 rotMat(mat4 mat,vec3 a)\n{\n    mat3 rot = FromEuler(a);\n    mat4 m;\n\n    m[0] = vec4(rot[0],0.0);\n    m[1] = vec4(rot[1],0.0);\n    m[2] = vec4(rot[2],0.0);\n    m[3] = vec4(0.0,0.0,0.0,1);\n\n    m = mul(m,mat);\n\n    return m;\n}\n\nmat4 scaleMat(mat4 mat,vec3 s)\n{\n    mat[0].xyz *= 1.0 / s.x;\n    mat[1].xyz *= 1.0 / s.y;\n    mat[2].xyz *= 1.0 / s.z;\n\n    return mat;\n}\n\nObjectData createObject(float d,float m,mat4 w2l)\n{\n    ObjectData od;\n    od.distance = d;\n    od.materialId = m;\n    od.world2LocalMatrix = w2l;\n\n    return od;\n}\n\nObjectData createObject(float d,float m)\n{\n    mat4 w2l;\n    w2l[0] = vec4(1.0,0.0,0.0,0.0);\n    w2l[1] = vec4(0.0,1.0,0.0,0.0);\n    w2l[2] = vec4(0.0,0.0,1.0,0.0);\n    w2l[3] = vec4(0.0,0.0,0.0,1.0);\n    \n    return createObject(d,m,w2l);\n}\n\nObjectData PikaHeadObjective(vec3 p)\n{   \n    float  move = sign(sin(iTime)) * abs(sin(iTime*1.0))*0.2;\n    move = max(0.0,move);\n\n    vec3 rotate = vec3(0.0,iTime*100.0,0.0);\n    rotate = vec3(0.0,0.0,0.0);\n    mat4 w2l = trs(vec3(0.0,move,0.0),rotate,vec3(1.0,1.0,1.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  earAngle = mix(30.0,50.0,0.5 + 0.5 * sin(iTime*10.0));\n    //earAngle = 45;\n\n    vec3 head1Pos = localPos;\n    vec3 head2Pos = localPos + vec3(0.0,-0.11,0.0);\n    vec3 leftEar1Pos = RotateEuler(localPos - vec3(0.2,0.0,0.0),vec3(0.0,0.0,earAngle)) + vec3(0.2 - 0.36,0.16,0.0);\n    vec3 rightEar1Pos = RotateEuler(localPos - vec3(-0.2,0.0,0.0),vec3(0.0,0.0,-earAngle)) + vec3(-0.2 + 0.36,0.16,0.0);\n    vec3 leftEarClipPos = leftEar1Pos + vec3(-0.15,-0.03,0.0);\n    vec3 rightEarClipPos = rightEar1Pos + vec3(0.15,-0.03,0.0);\n    vec3 nosePos = localPos + vec3(0.0,-0.02,-0.21-0.01);\n\n    vec3 leftEye1Pos = localPos + vec3(-0.1,0.04,-0.21 + 0.065);\n    vec3 rightEye1Pos = localPos + vec3(0.1,0.04,-0.21 + 0.065);\n    vec3 leftEye2Pos = leftEye1Pos + vec3(-0.01,0.015,-0.05 + 0.015);\n    vec3 rightEye2Pos = rightEye1Pos + vec3(0.01,0.015,-0.05 + 0.015);\n    vec3 leftFacePos = localPos + vec3(-0.14,-0.07,-0.21 + 0.12);\n    vec3 rightFacePos = localPos + vec3(0.14,-0.07,-0.21 + 0.12);\n\n    vec3 mouthPos = RotateEuler(localPos,vec3(0.0,0.0,-90)) + vec3(-0.07,0.0,-0.21 - 0.011);\n    vec3 tonguePos = localPos;\n\n    ObjectData head1 = createObject(sdSphere(head1Pos,0.21),8.0,w2l);\n    ObjectData head2 = createObject(sdTorus(head2Pos,vec2(0.08,0.07)),8.0,w2l);\n\n    ObjectData leftEar1 = createObject(sdEllipsoid(leftEar1Pos,vec3(0.2,0.05,0.045)),8.0,w2l);\n    ObjectData rightEar1 = createObject(sdEllipsoid(rightEar1Pos,vec3(0.2,0.05,0.045)),8.0,w2l);\n\n    ObjectData leftEar2 = leftEar1;\n    leftEar2.materialId = 10.0;\n    ObjectData rightEar2 = rightEar1;\n    rightEar2.materialId = 10.0;\n\n    ObjectData leftEarClip = createObject(sdSphere(leftEarClipPos,0.1),8.0,w2l);\n    ObjectData rightEarClip = createObject(sdSphere(rightEarClipPos,0.1),8.0,w2l);\n\n    ObjectData nose = createObject(sdEllipsoid(nosePos,vec3(0.015,0.01,0.01)),2.0,w2l);\n\n    ObjectData leftEye1 = createObject(sdSphere(leftEye1Pos,0.05),2.0,w2l);\n    ObjectData rightEye1 = createObject(sdSphere(rightEye1Pos,0.05),2.0,w2l);\n    ObjectData leftEye2 = createObject(sdSphere(leftEye2Pos,0.016),3.0,w2l);\n    ObjectData rightEye2 = createObject(sdSphere(rightEye2Pos,0.016),3.0,w2l);\n\n    ObjectData leftFace = createObject(sdSphere(leftFacePos,0.08),9.0,w2l);\n    ObjectData rightFace = createObject(sdSphere(rightFacePos,0.08),9.0,w2l);\n\n    ObjectData mouse = createObject(sdCosCurve(mouthPos,vec2(0.003,0.06),vec3(0.01,1.5,0.3)),2.0,w2l);\n\n    leftEar1.distance = OpS(leftEar1.distance,leftEarClip.distance);\n    rightEar1.distance = OpS(rightEar1.distance,rightEarClip.distance);\n\n    leftEar2.distance = OpI(leftEar2.distance,leftEarClip.distance);\n    rightEar2.distance = OpI(rightEar2.distance,rightEarClip.distance);\n\n    head1.distance = OpSU(head1.distance,head2.distance,0.2);\n    head1.distance = OpSU(head1.distance,leftEar1.distance,0.04);\n    head1.distance = OpSU(head1.distance,rightEar1.distance,0.04);\n\n    head1 = OpU_OD(head1,leftEar2);\n    head1 = OpU_OD(head1,rightEar2);\n    head1 = OpU_OD(head1,leftEye1);\n    head1 = OpU_OD(head1,rightEye1);\n    head1 = OpU_OD(head1,leftEye2);\n    head1 = OpU_OD(head1,rightEye2);\n    head1 = OpU_OD(head1,leftFace);\n    head1 = OpU_OD(head1,rightFace);\n    head1 = OpU_OD(head1,nose);\n    head1 = OpU_OD(head1,mouse);\n\n    ObjectData obj = head1;\n\n    return obj;\n}\n\nObjectData BallObjective(vec3 p)\n{\n    vec3 rotate = vec3(20.0,60.0,-20.0);\n    //rotate = vec3(0,_Time.y*100,0);\n    mat4 w2l = trs(vec3(0.0,0.0,0.0),rotate,vec3(3.0,3.0,3.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  openBallAngle = sign(sin(iTime)) * abs(sin(iTime*1.0))*90.0;\n\n    openBallAngle = max(0.0,openBallAngle);\n\n    vec3 p1 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0);\n    vec3 p2 = RotateEuler(localPos,vec3(0.0,0.0,180.0));\n    vec3 p3 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,90.0 + openBallAngle)) + vec3(0.0,-0.4,0.0);\n    vec3 p4 = RotateEuler(localPos + vec3(0.2,0.0,0.0),vec3(0.0,0.0,90.0 + openBallAngle)) + vec3(0.0,-0.41,0.0);\n    vec3 p5 = RotateEuler(localPos + vec3(0.2,0.0,0.0), vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0) + vec3(0.0,0.005,0.0);\n    vec3 p6 = RotateEuler(localPos , vec3(0.0,0.0,0.0)) - vec3(0.0,0.005,0.0);\n\n    ObjectData obj1_0 = createObject(sdHalfSphere(p1,vec2(0.2,0.0005)),12.0,w2l);\n    ObjectData obj2_0 = createObject(sdHalfSphere(p2,vec2(0.2,0.0005)),11.0,w2l);\n\n    ObjectData obj1_1 = createObject(sdHalfSphere(p1,vec2(0.18,0.0005)),12.0,w2l);\n    ObjectData obj2_1 = createObject(sdHalfSphere(p2,vec2(0.18,0.0005)),11.0,w2l);\n\n    ObjectData obj3 = createObject(sdCappedCylinder(p3,vec2(0.03,0.005)),11.0,w2l);\n    ObjectData obj4 = createObject(sdCappedCylinder(p4,vec2(0.01,0.002)),11.0,w2l);\n\n    ObjectData obj5 = createObject(sdSphericalShell(p5 ,vec3(0.2005,0.005,0.015)),2.0,w2l);\n    ObjectData obj6 = createObject(sdSphericalShell(p6,vec3(0.2005,0.005,0.015)),2.0,w2l);\n\n    obj1_0.distance = OpS(obj1_0.distance,obj1_1.distance);\n    obj2_0.distance = OpS(obj2_0.distance,obj2_1.distance);\n\n    ObjectData obj = OpU_OD(obj1_0,obj2_0);\n    obj = OpU_OD(obj,obj3);\n    obj = OpU_OD(obj,obj4);\n    //obj = OpU_OD(obj,obj5);\n    //obj = OpU_OD(obj,obj6);\n\n    return obj;\n}\n\nObjectData BallLineObjective(vec3 p)\n{\n    vec3 rotate = vec3(20.0,60.0,-20.0);\n    //rotate = vec3(0,_Time.y*100,0);\n    mat4 w2l = trs(vec3(0.0,0.0,0.0),rotate,vec3(3.0,3.0,3.0));\n\n    vec3 localPos = mulMat(w2l,p);\n\n    float  openBallAngle = sign(sin(iTime)) * abs(sin(iTime*1.0))*90.0;\n\n    openBallAngle = max(0.0,openBallAngle);\n\n    vec3 p5 = RotateEuler(localPos + vec3(0.2,0.0,0.0), vec3(0.0,0.0,openBallAngle)) - vec3(0.2,0.0,0.0) + vec3(0.0,0.005,0.0);\n    vec3 p6 = RotateEuler(localPos , vec3(0.0,0.0,0.0)) - vec3(0.0,0.005,0.0);\n\n    ObjectData obj5 = createObject(sdSphericalShell(p5 ,vec3(0.2005,0.005,0.015)),13.0,w2l);\n    ObjectData obj6 = createObject(sdSphericalShell(p6,vec3(0.2005,0.005,0.015)),13.0,w2l);\n\n    ObjectData obj = OpU_OD(obj5,obj6);\n\n    return obj;\n}\n\nObjectData ObjectsGroup(vec3 p)\n{   \n    ObjectData pikahead = PikaHeadObjective(p);\n    ObjectData pokemonBall = BallObjective(p);\n    //return pikahead;\n    return OpU_OD(pikahead,pokemonBall);\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd, float mint, float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < 16; i++ )\n    {\n        float h = ObjectsGroup( ro + rd*t ).distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define RAYMARCH_STEP_NUM 256\nObjectData Raymarching(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 10.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float n = 0.5e-8;\n    mat4 w2l;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = n*t;\n        ObjectData res = ObjectsGroup( ro + rd*t );\n        if( res.distance < precis || t > tmax ) break;\n        t += res.distance;\n        m = res.materialId;\n        w2l = res.world2LocalMatrix;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    ObjectData data = createObject(t,m,w2l);\n\n    return data;\n}\n\nObjectData RaymarchingBallLine(vec3 ro, vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 10.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float n = 0.5e-8;\n    mat4 w2l;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = n*t;\n        ObjectData res = BallLineObjective( ro + rd*t );\n        if( res.distance < precis || t > tmax ) break;\n        t += res.distance;\n        m = res.materialId;\n        w2l = res.world2LocalMatrix;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    ObjectData data = createObject(t,m,w2l);\n\n    return data;\n}\n\nfloat Fbm(vec2 p)\n{\n    const int octaves = 12;\n    float lacunarity = 0.5;\n    float gain = 2.0;\n    float sum = 0.0;\n    float freq = 2.0, amp = 1.1;\n    for(int i = 0; i < octaves; i ++)\n    {\n        float n = Noise(p * freq);\n        sum += n * amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n\n    return sum;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        ObjectsGroup(pos+eps.xyy).distance - ObjectsGroup(pos-eps.xyy).distance,\n        ObjectsGroup(pos+eps.yxy).distance - ObjectsGroup(pos-eps.yxy).distance,\n        ObjectsGroup(pos+eps.yyx).distance - ObjectsGroup(pos-eps.yyx).distance );\n\n    return normalize(nor);\n}\n\nvec4 RenderOutline(vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor,1.0);\n}\n\nvec4 RenderBallLine(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    float aa = 1.0 - pow(saturate(abs(localPos.y / 0.01)),4.0);\n\n    return vec4(diffuseColor,aa);\n}\n\nvec4 RenderMaterial0(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\nvec4 RenderMaterial1(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 p = (localPos);\n\n    diffuseColor = mix(diffuseColor,vec3(1.0,1.0,0.0),Fbm(vec2(length(p.xy),p.z)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\nvec4 RenderMaterial2(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    float wise = 0.1;\n    float ndl = ((dot(normal,lightDir)*0.5+0.5) + wise) / (1.0 + wise);\n\n    vec3 p = normalize(localPos);\n    diffuseColor = mix(diffuseColor,vec3(1,0,1),Fbm(vec2(length(p.xy),p.z)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    return vec4(diffuseColor * ndl + pow(rdv,35.0),aa);\n}\n\n\nvec4 RenderMaterial4(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float rampSmooth = 0.005;\n    float threshold1 = 0.5;\n    float threshold2 = 0.2;\n    float rampThresholdBlend = 0.7;\n\n    float ramp1 = smoothstep(threshold1 - rampSmooth, threshold1,ndl);\n    float ramp2 = smoothstep(threshold2 - rampSmooth, threshold2,ndl);\n\n    float ramp = mix(0.0,mix(mix(threshold2,threshold1,rampThresholdBlend) ,1.0,ramp1),ramp2);\n\n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.1,0.3,0.3));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0.0,0.0,0.0),diffuseColor + 0.15*pow(rdv,35.0),outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 RenderMaterial5(vec3 localPos,vec3 position,vec3 normal,vec3 lightDir,vec3 viewDir,vec3 diffuseColor,float shadow)\n{\n    viewDir = normalize(viewDir);\n    \n    float ndl = dot(normal,lightDir)*0.5+0.5;\n\n    float ramp = ndl;\n    \n    vec3 diffuseHsv = RGBtoHSV(diffuseColor);\n    vec3 shadowHsv = RGBtoHSV(vec3(0.1,0.3,0.3));\n\n    diffuseColor = HSVtoRGB(vec3(diffuseHsv.rg,mix(shadowHsv.b,diffuseHsv.b,ramp)));\n\n    vec3 ref = reflect(lightDir,normal);\n\n    float rdv = max(0.0,dot(ref,-viewDir));\n\n    float aa = 1.0 - saturate(pow(1.0 - max(0.0,dot(normal,viewDir)),16.0));\n\n    float outline = smoothstep(0.09,0.18,pow(max(0.0,dot(normal,viewDir)*0.9+0.1),1.4478));\n\n    vec3 finalColor = mix(vec3(0,0,0),diffuseColor + 0.65*pow(rdv,35.0),outline);\n\n    return vec4(finalColor*max(shadow,0.4),aa);\n}\n\nvec4 Render(vec3 orgPos,vec3 rayDir)\n{\n    vec4 color = vec4(0,0,0,0) ;\n\n    ObjectData result = Raymarching(orgPos, rayDir);\n    float  dist = result.distance;\n    float  material = result.materialId;\n\n    if(material >= 0.0)\n    {\n        mat4 w2l = result.world2LocalMatrix;\n        vec3 position = orgPos + rayDir * dist;\n        vec3 normal = CalcNormal(position);\n        vec3 lightDir = normalize(vec3(0.5*sin(iTime*2.0),-1,1));\n        vec3 diffColor = vec3(1,1,1);\n        vec3 uViewDir = -rayDir * dist;\n        vec3 localPos = mulMat(w2l,position);\n        float  shadow = SoftShadow(position,lightDir,0.02, 2.5);\n\n        mat4 w2l_2nd;\n        w2l_2nd[0]=vec4(1,0,0,w2l[0].w);\n        w2l_2nd[1]=vec4(0,1,0,w2l[1].w);\n        w2l_2nd[2]=vec4(0,0,1,w2l[2].w);\n        w2l_2nd[3]=vec4(0,0,0,1);\n        \n\n        vec3 localPos_2nd = mulMat(w2l_2nd,position);\n\n        if(material == 1.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial1(localPos_2nd,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 2.0)\n        {\n            diffColor = vec3(0,0,0);\n            color = RenderOutline(position,normal,lightDir,uViewDir,diffColor,shadow);  \n        }\n        else if(material == 3.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderOutline(position,normal,lightDir,uViewDir,diffColor,shadow);  \n        }\n        else if(material == 4.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial2(localPos_2nd,position,normal,lightDir,uViewDir,diffColor,shadow);\n        }\n        else if(material == 6.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial0(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 7.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderMaterial0(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 8.0)\n        {\n            diffColor = vec3(1,1,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 9.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 10.0)\n        {\n            diffColor = vec3(0,0,0);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 11.0)\n        {\n            diffColor = vec3(1,1,1);\n            color = RenderMaterial4(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n        else if(material == 12.0)\n        {\n            diffColor = vec3(1,0,0);\n            color = RenderMaterial5(localPos,position,normal,lightDir,uViewDir,diffColor,shadow);   \n        }\n    }\n\n    ObjectData result2 = RaymarchingBallLine(orgPos, rayDir);\n\n    result2 = OpU_OD(result,result2);\n\n    float  dist2 = result2.distance;\n    float  material2 = result2.materialId;\n\n    if(material2 == 13.0)\n    {\n        mat4 w2l = result.world2LocalMatrix;\n        vec3 position = orgPos + rayDir * dist;\n        vec3 normal = CalcNormal(position);\n        vec3 lightDir = normalize(vec3(0.5*sin(iTime*2.0),-1,1));\n        vec3 diffColor = vec3(1,1,1);\n        vec3 uViewDir = -rayDir * dist;\n        vec3 localPos = mulMat(w2l,position);\n        float  shadow = SoftShadow(position,lightDir,0.02, 2.5);\n\n        mat4 w2l_2nd;\n        w2l_2nd[0]=vec4(1,0,0,w2l[0].w);\n        w2l_2nd[1]=vec4(0,1,0,w2l[1].w);\n        w2l_2nd[2]=vec4(0,0,1,w2l[2].w);\n        w2l_2nd[3]=vec4(0,0,0,1);\n        \n\n        vec3 localPos_2nd = mulMat(w2l_2nd,position);\n\n        diffColor = vec3(0,0,0);\n        vec4 color2 = RenderBallLine(localPos,position,normal,lightDir,uViewDir,diffColor,shadow); \n\n        color.rgb = mix(color.rgb,color2.rgb,color2.a);\n    }\n\n\n    return color;\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aa = 0.0;\n    vec4 color = vec4(0.0);\n    vec2 canvasPos = fragCoord / iResolution.xy;\n    for(int i = -AA; i <= AA; ++ i)\n    {\n        for (int j = -AA; j <= AA; ++ j)\n        {\n            vec2 orgPos = (2.0 * (fragCoord + vec2(i,j) * 0.35) -  iResolution.xy) / iResolution.y;\n\t\t\t\n            vec3 cameraPos = vec3(0,0,2);\n            vec3 lookAtPos = vec3(0,0,0);\n\n            mat3 cameraMatrix = SetCamera(cameraPos,lookAtPos);\n\n            vec3 rayDir = mul(cameraMatrix,normalize(vec3(orgPos,1)));\n\n            color += Render(cameraPos,rayDir);\n            aa += 1.0;\n        }\n    }    \n    \n    color /= aa;\n    \n    vec4 skyBox = mix(vec4(1,1,1,1),vec4(0,0.3,1,1),pow(canvasPos.y,0.4));\n\n    vec4 finialColor = vec4(mix(skyBox.rgb,color.rgb,color.a),skyBox.a);\n\n    fragColor = finialColor;\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[276, 276, 297, 297, 369], [371, 371, 391, 391, 433], [435, 435, 496, 496, 546], [548, 548, 568, 568, 595], [597, 597, 617, 617, 644], [646, 646, 666, 666, 702], [704, 704, 724, 724, 760], [762, 762, 782, 782, 827], [829, 829, 849, 849, 894], [896, 896, 922, 922, 1271], [1273, 1273, 1299, 1299, 1475], [1477, 1477, 1525, 1525, 1561], [1563, 1563, 1592, 1592, 1845], [1847, 1847, 1885, 1885, 1924], [1926, 1926, 1953, 1953, 2345], [2347, 2347, 2393, 2393, 2534], [2536, 2536, 2571, 2571, 2607], [2609, 2609, 2630, 2630, 2879], [2881, 2881, 2914, 2914, 3090], [3092, 3100, 3130, 3130, 3155], [3157, 3172, 3211, 3211, 3310], [3312, 3334, 3373, 3373, 3404], [3406, 3417, 3447, 3447, 3473], [3475, 3490, 3520, 3520, 3548], [3550, 3558, 3586, 3586, 3622], [3624, 3624, 3672, 3672, 3754], [3756, 3756, 3788, 3788, 3816], [3818, 3818, 3846, 3846, 3923], [3925, 3925, 3953, 3953, 4011], [4013, 4013, 4054, 4054, 4116], [4118, 4118, 4151, 4151, 4206], [4208, 4208, 4244, 4244, 4280], [4282, 4282, 4314, 4342, 4403], [4405, 4405, 4438, 4466, 4499], [4501, 4501, 4534, 4534, 4625], [4627, 4627, 4679, 4679, 4806], [4808, 4808, 4850, 4850, 4948], [4950, 5003, 5042, 5042, 5231], [5233, 5233, 5273, 5273, 5391], [5393, 5393, 5433, 5433, 5608], [5610, 5610, 5648, 5648, 5723], [5725, 5725, 5762, 5762, 5822], [5824, 5824, 5849, 5849, 6169], [6172, 6172, 6220, 6220, 6522], [6524, 6524, 6554, 6554, 6615], [6617, 6617, 6649, 6649, 6730], [6732, 6732, 6762, 6762, 6961], [6963, 6963, 6995, 6995, 7101], [7103, 7103, 7154, 7154, 7267], [7269, 7269, 7311, 7311, 7510], [7512, 7512, 7550, 7550, 11137], [11139, 11139, 11173, 11173, 13053], [13055, 13055, 13093, 13093, 13844], [13846, 13846, 13879, 13879, 14043], [14045, 14045, 14106, 14106, 14395], [14427, 14427, 14469, 14469, 14978], [14980, 14980, 15030, 15030, 15544], [15546, 15546, 15565, 15565, 15874], [15876, 15876, 15903, 15903, 16240], [16242, 16242, 16347, 16347, 16462], [16464, 16464, 16584, 16584, 16685], [16687, 16687, 16808, 16808, 17160], [17162, 17162, 17283, 17283, 17746], [17748, 17748, 17869, 17869, 18334], [18337, 18337, 18458, 18458, 19486], [19488, 19488, 19609, 19609, 20296], [20298, 20298, 20336, 20336, 24324], [24339, 24339, 24396, 24396, 25210]]}
{"id": "ldVfDm", "name": "Sidescrolling Starfield", "author": "rkibria", "description": "A homage to old space shooter games.", "tags": ["2d", "stars"], "likes": 3, "viewed": 207, "date": "1529188721", "time_retrieved": "2024-06-20T19:15:21.094306", "image_code": "const float scrollspeed = 0.1;\n\nconst int small_count = 25;\nconst vec4 small_color = vec4( 0.7, 0.7, 1.0, 1.0 );\nconst float small_size = 0.003;\nconst float small_flicker = 2.5;\n\nconst int big_count = 6;\nconst vec4 big_color = vec4( 1.0, 1.0, 0.6, 1.0 );\nconst float big_size = 0.005;\nconst float big_flicker = 1.5;\n\nvoid iteration(inout float a, inout float b)\n{\n    float t = 0.111 * a + 1.123 * fract(123.456 * b);\n    float v = 0.999 * b - 3.456 * fract(456.123 * a);\n    a = t;\n    b = -v;\n}\n\nfloat starfield(int index, float seed, int count, vec2 uv, float radius, float flicker)\n{\n    int n = count + 3;\n    float w = 1.0 / float(count);\n\n    float a = 2.1 + float(index) + seed;\n    float b = 1.2 + seed;\n    float c = 0.0;\n\n    for( int i = 0; i < n; i++ )\n    {\n        iteration( a, b );\n\n        if( i > 2 )\n        {\n            float x = float(i - 3) * w + fract(a) * w / 2.;\n            float y = fract(b) * iResolution.y/iResolution.x;\n\t        vec2 star = vec2( x, y );\n            float d = distance(star, uv);\n            float r = (1. + 0.5 * abs(sin(2.*(x+y) + radius + iTime*flicker))) * radius;\n            c = max(c, smoothstep(r, r - 0.001, d));\n        }\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    int index = int( iTime * scrollspeed );\n    float offset_x = mod( iTime * scrollspeed, 1. );\n    \n    fragColor = vec4(0, 0, (1.-uv.y) * 0.1, 0.);\n\n    fragColor += small_color\n        * starfield(index, 0., small_count, vec2(uv.x + offset_x, uv.y), small_size, small_flicker);\n    fragColor += small_color\n        * starfield(index + 1, 0., small_count, vec2(-1.0 + uv.x + offset_x, uv.y), small_size, small_flicker);\n\n    fragColor += big_color\n        * starfield(index, 1., big_count, vec2(uv.x + offset_x, uv.y), big_size, big_flicker);\n    fragColor += big_color\n        * starfield(index + 1, 1., big_count, vec2(-1.0 + uv.x + offset_x, uv.y), big_size, big_flicker);\n    \n    fragColor = pow(fragColor, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[317, 317, 363, 363, 496], [498, 498, 587, 587, 1202], [1204, 1204, 1261, 1261, 2037]]}
{"id": "ldVfWm", "name": "PurpleFlow", "author": "Del", "description": "purple", "tags": ["purple"], "likes": 3, "viewed": 460, "date": "1529164144", "time_retrieved": "2024-06-20T19:15:21.100393", "image_code": "// Mellow purple flow background - Del 16/06/2018\nconst float pi = 3.14159;\n\nvec4 MellowPurple(vec2 pos)\n{\n    pos *= 0.5;\n    vec4 col = vec4(0.32,0.19,0.35,1.0);\n    float d = length(pos);\n    float tt = iTime*0.08;\n    float iter = (pos.x*pos.y);\n    iter *= 0.5+sin(pos.x*0.5+tt*0.95)+0.5;\n    float r = sin(sin(tt)*pos.y);\n    r += .4;\n    float d1 = sin(tt+pos.x+pos.y);\n    float val = sin(tt+iter*pi );\n    float brightness = 0.25 / abs( d1 * val - r);\n//    brightness +=  0.25 /abs( d1+0.1 * val - r);\n//    brightness += 0.25 / abs( d1-0.1 * val - r);\n    brightness +=  0.25 /abs( d1+0.4 * val - r);\n    brightness += 0.25 / abs( d1-0.4 * val - r);\n    brightness *= 0.05;\n    brightness = brightness/(brightness + 1.);\n    brightness*=0.75-d;\n    col += brightness;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;     \n    fragColor = MellowPurple(pos);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 77, 106, 106, 796], [799, 799, 856, 856, 963]]}
{"id": "ldVfWW", "name": "Cartoon sea", "author": "rkibria", "description": "A not-really-pathtracing shader.", "tags": ["cartoon", "water", "animated", "stylized"], "likes": 4, "viewed": 105, "date": "1528931545", "time_retrieved": "2024-06-20T19:15:21.100393", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord / iResolution.xy - 0.5 ) * 2.;\n    vec3 col = vec3( 0 );\n    \n    vec3 ray = normalize( vec3( uv, 1. ) );\n    \n    bool flag = false;\n    for( float j = 15.0; j >= 1.0; j -= 0.25 )\n    {\n        vec3 d = j * ray;\n        float t = 1.2 * iTime;\n        float h = ( sin( t + d.x * 0.9 + 0.3 ) * 0.6\n                   + cos( t + d.z * 0.9 ) * 0.7\n                  ) - 1.7;\n\n        if( d.y <= h )\n        {\n            col = vec3( 0.2, 0.8 / length( d ), 1. / j + 0.1 );\n            flag = true;\n            j += 0.125; // smoother waves\n        }\n    }\n    \n    if( !flag )\n    {\n        col = ( vec3( 0.5 - uv.y ) + vec3( 0.2, 0.2, 0.8 * uv.y ) ) * 0.8;\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 781]]}
{"id": "ldVfWy", "name": "Unrequited Love", "author": "Saineni", "description": "heart 2d", "tags": ["heart"], "likes": 4, "viewed": 109, "date": "1530357543", "time_retrieved": "2024-06-20T19:15:21.100393", "image_code": "float heart2D( vec2 uv){\n    uv *= 0.5;\n    uv.x = abs(uv.x);\n    uv.y = -0.15 -uv.y*1.2 + uv.x*(1.0-uv.x);\n    float c= length(uv)-0.5;\n    return c;\n}\n\nvec2 animate( vec2 uv, float speed){\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*speed*sin(tt*6.2831*3.0 + uv.y*0.5)*exp(-tt*4.0);\n    uv *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 P = 5. * (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y); //uv\n \tfloat s=1.5; // speed of the animated heart\n    \n    vec2 uv = animate(P,s);\n\tfloat d = heart2D(uv);\n    vec3 col = 0.9 + sin(iTime+P.xyx+vec3(0,2,4));\n\n\tfragColor = vec4(mix(col, vec3(1.), clamp(d / 0.04, 0.4, 1.0)),1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 152], [154, 154, 190, 190, 392], [394, 394, 451, 451, 779]]}
{"id": "ldVfWz", "name": "Raymarch Practice - AvfasfdBgfzs", "author": "minujeong", "description": "Practice\n", "tags": ["raymarch"], "likes": 0, "viewed": 119, "date": "1528440373", "time_retrieved": "2024-06-20T19:15:21.100393", "image_code": "#define FAR     80.0\n#define NRM_OFS 0.002\n\n\nfloat sadd(float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nfloat map_torus(vec3 o)\n{\n    o.x += 0.50;\n    o.y += 0.45;\n    \n    float rx = cos(iTime * 4.0);\n    float rz = cos(iTime * 4.0 + 0.12);\n    mat3 trz = mat3(\n        cos(rz), -sin(rz), 0,\n        sin(rz), cos(rz), 0,\n        0, 0, 1\n    );\n    \n    mat3 trx = mat3(\n        \n        1, 0, 0,\n        0, cos(rx), -sin(rx),\n        0, sin(rx), cos(rx)\n    );\n    \n    vec3 p = inverse(trx) * inverse(trz) * o;\n    vec2 q = vec2(length(p.xz) - 0.5, p.y);\n    return length(q) - (cos(iTime * 18.0) * 0.05 + 0.15);\n}\n\nfloat map_sphere(vec3 o)\n{\n    vec3 q = o + vec3(\n        0.45 - abs(cos(iTime * 2.0) * 0.45),\n        0.35 - abs(cos(iTime * 2.0) * 0.45),\n        0);\n    return length(q) - 0.25;\n}\n\nfloat map_sphere_2(vec3 o)\n{\n    float x = cos(iTime * 14.0) - sin(iTime * 14.0);\n    float z = sin(iTime * 14.0) + cos(iTime * 14.0);\n\tvec3 q = o + vec3(x, 0, z) * 0.25;\n    return length(q) - 0.25;\n}\n\nfloat world(vec3 p)\n{\n    float st = sadd(map_sphere(p), map_torus(p));\n    float sst = sadd(st, map_sphere_2(p));\n    return sst;\n}\n\nfloat raymarch(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    vec3 p = vec3(0, 0, 0);\n    float d = 0.0;\n    float ad = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        p = o + r * t;\n        d = world(p);\n        ad = abs(d);\n        if (ad < 0.01)\n        {\n            return t;\n        }\n        t += d;\n    }\n    \n    return FAR;\n}\n\n\n\nvec3 get_normal(vec3 p)\n{\n    vec2 e = vec2(NRM_OFS, 0);\n    float d1 = world(p + e.xyy), d2 = world(p - e.xyy);\n    float d3 = world(p + e.yxy), d4 = world(p - e.yxy);\n    float d5 = world(p + e.yyx), d6 = world(p - e.yyx);\n    \n    return normalize(vec3(\n        d1 - d2,\n        d3 - d4,\n        d5 - d6\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 o = vec3(cos(iTime) * 0.5 - 0.5, 0, -4);\n    vec3 r = normalize(vec3(uv, 1.15));\n    r = normalize(vec3(r.xy, r.z - length(r.xy) * .15));\n    \n    float cr = 0.0;\n    float d = raymarch(o, r);\n    if (d < FAR)\n    {\n        vec3 hit = o + r * d;\n        vec3 normal = get_normal(hit);\n        float ndu = dot(normal, vec3(0, 0.75, -0.25));\n        \n        vec3 color1 = vec3(0.25, 0.25, 0.25);\n        vec3 color2 = vec3(1, 1, 1);\n        vec3 fncolor = mix(color1, color2, ndu);\n        fncolor.x = max(fncolor.x, 0.15);\n        fncolor.z = max(fncolor.z, sin(iTime) * 0.1 + 0.1);\n        fncolor.xz += uv * 0.5 * ndu;\n        fragColor = vec4(fncolor, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.45, 0.25, 0.25, 1.0) + vec4(uv, length(uv), 0) * 0.2;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[45, 45, 75, 75, 194], [196, 196, 221, 221, 708], [710, 710, 736, 736, 892], [894, 894, 922, 922, 1095], [1097, 1097, 1118, 1118, 1229], [1231, 1231, 1263, 1263, 1565], [1569, 1569, 1594, 1594, 1885], [1887, 1887, 1944, 1944, 2790]]}
{"id": "ldVfzy", "name": "Bad Shadow Box", "author": "hypothete", "description": "I\"m having a rough time trying to understand shadows. I haven't found sample code for simple hard shadows, so I'm working off of iq's improved soft shadow function. As you can see I'm getting a lot of artifacts. Any advice on where to start?\n\n", "tags": ["sdf", "cornellbox", "shadows"], "likes": 0, "viewed": 135, "date": "1529425866", "time_retrieved": "2024-06-20T19:15:21.973302", "image_code": "#define EPSILON 0.01\n#define MAXSTEPS 128\n#define NEAR 0.1\n#define FAR 100.0\n#define TWOPI 6.28319\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat udfBox( vec3 p, vec3 b ) {\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat dot2( in vec3 v ) {\n    return dot(v,v);\n}\n\nfloat udfQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(dc,nor),pc)) +\n         sign(dot(cross(ad,nor),pd))<3.0)\n        ?\n        min( min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n                 dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n            dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n        :\n        dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 sceneSDF(vec3 p) {\n    \n    // x is distance to scene, y is object id\n\n    float id = 0.0;\n    float cr = 5.0;\n\n    vec3 q = p - vec3(0.0, 0.0, 10.0);\n    vec3 ca = vec3(-cr,  cr,  cr);\n    vec3 cb = vec3( cr,  cr,  cr);\n    vec3 cc = vec3(-cr, -cr,  cr);\n    vec3 cd = vec3( cr, -cr,  cr);\n    vec3 ce = vec3(-cr,  cr, -cr);\n    vec3 cf = vec3( cr,  cr, -cr);\n    vec3 cg = vec3(-cr, -cr, -cr);\n    vec3 ch = vec3( cr, -cr, -cr);\n\n    vec3 b1 = vec3(1.0);\n    float box1 = udfBox(p - vec3(-2.0, -cr+b1.y, 10.0), b1);\n\n    vec3 b2 = vec3(1.5, 3.0, 1.5);\n    float box2 = udfBox(p - vec3(2.0, -cr+b2.y, 9.0), b2);\n\n    float tot = FAR;\n\n    float back = udfQuad(q, ca, cb, cd, cc);\n    float right = udfQuad(q, cb, cf, ch, cd);\n    if (right < EPSILON) { id = 1.0; }\n    float left = udfQuad(q, ce, ca, cc, cg);\n    if (left < EPSILON) { id = 2.0; }\n    float top = udfQuad(q, ce, cf, cb, ca);\n    float bottom = udfQuad(q, cc, cd, ch, cg);\n\n    tot = min(tot, back);\n    tot = min(tot, right);\n    tot = min(tot, left);\n    tot = min(tot, top);\n    tot = min(tot, bottom);\n    tot = min(tot, box1);\n    tot = min(tot, box2);\n\n    return vec2(tot, id);\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec3 v1 = vec3(1.0, -1.0, -1.0);\n    vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    vec3 v4 = vec3(1.0, 1.0, 1.0);\n    return normalize(\n        v1 * sceneSDF(p + v1*EPSILON).x +\n        v2 * sceneSDF(p + v2*EPSILON).x +\n        v3 * sceneSDF(p + v3*EPSILON).x +\n        v4 * sceneSDF(p + v4*EPSILON).x\n    );\n}\n\nfloat distToSurface(Camera c, out vec3 ip, out float id) {\n    float depth = NEAR;\n    for (int i=0; i<MAXSTEPS; i++) {\n        ip = c.pos + c.dir * depth;\n        vec2 distToScene = sceneSDF(ip);\n        id = distToScene.y;\n        if (distToScene.x < EPSILON) {\n            return depth;\n        }\n        depth += distToScene.x;\n        if (depth >= FAR) {\n            return FAR;\n        }\n    }\n    return depth;\n}\n\nfloat lambert(vec3 norm, vec3 lpos) {\n    return max(dot(norm, normalize(lpos)), 0.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n\t// based off of http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    float res = 1.0;\n    float ph = 1e20;\n    float tmin = 0.1;\n    float tmax = 2.0;\n    float k = 8.0;\n\n    for (float t = tmin; t < tmax;) {\n        vec2 h = sceneSDF(ro + rd * t);\n        if (h.x < EPSILON) {\n            return 0.0;\n        }\n        float y = (h.x * h.x) / (2.0 / ph);\n        float d = sqrt((h.x * h.x) - (y * y));\n        res = min(res, k * d / max(0.0, t - y));\n        ph = h.x;\n        t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 nrmDir = normalize(vec3(uv, 1.0));\n    Camera camera = Camera(vec3(0.0, 0.0, 0.0), nrmDir);\n    vec3 endPt;\n    vec3 col = vec3(0.0);\n    float id = 0.0;\n    float t = distToSurface(camera, endPt, id);\n\n    if (t < FAR) {\n        vec3 nrm = sceneNormal(endPt);\n\n        if (id == 1.0) {\n            col = vec3(0.8, 0.1, 0.1);\n        }\n        else if(id == 2.0) {\n            col = vec3(0.1, 0.8, 0.1);\n        }\n        else {\n            col = vec3(0.9);\n        }\n\n        vec3 lpos = vec3(4.5 * sin(iTime), -4.0, 7.5 + 4.5 * cos(iTime)); // light position top\n\n        float lamb = lambert(nrm, lpos - endPt);\n        float shad = shadow(endPt, normalize(lpos - endPt));\n\n        col *= lamb;\n        col *= max(0.2, shad);\n\n    } \n\n    col = pow(col, vec3(0.4545)); // gamma\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[174, 174, 196, 196, 268], [270, 270, 302, 302, 343], [345, 345, 370, 370, 393], [395, 395, 452, 452, 1153], [1155, 1155, 1178, 1229, 2313], [2315, 2315, 2341, 2341, 2684], [2686, 2686, 2744, 2744, 3105], [3107, 3107, 3144, 3144, 3195], [3197, 3197, 3229, 3309, 3756], [3758, 3758, 3813, 3813, 4705]]}
{"id": "ldyBDD", "name": "Fractal Zone 1.01", "author": "chantecleer", "description": "Come through a trip to the fractal zone", "tags": ["fractal"], "likes": 13, "viewed": 179, "date": "1528852511", "time_retrieved": "2024-06-20T19:15:22.476225", "image_code": "// this was inspired by the following two shaders:\n// https://www.shadertoy.com/view/Mdf3z7\n// https://www.shadertoy.com/view/MlfczH\n\n#define A 2. * iTime\n#define MinimumDistance 0.0009\n#define asgt(i) abs(sin(i * iTime))\n#define acgt(i) abs(cos(i * iTime))\n#define sgt(i) sin(i * iTime)\n#define cgt(i) cos(i * iTime)\n#define Giter 5\n#define MaxSteps 10\n#define Iterations 10\n#define raySteps 32 // changing this to 64 might open your third eye\n\nfloat DE(in vec3 z) {\n    vec3 Offset = vec3(0.92858,0.92858,0.32858);\n    Offset.y += 0.5*asgt(0.05);\n    Offset.x -= 0.2*cgt(0.1);\n    \n    float Scale = 2.0 + 1.2*asgt(0.1);\n    Scale += 0.2*sgt(1.);\n\n\tz  = abs(2.-mod(z,4.0));\n\n    z.x *= (1. - 0.01*sgt(1.));\n    z.y *= (1. + 0.01*cgt(1.0));\n    z.z *= (1. + 0.01*sgt(1.0));\n\n\tfloat d = 10.0;\n\tfor (int m = 0; m < Iterations; m++) {\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(2.*Scale-1.);\n\t\tif( z.z < -0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\n        d = min(d, length(z) * pow(Scale, float(-m)-1.0));\n\t}\n\n\treturn d-0.001;\n}\n    \nvec3 Glow(vec3 z, float b){\n    z = fract( z * .2) * 2. -1.;\n\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    return z;\n}\n\nvec3 fog(float a,vec3 b,float c){ \n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c );\n}\n\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e=(fog( .1, abs(fr), d)*1. +\n            fog( .1, vec3(length( fr.yz ), length( fr.zx ), length( fr.xy )), d) * 5.0 \n            * (sin( A * vec3(2.1, 1.3, 1.7) + b*10.) + 1.)); \n\n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( .5 -c *(200.+500.*asgt(1.)) / d, 0. ) / d * 70.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float speed = 0.5;\n    vec3 base = vec3(0.1, 0.3*sgt(0.1), 0.3*cgt(0.1)) * speed;\n\n    vec3 camPos = 0.2*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos); \n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); \n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color; float totalDistance, distance, v;\n\n    for(int i = 0; i < raySteps; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = DE(pos);        \n        v = sin( A * .1 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance + .001; \n        color += ( W( x, v, distance, 1.) ) * (distance + 0.001);      \n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 446, 467, 467, 1124], [1130, 1130, 1157, 1157, 1332], [1334, 1334, 1367, 1367, 1421], [1423, 1423, 1463, 1463, 1758], [1760, 1760, 1816, 1816, 2739]]}
{"id": "ldyBDG", "name": "Zebra Grid", "author": "vjyourself", "description": "Zebra shifting grid", "tags": ["grid", "zebra"], "likes": 1, "viewed": 105, "date": "1530200430", "time_retrieved": "2024-06-20T19:15:22.706617", "image_code": "float ds(in float st, in float l0, in float l2){\n  float l1 = (l0+l2)*0.5;\n  return  smoothstep( l0, l1, st ) - smoothstep( l1, l2, st );\n}\n\nvec2 transUV(in vec2 uv){\n    vec2 uvt = uv;\n    uvt.x+=sin(uvt.x*26.0+iTime*0.6)*0.02;\n    uvt.y+=sin(uvt.y*22.0+iTime*0.6)*0.02;\n    return uvt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying gradient\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t//col = fract((uv.x+uv.y)*100.0) < 0.5 ? vec3(1.0,1.0,1.0) : vec3(0.0,0.0,0.0);\n    \n    // Grid\n    vec2 uvt = transUV(uv);\n    \n  \n   \tfloat zebra = ds(fract((uvt.x+uvt.y)*20.0),0.0,0.8);\n    vec3 colZebra = vec3(zebra);\n    \n    float countX=20.0;\n    float countY=12.0;\n    float width = 0.1;\n    float frakX =fract(uvt.x*countX);\n    float frakY =fract(uvt.y*countY);\n    float gridX = ds(frakX,0.0,width);\n    float gridY = ds(frakY,0.0,width);\n    \n    vec3 finalCol = col*zebra + vec3(gridX*0.3)+ vec3(gridY*0.3);\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 48, 48, 139], [141, 141, 166, 166, 289], [291, 291, 348, 398, 1114]]}
{"id": "ldyBWD", "name": "Boxy Pikachu", "author": "fizzer", "description": "A fanart recreation of the new boxy Pikachu design from the Nintendo game Pokémon Quest.\nIt turns out Pokémon are easy to make with SDFs when they are made of boxes!", "tags": ["nintendo", "pikachu", "boxy"], "likes": 59, "viewed": 2639, "date": "1528840282", "time_retrieved": "2024-06-20T19:15:23.961182", "image_code": "#define AA 4 // Anti-aliasing sampling box size factor. Total number of samples will be AA ^ 2\n\n#define PI 3.141592653589\n\nfloat time;\n\n// 2D rotation matrix\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// Rounded box distance with internal distance, 2D version.\nfloat box(vec3 p,vec3 s)\n{\n    p=abs(p)-s;\n    float d=max(p.x,max(p.y,p.z));\n    return max(d,length(max(p,vec3(0))));\n}\n\n// Rounded box distance with internal distance, 3D version.\nfloat box(vec2 p,vec2 s)\n{\n    p=abs(p)-s;\n    float d=max(p.x,p.y);\n    return max(d,length(max(p,vec2(0))));\n}\n\n// The main body SDF, sans mouth.\nfloat body(vec3 p)\n{\n    float d=1e4;\n    p.y+=.05;\n\n    // Tail, made of some rotated boxes.\n    float taild;\n    vec3 tp=p;\n    tp.xy*=rotmat(0.2);\n    taild=box(tp-vec3(1,0.4,1.2),vec3(.5,.3,.1))-.1;\n    taild=min(taild,box(tp-vec3(1.2,1.3,1.2),vec3(.3,.7,.1))-.1);\n    taild=min(taild,box(tp-vec3(1.9,1.5,1.2),vec3(.9,.5,.1))-.1);\n\n    d=min(d,taild);\n\n    // Rest of the body is symmetrical.\n    p.x=abs(p.x);\n\n    // Torso / head.\n    d=min(d,box(p,vec3(.93,.7,.95))-.2);\n    \n    // Ears\n    d=min(d,box(p-vec3(.6,1,-.6+p.y/8.),vec3(.2,1.1,.05))-.1);\n\n    // Feet\n    p-=vec3(-.1,.05,.1);\n    d=min(d,box(vec3(p.xy,abs(p.z-.1))-vec3(.7,-1,.7),vec3(.23,.4,.15))-.06);\n    p-=vec3(.7,-1.4,-.0);\n    p.z=abs(p.z);\n    d=min(d,box(p-vec3(0,0,0.7),vec3(.23,.05,.2))-.06);\n    \n    return d;\n}\n\n// The complete body.\nfloat bodyWithMouth(vec3 p)\n{\n    float d=body(p);\n    \n    p.x=abs(p.x);\n    \n    // Main mouth shape.\n    d=max(d,-(box(p-vec3(0,-.4,-2),vec3(.34,.14,1.2))-.012));\n    \n    // The upper triangular part, which is just a rotated box.\n    p.y+=.21;\n    p.z+=2.;\n    p.xy*=rotmat(-1.);\n    d=max(d,-(box(p,vec3(.1,.05,1.2))-.012));\n    \n    return d;\n}\n\n// Scene SDF.\nfloat f(vec3 p)\n{\n    return bodyWithMouth(p);\n}\n\n// Linstep, for cheaper smoothening of texture edges.\nfloat linstep(float a,float b,float x)\n{\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\n// Face texture.\nvec3 face(vec2 p)\n{\n    p.y*=1.1;\n    vec3 c=vec3(1,1,.2);\n    \n    // Mirrored through X axis.\n    p.x=abs(p.x);\n    \n    // Eyes\n    c=mix(c,vec3(0),linstep(.02,.01,box(p-vec2(.45,.3),vec2(.15,.17))));\n    c=mix(c,vec3(1),linstep(.02,.01,box(p-vec2(.4,.39),vec2(.04,.04))));\n    \n    // Nose\n    c=mix(c,vec3(0),linstep(.02,.01,box(p-vec2(0,-.02),vec2(.07,.03))));\n    \n    // Cheeks\n    c=mix(c,vec3(1,.15,.04),linstep(.02,.01,box(p-vec2(0.7,-.25),vec2(.18,.2))));\n    \n    return c;\n}\n\n// Maps [0, 1] x [0, 1] to unit disc.\nvec2 disc(vec2 uv)\n{\n   float a = uv.x * PI * 2.;\n   float r = sqrt(uv.y);\n   return vec2(cos(a), sin(a)) * r;\n}\n\n// Maps [0, 1] x [0, 1] to disc with linear distribution.\nvec2 tent(vec2 uv)\n{\n\treturn disc(vec2(uv.x, 1. - sqrt(1. - uv.y)));\n}\n\nvec3 sampleScene(vec2 coord)\n{\n    vec2 t = coord / iResolution.xy * 2. - 1.;\n\tt.x *= iResolution.x / iResolution.y;\n    \n    // Set up primary ray.\n    float an=7.;\n    vec3 ro=vec3(.3,0.6,15.);\n    vec3 rd=normalize(vec3(t.xy,-5.));\n\n    // Intersect with ground plane.\n    float groundt=(-1.55-ro.y)/rd.y;\n\n\t// Compositional orientation.\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n    // Animating orientation.\n    mat2 rx=rotmat(cos(time*7.)*.1);\n    mat2 rz=rotmat(cos(time*3.)*.1);\n\n    ro.y-=abs(sin(time*7.+PI))/8.+.05;\n    ro.yz*=rx;\n    rd.yz*=rx;\n\n    ro.xy*=rz;\n    rd.xy*=rz;\n\n    // Reject negative ground plane intersection distance.\n    if(groundt<0.)\n        groundt=1e4;\n\n    float dt=5.,d=0.;\n    \n    // Trace through SDF.\n    for(int i=0;i<140;++i)\n    {\n        d=f(ro+rd*dt);\n        if(abs(d)<1e-3||dt>20.||dt>groundt)\n            break;\n        dt+=d;\n    }\n\n    // Backdrop colour.\n    vec3 c=vec3(.5,15,.3)*.9;\n    \n    if(groundt<dt)\n    {\n        // Ground is nearer. Just apply some basic shadow shape.\n        vec3 rp=ro+rd*groundt;\n        c*=mix(.7,1.,linstep(0.,.1,box(rp.xz,vec2(1.))-.5));\n    }\n    else if(dt<20.)\n    {   \n        // SDF is nearer.\n        float d2=f(ro+rd*dt+normalize(vec3(-2,2,-1))*1e-2);\n        float l=.5+.5*(d2-d)/1e-2;\n\n        // Get the intersection point.\n        vec3 rp=ro+rd*dt;\n\n        // Determine a colour based on where the ray hit is.\n        \n        c=vec3(1,1,.2);\n\n        if(bodyWithMouth(rp)>body(rp))\n            // Main body.\n            c=vec3(1.3,.5,1)/2.*mix(.5,1.,smoothstep(.3,.6,l));\n        else if(rp.z<-1.)\n            // Face texture.\n            c=face(rp.xy);\n        else if(rp.y>1.2&&rp.z<0.)\n            // Tips of ears.\n            c=mix(c,vec3(0),linstep(0.,.01,rp.y-1.7));\n\n        // Stripes on back.\n        rp.xz=abs(rp.xz-vec2(0,.3))-vec2(0,.3);\n        rp.y-=.8;\n        float stripesd=box(rp,vec3(6,.5,.15))-.02;\n        c=mix(c,vec3(1,.5,.1)/4.,linstep(.01,0.,stripesd));\n\n\t\t// Apply some directional light.\n        c*=mix(vec3(1,1,.8)*.9,vec3(1),smoothstep(.3,.31,l));\n    }\n    \n    return c;\n}\n\n\n// Hash function from IQ.\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\tfragColor.a = 1.;\n\n    fragColor.rgb = vec3(0);\n    \n    // Toroidal shift for anti-aliasing samples.\n    float hashindex=fragCoord.x+fragCoord.y*957.;\n    vec2 uvshift=vec2(hash(hashindex*2.),hash(hashindex*2.+1.));\n    \n    // Anti-aliasing loop.\n    for(int y=0;y<AA;++y)\n        for(int x=0;x<AA;++x)\n        {\n            // Get a filter kernel samplepoint. Here a tent filter is used.\n            vec2 uv=fract(vec2(float(x)+.5,float(y)+.5)/float(AA)+uvshift);\n            vec2 offset = tent(uv);\n            \n            // Sample the scene.\n\t\t    fragColor.rgb += clamp(sampleScene(fragCoord + offset), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    \n    // Gamma correction.\n    fragColor.rgb=pow(fragColor.rgb,vec3(1./2.2));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[136, 158, 180, 180, 229], [231, 291, 317, 317, 412], [414, 474, 500, 500, 586], [588, 622, 642, 642, 1416], [1418, 1440, 1469, 1469, 1790], [1792, 1806, 1823, 1823, 1854], [1856, 1910, 1950, 1950, 1989], [1991, 2008, 2027, 2027, 2496], [2498, 2536, 2556, 2556, 2648], [2650, 2708, 2728, 2728, 2778], [2780, 2780, 2810, 2810, 4953], [4956, 4982, 5003, 5003, 5042], [5044, 5044, 5101, 5101, 5875]]}
{"id": "ldyBWy", "name": "Ray marching practice 2", "author": "lnae", "description": "more weird tests", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 119, "date": "1530216257", "time_retrieved": "2024-06-20T19:15:23.967269", "image_code": "#define PI 3.14159\n#define STEPS 64.\n#define EPS 0.0001\n#define EPSN 0.005\n\nmat2 rot(float angle){\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat distCube(vec3 pos, float radius){\n\treturn length(max(abs(pos) - radius, 0.)) - 0.05 * ((0.5 * sin(iTime + 5. * pos.y) + 0.5));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(vec3 pos){\n    //slightly tilt the scene\n    pos.yz = rot(0.4) * pos.yz;\n    \n    //rotate\n    pos.xz = rot(iTime + sin(iTime) + 0.75) * pos.xz;\n    \n    vec3 posCube = pos;\n    //twist\n    posCube.xz = rot(iTime + sin(iTime + 5. * posCube.y) + 0.75) * posCube.xz;\n    \n    //repeat around y axis\n    float angle = atan(posCube.z, posCube.x);\n    float r = length(posCube.xz);    \n   \tfloat div = PI / 8.;\n    angle = abs(mod(angle, div) - 0.5 * div);\n    posCube.x = r * cos(angle);\n    posCube.z = r * sin(angle);\n    \n    posCube.xz = rot(PI / 4.) * posCube.xz;    \n    \n    //twisted rounded cube\n    float dist = distCube(posCube, 0.15);\n    \n    //repeat without twisting for the spheres\n    angle = atan(pos.z, pos.x);\n    float q = floor(angle / div);\n    angle = abs(mod(angle, div) - 0.5 * div);\n    pos.x = r * cos(angle);\n    pos.z = r * sin(angle);\n    \n    //aggressive spheres\n    float tr = abs(0.25 * sin(2.5 * sin(0.5 * iTime + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(1. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 1.)) + 0.05, 0.)), 0.02 * (mod(q, 2.) + 0.5)));    \n    dist = min(dist, distSphere((pos - vec3(2. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 0.8)) + 0.05, 0.)), 0.025 * (mod(q + 1., 2.) + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(3. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 0.5)) + 0.05, 0.)), 0.03 * (mod(q, 2.) + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(4. * tr + 0.25, 0.15 * sin(3. * sin(iTime + 0.2)) + 0.05, 0.)), 0.035 * (mod(q + 1., 2.) + 0.5)));\n\n\treturn dist;\n}\n\nvec3 getNormal(vec3 pos){\n\treturn normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.) - distScene(pos - vec3(EPSN, 0., 0.))),\n                         distScene(pos + vec3(0., EPSN, 0.) - distScene(pos - vec3(0., EPSN, 0.))),\n                         distScene(pos + vec3(0., 0., EPSN) - distScene(pos - vec3(0., 0., EPSN)))));\n}\n\nvec3 render(vec2 uv){\n\tvec3 eye = vec3(0., 0., 3.);\n    vec3 ray = normalize(vec3(uv, 0.) - eye);\n    vec3 col = vec3(0.2);\n   \n    //raymarch\n    vec3 pos = eye;\n    float s, dist;\n    bool hit = false;\n    for(s = 0.; s < STEPS; s++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n        \tbreak;\n        }\n        pos += dist * ray;\n    }\n    \n    //color\n    if(s < STEPS) col = 0.5 * getNormal(pos) + 0.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[76, 76, 98, 98, 163], [165, 165, 204, 204, 299], [301, 301, 342, 342, 374], [376, 376, 402, 432, 1922], [1924, 1924, 1949, 1949, 2251], [2253, 2253, 2274, 2274, 2692], [2694, 2694, 2751, 2751, 2878]]}
{"id": "ldyBz3", "name": "dithering 001", "author": "bananoid", "description": "dithering", "tags": ["dithering"], "likes": 0, "viewed": 92, "date": "1529742340", "time_retrieved": "2024-06-20T19:15:24.409860", "image_code": "float luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nconst float numColors = 6.0;\nconst float numPixel = 64.0;\n\nconst float err_7_16 = .4375;\nconst float err_3_16 = .1875;\nconst float err_5_16 = .3125;\nconst float err_1_16 = .0625;\n    \nvec3 colorAt(vec2 uv){\n\t// Time varying pixel color\n\t//return 0.5 + 0.5*cos(iTime*1.0 + uv.xyx * 10.0);\n    vec3 col;\n    float w = distance(uv, vec2(0.5)); \n    col.r = cos(w * 10.012 + iTime * 0.1513) * 0.5 + 0.5;\n    col.g = cos(w * 7.0545 + iTime * 0.2431) * 0.5 + 0.5;\n    col.b = cos(w * 8.066 + iTime * 0.31345) * 0.5 + 0.5;\n    \n    //return vec3(col.r);\n    return col;\n}\n\nvec2 qPos(vec2 pos){\n\treturn round(pos * numPixel) / numPixel;\n}\n\nvec3 qColor(vec3 col){\n    return round(col * numColors) / numColors;\n}\n\nvec3 errorAt(vec2 qUV){\n\tvec3 col = colorAt(qUV);\n    vec3 newCol = qColor(col);  \n\tvec3 error = col - newCol;\n    //return qColor(error);\n    return error;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 qUV = qPos(uv);\n\t\n    vec3 col = colorAt(qUV);\n    vec3 orgCol = qColor(col); \n    \n    float r = random(qUV);\n    col = mix(col,vec3(r),0.4);\n    vec3 newCol = qColor(col);\n    \n\t//vec3 error = col - newCol;\n    \n    //oldpixel  := pixel[x][y]\n    //newpixel  := find_closest_palette_color(oldpixel)\n    //pixel[x][y]  := newpixel\n    //quant_error  := oldpixel - newpixel\n    //pixel[x + 1][y    ] := pixel[x + 1][y    ] + quant_error * 7 / 16\n    //pixel[x - 1][y + 1] := pixel[x - 1][y + 1] + quant_error * 3 / 16\n   \t//pixel[x    ][y + 1] := pixel[x    ][y + 1] + quant_error * 5 / 16\n    //pixel[x + 1][y + 1] := pixel[x + 1][y + 1] + quant_error * 1 / 16\n    //float qP = 1.0/numPixel ;\n          \n\n    \n    //newCol /=4.0;\n    //newCol = dither8x8(qPos(uv), col2);\n    \n    orgCol = mix(orgCol, newCol , floor(uv.x*2.0) );\n    fragColor = vec4(orgCol,1.0);\n    \n    //newCol = mix(vec3( 0.6, 0.0, 0.1), vec3( 0.95, 0.3, 0.0) , newCol.r);\n    \n    fragColor = vec4(newCol,1.0);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 74], [76, 76, 100, 100, 154], [156, 156, 180, 180, 287], [473, 473, 495, 576, 853], [855, 855, 875, 875, 919], [921, 921, 943, 943, 992], [994, 994, 1017, 1017, 1152], [1154, 1154, 1211, 1261, 2298]]}
{"id": "ldyfDD", "name": "curvature average", "author": "mikoval", "description": "curvature average", "tags": ["fractalmandlebrot"], "likes": 11, "viewed": 212, "date": "1528867420", "time_retrieved": "2024-06-20T19:15:24.409860", "image_code": "#define iteration_holder 300\n#define escape_holder 100.0\nfloat zoom = 8000.463325567321 ;\nvec2 focusPoint = vec2(-0.3160039610412624, -0.6428171368132422);\n\nvec3 image1(float v, float l){\n\tvec3 col;\n    \n \n    col.r =  0.5 + 0.5 * sin(3.0 * iTime + l / 3.0) ;\n    \n  \n    col.g = 0.5 + 0.5 * sin( 6.0 * sin(iTime) + 10.0 * cos(v * 10.0 / log(l)));\n    \n    col.b = 0.5 + 0.5 * sin(4.0 * sin(iTime) + 10.0 * cos(v * v * 10.0 / log(l)));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float izoom = pow(1.001, zoom + 4000.0 * sin(iTime/2.0) );\n\n    vec2 z = vec2(0.0);\n\n    vec2 c = focusPoint + (uv * 4.0 - 2.0)  * 1.0 / izoom ;\n\n    c.x *= iResolution.x / iResolution.y;\n\n    vec2 p = z;\n\n\n\n    float l;\n    float sum = 0.0;\n    float sum2 = 0.0;\n\n    float sum3 = 0.0;\n    float sum4 = 0.0;\n\n    int skip = 0;\n\n    float min_dist = 10000.0;\n    for( int i=0; i<iteration_holder; i++ )\n    {\n        l++; \n        if( length(z)>escape_holder) break;\n        p = z;\n        vec2 t = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y );\n        z = t + c;\n\n        min_dist = min(min_dist, length(z-vec2(-0.8181290, -0.198848)));\n        sum2 = sum;\n        sum4 = sum3;\n        if ((i>skip)&&(i!=00-1)) {\n\n            float mp=length(t);\n            float m = abs(mp  - length(c)  );\n            float M = mp + length(c);\n\n            float curve1 = 0.5 + 0.5 * sin(10.0 * sin(iTime/20.0) + 4.0  * atan(z.x, z.y));\n            float curve2 = 0.5 + 0.5 * sin(10.0 * sin(iTime) * atan(z.x, z.y));\n            sum += 1.0 * curve1;\n            sum3 +=  1.0 * curve2;\n        }\n\n    }\n\n    sum = sum / (l );\n    sum2 = sum2 / (l - 1.0);\n\n    sum3 = sum3 / (l );\n    sum4 = sum4 / (l - 1.0);\n\n    \n    \n    \n    l = l + 1.0 + 1.0/log(2.0) * log(log(100.0)/ log(sqrt(dot(z,z))));\n    float d = l - floor(l);\n\n\n    float r = sum * d + sum2 * (1.0 - d);\n\n\n\n\n    \n\t\n\n\n    vec3 finalColor = image1(r, l);\n\n    \n\n\n    if(l > (float(iteration_holder) - 1.0)){\n         fragColor = vec4(vec3(0.0), 1.0);\n    }\n    else{\n         fragColor = vec4(finalColor, 1.0);\n    }\n\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldyfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[157, 157, 187, 187, 458], [460, 460, 517, 517, 2127]]}
{"id": "lscczl", "name": "The Universe Within", "author": "BigWIngs", "description": "Been reading up on psychedelics and got inspired. Put fullscreen, make sure sure you have sound and stare at it until the end! Use mouse to move.", "tags": ["psychedelic", "universe", "brain", "trip", "flythrough", "neurons", "network", "blockchain", "consciousness", "spiritual", "mystic", "multiverse"], "likes": 318, "viewed": 17449, "date": "1529463361", "time_retrieved": "2024-06-20T19:15:25.252388", "image_code": "// The Universe Within - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// After listening to an interview with Michael Pollan on the Joe Rogan\n// podcast I got interested in mystic experiences that people seem to\n// have when using certain psycoactive substances. \n//\n// For best results, watch fullscreen, with music, in a dark room.\n// \n// I had an unused 'blockchain effect' lying around and used it as\n// a base for this effect. Uncomment the SIMPLE define to see where\n// this came from.\n// \n// Use the mouse to get some 3d parallax.\n\n// Music - Terrence McKenna Mashup - Jason Burruss Remixes\n// https://soundcloud.com/jason-burruss-remixes/terrence-mckenna-mashup\n//\n// YouTube video of this effect:\n// https://youtu.be/GAhu4ngQa48\n//\n// YouTube Tutorial for this effect:\n// https://youtu.be/3CycKKJiwis\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": "4s2SR3", "previewfilepath": "https://soundcloud.com/jason-burruss-remixes/terrence-mckenna-mashup", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jason-burruss-remixes/terrence-mckenna-mashup", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscczl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1012, 1031, 1050, 1050, 1185], [1187, 1187, 1229, 1229, 1386], [1388, 1388, 1426, 1426, 1452], [1454, 1454, 1494, 1494, 1541], [1543, 1543, 1592, 1592, 1708], [1710, 1710, 1747, 1747, 1961], [1963, 1963, 2006, 2006, 2863], [2865, 2865, 2922, 2922, 3924]]}
{"id": "lsGBDh", "name": "Sphere-traced glass attempt", "author": "MacSlow", "description": "Trying out glass in a sphere-tracing setup. Not very efficient, not fully correct, but the best I could sort out at the moment... best \"wing it\"-effort so to speak :)", "tags": ["3d", "glass", "spheretracing", "fresnel"], "likes": 7, "viewed": 583, "date": "1528554381", "time_retrieved": "2024-06-20T19:15:26.931301", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// some thing in a sliced box - more experimenting with boolean operations\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 64;\nconst float EPSILON = .000125;\nconst float STEP_BIAS = .75;\n\nstruct HitResult {\n\tfloat dist;\n\tint materialId;\n};\n\nstruct Material {\n    vec3 diffuse;\n    bool doesReflect;\n    bool doesRefract;\n    float ior;\n};\n\nfloat sdTerrain (in vec3 p, in float height)\n{\n    float h = .5*texture (iChannel0, .1*p.xz).r;\n    h += .25*texture (iChannel0, .2*p.xz).r;\n    h += .125*texture (iChannel0, .4*p.xz).r;\n    h += .0625*texture (iChannel0, .8*p.xz).r;\n    h /= (.5 + .25 + .125 + .0625);\n    h += height;\n    return p.y - .0625*h*.25;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\n\treturn mat2 (c, s, -s, c);\n}\n\nHitResult scene (in vec3 p)\n{\n\tfloat ground = sdTerrain (p, -22.);\n\n\tvec3 boxCenter = p + vec3 (.0, -.5, .0);\n\tboxCenter.xy *= r2d(60.*iTime);\n\tboxCenter.yz *= r2d(-30.*iTime);\n\tboxCenter.zx *= r2d(40.*iTime);\n\tfloat outterBox = sdBox (boxCenter, vec3 (.4), .05);\n\tfloat innerBox = sdBox (boxCenter, vec3 (.375), .05);\n\toutterBox = max (-innerBox, outterBox);\n\t\n\tvec3 cutterBoxCenter = p + vec3 (.0, -.2, .0);\n\tcutterBoxCenter.xy *= r2d(20.*iTime);\n\tcutterBoxCenter.yz *= r2d(40.*iTime);\n\tcutterBoxCenter.y += .4*cos (iTime);\n\tcutterBoxCenter.y = mod (cutterBoxCenter.y + .1, .2) - .1;\n\tfloat cutterBoxes = sdBox (cutterBoxCenter, vec3 (1., .035, 1.), .0);\n\toutterBox = max (outterBox, cutterBoxes);\n\n\tvec3 ballCenter = p + vec3 (.0, -.5, .0);\n\tfloat warp = .2 + .1*(.5+.5*cos (20.*ballCenter.y + 5.*iTime));\n\tfloat ball = length (ballCenter) - warp;\n\n\tHitResult result = HitResult (.0, -1);\n\tresult.dist = min (ball, min (outterBox, ground));\n\tresult.materialId = result.dist == outterBox ? 0 : (result.dist == ground ? 2 : (result.dist == ball ? 1 : -1));\n\n\treturn result;\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, inout int id)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tint i = 0;\n\tfor (; i < MAX_ITER; ++i) {\n\t\tHitResult result = scene (ro + t*rd);\n\t\td = result.dist;\n\t\tid = result.materialId;\n\t\tif (abs (d) < EPSILON*(1. + .125*d)) break;\n\t\tt += d*STEP_BIAS;\n\t}\n\n\treturn t;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n\tvec2 e = vec2 (epsilon, .0);\n\tfloat d = scene (p).dist;\n\treturn normalize (vec3 (scene (p + e.xyy).dist,\n\t\t\t\t\t\t\tscene (p + e.yxy).dist,\n\t\t\t\t\t\t\tscene (p + e.yyx).dist) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n    vec3 rd = normalize (lPos - p);\n    float result = 1.;\n    float t = .1;\n    float ph = 1e10;\n    for (int i = 0; i < 64; i++) {\n        float h = scene (p + .01*n + t * rd).dist;\n        if (h < .00001) return .0;\n        float y = h*h/(2.*ph);\n        float d = sqrt (h*h - y*y);\n        result = min (result, 10.*d/max (.0, t - y));\n        ph = h;\n        t += h*.5;\n    }\n\n    return result;\n}\n\nMaterial materials[4] = Material[4] (Material (vec3 (1., .1, .2), false, true, 1./1.33),\n\t\t\t\t\t\t\t         Material (vec3 (.3, 1., .2), true, false, 1.0),\n\t\t\t\t\t\t\t         Material (vec3 (.75, .85, .95), true, false, 1.0),\n\t\t\t\t\t\t\t         Material (vec3 (1., .5, .25), false, false, 1.0));\n\nvec3 shade (in vec3 ro,\n\t\t\tin vec3 rd,\n\t\t\tin float d,\n\t\t\tin vec3 n,\n\t\t\tin int matId,\n\t\t\tin vec3 lPos,\n\t\t\tin vec3 lCol)\n{\n\tvec3 p = ro + d*rd;\n\tvec3 l = normalize (lPos - p);\n\tfloat diffuse = max (dot (l, n), .0);\n\tfloat sha = shadow (p, n, lPos);\n\tfloat lDist = distance (lPos, p);\n\tfloat attenuation = 2. / (lDist*lDist);\n\tvec3 diffTerm = sha*diffuse*lCol*attenuation;\n\n\tvec3 h = normalize (l - rd);\n\tfloat specular = pow (max (dot (n, h), .0), 20.);\n\tvec3 specColor = vec3 (1.);\n\tvec3 specTerm = (sha > .1) ? attenuation*specular*specColor : vec3 (.0);\n\n\treturn diffTerm * materials[matId].diffuse + specTerm;\n}\n\nvec3 shadeReflect (in vec3 ro,\n\t\t\t       in vec3 rd,\n\t\t\t       in float d,\n\t\t\t       in vec3 n,\n\t\t\t       in int matId,\n\t\t\t       in vec3 lPos,\n\t\t\t       in vec3 lCol)\n{\n    vec3 base = shade (ro, rd, d, n, matId, lPos, lCol);\n\n    vec3 p = ro + d*rd;\n\tvec3 l = normalize (lPos - p);\n\tfloat diffuse = max (dot (l, n), .0);\n\tfloat sha = shadow (p, n, lPos);\n\tfloat lDist = distance (lPos, p);\n\tfloat attenuation = 2. / (lDist*lDist);\n\tvec3 diffTerm = sha*diffuse*lCol*attenuation;\n\n\tvec3 h = normalize (l - rd);\n\tfloat specular = pow (max (dot (n, h), .0), 20.);\n\tvec3 specColor = vec3 (1.);\n\tvec3 specTerm = (sha > .1) ? attenuation*specular*specColor : vec3 (.0);\n\n\treturn base + diffTerm * materials[matId].diffuse + specTerm;\n}\n\nvec3 camera (in vec3 ro, in vec3 aim, in float zoom, in vec2 uv)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = ro + forward*zoom;\n\n\treturn normalize (center + uv.x*right + uv.y*up - ro);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3 (2.*cos (iTime), .7, 2.*sin (iTime));\n\tvec3 rd = camera (ro, vec3 (.0, .3, .0), 1.5, uv);\n\n\tvec3 lPos1 = vec3 (1.);\n\tvec3 lCol1 = vec3 (.975, .95, .925);\n\tvec3 lPos2 = vec3 (1., 2., -1.);\n\tvec3 lCol2 = vec3 (.925, .95, .975);\n\n\tint materialId = 0;\n\tfloat d = raymarch (ro, rd, materialId);\n\tfloat fog = 1. / (1. + d*d*.1);\n\tvec3 p = ro + d*rd;\n\tvec3 n = normal (p, d*EPSILON);\n\tvec3 col = vec3 (.1);\n\tcol += shade (ro, rd, d, n, materialId, lPos1, lCol1);\n\tcol += shade (ro, rd, d, n, materialId, lPos2, lCol2);\n\n    const float airIOR = 1.;\n    const float waterIOR = 1.33;\n    float rZero = pow (((airIOR - waterIOR) / (airIOR + waterIOR)), 2.);\n\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    float cosTheta1 = max (.0, dot (n, lDir1));\n    float cosTheta2 = max (.0, dot (n, lDir2));\n    float fresnel1  = rZero + (1. - rZero) * pow((1. - cosTheta1), 5.);\n    float fresnel2  = rZero + (1. - rZero) * pow((1. - cosTheta2), 5.);\n\n    if (materials[materialId].doesReflect) {\n        vec3 refl = normalize (reflect (rd, n));\n        float refd = raymarch (p + .01*n, refl, materialId);\n        vec3 refp = p + refd*refl;\n        vec3 refn = normal (refp, refd*EPSILON);\n        vec3 refc = shade (p, refl, refd, refn, materialId, lPos1, lCol1);\n        refc += shade (p, refl, refd, refn, materialId, lPos2, lCol2);\n\n        col += fresnel1*fresnel2*.35*refc;\n    }\n\n    if (materials[materialId].doesRefract) {\n        vec3 refractedDir = normalize (refract (rd, n, materials[materialId].ior));\n        float dist = raymarch (p - .125*n, refractedDir, materialId);\n        vec3 refractedHit = p + dist*refractedDir;\n        vec3 refractedHitNormal = normal (refractedHit, dist*EPSILON);\n        col += shade (p, refractedDir, dist, refractedHitNormal, materialId, lPos1, lCol1);\n\t\tcol += shade (p, refractedDir, dist, refractedHitNormal, materialId, lPos2, lCol2);\n\n        if (materials[materialId].doesRefract) {\n            refractedDir = normalize (refract (refractedDir, refractedHitNormal, materials[materialId].ior));\n            dist = raymarch (refractedHit - .125*refractedHitNormal, refractedDir, materialId);\n            refractedHit = refractedHit + dist*refractedDir;\n            refractedHitNormal = normal (refractedHit, dist*EPSILON);\n            col += shade (refractedHit, refractedDir, dist, refractedHitNormal, materialId, lPos1, lCol1);\n            col += shade (refractedHit, refractedDir, dist, refractedHitNormal, materialId, lPos2, lCol2);\n        }\n\n        if (materials[materialId].doesReflect) {\n            vec3 refl = normalize (reflect (refractedDir, refractedHitNormal));\n            float refd = raymarch (refractedHit + .01*refractedHitNormal, refl, materialId);\n            vec3 refp = refractedHit + refd*refl;\n            vec3 refn = normal (refp, refd*EPSILON);\n            vec3 refc = shade (refractedHit, refl, refd, refn, materialId, lPos1, lCol1);\n            refc += shade (refractedHit, refl, refd, refn, materialId, lPos2, lCol2);\n            col += fresnel1*fresnel2*.25*refc;\n    \t}\n    }\n\n\tcol = mix (col, vec3 (.925, .95, .975), pow (1. - 1. / d, 15.));\n\tcol *= fog;\n\tcol = col / (1. + col);\n\tcol *= vec3 (.875, .85, .8);\n\tcol = .1*col + .9*sqrt (col);\n\tcol *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1193, 1239, 1239, 1511], [1513, 1513, 1564, 1564, 1664], [1666, 1666, 1694, 1694, 1800], [1802, 1802, 1831, 1831, 2878], [2880, 2880, 2935, 2935, 3174], [3176, 3176, 3219, 3219, 3395], [3397, 3397, 3448, 3448, 3851], [4141, 4141, 4261, 4261, 4754], [4756, 4756, 4925, 4925, 5486], [5488, 5488, 5554, 5554, 5819], [5821, 5821, 5877, 5877, 9368]]}
{"id": "lsGfDG", "name": "Cosines", "author": "megha_not_so_tiny", "description": "Learning shader writing - 01", "tags": ["cosine"], "likes": 0, "viewed": 53, "date": "1530203284", "time_retrieved": "2024-06-20T19:15:27.137432", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //bring everything in the -0.5 to 0.5 space\n   \tvec2 q = uv - vec2(0.2, 0.5);\n\n    // polar coordinates\t\n    // cos along the circumference of the circle\n    // atan - postion of every point along the circle\n    float r = 0.2 + 0.2* cos(atan(q.x, q.y)*10.0 - 10.0*q.x)*mod(iTime,100.0);\n    //float s = 0.2 + 0.2*sin(r);\n    vec3 col = vec3(0.9, 0.3, 0.0);\n   \n   \n    col *= smoothstep(r, r + 0.1, length(q));\n    // Time varying pixel color\n    //col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    if (pow(q.x,q.y) == pow(q.y,q.x))\n    {\n        col = vec3(1,1,1);\n    }\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2, 2, 59, 109, 796]]}
{"id": "lsGfR3", "name": "LSD scroller (fbm, domain-warp)", "author": "fanatrick", "description": "lazy implementation of this article http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["noise", "fbm", "perlin", "domainwarp"], "likes": 4, "viewed": 186, "date": "1529757540", "time_retrieved": "2024-06-20T19:15:27.137432", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm_do(vec2 uv){\n    vec2 q = vec2( fbm( uv + vec2(0.0+iTime/10.0,0.0+iTime/10.0) ),\n                   fbm( uv + vec2(5.2+iTime/5.0,1.3+iTime/5.0) ) );\n    \n    vec2 r = vec2( fbm( uv + 4.0*q + vec2(1.7+iTime/4.0,9.2+iTime/7.0) ),\n                     fbm( uv + 4.0*q + vec2(8.3-iTime/8.0,2.8+iTime/4.0) ) );\n\n    return (1.0-fbm( uv + 16.0*r ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y -= iTime/16.4;\n    uv.x -= iTime/8.0;\n    fragColor = vec4( fbm_do(uv + vec2(9.68, 4.35)), fbm_do(uv + vec2(3.42, 7.75)), fbm_do(uv + vec2(1.94, 3.16)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGfR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 92], [94, 94, 120, 120, 456], [458, 458, 476, 476, 645], [647, 647, 669, 669, 1002], [1004, 1004, 1060, 1060, 1275]]}
{"id": "lsGfzc", "name": "Dust Light Explosion", "author": "TheRomanOne", "description": "Experimenting with camera settings, split screen, rotation matrices and the smoothstep function.\n", "tags": ["camera", "rotation", "martix", "split"], "likes": 5, "viewed": 261, "date": "1529940696", "time_retrieved": "2024-06-20T19:15:27.894876", "image_code": "// Experimenting with rotation matrices and a split screen.\n// Use mouse to change the position of the separation line\n// on the screen.\n// Number of particles is gridSize³, so feel free to change it\n//\n// Special thanks to BigWIngs\n\n\n#define PI 3.141592654\n\n\n\nfloat gridSize = 7.;\n\n\n\nstruct Globals\n{\n    vec3 origin;\n    vec3 rd;\n    vec3 lookAt;\n};\n\nGlobals globals;\n\nfloat getDistance(vec3 point)\n{\n    return length(cross(point - globals.origin, globals.rd))/length(globals.rd);\n}\n\nfloat drawSphere(vec3 point, float radius, float y)\n{\n    float dis = getDistance(point);\n    float scale = 1. + 0.5*cos(iTime*y * 5.5);\n    return smoothstep(radius, radius - scale,dis ); \n}\n\nvoid init(vec2 uv, vec3 lookAt)\n{\n    globals.lookAt = lookAt;\n    globals.origin = vec3(0, 0, -70.);\n    vec3 camZ = normalize(globals.lookAt - globals.origin);\n    vec3 camX = normalize(cross(vec3(0,1,0), camZ));\n    vec3 camY = cross(camZ, camX);\n    vec3 newuv = vec3(uv, 0.);\n    globals.rd = normalize(newuv.x * camX + newuv.y * camY + camZ);\n}\n\nmat4 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n        1, 0, 0, 0,\n        0, c,-s, 0,\n        0, s, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c, 0, s, 0,\n        0, 1, 0, 0,\n       -s, 0, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateZ(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 translateXYZ(float x, float y, float z)\n{\n    return mat4(\n            1, 0, 0, x,\n            0, 1, 0, y,\n            0, 0, 1, z,\n            0, 0, 0, 1\n        );\n}\n\nvec3 mat4Vec3(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 1.)).xyz;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 col = vec3(0.);\n    float t = (iTime + 14.1)/ 3.;\n    \n    float interval = 20. * (1. + sin(t));\n    float sphereSize = .9 - .4 * cos(t+PI/2.);\n    init(uv, vec3((gridSize - 1.)* interval / 2.));\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    float mouse = mo.x-.5;\n    if (mo.y == 0.)\n        mouse = -0.0025;\n    float line = 0.005;\n    \n    if(uv.x > mouse && uv.x < mouse + line)\n        col = vec3(1., .52, 0.7);\n    else\n        for(float i = 0.; i < gridSize; i++)\n            for(float j = 0.; j < gridSize; j++)\n                for(float k = 0.; k < gridSize; k++)\n                {\n                    vec3 point = vec3(\n                        i*interval,\n                        j*interval,\n                        k*interval\n                    );\n\n                    mat4 matrixStack = mat4(1);\n                    float forX, forY, forZ = 0.;\n                    if(uv.x < mouse)\n                    {\n                        forX = j + k;\n                        forY = i + k;\n                        forZ = j + i;\n                    }\n                    \n                    matrixStack *= rotateX(t + forX);\n                    matrixStack *= rotateY(t + forY);\n                    matrixStack *= rotateZ(t + forZ);  \n                    \n\t\t\t\t\tpoint -= globals.lookAt;\n                    point = mat4Vec3(matrixStack, point);\n                    point += globals.lookAt;\n\n                    vec3 c = 7.*vec3(i, j, k)/gridSize;\n\n                    col += vec3(c*drawSphere(point, sphereSize, k));   \n                }\n    \n    fragColor = vec4(col/2.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 372, 403, 403, 486], [488, 488, 541, 541, 679], [681, 681, 714, 714, 1031], [1033, 1033, 1060, 1060, 1222], [1224, 1224, 1251, 1251, 1413], [1415, 1415, 1442, 1442, 1604], [1606, 1606, 1652, 1652, 1777], [1779, 1779, 1810, 1810, 1849], [1851, 1851, 1908, 1908, 3597]]}
{"id": "lsKBDm", "name": "dripdrop", "author": "lennyjpg", "description": "asdfasdf", "tags": ["asdfasdfasdf"], "likes": 6, "viewed": 434, "date": "1529187178", "time_retrieved": "2024-06-20T19:15:27.894876", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy,\n    f = (uv - 0.5) * 1.5;\n    f.x *= iResolution.x/iResolution.y;\n    vec2 center = iMouse.y>0.0 ? iMouse.xy/iResolution.xy * 4.0 -2. : vec2(0.5) * 4.0 -2.;   \n    float n = atan(f.x,f.y);\n    float angle = atan(f.x,f.y),\n     t = iTime * .3;\n    float  d = distance(center,f);\n    float j = d*3.0;\n    vec2 offset = vec2(sin(j), cos(j) )* 0.5;\n    center*=offset;\n    d = distance(center,f);\n    float e = sin(t*3.0);\n    d += d < e ? -t : t;\n    angle+=e;\n    float big = sin( d*2.5 ),\n     medium = sin(d*7.3)+.7,\n     small = sin(d*123.)+1.1,\n     r = medium - big * small,\n     c = smoothstep(r-.1, r+.91,  sin(t*.37));\n    c = iMouse.z > 0. ? c : 1.-c;\n    O = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 49, 49, 767]]}
{"id": "lsKBDw", "name": "floral", "author": "lennyjpg", "description": "sdfgsdfg", "tags": ["sdfgsdfg"], "likes": 1, "viewed": 340, "date": "1529153633", "time_retrieved": "2024-06-20T19:15:27.894876", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy,\n    f = (uv - 0.5) * 1.5;\n    f.x *= iResolution.x/iResolution.y;\n    float angle = atan(f.x,f.y),\n     t = iTime * .3,\n     d = length(f) - t; \n    float r = sin(d*3.);  \n    float c = smoothstep(r-.1, r+.1, sin(t*3.+angle*5.0));\n    O = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 49, 49, 339]]}
{"id": "lsKfWy", "name": "Jelly Plasma", "author": "_polymath", "description": "Not original but came out well I think", "tags": ["plasma"], "likes": 2, "viewed": 340, "date": "1530356088", "time_retrieved": "2024-06-20T19:15:27.894876", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * 5.0 / iResolution.xy - 1.0;\n    float d = 0.0;\n    for (float i = 0.0; i < 200.0; ++i) {\n        float j = max(0.0, 3.14 - distance(uv, vec2(\n            sin(i + iTime * mod(i * 2633.2363, 0.42623)) * 12.0,\n            cos(i  * 0.617 + iTime * mod(i * 36344.2363, 0.52623)) * 12.0\n        )));\n        d += cos(j);\n     }\n    float r = cos(d * 6.0) * 0.5 + 0.5;\n    float g = cos(d * 3.0) * 0.5 + 0.5;\n    fragColor = vec4(r, g, max(r, g), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 531]]}
{"id": "lsKfzy", "name": "Einfacher Pixelshader", "author": "schnaader", "description": "Einfacher Pixelshader, der die Funktionsweise von Shadertoy demonstrieren soll", "tags": ["simple"], "likes": 0, "viewed": 90, "date": "1529423680", "time_retrieved": "2024-06-20T19:15:27.894876", "image_code": "//     Ausgabe: Farbwert (r,g,b,a), Eingabe: (x,y)-Koordinate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalisierter Koordinaten-Vektor\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Farbwert\n    vec3 col = vec3(uv.x, uv.y, sin(iTime) / 2.0 + 0.5);\n\n    // Neuer Pixelwert\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 62, 119, 160, 333]]}
{"id": "lsVBDh", "name": "Rising stones", "author": "WAHa_06x36", "description": "Playing around with colouring and trying to create a sense of place. Not sure if I actually manage to achieve that, but there are blobs. Use mouse to look around, or maybe VR works? I have no idea.", "tags": ["blobs"], "likes": 11, "viewed": 540, "date": "1528724876", "time_retrieved": "2024-06-20T19:15:28.579850", "image_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\t\n// Mix final noise value\nvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n\n    vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\n\n    vec4 temp = m2 * m * pdotx;\n    vec3 grad = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n    grad += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n \n    return 42.0 * vec4(grad, dot(m4, pdotx));\n}\n\nvec3 getSkyColor(vec3 e) {\n\tfloat y = e.y;\n\tvec4 r = snoise(150.0 * e);\n\ty+=r.w*0.01-r.y*0.005;\n\ty = atan(2.0*y);\n\treturn mix(vec3(1.0,1.0,0.7), vec3(0.5,0.7,0.4), clamp(y + 1.0, 0.0, 1.0))+\n\t\tmix(vec3(0.0), -vec3(0.5,0.7,0.4), clamp(y, 0.0, 1.0));\n}\n\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x), cos(ang.x));\n\tvec2 a2 = vec2(sin(ang.y), cos(ang.y));\n\tvec2 a3 = vec2(sin(ang.z), cos(ang.z));\n\treturn mat3(\n\t\tvec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x),\n\t\tvec3(-a2.y * a1.x, a1.y * a2.y, a2.x),\n\t\tvec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y)\n\t);\n}\n\nfloat distfunc(vec3 p) {\n\treturn (snoise(p + vec3(0.0, -iTime * 0.1, 0.0)).w + length(p) * 0.3) * 0.3;\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 pos, in vec3 dir) {\n\tpos.z -= 4.0;\n    \n    vec3 sky = getSkyColor(dir);\n\n\tvec3 colour = pow(clamp(sky, 0.0, 1.0),vec3(0.75));\n\t\n\tfor (int i = 0; i< 256; i++) {\n\t\tfloat dist = distfunc(pos);\n\t\tif (dist < 0.001) {\n\t\t\tfloat e = 0.01;\n\t\t\tvec3 n = normalize(vec3(dist - distfunc(pos - vec3(e, 0, 0)), dist - distfunc(pos - vec3(0, e, 0)), dist - distfunc(pos - vec3(0, 0, e))));\n\t\t\tvec4 t = snoise(70.0 * (pos + vec3(0.0, -iTime * 0.1, 0.0)));\n\t\t\tcolour = vec3(1.0 - 0.75 * float(i) / 256.0) * (1.0 + 0.3 * -n.y + 0.005 * t.y) * vec3(0.9, 1.0, 0.8);\n\t\t\tbreak;\n\t\t}\n\t\tif (length(pos) > 30.0) break;\n\t\tpos += dir * dist;\n\t}\n\t\n\tfragColor = vec4(colour, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n \tvec2 mouse = iMouse.xy == vec2(0.0) ? vec2(0.5) : iMouse.xy / iResolution.xy;\n    \n\tvec3 ang = vec3(0.0, -(mouse.y - 0.5) * 3.14159265 * 1.0, mouse.x * 3.1415926535 * 2.0);\n\n    vec3 dir = normalize(vec3(p.xy, -2.0 + length(p) * 0.15)) * fromEuler(ang);\n\n    mainVR(fragColor, fragCoord, vec3(0.0), dir);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 58], [59, 59, 86, 86, 134], [136, 136, 156, 156, 2198], [2200, 2200, 2226, 2226, 2450], [2452, 2452, 2478, 2478, 2840], [2842, 2842, 2866, 2866, 2946], [2948, 2948, 3026, 3026, 3659], [3661, 3661, 3717, 3717, 4111]]}
{"id": "lsVBDm", "name": "Moire Zoom", "author": "rkibria", "description": "Not much in there!", "tags": ["patterns", "mini"], "likes": 2, "viewed": 63, "date": "1529537739", "time_retrieved": "2024-06-20T19:15:28.579850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n    fragColor = vec4(sqrt(fract(iTime * iTime / 11. * uv.x * 2222. * uv.y)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 185]]}
{"id": "lsVfDD", "name": "moving rectangle by fract iTime", "author": "guowei", "description": "moving rectangle", "tags": ["rectangle", "moving"], "likes": 1, "viewed": 67, "date": "1528948119", "time_retrieved": "2024-06-20T19:15:28.798022", "image_code": "float inGap(float a, float b, float t) {\n\tif(t >= a && t <= b) return 1.0;\n    return 0.0;\n}\n\nfloat rect(vec2 uv, vec2 startPosition, vec2 widthHeight) {\n    vec2 endPosition = startPosition + widthHeight;\n\tfloat inX = inGap(startPosition.x, endPosition.x, uv.x);\n    float inY = inGap(startPosition.y, endPosition.y, uv.y);\n    \n    return inX * inY;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 startPosition = vec2(0.0, 0.1);\n    vec2 widthHeight = vec2(0.1, 0.15);\n    \n    //startPosition.x += abs(sin(iTime)) / 5.0;\n    startPosition.x += fract(iTime / 10.0);\n    if(startPosition.x + widthHeight.x > 1.0) {\n    \tstartPosition.x = 0.0;\n    }\n    \n    float rectColor = rect(uv, startPosition, widthHeight);\n\n    // Time varying pixel color\n    vec3 col = vec3(rectColor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 40, 40, 92], [94, 94, 153, 153, 353], [355, 355, 412, 462, 955]]}
{"id": "lsVfW1", "name": "Living wax", "author": "MacSlow", "description": "This is a lucky accident, I have to admit that. It started as a variation of https://www.shadertoy.com/view/ldGfD1", "tags": ["3d", "noise", "spheretracing", "pbr"], "likes": 12, "viewed": 685, "date": "1528747940", "time_retrieved": "2024-06-20T19:15:30.246585", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Living wax - lucky accident started from https://www.shadertoy.com/view/ldGfD1\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define MAX_STEPS 96\n#define STEP_BIAS .75\n#define EPSILON .001\n#define PI 3.14159265359\n\nfloat hashn (vec3 p, float t)\n{\n    p = fract (p*.3183099 + .1);\n    p *= 17.;\n    return max (fract (p.x*p.y*p.z*(p.x + p.y + p.z)), 1. - t);\n}\n\nfloat noise (in vec3 x, in float t)\n{\n    vec3 p = floor (x);\n    vec3 f = fract (x);\n    f = f*f*(3. - 2.*f);\n\t\n    return mix(mix(mix( hashn(p+vec3(0,0,0), t), \n                        hashn(p+vec3(1,0,0), t),f.x),\n                   mix( hashn(p+vec3(0,1,0), t), \n                        hashn(p+vec3(1,1,0), t),f.x),f.y),\n               mix(mix( hashn(p+vec3(0,0,1), t), \n                        hashn(p+vec3(1,0,1), t),f.x),\n                   mix( hashn(p+vec3(0,1,1), t), \n                        hashn(p+vec3(1,1,1), t),f.x),f.y),f.z);\n}\n\nfloat smax (in float a, in float b, in float k)\n{    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n    return length (p) - radius;\n}\n\nfloat sdBox (in vec3 p, in vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nvec3 opTwist (in vec3 p)\n{\n    mat2  m = r2d (p.y*p.x*p.z);\n    vec3  q = vec3 (m*p.xz, p.y);\n    return q;\n}\n\nfloat scene (in vec3 p, in float t)\n{\n    vec3 noiseCenter = p;\n    noiseCenter.z -= 2.; \n    vec3 boxCenter = noiseCenter;\n    vec3 ballCenter = noiseCenter + vec3 (.0, .0, 1. + 1.*(.5 + .5*cos(t))); \n\n    noiseCenter += .05*opTwist (.5*p);\n    noiseCenter.xy *= r2d (10.*t);\n    noiseCenter.yz *= r2d (-20.*t);\n    noiseCenter.zx *= r2d (30.*t);\n\n    float variation = 6. + 4.*(.5 + .5*cos (14.*t));\n    vec3 offset = vec3 (-5.,-1., 1.)*t*.5;\n    float f = 3. + 2.5*(.5 + .5*cos(.5*t));\n    float structure = noise (f*noiseCenter + offset, variation) - .65 + (sin (t) + 1.)*.05;\n\n    float box = sdBox (boxCenter, vec3 (6.));\n    float ball = sdSphere (ballCenter, 1.5 + .5*(.5 + .5*cos (t)));\n    ball = min (ball, sdSphere (ballCenter + vec3 (.0, .0, -1.5), 1.5 + .5*(.5 + .5*cos (t))));\n    structure = smax (-ball, structure*.5, .25);\n\n    return smax (box, structure, .25);\n}\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec3 normal (vec3 p, float epsilon, in float t)\n{\n    float d = scene (p, t);\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene(p + e.xyy, t),\n                            scene(p + e.yxy, t),\n                            scene(p + e.yyx, t)) - d); \n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in float t)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON, t);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo = vec3 (.4);\n    float metallic = .2;\n    float roughness = .1;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.5, .2, .1);\n    lightColors[1] = vec3 (.1, .3, .5);;\n\n    vec3 lightPositions[2];\n    float c = cos (t);\n    float s = sin (t);\n    lightPositions[0] = vec3 (-.5*c, -.5*s, -.1);\n    lightPositions[1] = vec3 (.5*c, .5*s, 1.);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (.04);\n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3 (.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for (int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize (lightPositions[i] - p);\n        vec3 H = normalize (V + L);\n        float dist = distance (p, lightPositions[i]);\n        float attenuation = 2./(dist*dist);\n        vec3 radiance = lightColors[i]*attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX (N, H, roughness);\n        float G = geomSmith (N, V, L, roughness);\n        vec3 F = fresnelSchlick (max (dot (H, V), .0), F0, roughness);\n\n        vec3 kS = F;\n        kD = vec3 (1.) - kS;\n        kD *= 1. - metallic;\n        \n        vec3 nominator = NDF * G * F;\n        float denominator = 4. * max (dot (N, V), .0) * max (dot (N, L), .0);\n        vec3 specular = nominator / max (denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max (dot (N, L), .0);                \n        Lo += (kD*albedo/PI + specular)*radiance*NdotL;\n    }\n\n    vec3 ambient = kD * albedo;\n\n    return ambient + Lo;\n}\n\nfloat trace (in vec3 o, in vec3 r)\n{\n    float t = .0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n       vec3 p = o + r*t;\n       float d = scene (p, iTime);\n       t += d*STEP_BIAS;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // set up view-ray/\"camera\"\n    vec3 r = normalize (vec3 (uv, .75));\n    vec3 o = vec3 (0.);\n\n    // determine pixel-color\n    float d = trace (o, r);\n    vec3 color = shade (o, r, d, iTime);\n\n    // tone-map, gamma-correct, \"fog\"\n    color = color / (1. + color);\n    color = pow (color, vec3 (1./2.2));\n    color *= 2.3 - d*.5;\n\n    fragColor = vec4 (color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1052, 1083, 1083, 1196], [1198, 1198, 1235, 1235, 1743], [1745, 1745, 1794, 1794, 1874], [1876, 1876, 1921, 1921, 1955], [1957, 1957, 1993, 1993, 2078], [2080, 2080, 2108, 2108, 2222], [2224, 2224, 2250, 2250, 2333], [2335, 2335, 2372, 2372, 3217], [3219, 3219, 3279, 3279, 3532], [3534, 3534, 3593, 3593, 3701], [3703, 3703, 3774, 3774, 3985], [3987, 3987, 4057, 4057, 4137], [4139, 4139, 4188, 4188, 4405], [4407, 4407, 4468, 4468, 6304], [6306, 6306, 6342, 6342, 6509], [6511, 6511, 6568, 6604, 7080]]}
{"id": "lsyBDD", "name": "Mengerbob Tesseractpants", "author": "chantecleer", "description": "just a fractal made from others on here :)", "tags": ["fractal"], "likes": 5, "viewed": 171, "date": "1528853835", "time_retrieved": "2024-06-20T19:15:30.246585", "image_code": "#define asgt(i) abs(sin(i * iTime))\n#define acgt(i) abs(cos(i * iTime))\n#define sgt(i) sin(i * iTime)\n#define cgt(i) cos(i * iTime)\n#define A 2. * iTime\n#define Giter 6\n#define MaxSteps 20\n#define MinimumDistance 0.0009\n#define Iterations 10\n#define Offset vec3(0.92858,0.92858,0.32858)\n\n\nfloat DE(in vec3 z) \n{\n    float Scale = 2.0 + 1.2*asgt(0.1);\n    Scale += 0.2*sgt(1.);\n\n\tz  = abs(2.-mod(z,4.0));\n\n    z.x *= (1. - 0.01*sgt(1.));\n    z.y *= (1. + 0.01*cgt(1.0));\n    z.z *= (1. + 0.01*sgt(1.0));\n\n\tfloat d = 10.0;\n\tfor (int m = 0; m < Iterations; m++) {\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(2.*Scale-1.);\n\t\tif( z.z < -0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\n        d = min(d, length(z) * pow(Scale, float(-m)-1.0));\n\t}\n\n\treturn d-0.001;\n}\n    \n\nvec3 Glow(vec3 z, float b){\n    z = fract( z * .2) * 2. -1.; \n\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    return z;\n}\n\n\nvec3 fog(float a,vec3 b,float c){ \n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c );\n}\n\n\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e=(fog( .1, abs(fr), d)*1. +\n            fog( .1, vec3(length( fr.yz ), length( fr.zx ), length( fr.xy )), d) * 5.0 \n            * (sin( A * vec3(2.1, 1.3, 1.7) + b*10.) + 1.)); \n\n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( .5 -c *(200.+500.*asgt(1.)) / d, 0. ) / d * 70.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n\n    float speed = 0.5;\n \n    vec3 base = vec3(0.1, 0.3*sgt(0.1), 0.3*cgt(0.1)) * speed;\n\n    vec3 camPos = 0.2*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos);\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir);\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color; float totalDistance, distance, v;\n\n    for(int i = 0; i < 64; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = DE(pos);        \n        v = sin( A * .1 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance + .001; \n        //color += ( 0.5*W( x, v, distance, 1.) ) * (distance + 0.001);\n        color +=  0.2*W( x, v, distance, 1.)  * (distance + 0.001)+ \n                   0.2*W( x, v, distance, 21.0 )  * (distance + 0.002)+ \n                   1.2*W( x, v, distance, 51.0 )  * (distance + 0.004);        \n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[289, 289, 311, 311, 852], [859, 859, 886, 886, 1062], [1065, 1065, 1098, 1098, 1152], [1155, 1155, 1195, 1195, 1490], [1493, 1493, 1549, 1549, 2648]]}
{"id": "lsyBR3", "name": "Sub Earth Tunnel", "author": "aiekick", "description": "Sub Earth Tunnel", "tags": ["tunnel", "earth", "sub"], "likes": 8, "viewed": 658, "date": "1529708774", "time_retrieved": "2024-06-20T19:15:31.216503", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 m1;\nmat3 m2;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08 + cos(t*0.1)*2.), sin(t*0.12 + sin(t*0.05)*2.5)) * 4.;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length(max(abs(p.x), abs(p.y)) - p.z);\n}\n\nfloat map(vec3 p)\n{\n    vec2 pa = path(p.z); \n\tfloat a = pa.x * pa.y * 0.1;\n\t\n    p.xy -= pa;\n    p.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n\tvec3 qm1 = p*m1, qm2 = p*m2;\n\t\n    float d0 = min(pattern(qm1), pattern(qm2));\n    float d1 = min(pattern(qm1*3.), pattern(qm2*2.));\n    \n   \tfloat dist0 = (1.-clamp(d0,0.,1.));\n\tfloat dist1 = (1.-clamp(d1,0.,1.))*d0;\n\n    float di0 = length(p.xy); // tunnel\n    float di1 = abs(cos(p.x*0.3)*p.y); // planes\n    float di2 = 1.7 - 0.4 * cos(p.z*0.1) - abs(cos(p.x*0.5)*p.x + sin(p.y*0.5)*p.y); // planes\n    \n\tp.z *= 0.5;\n\t\n\tvec2 cs = vec2(cos(p.z), sin(p.z)) * 0.5 + 0.5;\n\t\n    return mix(di2, 1.47-mix(di0, di1, cs.y), cs.x) - dist0*0.75 - dist1*2.25;\n}\n\nvec3 nor( vec3 pos, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint // ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    for (int i=0;i<8;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*8.); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s);\n\treturn map(p - n * s);\n}\n\n// from shane\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 0.1) * 0.5; \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n    m1 = mx * my * mz;\n    m2 = m1 * m1;\n\t\n    float time = iTime * 5.;\n    \n    vec3 cu = vec3(0,1,0);\n  \tvec3 cv = vec3(path(time + .1),time + .1);\n\t\n  \tvec2 uv = (g+g-si)/si.y;\n    \n    vec3 ro = vec3(path(time),time);\n    vec3 lp = vec3(path(time + 3.),time + 3.);\n    \n\tvec2 fov = vec2(0.75,0.9);\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n  \tvec3 rd = normalize(z + uv.x*x*fov.x + uv.y*y*fov.y);\n    \n    float s = 1.;\n    float d = 0.;\n\t\n\tfor(int i=0;i<80;i++)\n    {      \n        if (d*d/s>1e5) break;\n        d += s = map(ro+rd*d) * .6;\n\t}\n\t\n    vec3 p = ro+rd*d;\n    vec3 n = nor(p, 0.01);\n        \n    f = shade(ro, rd, d, lp);\n\t\n\tf = f.zyww + f.x*0.2;\n\n    float fog = 1.0-exp( -0.01*d*d );\n    f = mix( f, vec4(0.8), fog);\n       \n\tf = mix(f, f.grba, sin(fog*5.));\n   \tfragColor = sqrt(f*f*f*1.5);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 139, 164, 164, 222], [223, 223, 248, 248, 306], [307, 307, 332, 332, 390], [411, 411, 431, 431, 512], [514, 514, 537, 537, 615], [617, 617, 636, 636, 1319], [1321, 1321, 1352, 1352, 1555], [1557, 1778, 1806, 1806, 2131], [2133, 2215, 2272, 2272, 2463], [2465, 2465, 2501, 2501, 2547], [2549, 2563, 2614, 2614, 2788], [2790, 2804, 2867, 2867, 3229], [3231, 3231, 3279, 3279, 4186], [4188, 4188, 4240, 4240, 5276]]}
{"id": "lsyBWD", "name": "Coeur", "author": "saidwho12", "description": "inspired from iq's :)", "tags": ["test"], "likes": 1, "viewed": 134, "date": "1529116081", "time_retrieved": "2024-06-20T19:15:31.671006", "image_code": "#define inf 1.e32\n#define pi 3.14159\n#define tau 6.28318\n#define time (.25*iTime)\n#define sqr(x) x*x\n\nmat3 rotY( in float theta ) {\n\tfloat c = cos(theta), s = sin(theta);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\n\nmat2 rot(in float theta) {\n\tfloat c = cos(theta), s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat f( in vec3 p ) {\n    \n#if 1\n    p = rotY(tau*time)*p;\n    p.z *= 1. + .5*(1.-p.y*.5+.5);\n    p.x *= 0.95;\n    p.y -= -.125*pow(length(abs(p.x*1.76)-1.7), 2.0);\n    float d = length(p)-1. - 0.25 * sin(radians(360.0) * iTime) \n        * sin(radians(360.0) * 0.32 * (p.y * exp(-1.0 * fract(iTime))));\n    \n\treturn d*.5;\n#else\n    float d = length(rot(p.y*radians(360.0))*p.xz-vec2(0.5,0))-0.25;\n    return d*.6; // lipschitz artifacts\n#endif\n}\n\nvec3 n( in vec3 p ) {\n    const float e = .0001;\n\treturn normalize(vec3(\n    \tf(vec3(p.x+e, p.yz)) - f(vec3(p.x-e, p.yz)),\n        f(vec3(p.x, p.y+e, p.z)) - f(vec3(p.x, p.y-e, p.z)),\n        f(vec3(p.xy, p.z+e)) - f(vec3(p.xy, p.z-e))\n    ));\n}\n\nconst int iter_max = 256;\nconst float t_min = .01, t_max = 1000., eps = .0001;\nfloat trace( in vec3 o, in vec3 d ) {\n    float t = t_min;\n    int idx = 0;\n    for(int i = 0; i<iter_max; i++) {\n    \tfloat r = f(o+d*t);\n        if(r<eps || !(t<t_max)) {\n            idx = i;\n            break;\n        }\n        t+=r;\n    }\n    if(t>t_max || idx==iter_max)\n    \treturn inf;\n    return t;\n}\n\nvec3 shade( in vec3 o, in vec3 p ) {\n    vec3 lp = vec3(0,.9,2);\n\tvec3 N = n(p);\n    vec3 V = normalize(p-o);\n    vec3 L = normalize(lp-p);\n    vec3 R = reflect(L, N);\n    //return N*.5+.5;\n    return vec3(1,.25,.25)* (0.2 + .6*max(dot(N,L),0.0) + .7*pow(max(dot(R,V),0.0),20.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0,0,3),\n        f = vec3(0,0,-1),\n        u = vec3(0,1,0),\n        r = cross(f,u),\n        d = vec3(f+p.x*r+p.y*u);\n    float t = trace(o, d);\n    vec3 col = vec3(1);\n    if(t != inf)\n     col = shade(o, o+d*t);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[102, 102, 131, 131, 217], [220, 220, 246, 246, 317], [319, 319, 341, 341, 765], [767, 767, 788, 788, 1012], [1093, 1093, 1130, 1130, 1401], [1403, 1403, 1439, 1439, 1685], [1687, 1687, 1744, 1744, 2071]]}
{"id": "lsyfRw", "name": "Art by Numbers IV", "author": "mhnewman", "description": "Inspired by the works of Takashi Murakami", "tags": ["procedural", "art", "takashi", "murakami"], "likes": 32, "viewed": 485, "date": "1528473170", "time_retrieved": "2024-06-20T19:15:31.677154", "image_code": "float border = 0.02;\nfloat aa;\n\nfloat hash(float p) {\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y);\n}\n\nvec2 hash2(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nvec3 drawEye(vec3 background, vec2 pos, vec2 center, float radius, vec3 color) {\n    float r = distance(pos, center);\n    r = (radius - r) / aa + 0.5;\n    return mix(background, color, clamp(r, 0.0, 1.0));\n}\n\nvec3 drawHead(vec3 background, vec2 pos, vec2 center, float radius, vec3 color) {\n    float r = distance(pos, center);\n    float a = clamp((radius - r) / aa + 0.5, 0.0, 1.0);\n    float c = clamp((radius - r - border) / aa + 0.5, 0.0, 1.0);\n    return mix(background, c * color, a);\n}\n\nvec3 drawMouth(vec3 background, vec2 pos, vec2 center1, float radius1, vec2 center2, float radius2, vec3 color) {\n    float r1 = distance(pos, center1);\n    float a1 = clamp((radius1 - r1) / aa + 0.5, 0.0, 1.0);\n    float c1 = clamp((radius1 - r1 - border) / aa + 0.5, 0.0, 1.0);\n    float r2 = distance(pos, center2);\n    float a2 = clamp((radius2 - r2) / aa + 0.5, 0.0, 1.0);\n    float c2 = clamp((radius2 - r2 - border) / aa + 0.5, 0.0, 1.0);\n    return mix(background, c1 * c2 * color, a1 * a2);\n}\n\nvec3 drawPetal(vec3 background, vec2 pos, vec2 center, float radius, vec3 rotation, vec3 color1, vec3 color2) {\n    pos -= center;\n    float r = length(pos);\n    float t = 1.9098593 * atan(pos.y, pos.x) + rotation.x * sin(rotation.y * iTime + 6.2831853 * rotation.z);\n    t = mod(t, 2.0);\n    vec3 color = mix(color1, color2, step(t, 1.0));\n    t = 0.52359878 * (0.5 - abs(mod(t, 1.0) - 0.5));\n    pos = r * vec2(cos(t), sin(t));\n    \n    r = distance(pos, radius * vec2(0.767327, 0.2056046));\n    float a = clamp((0.2056046 * radius - r + 0.5 * border) / aa + 0.5, 0.0, 1.0);\n    float c = clamp((0.2056046 * radius - r - 0.5 * border) / aa + 0.5, 0.0, 1.0);\n    \n    float stem = step(pos.x, 0.767327 * radius);\n    a = mix(a, 1.0, stem);\n    c = mix(c, clamp((pos.y - 0.5 * border) / aa + 0.5, 0.0, 1.0), stem);\n    \n    return mix(background, c * color, a);\n}\n\n#define range(min, max) mix(min, max, hash(id += 0.1))\n#define hsv(hue, sat, val) (val) * (vec3(1.0 - (sat)) + (sat) * (0.5 + 0.5 * cos(6.2831853 * (vec3(hue) + vec3(0.0, 0.33, 0.67)))))\n\nvec3 draw(vec3 color, vec2 pos, vec2 screen, vec2 block, vec2 offset, float level) {\n    block += mod(offset - mod(block, 5.0), 5.0) - 2.0;\n    \n    float id = hash(block);\n    vec2 center = block + vec2(0.1) + 0.8 * hash2(block) - 0.01 * level * screen;\n    vec3 rotation = vec3(range(0.0, 2.0), range(0.0, 0.8), range(0.0, 1.0));\n    float petalHue = range(0.0, 1.0);\n    float petalSat1 = pow(hash(id += 0.1), 0.4);\n    float petalSat2 = pow(hash(id += 0.1), 2.0) * petalSat1;\n    vec3 petal1 = hsv(petalHue, petalSat1, 1.0);\n    vec3 petal2 = hsv(petalHue, petalSat2, 1.0);\n    vec3 mouth = hsv(range(0.0, 1.0), 0.8, 1.0);\n    vec3 left = hsv(fract(2.0 * iTime + hash(id += 0.1)), 0.5, 0.8);\n    vec3 right = hsv(fract(2.0 * iTime + hash(id += 0.1)), 0.5, 0.8);\n    float radius = mix(0.4, 1.4, pow(hash(id += 0.1), 2.0));\n\n    color = drawPetal(color, pos, center, radius, rotation, petal1, petal2);\n    color = drawHead(color, pos, center, 0.4 * radius, vec3(1.0));\n    color = drawEye(color, pos, center + radius * vec2(-0.14, 0.18), 0.05 * radius, left);\n    color = drawEye(color, pos, center + radius * vec2(0.14, 0.18), 0.05 * radius, right);\n    color = drawMouth(color, pos, center, 0.28 * radius, center + radius * vec2(0.0, -0.64), 0.72 * radius, mouth);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = 3.0 * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float t = 0.1 * iTime;\n    vec2 pos = screen + 3.0 * vec2(t + 0.4 * sin(2.0 * t), 2.0 * cos(t));\n    aa = 6.0 / iResolution.y;\n    \n    vec2 block = floor(pos);\n    \n    vec3 color = vec3(0.8, 0.7, 0.9);\n    \n    color = draw(color, pos, screen, block, vec2(0.0, 0.0), 24.0);\n    color = draw(color, pos, screen, block, vec2(2.0, 1.0), 23.0);\n    color = draw(color, pos, screen, block, vec2(4.0, 0.0), 22.0);\n    color = draw(color, pos, screen, block, vec2(3.0, 2.0), 21.0);\n    color = draw(color, pos, screen, block, vec2(4.0, 4.0), 20.0);\n    color = draw(color, pos, screen, block, vec2(2.0, 3.0), 19.0);\n    color = draw(color, pos, screen, block, vec2(0.0, 4.0), 18.0);\n    color = draw(color, pos, screen, block, vec2(1.0, 2.0), 17.0);\n    color = draw(color, pos, screen, block, vec2(2.0, 0.0), 16.0);\n    color = draw(color, pos, screen, block, vec2(4.0, 1.0), 15.0);\n    color = draw(color, pos, screen, block, vec2(3.0, 3.0), 14.0);\n    color = draw(color, pos, screen, block, vec2(1.0, 4.0), 13.0);\n    color = draw(color, pos, screen, block, vec2(0.0, 2.0), 12.0);\n    color = draw(color, pos, screen, block, vec2(1.0, 0.0), 11.0);\n    color = draw(color, pos, screen, block, vec2(3.0, 1.0), 10.0);\n    color = draw(color, pos, screen, block, vec2(4.0, 3.0), 9.0);\n    color = draw(color, pos, screen, block, vec2(2.0, 4.0), 8.0);\n    color = draw(color, pos, screen, block, vec2(0.0, 3.0), 7.0);\n    color = draw(color, pos, screen, block, vec2(1.0, 1.0), 6.0);\n    color = draw(color, pos, screen, block, vec2(3.0, 0.0), 5.0);\n    color = draw(color, pos, screen, block, vec2(4.0, 2.0), 4.0);\n    color = draw(color, pos, screen, block, vec2(3.0, 4.0), 3.0);\n    color = draw(color, pos, screen, block, vec2(1.0, 3.0), 2.0);\n    color = draw(color, pos, screen, block, vec2(0.0, 1.0), 1.0);\n    color = draw(color, pos, screen, block, vec2(2.0, 2.0), 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[32, 32, 53, 53, 185], [187, 187, 207, 207, 327], [329, 329, 349, 349, 502], [504, 504, 584, 584, 711], [713, 713, 794, 794, 996], [998, 998, 1111, 1111, 1499], [1501, 1501, 1612, 1612, 2364], [2554, 2554, 2638, 2638, 3848], [3850, 3850, 3905, 3905, 5903]]}
{"id": "lsyfWD", "name": "Watercolor Blending", "author": "viclw17", "description": "Watercolor Blending effect test.", "tags": ["uv"], "likes": 17, "viewed": 5275, "date": "1528850688", "time_retrieved": "2024-06-20T19:15:31.677154", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = .1;\n    float scale = 0.002;\n    vec2 p = fragCoord * scale;   \n    for(int i=1; i<10; i++){\n        p.x+=0.3/float(i)*sin(float(i)*3.*p.y+iTime*speed)+iMouse.x/1000.;\n        p.y+=0.3/float(i)*cos(float(i)*3.*p.x+iTime*speed)+iMouse.y/1000.;\n    }\n    float r=cos(p.x+p.y+1.)*.5+.5;\n    float g=sin(p.x+p.y+1.)*.5+.5;\n    float b=(sin(p.x+p.y)+cos(p.x+p.y))*.3+.5;\n    vec3 color = vec3(r,g,b);\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 507]]}
{"id": "lt2yzt", "name": "Smooth min and Noise", "author": "tylerbata", "description": "visualizing some noise functions as well as smooth min to try and make a tree like texture\n\nadded simple but crazy expensive AO!", "tags": ["smoothmin"], "likes": 2, "viewed": 231, "date": "1528243315", "time_retrieved": "2024-06-20T19:15:31.677154", "image_code": "#define TEST 1\n#define PI 3.14159265359\n#define MAX_RAY_STEPS 75\n\nfloat steps;\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 heatMap(float greyValue) {   \n\tvec3 heat;      \n    heat.r = smoothstep(0.5, 0.8, greyValue);\n    if(greyValue >= 0.90) {\n    \theat.r *= (1.1 - greyValue) * 5.0;\n    }\n\tif(greyValue > 0.7) {\n\t\theat.g = smoothstep(1.0, 0.7, greyValue);\n\t} else {\n\t\theat.g = smoothstep(0.0, 0.7, greyValue);\n    }    \n\theat.b = smoothstep(1.0, 0.0, greyValue);          \n    if(greyValue <= 0.3) {\n    \theat.b *= greyValue / 0.3;     \n    }\n\treturn heat;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat opB( float a, float b) {\n#if TEST\n    float k = 0.7;//0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);   \n#else\n    const float k  = 80.0;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n#endif\n}\n\nfloat two(vec3 p) {\n    return sdSphere(p - vec3(0.0,1.0,0.0), 1.0);\n}\n\nfloat sum(vec3 pos) {\n\t\n    float val = 0.0;\n    \n    float t = 1.0;\n    \n    float warp = snoise(pos*0.3);\n    vec3 p2 = pos*vec3(1.0,warp*8.0,1.0);//pos + vec3(0.0,warp*8.0,0.0);\n    \n    \n    val += two(pos)*0.4; t *= 2.01;\n    //val += snoise(pos*t)*0.05;\n    //t *= 2.01;\n    //val += snoise(pos*t)*0.125;\n    //t *= 2.01;\n    //t *= 2.01;\n    //t *= 2.01;\n    val += snoise(p2*t)*(val*0.1);\n    \n    return val - 0.08;\n}\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sum(pos), 10.0 ) ); //sdSphere(    pos-vec3( 0.0,1.0, 0.0), 1.0 )\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    steps = 0.0;\n    for( int i=0; i<MAX_RAY_STEPS; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n        steps += 1.0;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat castRayF( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.1;\n    float tmax = 10.0;\n    float t = tmin;\n    for( int i=0; i<128; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float tempT = map( ro+rd*t ).x;\n        if( tempT<precis || t>tmax ) break;\n        t += tempT;\n    }\n    if( t>tmax )t = -1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n\tvec2 eps = vec2( 0.001, 0.0 );\n\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\t\t\t\t map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n    \t\t\t\t map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nmat3 base( in vec3 ww ) {\n    vec3  vv  = vec3(0.0,0.0,1.0);\n    vec3  uu  = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\nvec3 sphereToCart(vec3 r) {\n    return vec3(r.x*sin(r.z)*cos(r.y), r.x*sin(r.z)*sin(r.y), r.x*cos(r.z));\n}\nfloat simpleAO(vec3 p, vec3 n) {\n    mat3 b = base(n);\n    float ao = 0.0;\n    \n    int c = 3;\n    float it = 1.0/float(c*c);\n    \n    for(int y = 0; y < c; y++) {\n        for(int x = 0; x < c; x++) {\n            vec3 rd = sphereToCart( vec3(0.1, (float(x)/4.0)*PI, (float(y)/4.0)*PI) )*b;\n            float t = castRayF(p + rd*0.01, rd);\n            if(t<0.0)ao += it;\n        }\n    }\n    return ao;\n}\n\n\n//IQ's AO\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<2; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 test(vec3 norm) {\n\tvec3 b = vec3(0.545,0.271,0.075);\n    return norm.y*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 10.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, 0.7, 0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    \n    \n    \n    \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 light = vec3(cos(1.0),0.8,sin(1.0));\n    \n    if(m > -0.5) {\n        vec3 pnor = normalize(pos - vec3(0.0,1.0,0.0));\n        \n        float c = max(dot(nor,pnor),0.0);\n        \n        c*= 30.0;\n        \n        m += c;\n        m = 0.0;\n        \n        col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        col = test(nor);\n        \n        if( m<1.5 ) {\n\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n            \n        }\n        \n        float diff = max(dot(nor,light),0.0);\n        \n        float ao = calcAO(pos, nor);\n        \n        col = col*diff*0.6 + col*ao*0.4;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if(uv.x > 0.5) {\n        col = heatMap(steps/float(MAX_RAY_STEPS));\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2yzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[80, 80, 101, 101, 150], [152, 152, 173, 173, 222], [224, 224, 246, 246, 286], [288, 288, 316, 316, 368], [370, 370, 394, 394, 2538], [2540, 2540, 2571, 2571, 2982], [2985, 2985, 3020, 3020, 3046], [3048, 3048, 3078, 3078, 3317], [3319, 3319, 3338, 3338, 3389], [3391, 3391, 3412, 3412, 3817], [3820, 3820, 3845, 3845, 3860], [3863, 3863, 3894, 3894, 3985], [3987, 3987, 4020, 4020, 4046], [4048, 4048, 4078, 4078, 4111], [4114, 4184, 4209, 4209, 4368], [4370, 4370, 4410, 4410, 4787], [4789, 4789, 4831, 4831, 5112], [5114, 5114, 5145, 5145, 5361], [5363, 5363, 5388, 5388, 5568], [5569, 5569, 5596, 5596, 5675], [5676, 5676, 5708, 5708, 6078], [6081, 6091, 6133, 6133, 6432], [6435, 6435, 6487, 6487, 6664], [6667, 6667, 6689, 6689, 6747], [6749, 6749, 6806, 6806, 8223]]}
{"id": "MdGBD1", "name": "Fuzzy Sets: Distance Fields", "author": "ptrgags", "description": "I recently made the observation that fuzzy sets are much like distance fields. Here I experiment with this concept.", "tags": ["distance", "fuzzylogic", "fuzzysets"], "likes": 2, "viewed": 130, "date": "1528590894", "time_retrieved": "2024-06-20T19:15:32.470980", "image_code": "// Center of the screen in pixels and UV coordinates\n#define CENTER (iResolution.xy / 2.0)\n#define CENTER_UV vec2(0.0)\n\n//center of sigmoids for the background\n#define NEAR 0.2\n#define FAR 0.7\n#define WIDTH 0.1\n\n//Center of sigmoids for the mouse\n#define NEAR_MOUSE 0.05\n#define FAR_MOUSE 0.1\n#define WIDTH_MOUSE 0.01\n\n// These parameters control the sine wave.\n#define MID_ANGLE 0.5\n#define SECTOR_SIZE 0.01\n#define ROTATE_FREQ 0.4\n#define TWIST_AMP 0.5\n#define TWIST_FREQ 10.0\n// Not sure if this is the right physics term. This\n// is a multiplier of the phase angle in space.\n#define TWIST_PHASE_VEL 5.0\n// This prevents the sigmoids from having 0 width.\n#define BLUR_BIAS 0.01\n#define BLUR_AMP 0.4\n#define BLUR_FREQ 0.3\n\n// Fuzzy logic operations\n#define NOT(x) (1.0 - (x))\n#define AND min\n#define OR max\n\n// Fuzzy logic hedges\n#define VERY(x) ((x) * (x))\n#define SOMEWHAT sqrt\n\n// I wish this came with GLSL out of the box.\n#define PI 3.141592\n#define TAU (2.0 * PI)\n\n// Compute a fuzzy set for distance to a point.\n// I use sigmoid-shaped boundaries with smoothstep()\n// x is the input point\n// center is the center of the distance field\n// near, far are the center of the sigmoid-like curves that divide the sets.\n// width is the width of the sigmoid-like curves\nvec3 fuzzy_dist(float dist, float near_point, float far_point, float width) {\n    float half_width = width / 2.0;\n    \n    // Make the sigmoid shapes for near and far using smoothstep()\n    float near = smoothstep(near_point + half_width, near_point - half_width, dist);\n    float far = smoothstep(far_point - half_width, far_point + half_width, dist);\n    \n    // We are at a medium distance if we are not near and not far.\n    float mid = AND(NOT(near), NOT(far));\n    \n    // Return the membership for the three categories.\n    return vec3(near, mid, far);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates from the center of the screen.\n    // This accounts for the screen aspect ratio.\n    vec2 uv = (fragCoord - CENTER)/iResolution.y;\n    \n    // Do the same for mouse coordinates. Note that for some reason\n    // Shadertoy only updates the mouse when a button is pressed.\n    vec2 mouse_uv = (iMouse.xy - CENTER)/iResolution.y;\n    \n    // Compute fuzzy sets ====================================\n\n    // Compute the fuzzy set for distance to the center of the screen.\n    float from_center = distance(uv, CENTER_UV);\n    vec3 center_dist = fuzzy_dist(from_center, NEAR, FAR, WIDTH);\n    \n    // Compute the fuzzy set for distance to the mouse\n    float from_mouse = distance(uv, mouse_uv);\n    vec3 mouse_dist = fuzzy_dist(from_mouse, NEAR_MOUSE, FAR_MOUSE, WIDTH_MOUSE);\n    \n    // In principle this is computing the distance from pi radians\n    // around the circle. However, I'm rotating and distorting the\n    // polar coordinates with a sine wave for a cooler effect!\n    // Polar angle\n    float angle = atan(uv.y, uv.x);\n    // Rotate cooordinates\n    float rotate = ROTATE_FREQ * TAU * iTime;\n    // Twist the coordinates with a high-frequency sine wave\n    // in the radial directtion.\n    float twist = TWIST_AMP * sin(\n        TWIST_FREQ * TAU * from_center - TWIST_PHASE_VEL * TAU * iTime);\n    // Apply the transformations\n    float transformed = angle - rotate + twist;\n    // Normalize from 0 (0 radians) to 1 (2 pi radiaans)\n    float normalized = mod(transformed, TAU) / TAU;\n    // Vary the shape of the fuzzy sets for an even cooler effect!\n    // Specifically, stretch/shrink the width of the curves.\n\t// This needs to be a positive number else smoothstep() in my \n    // fuzzy_dist function\n    //will misbehave.\n    float width_blur = BLUR_BIAS + BLUR_AMP + BLUR_AMP * sin(\n        BLUR_FREQ * TAU * iTime);\n    \n    //vec3 angle_dist = fuzzy_dist(normalized, NEAR_ANGLE, FAR_ANGLE, blur);\n    vec3 angle_dist = fuzzy_dist(\n        normalized, \n        MID_ANGLE - SECTOR_SIZE, \n        MID_ANGLE + SECTOR_SIZE, \n        width_blur);\n    \n    // =============================================================\n    // Let's make some fuzzy logic propositions to make some abstract art!\n    \n    // If distance to mouse is very, very medium and distance to the\n    // center of the screeen is somewhat medium, paint a ring.\n    // This ring will only show up inside the middle distance field for \n    float mouse_vv_med = VERY(VERY(mouse_dist.y));\n    float center_s_med = SOMEWHAT(center_dist.y);\n    float ring = AND(mouse_vv_med, center_s_med);\n    \n    // If distance from the center is far or very near, paint a background.\n    float background = OR(center_dist.z, VERY(center_dist.x));\n    \n    // If the angle is medium and the distance to the center of the\n    // screen is somewhat medium, paint it in.\n    float wave = AND(center_s_med, angle_dist.y);\n    \n    // Let's build the image. =======================================\n    \n    // The background is orange.\n    vec4 image = vec4(1.0, 0.5, 0.0, 1.0) * background;\n    \n    \n    // Texture the ring around the mouse.\n    vec4 ring_color = texture(iChannel0, uv);\n    image = mix(image, ring_color, ring);\n    \n    // Draw the sweeping ray in teal\n    vec4 wave_color = vec4(0.0, 1.0, 0.8, 1.0);\n    image = mix(image, wave_color, wave);\n\n    // Output to screen ============================================\n    fragColor = vec4(image);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[973, 1270, 1347, 1347, 1831], [1833, 1833, 1890, 2001, 5341]]}
{"id": "MdGBWw", "name": "Hypnospirals", "author": "rkibria", "description": "Wanted to see if I can derive the maths for spirals correctly.", "tags": ["2d", "spiral"], "likes": 1, "viewed": 83, "date": "1529013803", "time_retrieved": "2024-06-20T19:15:32.470980", "image_code": "#define PI 3.14159265359\n#define TWO_PI (2. * PI)\n\n#define _SPIRAL(a,d,w) (abs(((a) / (d)) - (w)))\nfloat spiral(in float angle, in float dist, in float k, in float max_winding)\n{\n    float v = _SPIRAL(angle, dist, k);\n    for(float i = 1.; i < max_winding; i += 1.)\n    {\n\t    v = min(v, _SPIRAL(angle + i * TWO_PI, dist, k));\n    }\n    return v;\n}\n\nfloat get_angle(in vec2 uv)\n{\n    float uv_angle = atan(uv.y, uv.x);\n    if(uv_angle < 0.0)\n    \tuv_angle += TWO_PI;\n    return uv_angle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) /iResolution.x;\n    \n    float rt = iTime * 0.5;\n    mat2 rmt = mat2(cos(rt), -sin(rt), sin(rt), cos(rt));\n    uv = rmt * uv;\n        \n    vec3 col = vec3(0);\n\n    float r = 0.5 * spiral(get_angle(uv), length(uv), 200. + 149. * sin(iTime), 20.);\n    r = 2.5 * abs(sin(iTime)) - r;\n\n    vec2 uv2 = vec2(uv.x + sin(iTime) * 0.1, uv.y + cos(iTime) * 0.1);\n    float g = 0.5 * spiral(get_angle(uv2), length(uv2), 200. + 149. * sin(iTime), 20.);\n    g = 2.5 * abs(sin(iTime + PI/4.)) - g;\n\n    vec2 uv3 = vec2(uv.x + cos(iTime) * 0.2, uv.y + sin(iTime) * 0.2);\n    float b = 0.5 * spiral(get_angle(uv3), length(uv3), 200. + 149. * sin(iTime), 20.);\n    b = 2.5 * abs(sin(iTime + PI/2.)) - b;\n\n    col = vec3(r, g, b);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[99, 99, 178, 178, 348], [350, 350, 379, 379, 489], [491, 491, 548, 548, 1342]]}
{"id": "MdGBzG", "name": "PurpleFlowII", "author": "Del", "description": "flow", "tags": ["flow"], "likes": 10, "viewed": 600, "date": "1529258958", "time_retrieved": "2024-06-20T19:15:32.470980", "image_code": "// Mellow purple II flow background - Del 17/06/2018\nconst float PI = 3.14159;\n\nvec2 rotate(vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec4 MellowPurple(vec2 pos)\n{\n    pos = abs(pos*4.0);\t\t\t// Mirror, Zoom etc\n    \n    pos.y *= sin(pos.x);\n    vec4 col = vec4(0.32,0.19,0.35,1.0);\n    float tt = iTime*0.8;\n    float iter = (pos.x*pos.y);\n    iter *= 0.5+sin(pos.x*0.5+tt*0.95)+0.5;\n    float r = sin(sin(tt)*pos.y);\n    //r += .6;\n    float d1 = sin(tt+pos.x+pos.y);\n    float val = sin(tt+iter*PI );\n    float brightness = 0.25 / abs( d1 * val - r);\n    brightness = brightness/(brightness + 8.);\n    col += brightness;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;     \n    pos = rotate(pos,iTime*0.2);\n    \n\tpModPolar(pos,7.0);    \n    \n    fragColor = MellowPurple(pos);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 80, 110, 110, 183], [185, 185, 235, 235, 473], [475, 475, 504, 504, 980], [983, 983, 1040, 1040, 1215]]}
{"id": "MdGfRm", "name": "Audio Reactive Roses", "author": "lnae", "description": "Trying to figure out how to use the audio input :)", "tags": ["2d", "audio"], "likes": 8, "viewed": 303, "date": "1528034413", "time_retrieved": "2024-06-20T19:15:32.476826", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float bass = texture(iChannel0, vec2(0.0, 0.25)).x;\n        \n    bass = bass * bass;\n    \n    uv *= 4.0;\n    \n    float time = 0.5 * iTime;\n    float angle = atan(uv.y, uv.x) + 2.0 * sin(PI * time);\n    float radius = length(uv);\n    \n    float wave = texture(iChannel0, vec2(abs(atan(uv.y, uv.x) / (2.0 * PI)), 0.75)).x;\n    \n    float n = mod(floor(time + 4.0), 10.0);\n    float d = mod(floor(time / 10.0 + 5.0), 10.0) + 1.0;  \n    float k = n / d;\n    float offset = sin(2.6 * sin(1.9 * sin(PI * time)));\n    \n    offset += bass;\n    \n    vec3 colorOffset = vec3(offset) + vec3(0.5, 0.25, 0.25) * (wave - 0.5);\n\n    vec3 res = vec3(10000.0);    \n    for(float i = 0.0; i < d; i++){\n    \tangle += 2.0 * PI;\n        res = min(res, abs(radius - ( cos(k * angle) + colorOffset)));\n        res = min(res, abs(-radius - (cos(k * (angle + PI)) + colorOffset)));\n    }\n    \n    res = (bass + 0.5) * smoothstep(0.05, 0.0, res);\n    \n    fragColor = vec4(res,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGfRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 77, 77, 1113]]}
{"id": "MdGfWR", "name": "sadfasfdasfasdfasdfasfasdanger", "author": "lennyjpg", "description": "sdfasdfasdf", "tags": ["sadfasdf"], "likes": 4, "viewed": 333, "date": "1528249593", "time_retrieved": "2024-06-20T19:15:32.477091", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x-0.5;\n    float t = iTime*0.01;\n    fragColor = vec4(sin(atan(uv.x,uv.y+t)*iTime*1000000.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 190]]}
{"id": "MdKBzy", "name": "distance field for shapes", "author": "Veggiebob", "description": "2 simple distance fields for a rectangle, and a distance field for a circle. Red is negative. I put the 3D versions underneath them.", "tags": ["distancefield", "rectangle"], "likes": 1, "viewed": 95, "date": "1529417905", "time_retrieved": "2024-06-20T19:15:32.840727", "image_code": "float align (float diff, float dim){\n    return max(diff-dim, 0.);\n}\nfloat box (vec4 box, vec2 pos){\n    float n = align(abs(pos.x-box.x), box.z)+align(abs(pos.y-box.y), box.w)-min(box.z/2., box.w/2.);\n    return n;\n}\nfloat distRect(vec4 r, vec2 p) { //credit to BigWIngs for this function\n\tvec2 d = max(abs(p - r.xy) - r.zw*.5, 0.);\n       return dot(d, d);\n}\n/*\n//The 3D version\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\n*/\nfloat circle (vec2 pos, float radius, vec2 p){\n    return length(p-pos)-radius;\n}\n/*\n//The 3D version\nfloat sphere (vec3 pos, float radius, vec3 p){\n    return length(p-pos)-radius;\n}\n//very simple :)\n*/\nfloat donut (vec2 pos, float radius, vec2 p){\n    float d = pow(max(abs(circle(pos, radius, p)),abs(circle(pos, radius*0.5, p))), 3.)*50.-0.15;\n    d = clamp(d, -1., 1.);\n    return d;\n}\n//no 3d version\nfloat ring (vec2 pos, float radius, vec2 p){\n    return max(abs(circle(pos, radius, p)),abs(circle(pos, radius*0.5, p)));\n}\n//this is a work in progress\n/*\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float distBox = distRect(vec4(0.2, sin(iTime)*0.5, 0.1, 0.1), uv)*8.;\n    float distBox2 = box(vec4(sin(iTime)*0.5, 0.2, 0.1, 0.1), uv);\n    float distCircle = circle(vec2(0.), 0.2, uv);\n    float weirdBox = box(vec4(sin(iTime*1.3)*0.4, cos(iTime*1.3)*0.4, 0.1, 0.1), uv);\n    float don = donut(vec2(sin(iTime)*0.5), 0.3, uv);\n    \n    float endDist = min(min(min(min(distBox, distCircle), distBox2), weirdBox), don);\n    vec3 col = vec3(1.);\n    float contrast = 5.;\n    if(endDist<0.){\n    \tcol = vec3(-endDist*contrast, 0., 0.);\n    } else {\n        col = vec3(endDist*contrast);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKBzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 68], [69, 69, 100, 100, 217], [218, 218, 250, 289, 360], [361, 618, 664, 664, 699], [700, 822, 867, 867, 1008], [1009, 1025, 1069, 1069, 1148], [1149, 1185, 1242, 1292, 2041]]}
{"id": "MdKczw", "name": "LINDA", "author": "GuntherRox", "description": "linda,bored, practicing ", "tags": ["i"], "likes": 0, "viewed": 55, "date": "1528804873", "time_retrieved": "2024-06-20T19:15:32.846777", "image_code": "#define RADIUS 0.02\n\nbool circle (vec2 uv, vec2 p, float radius)\n{\n    float dist = sqrt((uv.x - p.x)*(uv.x - p.x) + (uv.y - p.y)*(uv.y - p.y));\n    if(dist<radius)\n        return true;\n    \n    else return false;\n              \n}\n\nfloat dist_to_line(vec2 p1, vec2 p2, vec2 uv)\n{\n\tfloat a = abs(distance(p1, uv));\n\tfloat b = abs(distance(p2, uv));\n\tfloat c = abs(distance(p1, p2));\n\n\tfloat d = abs(sqrt(c*c + RADIUS*RADIUS));\n    \n\tif (a >= d || b >= d)\t{\n        float dist1 = distance(p1, uv);\n        float dist2 = distance(p2, uv);\n        return min(dist1,dist2);\n\t}\n\n\tfloat p = (a + b + c) * 0.5;\n\n\tfloat h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n    return h;\n}\n\nfloat falloff(float dist)\n{\n    if (dist*1.5 > RADIUS) {\n        return 0.0;\n    } else {\n        return 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord/iResolution.xy;\n   \t//uv -= .5; \n    uv.x *= iResolution.x/iResolution.y;\n    \n  \n    uv += cos(iTime)*.06;\n    \n    uv.x += -0.5;\n    \n    //legs line\n    vec2 p1 = vec2(.2,.1);\n    vec2 p2 = vec2(.2,.25);\n    float dist1 = dist_to_line(p1, p2, uv);        \n\tfloat i1 = falloff(dist1);\n    \n    //legs line\n    vec2 p3 = vec2(.3,.1);\n    vec2 p4 = vec2(.3,.25);\n    float dist2 = dist_to_line(p3, p4, uv);        \n\tfloat i2 = falloff(dist2);\n\t\n    //fragColor = vec4(i1,0,1,1); \n\t\n    \n    //arm line\n    \n    vec2 p5 = vec2(.38,.34);\n    vec2 p6 = vec2(.48,.4+sin(iTime*5.)/9.);\n    float dist3 = dist_to_line(p5, p6, uv);        \n\tfloat i3 = falloff(dist3);\n\t\n    vec2 p7 = vec2(.12,.34);\n    vec2 p8 = vec2(.05,.4-sin(iTime*5.)/9.);\n    float dist4 = dist_to_line(p7, p8, uv);        \n\tfloat i4 = falloff(dist4);\n    \n    fragColor = vec4(i1+i2 + i3 + i4*.5,0,.5,1);\n    \n     \n    //i dot\n    vec2 c2 = vec2 (.25, .35);\n    float rBody = 0.13;\n    \n    bool isAdot = circle(uv, c2, rBody );\n    \n    if(isAdot == true)\n           fragColor = vec4(1.*.5+1.,.5,1,1);\n    \n    //Ball\n    vec2 c3 = vec2 (5. * sin(iTime*5.)/50., .5);\n    float rBall = 0.02;\n    \n    bool isABall = circle(uv, c3, rBall );\n    \n    if(isAdot == true || isABall == true)\n           fragColor = vec4(1.*sin(iTime)*.5+1.,.5,1,1);\n    \n    vec3 c1 = texture(iChannel0, uv*1.2).rgb;\n   \t\n    if(uv.y < 0.1)\n    fragColor.rgb = c1;\n    \n    \n    // Eyes Draw\n    \n    vec2 leftEye1 = vec2 (.18, .38);\n    vec2 rightEye2 = vec2 (.30, .38);\n\n\tfloat leftEyeRadius1 = 0.04;\n    float rightEyeRadius2 = 0.04;\n    \n    bool isInlEye = circle (uv, leftEye1, leftEyeRadius1);\n    if (isInlEye) fragColor = vec4 (0.5,.2,0.4,1);\n\n\tbool isInrEye = circle (uv, rightEye2, rightEyeRadius2);\n    if  (isInrEye) fragColor = vec4 (0.5,.2,.4,0); \n    \n   // Pupils Eyes Draw\n    \n    vec2 leftEye3 = vec2 (.18, .38 + (.01 + sin(iTime)/35.));\n    vec2 rightEye4 = vec2 (.30, .38 + (.01 - sin(iTime)/35.));\n\n\tfloat leftEyeRadius3 = 0.02;\n    float rightEyeRadius4 = 0.02;\n    \n    bool isInlEye1 = circle (uv, leftEye3, leftEyeRadius3);\n    if (isInlEye1) fragColor = vec4 (0,0,0,0);\n\n\tbool isInrEye1 = circle (uv, rightEye4, rightEyeRadius4);\n    if  (isInrEye1) fragColor = vec4 (0,0,0,0); \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKczw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[21, 21, 66, 66, 230], [232, 232, 279, 279, 683], [685, 685, 712, 712, 801], [803, 803, 860, 860, 3148]]}
{"id": "MdVBDD", "name": "李明杰VIRTUALDJ2", "author": "leneer", "description": "李明杰VIRTUALDJ2", "tags": ["virtualdj"], "likes": 2, "viewed": 359, "date": "1528944284", "time_retrieved": "2024-06-20T19:15:32.846777", "image_code": "//https://www.shadertoy.com/view/XlKSzw//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = 0.5 * (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // warp uv pre-perspective shift\n    float displaceAmp = 0.1;\n    float displaceFreq = 2.5;\n    uv += vec2(displaceAmp * sin(time + uv.x * displaceFreq));\n    \n    // 3d params\n    // 3d plane technique from: http://glslsandbox.com/e#37557.0 \n    float horizon = 0.2 * cos(time); \n    float fov = 0.35 + 0.15 * sin(time); \n\tfloat scaling = 0.3;\n    // create a 2nd uv with warped perspective\n\tvec3 p = vec3(uv.x, fov, uv.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n    \n    // wobble the perspective-warped uv \n    float oscFreq = 12.;\n    float oscAmp = 0.04;\n    s += vec2(oscAmp * sin(time + s.x * oscFreq));\n\t\n\t// normal drawing here\n    // lines/lattice\n    float color = max(\n        smoothstep(0.2, 0.8, 0.94 - pow(sin(s.y * 100.), 0.3)), \n        smoothstep(0.2, 0.8, 0.94 - pow(sin(s.x * 100.), 0.3))\n    );\n\n\t// 线条深度范围\n\tcolor *= p.z * p.z * 20.0;\n    // 线条颜色\n\tfragColor = vec4( vec3(color, 0, 0), 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 42, 99, 99, 1160]]}
{"id": "MdVBRD", "name": "Steps..", "author": "asis5528", "description": "Made a small 2d scene by combining shapes........", "tags": ["shapes", "steps"], "likes": 9, "viewed": 340, "date": "1528018737", "time_retrieved": "2024-06-20T19:15:32.846777", "image_code": "\n#define PI 3.14159265359\n#define asp 1920./1080.\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5,0.49) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.01),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.02),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat star(vec2 uv1){\n   \n    float time = iTime;\n    vec2 lst = uv1-vec2(0.5*asp,0.5);\n    float r =0.1+0.025*cos(atan(lst.y,lst.x)*6.+0.);\n\tfloat c1 = smoothstep(r,r-0.1,length(uv1-vec2(0.5*asp,0.5)));\n\treturn c1;\n}\t\n\n\n\nfloat circle(vec2 uv,float radius){\n    float k = 0.0;\n     uv.x/=1.9*1.3; \n    if (uv.y<0.0){\n       \n        k= smoothstep(radius,radius-0.01,length(uv));\n    }\t\n    return k; }\n    \nfloat circle3(vec2 uv,float radius){\n    float k = 0.0;\n     uv.x/=2.56*1.3; \n    if (uv.y<0.0){\n       \n        k= smoothstep(radius,radius-0.01,length(uv));\n    }\t\n    return k; }    \nfloat cir(vec2 uv,float radius,float blur){\n\tfloat c = smoothstep(radius,radius-blur,length(uv));\n    return c;\n}\n\nfloat box2(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5,0.49) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.005),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.02),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat box3(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5,0.49) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.005),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.02),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\n\nfloat circle2(vec2 uv,float radius){\n    \tfloat k = 0.0;\n     uv.x/=1.1; \n    if (uv.y>0.0){\n       \n        k= smoothstep(radius,radius-0.01,length(uv));\n    }\t\n    return k; }\n\nfloat box1(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5,0.49) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nfloat box4(in vec2 _st, in vec2 _size){\n    _st = _st-vec2(0.2185*asp,0.0);\n    _size = vec2(0.5,0.49) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.01),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.01),\n                    vec2(1.0,1.)-_st);\n    return uv.x*uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    vec2 uv = fragCoord/vec2(iResolution.x,iResolution.y);\n\tfloat gradient = length(uv.y);\n    vec2 cuv = uv;\n    vec4 background = vec4(0.7,0.5,0.1,1.)*length(uv.x*2.);\n    background=background/2.+ box(uv-vec2(-0.2,0.3),vec2(0.2,0.2))*texture(iChannel0,(uv+vec2(0.32,0.15))*vec2(2.8,2.8)).z;\n    float bb = box1(uv-vec2(-0.2,0.3),vec2(0.22,0.23))-box1(uv-vec2(-0.2,0.3),vec2(0.2,0.2));\n    background += bb/2.;\n    uv *= 1.9;\n    \n    \n    //ladder sticks,i don't know what that's called\n    \n    vec4 b = vec4(box(uv+vec2(0.43,0.0),vec2(0.03,0.6)));\n    b+= vec4(box(uv+vec2(0.23,-0.2),vec2(0.03,0.6)));\n    b+= vec4(box(uv+vec2(0.0,-0.4),vec2(0.03,0.6)));\n    b+= vec4(box(uv+vec2(-0.2,-0.6),vec2(0.03,0.6)));\n    b+= vec4(box(uv+vec2(-0.4,-0.78),vec2(0.03,0.56)));\n    b+= vec4(box(uv+vec2(-0.6,-0.98),vec2(0.03,0.56)));\n    b+= vec4(box(uv+vec2(-0.8,-1.18),vec2(0.03,0.56)));\n    b+= vec4(box(uv+vec2(-1.,-1.38),vec2(0.03,0.56)));\n    b+= vec4(box(uv+vec2(-1.2,-1.58),vec2(0.03,0.56)));\n    \n    \n    \n    \n    vec2 st = uv;\n    st.x*=1920./1080.;\n    st -= vec2(0.5)-vec2(0.17,-0.27);\n    // rotate the space\n    st = rotate2d( cos(44.4/5.)*3.12 ) * st;\n    // move it back to the original place\n    st += vec2(0.5)+vec2(-0.17,0.27);\n    \n    b=vec4(clamp(clamp(b,0.0,1.)+clamp(box(st-vec2(-0.9,0.14),vec2(3.9,0.06)),0.0,1.),0.0,1.));\n    \n    b*=vec4(0.811, 0.670, 0.388,1.);\n    \n    \n    \n    \n    ////////////////////////sticks finished\n    \n    \n    vec2 Frag = fract(uv*1.);\n    vec2 id = floor(uv*5.);\n \t//////////stairs steps ..........\n    float stairs = id.y-id.x;\n    float k = length((uv.y+(1.-iMouse.y)/100.)*1.2);\n    // Output to screen\n    \n    stairs = clamp(stairs,0.,1.);\n    float gra = 1.-k;\n    float proc = clamp((1.-stairs),0.0,0.7)*(1.-st.x)/2.;\n    \n    \n    \n    \n    \n    \n    b = clamp(b,0.0,1.);\n    \n    fragColor = clamp(clamp(background*(1.-proc*22222.),0.0,1.)*clamp((1.-b*4.),0.0,1.),0.0,1.);\n    fragColor = clamp(fragColor,0.,1.); \n    b*=stairs;\n    fragColor += clamp(clamp(vec4(proc/2.,proc/1.5,proc/2.,1.),0.0,1.)+clamp(b*k*0.8,0.,1.),0.0,1.);\n    \n    vec2 off = vec2(-0.4,0.225);\n    \n\tvec4 c;\n    cuv.x*=asp;\n    cuv -= vec2(0.5,0.5-0.11*2.)-off;\n    cuv = rotate2d(sin(iTime*2.)/8.)*cuv;\n    cuv+= vec2(0.5,0.5-0.11*2.)-off;\n    c =clamp(c+ box2(cuv+off,vec2(0.17,0.03)),0.0,1.);\n    \n    \n    \n    c =clamp(c+ box2(cuv+vec2(0.0,0.2)+off,vec2(0.2,0.005)),0.0,1.);\n    \n    \n    \n    \n    \n    \n    \n    \n    vec2 luv = cuv;\n    luv -= vec2(0.5-0.07,0.5-0.08/4.)-off;\n    luv = rotate2d(6.08)*luv;\n    luv += vec2(0.5-0.07,0.5-0.08/4.)-off;\n    \n    c =clamp(c+ box3(luv+vec2(0.07,0.11)+off,vec2(0.04,0.25)),0.0,1.);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vec2 ruv = cuv;\n    ruv -= vec2(0.5+0.07,0.5-0.08/4.)-off;\n    ruv = rotate2d(12.7)*ruv;\n    ruv += vec2(0.5+0.07,0.5-0.08/4.)-off;\n    \n    c =clamp(c+ box3(ruv+vec2(-0.07,0.11)+off,vec2(0.04,0.25)),0.0,1.);\n\t\n    \n    float ring = circle(cuv-vec2(0.505*asp,0.087),0.087*1.02)-circle3(vec2(cuv.x,cuv.y)-vec2(0.505*asp,0.087),0.067*1.02);\n    \n    \n    \n    c+=ring;\n    float ring2 = circle2(cuv-vec2(0.51*asp,0.29),0.082)-circle2(cuv-vec2(0.51*asp,0.29),0.068);\n    c+=ring2;\n    cuv -= vec2(0.5+0.07,0.5-0.08/4.)-off;\n    cuv = rotate2d(100.15)*cuv;\n    cuv += vec2(0.5+0.07,0.5-0.08/4.)-off;\n    c = clamp(c+box2(cuv-vec2(0.07,0.09)+off,vec2(0.03,0.2)),0.0,1.);\n   \t\n    uv + vec2(0.5);\n   \tuv = rotate2d( sin(iTime/2.)*3.12 ) * st;\n \tuv - vec2(0.5);\n    uv+=vec2(1.8);\n   k = clamp(k,0.0,1.);\n     fragColor= clamp(fragColor*(1.-c*2.),0.0,1.);\n    fragColor += clamp(clamp(c,0.0,1.)*gradient/1.5,0.0,1.)*texture(iChannel1,cuv*33.)*exp(2.2);\n    fragColor = clamp(fragColor+clamp(c.x,0.0,0.2),0.0,1.);\n vec2 uv1 = fragCoord/iResolution.xy;\n\t uv1.x*=asp;\n    uv1 -= vec2(0.5*asp,0.5+0.5);\n   \tuv1 = rotate2d(sin( iTime*2.)/6. ) * uv1;\n \tuv1 +=vec2(0.5*asp,0.5+0.5);\n    \n    fragColor+=star(uv1)+box4(uv1-vec2(0.0,0.3),vec2(0.01,0.6));\n    vec2 uv2 = fragCoord/iResolution.xy;\n\t uv2.x*=asp;\n    uv2 -= vec2(0.6*asp,0.5+0.5);\n   \tuv2 = rotate2d(sin( iTime*2.+30.)/3. ) * uv2;\n \tuv2 +=vec2(0.6*asp,0.5+0.5);\n    \n    fragColor+=(star(uv2-vec2(0.2,0.0))+box4(uv2-vec2(0.2,0.3),vec2(0.01,0.6)))*vec4(0.7,0.5,1.2,1.);\n    \n    vec2 uv3 = fragCoord/iResolution.xy;\n    vec2 bu = uv3;\n    vec2 uv4 = uv3;\n    \n    vec2 uv5 = uv3;\n   \t\n    //cat body\n    uv3-=vec2(0.5);\n    uv3.x*=asp;\n    uv3*=0.9;\n    uv3.y*=1.1-uv3.y/2.;\n    uv3.y*=1.1;\n    float cat_body = cir(uv3,0.2,0.01);\n    \n    //cat head\n    uv4-=vec2(0.36,0.45);\n    uv4.x*=asp;\n    uv4 = rotate2d(5.69)*uv4;\n    uv4.x*=1.0;\n    uv4.y-=abs(uv4.x)*0.17;\n    float cat_head = cir(uv4,0.13,0.01);\n    \n    //cat ears\n    uv5-=vec2(0.35,0.52);\n    \n    uv5.x*=asp;\n   \t\n    uv5 = rotate2d(12.80)*uv5;\n    \t\n    float ear_base = cir(uv5,0.13,0.01);\n    float box_cut = box(uv5+vec2(0.4,0.5),vec2(0.1,0.22));\n    float box_cut_1 = box(uv5+vec2(0.4,0.55),vec2(1.22,0.20));\n    uv5.x*=1.2;\n    float cir_cut = cir(uv5-vec2(-0.09,0.15),0.15,0.02);\n    //uv5.y-=(uv5.x*2.+0.06)*0.3;\n    float cat_ears = clamp(((ear_base-box_cut)-cir_cut)-box_cut_1,0.0,1.);\n    \n    \n    \n    float cat =clamp(cat_ears+cat_head+cat_body,0.0,1.);\n    \n     uv3 = fragCoord/iResolution.xy;\n   \n     bu = uv3;\n     uv4 = uv3;\n    \n     uv5 = uv3;\n   \t\n    //cat body\n    uv3-=vec2(0.5);\n    uv3*=1.1;\n    uv3.x*=asp;\n    uv3*=0.9;\n    uv3.y*=1.1-uv3.y/2.;\n    uv3.y*=1.1;\n     cat_body = cir(uv3,0.2,0.01);\n    \n    //cat head\n    uv4-=vec2(0.36,0.45);\n    uv4*=1.1;\n    uv4.x*=asp;\n    uv4 = rotate2d(5.69)*uv4;\n    uv4.x*=1.0;\n    uv4.y-=abs(uv4.x)*0.17;\n     cat_head = cir(uv4,0.13,0.01);\n    \n    //cat ears\n    uv5-=vec2(0.35,0.52);\n    uv5*=1.1;\n    uv5.x*=asp;\n   \t\n    uv5 = rotate2d(12.80)*uv5;\n    \t\n     ear_base = cir(uv5,0.13,0.01);\n     box_cut = box(uv5+vec2(0.4,0.5),vec2(0.1,0.22));\n     box_cut_1 = box(uv5+vec2(0.4,0.55),vec2(1.22,0.20));\n    uv5.x*=1.1;\n     cir_cut = cir(uv5-vec2(-0.09,0.15),0.15,0.02);\n    //uv5.y-=(uv5.x*2.+0.06)*0.3;\n     cat_ears = clamp((ear_base-box_cut-box_cut_1)-cir_cut,0.0,1.);\n    \n    \n    \n     float cat_1 =cat_ears+cat_head+cat_body;\n    float cat_2 = clamp(cat,0.0,1.)-clamp(cat_1,0.0,1.);\t\n   \tfloat cat_3 = mix(cat,cat_2,0.5);\n    vec2 uv6 = bu;\n    uv6 -= 0.5;\n    uv6+=vec2(0.16,0.05);\n    uv6.x*=asp;\n    uv6 = rotate2d(12.80)*uv6;\n    float cat_eye = clamp(cir(uv6,0.04,0.01)-cir(uv6-vec2(0.0,0.006),0.04,0.01),0.0,1.0);\n    uv6.x*=0.7;\n    uv6+=vec2(-0.05,0.13);\n     uv6 = rotate2d(31.36)*uv6;\n    float cat_m = clamp(cir(uv6,0.08,0.01)-cir(uv6+vec2(0.001,0.003),0.08,0.01)-(box(uv6+vec2(0.5),vec2(1.2,0.07))+box(uv6+vec2(0.44,0.5),vec2(0.1,0.3))),0.0,1.);\n     uv6 = rotate2d(43.71)*uv6; \n    uv6+=vec2(0.00,0.025);\n    cat_m += clamp(cir(uv6,0.08,0.01)-cir(uv6+vec2(0.001,0.003),0.08,0.01)-(box(uv6+vec2(0.5),vec2(1.2,0.07))+box(uv6+vec2(0.44,0.5),vec2(0.1,0.3))),0.0,1.);\n    \n    //fragColor = vec4(cat_eye+cat_3+cat_m);\n    //fragColor =mix(vec4(clamp(cat,0.0,1.0)),fragColor,0.6);\n \n    //fragColor = vec4(gradient);\n    //fragColor = *vec4(background);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "Md2XzV", "previewfilepath": "https://soundcloud.com/sergio-sergio-815961212/baby-animals-sleeping-short-bedtime-lullaby-brahms-lullaby-lullaby-and-goodnight", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sergio-sergio-815961212/baby-animals-sleeping-short-bedtime-lullaby-brahms-lullaby-lullaby-and-goodnight", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVBRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[50, 50, 78, 78, 164], [165, 165, 203, 203, 473], [475, 475, 496, 496, 692], [697, 697, 732, 732, 876], [882, 882, 918, 918, 1063], [1068, 1068, 1111, 1111, 1181], [1183, 1183, 1222, 1222, 1493], [1495, 1495, 1534, 1534, 1805], [1809, 1809, 1845, 1845, 1986], [1988, 1988, 2027, 2027, 2299], [2302, 2302, 2341, 2341, 2650], [2651, 2651, 2708, 2708, 9827]]}
{"id": "MdVBRy", "name": "Krypto Planes", "author": "aiekick", "description": "Krypto Planes", "tags": ["planes", "krypto"], "likes": 19, "viewed": 627, "date": "1529409137", "time_retrieved": "2024-06-20T19:15:33.919623", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 m1;\nmat3 m2;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08 + cos(t*0.1)*2.), sin(t*0.12 + sin(t*0.05)*2.5)) * 4.;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length( max(abs(p.x), abs(p.y)) - p.z);\n}\n\nvec4 map(vec3 p)\n{\n    vec2 pa = path(p.z); \n\t\n    p.xy -= pa;\n\t\n    float a = pa.x * pa.y * 0.1;\n\tp.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    float d0 = min(pattern(p*m1), pattern(p*m2));\n    float d1 = min(pattern(p*3.*m1), pattern(p*2.*m2));\n    \n   \tfloat dist0 = dot(vec3(1)-clamp(d0,0.,1.),vec3(1));\n\tfloat dist1 = dot(vec3(1)-clamp(d1,0.,1.),vec3(d0));\n    \n\tfloat dist = mix(dist0, dist1, 0.75);\n\t\n    //return vec4(1.47 - length(p.xy) - dist, vec3(step(dist,0.1))); // tunnel\n\treturn vec4(1.47 - abs(cos(p.x*0.3)*p.y) - dist, vec3(step(dist,0.1))); // planes\n}\n\nvec3 nor( vec3 pos, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .01);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 0.1) * 0.5; \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n    m1 = mx * my * mz;\n    m2 = m1*m1;\n\t\n    float time = iTime * 5.;\n    // for avoid artifacts due to float precision over 400 secs\n    //time = mod(iTime * 5., 400.); \n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,time + .1); //Change camere view here\n\tcamView.xy += path(camView.z);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n    \n    vec3 ro = vec3(0,0,time);\n\tro.xy += path(ro.z);\n    \n    vec3 lp = vec3(path(ro.z + 3.),ro.z + 3.);\n    \n\tvec2 fov = vec2(0.75,0.9);\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u*fov.x + uv.y*v*fov.y);\n    \n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<80;i++)\n    {      \n        if (d*d/s>1e5) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n    vec3 p = ro+rd*d;\n    vec3 n = nor(p, 0.1);\n        \n    f = shade(ro, rd, d, lp);\n\t\n\tf = f.zyww + f.x*0.2;\n\n    f = mix( f, vec4(0.8), 1.0-exp( -0.01*d*d ) );\n        \n   \tfragColor = sqrt(f*f*f*1.5);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 165, 190, 190, 248], [249, 249, 274, 274, 332], [333, 333, 358, 358, 416], [437, 437, 457, 457, 538], [540, 540, 563, 563, 642], [644, 644, 662, 662, 1222], [1224, 1224, 1255, 1255, 1470], [1472, 1693, 1721, 1721, 2046], [2048, 2130, 2187, 2187, 2413], [2415, 2415, 2451, 2451, 2587], [2589, 2765, 2815, 2815, 3000], [3002, 3211, 3273, 3273, 3783], [3785, 3785, 3833, 3833, 4740], [4742, 4742, 4799, 4799, 6005]]}
{"id": "MdVBWz", "name": "grid_0", "author": "balkhan", "description": "grid", "tags": ["raymarching"], "likes": 32, "viewed": 3689, "date": "1529942546", "time_retrieved": "2024-06-20T19:15:34.853141", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.0001\n#define FAR\t\t\t30.\n\n#define UNIFORM_ROTATION\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tid;\nvec3\th;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tR = iResolution.xy, uv  = (f-R*.5)/R.yy;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 2.-iTime);\n    \n    vec4\tinter = (march(pos, dir));\n\n    col = h*1.-.5;\n\n    c_out =  vec4(col, h.x);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5; \n    p.z -= iTime*-1.725;\n\n    p.y += sin(iTime*-1.+p.z*.5)*.5;\n    p.x += cos(iTime*-1.+p.z*.5)*.5;\n    rotate(p.xy, p.z*.25 + 1.0*sin(p.z*.125 - iTime*0.5) + 0.*iTime);\n    \n    float\ttube = max(-(length(p.yx)-2.), (length(p.yx)-8.));\n    tube = max(tube, p.z-10.-0./length(p.yx*.06125) );\n    tube = max(tube, -p.z-10.-0./length(p.yx*.06125) );\n    vec3\tpr = p;\n    pr.xy = (fract(p.xy*.5)-.5)*1.;\n    id = vec3(floor(p.xy*1.-.0), (floor(p.z*.5)-.0)*4.);\n    \n    pr.xy = abs(pr.xy)-.2505;\n    #ifdef UNIFORM_ROTATION\n    rotate(pr.xy, iTime);\n    #else\n    rotate(pr.xy, clamp( + (mod(id.x*.5, 2.)-1. <= 0. ? 1. : -1.) + (mod(id.y*.5, 2.)-1. <= 0. ? 1. : -1.), -2., 2.) * iTime*.5 );\n    #endif\n    pr.z = (fract(pr.z*.5)-.5)*4.;\n\tmind = mylength(vec2(mylength(pr.xyz)-.31, pr.z ))-.084;\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n    \trotate(dirr.xy, .51025*dist.y+iTime*-.0 );\n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*.5;\n        float\td = 5.;\n        h -= vec3(.3, .2, .3)*.1/ (d+.0);\n        h += (\n            .001/(dist.x*dist.x+0.01) \n            -\n            1./(dist.y*dist.y+40.)\n             )\n            *\n            vec3\n        (\n    \t\t1.+(sin(1.0*(id.y+id.x+id.z)+0.00) )\n            ,\n            1.+(sin(1.0*(id.x+id.y+id.z)+1.04) )\n            ,\n            1.+(sin(1.0*(id.z+id.x+id.z)+2.08) )\n        )*.5;\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E || log(dist.y*dist.y/dist.x/1e5)>0.)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVBWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 425, 468, 468, 733], [735, 735, 756, 756, 1590], [1593, 1593, 1625, 1625, 2653], [2655, 2669, 2693, 2693, 2837], [2839, 2839, 2863, 2863, 3001], [3003, 3003, 3043, 3043, 3118], [3120, 3120, 3148, 3148, 3256], [3259, 3259, 3309, 3309, 3569], [3571, 3571, 3593, 3593, 3799]]}
{"id": "MdVfDR", "name": "Alien Epitaph", "author": "felipunkerito", "description": "Playing with the mouse gives new patterns", "tags": ["3d", "sdf", "kifs"], "likes": 5, "viewed": 421, "date": "1528408519", "time_retrieved": "2024-06-20T19:15:34.853141", "image_code": "#define EPS 0.002\n#define STEPS  64\n#define FAR   10.\n#define KIFS   30\n// Uncomment for a different pattern\n#define BOX\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n\t\t         sin( a ),  cos( a )\n\t\t   );\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map( vec3 p, out vec3 tra )\n{\n\n\tmat3 rota = mat3( 1.0 );\n    \n    float wav = texture( iChannel0, vec2( 0.0, 0.10 ) ).x * 0.05;\n    float fre = texture( iChannel0, vec2( 0.1, 0.20 ) ).x * 0.05;\n    \n    vec2 mou = iMouse.xy / iResolution.xy;\n\t\n\tfor( int i = 0; i < KIFS; ++i )\n\t{\n        \n        if( mou.x == 0.0 ) mou.x = sin( iTime * 0.1 + wav ); // max( cos( iTime * 0.15 + wav ), 1e-5 );\n        if( iMouse.z < 0.0 ) mou.x = sin( iTime * 0.1 + wav );\n        \n\t\tp = abs( p * rota - vec3( 0.1, 0.0, 0.0 ) );\n\t\tp.xy = p.yx;        \n\t\tp.xz *= rot( 1.8 + mou.x + fre );\n\t\tp.yx *= rot( 1.8 + mou.y + wav );\n        \n        if( p.z < 0.1 )\n        {\n        \n            tra = vec3( 2, 0, 0 ) * p.z * 2.0;\n            \n        }\n        else if( p.z < 0.2 )\n        {\n        \n            tra = mix( tra, vec3( 0.1, 0.6, 0.2 ) * p.z * 2.0, p.z );\n            \n        }\n        else if( p.z < 0.3 )\n        {\n        \n            tra = mix( tra, vec3( 0.1, 0.0, 0.2 ) * p.z * 2.0, p.z );\n            \n        }\n         \n\t}\n\t\n    #ifdef BOX\n    \n\treturn 1.0 - sdBox( p, vec3( 1.0 ) );\n    \n    #else\n    \n    return 1.0 - length( p );\n\n    #endif\n    \n}\n\nvec3 norm( vec3 p )\n{\n\n    vec3 tra = vec3( 0.0 );\n\tvec2 e = vec2( EPS, 0.0 );\n\treturn normalize( vec3( map( p + e.xyy, tra ) - map( p - e.xyy, tra ),\n\t\t\t                map( p + e.yxy, tra ) - map( p - e.yxy, tra ),\n\t\t\t                map( p + e.yyx, tra ) - map( p - e.yyx, tra )\n\t\t\t              )\n\t\t\t         );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n\tfloat t = 0.0; vec3 tra = vec3( 0.0 ); d = 0.0;\n\t\n\tfor( int i = 0; i < STEPS; ++i )\n\t{\n\t\n\t\td = 0.5 * map( ro + rd * t, tra );\n\t\tif( d < EPS || t > FAR ) break;\n\t\t\n\t\tt += d;\n\t\n\t}\n\t\n\treturn t;\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0; vec3 tra = vec3( 0.0 );\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n        \n        float h = map( ro + rd * t, tra );\n        \n        if( h < 0.001 ) return 0.0;\n        res = min( res, 14.0 * h / t );\n        t += h;\n    \n    }\n    \n    return res;\n    \n}\n\nvec3 shad( vec3 ro, vec3 rd )\n{\n\n\tfloat d = 0.0, t = ray( ro, rd, d );\n\tvec3 p = ro + rd * t;\n    vec3 tra = vec3( 0.0 );\n    float ma = map( p, tra );\n\tvec3 n = norm( p );\n\tvec3 lig = normalize( vec3( sin( iTime * 0.2 ), cos( iTime * 0.2 ), 0.1 ) );\n    vec3 blig = vec3( -lig );\n\tvec3 ref = reflect( rd, n );\n\tvec3 col = vec3( 0 );\n    \n\tfloat amb = 0.5 + 0.5 * n.y;\n\tfloat dif = max( 0.0,  dot( lig, n ) );\n    float bac = max( 0.0, 0.2 + 0.5 * dot( blig, n ) );\n\tfloat spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n    float speO = pow( clamp( dot( ref, blig ), 0.0, 1.0 ), 16.0 );\n\tfloat sha = softShadows( p, lig );\n    float shaO = softShadows( p, blig );\n\t\n    col = tra;\n\tcol += 0.8 * amb;\n\tcol += 0.2 * dif * bac * sha * shaO;\n\tcol += 0.4 * spe;\n    col += 0.4 * speO;\n    \n    col *= sqrt( col );\n\t\n\treturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    float wav = texture( iChannel0, vec2( 0.0, 0.10 ) ).x * 0.2;\n    \n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n\t//vec3 ro = vec3( 0.0, 0.0, 3.0 * sin( iTime + wav ) );\n    //vec3 ro = vec3( 0.0, 0.0, 2.6 );\n\tvec3 ro = vec3( sin( iTime * 0.2 ), -wav, cos( iTime * 0.2 ) );\n    vec3 ww = normalize( vec3( 0 ) - ro );\n\tvec3 uu = normalize( cross( vec3( 0, 1, 0 ), ww ) );\n\tvec3 vv = normalize( cross( ww, uu ) );\n\tvec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n\t\n\t//vec3 rd = normalize( vec3( uv, -1.0 ) );\n\t\n\tfloat d = 0.0, t = ray( ro, rd, d );\n\t\n\tvec3 col = d < EPS ? shad( ro, rd ) : vec3( 0.0 );\n\n\tfragColor = vec4( vec3( col ), 1.0 );\n\n}", "image_inputs": [{"id": "XsBXR3", "previewfilepath": "https://soundcloud.com/kpedro/bassnectar-falling-ft-paper", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kpedro/bassnectar-falling-ft-paper", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[72, 122, 143, 143, 221], [223, 223, 254, 254, 345], [347, 347, 382, 382, 1506], [1508, 1508, 1529, 1529, 1826], [1828, 1828, 1872, 1872, 2068], [2070, 2070, 2115, 2115, 2398], [2400, 2400, 2431, 2431, 3234], [3236, 3236, 3294, 3294, 3975]]}
{"id": "MdVfWG", "name": "glow waves", "author": "xdaimon", "description": ".", "tags": ["raymarch", "sound", "glow"], "likes": 10, "viewed": 439, "date": "1530321885", "time_retrieved": "2024-06-20T19:15:35.295484", "image_code": "float dtl(vec3 p, vec3 lo, vec3 ld, float l) {\n    vec3 x = p - lo; // x's origin is now at lo\n    float t = clamp(dot(ld, x), 0., l);\n    return length(x - ld * t);\n}\n\nfloat get_bit_freq(float x) {\n    float grid = floor(x * 32.)/32.;\n    return .015 + 3./15.*(texture(iChannel0, vec2(grid, .25)).r*2.-1.);\n}\n\nfloat get_wave_sound(float x) {\n    return texture(iChannel0, vec2(x, .75)).r*2.-1.;\n}\n\nfloat plane(vec3 p, vec3 pb1, vec3 pb2, vec3 pn, vec2 bound) {\n    mat3 r3_to_plane_basis = transpose(mat3(pb1, pn, pb2));\n    vec3 x = r3_to_plane_basis * p;\n    x.y = abs(x.y);\n    x.z -= get_bit_freq(x.x / bound.x*.5+.5);\n    //x.z -= .1 + 4./15.*get_wave_sound(x.x / bound.x * .5 + .5);\n    x.xz = max(abs(x.xz) - bound, vec2(0));\n    return length(x);\n}\n\nfloat map(vec3 p) {\n    //float d = plane(p, vec3(0,0,1), vec3(0,1,0), vec3(1,0,0), vec2(.5,.01));\n    //*\n\t//or\n\tfloat d = length(vec2(p.y+.2*get_wave_sound(p.z+.5), p.x));\n    if (abs(p.z)>.49)\n        d = 1.;//*/\n\n    p = abs(p);\n    d = min(d, 1.3*dtl(p, vec3(.2,.2,.5), vec3(0,-1,0), .2));\n    d = min(d, 1.3*dtl(p, vec3(.2,.2,.5), vec3(-1,0,0), .2));\n    d = min(d, 1.3*dtl(p, vec3(.2,.2,.5), vec3(0,0,-1), .5));\n    return d;\n}\n\nvec2 sphere(vec3 p, vec3 ro, vec3 rd, float r) {\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro - p, rd);\n    float c = dot(ro - p, ro - p) - r*r;\n    float h = b*b - 4.0*a*c;\n    if (h < 0.)\n        discard;\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n#define iRes iResolution\nvoid mainImage( out vec4 C, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iRes.xy * 2. - 1.;\n    uv.x *= iRes.x / iRes.y;\n    uv /= 2.;\n\n    C = vec4(0);\n\n    float away = 3.141592;\n    float th = -iTime / 10. -iMouse.x/80.; float cs = cos(th); float sn = sin(th);\n    vec3 ro = away*vec3(cs, .2, sn);\n    vec3 ta = vec3(0);\n    vec3 forward = normalize(ta - ro);\n    vec3 up = vec3(0,1,0);\n    vec3 right = vec3(-sn, 0., cs); // deriv of ro, which also is (-z,0,x)\n    //vec3 right = normalize(cross(forward,up));\n    vec3 rd = normalize(vec3(mat3(right, up, forward) * vec3(uv.x, uv.y, away)));\n\n    vec2 bound = sphere(vec3(0), ro, rd, 3.);\n    float t = bound.x;\n    float dist;\n    float csum = 0.;\n    for (int i = 0; i < 128; ++i) {\n        dist = map(ro+rd*t);\n        csum += 1. / (dist*dist);\n        t += dist*.2;\n        if (t > bound.y)\n            break;\n    }\n    C = vec4(.00001*csum);\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 46, 46, 167], [169, 169, 198, 198, 309], [311, 311, 342, 342, 397], [399, 399, 461, 461, 757], [759, 759, 778, 871, 1193], [1195, 1195, 1243, 1243, 1462], [1489, 1489, 1538, 1538, 2394]]}
{"id": "MdVfWy", "name": "Refraction & Hue shift", "author": "setchi", "description": "Refraction, Hue shift", "tags": ["raymarching", "refraction", "hue"], "likes": 22, "viewed": 866, "date": "1530359751", "time_retrieved": "2024-06-20T19:15:36.441194", "image_code": "#define PI 3.141592654\n#define HASHSCALE1 .1031\n\nconst float EPS = 1e-2;\nfloat OFFSET = EPS * 5.0;\nfloat TIME;\n\nvec3 hue(float hue) {\n    vec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n    rgb = abs(rgb * 2. - 1.);\n    return clamp(rgb * 3. - 1., 0., 1.);\n}\n\nvec3 hsvToRgb(vec3 hsv) {\n    return ((hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nfloat hash11(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 rotate2d(vec2 p, float angle) {\n    return p * mat2(cos(angle), -sin(angle),\n        sin(angle), cos(angle));\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat qinticInOut(float t) {\n    return t < 0.5 ?\n        +16.0 * pow(t, 5.0) :\n        -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat sineInOut(float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat box(vec2 p, float size) {\n    p += 0.5;\n    size = 0.5 + size * 0.5;\n    p = step(p, vec2(size)) * step(1.0 - p, vec2(size));\n    return p.x * p.y;\n}\n\nfloat postEffectPattern(vec2 p) {\n    float t1 = fract(TIME);\n    float e11 = qinticInOut(t1) - 0.5;\n\n    float t2 = fract(TIME - 0.05);\n    float e21 = qinticInOut(t2) - 0.5;\n    float e22 = sineInOut(t2) - 0.5;\n\n    float ofs = 0.6 + TIME * 0.2;\n    float diff = 0.35;\n    float scale = 1.3;\n\n    float index = 2.;\n    index = mix(index, 5., box(rotate2d(p, PI * e11 + ofs + diff * 1.), scale * 3.6 * abs(e11)));\n    index = mix(index, 4., box(rotate2d(p, PI * e11 + ofs + diff * 2.), scale * 3.6 * abs(e11)));\n    index = mix(index, 1., box(rotate2d(p, PI * e21 + ofs + diff * 3. + 0.2), scale * 3.6 * abs(e21)));\n    index = mix(index, 0., box(rotate2d(p, PI * e21 + ofs + diff * 3. + 0.2), scale * 3.0 * abs(e21)));\n    index = mix(3., index, box(rotate2d(p, PI * e22 + ofs + diff * 0.), 20. * abs(e22)));\n\n    return index;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y + 5.;\n}\n\nfloat udBox(vec3 p, vec3 b, float r) {\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat dGlass(vec3 p) {\n    float it = mod(floor(TIME - 0.5), 4.);\n\n    if (it == 0.)\n        return sdSphere(p, .6);\n    if (it == 1.)\n        return sdTorus(rotateX(p, PI / 2.), vec2(.5, .2));\n    if (it == 2.)\n        return sdHexPrism(p, vec2(0.45));\n    if (it == 3.)\n        return udBox(rotateY(rotateX(p, PI / 4.), PI / 4.), vec3(0.4), 0.05);\n}\n\nfloat map(vec3 p) {\n    float b = sdPlane(p);\n    float c = dGlass(p);\n    return min(b, c);\n}\n\nvec3 floorPattern(vec2 p) {\n    return vec3(0.2) * mod(floor(p.x * 0.3) + floor(p.y * 0.3), 2.0);\n}\n\nvec2 intersect(vec3 ro, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n        float res = abs(map(ro + ray * t));\n        if (res < 0.005) return vec2(t, res);\n        t += res;\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 pos, float e) {\n    vec3 eps = vec3(e, 0.0, 0.0);\n\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 renderScene(vec2 p) {\n    float t1 = fract(TIME);\n    float e1 = qinticInOut(t1) - 0.5;\n    float e2 = sineInOut(t1) - 0.5;\n    float ofs = 0.6 + TIME * 0.2;\n    float t2 = abs(1. - e2 - ofs) * PI;\n\n    vec3 ro = vec3(cos(t2) * 24. * e1, 2., sin(t2) * 24. * e1);\n    vec3 ta = vec3(0);\n    mat3 cm = createCamera(ro, ta, 0.);\n    vec3 ray = cm * normalize(vec3(p, 10.0));\n\n    vec3 fresnel = vec3(0);\n\n    for (int i = 0; i < 6; i++) {\n        vec2 res = intersect(ro, ray);\n\n        if (res.y <= -0.5) {\n            return vec3(1);\n        }\n\n        vec3 pos = ro + ray * res.x;\n        vec3 nor = normal(pos, 0.008);\n\n        if (dGlass(pos) > 0.005) {\n            vec3 col = vec3(0);\n            col += floorPattern(pos.xz);\n            col += fresnel;\n            return col + vec3(0.001, 0.002, 0.004) * res.x * 3.;\n        }\n\n        if (i == 0 && dot(-ray, nor) < 0.5) {\n            float a = 1. - dot(-ray, nor) * 2.;\n            fresnel = mix(fresnel, vec3(0., 0.8, 0.8), a);\n        }\n\n        float eta = 1.1;\n\n        bool into = dot(-ray, nor) > 0.0;\n        nor = into ? nor : -nor;\n        eta = into ? 1.0 / eta : eta;\n\n        ro = pos - nor * OFFSET;\n        ray = refract(ray, nor, eta);\n\n        if (ray == vec3(0.0)) {\n            ro = pos + nor * OFFSET;\n            ray = reflect(ray, nor);\n        }\n    }\n}\n\nvec3 render(vec2 p) {\n    vec3 col = renderScene(p);\n    float effect = postEffectPattern(p);\n    float hue = hash11(floor(TIME + 0.5));\n\n    if (effect == 0.)\n        return col;\n    if (effect == 1.)\n        return hsvToRgb(vec3(hue + p.x * .08, 1, 1));\n    if (effect == 2.)\n        return mix(col, hsvToRgb(vec3(hue - 0.2 - p.y * .08, 1, 1)), 0.7);\n    if (effect == 3.)\n        return vec3(1.);\n\n    return mix(col, hsvToRgb(vec3(hue + (effect - 4.) * 0.1, 1, 1)), 0.7);\n}\n\nvec3 aaRender(vec2 p) {\n    vec3 col = vec3(0.0);\n    const int num = 4;\n\n    for (int i = 0; i < num; i++) {\n        float fi = float(i + 1);\n        col += render(p + vec2(step(fi, 2.001), mod(fi, 2.001)) * 0.0015);\n    }\n\n    return col / float(num);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float timeScale = 0.7;\n    TIME = iTime * timeScale + 10.;\n\n    vec3 col = aaRender(uv);\n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[112, 112, 133, 133, 262], [264, 264, 289, 289, 344], [346, 346, 369, 369, 489], [491, 491, 513, 513, 637], [639, 639, 675, 675, 755], [757, 757, 792, 792, 907], [909, 909, 944, 944, 1058], [1060, 1060, 1088, 1088, 1187], [1189, 1189, 1215, 1215, 1256], [1258, 1258, 1289, 1289, 1413], [1415, 1415, 1448, 1448, 2246], [2248, 2248, 2282, 2282, 2378], [2380, 2380, 2403, 2403, 2426], [2428, 2428, 2466, 2466, 2513], [2515, 2515, 2548, 2548, 2576], [2578, 2578, 2609, 2609, 2683], [2685, 2685, 2707, 2707, 3036], [3038, 3038, 3057, 3057, 3132], [3134, 3134, 3161, 3161, 3233], [3235, 3235, 3270, 3270, 3465], [3467, 3467, 3499, 3499, 3712], [3714, 3714, 3761, 3761, 3949], [3951, 3951, 3977, 3977, 5288], [5290, 5290, 5311, 5311, 5767], [5769, 5769, 5792, 5792, 6024], [6026, 6026, 6081, 6081, 6320]]}
{"id": "MdVfWz", "name": "june 8 2018", "author": "hellochar", "description": "fun with cos", "tags": ["domainwarp"], "likes": 2, "viewed": 84, "date": "1528440657", "time_retrieved": "2024-06-20T19:15:36.447604", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 40. + 4. * cos(iTime);\n    uv += vec2(6. + cos(iTime / 9.) * 6., 2.);\n    \n    vec2 uvCore = uv;\n    \n    uv *= 1. / (1. + pow(length(uvCore), 2.) * 0.2);\n    \n    uv += 1. + cos(iTime / 10.) * 0.5;\n    \n    //uv *= cos(uv.yx);\n    uv += cos(uv.yx * 2.) * 0.5;\n    //uv *= cos(uv.yx);\n    uv += cos(uv.yx * 5.) * 0.25;\n    //uv *= cos(uv.yx);\n    uv += cos(uv.yx * 20.) * 0.125;\n    \n    float iTimeSlow = iTime * 2.;\n    uv *= cos(uv.yx * (iMouse.xy / iResolution.xy - vec2(0.5)) * 1. + iTime);\n    uv *= cos(uv.yx + iTimeSlow) * 5.;\n    uv *= cos(uv.yx + iTimeSlow);\n    uv *= cos(uv.yx + iTimeSlow);\n    uv *= cos(uv.yx * 4. + iTimeSlow);\n    \n    vec3 col1 = 1. - ((1. + cos(uv)) / 2.).xyy;\n    \n    vec3 col = col1;//mix(bg, col1, 1. / (1. + pow(length(uvCore), 2.)) * 1.3); // * 1. / (1. + pow(length(uvCore), 2.) * 0.1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 103, 103, 1054]]}
{"id": "MdVfz3", "name": "Banding reduction HDR dithering", "author": "nomadiclizard", "description": "Eliminates the banding caused by default quantisation on an 8 bit panel by adding random noise.", "tags": ["2d"], "likes": 3, "viewed": 270, "date": "1529872011", "time_retrieved": "2024-06-20T19:15:36.956203", "image_code": "/*\n\nThe thought struck that HDR could be simulated on an 8 bit panel by dithering\nat a higher resolution than the source. Sadly it's not an original thought :(\n\ne.g. http://sandervanrossen.blogspot.com/2012/02/hdr-dithering.html\n\nThe lower half of the screen is using default quantisation, the upper half\nhas [0:1/256] noise added to it to eliminate the banding.\n\nNoise function from:\n\nhttps://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\nchanged slightly to do a divide by 256 in the bitmask\n\n*/\n\n/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    // const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeMantissa = 0x00007FFFu;\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\n// NL because of >>8 mantissa returns in range [0:1/256] which is perfect for quantising\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n/* stuff by nomadic lizard */\n\nvec3 quantise(in vec3 fragColor, in vec2 fragCoord)\n{\n    return fragColor + random(vec3(fragCoord, iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 posn = fragCoord/iResolution.xy;\n    vec2 uv = posn / 5.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xxx);\n\n    // Quantise with random when in top half of screen\n    if(posn.y > 0.5) {\n    \tcol = quantise(col, fragCoord);\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[577, 648, 669, 669, 800], [802, 868, 890, 890, 948], [949, 949, 971, 971, 1029], [1030, 1030, 1052, 1052, 1110], [1112, 1270, 1302, 1377, 1768], [1770, 1908, 1933, 1933, 1984], [1985, 1985, 2010, 2010, 2061], [2062, 2062, 2087, 2087, 2138], [2139, 2139, 2164, 2164, 2215], [2217, 2248, 2301, 2301, 2358], [2360, 2360, 2417, 2467, 2800]]}
{"id": "MdVfzd", "name": "Simple circles and rects", "author": "ma77os", "description": "building block to create and move shapes", "tags": ["2d", "circles", "shapes", "rects"], "likes": 0, "viewed": 85, "date": "1530109752", "time_retrieved": "2024-06-20T19:15:37.483677", "image_code": "// The MIT License\n// Copyright © 2020 André Mattos\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat createCircle(vec2 uv, vec2 pos, float r){\n    float d = length(pos - uv);\n    \n    // smoothstep to correct aliasing\n    return smoothstep(r, r-d*0.05, d);\n}\n\nfloat createRect(vec2 uv, vec2 pos, float w, float h){\n    uv -= pos;\n    float left = -w*0.5;\n    float right = w*0.5;\n    float bottom = -h*0.5;\n    float top = h*0.5;\n    float blur = 0.01;\n    float leftEdge = smoothstep(left-blur, left, uv.x);\n    float rightEdge = smoothstep(right+blur, right, uv.x);\n    float bottomEdge = smoothstep(bottom-blur, bottom, uv.y);\n    float topEdge = smoothstep(top+blur, top, uv.y);\n    \n    return leftEdge * rightEdge * bottomEdge * topEdge;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \t\n    // remapping coordinates from (0 <> 1) to (-0.5 <> -0.5)\n    uv -= .5;\n    \n    // adjusting screen ratio to avoid distorted image\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    // circle 1\n    vec3 color1 = vec3(sin(iTime*0.1)*0.5+0.5, sin(iTime*0.8)*0.5+0.5, sin(iTime*1.6)*0.5+0.5);\n    vec2 pos1 = vec2(sin(iTime * 2.) * 0.3, sin(iTime) * 0.3);\n    float radius1 = 0.1;\n    vec3 circle1 = createCircle(uv, pos1, radius1) * color1;\n    \n    \n    // circle 2\n    vec3 color2 = vec3(sin(iTime*0.7)*0.5+0.5, sin(iTime*1.2)*0.5+0.5, sin(iTime*1.8)*0.5+0.5);\n    vec2 pos2 = vec2(sin(iTime * 0.8) * 0.3, sin(iTime*1.5) * 0.3);\n    float radius2 = 0.15;\n    vec3 circle2 = createCircle(uv, pos2, radius2) * color2;\n    \n    // rect 1\n    vec3 color3 = vec3(sin(iTime*0.2)*0.5+0.5, sin(iTime*1.9)*0.5+0.5, sin(iTime*0.8)*0.5+0.5);\n    vec2 pos3 = vec2(sin(iTime * 0.8) * 0.3, sin(iTime*0.4) * 0.25);\n    vec3 rect1 = createRect(uv, pos3, 0.15, 0.15) * color3;\n    \n    // rect 2\n    vec3 color4 = vec3(sin(-iTime*2.)*0.5+0.5, sin(iTime*-1.4)*0.5+0.5, sin(iTime*0.8)*0.5+0.5);\n    vec2 pos4 = vec2(sin(iTime * -0.6) * 0.3, sin(iTime*-0.9) * 0.25);\n    vec3 rect2 = createRect(uv, pos4, 0.1, 0.2) * color4;\n    \n    // combining shapes\n    vec3 c = circle1 + circle2 + rect1 + rect2;\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1080, 1127, 1127, 1243], [1245, 1245, 1299, 1299, 1730], [1732, 1732, 1789, 1839, 3248]]}
{"id": "MdVfzG", "name": "Circles in stretching space", "author": "WittyBit", "description": "Circles in stretching space", "tags": ["circles", "space", "stretch"], "likes": 7, "viewed": 159, "date": "1529395786", "time_retrieved": "2024-06-20T19:15:37.483677", "image_code": "float map(vec3 p, float size) {\n    return length(fract(p) * 2. - 1.) - size ;\n}\n\nfloat trace(vec3 ro, vec3 rd, float size) {\n\tfloat t = 0.;\n    \n    for(int i = 0; i < 32; ++i)\n        t += map(ro + rd * t, size) / 2.;\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tuv = (uv * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n    \n    vec2 m = (1. - iMouse.xy / iResolution.xy) * (iResolution.x / iResolution.y);\n    \n    vec3 rd = normalize(vec3(uv, m));\n    float t = trace(vec3(0., 0., iTime), rd, fract(abs(uv.x) / 2.));\n    \n    fragColor = vec4(1. / ( 1. + t * t * 0.1));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 31, 31, 80], [82, 82, 125, 125, 240], [242, 242, 299, 299, 659]]}
{"id": "MdyBDy", "name": "Chaotic Blossom", "author": "Flopine", "description": "Still experimenting with more \"organic\" movements and shapes.", "tags": ["raymarching", "colors", "flower", "repetition"], "likes": 21, "viewed": 365, "date": "1530225462", "time_retrieved": "2024-06-20T19:15:38.071585", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui, XT95 and Coyhot for teaching me <3\n// cookie collective rulz!\n\n#define ITER (64.)\n#define PI (3.141592)\n#define time (iTime*0.5)\n\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat odile (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat torus (vec3 p, vec2 d)\n{\n    vec2 q = vec2(length(p.xz)-d.x,p.y);\n  \treturn length(q)-d.y;\n}\n\nfloat prim1 (vec3 p)\n{\n    float steps = 3.;\n\tfloat t1 = torus(p, vec2(1.5,.15));\n    float od = odile(p,.8);\n    p.yz *= rot(PI/2.);\n    float t2 = torus(p,vec2(1.6,0.15));\n    return stmin(od,stmin(t1,t2, 0.5, steps),0.5,steps);\n}\n\nfloat fractal(vec3 p)\n{\n    float prim = prim1(p);\n    float prout = .3;\n    for (int i = 0; i<5; i++)\n    {\n        prout += .4;\n        p.xz *= rot(sin(iTime*prout));\n        p.xy = moda(p.xy, 2.*PI/5.);\n        p.x -= 4.;\n      \tprim = smin(prim, prim1(vec3(p.x, p.yz*rot(PI/4.))), 2.);  \n    }\n    return prim;\n}\n\n\nvec4 SDF(vec3 p)\n{\n  \tp.xz *= rot(time);\n    p.yz *= rot(time);\n    p.y += sin(p.x+iTime*3.)*length(p)*0.1;\n    float d = fractal(p);\n    return vec4(d, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-15.); vec3 p = ro;\n    vec3 dir = normalize(vec3(uv,1));\n    \n    float shad = 0.;\n    float t = 0.;\n    float tmax = 100.;\n    vec3 c = vec3(0.);\n    \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p).x;\n        t += d;\n        if (d<0.001 || t>tmax)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p+= d*dir*0.8;\n    }                 \n    vec3 pal = palette (length(SDF(p).yzw),\n                        vec3(0.2,0.6,0.3),\n                        vec3(0.5,0.1,0.5),\n                        vec3(.08),\n                        vec3(0.,0.5,0.1));\n    if (t<tmax) c = vec3(1.-shad)*pal*1.5;\n\tc = mix(c, vec3(0.5,0.4,0.2)*0.35, 1.-(exp(-.002*t*t)));\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyBDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 195, 214, 214, 257], [259, 259, 290, 290, 414], [416, 416, 457, 457, 528], [530, 530, 579, 579, 684], [686, 686, 742, 742, 773], [775, 775, 806, 806, 843], [845, 845, 875, 875, 943], [945, 945, 967, 967, 1177], [1179, 1179, 1202, 1202, 1495], [1498, 1498, 1516, 1516, 1656], [1658, 1658, 1715, 1765, 2638]]}
{"id": "MdyBR3", "name": "some trig, some polar", "author": "MacSlow", "description": "I was bored and played around with functions of polar-coordinates until this came out. More colors would be nice... but then I like the clean monochrome look of it somehow.", "tags": ["2d", "sdf", "antialiasing", "polar"], "likes": 3, "viewed": 389, "date": "1529711100", "time_retrieved": "2024-06-20T19:15:38.416923", "image_code": "mat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.x, cart.y);\n    return vec2 (phi, r);\n}\n\nvec2 polar2cart (in vec2 polar)\n{\n    float x = polar.x*cos (polar.y);\n    float y = polar.x*sin (polar.y);\n    return vec2 (y, x);\n}\n\nfloat graph (in vec2 p)\n{\n    vec2 polar = cart2polar (p);\n    polar.y = abs (4.*sin (.75*polar.y) * cos (2.*polar.x));\n    p = polar2cart (polar);\n\n\treturn length (p.x / p.y);\n}\n\nvec2 gradient (in vec2 p)\n{\n    //return vec2 (dFdx (graph (p)), dFdy (graph (p))) / fwidth (graph (p));\n    vec2 e = vec2 (.001, .0);\n    return vec2 (graph (p - e.xy) - graph (p + e.xy),\n                 graph (p - e.yx) - graph (p + e.yx)) / (.75*e.x);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 p = (5. + 10.*(.5 + .5*cos(3.*iTime)))*uv;\n    p *= r2d (34.*iTime);\n    p += vec2 (3.*cos (iTime), 3.*sin (iTime));\n    p.x += .5*cos (p.y + 2.*iTime);\n    p.y += .5*sin (p.x + 4.*iTime);\n\n    float d = abs (graph (p)) / length (gradient (p));\n    float thickness = 20. / iResolution.y;\n    vec3 col = vec3 (smoothstep (1.*thickness, 2.*thickness, d));\n\n\tvec3 c = vec3 (1., .95, .9);\n\tc *= .8 + .2*smoothstep (.0, 25.*(2./iResolution.y), d);\n\tcol = mix (c, col, 1. - smoothstep (.0, 12.*(1./iResolution.y), d));\n\n    col *= 1. - .4*length (fragCoord/iResolution.xy*2. - 1.);\n    col = col / (1. + col);\n    col = pow (col, vec3 (1./2.2));\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 142], [144, 144, 176, 176, 272], [274, 274, 307, 307, 407], [409, 409, 434, 434, 587], [589, 589, 616, 693, 846], [848, 848, 905, 905, 1695]]}
{"id": "MdyBRG", "name": "Fade2", "author": "YiubunAuyeung", "description": "bubble", "tags": ["fade"], "likes": 2, "viewed": 66, "date": "1529251690", "time_retrieved": "2024-06-20T19:15:38.683758", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float grey = 1.0;    \n    vec3 img = texture(iChannel1, uv).rgb;\n    \n    vec2 uv0 = (uv*2.0 - 1.0) * 0.5;\n    uv0.x = 1.0-abs(uv0.x);\n    float length0 = sqrt(dot(uv0, uv0));\n    float time = fract(iTime / 2.0) * 5.0;\n    float mask = 1.0 - (length0 * 5.0 - (time*(grey*0.5+0.5)));\n    \n    // background\t \n\tvec3 color = vec3(1.0);\n\n    // bubbles\t\n    uv *= 2.0;\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.1*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = 3.0 * mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\t\t\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n    mask += 1.0 - dot(color,vec3(1.0/3.0));\n    \n    // Output to screen\n    fragColor.rgb = (1.0-mask) * img + mask*vec3(1.0,1.0,1.0);\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 107, 1457]]}
{"id": "MdyBRy", "name": "Party Sausage", "author": "nr4", "description": "Analytic spline distance: https://www.shadertoy.com/view/XsVBWw\nadapted to three dimensions and optimized. Still a little slow though :/ ", "tags": ["raymarching", "spline", "quadratic", "sausage"], "likes": 1, "viewed": 138, "date": "1529414634", "time_retrieved": "2024-06-20T19:15:39.514061", "image_code": "/*\n * Party Sausage\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// changes: \n// - optimized three-zero case\n// - removed incompatible sinh(.) and tanh(.) calls\n// - added abs to specular (fixes smartphone bug)\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n//hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n//distance to spline with parameter t\nfloat dist(vec3 p0,vec3 p1,vec3 p2,vec3 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum distance to spline\nfloat dsp(vec3 p0, vec3 p1, vec3 p2, vec3 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec3 E = x-p0, F = p2-2.*p1+p0, G = p1-p0,\n    \tai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return dist(p0,p1,p2,x,ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nvec2 scene(vec3 x)\n{\n    vec3 p1 = -sin(iTime)*.3*c.xxx, \n        p2 = .4*rot(vec3(1.1,1.2,1.3)*iTime)*c.xxy,\n        p3 = sin(iTime)*.2*c.xxx;\n    return vec2(dsp(p1,p2,p3,x)-.06, 216.);\n}\n\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x, dx=1.e-4;\n    return normalize(vec3(scene(x+dx*c.xyy).x-s, scene(x+dx*c.yxy).x-s, scene(x+dx*c.yyx).x-s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera setup\n    vec2 uv = fragCoord/iResolution.xy-.5, s = c.xy;\n\tvec3 o = c.yyx+.3*vec3(cos(.5*iTime), sin(.5*iTime), 0.), rt = uv.x*c.xyy+uv.y*c.yxy, d = normalize(rt-o), x = c.yyy, col=c.yyy;\n\tfloat di = 0.;\n    \n    //raymarching\n    for(int i=0; i<100; ++i)\n    {\n        x = o + di*d;\n        s = scene(x);\n        if(s.x < 1.e-4)break;\n        if(i==99)\n        {\n            fragColor = vec4(mix(.2*c.xxx, .5*c.xxx, round(1.*(.5+.5*sin(6.*atan(uv.y/uv.x)+3.e-1*iTime)))/1.), 1.);\n            return;\n        }\n        di += s.x;\n    }\n\n    //colorize\n    vec3 n = normal(x), l = 2.*c.yyx, v = normalize(x-o), r = normalize(reflect(-l,n));\n    \n    col = .4*abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+12.4*s.y))*.3*c.xyy))\n        + .4*abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+3.6*s.y))*.4*c.xyy*dot(l, n)))\n        + abs((rot(vec3(1.3, 1.45, 1.56)*(iTime+15.1*s.y))*2.5*c.xxy*pow(abs(dot(r,v)), 5.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[943, 959, 980, 980, 1050], [1052, 1090, 1142, 1142, 1230], [1232, 1261, 1307, 1360, 2095], [2097, 2097, 2115, 2115, 2365], [2367, 2367, 2387, 2387, 2556], [2558, 2558, 2579, 2579, 2714], [2716, 2716, 2773, 2792, 3715]]}
{"id": "MdyBWR", "name": "solarium", "author": "lennyjpg", "description": "fffffff", "tags": ["fffff"], "likes": 2, "viewed": 342, "date": "1528237536", "time_retrieved": "2024-06-20T19:15:39.514061", "image_code": "void mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec2 uv = f/iResolution.y-0.5;\n    fragColor = vec4(sin(atan(uv.y, uv.x)*iTime*10.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 49, 49, 142]]}
{"id": "MdyfRK", "name": "Live Jigsaw", "author": "dr2", "description": "Self-solving jigsaw with live image", "tags": ["wave", "sunset", "bird", "puzzle", "jigsaw"], "likes": 15, "viewed": 690, "date": "1529507984", "time_retrieved": "2024-06-20T19:15:39.677715", "image_code": "// \"Live Jigsaw\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Self-solving jigsaw with live image\n\n// Tiling based on simplified (textureless) version of Shane's \"Jigsaw\"\n// Scenery updated from my old \"Seabirds at Sunset\"\n\n#define AA  0   // optional antialiasing\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrSphDf (vec3 p, float r);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 birdMat[2], bdMat;\nvec3 birdPos[2], bdPos, fltBox, qHit, qnBlk, sunDir, waveDisp, cloudDisp, ltDir, blkSize;\nfloat dstFar, tCur, birdVel, birdLen, legAng;\nint idObj, idObjGrp;\nconst int idWing = 1, idBdy = 2, idEye = 3, idBk = 4, idLeg = 5;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat BdWingDf (vec3 p, float dMin)\n{\n  vec3 q, qh;\n  float wngFreq, wSegLen, wChord, wSpar, fTap, tFac, d, dd, a, wr, wf;\n  wngFreq = 6.;\n  wSegLen = 0.15 * birdLen;\n  wChord = 0.3 * birdLen;\n  wSpar = 0.03 * birdLen;\n  fTap = 8.;\n  tFac = (1. - 1. / fTap);\n  q = p - vec3 (0., 0., 0.3 * birdLen);\n  q.x = abs (q.x) - 0.1 * birdLen;\n  wf = 1.;\n  a = -0.1 + 0.2 * sin (wngFreq * tCur);\n  d = dMin;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar, wr * wChord), - q.x));\n    }\n    if (dd < d) { d = dd;  qh = q; }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  q = qh;\n  DMINQ (idObjGrp + idWing);\n  return dMin;\n}\n\nfloat BdBodyDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float bkLen, d, a, wr, tr, u;\n  bkLen = 0.15 * birdLen;\n  q = p;\n  wr = q.z / birdLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * birdLen, birdLen);\n  DMINQ (idObjGrp + idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= birdLen * vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009 * birdLen, 0.2 * birdLen);\n  DMINQ (idObjGrp + idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04 * birdLen);\n  DMINQ (idObjGrp + idEye);\n  q = p;  q -= birdLen * vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.25 * wr * bkLen, 0.25 * wr * bkLen, bkLen);\n  DMINQ (idObjGrp + idBk);\n  return dMin;\n}\n\nfloat BdFootDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float lgLen, ftLen, d;\n  lgLen = 0.1 * birdLen;\n  ftLen = 0.5 * lgLen;\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.1, -0.12, 0.6);\n  q.yz = Rot2D (q.yz, legAng);\n  q.xz = Rot2D (q.xz, -0.05 * pi);\n  q.z += lgLen;\n  d = PrCylDf (q, 0.15 * lgLen, lgLen);\n  DMINQ (idObjGrp + idLeg);\n  q.z += lgLen;\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (q.xy, floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) * (2. * pi / 3.));\n  q.xz = Rot2D (q.xz, - pi + 0.4 * legAng);\n  q.z -= ftLen;\n  d = PrCapsDf (q, 0.2 * ftLen, ftLen);\n  DMINQ (idObjGrp + idLeg);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < 2; k ++) {\n    idObjGrp = (k + 1) * 256;\n    q = birdMat[k] * (p - birdPos[k]);\n    dMin = BdWingDf (q, dMin);\n    dMin = BdBodyDf (q, dMin);\n    dMin = BdFootDf (q, dMin);\n  }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec4 col4;\n  vec3 nn;\n  float gw, w;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (id == idWing) {\n    gw = 0.15 * birdLen;\n    w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col4 = vec4 (mix (vec3 (0.05), vec3 (1.), w), 0.1);\n  } else if (id == idEye) {\n    col4 = vec4 (0., 0.6, 0., 1.);\n  } else if (id == idBdy) {\n    if (ig == 1) nn = birdMat[0] * n;\n    else nn = birdMat[1] * n;\n    col4 = vec4 (mix (mix (vec3 (1.), vec3 (0.1), smoothstep (0.5, 1., nn.y)), vec3 (1.),\n       1. - smoothstep (-1., -0.7, nn.y)), 0.1);\n  } else if (id == idBk) {\n    col4 = vec4 (1., 1., 0., 0.1);\n  } else if (id == idLeg) {\n    col4 = vec4 ((0.5 + 0.4 * sin (100. * qHit.z)) * vec3 (0.6, 0.4, 0.), 0.1);\n  }\n  col4.gb *= 0.7;\n  return col4;\n}\n\nvec3 BirdTrack (float t)\n{\n  vec3 bp, tt, fbR;\n  float ti[9], rdTurn, tC, tCyc, tSeq, a, h, hd, tf, rSeg;\n  rdTurn = 0.45 * min (fltBox.x, fltBox.z);\n  t = - t;\n  rdTurn = 0.45 * min (fltBox.x, fltBox.z);\n  tC = 0.5 * pi * rdTurn / birdVel;\n  tt = vec3 (fltBox.x - rdTurn, length (fltBox.xy), fltBox.z - rdTurn) * 2. / birdVel;\n  tCyc = 2. * (2. * tt.z + tt.x  + 4. * tC + tt.y);\n  tSeq = mod (t, tCyc);\n  ti[0] = 0.;  ti[1] = ti[0] + tt.z;  ti[2] = ti[1] + tC;\n  ti[3] = ti[2] + tt.x;  ti[4] = ti[3] + tC;  ti[5] = ti[4] + tt.z;\n  ti[6] = ti[5] + tC;  ti[7] = ti[6] + tt.y;  ti[8] = ti[7] + tC;\n  h = - fltBox.y;\n  hd = 1.;\n  if (tSeq > 0.5 * tCyc) { tSeq -= 0.5 * tCyc;  h = - h;  hd = - hd; }\n  rSeg = -1.;\n  fbR = vec3 (1.);\n  fbR.xz -= vec2 (rdTurn) / fltBox.xz;\n  bp.xz = fltBox.xz;\n  bp.y = h;\n  if (tSeq < ti[4]) {\n    if (tSeq < ti[1]) {\n      tf = (tSeq - ti[0]) / (ti[1] - ti[0]);\n      bp.xz *= vec2 (1., fbR.z * (2. * tf - 1.));\n    } else if (tSeq < ti[2]) {\n      tf = (tSeq - ti[1]) / (ti[2] - ti[1]);  rSeg = 0.;\n      bp.xz *= fbR.xz;\n    } else if (tSeq < ti[3]) {\n      tf = (tSeq - ti[2]) / (ti[3] - ti[2]);\n      bp.xz *= vec2 (fbR.x * (1. - 2. * tf), 1.);\n    } else {\n      tf = (tSeq - ti[3]) / (ti[4] - ti[3]);  rSeg = 1.;\n      bp.xz *= fbR.xz * vec2 (-1., 1.);\n    }\n  } else {\n    if (tSeq < ti[5]) {\n      tf = (tSeq - ti[4]) / (ti[5] - ti[4]);\n      bp.xz *= vec2 (- 1., fbR.z * (1. - 2. * tf));\n    } else if (tSeq < ti[6]) {\n      tf = (tSeq - ti[5]) / (ti[6] - ti[5]);  rSeg = 2.;\n      bp.xz *= - fbR.xz;\n    } else if (tSeq < ti[7]) {\n      tf = (tSeq - ti[6]) / (ti[7] - ti[6]);\n      bp.xz *= vec2 (fbR.x * (2. * tf - 1.), - 1.);\n      bp.y = h + 2. * fltBox.y * hd * tf;\n    } else {\n      tf = (tSeq - ti[7]) / (ti[8] - ti[7]);  rSeg = 3.;\n      bp.xz *= fbR.xz * vec2 (1., -1.);\n      bp.y = - h;\n    }\n  }\n  if (rSeg >= 0.) {\n    a = 0.5 * pi * (rSeg + tf);\n    bp += rdTurn * vec3 (cos (a), 0., sin (a));\n  }\n  return vec3 (bp.z, bp.y + 1.2 * fltBox.y, - bp.x);\n}\n\nvoid BirdPM (float t)\n{\n  vec3 bpF, bpB, vel, acc, va, ort, cr, sr;\n  float vy, el, dt;\n  dt = 1.;\n  bdPos = BirdTrack (t);\n  bpF = BirdTrack (t + dt);\n  bpB = BirdTrack (t - dt);\n  vel = (bpF - bpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (bpF - 2. * bdPos + bpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  el = - 0.7 * asin (vel.y / length (vel));\n  ort = vec3 (el, atan (vel.z, vel.x) - 0.5 * pi, 0.2 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  bdMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  legAng = pi * clamp (0.4 + 1.5 * el, 0.12, 0.8);\n}\n\nfloat WaveHt (vec3 p)\n{\n  float ht, w, wb;\n  p *= 0.03;\n  ht = 0.5 * sin (2. * dot (p.xz + 20. * waveDisp.xz, vec2 (1.)));\n  p += waveDisp;\n  wb = 1.414;\n  w = wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) + 20. * waveDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p) - vec2 (WaveHt (p + e.xyy), WaveHt (p + e.yyx)), e.x).xzy);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p;\n  float ds, fd, att, attSum, d, sd;\n  p = ro + rd * (200. - ro.y) / rd.y;\n  ds = 0.1 * sqrt (length (ro - p));\n  fd = 0.001 / (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz -= cloudDisp.xz;\n  p *= 3.;\n  att = Fbm2 (p.xz);\n  attSum = att;\n  fd *= 3.;\n  d = fd;\n  ds *= fd;\n  for (int j = 0; j < 4; j ++) {\n    attSum += Fbm2 (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  sd = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n     0.3 * (vec3 (1., 0.4, 0.2) * pow (sd, 256.) + vec3 (1., 0.8, 0.7) * pow (sd, 1024.));\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2),\n     att * (0.001 + 0.999 * smoothstep (0.001, 0.004, rd.y))), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 4.) * (pow (sd, 8.) + 0.5);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, reflFac, dw;\n  reflFac = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (rd.y < 0. && dstObj >= dstFar) {\n    dw = - (ro.y + 1.5) / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaveNf (ro, dw));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    reflFac *= 0.7;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    col4 = BirdCol (vn);\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n       col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n  } else col = SkyCol (ro, rd);\n  return reflFac * col;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 blkSize)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat JigDist (vec2 p, vec4 dpEdge, bool evOdd)\n{\n  vec4 a, cc, s;\n  vec2 e, bx, by;\n  float ecShift, ecRad, tcRad, d;\n  e = vec2 (0, 1);\n  e = evOdd ? e : e.yx;\n  ecShift = 2.;\n  ecRad = length (vec2 (0.5, 0.5 + ecShift));\n  bx = ecShift * e.yx;\n  by = (1. + ecShift) * e.xy;\n  d = max (length (abs (p) + bx) - ecRad, ecRad - length (abs (p) - by));\n  if (evOdd) dpEdge = dpEdge.zwxy;\n  a = 0.05 * pi * clamp (0.5 - dpEdge, -0.2, 0.2);\n  ecRad -= 0.02;\n  s = (2. * step (vec4 (0.5), dpEdge) - 1.) * vec4 (-1., 1., -1., 1.);\n  tcRad = 0.12;\n  d = s.x * min (s.x * d, length (Rot2D (p + bx, a.x) - ecRad * e.yx)- tcRad);\n  d = s.y * min (s.y * d, length (Rot2D (p - bx, a.y) + ecRad * e.yx)- tcRad);\n  d = s.z * min (s.z * d, length (Rot2D (p - by, a.z) + ecRad * e.xy)- tcRad);\n  d = s.w * min (s.w * d, length (Rot2D (p + by, a.w) - ecRad * e.xy)- tcRad);\n  return d;\n}\n\nvec3 JigPat (vec2 p, float rndOff)\n{\n  vec4 dpEdge;\n  vec2 cID, e, q, iq;\n  float d, h;\n  d = dstFar;\n  e = vec2 (0.5, 0.);\n  for (float iy = 0.; iy < 2.; iy ++) {\n    for (float ix = 0.; ix < 2.; ix ++) {\n      q = p + vec2 (ix, iy);\n      iq = floor (q / 2.) * 2. - vec2 (ix, iy);\n      dpEdge = vec4 (Hashfv2 (iq + rndOff + e.yx), Hashfv2 (iq + rndOff - e.yx),\n         Hashfv2 (iq + rndOff + e.xy), Hashfv2 (iq + rndOff - e.xy));\n      h = JigDist (mod (q, 2.) - 1., dpEdge, (ix == iy));\n      if (h < d) {\n        cID = iq;\n        d = h;\n      }\n    }\n  }\n  return vec3 (- d, cID);\n}\n\nvec3 ShowSceneBlk (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, jp;\n  vec2 cID, w;\n  float dBlk, t, rndOff;\n  bool isImg;\n  dBlk = BlkHit (ro, rd, blkSize);\n  if (dBlk < dstFar) {\n    ro += dBlk * rd;\n    vn = qnBlk;\n    isImg = false;\n    if (vn.y > 0.99) {\n      col = vec3 (0.2, 0.3, 0.2);\n      t = tCur / 30. + 0.1;\n      rndOff = 17. * floor (t);\n      jp = JigPat (ro.xz, rndOff);\n      cID = jp.yz;\n      w = abs (cID) / blkSize.xz;\n      if (Hashfv2 (cID + rndOff) < clamp (3.2 * SmoothBump (0.2, 0.8, 0.18,\n         mod (t, 1.)) + 2. * max (w.x, w.y) - 2.2, 0., 1.)) {\n        col = ShowScene (vec3 (0., 4., -30.), normalize (vec3 (ro.xz / blkSize.z, 2.4)));\n        col = mix (vec3 (0.2), col, smoothstep (0.015, 0.025, jp.x));\n        isImg = true;\n      }\n    } else col = vec3 (0.2, 0.2, 0.3);\n    if (isImg) col = clamp (col * mix (1., smoothstep (0., 1., Maxv3 (col)), 0.2), 0., 1.);\n    else {\n      if (vn.y > 0.99) vn = VaryNf (128. * ro, vn, 0.5);\n      col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n         0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);\n    }\n  } else col = vec3 (0.7, 0.7, 0.8) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  sunDir = normalize (vec3 (0., 0.05, 1.));\n  waveDisp = 0.001 * tCur * vec3 (1., 0., 1.);\n  cloudDisp = 0.05 * tCur * vec3 (1., 0., -1.);\n  birdLen = 1.2;\n  birdVel = 7.;\n  fltBox = vec3 (12., 4., 12.);\n  for (int k = 0; k < 2; k ++) {\n    BirdPM (tCur + float (k) * 10.);\n    birdMat[k] = bdMat;\n    birdPos[k] = bdPos;\n  }\n  dstFar = 100.;\n  blkSize = vec3 (16.25, 0.1, 9.25);\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -4. * blkSize.x);\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 6.8));\n    col += (1. / naa) * ShowSceneBlk (ro, rd);\n  }\n  fragColor = vec4 (pow (clamp (col, 0., 1.), vec3 (0.8)), 1);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  if (f > 0.001) {\n    g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n    n += f * (g - n * dot (n, g));\n    n = normalize (n);;\n  }\n  return n;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[159, 1112, 1149, 1149, 2126], [2128, 2128, 2165, 2165, 3048], [3050, 3050, 3087, 3087, 3673], [3675, 3675, 3697, 3697, 3960], [3962, 3962, 3995, 3995, 4171], [4173, 4173, 4194, 4194, 4394], [4396, 4396, 4419, 4419, 5209], [5211, 5211, 5237, 5237, 7217], [7219, 7219, 7242, 7242, 7971], [7973, 7973, 7996, 7996, 8311], [8313, 8313, 8344, 8344, 8497], [8499, 8499, 8531, 8531, 9489], [9491, 9491, 9526, 9526, 10118], [10120, 10120, 10167, 10167, 10594], [10596, 10596, 10645, 10645, 11466], [11468, 11468, 11504, 11504, 12057], [12059, 12059, 12097, 12097, 13248], [13250, 13250, 13303, 13303, 14711], [14713, 14713, 14746, 14746, 14773], [14775, 14775, 14818, 14818, 14882], [14884, 14884, 14926, 14926, 14977], [14979, 14979, 15038, 15038, 15142], [15144, 15144, 15190, 15190, 15247], [15249, 15249, 15271, 15271, 15309], [15311, 15311, 15368, 15368, 15451], [15453, 15453, 15483, 15483, 15596], [15630, 15630, 15654, 15654, 15714], [15716, 15716, 15740, 15740, 15870], [15872, 15872, 15896, 15896, 16116], [16118, 16118, 16143, 16143, 16329], [16331, 16331, 16356, 16356, 16581], [16583, 16583, 16604, 16604, 16759], [16761, 16761, 16790, 16790, 17002], [17004, 17004, 17043, 17043, 17268]]}
{"id": "Mdyfz3", "name": "Plasmic travel", "author": "Himred", "description": "An experiment that turned pretty nice\nNicer in full screen", "tags": ["raymarch", "plasma"], "likes": 4, "viewed": 416, "date": "1529749602", "time_retrieved": "2024-06-20T19:15:39.829156", "image_code": "float m(vec3 p) \n{ \n    p.y+=1.5*sin(p.x+iTime*2.);\n\tp.z+=3.*iTime; \n    return length(.1*sin(p.x/1.5+p.y)+cos(p.zzx/4.))-.9; \n}\n\nvoid mainImage(out vec4 c,vec2 u)\n{\n    vec3 d=.9-vec3(u/.65,0)/iResolution.x,o=d;\n    for(int i=0;i<64;i++) o+=m(o)*d;\n    c.rgb = abs(m(o*1.8)*vec3(.3+sin(o.x)/3.,.1,.1)+m(o*.5)*vec3(.1,.05,0))*(9.-o.y/3.);\n    // Kind of fire flame effect\n    //c.rgb = 1.*abs(m(o+d)*vec3(.3,.15,.1)+m(o*.5)*vec3(.1,.05,0))*(12.-o.x/2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdyfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 18, 18, 128], [130, 130, 165, 165, 455]]}
{"id": "Mdyfzc", "name": "NOVA 18 Showdown Final - yx", "author": "yx", "description": "Hastily coded live in 25 minutes at NOVA 2018. Coded in Bonzomatic, adapted here for shadertoy.", "tags": ["showdown", "nova18"], "likes": 11, "viewed": 671, "date": "1529787259", "time_retrieved": "2024-06-20T19:15:39.829156", "image_code": "// fuck your digits\n#define pi (acos(-1.))\n\nfloat noise(vec2 uv)\n{\n  return fract(sin(dot(uv, vec2(12.43243,4.543))*46573.71254));\n}\n\nfloat mlength(vec2 a)\n{\n  a=abs(a);\n  return max(a.x,a.y);\n}\n\nvec2 R(vec2 a, float b)\n{\n  float c =cos(b);\n  float s =sin(b);\n  return vec2(\n    a.x*c-a.y*s,\n    a.x*s+a.y*c\n  );\n}\n\n// :)\nfloat IKEDA(vec2 uv,float th)\n{\n  th = min(.5,th);\n  uv = R(uv,sin(floor(iTime*2.)));\n\n  //return mlength(uv)<4. ? 1. : 0.;\n\n  uv.x *= 15.;\n  \n\n  float sc = mix(.4,.1,noise(vec2(0,floor(uv.y))));\n  float sp = noise(vec2(1,floor(uv.y)))+2.;\n  uv.x+=sp*iTime*5.;\n  uv.x*=sc;\n  float n = noise(floor(uv));\n  n = fract(n+iTime*sp);\n  uv.x += iTime*10.;\n  return n>th&&fract(uv.y)>.35 && fract(uv.x*.5) < .8 ?1.:0.;\n}\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvec4 pal(vec4 a, vec4 b, vec4 c, vec4 d, float t)\n{\n  return a+b*cos(2.*pi*(c*t+d));\n}\n\n// <3\nvec4 logichroma(float t)\n{\n  return pal(\n    vec4(.5),\n    vec4(.5),\n    vec4(1.),\n    vec4(0,.33,.67,1),\n    t\n  );\n}\n\nvec3 SG(vec2 uv)\n{\n  return vec3(\n    (2.*uv) /  (1.+dot(uv,uv)),\n    (-1.+dot(uv,uv)) /  (1.+dot(uv,uv))\n  );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 suv = fragCoord.xy / iResolution.xy;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float v = (1.-length(uv))*3.;\n  v=clamp(v,0.,1.);\n\n  vec3 s = SG(uv*3.);\n  s.xz = R(s.xz,iTime*1.9);\n  float m = s.x*s.z > 0. ? 1. : 0.;\n\n  float f = texture(iChannel0, vec2(0.005,0)).r*.5;\n\n\n  m = s.x*40.+.5 + f*4.;\n  m = clamp(m,0.,1.);\n\n\n  uv *= 1.-f*.8;\n  out_color=vec4(.0);\n  for(int i=0;i<30;++i)\n  {\n    out_color += vec4(IKEDA(uv*12.,.2+f*.5)) * logichroma(1.-float(i)/30.) * (1.-(float(i)/30.));\n    uv *= pow(0.992,1.-f);\n    uv.x+=sin(iTime)*.002;\n    uv.y+=cos(iTime)*.002;\n  }\n  out_color *= .1;\n  out_color = mix(out_color, 1.-out_color, m);\n  out_color *= v;\n}", "image_inputs": [{"id": "XdjSz3", "previewfilepath": "https://soundcloud.com/space-laces/space-laces-dungeons-and-dragons", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/space-laces/space-laces-dungeons-and-dragons", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdyfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 44, 66, 66, 132], [134, 134, 157, 157, 194], [196, 196, 221, 221, 314], [316, 322, 353, 353, 734], [736, 736, 769, 769, 934], [936, 936, 987, 987, 1022], [1024, 1030, 1056, 1056, 1148], [1150, 1150, 1168, 1168, 1262], [1264, 1264, 1316, 1316, 2077]]}
{"id": "Mljczy", "name": "const step ray marching", "author": "tylerbata", "description": "Made to test my other program to visualize the octree inefficiently.  ", "tags": ["raymarching"], "likes": 1, "viewed": 196, "date": "1528243124", "time_retrieved": "2024-06-20T19:15:39.835336", "image_code": "float scale = 2.0;\n\nfloat min3(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\nfloat max3(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 p) {\n    //return min(max(-sdSphere(p, 7.5 * scale), sdBox(p, vec3(6.0) * scale)), -sdSphere(p, 25.0 * scale));\n    return max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));\n}\n\n\n\nfloat hitBox(vec3 ro, vec3 rd, vec3 box0, vec3 box1, float minMax) {\n\tvec3 pos0 = (box0 - ro) / rd;\n\tvec3 pos1 = (box1 - ro) / rd;\n\tfloat tmin = max3(min(pos0, pos1));\n\tfloat tmax = min3(max(pos0, pos1));\n    \n    float t = (bool(minMax))? tmax : tmin;\n\treturn (tmin < tmax && tmax > 0.0)? t : -1.0;\n}\n\n\nfloat cast_ray( in vec3 ro, in vec3 rd, float t, float tmin,float tmax)\n{\n\tfloat precis = 0.005;\n    float delta = 0.05;\n    int steps = int((tmax - tmin) / delta);\n    for( int i=0; i < steps; i++ )\n    {\n\t    float tempT = map( ro+rd*t);\n        if( tempT<precis || t>tmax ) break;\n        t += delta;\n    }\n\n\tif(t + delta*1.5 > tmax)t = -1.0;\n\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rd = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 ro = vec3(0.0, 2.0 * sin(iTime), -25.0);\n\tro.xz = rotate2d(ro.xz, iTime*0.1);\n\trd.xz = rotate2d(rd.xz, iTime*0.1);\n\n    \n    float tEntry = hitBox(ro,rd,vec3(-6.0), vec3(6.0), 0.0);\n    float tExit = hitBox(ro,rd,vec3(-6.0), vec3(6.0), 1.0);\n    float dt = tExit - tEntry;\n    \n    float t = -1.0;\n    vec3 col = rd;\n    \n    if(tEntry > 0.0)\n        t = cast_ray(ro,rd,tEntry,tEntry,tExit);\n    \n    \n    col = vec3(t / 64.0);\n    \n    \n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mljczy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 20, 40, 40, 75], [76, 76, 96, 96, 131], [133, 133, 165, 165, 276], [278, 278, 311, 311, 335], [338, 338, 369, 369, 465], [467, 467, 486, 593, 651], [655, 655, 723, 723, 956], [959, 959, 1032, 1032, 1321], [1325, 1325, 1382, 1382, 2165]]}
{"id": "MlyGzd", "name": "Nyan Cat Squadron", "author": "Gnurou", "description": "Playing with Nyan-kun. Work in progress. Probably a lot that can be optimized.", "tags": ["nyan"], "likes": 0, "viewed": 185, "date": "1527859431", "time_retrieved": "2024-06-20T19:15:41.023225", "image_code": "// Use camera as background instead of generated stars?\n#define ENABLE_TEXTURE_BG false\n#define NB_CATS 10\n#define NB_STARS 10\n#define NB_RAINBOW_COLS 6\n\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define STAR_W 7\n#define STAR_H 7\n#define STAR_NB_FRAMES 4\n\nbool bounding_box_check(vec2 uv, vec2 top, vec2 bottom)\n{\n    return all(lessThan(top, uv)) && all(lessThan(uv, bottom));\n}\n\nvec4 nyancat_rainbow(in vec2 uv, in float factor)\n{\n    const vec3 colors[] = vec3[](\n        vec3(0.5, 0.0, 1.0),\n        vec3(0.0, 0.7, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n        vec3(1.0, 0.5, 0.0),\n        vec3(1.0, 0.0, 0.0)\n    );\n    const float start = 0.21;\n    const float size = 0.57;\n    const float ssize = size / float(NB_RAINBOW_COLS);\n    const float shift = 0.014;\n    // TODO replace this with parameter, set properly from\n    // caller\n    const float rear = .25;\n    float pos = start;\n    vec4 col;\n    \n#define RAINBOW_LENGTH 4.    \n    // Early return if bounding box check fails\n    if (!bounding_box_check(uv, vec2(-RAINBOW_LENGTH, start),\n                                vec2(rear, start + size + shift)))\n        return vec4(0.);\n    \n    if (int(mod(uv.x * 6.0 + round(iTime * 3.0), 2.0)) == 1)\n        pos += shift;\n\n    for (int i = 0; i < NB_RAINBOW_COLS; i++) {\n\t    float c;\n        float end = pos + ssize;\n\t    c = 1.0 - step(uv.y, pos);\n\t    c *= step(uv.y, end);\n\t    c *= step(uv.x, rear);    \n\t    col.rgb += colors[i] * c;\n        col.a += c;\n        pos = end;\n    }\n    \n    // Make fade out vary with time.\n    float rstart = -RAINBOW_LENGTH - abs(sin(iTime * 3.0) / 4.);\n    col.a = col.a != 0. ?\n        smoothstep(rstart, rear, uv.x - rear) : \n    \t0.0;\n    \n    return vec4(col);\n}\n\nvec4 nyancat(in vec2 uv, in float factor, in float angle)\n{\n\tint frame = int(floor(mod((iTime + factor) * 13.0, 6.0)));\n\n    vec4 c = nyancat_rainbow(uv + 0.5, factor);\n\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));    \n    uv += 0.5;\n    \n    uv = clamp(uv, 0.0, 1.0);\n    \n    // Return early is bounding box test fails\n    if (!bounding_box_check(uv, vec2(0., 0.), vec2(1., 1.)))\n        return c;\n\n    // Scale to 1 frame\n    uv.x *= 40.0 / 256.0;\n    // Choose frame\n    uv.x += float(frame) * (40.0 / 256.0);\n    \n    vec4 t = texture(iChannel0, uv);\n    \n    return vec4(mix(c.rgb, t.rgb, t.a), clamp(c.a + t.a, 0.0, 1.0));\n}\n\n// TODO return Z as well so we know how to mix colors\nvec4 nyancat_moving(in vec2 uv, in float factor)\n{\n\tconst float rotCenter = 0.5;\n    // Rotation center\n    uv -= rotCenter;\n    // Fix aspect ration\n    uv.x /= iResolution.y / iResolution.x;\n    \n    // Initial position\n    uv += vec2(-.6 + rand(vec2(factor * 1.5, factor)), -.5 + rand(vec2(factor * 2.3, factor)));\n\n    // Translate\n    //uv -= vec2(sin(iTime * factor / 2.0) / 2.0, sin(iTime / 3.3 * factor) / 3.0);\n    \n    uv += vec2(sin(iTime + factor) / (factor + 1.0),\n               sin(iTime + factor) / (factor + 10.0));\n    \n    // Scale\n    float scalefactor = ((sin(iTime) / 2.0) + factor + 1.7);\n    uv *= mat2(scalefactor, 0.0, 0.0, scalefactor);\n\n    // Rotate\n    const float fac = 15.0;\n    const float speed = 7.0;\n    float angle = sin(iTime * speed) / factor / fac;\n    angle = abs(angle);\n\n    return nyancat(uv, factor, angle);\n}\n\nvec4 gen_bg(in vec2 uv)\n{\n    vec2 bguv = uv / iResolution.xy;\n    if (!ENABLE_TEXTURE_BG) {\n\t    float scalefactor2 = (sin(iTime) / 5.0) + 1.0;\n   \t\tbguv *= mat2(scalefactor2, 0.0, 0.0, scalefactor2);\n    \tbguv.x += iTime / 1.2;\n    }\n\n    return texture(iChannel1, bguv);\n}\n\n// Star is drawn from (-.5, -.5) to (.5, .5)\nvec4 gen_star(in vec2 uv, float factor)\n{\n    const float xstep = 1.0 / float(STAR_W);\n    const float ystep = 1.0 / float(STAR_H);\n    \n    // Move to center\n    uv -= .5;\n    \n    // Fix aspect ratio\n    uv.x /= iResolution.y / iResolution.x;\n\n#define SCALE_DOWN 10.\n    // Scale down\n    // TODO vary size and speed down as star is further away?\n    uv *= SCALE_DOWN;\n\n    // Randomize y and starting x according to factor\n    // TODO also randomize y according to iTime modulo width of scene\n    uv.y += ((factor * SCALE_DOWN) - (SCALE_DOWN / 2.));\n    uv.x += ((rand(vec2(factor)) * SCALE_DOWN) - (SCALE_DOWN / 2.));\n\n    // Scroll x according to time and speed\n    // TODO aspect ratio not taken into account?\n    float speed = SCALE_DOWN / 1.2;\n    uv.x = -(SCALE_DOWN / 2.) + mod(uv.x + iTime * speed, SCALE_DOWN);\n    \n    // Return early if bounding box test fails\n    if (!bounding_box_check(uv, vec2(-.5, -.5), vec2(.5, .5)))\n        return vec4(0.);\n\n    int frame = int(mod((iTime + factor * PI * 10.) * 6.,\n                        float(STAR_NB_FRAMES) + 10.));\n    \n    // Early return if end of animation\n    if (frame >= STAR_NB_FRAMES)\n        return vec4(0.);\n\n    // DEBUG: is the correct frame selected?\n    // return vec4(vec3(float(frame) / float(STAR_NB_FRAMES)), 1.);\n    \n    // Find the pixel coordinate of the star \n    int py = int(floor((uv.y + .5) * float(STAR_H)));\n    int px = int(floor((uv.x + .5) * float(STAR_W)));\n    \n    // Mirror x and y to get the correct pixel data\n    py = abs(py - 3);\n    px = abs(px - 3);\n    \n    vec4 p1 = vec4(1.);\n    vec4 p0 = vec4(0.);\n    \n    // Early filter of most transparent pixels\n\tif (frame != 3 && (px != 0 && py !=0))\n        return p0;\n    \n    // For frame 0, the second pixel on each axis is set\n    if (frame == 0)\n        return (px | py) == 1 ? p1 : p0;\n    \n    // For frame 1, the second and third pixel on each axis is set\n    if (frame == 1) {\n        px |= py;\n        return (px == 1 || px == 2) ? p1 : p0;\n    }\n    \n    if (frame == 2)\n        return (px | py) != 1 ? p1 : p0;\n    \n    if (frame == 3) {\n        if (px == 0 || py == 0) {\n            px |= py;\n            return px == 3 ? p1 : p0;\n        }\n        \n        return px == 2 && py == 2 ? p1 : p0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n  \tvec3 col;\n    vec4 fg;\n\n    // Background\n\tif (ENABLE_TEXTURE_BG)\n\t    col = gen_bg(fragCoord.xy).rgb;\n    else\n    \tcol = vec3(.16, .16, .45);\n\n    for (int i = 0; i < NB_STARS; i++) {\n\t    fg = gen_star(uv, rand(vec2(float(i))));\n  \t    col = mix(col, fg.rgb, fg.a);\n    }\n\n    for (int i = 0; i < NB_CATS; i++) {\n\t    fg = nyancat_moving(uv, float(NB_CATS - i));\n\t    col = mix(col, fg.rgb, fg.a);\n    }\n    // TODO make sure cat is drawn on (-.5, .5) scale inside\n    // function (makes bounding box check easier).\n//    fg = nyancat_moving(uv, 1.0);\n//    uv -= .5; fg = nyancat(uv, 1.0, 0.);\n//    fg = nyancat_rainbow(uv - vec2(.75, 0.), 1.0);\n    col = mix(col, fg.rgb, fg.a);\n\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlyGzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 207, 227, 227, 299], [361, 361, 418, 418, 484], [486, 486, 537, 537, 1843], [1845, 1845, 1904, 1904, 2496], [2498, 2552, 2602, 2602, 3406], [3408, 3408, 3433, 3433, 3683], [3685, 3730, 3771, 3771, 5994], [5996, 5996, 6053, 6053, 6820]]}
{"id": "MsGBDD", "name": "Orthographic 4D Polytopes", "author": "Ebanflo", "description": "Behold, the best shape.\n\nMouse controls 2 of the 6 rotation parameters. See the code to change the other 4 parameters and see the orthoplex or tesseract.", "tags": ["2d", "math", "4d", "polytope"], "likes": 9, "viewed": 517, "date": "1529135582", "time_retrieved": "2024-06-20T19:15:42.429294", "image_code": "/*\nIf you have a cube, and you make a square pyramid from each face to the center,\nthen turn each pyramid inside out, you get a rhombic dodecahedron. This is a very nice\nshape; its kind of like a combination of a cube and octahedron, except it isn't\nplatonic. If you perform this construction in 4D, however, you do get a platonic solid:\nthe 24-cell! It is also called the octaplex because of its octahedral faces.\nIt's a surprisingly easy exercise to show that this is indeed a platonic solid.\nThe fact that it has octahedral faces makes it easy to see that its Schlafi symbol is\n{3,4,3}, meaning it is also self-dual! And it tiles 4D space for the same reason the\nrhombic dodecahedron tiles 3D space! Thus, it is objectively the best shape.\nIn addition, it shares vertices with a standard tesseract and orthoplex (4D octahedron),\nwhich makes it easy to render all three with the same code.\n*/\n\n#define AA 1\n\nconst bool octaplex = true; //24-cell\nconst bool tesseract = false; //8-cell\nconst bool orthoplex = false; //16-cell\n\n#define speed1 0.1\n#define speed2 0.2\n#define speed3 0.3\n#define speed4 0.4\n\n//cube verts\n#define h1 vec2(0.5, -0.5)\n\n#define v1 h1.xxxx\n#define v2 h1.yxxx\n#define v3 h1.xyxx\n#define v4 h1.xxyx\n#define v5 h1.xxxy\n#define v6 h1.yyxx\n#define v7 h1.xyyx\n#define v8 h1.xxyy\n#define v9 h1.yxxy\n#define v10 h1.xyxy\n#define v11 h1.yxyx\n#define v12 h1.yyyx\n#define v13 h1.yyxy\n#define v14 h1.yxyy\n#define v15 h1.xyyy\n#define v16 h1.yyyy\n\n//pyramid verts\n#define h2 vec3(1, -1, 0)\n\n#define v17 h2.xzzz\n#define v18 h2.yzzz\n#define v19 h2.zxzz\n#define v20 h2.zyzz\n#define v21 h2.zzxz\n#define v22 h2.zzyz\n#define v23 h2.zzzx\n#define v24 h2.zzzy\n\nmat4 rot(float wx, float wy, float wz, float xy, float xz, float yz){\n    mat4 result = mat4(cos(wx), 0, 0, -sin(wx),\n                       0, 1, 0, 0,\n                       0, 0, 1, 0,\n                       sin(wx), 0, 0, cos(wx)\n                       );\n    result *= mat4(1, 0, 0, 0,\n                   0, cos(wy), 0, -sin(wy),\n                   0, 0, 1, 0,\n                   0, sin(wy), 0, cos(wy)\n                   );\n    result *= mat4(1, 0, 0, 0,\n                   0, 1, 0, 0,\n                   0, 0, cos(wz), -sin(wz),\n                   0, 0, sin(wz), cos(wz)\n                   );\n    result *= mat4(cos(xy), -sin(xy), 0, 0,\n                   sin(xy), cos(xy), 0, 0,\n                   0, 0, 1, 0,\n                   0, 0, 0, 1\n                   );\n    result *= mat4(cos(xz), 0, -sin(xz), 0,\n                   0, 1, 0, 0,\n                   sin(xz), 0, cos(xz), 0,\n                   0, 0, 0, 1\n                   );\n    result *= mat4(1, 0, 0, 0,\n                   0, cos(yz), -sin(yz), 0,\n                   0, sin(yz), cos(yz), 0,\n                   0, 0, 0, 1\n                   );\n    return result;\n}\n\nvec3 drawSegment(vec2 p, vec4 vertex1, vec4 vertex2){\n    float d = distance(vertex1.xy, vertex2.xy);\n    float d1 = distance(p, vertex1.xy);\n    float d2 = distance(p, vertex2.xy);\n    \n    if(abs(d - d1 - d2) < 0.0001)\n        return mix(0.5 + vertex1.xyz*inversesqrt(2.0 - 2.0*vertex1.w), 0.5 + vertex2.xyz*inversesqrt(2.0 - 2.0*vertex2.w), d1/d);\n    else return vec3(0);\n}\n\nvec3 render(vec2 fragCoord){\n    vec3 color = vec3(0);\n    \n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 m = 2.0*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    mat4 rotation =\n        rot(m.x, m.y, speed1*iTime, speed2*iTime, speed3*iTime, speed4*iTime);\n    \n    vec4 c1 = rotation*v1;\n    vec4 c2 = rotation*v2;\n    vec4 c3 = rotation*v3;\n    vec4 c4 = rotation*v4;\n    vec4 c5 = rotation*v5;\n    vec4 c6 = rotation*v6;\n    vec4 c7 = rotation*v7;\n    vec4 c8 = rotation*v8;\n    vec4 c9 = rotation*v9;\n    vec4 c10 = rotation*v10;\n    vec4 c11 = rotation*v11;\n    vec4 c12 = rotation*v12;\n    vec4 c13 = rotation*v13;\n    vec4 c14 = rotation*v14;\n    vec4 c15 = rotation*v15;\n    vec4 c16 = rotation*v16;\n    \n    vec4 p1 = rotation*v17;\n    vec4 p2 = rotation*v18;\n    vec4 p3 = rotation*v19;\n    vec4 p4 = rotation*v20;\n    vec4 p5 = rotation*v21;\n    vec4 p6 = rotation*v22;\n    vec4 p7 = rotation*v23;\n    vec4 p8 = rotation*v24;\n    \n    if(tesseract || octaplex){\n        color += drawSegment(xy, c1, c2);\n        color += drawSegment(xy, c1, c3);\n        color += drawSegment(xy, c1, c4);\n        color += drawSegment(xy, c1, c5);\n    \n        color += drawSegment(xy, c2, c6);\n        color += drawSegment(xy, c2, c9);\n        color += drawSegment(xy, c2, c11);\n        \n        color += drawSegment(xy, c3, c6);\n        color += drawSegment(xy, c3, c7);\n        color += drawSegment(xy, c3, c10);\n        \n        color += drawSegment(xy, c4, c7);\n        color += drawSegment(xy, c4, c8);\n        color += drawSegment(xy, c4, c11);\n\n        color += drawSegment(xy, c5, c8);\n        color += drawSegment(xy, c5, c9);\n        color += drawSegment(xy, c5, c10);\n    \n        color += drawSegment(xy, c6, c12);\n        color += drawSegment(xy, c6, c13);\n    \n        color += drawSegment(xy, c7, c12);\n        color += drawSegment(xy, c7, c15);\n    \n        color += drawSegment(xy, c8, c14);\n        color += drawSegment(xy, c8, c15);\n    \n        color += drawSegment(xy, c9, c13);\n        color += drawSegment(xy, c9, c14);\n    \n        color += drawSegment(xy, c10, c13);\n        color += drawSegment(xy, c10, c15);\n    \n        color += drawSegment(xy, c11, c12);\n        color += drawSegment(xy, c11, c14);\n    \n        color += drawSegment(xy, c16, c12);\n        color += drawSegment(xy, c16, c13);\n        color += drawSegment(xy, c16, c14);\n        color += drawSegment(xy, c16, c15);\n    }\n\n    if(octaplex){\n        color += drawSegment(xy, p1, c1);\n        color += drawSegment(xy, p1, c3);\n        color += drawSegment(xy, p1, c4);\n        color += drawSegment(xy, p1, c5);\n        color += drawSegment(xy, p1, c7);\n        color += drawSegment(xy, p1, c8);\n        color += drawSegment(xy, p1, c10);\n        color += drawSegment(xy, p1, c15);\n    \n        color += drawSegment(xy, p2, c2);\n        color += drawSegment(xy, p2, c6);\n        color += drawSegment(xy, p2, c9);\n        color += drawSegment(xy, p2, c11);\n        color += drawSegment(xy, p2, c12);\n        color += drawSegment(xy, p2, c13);\n        color += drawSegment(xy, p2, c14);\n        color += drawSegment(xy, p2, c16);\n    \n        color += drawSegment(xy, p3, c1);\n        color += drawSegment(xy, p3, c2);\n        color += drawSegment(xy, p3, c4);\n        color += drawSegment(xy, p3, c5);\n        color += drawSegment(xy, p3, c8);\n        color += drawSegment(xy, p3, c9);\n        color += drawSegment(xy, p3, c11);\n        color += drawSegment(xy, p3, c14);\n    \n        color += drawSegment(xy, p4, c3);\n        color += drawSegment(xy, p4, c6);\n        color += drawSegment(xy, p4, c7);\n        color += drawSegment(xy, p4, c10);\n        color += drawSegment(xy, p4, c12);\n        color += drawSegment(xy, p4, c13);\n        color += drawSegment(xy, p4, c15);\n        color += drawSegment(xy, p4, c16);\n    \n        color += drawSegment(xy, p5, c1);\n        color += drawSegment(xy, p5, c2);\n        color += drawSegment(xy, p5, c3);\n        color += drawSegment(xy, p5, c5);\n        color += drawSegment(xy, p5, c6);\n        color += drawSegment(xy, p5, c9);\n        color += drawSegment(xy, p5, c10);\n        color += drawSegment(xy, p5, c13);\n    \n        color += drawSegment(xy, p6, c4);\n        color += drawSegment(xy, p6, c7);\n        color += drawSegment(xy, p6, c8);\n        color += drawSegment(xy, p6, c11);\n        color += drawSegment(xy, p6, c12);\n        color += drawSegment(xy, p6, c14);\n        color += drawSegment(xy, p6, c15);\n        color += drawSegment(xy, p6, c16);\n    \n        color += drawSegment(xy, p7, c1);\n        color += drawSegment(xy, p7, c2);\n        color += drawSegment(xy, p7, c3);\n        color += drawSegment(xy, p7, c4);\n        color += drawSegment(xy, p7, c6);\n        color += drawSegment(xy, p7, c7);\n        color += drawSegment(xy, p7, c11);\n        color += drawSegment(xy, p7, c12);\n    \n        color += drawSegment(xy, p8, c5);\n        color += drawSegment(xy, p8, c8);\n        color += drawSegment(xy, p8, c9);\n        color += drawSegment(xy, p8, c10);\n        color += drawSegment(xy, p8, c13);\n        color += drawSegment(xy, p8, c14);\n        color += drawSegment(xy, p8, c15);\n        color += drawSegment(xy, p8, c16);\n    }\n\n    else if(orthoplex){\n        color += drawSegment(xy, p1, p3);\n        color += drawSegment(xy, p1, p4);\n        color += drawSegment(xy, p1, p5);\n        color += drawSegment(xy, p1, p6);\n        color += drawSegment(xy, p1, p7);\n        color += drawSegment(xy, p1, p8);\n        \n        color += drawSegment(xy, p2, p3);\n        color += drawSegment(xy, p2, p4);\n        color += drawSegment(xy, p2, p5);\n        color += drawSegment(xy, p2, p6);\n        color += drawSegment(xy, p2, p7);\n        color += drawSegment(xy, p2, p8);\n        \n        color += drawSegment(xy, p3, p5);\n        color += drawSegment(xy, p3, p6);\n        color += drawSegment(xy, p3, p7);\n        color += drawSegment(xy, p3, p8);\n        \n        color += drawSegment(xy, p4, p5);\n        color += drawSegment(xy, p4, p6);\n        color += drawSegment(xy, p4, p7);\n        color += drawSegment(xy, p4, p8);\n        \n        color += drawSegment(xy, p5, p7);\n        color += drawSegment(xy, p5, p8);\n        \n        color += drawSegment(xy, p6, p7);\n        color += drawSegment(xy, p6, p8);\n    }\n    \n    return color;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(vec3(0), 1);\n    \n    for(int i = 0; i < AA; i++){\n        for(int j = 0; j < AA; j++){\n            fragColor.rgb += render(fragCoord + vec2(i, j));\n        }\n    }\n    fragColor /= float(AA*AA);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsGBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1458, 1662, 1731, 1731, 2792], [2794, 2794, 2847, 2847, 3171], [3173, 3173, 3201, 3201, 9501], [9507, 9507, 9561, 9561, 9780]]}
{"id": "MsGBz3", "name": "space rings", "author": "laserdog", "description": "fun with particles", "tags": ["particles"], "likes": 14, "viewed": 5127, "date": "1529729931", "time_retrieved": "2024-06-20T19:15:42.429294", "image_code": "#define time iTime*1.25\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\t\n\nconst float numParticles = 25.;\nconst float numRings = 5.;\nconst float offsetMult = 30.;\nconst float tau = 6.23813;\n\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\n              in float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nvec3 particleColor(vec2 uv, float radius, float offset, float periodOffset)\n{\n    vec3 color = palette(.4 + offset / 4., p0);\n    uv /= pow(periodOffset, .75) * sin(periodOffset * iTime) + sin(periodOffset + iTime);\n    vec2 pos = vec2(cos(offset * offsetMult + time + periodOffset),\n        \t\tsin(offset * offsetMult + time * 5. + periodOffset * tau));\n    \n    float dist = radius / distance(uv, pos);\n    return color * pow(dist, 2.) * 1.75;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 3.45;\n\n    fragColor.rgb = vec3(0.);\n    \n    for (float n = 0.; n <= numRings; n++)\n    {\n        for (float i = 0.; i <= numParticles; i++) {\n        \tfragColor.rgb += particleColor(uv, .03, i / numParticles, n / 2.);\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsGBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[218, 218, 414, 414, 505], [507, 507, 584, 584, 953], [956, 956, 1013, 1013, 1323]]}
{"id": "MsKBzc", "name": "Enter the Pipotron", "author": "CoyHot", "description": "A 3D looking  tunnel effect, only created using 2D tricks and a lot of UV distorsions.\nThe code is fully commented to understand how it works ... and to play with it by changing some values.", "tags": ["2d", "tunnel", "oldschool", "pipotron"], "likes": 7, "viewed": 325, "date": "1530005931", "time_retrieved": "2024-06-20T19:15:42.926433", "image_code": "// ----------------- Enter the Pipotron -------------\n// ------------ A 'Only 2D' timewarp tunnel ---------\n//  ----- Francois 'CoyHot' Grassard, June 2018 ----\n//     A tunnel effect only created with 2D tricks  \n// --------------------------------------------------\n\nvec2 rot (vec2 uv,float angle)\n{\n    return uv*mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5)/vec2(iResolution.y / iResolution.x, 1);\n    \n    float gridSize = 50.; // Higher value mean more triangular shapes\n    float angle = 3.1416/6.; // Angle used to simulate the reflection\n    float refFactor = 0.65; // Initial reflection factor (on the ground)\n\n    uv = rot(uv,sin(iTime)/10.); // Rotating the whole image a bit\n    uv = rot(uv,sin((uv.y*4.+iTime/2.)*10.)/300.); // Add a tiny distortion to whole structure\n    \n\tuv.y += cos(uv.y*1.1); // Simulate the lens distortion\n    uv.y -= 0.9; // Offset to move the horizon down\n   \n    if (uv.y+abs(uv.x)/3.8 < -0.20) // Define the ground shape\n    {\n        refFactor = 3.; // Factor used to reduce the luminosity of the reflection on the ground\n\t}   \n\n    float transFac = smoothstep(-0.1,-0.25,uv.y+abs(uv.x)/3.8)+0.75; // Fake Wall/Ground Ambien Occlusion\n\n    uv.x = -abs(uv.x); // Symetrize to lines to create a triangular shape\n    uv.y += 0.2; // Align the whole shape to fil the fake reflection\n    uv =rot(uv,-angle*3.5); // Rotate the shapes to create the reflection\n\n\tuv.y *= 0.9; // Strech uv verticaly a bit, to enhance the fake lens effect\n\n    uv.x = -abs(uv.x);\n    uv.y = abs(uv.y+0.2);\n    \n    uv =rot(uv,-angle*1.4); // Change the 1.4 valu to tweak the \"verticality\" of the structure\n\n    uv.y -= 0.35;   // Offset do define if we gonna catch the lines from the top (tiny/slow)\n    \t\t\t\t// or from the bottom (big/fast) of the image.\n    \n    uv.y /= exp(uv.y); // Strech lines to make them accelerate (to simulate the perspective of the tunnel), from the bottom to the top\n    \n    float zDepth = 1.-(length (vec2(uv.x,uv.y-(5./7.)))*(1.+(abs(sin(iTime/2.))-0.35))); // Create a fake (animated) Z-Depth, only based on UV\n\n    uv.y -=(iTime/7.0); // Move the lines UP (and make you fly through the tunnel) \n\n\n    float hLine = sin(uv.y*gridSize); // Draw the lines\n\tfloat grid = clamp(((hLine))*1.25,0.,1.);  // Clamp the result to avoid negative values\n    \n    vec3 gridColor = vec3(grid/(refFactor*transFac)); // Dim the reflection off the ground\n\n    \n    // Create a small bevel on the edges shape\n    uv.y -= 0.01; // Offset the UV (so, go a few milliseconds away in the future) \n    hLine = sin(uv.y*gridSize);\n\tgrid = clamp(((hLine))*2.25,0.,1.0);   \n    gridColor += vec3(grid/(refFactor*transFac)/5.,0.25,0.); // Add this \"echo shape\"\n\n\n    // Add a thickness to the shapes   \n    uv.y -= 0.025; // Offset the UV (and travel to the future ... but far away than previously)\n    hLine = sin(uv.y*gridSize);    \n\tgrid = clamp(((hLine))*2.25,0.,1.0);   \n    gridColor += vec3(grid/(refFactor*transFac)/6.);// Add this \"echo shape\"\n\n    gridColor *= vec3(zDepth); //Multiply the image by the Z-Depth Mask\n    \n\t// AND FINALY : Add more colors !\n    gridColor += (vec3(sin(uv.x)/2.,abs(sin(uv.y*10.)/15.),0.1))*(abs(sin(iTime)+1.5));\n\n    // Output to screen\n    fragColor = vec4(gridColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsKBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 269, 301, 301, 372], [374, 374, 431, 431, 3359]]}
{"id": "MsKfDG", "name": "李明杰V8", "author": "leneer", "description": "ljx", "tags": ["ljx"], "likes": 0, "viewed": 81, "date": "1530337203", "time_retrieved": "2024-06-20T19:15:42.926433", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n    float sqrt3 = 1.73205;\n    r *= 2.5;\n    \n    float the = 0.0 + iTime * 1.0;\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec2 r1 = abs(r);\n    r1.y += 1.0 * r1.x / sqrt3;\n    if(r1.x <= 0.5 *  sqrt3 && r1.y  <= 1.0){\n    \tret = vec3(1.0);\n    }\n    vec2 r2 = abs(r - vec2(sqrt3 * 0.5, -1.5));\n    r2.y += 1.0 * r2.x / sqrt3;\n    if(r2.x <= 0.5 *  sqrt3 && r2.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 0.0);\n    }\n    vec2 r3 = abs(r - vec2(sqrt3 * 0.5, 1.5));\n    r3.y += 1.0 * r3.x / sqrt3;\n    if(r3.x <= 0.5 *  sqrt3 && r3.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 0.0);\n    }\n    vec2 r4 = abs(r - vec2(sqrt3, 0.0));\n    r4.y += 1.0 * r4.x / sqrt3;\n    if(r4.x <= 0.5 *  sqrt3 && r4.y  <= 1.0){\n    \tret = vec3(1.0, 1.0, 0.0);\n    }\n    vec2 r5 = abs(r - vec2(-sqrt3, 0.0));\n    r5.y += 1.0 * r5.x / sqrt3;\n    if(r5.x <= 0.5 *  sqrt3 && r5.y  <= 1.0){\n    \tret = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 r6 = abs(r - vec2(-sqrt3 * 0.5, 1.5));\n    r6.y += 1.0 * r6.x / sqrt3;\n    if(r6.x <= 0.5 *  sqrt3 && r6.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 1.0);\n    }\n    vec2 r7 = abs(r - vec2(-sqrt3 * 0.5, -1.5));\n    r7.y += 1.0 * r7.x / sqrt3;\n    if(r7.x <= 0.5 *  sqrt3 && r7.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 1.0);\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsKfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1505]]}
{"id": "MsKfRV", "name": "rotating breathing circle", "author": "guowei", "description": "rotating breathing circle", "tags": ["circle", "rotating", "breathing"], "likes": 3, "viewed": 714, "date": "1529644501", "time_retrieved": "2024-06-20T19:15:42.926433", "image_code": "#define PI 3.1415926\n#define TWOPI = 6.2831853\n\nfloat circle(float radius, vec2 center, vec2 uv) {\n\tfloat d = distance(center, uv);\n    return 1.0 - smoothstep(radius-1./iResolution.y, radius+1./iResolution.y, d);\n}\n\nvec2 angleRadius(vec2 uv) {\n    float twoPi = 6.2831853;\n\tfloat anglePixel = atan(uv.y, uv.x);\n    float lengthPixel = length(uv);\n    \n    return vec2(anglePixel, lengthPixel);\n}\n\nfloat filterPositive(float n) {\n    //if(n <= 0.005) {\n    \t//return 0.0;\n        //return smoothstep(0.0, 0.005, n);\n    //} else {\n    \t//return 1.0;\n        //return smoothstep(0.995, 1.005, n);\n    //}\n    return smoothstep(0.0, 0.005, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y; //many thanks to FabriceNeyret2\n    \n    float radius = 0.3;\n    float ringThick = 0.05;\n    \n    vec2 stPolar = angleRadius(uv);\n    \n    float sPolar = stPolar.x * 3.0 + iTime * 10.0;\n    //float sPolar = stPolar.x * 6.0;\n    float cosSPolarTemp = cos(sPolar);\n    float cosSPolar = filterPositive(cosSPolarTemp);\n    \n    vec3 color = vec3(cosSPolar);\n    \n\n    float inCircleAA = smoothstep(radius, radius + 0.005, angleRadius(uv).y); //AA version\n    float smallCircleAA = smoothstep(radius - ringThick, radius - ringThick + 0.005, angleRadius(uv).y); //AA version\n    vec3 col = 1.0 - vec3(inCircleAA);\n    vec3 col_2 = 1.0 - vec3(smallCircleAA);\n    vec3 colorGap = col - col_2;\n    vec3 finalColor = color * colorGap;\n    vec3 colorMask = vec3(10, 1.5, 1.0);\n    finalColor /= 10.0;\n    finalColor *= colorMask;\n    \n    float centerCircleAA = smoothstep(0.1, 0.1 + 0.005, angleRadius(uv).y); //AA version\n    vec3 centerCircleColor = 1.0 - vec3(centerCircleAA);\n    centerCircleColor /= 10.0;\n    centerCircleColor *= colorMask;\n    \n    vec2 centerC = vec2(0.0, 0.0);\n    float bubbleRadius = abs(sin(iTime * 3.0)) / 3.0;\n    float bubbleCircleColor = circle(bubbleRadius, centerC, uv);\n    vec4 bubbleColor = vec4(vec3(bubbleCircleColor) / 10.0 * colorMask, 1.0);\n    \n    fragColor = vec4(finalColor + centerCircleColor, 1.0);\n    fragColor += bubbleColor;\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsKfRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 98, 98, 215], [217, 217, 244, 244, 396], [398, 398, 429, 603, 643], [645, 645, 702, 702, 2147]]}
{"id": "MsKfWD", "name": "李明杰VDJ", "author": "leneer", "description": "personal use", "tags": ["virtualdj"], "likes": 2, "viewed": 964, "date": "1528943079", "time_retrieved": "2024-06-20T19:15:42.926433", "image_code": "//https://www.shadertoy.com/view/XlKSzw//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = 0.5 * (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // warp uv pre-perspective shift\n    float displaceAmp = 0.1;\n    float displaceFreq = 2.5;\n    uv += vec2(displaceAmp * sin(time + uv.x * displaceFreq));\n    \n    // 3d params\n    // 3d plane technique from: http://glslsandbox.com/e#37557.0 \n    float horizon = 0.2 * cos(time); \n    float fov = 0.35 + 0.15 * sin(time); \n\tfloat scaling = 0.3;\n    // create a 2nd uv with warped perspective\n\tvec3 p = vec3(uv.x, fov, uv.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n    \n    // wobble the perspective-warped uv \n    float oscFreq = 12.;\n    float oscAmp = 0.04;\n    s += vec2(oscAmp * sin(time + s.x * oscFreq));\n\t\n\t// normal drawing here\n    // lines/lattice\n    float color = max(\n        smoothstep(0.2, 0.8, 0.94 - pow(sin(s.y * 100.), 0.3)), \n        smoothstep(0.2, 0.8, 0.94 - pow(sin(s.x * 100.), 0.3))\n    );\n\n\t// 线条深度范围\n\tcolor *= p.z * p.z * 20.0;\n    // 线条颜色\n\tfragColor = vec4( vec3(0, color, 0), 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsKfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 42, 99, 99, 1160]]}
{"id": "MsVfWz", "name": "yummy", "author": "hellochar", "description": "spirally normy flava (mouse)", "tags": ["rotate", "cos", "domainwarp"], "likes": 1, "viewed": 69, "date": "1528444509", "time_retrieved": "2024-06-20T19:15:43.205342", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv += vec2(0.2, 0.1);\n    uv *= 80.;\n    \n    // [ 0, 1 ]\n    float spirally = cos(iTime / 10.);\n    \n    float normy = 1. + pow(iMouse.x / iResolution.x, 4.) * 50.;\n    float flava = 20. * iMouse.y / iResolution.y;\n    \n    uv += (rotate2d(cos(iTime / 10.) * 2.6) * uv);\n    \n    uv += (rotate2d(length(uv) * spirally) * uv * -2.) * 0.5;\n    \n    uv += (iMouse.xy / iResolution.xy) * 50.;\n    \n    uv += cos(uv) * 2.;\n    \n    uv = mix(uv, uv * 1. / (1. + length(uv.yx)), 0.8);\n    uv += sin(uv.yx * 1.) * 0.5;\n    \n    uv *= 0.1 / spirally;\n    \n    uv *= normy / (normy + pow(length(uv.yx), 2.));\n    \n    uv += sin(uv.yx * flava) * 0.25;\n    \n    uv += cos(uv + cos(uv*12.) * 0.25) * 0.5;\n    uv += (rotate2d(iTime + length(uv) / 4.) * (uv.yx * -4.)) * 0.25;\n    \n    uv += cos(uv + cos(uv*12.) * 0.25) * 0.5;\n    uv += (rotate2d(iTime + length(uv) / 8.) * (uv.yx * -8.)) * 0.02;\n\n    // Time varying pixel color\n    vec3 col = (cos(uv)).xyy; // * vec3(log(1. + length(uv)) * 1.);\n    \n    // vec3 col = vec3(log(length(uv)) / 2.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsVfWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 114], [116, 116, 173, 223, 1376]]}
{"id": "MsVfz1", "name": "Neon Lit Hexagons", "author": "Shane", "description": "A simple raymarched hexagon scene with some neon elements.", "tags": ["raymarching", "volumetric", "hexagon", "glow", "neon"], "likes": 253, "viewed": 11361, "date": "1527860847", "time_retrieved": "2024-06-20T19:15:48.745061", "image_code": "/*\n\tNeon Lit Hexagons\n\t-----------------\n\n\tI needed a break from a few technical shaders I've beem hacking away at, so I finished an old \n\tgeometric example that'd been sitting on the blocks for a while.\n\t\n\t3D hexagon tech imagery is a bit of a cliche, but I've always been a fan. Most tend to be high \n\tquality pathtraced renderings, but since this is a realtime raymarched example, I had to make \n\ta lot of concessions. The glowing neon lights were inspired by some of Shau's examples, some\n\tonline imagery, and practically half the demos out there. :)\n\n\tI tried to create the glowing effect without the use of a volumetric pass, but my eyes weren't\n\taccepting the results, which meant the observant people on here -- pretty much everyone -- would \n\tnotice immediately, so I put a relatively cheap one in. The improvements were immediate, but it\n\twas at the cost of rendering speed... I'm just hoping no one notices the lack of reflections from \n\tthe neon lights. :) I have a pretty quick laptop, but ever since the WebGL 2 update, it hasn't \n\tenjoyed compiling extra passes, so reflections had to go. At a later stage, I might attempt to \n\tfake them in some way.\n\n\tThere are a couple of surface detail defines below that I had to leave out. I also came pretty \n\tclose to greebling the surfaces, but figured that might be overkill. In the end, I took the \n\t\"less is more\" approach. However, I intend to put together a greebled surface pretty soon.\n\n\n    // Other neon-looking examples:\n\n\t// Shau has a heap of bright glowing examples, but here's a few.\n\tOTT - shau\n\thttps://www.shadertoy.com/view/4sVyDd\n\n\t43% Burnt - shau\n\thttps://www.shadertoy.com/view/XljBWW\n\n\tAngle Grinder - shau\n\thttps://www.shadertoy.com/view/XtsfWX\n\n\n    // Great example.\n\tNeon World - zguerrero\n    https://www.shadertoy.com/view/MlscDj\n\n*/\n\n\n\n// Hexagon: 0, Dodecahedron: 1, Circle: 2.\n// Squares, stars, etc, are possible too, but I didn't include those.\n#define SHAPE 0\n\n\n// Details usually make a scene more interesting. In this case, however, they seemed a\n// little expensive, so I left them out.\n//\n// I wanted to include the grooves, at least, but I figured speed on slower machines was\n// more important.\n//#define ADD_DETAIL_GROOVE \n//#define ADD_DETAIL_BOLT\n\n// Animating the neon lights, or not. I find them a little too distracting, \n// so the default is \"off.\"\n//#define ANIMATE_LIGHTS\n\n// If Borg green is more your thing. :)\n//#define GREEN_GLOW\n\n// Maximum ray distance.\n#define FAR 50.\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// vec2 to float hash.\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(7.163, 157.247)); \n    return fract(sin(n)*43758.5453);\n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n*/\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - .2)*7., .001); // n = max(abs(n), .001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n*/\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    // We only want positive normal weightings. The normal is manipulated to suit\n    // your needs.\n    n = max(abs(n) - .2, .001); // n = max(n*n - .1, .001), etc.\n    //n /= dot(n, vec3(1)); // Rough renormalization approximation.\n    n /= length(n); // Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; // Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; // Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; // Front and back.\n    \n    // Blending the surrounding textures with the normal weightings. If the surface is facing\n    // more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    //\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n    return n;//abs(n - .5)*2.;\n}\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    // Four layers of 3D noise.\n    //p /= 1.5;\n    //p -= vec3(0, 0, iTime*1.);\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    \n    //return vec2(sin(z * 0.15)*2.4, cos(z * 0.075)*.15); \n    \n    return vec2(sin(z * 0.15)*2.4, 0);\n}\n\n\n\n\n//////\n//float objID, svObjID;\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\nconst vec2 s = vec2(.866025, 1);//const vec2 s = vec2(1, 1.7320508); //\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following.\nfloat hex(in vec2 p){\n    \n    //return length(p);\n    p = abs(p);\n    \n    // Below is equivalent to:\n    return max(p.x*.866025 + p.y*.5, p.y); \n\n    //return max(dot(p, s*.5), p.x); // Hexagon.\n    \n}\n\n/*\n// More accurate formula, but involves more operations and didn't improve quality by any\n// significant amount, so I've used the estimation below.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    \n    // Note the \"*1.5\" You need to take the minimum of\n    // long-sided rectangles, not squares. Squares will give\n    // you a dodecahedron.\n    vec3 b = vec3(r*1.5, ht, r); \n    \n    //p.xz = abs(p.xz);\n    //p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    \n    b -= .015;\n    //p.xz = r2(-3.14159/3.)*q.xz;\n  \tfloat d1 = length(max(abs(p) - b, 0.));\n    p.xz = r2(6.2831/3.)*p.xz;\n    float d2 = length(max(abs(p) - b, 0.));\n\n    p.xz = r2(6.2831/3.)*p.xz;\n    float d3 = length(max(abs(p) - b, 0.));    \n    return max(max(d1, d2), d3) - .015;\n}\n*/\n\n/*\n// Signed distance to a regular hexagon -- using IQ's more exact method.\nfloat sdHexagon(in vec2 p, in float r){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.\n  p = abs(p);\n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n    \n}\n\n// IQ's extrusion formula, with a bit of rounding (the .015 bit) thrown in.\nfloat opExtrusion(in float sdf, in float pz, in float h)\n{\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x,w.y), 0.) + length(max(w + .015, 0.)) - .015;\n}\n\n// A technically correct hexagonal pylon formual.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n    \n    float hex = sdHexagon(p2, r);\n    return opExtrusion(hex, pz, ht);\n}\n*/\n\n// Normally, I'd say this is the hexagonal pylon distance function. However, I should \n// probably make the distinction between a fully bonafide distance function and something\n// that estimates it. This is a bound of sorts. There's not a great deal between it and \n// the real thing, but it does exhibit different behaviour away from the surface, which \n// can affect things like shadows, etc. However, as you can see, in this situation, you\n// can't really tell. I figured I'd mention this, because myself and others use a lot of\n// these kind of functions.\n//\n// By the way, a more exact formula is commented out above.\n//\n// Hexagonal pylon field. There's also defines for a dodecahedron and a cylinder.\nfloat hexPylon(vec2 p2, float pz, float r, float ht){\n\n    vec3 p = vec3(p2.x, pz, p2.y);\n    vec3 b = vec3(r, ht, r);\n    \n    \n    #if SHAPE == 0\n    // Hexagon.\n    p.xz = abs(p.xz);\n    p.xz = vec2(p.x*.866025 + p.z*.5, p.z);\n    // The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    // and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #elif SHAPE == 1\n    // Dodecahedron.\n    p.xz = abs(p.xz);\n    p2 = p.xz*.8660254 + p.zx*.5;\n    p.xz = vec2(max(p2.x, p2.y), max(p.z, p.x));\n    // The \".015\" is a subtle rounding factor. Zero gives sharp edges,\n    // and larger numbers give a more rounded look.\n  \treturn length(max(abs(p) - b + .015, 0.)) - .015;\n    #else\n    // Cylinder -- IQ's cylinder function, to be precise, so I think this particular\n    // function is a proper distance field.\n    p.xy = abs(vec2(length(p.xz), p.y)) - b.xy + .015;\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.)) - .015;\n    #endif\n    \n    \n}\n \n\n\n// IDs for the neon lights. Added at the last minute. Identifying things can be tiresome. Individual \n// objects need to be identified, and sometimes, objects within objects need identification too.\n// In this case, there are four pylon groupings. Each pylon object contains a neon light object that \n// is either on or off.\n// \n// If you're seting IDs withing the distance function, they can be lost when calling things like the \n// \"normal\" function, etc. Therefore, you need extra variables to save the IDs directly after calling \n// the trace function. Then there's the matter of ID sorting, which should be done outside the loop... \n// Even with a \"struct,\" or something to that effect, it can still be messy. Having said that, I might \n// start trying to streamline and formalize the process.\nvec4 litID;\nfloat svLitID;\n\n// The pylon and light distance field.\n// Variables in order: p.xz, p.y, radius, height, ID, direction (unused).\nfloat objDist(vec2 p, float pH, float r, float ht, inout float id, float dir){\n    \n    // Neon light height: Four levels, plus the height is divided by two.\n    const float s = 1./16.; //1./4./2.*.5; \n\n    // Main hexagon pylon.\n    float h1 = hexPylon(p, pH, r, ht);\n    \n    #ifdef ADD_DETAIL_GROOVE\n    // I like this extra detail, but it was a little too expensive.\n\th1 = max(h1, -hexPylon(p, pH + ht, r - .06, s/4.)); // Extra detail.\n    #endif\n    \n    #ifdef ADD_DETAIL_BOLT\n    // An alternative extra detail. Also a little on the expensive side.\n    h1 = min(h1, hexPylon(p, pH, .1, ht + s/4.)); // Extra detail.\n    #endif\n\n    \n    \n    // Thin hexagon slab -- sitting just below the top of the main hexagon. It's\n    // lit differently to represent the neon portion.\n    float h2 = hexPylon(p, pH + ht - s, r + .01, s/3.);\n    \n     \n    // Opens a space around the neon lit hexagon. Used, if the radius of \"h2\" is\n    // less that \"h1,\" which isn't the case here.\n    //h1 = smax(h1, -(abs(pH + ht - s) - s/3.), .015);\n    \n    // Identifying the main hexagon pylon or the neon lit portion.\n    id = h1<h2? 0. : 1.;\n    \n    // Return the closest object.\n    return min(h1, h2);\n    \n}\n\n// Height field for the hexagon.\nfloat hexHeight(vec2 p){\n    \n    // Random height.\n    //return hash21(p + 57.)*.75;\n    \n    // Any kind of cheap flowing height field will do. \n    return dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    \n    \n    // Two layers. Not used, because we're trying to keep costs down.\n    //float n1 = dot(sin(p*2. - cos(p.yx*1.4)), vec2(.25)) + .5;\n    //float n2 = dot(sin(p.yx*8. - cos(p*6.)), vec2(.25)) + .5;\n    //return n1*.85 + n2*.15;\n}\n\n\n\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, it's necessary to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p, float pH){\n   \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(0, .5))/s.xyxy) + vec4(0, 0, 0, .5);\n    vec4 hC2 = floor(vec4(p - vec2(.5, .25), p - vec2(.5, .75))/s.xyxy) + vec4(.5, .25, .5, .75);\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - (hC.xy + .5)*s, p - (hC.zw + .5)*s);\n    vec4 h2 = vec4(p - (hC2.xy + .5)*s, p - (hC2.zw + .5)*s);\n    \n    // Hexagon height.\n    vec4 ht = vec4(hexHeight(hC.xy), hexHeight(hC.zw), hexHeight(hC2.xy), hexHeight(hC2.zw));\n    // Restricting the heights to five levels... The \".02\" was a hack to take out the lights\n    // on the ground tiles, or something. :)\n    ht = floor(ht*4.99)/4./2. + .02;\n\n    // The pylon radius. Lower numbers leave gaps, and heigher numbers give overlap. There's not a \n    // lot of room for movement, so numbers above \".3,\" or so give artefacts.\n    const float r = .25; // .21 to .3. \n    vec4 obj = vec4(objDist(h.xy, pH, r, ht.x, litID.x, 1.), objDist(h.zw, pH, r, ht.y, litID.y, -1.), \n                    objDist(h2.xy, pH, r, ht.z, litID.z, -1.), objDist(h2.zw, pH, r, ht.w, litID.w, 1.));\n    \n    \n    //tempD = min(min(obj.x, obj.y), min(obj.z, obj.w));\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    h = obj.x<obj.y ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    h2 = obj.z<obj.w ? vec4(h2.xy, hC2.xy) : vec4(h2.zw, hC2.zw);\n    \n    vec2 oH = obj.x<obj.y ? vec2(obj.x, litID.x) : vec2(obj.y, litID.y);\n    vec2 oH2 = obj.z<obj.w ? vec2(obj.z, litID.z) : vec2(obj.w, litID.w);\n    \n    //return oH<oH2 ? vec4(h.xy, hC.xy) : vec4(h2.xy, hC2.xy);\n    return oH.x<oH2.x ? vec4(oH,  h.zw) : vec4(oH2, h2.zw);\n    \n}\n\n// Some IDs. One to save the unique hexagonal center coordinates and an ID for the part of the\n// pylon that is lit. These were added on the fly. There'd be cleaner ways to do this.\nvec2 v2Rnd, svV2Rnd;\nfloat gLitID;\n\n\n\n// Reducing the heightmap function to a single texel lookup - via the stone texture which was \n// generated outside the distance function in the onscreen buffer, of course.\n//\n// Using the single pass system, there would have been no other option than to generate the stone \n// texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n// Voronoi heightmap. :)\nfloat heightMap(in vec3 p){\n\n    // The stone texture is tileable, or repeatable, which means the pattern is slightly\n    // repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    // doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    //return Voronoi(p.xy*2.);//texture2D(texChannel0, fract(p/2.), -100.).w;\n    \n    const float sc = 1.;\n    vec4 h = getHex(p.xz*sc, -p.y*sc);\n    \n    v2Rnd = h.zw;\n    \n    gLitID = h.y;\n        \n    return h.x/sc;\n\n}\n\n///////\n\n// Standard setup for a plane at zero level with a perturbed surface on it.\nfloat map(vec3 p){\n    \n    float c = heightMap(p);\n    \n    //objID = 1.;\n    \n    return c*.7;\n \n}\n\n// Global glow variable.\nvec3 glow;\n\n// Determines whether the neon light should be switched on, or not.\nfloat getRndID(vec2 p){\n    \n    #ifdef ANIMATE_LIGHTS\n    // Blinking version. Interesting, but I found it too distracting.\n    float rnd = hash21(p);\n    return smoothstep(.5, .875, sin(rnd*6.283 + iTime)); \n    #else\n    return hash21(p) - .75;\n    #endif\n    \n    \n}\n\n// Standard raymarching routine, with some custom glow mixed in.\nfloat trace(vec3 ro, vec3 rd){\n   \n    // Applying some jitter to the jump off point to alleviate volumetric banding.\n    float t = hash31(ro + rd)*.25, d, ad;\n\n    glow = vec3(0);\n    \n    // It's a kind of expensive function, so I'm trying to minimize the iteration number.\n    // In fact, since the GPU unrolls everything, this number should always be minimized.\n    for (int i = 0; i<80; i++){\n\n        d = map(ro + rd*t);\n        ad = abs(d);\n\n     \tif(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        // Applying some glow. There are probably better ways to go about it, but this\n        // will suffice. If the ray passes within \"gd\" units of the neon object, add some\n        // distance-based glow.\n        const float gd = .1;\n        float rnd = getRndID(v2Rnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { // && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)/gd/(1. + ad*ad/gd/gd*8.);\n            // Colors are possible, but I just wanted the scaler value, which is colorized\n            // outside the loop.\n            glow += gl; \n        }\n        \n        t += d;  // Advance the ray.\n    }\n    \n   \n    return min(t, FAR);\n}\n\n\n\n\n/*\nvoid getGlow(vec3 ro, vec3 rd, float t){\n    \n   glow = vec3(0);\n   float t2 = hash31(ro + rd)*.25, d, ad;\n   t2 = max(t2 - 3., 0.);\n\n   for (int i = 0; i<30; i++){\n       \n\t\td = map(ro + rd*t2);\n        ad = abs(d);\n\n        if(ad<.001*(t2*.125 + 1.) || t2>FAR) break;\n\n        const float gd = .1;\n        float rnd = getRndID(vRnd);\n        if(rnd>0. && gLitID == 1. && ad<gd) { // && ad<.05\n\t\t\tfloat gl = .2*(gd - ad)/gd/(1. + ad*ad/gd/gd*8.);\n            glow += gl;\n        }\n       \n\t\tt2 += d;\n        \n    }\n    \n   \n    \n}\n*/\n\n/*\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i<32; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.25 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n*/\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min(h, stepDist); // So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        dist += clamp(h, .02, .25); // So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n/*\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { \n\t\n    // Roughly two pixel edge spread, but increased slightly with larger resolution.\n    vec2 e = vec2(ef/mix(450., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n      \n    // Wider sample spread for the curvature.\n    //e = vec2(12./450., 0);\n\t//d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t//d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t//d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \t \n    \n    e = vec2(.0025, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*/\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    //p.xz += iTime*.5;\n    \n    float n3D2 = noise3D(p*3.);\n   \n    // A bit of fBm.\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Bluish tinge.\n    \n    return mix(p, p.zyx, n3D2*.25 + .75); // Mixing in a bit of purple.\n\n}\n\n\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    \n    //p.xy -= path(p.z);\n    float sz0 = 1./2.;\n    \n    // Texel retrieval.\n    vec3 txP = p;\n    //txP.xz *= r2(getRndID(svVRnd)*6.2831);\n    vec3 col = tex3D(iChannel0, txP*sz0, n );\n    col = smoothstep(-.0, .5, col);//*vec3(.5, .8, 1.5);\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5);\n    // Darken the surfaces to bring more attention to the neon lights.\n    col /= 16.;\n    \n   \n    // Unique random ID for the hexagon pylon.\n    float rnd = getRndID(svV2Rnd);\n    \n    // Subtly coloring the unlit hexagons... I wasn't feeling it. :)\n    //if(svLitID==1. && rnd<=.0) col *= vec3(1, .85, .75)*4.;\n\n    // Applying the glow.\n    //\n    // It's took a while to hit upon the right combination. You can create a cheap lit object \n    // effect by simply ramping up the object's color intensity. However, your eyes can tell that\n    // it's lacking that volumetric haze. Volumetric haze is achievable via a volumetric appoach.\n    // However, it's prone to patchiness. The solutionm, of course, is to combine the smoothness\n    // of direct object coloring with a portion of the glow. That's what is happining here.\n\n    // Object glow.\n    float oGlow = 0.;\n    \n    // Color every lit object with a gradient based on its vertical positioning.\n    if(rnd>0. && svLitID==1.) {\n        \n        float ht = hexHeight(svV2Rnd);\n    \tht = floor(ht*4.99)/4./2. + .02;\n        const float s = 1./4./2.*.5; // Four levels, plus the height is divided by two.\n     \n        oGlow = mix(1., 0., clamp((abs(p.y - (ht - s)))/s*3.*1., 0., 1.));\n        oGlow = smoothstep(0., 1., oGlow*1.);\n    }\n    \n    // Mix the object glow in with a small potion of the volumetric glow.\n    glow = mix(glow, vec3(oGlow), .75);\n    \n    // Colorizing the glow, depending on your requirements. I've used a colorful orangey palette,\n    // then have modified the single color according to a made up 3D transcental function.\n    //glow = pow(vec3(1, 1.05, 1.1)*glow.x, vec3(6, 3, 1));\n    glow = pow(vec3(1.5, 1, 1)*glow, vec3(1, 3, 6)); // Mild firey orange.\n    glow = mix(glow, glow.xzy, dot(sin(p*4. - cos(p.yzx*4.)), vec3(.166)) + .5); // Mixing in some pink.\n    glow = mix(glow, glow.zyx, dot(cos(p*2. - sin(p.yzx*2.)), vec3(.166)) + .5); // Blue tones.\n    //glow = mix(glow.zyx, glow, smoothstep(-.1, .1, dot(sin(p + cos(p.yzx)), vec3(.166))));\n     \n    #ifdef GREEN_GLOW \n    glow = glow.yxz;\n    #endif\n    \n   \n    return col;\n    \n}\n\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, in float t){\n    \n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n           // Texture bump the normal.\n    \tfloat sz0 = 1./1.;\n    \tvec3 txP = sp;\n        //txP.xy -= path(txP.z);\n        //txP.xz *= r2(getRndID(svVRnd)*6.2831);\n        sn = texBump(iChannel0, txP*sz0, sn, .005);///(1. + t/FAR)\n \n\n        // Retrieving the normal at the hit point.\n        //sn = getNormal(sp);  \n        float sh = softShadow(sp, lp, 12.);\n        float ao = calcAO(sp, sn);\n        sh = min(sh + ao*.3, 1.);\n\n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 1.5/(1. + lDist*.1 + lDist*lDist*.02);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //if(svLitID == 0.) diff = pow(diff, 4.)*2.;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n        float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n        \n\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + vec3(1, .6, .3)*spec*4. + .5*ao + vec3(.3, .5, 1)*fres*fres*2.);\n\n        // Fake environment mapping.\n        sceneCol += pow(sceneCol, vec3(1.))*envMap(reflect(rd, sn))*4.;\n        \n       \n        // Applying the shadows and ambient occlusion.\n        sceneCol *= atten*sh*ao;\n        \n        // For whatever reason, I didn't want the shadows and such to effect the glow, so I layered\n        // it over the top.\n        sceneCol += (objCol*6. + 1.)*glow; //*(sh*.35 + .65);\n \n        //sceneCol = vec3(sh);\n    \n    }\n    \n    \n\n    \n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n\t\n\t// Camera Setup.\n\t//vec3 lookAt = vec3(0., 0.25, iTime*2.);  // \"Look At\" position.\n\t//vec3 camPos = lookAt + vec3(2., 1.5, -1.5); // Camera position, doubling as the ray origin.\n\t\n\tvec3 lk = vec3(0, 1.25, iTime*2.);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, .175, -.25); // Camera position, doubling as the ray origin.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, 4); //4\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Camera lean.\n    //rd.xy *= r2(path(lk.z).x/32.);\n    /////////\n    \n\n    vec3 sceneColor, passColor, sn, sSn;\n\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    svV2Rnd = v2Rnd;\n    svLitID = gLitID;\n\n    \n    //getGlow(ro, rd, t);\n    \n    // Fog based off of distance from the camera. Not used here.\n    float fog = smoothstep(0., FAR-1., t); \n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n   \n    // Retrieving the normal at the hit point.\n    //sn = getNormal(ro); \n    //float edge = 0., crv = 1., ef = 5.;\n\t//sn = getNormal(ro, edge, crv, ef);//\n    //sSn = sn; // Save the unpeturbed normal.\n    sn = getNormal(ro);\n    \n    \n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = passColor;//*(1. - edge*.8);//mix(passColor, vec3(0), fog); //\n    \n    \n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    //float sh = softShadow(ro, lp, 12.);\n    //sh *= calcAO(ro, sn);\n    \n/*    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, normalize(sSn*.66 + sn*.34));\n    \n    \n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    svVRnd = vRnd;\n    svObjID = objID;\n    \n    // Advancing the reflected ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the new normal at the reflected hit point.\n    //sn = getNormal(ro); \n    float edge2 = 0., crv2 = 1.;//, ef2 = 8.;\n\tsn = getNormal(ro, edge2, crv2, ef);//getNormal(sp);\n\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add depends on what you're trying to accomplish.\n    passColor = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor*.5 + passColor*(1. - edge2*.8);//mix(passColor, vec3(0), fog);\n    \n*/  \n    \n    //sceneColor *= (1. - edge*.8);\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    //sceneColor *= sh;\n    \n    sceneColor = mix(sceneColor, vec3(0), fog);\n    \n\n    // Square vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor = min(sceneColor, 1.)*pow( 16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsVfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2484, 2517, 2537, 2537, 2595], [2597, 2620, 2641, 2641, 2729], [2731, 2754, 2775, 2775, 2872], [2875, 3098, 3136, 3136, 3217], [3913, 4071, 4117, 4223, 5089], [5091, 5167, 5192, 5285, 6271], [6273, 6311, 6332, 6418, 6534], [6538, 6638, 6660, 6748, 6794], [7085, 7261, 7282, 7311, 7464], [9065, 9773, 9826, 9826, 10784], [11616, 11729, 11807, 11886, 12929], [12931, 12964, 12988, 13110, 13410], [13415, 14110, 14140, 14519, 16341], [16563, 16962, 16989, 17331, 17477], [17488, 17564, 17582, 17582, 17664], [17703, 17771, 17794, 17794, 18041], [18043, 18108, 18138, 18225, 19246], [20458, 20673, 20717, 20795, 22037], [22041, 22240, 22267, 22267, 22426], [24063, 24146, 24182, 24182, 24426], [24429, 24615, 24675, 24675, 25513], [25516, 25815, 25835, 25835, 26203], [26206, 26206, 26242, 26277, 28692], [28695, 28837, 28910, 28910, 31127], [31132, 31132, 31188, 31216, 36300]]}
{"id": "MsyfRm", "name": "selecta", "author": "lennyjpg", "description": "store and test some colors and swatches. mouse around to mix any two colors.", "tags": ["2d", "colors"], "likes": 2, "viewed": 429, "date": "1528119845", "time_retrieved": "2024-06-20T19:15:48.745061", "image_code": "const vec3\nwhite = vec3(1),\ncream = vec3(.99, .97, .95),\nsand = vec3(.9, .85, .74),\nyello = vec3(1., 1., .37),\npink = vec3(1., .5, .5),\ntomato = vec3(1., .3, .3),\nred = vec3(.9, .05, .25),\nacid = vec3(.0, .9, .6),\nteal = vec3(.0, .55, .5),\nwald = vec3(.1, .37, .25),\nblue = vec3(.02, .01, .17),\ndark = vec3(.05, .05, .05),\nblack = vec3(0);\n\nconst vec3[] colors = vec3[](\n    white,\n    cream,\n    sand,\n    yello,\n    pink,\n    tomato,\n    red,\n    acid,\n    teal,\n    wald,\n    blue,\n    dark,\n    black\n);\n\nvec3 cc(float x){\n   float n = float(colors.length());\n   return colors[int(mod(x*n,n))];\n}\n\n#define click iMouse.z > .0\n#define gold 1.61803\n\nvec3 k(float yo){\n    int index = int( mod(yo,float(colors.length())) );\n    return colors[index];\n}\n\nvec3 list(vec2 uv, vec2 f){\n        float t = iTime * 0.2;\n\n    vec3 c = cc(uv.x);\n    if(uv.y < .04){\n        c = cc(iTime*0.01-uv.x);\n    }\n    \n    if(uv.y > .3){\n       c = vec3(mod(t/float(colors.length()),1.0));\n    }else if(uv.y < .037 ){\n       c = vec3(0);\n    }\n    \n    if(uv.y > .5){\n        vec3 a = mix(k(t-1.),k(t),uv.x),\n  \t    b = mix(k(t),k(t+1.),uv.x);\n        c = mix(a,b,mod(t,1.));\n    }\n    \n    if(uv.x-mod(t/float(colors.length()),1.0)<0.001){\n        if(abs(uv.y-0.5)<0.01){\n            c = vec3(mod(t/float(colors.length()),1.0));\n\n        }\n    }\n    \n     if(iResolution.y - f.y < 2. ){\n       c = vec3(1);\n    }\n    \n    return c;\n}\n\n\nvec3 detail(vec2 uv){  \n    float fade = clamp(uv.y+sin(iTime),0.0,1.0);\n    vec2 m =  iMouse.xy/iResolution.xy;\n    vec3 solid = cc(uv.y > .5 ? m.x : m.y),\n     gradient = mix ( cc(m.x), cc(m.y),fade),\n     c = uv.x > 1./ gold ? solid : gradient;\n    if(uv.x<.1){        \n        c = mix ( cc(m.x), cc(m.y),floor(sin(uv.y*200.0)+1.0));     \n    }\n    return c;\n}\n\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 uv = f/ iResolution.xy;\n    vec3 c = click ? detail(uv) :  list(uv,f);\n    float p = iTime*0.2;\n    if(abs(uv.y-0.5)>p){\n      c = vec3(0);\n    }\n    O = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsyfRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[509, 509, 526, 526, 600], [652, 652, 669, 669, 752], [754, 754, 781, 781, 1416], [1419, 1419, 1440, 1440, 1782], [1784, 1784, 1824, 1824, 2001]]}
{"id": "MsyfW1", "name": "Fuzzy Set: Hue", "author": "ptrgags", "description": "I noticed a similarity between fuzzy sets and this HSV -> RGB conversion chart:\nhttps://en.wikipedia.org/wiki/HSL_and_HSV#/media/File:HSV-RGB-comparison.svg\n\nI decided to play around with the math a bit!", "tags": ["hsv", "hue", "fuzzylogic"], "likes": 1, "viewed": 78, "date": "1528583057", "time_retrieved": "2024-06-20T19:15:49.290701", "image_code": "// This shader converts a hue from 0.0 to 1.0\n// onto the corresponding RGB value with full saturation.\n// I came up with this after noticing a similarity between this image:\n// https://en.wikipedia.org/wiki/HSL_and_HSV#/media/File:HSV-RGB-comparison.svg\n// and fuzzy sets.\n\n// Define where the pure values of RGB are\n// on the HSV color wheel. Convert the angle to\n// a value between 0 and 1.\n#define GREEN (120.0 / 360.0)\n#define BLUE (240.0 / 360.0)\n// Red is both at 0 degrees and 360 degrees.\n#define RED1 (0.0 / 360.0)\n#define RED2 (360.0 / 360.0)\n\n// Size of a sector \n#define SECTOR (1.0 / 6.0)\n// Slope of the trapezoid boundary\n// (rise = 1, run = 1/6)\n#define SLOPE (1.0 / SECTOR)\n\n// Define fuzzy logic operations\n// by aliasing built-in functions!\n#define AND min\n#define OR max\n\n// Calculate the trapezoidal fuzzy membership function\n// one of R, G, B, given a hue from 0.0 to 1.0.\n// For example, hue_trapezoid(hue, GREEN)\n// computes how \"green\" the hue is.\nfloat fuzzy_rgb(float h, float center) {\n    // This makes an upside down V shape\n    // with maximum at 2. It's scaled\n    // to match the values in the diagram (see the link above)\n    // 2          /\\\n    //           /  \\\n    // 1        /    \\\n    //         /      \\\n    //        /        \\\n    // 0     /          \\\n    //      /      | center\n    //     /              \\\n    // -1 /                \\ \n    float triangle = 2.0 - SLOPE * abs(h - center);\n    \n    // Clamp it between 0.0 and 1.0 to turn it into \n    // a trapezoid\n    //           ____\n    // 1        /    \\ <- the top spans 120 degrees. (2/6)\n    //         /      \\\n    //        /        \\\n    // 0     /__________\\ <- the base spans 240 degrees (4/6)\n    //             | center\n    return clamp(triangle, 0.0, 1.0);\n}\n\n// Convert a hue value to an RGB vector\n// with full saturation. This asssumes\n// hue is in the range 0.0 to 1.0.\nvec3 hue2rgb(float hue) {\n    // Compute membership in \"green\" and \"blue\"\n    float green = fuzzy_rgb(hue, GREEN);\n    float blue = fuzzy_rgb(hue, BLUE);\n    \n    // Red has to be handled differently since\n    // it is both at 0 and 360 degrees. Compute\n    // two half-trapezoids and union them together.\n    float red1 = fuzzy_rgb(hue, RED1);\n    float red2 = fuzzy_rgb(hue, RED2);\n    float red = OR(red1, red2);\n    \n    // Return the results for each fuzzy set.\n    return vec3(red, green, blue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Paint a rainbow across the screen\n    // horizontally. Make the rainbow move a bit with time.\n    // the fract() ensures the hue is always in [0.0, 1.0]\n    float hue = fract(uv.x + 0.1 * iTime);\n   \n    // compute the fuzzy set membership\n    vec3 color = hue2rgb(hue);\n    \n    // From here, we could use the three components\n    // to do some fuzzy logic operations. I'll do this\n    // in upcoming shaders. For now, I just wanted\n    // to display the results.\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsyfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[793, 974, 1014, 1383, 1772], [1774, 1888, 1913, 1961, 2391], [2393, 2393, 2450, 2472, 3052]]}
{"id": "XdccWN", "name": "Concentric violet circles", "author": "jamque", "description": "Concentric circles for a background scene.\nIt's a simple shader used in Bitlogic Enhanced version from OXiAB Game Studio\nGame Project Link: http://www.oxiab.com/proyectos-bitlogic-enhanced.php", "tags": ["circle", "bitlogic"], "likes": 4, "viewed": 129, "date": "1529061798", "time_retrieved": "2024-06-20T19:15:49.290701", "image_code": "float aspectScreen = 1.0;\nvec2  pixels = vec2(0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tpixels = fragCoord.xy / iResolution.xy;\n    aspectScreen = iResolution.y / iResolution.x;\n    \n\tvec3 color = vec3 (0.5,0.0,0.7);\n    \n    vec2 center = vec2 (0.5,0.5);\n    center.x += 0.02 * sin(iTime);\n    center.y += 0.03 * cos(iTime);\n        \n    vec2 q = pixels - center;\n    float radio = length(q);\n    \n    float distord  = radio + 0.2* cos( 2.0 * atan(q.y*aspectScreen,q.x) + 0.1 * sin(iTime));\n   \n    float value = smoothstep(fract(15.0 * distord + fract(-iTime / 1.0))- 0.005,0.05,0.5); \n   \n    color *= value * radio * 1.5; // Bright\n        \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdccWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[58, 58, 115, 165, 782]]}
{"id": "XddcWl", "name": "Creepy Tunnel", "author": "felipunkerito", "description": "Mouse moves the camera a little", "tags": ["3d", "raymarching", "sdf"], "likes": 14, "viewed": 557, "date": "1528017702", "time_retrieved": "2024-06-20T19:15:50.575504", "image_code": "// Thanks iq and Shane and dila\n\n#define EPS        0.001\n#define STEPS        256\n#define FAR         100.\n#define PI  acos( -1.0 )\n#define TPI     PI * 2.0\n#define HASHSCALE  .1031\n#define tim           5.\n// Comment the next line to get faster rendering\n// the problem is that it does not look as good, \n// it has some jittering\n#define PROCEDURAL\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq's\n\n#ifdef PROCEDURAL\n\nfloat noise( in vec3 x )\n{\n    \n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\n#else\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n#endif\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\n// https://www.shadertoy.com/view/MlXSWX\n\nvec2 path(in float z)\n{\n    float a = 54.0;\n    float b = a * 0.5;\n    float s = sin(z/a)*cos(z/b); return vec2(s*b, 0.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n    \n}\n\nvec2 map( vec3 p )\n{\n\n    /*vec2 tun = abs(p.xy-fbm(p))*vec2(0.5, 0.1071);\n    float n = 1. - max(tun.x, tun.y) + (0.5);\n    return min(n, p.y + fbm(p));*/\n    \n    vec3 pO = vec3( 0.0, 0.0, -iTime * tim - 0.9 );\n    pO.xy += path( pO.z );\n    \n    vec2 sph = vec2( length( p - pO ) - 0.3 - fbm( p - pO + iTime ) * 0.1, 0.0 );\n    \n    float tun = length( p.xy - path( p.z ) ) - 12.0;\n    float dif = length( p.xy - path( p.z ) ) - 6.5;\n    float fina = max( tun, -dif );\n    vec2 fin = vec2( fina - fbm( p + iTime ) * 2.0, 1.0 );\n    \n    if( sph.x < fin.x ) fin = sph;\n    \n    return fin;\n\n}\n\nvec3 norm( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    return normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                          ) );\n    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        if( h < EPS ) return 0.0;\n        res = min( res, 2.0 * h / t );\n        \n        t += h;\n    \n    }\n    \n    return res;\n\n}\n\nvec3 shad( vec3 ro, vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    vec3 lig = normalize( vec3( 0.0, 0.0, -iTime * tim ) );\n    lig.xy += path( lig.z );\n    vec3 ref = reflect( rd, n );\n    vec3 col = vec3( 0.0 );\n    //vec3 ref = texture( iChannel0, reflect( rd, n ) ).xyz;\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n    float rim = pow( 1.0 + dot( n, rd ), 2.0 );\n    \n    col += 0.4 * amb;\n    col += 0.2 * dif * sha;\n    col += 0.15 * spe;\n    col += 0.1 * rim;\n    \n    if( map( p ).y == 1.0 )\n    {\n    \n    \tcol += mix( vec3( 0.3, 0.1, 0.0 ), vec3( 0.0, 0.1, 0.2 ), fbm( p + iTime ) );\n    \n    }\n    \n    if( map( p ).y == 0.0 )\n    {\n    \n    \tcol *= vec3( 0 );\n    \n    }\n    \n    col *= vec3( 16.0 / ( 16.0 + t * t * 0.05 ) );\n    col /= vec3( 0.05 * ( 9.0 + t * t * 0.05 ) );\n    \n    col *= sqrt( col );\n    \n    return col;\n    \n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    vec2 mou = iMouse.xy / iResolution.xy;\n     \n    vec3 ro = vec3( 0.0, 0.0, -iTime * tim );\n    vec3 rd = normalize( vec3( uv, -1.0 ) );\n    \n    ro.xy += path( ro.z );\n    rd.zx *= rot( path(ro.z).x / -1000.0 );\n    \n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    \n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n\tvec3 col = d < EPS ? shad( ro, rd, t ) : vec3( 1.0 );\n    \n    if( map( p ).y == 0.0 )\n    {\n\n    \trd = normalize( reflect( rd, n ) );\n    \tro = rd * EPS;\n\n        if( d < EPS )\n        {\n            \n            col += shad( ro, rd, t ) * 0.3;\n            \n        }\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XddcWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[352, 394, 415, 415, 532], [534, 1464, 1488, 1488, 1721], [1723, 1765, 1788, 1788, 1888], [1890, 1890, 1931, 1931, 2024], [2026, 2026, 2047, 2047, 2148], [2150, 2150, 2170, 2305, 2744], [2746, 2746, 2767, 2767, 3043], [3045, 3045, 3090, 3090, 3335], [3337, 3337, 3377, 3377, 4351], [4353, 4353, 4397, 4397, 4612], [4614, 4614, 4671, 4721, 5464]]}
{"id": "XdGfDW", "name": "李明杰测试", "author": "leneer", "description": "personal use", "tags": ["digital"], "likes": 13, "viewed": 701, "date": "1528787083", "time_retrieved": "2024-06-20T19:15:50.575504", "image_code": "// by movAX13h //\n\n//vec3 color = vec3(0.2, 0.42, 0.68); // blue 1 蓝色一\n//vec3 color = vec3(0.1, 0.3, 0.5); // blue 2 蓝色二\nvec3 color = vec3(0.1, 0.5, 0.2); // Background green 绿色背景\n//vec3 color = vec3(0.1, 0.6, 0.3); // green 绿色\n\nfloat rand(float x) { return fract(sin(x) * 4358.5453123); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357); }\n\nfloat invader(vec2 p, float n)\n{\n\tp.x = abs(p.x);\n\tp.y = floor(p.y - 5.0);\n    return step(p.x, 2.0) * step(1.0, floor(mod(n/(exp2(floor(p.x - 3.0*p.y))),2.0)));\n}\n\nfloat ring(vec2 uv, float rnd)\n{\n    float t = 0.6*(iTime+0.2*rnd);\n    float i = floor(t/2.0);\n    vec2 pos = 2.0*vec2(rand(i*0.123), rand(i*2.371))-1.0;\n\treturn smoothstep(0.2, 0.0, abs(length(uv-pos)-mod(t,2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iMouse.z > 0.5) color = vec3(0.5, 0.3, 0.1);\n    \n    vec2 p = fragCoord.xy;\n\tvec2 uv = p / iResolution.xy - 0.5;\n    p.y += 120.0*iTime;\n    float r = rand(floor(p/8.0));\n    vec2 ip = mod(p,8.0)-4.0;\n    \n    float a = -0.3*smoothstep(0.1, 0.8, length(uv)) + \n        invader(ip, 809999.0*r) * (0.06 + 0.3*ring(uv,r) + max(0.0, 0.2*sin(10.0*r*iTime)));\n    \n\tfragColor = vec4(color+a, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdGfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 253, 274, 274, 313], [314, 314, 335, 335, 403], [405, 405, 437, 437, 568], [570, 570, 602, 602, 788], [790, 790, 845, 845, 1248]]}
{"id": "XdKfDw", "name": "Book of Shaders - transformation", "author": "barakchamo", "description": "Practicing the book of shaders", "tags": ["colors", "rotation", "transformation", "bookofshaders"], "likes": 2, "viewed": 94, "date": "1529086805", "time_retrieved": "2024-06-20T19:15:51.399794", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nuniform vec2 u_mouse;\nuniform float u_time;\n\nint gridSize = 50;\nfloat lineWidth = 0.01;\n\n/*\n  circle()\n    st - current pixel coordinates\n    xy - normalized circle center position\n    r  - circle radius (0.0 to 1.0)\n    fade - edge fade (0.0 to 1.0, as a percent of radius)\n*/\nfloat circle(in vec2 st, in vec2 xy, in float r, in float fade) {\n    vec2 dist = st - xy;\n\n    return 1.0 - smoothstep(\n      r - r * fade,\n      r + r * fade,\n      dot(dist, dist * 4.0)\n    );\n}\n\n/*\n  polygon()\n*/\nvec3 polygon(in vec2 st, in vec2 xy, in int n, in float angle, in float size, in float fade, in float pull) {//, in vec2 xy, in float r, in float fade) {\n   float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  vec2 mappedSt = (st + xy) *2.-1.;\n\n  // Angle and radius from the current pixel\n  float a = atan(mappedSt.x,mappedSt.y) + PI * (angle * 2.0 + 1.0);\n  float _r = TWO_PI / float(n);\n\n  // Shaping function that modulate the distance\n  d = cos(floor((0.5 + pull) + a / _r) * _r - a) * length(mappedSt);\n\n  return vec3(1.0 - smoothstep(size,size + fade + 0.01,d));\n}\n\n/*\n  polyRipple()\n*/\nvec3 polyRipple(in vec2 st, in vec2 xy, in int n, in float angle, in float size, in float fade, in float pull) {//, in vec2 xy, in float r, in float fade) {\n   float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  vec2 mappedSt = (st + xy) *2.-1.;\n\n  // Angle and radius from the current pixel\n  float a = atan(mappedSt.x,mappedSt.y) + PI * (angle * 2.0 + 1.0);\n  float _r = TWO_PI / float(n);\n\n  // Shaping function that modulate the distance\n  d = cos(floor((0.5 + pull) + a / _r) * _r - a) * length(mappedSt);\n\n  // return vec3(1.0 - smoothstep(size,size + fade + 0.01, d));\n  return vec3(clamp(fract(d * 10.0) + fade, 0.0, 1.0));\n}\n\n/*\n  ripple()\n\n*/\n\nvec3 ripple(in vec2 st, in vec2 offset, in float freq, in float pos, in float grade) {\n  // Remap the space to -1. to 1.440\n  vec2 xy = st *2.-1.;\n\n  // Make the distance field\n  float d = length( xy - offset );\n\n  // Visualize the distance field\n  return vec3(clamp(fract(d*freq + pos) + grade, 0.0, 1.0));\n}\n\n/*\n  grid()\n    st - current pixel coordinates\n    lineWidth - width of line stroke\n    gridCount - number of grid lines in X and Y axes\n    flatten - flatten XY grid colors\n    dots - draw dots instead of line strokes\n*/\nvec2 grid(in vec2 st, in float lineWidth, in float gridCount, in bool flatten, in bool dots) {\n  vec2 xy = fract(st * gridCount);\n\n  vec2 color = step(lineWidth, vec2((xy.x) , (xy.y)));\n  color *= step(lineWidth, 1.0 - vec2((xy.x) , (xy.y)));\n\n  vec2 _out;\n\n  if(!flatten) {\n    return color;\n  }\n\n  if(dots != true) {\n    _out = vec2(min(color.x, color.y));\n  } else {\n    _out = vec2(max(color.x, color.y));\n  }\n\n  return _out;\n}\n\n/*\n  posSin()\n  transforms sine function from -1 - 1 range to 0 - 1\n*/\nfloat posSin(in float n) {\n  return (sin(n) + 1.0) / 2.0;\n}\n\n/*\n  posSin()\n  transforms cosine function from -1 - 1 range to 0 - 1\n*/\nfloat posCos(in float n) {\n  return 0.5 + cos(n) / 2.0;\n}\n\nmat2 rotate2d(float _angle) {\n    return mat2(\n      cos(_angle), -sin(_angle),\n      sin(_angle), cos(_angle)\n    );\n}\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float u_time = iTime;\n  vec2 st = fragCoord/iResolution.xy;\n  // st.x *= st.x/st.y;\n  vec3 color = vec3(1.0);\n  float d = 0.0;\n\n  vec3 pct = vec3(st.x);\n\n  st.x = st.x + sin((fract(u_time / 5.0) + st.y) * 20.0) / 100.0;\n\n  // offset grid position by time\n  vec2 xy = st + fract(u_time / 20.0);\n\n  pct.r += polyRipple(st, vec2(0.0), 3, fract(-u_time / 10.0) , 0.33, 0.0, 0.0).r / -4.0;\n  pct.g += polyRipple(st, vec2(0.0), 4, fract(u_time / 10.0) , 0.33, 0.0, 0.0).r / -4.0;\n  pct.b += polyRipple(st, vec2(0.0), 5, fract(u_time / 10.0 + 0.5) , 0.33, 0.0, 0.0).r / -4.0;\n\n  st.x = st.x + sin((fract(u_time / 2.0) + st.y) * 50.0) / 50.0;\n\n  // move space from the center to the vec2(0.0)\n  st -= vec2(0.5);\n  // rotate the space\n  st = rotate2d( sin(u_time / 2.0 * PI) ) * st;\n  // move it back to the original place\n  st += vec2(0.5);\n\n  pct.r -= circle(st, vec2(0.1, 0.9), 0.333, posSin(u_time * 2.0)) ;\n  pct.r -= circle(st, vec2(0.9, 0.1), 0.333, posSin(u_time * 2.0)) ;\n  pct.g -= circle(st, vec2(0.1, 0.1), 0.333, posSin(u_time * 2.0)) ;\n  pct.g -= circle(st, vec2(0.9, 0.9), 0.333, posSin(u_time * 2.0)) ;\n\n  color = mix(colorA, colorB, pct);\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[190, 379, 444, 444, 576], [578, 596, 705, 749, 1166], [1168, 1189, 1301, 1345, 1822], [1824, 1843, 1929, 1966, 2152], [2154, 2376, 2470, 2470, 2807], [2809, 2880, 2906, 2906, 2939], [2941, 3014, 3040, 3040, 3071], [3073, 3073, 3102, 3102, 3192], [3273, 3273, 3330, 3330, 4515]]}
{"id": "XdKfRD", "name": "Wavy vortex", "author": "knutae", "description": "Answer to StackOverflow question https://stackoverflow.com/questions/5451376/how-to-implement-this-tunnel-like-animation-in-webgl/5493122", "tags": ["tunnel"], "likes": 10, "viewed": 389, "date": "1527806728", "time_retrieved": "2024-06-20T19:15:51.399794", "image_code": "const float PI = 3.14159265358979323846264;\nconst float TWOPI = PI*2.0;\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\nconst int MAX_RINGS = 30;\nconst float RING_DISTANCE = 0.05;\nconst float WAVE_COUNT = 60.0;\nconst float WAVE_DEPTH = 0.04;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rot = mod(iTime*0.6, TWOPI);\n    vec2 pos = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    pos = vec2(3.0*(pos.x - 0.5), 2.0*(pos.y - 0.5));\n    float x = pos.x;\n    float y = pos.y;\n\n    bool black = false;\n    float prevRingDist = RING_DISTANCE;\n    for (int i = 0; i < MAX_RINGS; i++) {\n        vec2 center = vec2(0.0, 0.7 - RING_DISTANCE * float(i)*1.2);\n        float radius = 0.5 + RING_DISTANCE / (pow(float(i+5), 1.1)*0.006);\n        float dist = distance(center, pos);\n        dist = pow(dist, 0.3);\n        float ringDist = abs(dist-radius);\n        if (ringDist < RING_DISTANCE*prevRingDist*7.0) {\n            float angle = atan(y - center.y, x - center.x);\n            float thickness = 1.1 * abs(dist - radius) / prevRingDist;\n            float depthFactor = WAVE_DEPTH * sin((angle+rot*radius) * WAVE_COUNT);\n            if (dist > radius) {\n                black = (thickness < RING_DISTANCE * 5.0 - depthFactor * 2.0);\n            }\n            else {\n                black = (thickness < RING_DISTANCE * 5.0 + depthFactor);\n            }\n            break;\n        }\n        if (dist > radius) break;\n        prevRingDist = ringDist;\n    }\n\n    fragColor = black ? BLACK : WHITE;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[285, 285, 342, 342, 1572]]}
{"id": "XdKfWD", "name": "Graffat on", "author": "luutifa", "description": "For graffathon 2018", "tags": ["finlandsfarjan"], "likes": 0, "viewed": 79, "date": "1528901048", "time_retrieved": "2024-06-20T19:15:52.151391", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nconst int OCTAVES=5;\nfloat fbm (vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nconst int ITR=50;\nconst float EPS=0.001;\nconst float MAX_T=120.;\n\nint material = 0;\n\nfloat xz_plane(vec3 p) {\n    return p.y;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 middle_sphere(vec3 p) {\n    //return vec2(sphere(p - vec3(2.8, 2.5, 5.), 1.), 0.);\n    return vec2(sphere(p - vec3(4., 2.5, 4.), 0.8), 0.);\n}\n\nvec2 floor_plane(vec3 p) {\n    vec2 aallot_pos = p.xz*0.5;\n    aallot_pos.x += sin(aallot_pos.y*2.+iTime*0.6)*0.2;\n    return vec2(xz_plane(p - vec3(0., -1., 0.) - fbm(aallot_pos)*0.2 + fbm(aallot_pos+iTime*0.4)*0.2), 1.);\n}\n\nvec2 boat(vec3 p) {\n    float a = 0.6;\n    vec2 base = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a), p.y, p.x * sin(a) + p.z * cos(a)) - vec3(-1.5, -1., 3.), vec3(.4, 0.1, 1.)), 2.);\n    vec2 top = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a), p.y, p.x * sin(a) +p.z * cos(a)) - vec3(-1.5, -0.9, 3.), vec3(.3, 0.1, 0.8)), 3.);\n    vec2 piippu = vec2(sdBox(vec3(p.x * cos(a) - p.z * sin(a),\n                    p.y,p.x*sin(a)+p.z * cos(a)) - vec3(-1.5, -.7, 2.6), vec3(.06, 0.1,0.2)), 2.);\n    if (base.x < top.x) {\n        return base;\n    } else if (top.x < piippu.x) {\n        return top;\n    } else {\n        return piippu;\n    }\n}\n\nvec2 sdf(vec3 p) {\n    vec2 ms = middle_sphere(p);\n    vec2 fp = floor_plane(p);\n    vec2 bt = boat(p);\n    if (ms.x < fp.x) {\n        return ms;\n    } else if (fp.x < bt.x) {\n        return fp;\n    } else {\n        return bt;\n    }\n}\n\nvec3 march(vec3 cam, vec3 ray) {\n    vec2 dist;\n    float t=0.;\n    for (int i=0; i<ITR; i++) {\n        dist = sdf(cam + ray * t);\n        t += dist.x*1.2;\n        if (dist.x < EPS) {\n            material = int(dist.y);\n            break;\n        }\n        if (t > MAX_T) {\n            material = -1;\n            break;\n        }\n    }\n    return cam + ray * t;\n}\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPS, 0.);\n    return (vec3(sdf(p+e.xyy).x, sdf(p+e.yxy).x, sdf(p+e.yyx).x) - sdf(p).x) / e.x;\n}\n\nvec3 sky(vec3 p) {\n    return mix(vec3(0.2, 0.3, 0.7), vec3(0.3, 0.5, 1.1), p.y/20.);\n}\n\nvec3 shade(vec3 p) {\n    if (p.z > 6.) {\n        return sky(p);\n    }\n    vec3 light = normalize(vec3(0., 0., 1.));\n    vec3 light2 = normalize(vec3(-0.2, -1., 0.2));\n    vec3 normal = normalize(grad(p));\n\n    float l = clamp(dot(-normal, light), 0., 1.);\n    l += clamp(dot(-normal, light2), 0., 1.);\n\n    vec3 color = vec3(1., 1., 0.);\n    float emit = 0.2;\n    if (material == -1) {\n        color = vec3(0.);\n    } else if (material == 1) {\n        color = vec3(0., 0., 1.);\n        l += pow(l, 12.);\n    } else if (material == 2) {\n        color = vec3(1., 0., 0.);\n    } else if (material == 3) {\n        color = vec3(1.);\n    }\n    return vec3(l * (color + emit));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //vec3 ray = normalize(vec3((v_texpos*vec2(2.*u_aspect_ratio,2.)-vec2(u_aspect_ratio,1.)), 1.));\n    vec3 ray = normalize(vec3(fragCoord/iResolution.yy*2.-1., 1.));\n    vec3 p = march(vec3(sin(iTime*0.3)*0.1, sin(iTime*0.2)*0.1, sin(iTime*0.1)*0.3), ray);\n    vec2 cloudpos = fragCoord/iResolution.xy*10.+vec2(iTime*0.6, 0.);\n    cloudpos.y += sin(cloudpos.x-iTime)*0.2;\n    cloudpos.y += sin(cloudpos.x*4.-iTime*0.3)*0.07;\n    fragColor = vec4(shade(p)+fbm(cloudpos*(sin(cloudpos.x+iTime)*.001+1.))*0.4*cloudpos.y/5., 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 93], [95, 173, 196, 196, 513], [536, 536, 557, 557, 782], [869, 869, 893, 893, 911], [913, 913, 944, 944, 972], [974, 974, 1005, 1005, 1092], [1094, 1094, 1122, 1181, 1240], [1242, 1242, 1268, 1268, 1466], [1468, 1468, 1487, 1487, 2100], [2102, 2102, 2120, 2120, 2336], [2338, 2338, 2370, 2370, 2701], [2703, 2703, 2722, 2722, 2836], [2838, 2838, 2856, 2856, 2925], [2927, 2927, 2947, 2947, 3599], [3601, 3601, 3656, 3757, 4186]]}
{"id": "XdKfWw", "name": "Particules Test", "author": "FlorianDuf", "description": "Test Particules.\n\nThey are many little problem in my particules simulator. Like the noise and the non chaotic movement of my particules.", "tags": ["particules2d"], "likes": 4, "viewed": 165, "date": "1529073860", "time_retrieved": "2024-06-20T19:15:52.424169", "image_code": "float rand(float n){\n    return 2.0*fract(cos(n*89.42)*343.42);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nbool point(in vec2 p, in vec2 pRef, in float distMax)\n{\n    return distance(p, pRef) <= distMax;\n}\n\nvec2 point_pos = vec2(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    float maxPoint = 40.0;\n    float size_point = 0.02;\n    \n    for (float i = 0.0; i < maxPoint; ++i)\n    {\n        float hazard=rand(i);\n        for (float j = 0.0; j < maxPoint; ++j)\n        {\n            float hazard2=rand(j);\n            point_pos = vec2(sin(hazard * hash(j) * iTime + hash(i + j+1.0)), sin(hazard2 *hash(i) * iTime + hash(i - j+1.0)));\n            \tif ( point(uv, point_pos, size_point) )\n                {\n                    //col = vec3(1.0);\n                    col = vec3(hash(j)); // Inferno's proposal\n                \t//col = vec3(hash(i),hash(j), hash(i*j));        \n                }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 65], [67, 67, 90, 90, 129], [132, 132, 187, 187, 230], [261, 261, 318, 368, 1232]]}
{"id": "XdKfzd", "name": "checkflow", "author": "lennyjpg", "description": "sdfgsdgfsgsdgf", "tags": ["dfgsdfgsd"], "likes": 5, "viewed": 354, "date": "1530045504", "time_retrieved": "2024-06-20T19:15:52.424169", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float f = 50.0;\n    float t = iTime * .150;\n    float e = 0.123;\n    float i = 7.7123;\n    uv.x += t + sin(uv.y*i)*e;\n    uv.y += t - cos(uv.x*i)*e;\n    float g = 100.0;\n    float k = sin(uv.x * g) * tan(uv.y*g) * f;\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 344]]}
{"id": "XdVfDw", "name": "Ray marching practice 1", "author": "lnae", "description": "my first attempt at ray marching", "tags": ["3d", "raymarching"], "likes": 6, "viewed": 267, "date": "1529090303", "time_retrieved": "2024-06-20T19:15:52.424169", "image_code": "#define STEPS 150.\n#define EPS 0.001\n#define EPSN 0.01\n\nmat2 rot(float angle){\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(vec3 pos){\n    vec3 twistedPos = vec3(rot(1.5 * sin(0.1 * pos.z + iTime)) * pos.xy, pos.z);\n    vec3 repeatPos = mod(twistedPos, 1.) - 0.5;\n    float dist = distSphere(repeatPos, 0.1 + 0.1 * sin(pos.z + 2. * iTime));    \n    return dist;\n}\n\nvec3 getNormal(vec3 pos){\n\treturn normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.)) - distScene(pos - vec3(EPSN, 0., 0.)),\n               distScene(pos + vec3(0., EPSN, 0.)) - distScene(pos - vec3(0., EPSN, 0.)),\n               distScene(pos + vec3(0., 0., EPSN)) - distScene(pos - vec3(0., 0., EPSN))));\n}\n\nvec3 render(vec2 uv){\n    vec3 bgcol = vec3(1. - length(uv)) + length(uv) * vec3(0., 0., 0.3);\n    vec3 eye = vec3(0., 0., 3.);\n    vec3 ray = normalize(vec3(uv, 0.) - eye);\n    vec3 pos = eye;\n    float dist, step;\n    bool hit = false;\n    \n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    float totalDist = length(pos - eye);\n    vec3 col = vec3(step / STEPS, 0.33, 0.66);\n    if(hit && totalDist < 30.)col = mix(col, getNormal(pos) * 0.5 + 0.5, 0.7);\n    col = mix(bgcol, col, 1./exp(totalDist * totalDist * 0.0006)); //fog\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;    \n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdVfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[56, 56, 78, 78, 143], [145, 145, 186, 186, 218], [220, 220, 246, 246, 475], [477, 477, 502, 502, 784], [786, 786, 807, 807, 1468], [1470, 1470, 1527, 1527, 1657]]}
{"id": "XdVfzd", "name": "Connections", "author": "Txoka", "description": "Sparkling points beeing connected by proximity.\n\nidea taken from:\nhttps://www.shadertoy.com/view/lscczl", "tags": ["lines", "dots", "points", "sparkle", "connections"], "likes": 30, "viewed": 1110, "date": "1530050211", "time_retrieved": "2024-06-20T19:15:52.424169", "image_code": "#define s(a,b,c) smoothstep(a,b,c)\n//#define experimental\nhighp float rand(vec2 co) {\n    return fract(cos(mod(dot(co.xy+0.12,vec2(12.9898,78.233)),3.14))*43758.5453);\n}\nhighp vec3 rand3(vec2 co){\n\tfloat t=rand(co);\n\tfloat z=rand(co+t);\n\treturn vec3(t,z,rand(co+z));\n}\nvec3 getpoint(vec2 id){\n\tvec3 r=rand3(id);\n\tvec3 ou=vec3(\n\t\tsin(iTime*r.x),\n\t\tcos(iTime*r.y),\n\t\tsin(iTime*r.z*10.)\n\t);\n\treturn ou*0.45+0.5;\n}\n\nfloat line(vec2 uv, vec2 p, vec2 p2){\n\tvec2 n=uv-p;\n\tvec2 w=p2-p;\n\tfloat r=clamp(dot(n,w)/dot(w,w),0.,1.);\n\tr=length(n-w*r);\n    #ifdef experimental\n\treturn clamp(0.01/r,0.,1.)*(s(0.6,1.,1./distance(p,p2)));\n    #else\n    return clamp(s(0.04,0.01,r)*(s(0.6,1.,1./distance(p,p2))),0.,1.);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tuv*=5.;\n\t\n\tvec2 id=floor(uv);\n    vec2 c=fract(uv);\n\n    vec2 p[9];\n\tfloat col=0.;\n    int i=0;\n    for(float n=-1.;n<=1.;n++){\n        for(float w=-1.;w<=1.;w++){\n\t\t\tvec2 nc=id+vec2(w,n);\n\t\t\tvec3 point=getpoint(nc);\n\t\t\tp[i]=point.xy+vec2(w,n);\n\t\t\tvec2 a=(p[i].xy-c)*10.;\n\t\t\tcol+=pow(point.z/dot(a,a),2.2);\n            i++;\n\t\t}\n\t}\n    \n    for(int i=0;i<9;i++){\n\t\tcol+=pow(line(c,p[i].xy,p[4].xy),2.2);\n\t}\n\tcol+=pow(line(c,p[1].xy,p[3].xy),2.2);\n\tcol+=pow(line(c,p[1].xy,p[5].xy),2.2);\n\tcol+=pow(line(c,p[7].xy,p[3].xy),2.2);\n    col+=pow(line(c,p[7].xy,p[5].xy),2.2);\n\t\n    col=pow(col,1./2.2);\n    col*=col;\n    col*=0.5;\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdVfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[35, 269, 292, 292, 410], [412, 412, 449, 449, 712], [714, 714, 770, 770, 1498]]}
{"id": "XdyBRc", "name": "Seamless cell noise", "author": "piluve", "description": "Working sample of how to implement seamless (tileable) 2d cell noise.", "tags": ["noise", "cell", "seamless"], "likes": 3, "viewed": 493, "date": "1529685119", "time_retrieved": "2024-06-20T19:15:52.424169", "image_code": "/*\n\t--: Seamless cell noise : --\n\t   nachocpol@gmail.com\n*/\n\nvec2 ran2( vec2 p ) \n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n\t\t\t  \t\t\t  dot(p,vec2(269.5,183.3))))\n                 \t\t\t* 43758.5453123);\n}\n\nfloat TileCell(vec2 tc, int grid, float seed)\n{\n    vec2 p   = tc * float(grid);\n    vec2 ftc = fract(p);\n    vec2 itc = floor(p);\n    float m  = 1.0;\n    \n    for(int i = -1; i < 2; i++)\n    {\n        for(int j = -1; j < 2; j++)\n        {\n            vec2 n = vec2(i,j);\n            vec2 q = itc + n;\n            \n            if(q.x == -1.0)q.x = float(grid-1);\n            else if(q.x == float(grid))q.x = 0.0;\n                \n            if(q.y == -1.0)q.y =float(grid-1);\n            else if(q.y == float(grid))q.y = 0.0;\n\n            vec2 rp \t= ran2(q * seed);\n            vec2 diff \t= n + rp - ftc;\n            float dist \t= length(diff);\n            m \t\t\t= min(m,dist);\n        }\n    } \n    \n    return pow(1.0 - m,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv \t= fragCoord/iResolution.xy;\n    float t \t= (sin(iTime * 0.25) * 4.0) + 6.0;\n    uv \t\t\t= fract(uv*t);   \n    // Cell noise \n    float c \t= TileCell(uv,4,1.0);\n    fragColor.xyz = vec3(0.3,0.25,0.67) * c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 61, 83, 83, 209], [211, 211, 258, 258, 941], [943, 943, 1000, 1000, 1218]]}
{"id": "XdyBW1", "name": "Trench Stairs", "author": "ChrisK", "description": "Click and drag to rotate camera", "tags": ["pathtracing", "stairs"], "likes": 1, "viewed": 295, "date": "1528584664", "time_retrieved": "2024-06-20T19:15:53.830305", "image_code": "// An infinite corridor with infinitely high stairs on both sides.\n\n// The sky is filled in analytically based on the angle of the camera ray,\n// so no rays are wasted on the sky and the horizon is in the correct spot\n// regardless of pathtracing distance or detail.\n\n// I am using blue noise to randomly jitter the position of the camera for each pixel.\n// This does a decent job of hiding aliasing in motion and I think it also works well\n// for simulating the slightly fuzzy effect of mesoptic (low-light) vision.\n// To turn the effect off, disable CAMERA_JITTER.\n\n\n//quick hack to loop every 20 seconds (fix problems when shader runs for a long time)\n#define iTime mod(iTime, 20.0)\n\n#define PI\t\t\t3.14159265359\n#define HALF_PI\t\t1.57079632679\n#define TAU     \t6.28318530718\n\n#define FOV\t\t\t\t\t\tPI*0.5\n#define CAMERA_HEIGHT\t\t\t1.0\n#define CAMERA_SPEED\t\t\t2.0\n#define CAMERA_JITTER\n\n#define LIGHT_POSITION\t\t\tro+vec3(0.5, -0.75, 0.0)\n#define SHADOW_HARDNESS\t\t\t250.0\n#define NORMAL_MAPPING\n\n#define MAX_STEPS_PER_RAY   \t100\n#define MAX_RAY_LENGTH     \t\t200.0\n#define EPSILON\t\t\t\t\t0.00005\t\t//error tolerance for ray-object collision\n#define SHADOW_ERROR\t\t\t0.01\n\n//#define DEBUG\n\n\n///////////////////////////////////////////////////////////////////////////////////////\n//\tMODEL\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t\t \t\t //\n///////////////////////////////////////////////////////////////////////////////////////\n\n//displacements (use in place of 'p' in distance function)\nvec3 repeat ( vec3 p, vec3 d ) { return mod(p+d*0.5,d)-d*0.5; }\n\nvec3 xrotate (vec3 p, float r) { return vec3( p.x, p.y*cos(r)-p.z*sin(r), p.y*sin(r)+p.z*cos(r) ); }\nvec3 yrotate (vec3 p, float r) { return vec3( p.x*cos(r)+p.z*sin(r), p.y, -p.x*sin(r)+p.z*cos(r) ); }\nvec3 zrotate (vec3 p, float r) { return vec3( p.x*cos(r)-p.y*sin(r), p.x*sin(r)+p.y*cos(r), p.z ); }\n\n//primatives\nfloat plane ( vec3 p ) { return abs(p.y); }\nfloat sphere ( vec3 p, float r ) { return length(p)-r; }\nfloat cube ( vec3 p, float l ) { vec3 d=abs(p)-l; return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)); }\nfloat box ( vec3 p, vec3 l ) { vec3 d=abs(p)-l; return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)); }\nfloat ubox ( vec3 p, vec3 l ) { return length(max(abs(p)-l,0.0)); }\n\nfloat xbar ( vec3 p, vec2 l ) { vec2 d=abs(p.yz)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\nfloat ybar ( vec3 p, vec2 l ) { vec2 d=abs(p.xz)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\nfloat zbar ( vec3 p, vec2 l ) { vec2 d=abs(p.xy)-l; return min(max(d.x,d.y),0.0)+length(max(d,0.0)); }\n\nfloat xcylinder ( vec3 p, float r ) { return length(p.yz)-r; }\nfloat ycylinder ( vec3 p, float r ) { return length(p.xz)-r; }\nfloat zcylinder ( vec3 p, float r ) { return length(p.xy)-r; }\n\nfloat xcylinder ( vec3 p, float r, float l ) { return max(length(p.yz)-r,abs(p.x)-l); }\nfloat ycylinder ( vec3 p, float r, float l ) { return max(length(p.xz)-r,abs(p.y)-l); }\nfloat zcylinder ( vec3 p, float r, float l ) { return max(length(p.xy)-r,abs(p.z)-l); }\n\nfloat torus ( vec3 p, float ra, float rb ) { return length(vec2(length(p.xz)-ra, p.y))-rb; }\nfloat cone ( vec3 p, float m ) { return dot(normalize(vec2(m, 1.0)), vec2(length(p.xz), p.y)); }\n\n\nfloat model ( vec3 p ) {\n    float stepsize = 0.5;\n    float stairwidth = 1.0;\n    float stairrepeat = 10.0;\n    float railheight = 3.0;\n    float wallwidth = 15.0;\n    float trenchwidth = 5.0;\n    \n    float ground = p.y+2.0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//ground plane\n    //ground = max( ground, -zbar(p, vec2(trenchwidth, 5.0)) );\t\t\t\t\t\t\t//cut trench\n    \n    p.x = abs(p.x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//mirror horizontally\n    vec3 sp = zrotate(p-vec3(wallwidth,0.0,5.0), -PI*0.25);\t\t\t\t\t\t\t\t//rotate space to match wall angle\n    float wall = sp.y-1.25;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//wall\n    \n    sp = repeat( sp, vec3(0.0,0.0,stairrepeat) );\t\t\t\t\t\t\t\t\t\t//repeat space along z-axis\n    float stepsides = xbar(sp, vec2(1.5, stairwidth+0.25 ));\t\t\t\t\t\t\t//slopes up side of stairs\n    wall = max( wall, -stepsides );\t\t\t\t\t\t\t\t\t\t\t\t\t\t//cut groove in wall for staircase\n    stepsides = max( stepsides, -xbar(sp, vec2(2.0, stairwidth )) );\t\t\t\t\t//cut space for steps\n    \n    float railing = \t\tycylinder( repeat(p+vec3(0.5,0.0,15.0-stairwidth-0.125), vec3(1.0, 0.0, stairrepeat)), 0.05);\n    railing = min( railing, ycylinder( repeat(p+vec3(0.5,0.0,15.0+stairwidth+0.125), vec3(1.0, 0.0, stairrepeat)), 0.05) );\n    railing = max( railing, sp.y-railheight );\t\t\t\t\t\t\t\t\t\t\t//cut balustrade above handrail\n    railing = min( railing, xcylinder(sp-vec3(0.0, railheight, stairwidth+0.125), 0.075 ) );\t//handrail #1\n    railing = min( railing, xcylinder(sp-vec3(0.0, railheight,-stairwidth-0.125), 0.075 ) );\t//handrail #2\n    \n    sp = repeat( sp, vec3(stepsize,0.0,0.0) );\t\t\t\t\t\t\t\t\t\t\t//repeat space along stair run\n    sp = zrotate(sp, PI*0.25);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//rotate space back to normal axes\n    float steps = ubox( sp, vec3(1.0,1.0,stairwidth) )-0.01;\t\t\t\t\t\t\t//staircase steps\n    float stairs = min( steps, stepsides );\t\t\t\t\t\t\t\t\t\t\t\t//combine steps with staircase sides\n    stairs = min( stairs, railing );\t\t\t\t\t\t\t\t\t\t\t\t\t//combine stairs with railings\n    stairs = max( stairs, wallwidth-p.x-4.0 );\t\t\t\t\t\t\t\t\t\t\t//cut stairs at bottom\n    \n    float trh = sqrt(2.0*railheight*railheight);\n    float trenchrail = ycylinder( repeat(p-vec3(trenchwidth+0.1, -2.0, 0.0), vec3(0.0, 0.0, 1.0)), 0.05, trh*0.5);\t//trenchside balustrade\n    trenchrail = min(trenchrail, zcylinder(p-vec3(trenchwidth+0.1, trh*0.5-2.0, 0.0), 0.075 ) );\t\t\t\t\t//trenchside handrails\n    \n    float d = min( wall, stairs );\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine wall and stairs\n    d = min( d, ground );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine with ground\n    d = min( d, trenchrail );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//combine with trench railing\n    d = max( d, -zbar(p, vec2(trenchwidth, 5.0)) );\t\t\t\t\t\t\t\t\t\t//cut trench\n    \n\treturn d;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tMATH\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcintersection ( vec3 ro, vec3 rd ) {\n\t//use sphere tracing to advance along ray\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    for ( int i=0; i<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH; i++ ) {\n\t\th = model( ro+rd*d );\n        d += h;\n\t}\n\treturn d<MAX_RAY_LENGTH ? d : -1.0;\n}\n\n\nfloat softshadow( vec3 ro, vec3 rd, float ldist ) {  \n    float res = 1.0;\n    float dmin = SHADOW_ERROR;\n    for( float t=dmin; t<ldist-dmin; ) {\n        float h = model(ro + rd*t);\n        if( h<SHADOW_ERROR*0.001 )\n            return 0.0;\t\t\t\t//full shadow - break early\n        res = min( res, SHADOW_HARDNESS*h/t );\n        t += h;\n    }\n    return res*res*(3.0-2.0*res);\t//adjust penumbra falloff for smoother results\n}\n\n\nvec3 getdata ( vec3 ro, vec3 rd ) {\n\t//use sphere tracing to advance along ray\n\tfloat h = 100.0;\n\tfloat d = 0.0;\n    int steps = 0;\n    while ( steps<MAX_STEPS_PER_RAY && h>EPSILON && d<MAX_RAY_LENGTH ) {\n\t\th = model( ro+rd*d );\n        d += h;\n        steps++;\n\t}\n\treturn vec3(d<MAX_RAY_LENGTH ? d : -1.0, steps, h);\n}\n\n\nvec3 getnormal ( vec3 p ) {\n\tconst float e = EPSILON*100.0;\n\tvec3 nor = vec3( model( p - vec3(e,0.0,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,e,0.0) ),\n\t\t\t\t\t model( p - vec3(0.0,0.0,e) ) );\n    nor = normalize( vec3(model(p)) - nor );\n    \n    #ifdef NORMAL_MAPPING\n    vec3 bump = texture( iChannel1, mix(p.xz,p.yz,abs(nor.x))*0.05 ).rgb - 0.5;\n    nor += bump*0.3;\n    nor = normalize(nor);\n    #endif\n    \n    return nor;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n//\tRENDERING\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 getrendersample ( vec3 ro, vec3 rd ) {\n    if( (rd.x-rd.y)<0.0 && (rd.x+rd.y)>0.0 ) {\n    \t//ray hit sky\n        return vec3(0.0,0.002,0.01)*(1.1-rd.y);\n    }\n        \n    float rl = calcintersection( ro, rd );\n    if ( rl > -0.5 ) {\n        //draw object\n\t\tvec3 xyz = ro + rd*rl;\n\t\tvec3 nor = getnormal( xyz );\n        \n        vec3 ld = normalize(LIGHT_POSITION-xyz);\t\t\t\t\t\t\t\t//direction to light\n        float ldist = distance(xyz,LIGHT_POSITION);\t\t\t\t\t\t\t\t//distance to light\n        vec3 lcol = vec3(0.75,0.7,0.5);\t\t\t\t\t\t\t\t\t\t\t//light colour\n        float li = 20.0/(ldist*ldist);\t\t\t\t\t\t\t\t\t\t\t//distance falloff\n        float shad = softshadow(xyz, ld, ldist);\t\t\t\t\t\t\t\t//soft shadows\n        \n        //float tex = texture( iChannel1, mix(xyz.xz,xyz.yz,abs(nor.x))*0.05 ).r;\n        \n        float diff = max(dot(ld, nor), 0.0);\t\t\t\t\t\t\t\t\t//Lambertian diffuse\n        \n        vec3 hv = normalize(ld-rd);\n        float m = 0.2;\n        float a = acos(dot(nor,hv));\n        float ta = tan(a);\n        float ca = cos(a);\n        float spec = exp(-(ta*ta)/(m*m))/(PI*m*m*ca*ca*ca*ca);\t\t\t\t\t//Beckmann specular\n        \n        vec3 c = mix( diff*lcol, vec3(spec), 0.15) * li*shad;\n        c += lcol*lcol*2.0/pow(distance(xyz,LIGHT_POSITION),2.0);\t\t\t\t//bounce light approximation\n        c *= 1.0 - clamp( (rl-50.0)/(MAX_RAY_LENGTH-50.0), 0.0, 1.0);\t\t\t//black fog to better hide render limit\n        return c;\n\t} else {\n\t\treturn vec3(0.0);\n\t}\n}\n\n\nvec3 getheatmap ( vec3 ro, vec3 rd ) {\n    //ray hit sky\n    if( (rd.x-rd.y)<0.0 && (rd.x+rd.y)>0.0 ) return vec3(0.0);\n    \n    vec3 gd = getdata(ro, rd);\n    \n    float steps = gd.y/float(MAX_STEPS_PER_RAY);\n    \n    if ( gd.x > -0.5 ) {\n\t\tvec3 xyz = ro + rd*gd.x;\n        vec3 ld = normalize( LIGHT_POSITION-xyz );\n        vec3 ldata = getdata( LIGHT_POSITION, -ld );\n        \n        float lightsteps = ldata.y/float(MAX_STEPS_PER_RAY);\n        float error = float(gd.z>EPSILON) + float(ldata.z>EPSILON);\n        return vec3( steps, error*0.5, lightsteps );\n\t} else {\n\t\treturn vec3( steps, 0.0, 0.0 );\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy*2.0 - 1.0;\t//camera-space position (-1 => 1)\n    \n    vec3 campos = vec3(0.0,CAMERA_HEIGHT,iTime*CAMERA_SPEED);\n    //campos = vec3( iTime, iTime, 0.0 )*CAMERA_SPEED;\t\t\t//stair climbing camera\n    \n    vec3 noise = texelFetch(iChannel0, ivec2(mod(fragCoord+float(iFrame)*30.0,1024.0)), 0).rgb-0.5;\n    \n    #ifdef CAMERA_JITTER\n    uv += noise.xy / iResolution.xy * (iResolution.x*0.002); \t\t\t\t//positional noise\n    //uv += noise.xy / iResolution.xy * (iResolution.x*0.01) * dot(uv,uv);\n    #endif\n    \n    uv.y *= iResolution.y/iResolution.x;\n    \n    float d = 1.0/tan(FOV/2.0);\t\t\t\t\t\t//distance from aperture/lens to picture plane\n    vec3 camray = normalize( vec3(uv,d) );\n    \n    if (iMouse.z>0.0) {\n    \tcamray = xrotate(camray, HALF_PI-iMouse.y/iResolution.y*PI);\n    \tcamray = yrotate(camray, PI+iMouse.x/iResolution.x*TAU);\n    }\n\n    vec3 col;\n    \n    #ifdef DEBUG\n    \n    col = getheatmap( campos, camray );\n    \n    #else\n    \n    col = getrendersample( campos, camray );\n    col *= 1.0-dot(uv,uv)*0.5;\t\t\t\t\t\t//vignette\n    col /= col+1.0;\t\t\t\t\t\t\t\t\t//Reinhard tonemapping\n    col = pow( col, vec3(0.45) );\t\t\t\t\t//gamma adjustment\n    col += noise/20.0;\t\t\t\t\t\t\t\t//noise\n    \n    #endif\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1383, 1442, 1474, 1474, 1505], [1507, 1507, 1539, 1539, 1607], [1608, 1608, 1640, 1640, 1709], [1710, 1710, 1742, 1742, 1810], [1812, 1825, 1849, 1849, 1868], [1869, 1869, 1903, 1903, 1925], [1926, 1926, 1958, 1958, 2035], [2036, 2036, 2066, 2066, 2143], [2144, 2144, 2175, 2175, 2211], [2213, 2213, 2244, 2244, 2315], [2316, 2316, 2347, 2347, 2418], [2419, 2419, 2450, 2450, 2521], [2523, 2523, 2560, 2560, 2585], [2586, 2586, 2623, 2623, 2648], [2649, 2649, 2686, 2686, 2711], [2713, 2713, 2759, 2759, 2800], [2801, 2801, 2847, 2847, 2888], [2889, 2889, 2935, 2935, 2976], [2978, 2978, 3022, 3022, 3070], [3071, 3071, 3103, 3103, 3167], [3170, 3170, 3194, 3194, 5773], [5776, 5980, 6025, 6068, 6265], [6268, 6268, 6319, 6319, 6692], [6695, 6695, 6730, 6773, 7014], [7017, 7017, 7044, 7044, 7435], [7438, 7646, 7689, 7689, 9085], [9088, 9088, 9126, 9144, 9698], [9701, 9701, 9758, 9758, 11036]]}
{"id": "XdyBWD", "name": "alijaya - Raytracer again", "author": "alijaya", "description": "raytracer again with reflection", "tags": ["raytracer"], "likes": 6, "viewed": 460, "date": "1528930045", "time_retrieved": "2024-06-20T19:15:53.836419", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Material {\n    vec3 ambient;\n    vec3 emission;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct HitInfo {\n    Ray ray;\n    bool isHit;\n    float dist;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Light {\n    bool directional;\n    vec3 position;\n    vec3 color;\n    float attenuation_constant;\n    float attenuation_linear;\n    float attenuation_quadratic;\n};\n\nvec3 camera_position;\nvec3 camera_target;\nvec3 camera_up;\nfloat aspect;\nfloat fovy;\nvec2 mouse;\nfloat PI = acos(-1.);\nfloat EPS = 0.001;\nvec3 ambientLight;\nLight lights[4];\nint numLights = 0;\nconst int maxDepth = 2;\n\nvoid addLight( Light light ) {\n    lights[numLights] = light;\n    numLights++;\n}\n\nHitInfo hitSphere( Ray ray, Sphere sphere ) {\n    // p = o + d * t\n    // (p - c) . (p - c) - r * r = 0\n    // (o + d * t - c) . (o + d * t - c) - r * r = 0\n    // (d . d) tt + 2 (d . (o - c)) t + ((o - c) . (o - c) - rr) = 0\n    \n    \n    vec3 co = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(ray.direction, co);\n    float c = dot(co, co) - sphere.radius * sphere.radius;\n    \n    float det = b * b - 4. * a * c;\n    \n    HitInfo hit;\n    hit.ray = ray;\n    if (det < 0.) {\n        hit.isHit = false;\n    } else {\n        hit.isHit = true;\n        \n        float t1 = (-b + sqrt(det)) / (2. * a);\n        float t2 = (-b - sqrt(det)) / (2. * a);\n        \n        if (t1 < 0. && t2 < 0.) {\n            hit.isHit = false;\n        } else if (t1 < 0.) {\n            hit.dist = t2;\n        } else if (t2 < 0.) {\n            hit.dist = t1;\n        } else {\n            hit.dist = min(t1, t2);\n        }\n    }\n    \n    if (hit.isHit) {\n        vec3 p = ray.origin + ray.direction * hit.dist;\n        hit.normal = normalize(p - sphere.center);\n        hit.material = sphere.material;\n    }\n    \n    return hit;\n}\n\nHitInfo selectHit( HitInfo a, HitInfo b ) {\n    if (!a.isHit) return b;\n    if (!b.isHit) return a;\n    if (a.dist < b.dist) return a;\n    else return b;\n}\n\nHitInfo castRay( Ray ray ) {\n    HitInfo hit;\n    \n    for (float i=0.; i<5.; i++) {\n        for (float j=0.; j<5.; j++) {\n            Sphere sp;\n            sp.center = vec3(j-2., i-2., 2.*sin(3.*iTime+i+j));\n            sp.radius = 0.4;\n            sp.material.ambient = vec3(1.);\n            sp.material.diffuse = vec3(i/5., 1., 1.);\n            sp.material.specular = vec3(0.5);\n            sp.material.shininess = (j+1.) * 10.;\n            \n            hit = selectHit(hit, hitSphere(ray, sp));\n        }\n    }\n    \n    return hit;\n}\n\nHitInfo castRayToLight( Ray ray ) {\n    HitInfo hit;\n    \n    for (int i=0; i<numLights; i++) {\n        Light l = lights[i];\n        Sphere sp;\n        sp.center = l.position;\n        sp.radius = 0.1;\n        sp.material.emission = l.color;\n        hit = selectHit(hit, hitSphere(ray, sp));\n    }\n    \n    return hit;\n}\n\nvec3 getColor( HitInfo hit ) {\n    HitInfo hitStack[maxDepth];\n    int depth = 0;\n    hitStack[depth] = hit;\n    \n    while (depth < maxDepth-1) {\n        hit = hitStack[depth];\n        if (!hit.isHit) break;\n        if (dot(hit.material.specular, hit.material.specular) <= 0.) break;\n        \n        vec3 p = hit.ray.origin + hit.ray.direction * hit.dist;\n        vec3 N = hit.normal;\n        vec3 E = normalize(- hit.ray.direction);\n        \n        Ray ray;\n        ray.direction = 2. * dot(N, E) * N - E;\n        ray.origin = p + ray.direction * EPS;\n        HitInfo h = castRay(ray);\n        hitStack[depth+1] = h;\n        \n        depth++;\n    }\n    \n    depth++;\n    \n    vec3 lastColor = vec3(0.);\n    while (depth > 0) {\n        depth--;\n    \t\n        hit = hitStack[depth];\n        if (!hit.isHit) {\n            lastColor = vec3(0.);\n            continue;\n        }\n\n        vec3 p = hit.ray.origin + hit.ray.direction * hit.dist;\n        vec3 N = hit.normal;\n        vec3 E = normalize(- hit.ray.direction);\n\n        // reflection\n        vec3 color = lastColor * hit.material.specular;\n\n        // ambient\n        color += ambientLight * hit.material.ambient + hit.material.emission;\n        for (int i=0; i<numLights; i++) {\n            Light l = lights[i];\n\n            float dist = distance(l.position, p);\n            \n            vec3 L;\n            if (l.directional) L = normalize(l.position);\n            else L = normalize(l.position - p);\n            \n            vec3 H = normalize(E + L);\n\n            // attenuation\n            float attenuation;\n            if (l.directional) attenuation = 1.;\n            else attenuation = l.attenuation_quadratic * dist * dist +\n                                l.attenuation_linear * dist +\n                                l.attenuation_constant;\n\n            // shadow\n            Ray ray;\n            ray.direction = L;\n            ray.origin = p + ray.direction * EPS;\n            HitInfo h = castRay(ray);\n\n            if (!h.isHit || h.dist > dist) { // if there's no other object obstructing\n\n                // diffuse\n                color += l.color / attenuation * hit.material.diffuse * max(dot(N, L), 0.);\n\n                // specular\n                color += l.color / attenuation * hit.material.specular * pow(max(dot(N, H), 0.), hit.material.shininess);\n\n            }\n        }\n        \n        lastColor = color;\n    }\n    \n    return lastColor;\n}\n\nvec3 getImage( vec2 coord ) {\n    // setup camera\n    float camera_distance = 6.;\n    camera_position = vec3(-sin(mouse.x * PI) * camera_distance, mouse.y * camera_distance, -cos(mouse.x * PI) * camera_distance);\n    camera_target = vec3(0., 0., 0.);\n    camera_up = vec3(0., 1., 0.);\n    fovy = 50.; // in degrees\n    \n    // setup lighting\n    ambientLight = vec3(0., 0., 0.1);\n    \n    Light pl1;\n    pl1.directional = false;\n    pl1.position = vec3(4. * cos(3.*iTime), 4. * sin(3.*iTime), 2.);\n    pl1.color = vec3(0.5);\n    pl1.attenuation_quadratic = 0.1;\n    addLight(pl1);\n    \n    Light pl2;\n    pl2.directional = false;\n    pl2.position = vec3(3. * cos(2.*iTime), 0., 3. * sin(2.*iTime));\n    pl2.color = vec3(0.7, 0.3, 0.5);\n    pl2.attenuation_linear = 0.3;\n    addLight(pl2);\n    \n    Light dl1;\n    dl1.directional = true;\n    dl1.position = vec3(3., 3., 3.);\n    dl1.color = vec3(0.7);\n    addLight(dl1);\n    \n    Light dl2;\n    dl2.directional = true;\n    dl2.position = vec3(-3., -3., -3.);\n    dl2.color = vec3(0.7, 0.3, 0.);\n    addLight(dl2);\n    \n    // make camera coordinate\n    vec3 w = normalize( camera_position - camera_target );\n    vec3 u = normalize(cross( camera_up, w ));\n    vec3 v = normalize(cross( w, u ));\n    mat3 giri = mat3(u, v, w);\n    \n    float hasil_tan = tan(radians(fovy / 2.));\n    vec3 ali;\n    ali.y = hasil_tan * coord.y;\n    ali.x = aspect * hasil_tan * coord.x;\n    ali.z = -1.;\n    \n    Ray ray;\n    ray.origin = camera_position;\n    ray.direction = giri * ali;\n    \n    HitInfo hit = selectHit(castRay(ray), castRayToLight(ray));\n    \n    return getColor(hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    aspect = iResolution.x / iResolution.y;\n    \n    mouse = iMouse.xy/iResolution.xy;\n    mouse -= 0.5;\n    mouse *= 2.;\n    \n    //fragColor = vec4(fract(uv), 1., 1.);\n    fragColor = vec4(getImage(uv), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[747, 747, 777, 777, 827], [829, 829, 874, 1054, 1989], [1991, 1991, 2034, 2034, 2146], [2148, 2148, 2176, 2176, 2686], [2688, 2688, 2723, 2723, 3007], [3009, 3009, 3039, 3039, 5437], [5439, 5439, 5468, 5488, 7056], [7058, 7058, 7115, 7115, 7396]]}
{"id": "XdyBWh", "name": "Color changing color grid", "author": "mitjaprelovsek", "description": "Grid of changing colors.", "tags": ["grid", "color", "change"], "likes": 1, "viewed": 290, "date": "1528464816", "time_retrieved": "2024-06-20T19:15:54.018250", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Inputs\n    float gridRows=5.0;\n    float gridCols=5.0;\n    float satFactor=0.5;\n    float movingSpeed=1.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //We find out in which grid the pixel is\n    int pixCol=int(uv.x*gridCols);\n    int pixRow=int(uv.y*gridRows);\n   \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = satFactor + satFactor*cos(iTime*movingSpeed+vec3(pixCol,pixRow,pixCol)+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 70, 642]]}
{"id": "XdyfRd", "name": "bo test", "author": "cnwander", "description": "light", "tags": ["light"], "likes": 0, "viewed": 59, "date": "1529923916", "time_retrieved": "2024-06-20T19:15:54.018250", "image_code": "float band(float t, float start, float end, float blur){\n\tfloat step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n    float mask = band(uv.x, left, right, blur);\n    mask *= band(uv.y, bottom, top, blur);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.x += sin(iTime);\n    uv.y += cos(iTime) * 0.6;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float m = -(x - 0.5) * (x + 0.5);\n    y = uv.y + m * cos(iTime);\n    \n    float blur = 2. * sin(x)* sin(x);\n    \n    float mask = rect(vec2(x, y), -1.0, 1.0, -0.1, 0.1, blur);\n\n    vec3 color = vec3(0.8, 0.8, 1.) * mask; \n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 56, 56, 195], [197, 197, 280, 280, 390], [392, 392, 449, 449, 919]]}
{"id": "XdyfRK", "name": "Mandelbrot Twist", "author": "pedrolb", "description": "It is not finished. It is more like something that will never be finished. Haha! Just making some tests with this shader using Mandelbrot.", "tags": ["notags"], "likes": 1, "viewed": 341, "date": "1529725349", "time_retrieved": "2024-06-20T19:15:54.024055", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 0.1 * (fragCoord - iResolution.xy / 2.0) / iResolution.xy;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n    uv += vec2(-0.01, 0.0);\n    \n    float iterations = 0.0;\n    float iterations_g = 0.0;\n    float iterations_b = 0.0;\n    \n    float max_iterations = 100.;\n    vec2 z = vec2(0.0, 0.0);\n    \n    // Twist Matrix\n    mat2x2 twist_mat = mat2x2(\n        vec2(cos(10.0 * length(uv * 4.0) * length(uv * 4.0)), - sin(10.0 * length(uv * 4.0) * length(uv * 4.0))),\n        vec2(sin(10.0 * length(uv * 4.0) * length(uv * 4.0)), cos(10.0 * length(uv) * length(uv * 4.0)))\n    );\n    \n    // Rot Matrix\n    mat2x2 rot_mat = mat2x2(\n        vec2(cos(iTime), - sin(iTime)),\n        vec2(sin(iTime), cos(iTime))\n    );\n    \n    // for red and blue\n    for(float i = 0.0; i < max_iterations; i++)\n    {        \n        z = i * twist_mat * inverse(rot_mat) * vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) +  uv;\n        \n        if(length(z) > 2.0)\n            break;            \n        \n        \n        iterations += 1.0;\n    }\n    \n    // for green\n    for(float i = 0.0; i < max_iterations; i++)\n    {        \n        z = i * twist_mat * inverse(rot_mat) * inverse(rot_mat) * vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) +  uv;\n        \n        if(length(z) > 2.0)\n            break;            \n        \n        \n        iterations_g += 1.0;\n    }\n    \n    // for blue\n    for(float i = 0.0; i < max_iterations; i++)\n    {        \n        z = i * twist_mat * inverse(rot_mat) * inverse(rot_mat) * inverse(rot_mat) * vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) +  uv;\n        \n        if(length(z) > 2.0)\n            break;            \n        \n        \n        iterations_b += 1.0;\n    }\n    \n    vec3 col = vec3(iterations / max_iterations, iterations_g / max_iterations, iterations_b / max_iterations);\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1945]]}
{"id": "Xdyfzc", "name": "noisy pattern textures", "author": "lomateron", "description": "comment last line to see more", "tags": ["noise", "patterns", "textures"], "likes": 7, "viewed": 453, "date": "1529699451", "time_retrieved": "2024-06-20T19:15:54.024316", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = fragCoord.xy * .03;\n    \n    u += sin(u.yx*69.)*(cos(iTime+3.14159265359)+1.);\n    \n    vec2 fl = floor(u);\n    float l = fract(sin(dot(fl,vec2(1.,1.123)))*1111.);\n    \n    u = fract(u)*2.-1.;\n    \n    vec4 c = vec4(\n        fract(sin(dot(fl,vec2(1.123,1.234)))*1111.),\n        fract(sin(dot(fl,vec2(1.345,1.456)))*1112.),\n        fract(sin(dot(fl,vec2(1.567,1.678)))*1113.),\n        1.);\n \n\tfragColor = sqrt(c*(dot(u,u)-l));\n    fragColor = sqrt(c*(l-dot(u,u)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdyfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 533]]}
{"id": "XllyW4", "name": "raymarching tutorial", "author": "flimshaw", "description": "based on https://www.youtube.com/watch?v=yxNnRSefK94", "tags": ["raymarch"], "likes": 2, "viewed": 115, "date": "1528079116", "time_retrieved": "2024-06-20T19:15:54.024316", "image_code": "\n#define STEPS 64\n\nfloat map(vec3 p, float r, float dist) {\n    vec3 pos = p + vec3(0., 0.,0.);\n    p = fract(pos) * 2.0 - 1.0;\n    return length(p) - r;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    int i = 1;\n    for(i = 1; i < STEPS; ++i) {\n       vec3 p = o + r * t;\n       float dist = length(p);\n       float d = map(p, .5, dist);\n       t += d * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0., 0., -iTime);\n    \n    float d = trace(o, r);\n    \n    vec3 c = 1.0 / vec3(1.0 + d * d * .3);\n    \n    fragColor = vec4(1.0 - c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllyW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 19, 59, 59, 155], [157, 157, 186, 186, 388], [390, 390, 447, 447, 779]]}
{"id": "XsGfRt", "name": "李明杰V3", "author": "leneer", "description": "circle", "tags": ["circle"], "likes": 2, "viewed": 188, "date": "1529897887", "time_retrieved": "2024-06-20T19:15:54.024316", "image_code": "#define TAU 6.28318530718\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat hash(vec2 uv) {\n    float f = fract(cos(sin(dot(uv, vec2(.009123898, .00231233))) * 48.512353) * 1111.5452313);\n    return f;\n}\n\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        f += noise((uv += .25) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\nvec4 blend(vec4 c1, vec4 c2)\n{\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), max(c1.a, c2.a)); \n}\n\nfloat mask(vec2 uv) {\n    uv *= .9 - fbm(-uv * 2. + vec2(0, -iTime)) * (texture(iChannel0, vec2(.25, .25)).x) * .5;\n    return length(uv) - .56;\n}\n\nvec4 spiral(vec2 uv) {\n    if (mask(uv) > 0.) return vec4(0);\n    float angel = atan(uv.x, uv.y) / TAU + .5 - iTime / 5. - texture(iChannel0, vec2(.1, .25)).x * .1;\n    angel -= (uv.y + uv.x) / 20.;\n    float dist = length(uv);\n    float _smooth = dist * 15.;\n    float alpha = saturate(sin(angel * 17. * TAU + sin(dist * 6. + 2.) * 2.) * _smooth);\n    float base = .64 - texture(iChannel0, vec2(.9, .25)).x / 5.;\n    float scratch = smoothstep(base, base + .01, fbm((uv - vec2(0, -iTime * .2)) * vec2(30., 2.)));\n    alpha = saturate(alpha - scratch);\n    alpha = saturate(alpha - smoothstep(-.1, .0, -dist));\n    vec3 color = vec3(.2, .5, .0) + noise(uv * 4.) * .3;\n\treturn vec4(color, alpha);\n}\n\nvec4 circle(vec2 uv) {\n    float width = .05;\n    float m = mask(uv);\n    float alpha = smoothstep(-width, -width + .005, m)* smoothstep(-width - .005, -width, -m);\n    vec3 color = vec3(.0, .5, .0) + (noise(uv * 03.) - .65) * .1;\n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\tfragColor = blend(vec4(.0, .0, .0, 0.), spiral(uv));\n    fragColor = blend(fragColor, circle(uv));\n    uv *= 1000.;\n    float amount = .1;\n    fragColor.r += (hash(uv) - .5) * amount;\n    uv += 100.;\n    fragColor.g += (hash(uv) - .5) * amount;\n    uv += 100.;\n    fragColor.b += (hash(uv) - .5) * amount;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsGfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[64, 64, 85, 85, 197], [199, 199, 221, 221, 502], [504, 504, 524, 524, 681], [683, 683, 713, 713, 777], [779, 779, 800, 800, 925], [927, 927, 949, 949, 1624], [1626, 1626, 1648, 1648, 1889], [1891, 1891, 1948, 1948, 2352]]}
{"id": "XsGfW1", "name": "Raymarching - YYYY", "author": "minujeong", "description": "Simple sketch trying to get used to raymarching.", "tags": ["raymarching"], "likes": 7, "viewed": 344, "date": "1528509686", "time_retrieved": "2024-06-20T19:15:54.891180", "image_code": "#define FAR     80.0\n#define NRM_OFS 0.001\n\nfloat sphere(vec3 p, float radius)\n{\n  return length(p) - radius;\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n\treturn length(box(p, b)) - r;\n}\n\nfloat blend(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nfloat world(vec3 p)\n{\n    float a = mod(iTime * 1.25, 3.141592 * 2.0);\n    mat3 rx = mat3(\n        cos(a), 0, sin(a),\n        0, 1, 0,\n        -sin(a), 0, cos(a)\n    );\n    p = rx * p;\n    \n    float bax = 0.06;\n    float baz = 0.13;\n    mat3 bodyrmat = mat3(\n        1, 0, 0,\n        0, cos(bax), -sin(bax),\n        0, sin(bax), cos(bax)\n    ) * mat3(\n        cos(baz), -sin(baz), 0,\n        sin(baz), cos(baz), 0,\n        0, 0, 1\n    );\n\n    \n    float chest = blend(\n        sphere(p + vec3(0.05, 0.12, 0.14), 0.06),\n        sphere(p + vec3(-0.25, 0.12, 0.14), 0.06),\n        0.1\n    );\n    \n    float heap = blend(\n        sphere(p + vec3(0.08, 0.72, -0.24), 0.13),\n        sphere(p + vec3(-0.08, 0.78, -0.24), 0.13),\n        0.05\n    );\n    \n    float arms = min(\n        blend(\n        \tcapsule(p, vec3(0.33, 0.18, 0.12), vec3(0.56, -0.22, 0.16), 0.13),\n            capsule(p, vec3(0.56, -0.24, 0.16), vec3(0.32, -0.65, -0.12), 0.13),\n            0.02\n        ),\n        min(\n            blend(\n                capsule(p, vec3(-0.29, 0.15, -0.04), vec3(-0.45, -0.05, -0.4), 0.13),\n                capsule(p, vec3(-0.45, -0.05, -0.4), vec3(-0.32, 0.45, -0.37), 0.13),\n                0.02\n            ),\n            capsule(\n                p,\n                vec3(-0.32, 0.52, -0.37),\n                vec3(-0.44, 0.72, -0.25),\n                0.12\n            )\n        )\n    );\n    \n    float legs = min(\n        blend(\n            capsule(p, vec3(0.26, -0.82, 0.14), vec3(0.15, -1.52, -0.08), 0.19),\n            capsule(p, vec3(0.15, -1.57, -0.08), vec3(0.17, -2.2, -0.12), 0.18),\n            0.05\n        ),\n        blend(\n            capsule(p, vec3(-0.26, -0.82, 0.14), vec3(-0.16, -1.35, -0.08), 0.19),\n            capsule(p, vec3(-0.16, -1.40, -0.08), vec3(-0.14, -2.2, 0.16), 0.18),\n            0.05\n        )\n    );\n    float pelvis = sphere(p + vec3(-0.04, 0.65, -0.07), 0.16);\n    legs = blend(legs, blend(heap, pelvis, 0.5), 0.2);\n    \n    float body = blend(\n        rbox(\n            bodyrmat * (p + vec3(-0.05, 0.22, -0.05)),\n            vec3(0.16, 0.42, 0.07),\n            0.09),\n        chest,\n        0.4\n    );\n    float head = blend(\n        sphere(p + vec3(-0.05, -0.87, 0.06), 0.35),\n        sphere(p + vec3(0.05, -0.65, 0.18), 0.06),\n        0.4\n    );\n    float torso = blend(body, head, 0.15);\n    float statue = blend(torso, legs, 0.1);\n\treturn blend(statue, arms, 0.06);\n}\n\nfloat raymarch(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    vec3 p = vec3(0, 0, 0);\n    float d = 0.0;\n    float ad = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        p = o + r * t;\n        d = world(p);\n        ad = abs(d);\n        if (ad < 0.01)\n        {\n            return t;\n        }\n        t += d;\n    }\n    \n    return FAR;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NRM_OFS, 0);\n    float d1 = world(p + e.xyy), d2 = world(p - e.xyy);\n    float d3 = world(p + e.yxy), d4 = world(p - e.yxy);\n    float d5 = world(p + e.yyx), d6 = world(p - e.yyx);\n    \n    return normalize(vec3(\n        d1 - d2,\n        d3 - d4,\n        d5 - d6\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 o = vec3(0.0, -0.5, -5.7);\n    vec3 r = normalize(vec3(uv, 1.15));\n    vec3 l = normalize(vec3(0, -5, 5));\n    vec3 h = vec3(r + l) * 0.5;\n    \n    float d = raymarch(o, r);\n    if (d < FAR)\n    {\n        vec3 n = normal(o + r * d);\n        float ndl = 1.0 - clamp(dot(n, l), -1.0, 0.0);\n        float ndh = - clamp(dot(n, h), -1.0, 0.0);\n        \n        vec3 color = mix(\n            vec3(0.02, 0.01, 0.03),\n            vec3(0.75, 0.5, 0.7),\n            ndl\n        );\n        color += pow(ndh, 52.0) * normalize(vec3(2, 1, 10)) * 10.0;\n        fragColor = vec4(mix(color, n, 0.3), 1.0);\n    }\n    else\n    {\n    \tfragColor = vec4(0.3, 0.3, 0.5, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsGfW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[44, 44, 80, 80, 111], [113, 113, 161, 161, 288], [290, 290, 317, 317, 360], [362, 362, 399, 399, 432], [434, 434, 474, 474, 577], [579, 579, 600, 600, 2984], [2986, 2986, 3018, 3018, 3320], [3322, 3322, 3343, 3343, 3634], [3636, 3636, 3693, 3693, 4430]]}
{"id": "XsGfWh", "name": "Travelling gradient", "author": "mitjaprelovsek", "description": "Simple travelling BW gradient", "tags": ["gradient", "travelling"], "likes": 0, "viewed": 111, "date": "1528468848", "time_retrieved": "2024-06-20T19:15:55.054659", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Inputs\n    float brightness=0.5;\n    float movingSpeed=10.0;\n    float waveSize=10.0;\n    float angle = 0.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n \n    // Time varying pixel color\n    vec3 col = brightness + brightness*cos(iTime*movingSpeed+vec3(uv.y,uv.y,uv.y)*waveSize*angle+vec3(uv.x,uv.x,uv.x)*waveSize*(1.0-angle));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsGfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 70, 515]]}
{"id": "XsKBDG", "name": "Pinch Bow", "author": "vjyourself", "description": "Pinch a rainbow ( use ur mouse )", "tags": ["rainbow", "pinch"], "likes": 3, "viewed": 186, "date": "1530263172", "time_retrieved": "2024-06-20T19:15:55.357731", "image_code": "float ds(in float st, in float l0, in float l2){\n  float l1 = (l0+l2)*0.5;\n  return  smoothstep( l0, l1, st ) - smoothstep( l1, l2, st );\n}\n\nvec2 transUV(in vec2 uv, in vec2 ani){\n    vec2 uvt = uv;\n    uvt.x+=sin(uvt.x*26.0+ani.x)*0.02;\n    uvt.y+=sin(uvt.y*22.0+ani.y)*0.02;\n    return uvt;\n}\nvec2 transUV2(in vec2 uv, in vec2 uv2, in float val){\n    vec2 uvt = uv;\n    vec2 dir = normalize(uv - uv2);\n    uvt+=dir*max(0.0,1.0-distance(uv,uv2))*val;\n    //uvt.x+=sin(uvt.x*26.0+ani.x)*0.02;\n    //uvt.y+=sin(uvt.y*22.0+ani.y)*0.02;\n    return uvt;\n}\nvoid test(in vec2 fragCoord){\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvM = iMouse.xy / iResolution.xy;\n    \n    // Time varying gradient\n    vec3 col = 0.5 + 0.5*cos(uv.xyx*4.0+vec3(0,2,4));\n\t//col = fract((uv.x+uv.y)*100.0) < 0.5 ? vec3(1.0,1.0,1.0) : vec3(0.0,0.0,0.0);\n    \n    // Grid\n    //vec2 uvt = transUV(uv,vec2(iTime*0.6));\n    vec2 uvt = transUV2(uv,uvM,0.1+(sin(iTime*3.0)*0.5+0.5)*0.3);\n    \n  \n   \tfloat zebra1 = ds(fract((1.0-uvt.x+uvt.y)*20.0),0.0,0.8);\n    float zebra2 = ds(fract((uvt.x+uvt.y)*20.0),0.0,0.8);\n    float zebra = clamp(zebra1+zebra2,0.0,1.0);\n    //vec3 colZebra = vec3(zebra2);\n    \n    float countX=20.0;\n    float countY=12.0;\n    float width = 0.1;\n    float frakX =fract(uvt.x*countX);\n    float frakY =fract(uvt.y*countY);\n    float gridX = ds(frakX,0.0,width);\n    float gridY = ds(frakY,0.0,width);\n    \n    vec3 finalCol = col*zebra;// + vec3(gridX*0.3)+ vec3(gridY*0.6);\n    \n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 48, 48, 139], [141, 141, 179, 179, 294], [295, 295, 348, 348, 551], [552, 552, 581, 581, 587], [588, 588, 645, 700, 1659]]}
{"id": "XsKBRt", "name": "tree wave", "author": "laserdog", "description": "had some trouble coming up with ideas today...", "tags": ["simple"], "likes": 3, "viewed": 155, "date": "1530160913", "time_retrieved": "2024-06-20T19:15:55.357731", "image_code": "#define tau 6.2831\n\nconst float cellCount = 9.;\n\n\nfloat polygon(vec2 p, float vertices, float size) \n{\n    float a = atan(p.x, p.y);\n    float b = tau / vertices;\n    return cos(round(a / b) * b - a) * length(p) - size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float cellSize = 2. / cellCount;\n    vec2 s = sign(uv);\n    vec2 node = floor(abs(uv) / cellSize) * s * cellSize + cellSize * .5 * s;\n    uv = node - uv;\n\n    fragColor.rgb = vec3(0.);\n    float val = sin(-iTime  * 3. + node.y * 2.);\n    \n    uv.y /= ((val + 1.) / 2. + 1.) / 1.5;\n    float colorAmount = smoothstep(.01, 0., polygon(uv, 5. - val * 2., .035));\n    vec3 color = mix(vec3(0.7, .0, 0.3), vec3(0., 0.7, .4), (val + 1.) / 2.);\n    fragColor.rgb = mix(vec3(.4, .2, .7) * .2, color, colorAmount);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[50, 50, 102, 102, 221], [223, 223, 280, 280, 857]]}
{"id": "XsKBRw", "name": "Everything will be fine", "author": "Gaktan", "description": "Got this thing by accident while trying to combine two shaders that totally cannot work together. Result is much better than excpeted.\n\nI'll just leave this here", "tags": ["2d", "kaleidoscope", "trippy", "mirror", "rotation", "symmetry", "void"], "likes": 9, "viewed": 297, "date": "1528059862", "time_retrieved": "2024-06-20T19:15:55.957765", "image_code": "// Fun to experiment with exposed parameters\n// Better to watch while listening to music\n\n#define KALEIDOSCOPE_SPEED_X    9.0*0.01\n#define KALEIDOSCOPE_SPEED_Y  -20.0*0.001\n#define KALEIDOSCOPE_SPLITS     25.0\n\n#define PI 3.14159265359\n\nvec2 kaleidoscope(vec2 uv, vec2 offset, float splits)\n{\n    // XY coord to angle\n    float angle = atan(uv.y, uv.x);\n    // Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    // Rotate by 90°\n    angle = angle + 0.25 * iTime * 0.05;\n    // Split angle \n    angle = mod(angle, 1.0 / splits) * splits;\n    \n    // Warp angle\n    angle = -abs(2.0*angle - 1.0) + 1.0;\n    \n    angle = angle*0.1;\n    \n    // y is just dist from center\n    float y = length(uv);\n    \n    angle = angle * (y*3.0);\n    \n    return vec2(angle, y) + offset;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  // Íñigo Quílez\n  // https://www.shadertoy.com/view/MsS3Wc\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n#define RAYS 20.0\n#define ROTATION_SPEED \t\t\t0.05\n#define SPINNING_SPEED \t\t\t0.1\n#define COLOR_SHIFTING_SPEED \t0.5\n\n// Here's where the accident comes into place\n// Abomination that makes no sense if we already have polar coordinates\n// But hey, it gives pretty results\nvec3 radialThing(vec2 uv)\n{\n    vec2 center = vec2(0.0, 0.5) * sin(iTime*0.1);\n    \n    float c = distance(uv, center);\n    \n    vec3 res = vec3(0.0, 0.0, 0.0);\n\n    vec2 pos = (uv - center);\n\n    // Cartesian to polar coordinates\n    float t = atan(pos.y, pos.x);\n    float t2 = (t + PI) / (PI*2.0);\n\n    // Spin with distance\n    t2 += c * sin(iTime * SPINNING_SPEED) * 0.5;\n\n    // Rotation\n    t2 = mod(t2 + (iTime * ROTATION_SPEED), 1.0);\n\n    // Rays\n    float angle = mod(t2, 1.0 / RAYS);\n    angle = ceil(angle * 2.0 * RAYS);\n\n    float colorShiftingSpeed = iTime * COLOR_SHIFTING_SPEED;\n\n    // Yuck\n    vec3 color1 = hsv2rgb(vec3((cos(colorShiftingSpeed + c * 0.2 + (t2*PI*2.0)) + 1.0), 0.8, 1.0));\n    vec3 color2 = hsv2rgb(vec3((cos((colorShiftingSpeed + 1.32) + c * 0.2 + (t2*PI*2.0)) + 1.0), 0.8, 1.0));\n    vec3 color = mix(color2, color1, angle);\n\n    res = color;\n\n#if 1\n    res.rgb = res.rgb * (1.0 - c);\n    res.rgb = res.rgb * smoothstep(-1.5, 1.0, c*10.0);\n#endif\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mobile friendly UVs\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime;\n    \n    // Start with a good color\n    time += 1207.0;\n    \n    vec2 A = vec2(time * KALEIDOSCOPE_SPEED_X * 0.005, \n                  time * KALEIDOSCOPE_SPEED_Y * 0.005);\n    \n\tuv = kaleidoscope(uv, A, KALEIDOSCOPE_SPLITS);\n\n\tfragColor.rgb = radialThing(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 237, 292, 317, 788], [790, 790, 812, 876, 1023], [1139, 1293, 1320, 1320, 2300], [2302, 2302, 2359, 2386, 2773]]}
{"id": "XsKBWD", "name": "Flat Heart Beat", "author": "AlphaRogue", "description": "Simple 2D flat beating heart.", "tags": ["2d", "heart"], "likes": 5, "viewed": 197, "date": "1528905658", "time_retrieved": "2024-06-20T19:15:55.957765", "image_code": "#define PI 2.356194\n#define RADIUS .05\n#define SIZE .0609\n#define RED vec4(.6, .09, .08, 1.)\n#define GREEN vec4(.71, .79, .73, 1.)\n#define BLUE vec4(.11, .15, .2, 1.)\n#define WHITE vec4(1., .98, .9, 1.)\n#define GAP .015\n\nvec4 aalias(float radius, float dist, vec4 bg, vec4 color, float ratio){\n    return mix(bg, color, smoothstep(radius, radius * ratio, dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 lM = vec2(max(iResolution.x, iResolution.y), min(iResolution.x, iResolution.y));\n    vec2 pos = (fragCoord -.5 * lM) / lM.x;\n    \n    pos.y += GAP;\n    \n    float dist = length(pos - vec2(0., GAP));\n\n    if (dist < SIZE * 3.8) fragColor = aalias(SIZE * 3.8, dist, BLUE, WHITE, .99);\n    else {\n        if (dist < SIZE * 4.15) fragColor = aalias(SIZE * 4.15, dist, GREEN, BLUE, .99);\n        else {\n            fragColor = GREEN;\n            return;\n        }\n    }\n    \n    pos *= .7 + abs(-abs(sin(iTime * 3.)) + .5);\n    \n    if (abs(pos.x) < SIZE / 2. && abs(pos.y) < SIZE / 2.) fragColor = RED; // Heart center\n    else if (pos.y < RADIUS * .2 - GAP) { // Bottom heart\n        float f = abs(pos.x) - .0855;\n        if (pos.y > f) fragColor = mix(WHITE, RED, smoothstep(f, f + .002, pos.y));\n    }\n    else {\n        float dist = length(vec2(abs(pos.x), pos.y + GAP) - vec2(.043));\n        if (dist < RADIUS) fragColor = aalias(RADIUS, dist, WHITE, RED, .97); // Top heart\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[221, 221, 293, 293, 364], [366, 366, 421, 421, 1414]]}
{"id": "XsKfWh", "name": "Fuzzy Sets: Mandelbrot", "author": "ptrgags", "description": "Mixing fractals and fuzzy logic.", "tags": ["fuzzylogic"], "likes": 2, "viewed": 90, "date": "1528638990", "time_retrieved": "2024-06-20T19:15:57.060917", "image_code": "#define CENTER (iResolution.xy / 2.0)\n#define MAX_ITER 1024\n#define MAX_DIST 1024.0\n#define MIN_ZOOM 0.1\n#define MAX_ZOOM 0.00001\n\n// Spiral in the seahorse valley of the mandelbrot set.\n#define POINT_OF_INTEREST vec2(-0.76158, -0.0847616)\n\n// Fuzzy logic operations\n#define NOT(x) (1.0 - (x))\n#define AND min\n#define OR max\n\n// Constants for this mandelbrot set coloring\n#define HUE_FREQ 100.0\n#define NEAR_POINT 0.0001\n#define FAR_POINT 0.01\n#define WIDTH 0.005\n#define ZOOM_SPEED 0.1\n\n// Complex multiplication\nvec2 cmult(vec2 z1, vec2 z2) {\n    float real = z1.x * z2.x - z1.y * z2.y;\n    float imag = z1.x * z2.y + z1.y * z2.x;\n    return vec2(real, imag);\n}\n\n// Square a complex number.\nvec2 csqr(vec2 z) {\n    return cmult(z, z);\n}\n\n// Compute the length squared of a vector.\nfloat length_squared(vec2 x) {\n    return dot(x, x);\n}\n\n\n/**\n * This distance estimator is based on the\n * code from Inigo Quilez's article here:\n * http://iquilezles.org/www/articles/distancefractals/distancefractals.htm\n */\nfloat mandelbrot_dist(vec2 c) {\n    vec2 z = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    \n    float dist_mask = 1.0;\n    float dist_squared = 0.0;\n    for (int i = 0; i < MAX_ITER; i++) {\n        // Compute the next derivative of the mandelbrot set sequence.\n        // dz = 2 * z * dz + 1\n        dz = 2.0 * cmult(z, dz) + vec2(1.0, 0.0);\n        \n        // Compute the next z value in the mandelbrot set sequence\n        // z = z^2 + c\n        z = csqr(z) + c;\n        \n        dist_squared = length_squared(z);\n        \n        if (dist_squared > MAX_DIST) {\n            dist_mask = 0.0;\n            break;\n        }\n    }\n    \n    // Distance estimator as described in the algorithm.\n    // d(c) = |z| * log|z| / |dz|\n    float d = sqrt(dist_squared / length_squared(dz)) * 0.5 * log(dist_squared);\n    return d;// * dist_mask;\n}\n\n// Compute a fuzzy set for distance to a point.\n// I use sigmoid-shaped boundaries with smoothstep()\n// x is the input point\n// center is the center of the distance field\n// near, far are the center of the sigmoid-like curves that divide the sets.\n// width is the width of the sigmoid-like curves\nvec3 fuzzy_dist(float dist, float near_point, float far_point, float width) {\n    float half_width = width / 2.0;\n    \n    // Make the sigmoid shapes for near and far using smoothstep()\n    float near = smoothstep(near_point + half_width, near_point - half_width, dist);\n    float far = smoothstep(far_point - half_width, far_point + half_width, dist);\n    \n    // We are at a medium distance if we are not near and not far.\n    float mid = AND(NOT(near), NOT(far));\n    \n    // Return the membership for the three categories.\n    return vec3(near, mid, far);\n}\n\n// Define where the pure values of RGB are\n// on the HSV color wheel. Convert the angle to\n// a value between 0 and 1.\n#define GREEN (120.0 / 360.0)\n#define BLUE (240.0 / 360.0)\n// Red is both at 0 degrees and 360 degrees.\n#define RED1 (0.0 / 360.0)\n#define RED2 (360.0 / 360.0)\n\n// Size of a sector \n#define SECTOR (1.0 / 6.0)\n// Slope of the trapezoid boundary\n// (rise = 1, run = 1/6)\n#define SLOPE (1.0 / SECTOR)\n\n// Calculate the trapezoidal fuzzy membership function\n// one of R, G, B, given a hue from 0.0 to 1.0.\n// For example, hue_trapezoid(hue, GREEN)\n// computes how \"green\" the hue is.\nfloat hue_trapezoid(float h, float center) {\n    // This makes an upside down V shape\n    // with maximum at 2. It's scaled\n    // to match the values in the diagram (see the link above)\n    // 2          /\\\n    //           /  \\\n    // 1        /    \\\n    //         /      \\\n    //        /        \\\n    // 0     /          \\\n    //      /      | center\n    //     /              \\\n    // -1 /                \\ \n    float triangle = 2.0 - SLOPE * abs(h - center);\n    \n    // Clamp it between 0.0 and 1.0 to turn it into \n    // a trapezoid\n    //           ____\n    // 1        /    \\ <- the top spans 120 degrees. (2/6)\n    //         /      \\\n    //        /        \\\n    // 0     /__________\\ <- the base spans 240 degrees (4/6)\n    //             | center\n    return clamp(triangle, 0.0, 1.0);\n}\n\n// Convert a hue value to an RGB vector\n// with full saturation. This asssumes\n// hue is in the range 0.0 to 1.0.\nvec3 fuzzy_hue(float hue) {\n    // Compute membership in \"green\" and \"blue\"\n    float green = hue_trapezoid(hue, GREEN);\n    float blue = hue_trapezoid(hue, BLUE);\n    \n    // Red has to be handled differently since\n    // it is both at 0 and 360 degrees. Compute\n    // two half-trapezoids and union them together.\n    float red1 = hue_trapezoid(hue, RED1);\n    float red2 = hue_trapezoid(hue, RED2);\n    float red = OR(red1, red2);\n    \n    // Return the results for each fuzzy set.\n    return vec3(red, green, blue);\n}\n\n\n// Normalized sine function from [0 to 1] instead of [-1 to 1]\nfloat norm_sin(float x) {\n    return 0.5 + 0.5 * sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - CENTER)/iResolution.y;\n    \n    float zoom = mix(MIN_ZOOM, MAX_ZOOM, norm_sin(ZOOM_SPEED * iTime));\n    \n    vec2 c = POINT_OF_INTEREST + uv * zoom;\n    \n    float dist = mandelbrot_dist(c);\n    \n    // Determine if we are \"near\", \"medium\", \"far\" to the Mandelbrot set.\n    vec3 dist_set = fuzzy_dist(dist / zoom, NEAR_POINT, FAR_POINT, WIDTH);\n    \n    // Map the distance onto a hue.\n    float hue = fract(dist / zoom * HUE_FREQ);\n    // Determine the R, G, B fuzzy sets from the hue. This vector\n    // of membership functions can be used as a color\n    vec3 color = fuzzy_hue(hue);\n    \n    // Start with a black screen\n    vec3 image = vec3(0.0);\n    \n    // Fuzzy logic time!\n    // If distance is near the mandelbrot set, color it navy\n    vec3 navy = vec3(0.0, 0.0, 0.35);\n    image = mix(image, navy, dist_set.x);\n    // If distance is medium, paint the hue color\n    image = mix(image, color, dist_set.y);\n    // If distance is far, draw a background.\n    vec3 background = texture(iChannel0, uv).rgb;\n    image = mix(image, background, dist_set.z);\n    \n    //Note: it would be more correct to compost these layers from background\n    // to foreground. However, I'm happy with how this looks.\n    \n\n    // Output to screen\n    fragColor = vec4(image, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[488, 514, 544, 544, 663], [665, 693, 712, 712, 738], [740, 783, 813, 813, 837], [840, 1009, 1040, 1040, 1839], [1841, 2138, 2215, 2215, 2699], [3119, 3300, 3344, 3713, 4102], [4104, 4218, 4245, 4293, 4739], [4742, 4805, 4830, 4830, 4863], [4865, 4865, 4922, 4972, 6269]]}
{"id": "XsVBR3", "name": "spherical coordinates", "author": "JohanFlod", "description": "messing about with spherical coordinates. ", "tags": ["checkerboard"], "likes": 1, "viewed": 183, "date": "1529794780", "time_retrieved": "2024-06-20T19:15:57.388345", "image_code": "// \n\n#define TWO_PI 6.28318530718\n\nfloat getDistortion(float amplitude, float frequence) {\n\treturn amplitude*sin(frequence+iTime*0.5);\n}\nvec3 generateCheckerboard(vec2 screen_space, vec3 black, vec3 white)\n{\n    // make the chequered pattern smaller towards the center \n   \tfloat checksum = ceil(((screen_space.x)/(5.-screen_space.x))+iTime)+ceil((screen_space.y)+4.0*iTime);\n    \n    // odd or even checkerboard position\n    bool check = mod(checksum,2.0) == 0.0;\n\n    \n  \t\n    // set colour according to which board position we are on \n\tvec3 color = (check)? black:white;\n    color = vec3(color);\n    return color; \n}\nvec3 colorCheckerboard(vec3 color, vec2 st)\n{\n  \tcolor.r = 0.2*smoothstep(0.3, 4.6, st.y) ;\n    color.r += getDistortion(.1,st.y);\n\tcolor.g = 0.2*smoothstep(0.3, 4.6, st.x) ;\n    color.g += getDistortion(0.1,st.x);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    // scale up coordinate system for a 5*5 checkerboard\n    st*=5.0;\n    vec3 color = vec3(.0);\n    vec3 black = vec3(0.0);\n    vec3 white = vec3(1.0);\n\t\n\t\n    vec2 toCenter = vec2(2.5)-0.68*st;\n \tfloat angle = atan(toCenter.x, toCenter.y);\n    float radius = length(toCenter)*2.;\n    // to polar coordinates\n    \n    \n    st.x = radius+4.0;\n    st.y = angle*TWO_PI*1.5;\n    color = generateCheckerboard(st, black, white);\n    color = mix(color,black,1.-radius/10.);\n    color.r += getDistortion(0.2,0.2);\n    color = color-vec3(0.1);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 35, 90, 90, 136], [137, 137, 207, 269, 619], [620, 620, 665, 665, 854], [857, 857, 914, 969, 1585]]}
{"id": "XsVBW1", "name": "Dithering tutorial", "author": "Klems", "description": "Short exemple of dithering for a facebook question.", "tags": ["banding", "dither", "dithering"], "likes": 6, "viewed": 592, "date": "1528668242", "time_retrieved": "2024-06-20T19:15:57.630644", "image_code": "float hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// how many values per channels\n// this is 256 for most displays\nconst float SIZE = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // color to display, use floating point precision here\n    vec3 col = vec3(fragCoord/iResolution.xy, sin(iTime)*0.5+0.5);\n    \n    // get some noise\n    float noise = 0.0;\n    // you can use different noises\n    // best is to use the dither texture, or use white noise\n    noise = texture(iChannel0, fragCoord/8.0).r;\n    if (fragCoord.x<iResolution.x*0.5)\n    \tnoise = hash13(vec3(fragCoord, iFrame));\n    \n    \n    // to do dithering, simply add noise to your frame\n    // that's it\n    col += (noise-0.5)/SIZE*2.0;\n    \n    \n    // do quantization, this will simulate a lower color depth\n    // essentialy, go from a float to an int\n    col = (floor(col*SIZE)+0.5)/SIZE;\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 126], [128, 218, 275, 339, 995]]}
{"id": "XsVBWh", "name": "Catherine wheels fireworks", "author": "FabriceNeyret2", "description": "ugly fast try.\n\nref: [url]https://www.youtube.com/results?search_query=catherine+wheel+firework[/url]\n", "tags": ["fireworks", "short"], "likes": 6, "viewed": 719, "date": "1528625615", "time_retrieved": "2024-06-20T19:15:57.636786", "image_code": "//#define rnd(p) fract( sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 )\n  #define rnd(p) fract(sin(p * mat2(127.1,311.7,269.5,183.3) )*43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = (U+U-R)/R.y;\n    O -= O;\n    \n    float t = -iTime, v = 3., T = 5.,                    // rotation\n          a = t + length(U);\n          a = - cos( mod( a/T ,3.1415926) ) * T;\n    U *= mat2(cos( v*a + vec4(0,33,11,0)));\n    \n    if (U.x<0.) U = -U;                                  // quadrant symmetry\n    if (U.y>0.) U = vec2(U.y,-U.x);\n    \n    U.x -= .3;\n    U.x /= U.y/4.; // / (4.-3.*abs(a/T)); \n    if (U.y > 0. || abs(U.x)>1. ) return;                // jet cone\n    \n    U.y -= t;                                            // jet\n    O = ( 2. - length( fract(U)-rnd(floor(U*1e2)/1e2) ) / fwidth(U.x) )\n        * vec4(1,.8,.6,0);\n    //  ( 1.2 - .2*  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 153, 191, 191, 892]]}
{"id": "XsVBWw", "name": "Analytic Spline Distance", "author": "nr4", "description": "Distance to a quadratic spline by solving a cubic equation.\nAcknowledgement to LordVetinari for the discussion and proof-reading my derivation steps.", "tags": ["spline", "distance", "quadratic", "analytic"], "likes": 6, "viewed": 213, "date": "1529235011", "time_retrieved": "2024-06-20T19:15:57.644400", "image_code": "/*\n * Analytic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//changes: fixed clamping of t.\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nfloat dist(vec2 p_0,vec2 p_1,vec2 p_2,vec2 x,float t)\n{\n    return length(x-pow(1.-t,2.)*p_0-2.*(1.-t)*t*p_1-t*t*p_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n    //control points. Uncomment to make it move ;-)\n    vec2 p_0 = vec2(-.25,-.25)+.15*vec2(sin(iTime), cos(3.*iTime)), \n        p_1 = vec2(.25,-.25)+.5*vec2(sin(iTime), .5-sin(iTime)),\n        p_2 = vec2(.25,.25)+.15*vec2(cos(iTime), sin(iTime));\n\n\t//coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = uv-p_0, F = p_2-2.*p_1+p_0, G = p_1-p_0;\n    vec3 coeff = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n    float a = coeff.x, b = coeff.y, c = coeff.z;\n\n\t//discriminant and helpers\n    float p = b-a*a/3., q = 2.*a*a*a/27.-a*b/3.+c, dis = q*q/4.+p*p*p/27.,\n        tau = a/3.;\n    \n    //solution with cardan formula\n    float k1 = -.5*q+sqrt(dis), k2 = -.5*q-sqrt(dis);\n    float u = sign(k1)*pow(abs(k1), 1./3.), v = sign(k2)*pow(abs(k2), 1./3.);\n    \n    float t_min = 1.;\n    if(dis > 0.)\n    {\n        t_min = u+v-tau;\n        t_min = clamp(t_min, 0.,1.);\n    }\n    else if(dis < 0.)\n    {\n        float fac = sqrt(-4./3.*p), arg = -.5*q*sqrt(-27./p/p/p),\n            t1 = -fac*cos(acos(arg)/3.+pi/3.)-tau,\n            t2 = fac*cos(acos(arg)/3.)-tau,\n            t3 = -fac*cos(acos(arg)/3.-pi/3.)-tau;\n        t1 = clamp(t1,0.,1.);\n        t2 = clamp(t2,0.,1.);\n        t3 = clamp(t3,0.,1.);\n        float b1 = dist(p_0,p_1,p_2,uv,t1),\n            b2 = dist(p_0,p_1,p_2,uv,t2),\n            b3 = dist(p_0,p_1,p_2,uv,t3);\n        t_min = mix(mix(t1, t2, step(b2, b1)), t3, step(b3, min(b1, b2)));\n    } \n    float dis_min = dist(p_0,p_1,p_2,uv,t_min);\n\n    vec3 col = k.yyy;\n    //spline distance isolines\n    col += (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*mod(dis_min,0.1)*10.+vec3(1.,0.,0.)*step(dis_min,.05);\n    //control points\n    col += k.yxx*step(length(uv-p_0), .05)+k.xyx*step(length(uv-p_1), .05)+k.yxx*step(length(uv-p_2), .05);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[746, 836, 891, 891, 956], [958, 958, 1015, 1015, 2875]]}
{"id": "XsVBz3", "name": "loopless dots along circle", "author": "FabriceNeyret2", "description": "in a fragment shader, regular patterns can generally be done loopless: each pixel determine on which feature it lays (or not).\n(Note that if patterns can superimpose, then one has not only to consider the central feature but also its direct neighborhs) .", "tags": ["tuto", "short", "loopless"], "likes": 12, "viewed": 706, "date": "1529824793", "time_retrieved": "2024-06-20T19:15:57.644400", "image_code": "#define S(v,r)  smoothstep ( 3./R.y, 0., length(v)-r ) // antialiased draw\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) ) // from https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;                           // normalized coordinates\n    \n    float r = .5,                                    // circle radius\n          n = 1.+30.*(.5+.5*sin(iTime)),             // number of dots\n          l = length(U),                             // polar coordinates\n          a = atan(U.y,U.x),\n    \n     u = r * ( fract( a*n/6.283 ) - .5 ) / (n/6.283),// local coordinates in\n     v = l - r,                                      // cells along the circle\n     i = floor( a*n/6.283 );                         // dot number\n    \n    U = vec2(u,v);\n    O = S( U, .03 ) * hue(i/n);                      // draw blobs\n    \n    if (iMouse.z>0.) U = abs(U)-.1, O += S(max(U.x,U.y),.0); // click to see Bboxes\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[186, 186, 224, 224, 991]]}
{"id": "XsVfDz", "name": "Corrected geometric ratio", "author": "grinist", "description": "Couldn't come up with a better name. A visual verification I got this right. Smoothing using continuous weighted average / lerp. Mouse changes delta step. See comments for more info.", "tags": ["graph", "geometric", "smoothing", "weightedaverage"], "likes": 5, "viewed": 406, "date": "1528378027", "time_retrieved": "2024-06-20T19:15:58.242872", "image_code": "// Let's say you want to smooth a continuously changing value temporally using weighted average,\n// such as user input, camera target position etc., and you'd do something like:\n// currValue = lerp(currValue, targetValue, 0.3);\n// You are doing this every frame and you've found a nice lerp factor for your frame rate.\n// Now, perhaps you need to change your target frame / physics rate and you notice the factor\n// you're using no longer gives the same smoothing.\n// Your lerps basically make a geometric series, although the target value can change every frame.\n// geometricRatio returns a corrected ratio for lerping with your new timestep,\n// referenceRatio is assumed to work correctly on the reference timestep.\n\n#define REFRATIO 0.5\n#define REFDELTA 0.2\n\nfloat geometricRatio(float referenceRatio, float referenceDt, float targetDt)\n{\n\treturn 1.0 - pow(1.0 - referenceRatio, targetDt / referenceDt);\n}\n\n// ----- The rest is just for demo\n\nfloat geometricCurve(float x, float ratio, float delta)\n{\n    x = max(x, 0.0);\n\n    float xSteps = x / delta;\n    \n    int left = int(floor(xSteps));\n    int right = int(ceil(xSteps));\n    float fr = fract(xSteps);\n    \n    // A series of lerps, start value = 0, target value = 1\n    float l = 0.0;\n    float r = 0.0;\n    for (int i = 0; i < right; i++)\n    {\n        l = r;\n        r = mix(r, 1.0, ratio);\n    }\n    l = (left == right) ? r : l;\n    \n    return mix(l, r, fr);\n}\n\nvec2 xy;\t\t// current graph coords\nvec2 dxy; \t\t// pixel size in graph units\nvec4 fColor;\t// current fragment color\n\nvoid mixColor(vec4 color, float alpha)\n{\n    fColor = vec4(mix(fColor.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, vec4 gridCol)\n{\n\tfloat mul = 1.0 / stepSize;\n\tvec2 g = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals\n\tg = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);\n    mixColor(gridCol, max(g.x, g.y));\n}\n\nvoid drawCurve(float value, vec4 curveCol)\n{\n\t// Using y distance to curve, modifying distance threshold with approximated slope\n    // Derivative breaks with drastic changes of value and discontinuities, but so be it\n    float yDist = abs(value - xy.y);\n    float dValue = abs(dFdx(value));\n\tfloat c = 1.0 - smoothstep(0.0, (dxy.y + dValue) * 2.0, yDist);\n\tmixColor(curveCol, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 graphSize = vec2(aspect * 1.2, 1.2);\n\tvec2 graphPos = 0.5 - graphSize * 0.5;\n\n\txy = graphPos + uv * graphSize;\t// graph coords\n\tdxy = graphSize / iResolution.xy;\t// pixel size in graph units\n\n    // new delta value\n    float auto = 0.51 + sin(iTime * 0.5) * 0.49;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = graphPos + mouse * graphSize;\n    float newDelta = iMouse.z <= 0.0 ? auto : (mouse.x);\n    newDelta = max(0.02, newDelta);\n    \n    // background\n\tfColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.7, 0.7, 0.7, 1.0), pow(length(0.5 - uv) * 1.414, 3.5));\n    \n\t// grid\n    drawGrid(0.1, vec4(0.0, 0.0, 0.0, 0.2));\n\tdrawGrid(0.5, vec4(0.0, 0.0, 0.0, 0.3));\n\tdrawGrid(1.0, vec4(0.0, 0.0, 0.0, 0.4));\n\n    // curves\n    drawCurve(geometricCurve(xy.x, REFRATIO, REFDELTA), vec4(0.91, 0.13, 0.23, 0.5));\n    float newRatio = geometricRatio(REFRATIO, REFDELTA, newDelta);\n    drawCurve(geometricCurve(xy.x, newRatio, newDelta), vec4(0.15, 0.45, 0.85, 0.8));\n\n\tfragColor = fColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 762, 841, 841, 908], [910, 946, 1003, 1003, 1424], [1436, 1541, 1581, 1581, 1652], [1654, 1654, 1699, 1699, 1934], [1936, 1936, 1980, 2153, 2318], [2320, 2320, 2375, 2375, 3482]]}
{"id": "XsyBDR", "name": "Exam", "author": "Andersone", "description": "Tuvākais, ko varēju dabūt, lai nav pilnībā par velti.", "tags": ["uzdevums4"], "likes": 1, "viewed": 84, "date": "1528204744", "time_retrieved": "2024-06-20T19:15:58.242872", "image_code": "float map(vec3 p)\n{\n    vec3 q = fract(p)* 2.0 - 1.0;\n    return length(q)- 0.2;\n}\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i=0; i<32; ++i){\n        vec3 p= o+r*t;\n        float d =map(p);\n        t +=d*0.5;\n    }\n    return t;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0 - 1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 r=normalize(vec3(uv, 1.0));\n    float the = iTime*0.014;\n    r.xz *=mat2(cos(the), -sin(the), sin(the), cos(the));\n    vec3 o = vec3(0.0, iTime,iTime);\n    float t = trace(o, r);\n    float fog=2.0/(1.0 + t*t*0.1);\n    vec3 fc = vec3(fog);\n    fragColor=vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsyBDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 19, 19, 82], [83, 83, 112, 112, 250], [251, 251, 306, 306, 690]]}
{"id": "XsyBW1", "name": "Ocean Creature", "author": "fizzer", "description": "A small sketch of some kind of aquatic animal in the open ocean.\nSorry for the really messy code this time. It's just a quick sketch.", "tags": ["ocean", "creature"], "likes": 16, "viewed": 244, "date": "1528497197", "time_retrieved": "2024-06-20T19:15:58.242872", "image_code": "\n#define PI 3.141592653589\n\nfloat time;\n\nfloat polydist(vec2 p,float angleoffset)\n{\n    float d=0.;\n    const int N=6;\n    for(int i=0;i<N;++i)\n    {\n        float a=float(i)/float(N)*PI*2.+angleoffset;\n        vec2 n=vec2(cos(a), sin(a));\n        d=max(d,dot(n,p));\n    }\n    return d;\n}\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    if (desc < 0.)\n        return vec2(1., 0.);\n\n    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a=1.0;\n    fragColor.rgb=vec3(0);\n    time=iTime;\n    vec2 tt = (fragCoord/iResolution.xy*2.-1.)*.75;\n    tt.x*=iResolution.x/iResolution.y;\n    float an=0.;\n\n    vec3 ro=vec3(0.,1.,5);\n    vec3 rd=normalize(vec3(tt.xy,-1.3));\n    vec2 ot=tt.xy;\n\n    rd.xy=normalize(rd.xy)*(length(rd.xy)-pow(length(rd.xy),4.)/1.5);\n\n    an=0.2;\n    rd.yz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.yz;\n    ro.yz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.yz;\n\n    an=-2.5;\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n    vec3 rdx=rd+dFdx(rd);\n    vec3 rdy=rd+dFdy(rd);\n\n    float t=-ro.y/rd.y;\n\n    vec3 spherepos=vec3(0.,sin(time*4.)*.1,0.);\n\n    vec2 dt=intersectSphere(ro, rd, spherepos, 1.);\n\n    if(dt.x<dt.y&&dt.x<t)\n    {\n        vec3 rp=ro+rd*dt.x-spherepos;\n        an=3.8;\n        rp.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rp.xz;\n\n        an=cos(time*4.)*.05;\n        rp.yz=mat2(cos(an),sin(an),-sin(an),cos(an))*rp.yz;\n\n        fragColor.rgb=vec3(.5,1,.5)/1.3;\n        float a=smoothstep(0.,.0005,dot(normalize(vec3(abs(rp.x),rp.y,rp.z)),normalize(vec3(.6,1.,-1)))-.99);\n\n        if(mod(time-.5,3.)<.1)\n            a=step(abs(rp.y-.65),.01)*step(abs(abs(rp.x)-.4),.1);\n\n        a=max(a,1.-smoothstep(0.,.005,abs(length(rp.xy-vec2(0.,.3))-.15)-.02-.01));\n\n        fragColor.rgb=mix(fragColor.rgb,vec3(.8),a);\n    }\n    else if(t>0.&&(t<dt.x||dt.x>dt.y))\n    {\n        vec3 rp=ro+rd*t;\n        vec3 rpx=ro+rdx*-ro.y/rdx.y;\n        vec3 rpy=ro+rdy*-ro.y/rdy.y;\n\n        float d=length(rp-spherepos)-1.;\n\n        float a=0.;\n        float wsum=0.;\n        const int N=3;\n        for(int i=-N;i<=+N;++i)\n        {\n            for(int j=-N;j<=+N;++j)\n            {\n                float w=1.;\n                float u=float(i)/float(N)/2., v=float(j)/float(N)/2.;\n                vec3 rp2=rp+(rpx-rp)*u+(rpy-rp)*v;\n\n                rp2.xz+=normalize(rp2.xz)*cos(d*3.-time)*exp(-d)*2.;\n\n                rp2.xz*=1.5;\n                a+=w*step(abs(cos(rp2.z+sin(rp2.x)+time/3.+cos(rp2.z+rp2.x/7.)*1.5)*cos(time/2.+rp2.x+sin(rp2.z/2.+15.*sin(rp2.z/20.)))),\n                          -pow(smoothstep(10.,240.,length(rp2.xz)),.5)+.2+cos(time*2.+rp2.x/3.-rp2.z/2.)*.05);\n                wsum+=w;\n            }\n        }\n\n        a/=wsum;\n\n        a+=step(fract(d*2.-time/2.),.3-d/4.);\n\n        fragColor.rgb=mix(vec3(0.3,0.35,1.),vec3(1),clamp(a,0.,2.)/10.);\n\n\n        fragColor.rgb+=exp(-length(rp.xz-ro.xz)/4.)*.3;\n    }\n\n    {\n        float a=0.;\n        float u=(atan(rd.z,rd.x)/PI)+time/400., v=acos(abs(rd.y))/PI+.02;\n\n        for(int i=0;i<45;++i)\n        {\n            float u2=u+float(i)*.2;\n            a=max(a,(cos(float(i)*13.)*.3+.7)*(1.-(cos(float(i)*9.)*.3+.7)*smoothstep(0.,.03,(polydist(vec2(mod(u2*8.,1.)-.5,(v-pow(.45+cos(float(i)*18.+floor(u2*8.)*21.)*.08,.8))*10.),floor(u2*8.)+time/15.))-(.11+cos(float(i))*.12))));\n        }\n\n        fragColor.rgb+=mix(vec3(0.3,0.35,1)/1.4*mix(.1,1.,step(0.,rd.y)),vec3(1),clamp(a,0.,1.)/3.)*mix(.2,1.,step(0.,rd.y));\n    }\n\n    fragColor.rgb+=pow(exp(-abs(rd.y)*(1.+100.*step(rd.y,0.))),.24)*.3;\n    fragColor.rgb+=exp(-length(ot)/2.)*.2;\n\n    float b=smoothstep(max(1e-4,length(max(abs(ot)-.67,0.))-.05),.0,.001);\n\n    fragColor.rgb=mix(min(fragColor.rgb,1.),vec3(.3),b);\n\n    fragColor.rgb=pow(fragColor.rgb,vec3(1./2.4));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsyBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[41, 41, 83, 83, 288], [290, 290, 351, 351, 632], [634, 634, 691, 691, 4042]]}
{"id": "XsyfWW", "name": "fractal practice 1", "author": "chantecleer", "description": "just a combination of a few fractal shaders from here", "tags": ["fractalde"], "likes": 8, "viewed": 173, "date": "1528773103", "time_retrieved": "2024-06-20T19:15:58.242872", "image_code": "\n#define FieldOfView 1.\n#define gt iGlobalTime * 0.1 // to make tunnel next\n//#define sgt(i) abs(sin(i * iGlobalTime))\n#define Giter 5 //iterations of the glowing lines fractal\n\n\n\nfloat DE(in vec3 z)\n{\t\n\t/* Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));   */\n\n    z = fract(z);// + 0.1*fract(2.*z);\n\n    float d =length(z.xy-vec2(0.5));\n    d = min(d, length(z.xz-vec2(0.5)));\n    d = min(d, length(z.yz-vec2(0.5)));\n    \n    return d-0.01;\n}\n    \nvec3 Glow(vec3 z, float b){\n    z = fract( z + 2.0) * 2. -1.; // divides plane again\n\n    //z.z = b; // THIS PART MAKES THE FLASHES!\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    //z.x += 0.2;\n    return z;\n}\n\n\nvec3 fog(float a,vec3 b,float c){ \n    //a *= c;\n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c ); // must be a fog function\n}\n\n// taes vec3 from Glow, v (random), u (ball at end of raytracer), and an int that is the transparency\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e= fog(0.01, abs(fr), d) * 2.; \n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( 1. -c * 200. / d, 0. ) / d * 70.;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float A = 3. * iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 base = vec3(.2, 0.5*sin(0.01*iTime), 0.5*cos(0.01*iTime));\n    //vec3 base = vec3(1.0, 0.7, 0.8);\n\n    vec3 camPos = 0.5*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(1.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color; float totalDistance, distance, v;\n\n    for(int i = 0; i < 32; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = min(abs(fract( pos.z ) - 0.5), DE(pos));\n        v = sin( A * .01 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance  + .001; \n        color += ( W( x, v, distance, 0.5) ) * (distance + 0.001);\n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsyfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[76, 180, 201, 268, 452], [458, 458, 485, 485, 749], [752, 752, 785, 800, 879], [881, 983, 1023, 1023, 1155], [1160, 1160, 1214, 1214, 2243]]}
{"id": "XtsBDl", "name": "attempt at raymarched noise/fog", "author": "MacSlow", "description": "It has some volumetric quality, but no where near proper clouds. There's no lighting or scattering of any kind. But I expected cloud-like shapes to emerge from the fbm/noise.\nI'm glad for any hints about what's wrong with my ray-marching the volume field.", "tags": ["3d", "raymarching", "noise", "fbm", "fog"], "likes": 3, "viewed": 160, "date": "1527979922", "time_retrieved": "2024-06-20T19:15:59.236864", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// raymarched noise/fog - playground for learning about volumetric clouds\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 128;\nconst float STEP_SIZE = .0125;\nconst float FAR = 1.5;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Result {\n    float dist;\n    float density;\n};\n\nconst Result nullResult = Result (.0, .0);\n\nmat2 r2d (in float a) { float r = radians (a); float c = cos (r); float s = sin (r); return mat2(vec2(c, s), vec2(-s, c));}\n//float hash (float f) { return fract (sin (f) * 4.5453); }\nfloat hash (float f) { return fract (sin (f)*45843.349); }\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    v = v * v * (3. - 2. * v);\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n    return mix (mix (mix (a, b, v.x),\n                     mix (c, d, v.x),\n                     v.y),\n                mix (mix (e, f, v.x),\n                     mix (g, h, v.x),\n                     v.y),\n                v.z);\n}\n\nmat3 rotZ (float degree)\n{\n\tfloat r = radians (degree);\n    float c = cos (r);\n    float s = sin (r);\n    mat3 m = mat3 (vec3 ( c,  s, .0),\n                   vec3 (-s,  c, .0),\n                   vec3 (.0, .0, .0));\n    return m;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat3 m1 = rotZ (1.1);\n\tmat3 m2 = rotZ (-1.2);\n\tmat3 m3 = rotZ (.9);\n\n    float result = .0;\n    result = .5 * noise3d (p); p *= m1 * 2.02;\n    result += .25 * noise3d (p); p *= m2 * 2.03;\n    result += .125 * noise3d (p); p *= m3 * 2.04;\n    result += .0625 * noise3d (p); p *= m3 * 2.05;\n    result += .01325 * noise3d (p);\n    result /= (.5 + .25 + .125 + .0625 + .01325);\n\n    return result;\n}\n\nResult march (in Ray ray, in bool typeToggle)\n{\n    float max_density = .0;\n    float density = .0;\n    Result res = nullResult;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ray.ro + res.dist*ray.rd;\n        p.xy *= r2d (2.*iTime);\n        p.yz *= r2d (-3.*iTime);\n        p.zx *= r2d (4.*iTime);\n        if (typeToggle) {\n        \tdensity = .75*noise3d (7.*p);\n        } else {\n        \tdensity = .75*fbm (7.*p);\n        }\n        max_density = max_density < density ? density : max_density;\n        if (max_density > 1. || res.dist > FAR) break;\n        res.dist += STEP_SIZE;\n    }\n\n    res.density = max_density;\n    return res;\n}\n\nRay camera (in vec3 ro, in vec3 aim, in float zoom, in vec2 uv)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = normalize (ro + forward*zoom);\n\n    return Ray (ro, normalize ((center + uv.x*right + uv.y*up) - ro));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = .0125*iTime;\n    vec3 ro = vec3 (.25*cos (t), sin (t), .25*sin (t));\n    vec3 lookAt = vec3 (.0);\n    float zoom = 1.;\n    Ray ray = camera (ro, lookAt, zoom, uv);\n    Result res;\n    if (uv.x < .0) {\n    \tres = march (ray, false);\n    } else {\n        res = march (ray, false);\n    }\n    vec3 col = mix (vec3(.0), vec3(1., .95, .9), res.density*res.density);\n\n    col = col / (1. + col);\n    col = .3*col + .7*sqrt (col);\n\n\tfragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1177, 1200, 1200, 1300], [1301, 1361, 1383, 1383, 1419], [1420, 1420, 1444, 1444, 2034], [2036, 2036, 2062, 2062, 2268], [2270, 2270, 2290, 2290, 2688], [2690, 2690, 2737, 2737, 3337], [3339, 3339, 3404, 3404, 3696], [3698, 3698, 3754, 3754, 4332]]}
