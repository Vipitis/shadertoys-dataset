{"id": "7d2XW3", "name": "test octahedron", "author": "wakkko", "description": "Little compilation of basic knowledge gathered. Makes for simple testing.", "tags": ["raymarching", "octahedron"], "likes": 2, "viewed": 50, "published": "Public", "date": "1623102272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float DEG2RAD = 3.14159265359/180.0;\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotate2X(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotate2Y(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotate2Z(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nvec3 translate(vec3 p, vec3 t)\n{\n\treturn p - t;\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n\ta = -a * DEG2RAD;\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c) * p;\n}\nvec3 rotateY(vec3 p, float a)\n{\n\ta = -a * DEG2RAD;\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c) * p;\n}\nvec3 rotateZ(vec3 p, float a)\n{\n\ta = -a * DEG2RAD;\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0) * p;\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat sceneSDF(vec3 samplePoint) { // objets dans la ma^p\n   vec3 oct1 = samplePoint +  vec3(-2.0, sin(iTime), 0.0);\n   oct1 = rotateY(oct1,iTime * 10.0) ;\n   float d1 = sdOctahedron(oct1, 1.0);\n   \n   vec3 oct2 = samplePoint +  vec3(2.0, sin(iTime), 0.0);\n   oct2 = rotateY(oct2,iTime * 10.0) ;\n   float d2 = sdOctahedron(oct2, 1.0);\n   \n   \n   //samplePoint = rotateY(iTime / 2.0) * samplePoint;\n   //samplePoint = samplePoint +  vec3(0.0, sin(iTime), 0.0);\n   return opU(d1,d2);\n}\n\nfloat Scene(vec3 p)\n{\n\n    int NUM_ITERATIONS = 15;\n    float SCALE = 2.0;\n    float C_X = 1.0;\n    float C_Y = 0.0;\n    float C_Z = 0.0;\n    float ROT1_X = 0.0;\n    float ROT1_Y = 0.0;\n    float ROT1_Z = 0.0;\n    \n    float ROT2_X = 0.0;\n    float ROT2_Y = 0.0;\n    float ROT2_Z = 0.0;\n    \n\n\tvec3 z = p;\n\tfloat b = 10000.0;\n\tfloat t = 0.0;\n\n\tfor (int i = 0; i < 30; ++i) {\n\t\tif (i == NUM_ITERATIONS) {\n\t\t\tbreak;\n\t\t}\n\t\tz = rotateX(z, ROT1_X);\n\t\tz = rotateY(z, ROT1_Y);\n\t\tz = rotateZ(z, ROT1_Z);\n\n\t\tif (z.x + z.y < 0.0) { z.xy = -z.yx; }\n\t\tif (z.x + z.z < 0.0) { z.xz = -z.zx; }\n\t\tif (z.x - z.y < 0.0) { z.xy = z.yx; }\n\t\tif (z.x - z.z < 0.0) { z.xz = z.zx; }\n\n\t\tz = rotateX(z, ROT2_X);\n\t\tz = rotateY(z, ROT2_Y);\n\t\tz = rotateZ(z, ROT2_Z);\n\n\t\tz = SCALE * z - (SCALE-1.0) * vec3(C_X, C_Y, C_Z);\n\n\t\tfloat m = dot(z, z);\n\t\tb = min(m, b);\n\t\tt = float(i+1);\n\t\tif (m >= 8.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (length(z)-2.0) * pow(SCALE, -t);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection); //croise l'item ?\n        //float dist = Scene(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n// Return the normalized direction to march in from the eye point for a single pixel.\n// de la cam ligne passe au pixel courant et continue tout droit jusqua que potentiellement rencontre un objet dans la scene \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n//LUMIERES\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n//movement de cam\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam\n   \tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 10.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));   \n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    \n    \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n     vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2XW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 215, 243, 243, 390], [392, 438, 466, 466, 613], [615, 661, 689, 689, 836], [839, 839, 871, 871, 888], [890, 890, 921, 921, 1029], [1030, 1030, 1061, 1061, 1169], [1170, 1170, 1201, 1201, 1309], [1312, 1312, 1350, 1350, 1630], [1634, 1634, 1667, 1667, 1696], [1698, 1698, 1732, 1755, 2181], [2183, 2183, 2204, 2204, 3112], [3115, 3536, 3627, 3627, 4014], [4017, 4229, 4294, 4294, 4426], [4430, 4442, 4471, 4471, 4781], [4783, 4783, 4923, 4923, 5513], [5515, 5559, 5644, 5644, 6444], [6447, 6465, 6514, 6549, 6775], [6777, 6777, 6834, 6844, 7607]], "test": "untested"}
{"id": "7l23Wt", "name": "колечко всевластия", "author": "dddd", "description": "fffff", "tags": ["yy"], "likes": 2, "viewed": 92, "published": "Public", "date": "1624998872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    \n     float x = p.x;\n     float y = p.y*iResolution.y/iResolution.x;\n    \n      float f = x*x+y*y - 0.25;\n             f = 1.0/f;\n\n    // Time varying pixel color\n               vec3 col = 0.5*cos(iTime+p.xyx+vec3(f,f,4));\n\n    // Output to screen\n                fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 454]], "test": "untested"}
{"id": "7l23zK", "name": "Hydrogen - Orbits", "author": "weasel", "description": "Hydrogen orbits. Implicit surface shows surface with probability density = const. Meant to see the shapes, not quantitative. m=0 Shapes are cut open. Use mouse to select a shape from a grid with n growing from the bottom.", "tags": ["3d", "raymarching", "physics"], "likes": 18, "viewed": 182, "published": "Public API", "date": "1624368925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Henrik Dick\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23zK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1186, 1199, 1217, 1217, 1313], [1315, 1335, 1354, 1354, 1451], [1453, 1490, 1516, 1516, 1726], [1728, 1751, 1770, 1770, 1818], [1820, 1846, 1873, 1873, 1938], [1940, 1963, 1982, 1982, 2008], [2010, 2044, 2064, 2064, 2078], [2079, 2079, 2098, 2098, 2117], [2119, 2154, 2198, 2198, 2675], [2677, 2709, 2765, 2765, 2943], [2945, 3007, 3051, 3051, 3312], [3314, 3388, 3430, 3430, 3767], [3769, 3769, 3815, 3815, 4079], [4081, 4110, 4147, 4147, 4210], [4236, 4236, 4302, 4302, 5431], [5433, 5433, 5463, 5463, 5502], [5503, 5503, 5542, 5542, 5570], [5598, 5598, 5660, 5660, 6407], [6409, 6409, 6482, 6482, 6894], [6896, 6896, 6956, 7022, 7491], [7591, 7591, 7653, 7653, 8927], [8929, 8929, 8984, 8984, 10528]], "test": "untested"}
{"id": "7l23zy", "name": "A simple 2D ray marching sample", "author": "travertexs", "description": "This is my first ray marching sample though it's a bit rough;)", "tags": ["raymarching"], "likes": 7, "viewed": 113, "published": "Public", "date": "1624199160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define Enable_iChannel3\n\n//#define Decay_Using_Actual_Ray_Length\n//#define Use_Jitter\n\n#define Depth_Test_Fallback\n#define Depth_Test_Steps 45.0\n#define Depth_Test_Fallback_Steps 12.0\n\nfloat brightness = 0.4;\nfloat edge_thickness = 0.04;\nfloat circle_radius = 0.25;\nfloat triangle_side_length = 0.5;\n\nvec2 circle_position = vec2(0.5, -0.375),\n     triangle_position = vec2(-0.5, 0.25);\n\nvec2 Coordinate_Normalize(out vec2 tex_coord, vec2 fragment_coordinate, vec2 resolution)\n{\n    tex_coord = fragment_coordinate / resolution;\n    vec2 normalized_coordinate = tex_coord * 2.0 - 1.0;\n\n    return normalized_coordinate * max(vec2(1.0), resolution / resolution.yx);\n}\n\nfloat Edge(float stuff, float thickness)\n{\n    thickness *= 0.5;\n    stuff = abs(stuff);\n    \n    return step(stuff, thickness);\n}\n\nfloat Circle(vec2 circle_position, float circle_radius, vec2 current_position)\n{\n    return length(current_position - circle_position) - circle_radius;\n}\n\nfloat Equilateral_Triangle(vec2 triangle_position, float side_length, vec2 current_position)\n{\n    float special_length = side_length * (sqrt(3.0) / 6.0);\n    \n    vec2 offset = current_position - triangle_position;\n    vec2 offset_direction = normalize(offset);\n    float offset_length = length(offset);\n    \n    vec2 base_direction = vec2(0.0, -1.0);\n    float offset_side_degree = degrees(acos(dot(base_direction, offset_direction)));\n\n    float degree_count = floor(offset_side_degree / 60.0);\n    offset_side_degree -= degree_count * 60.0;\n    \n    degree_count = floor(1.0 - abs(1.0 - degree_count));\n    offset_side_degree = abs(degree_count * 60.0 - offset_side_degree);\n    \n    float offset_side_cos = cos(radians(offset_side_degree));\n    float offset_side_length = offset_length - special_length / offset_side_cos;\n    \n    return offset_side_length * offset_side_cos;\n}\n\nfloat Depth_Tester(vec2 light_position, vec2 ray_direction, float ray_length, out float actual_ray_length)\n{\n    vec2 current_position = light_position;\n#ifdef Use_Jitter\n    float jitter = texture(iChannel1, iTime * vec2(2.0, 1.0)).x;\n#else\n    float jitter = 1.0;\n#endif\n\n    float origional_step = 0.0025;\n    float ray_step = origional_step * jitter;\n    actual_ray_length = 0.0;\n\n    float steps = 0.0, fallback_steps = 0.0;\n    float steps_max = Depth_Test_Steps;\n    float fallback_steps_max = Depth_Test_Fallback_Steps;\n    \n    \n    while(steps < steps_max && fallback_steps < fallback_steps_max)\n    {\n        current_position += ray_direction * ray_step;\n        actual_ray_length += ray_step;\n        \n        float stuff = 0.0;\n        float circle = Circle(circle_position, circle_radius, current_position);\n        float equilateral_triangle = Equilateral_Triangle(triangle_position, triangle_side_length, current_position);\n\n        stuff = min(circle, equilateral_triangle);\n        if (stuff <= ray_step)\n        {\n            if (stuff <= origional_step)\n            {\n                return 0.0;\n            }\n\n        #ifdef Depth_Test_Fallback\n            fallback_steps++;\n            if (fallback_steps >= fallback_steps_max)\n            {\n                return 0.0;\n            }\n\n            ray_step *= 0.5;\n            current_position -= ray_direction * ray_step;\n            actual_ray_length -= ray_step;\n            ray_step *= 0.5;\n            continue;\n        #endif\n        }\n\n        float error = ray_length - actual_ray_length;\n        if (error <= ray_step)\n        {\n            return 1.0;\n        }\n\n        ray_step += pow(steps * origional_step, 1.5);\n        steps++;\n    }\n    \n    return 0.0;\n}\n\nfloat Ray_Marching_2D(vec2 light_position, vec2 current_position)\n{\n    float light_strength = 0.0;\n    \n\n    vec2 origional_ray = current_position - light_position;\n    vec2 ray_direction = normalize(origional_ray);\n    float ray_length = length(origional_ray);\n\n    float actual_ray_length;\n    light_strength = Depth_Tester(light_position, ray_direction, ray_length, actual_ray_length);\n#ifdef Decay_Using_Actual_Ray_Length\n    light_strength *= pow(0.5, actual_ray_length) * (1.0 - brightness);\n#else\n    light_strength *= pow(0.5, ray_length) * (1.0 - brightness);\n#endif\n    \n    return light_strength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 tex_coord;\n    vec2 coord = Coordinate_Normalize(tex_coord, fragCoord, iResolution.xy);\n    \n    vec2 temp_coord;\n    vec2 mouse_coord = Coordinate_Normalize(temp_coord, iMouse.xy, iResolution.xy);\n\n    vec2 default_light_position = vec2(sin(0.75 * (iTime * 2.0 - 3.14159265358)) * 0.97, cos(iTime * 3.0) * 0.92);\n    if (iMouse.z < 0.5)\n    {\n        mouse_coord = default_light_position;\n    }\n\n    vec3 color = texture(iChannel0, tex_coord).rgb * 1.4;\n    vec3 edge_color = vec3(1.0, 0.6, 0.1);\n    vec3 light_color = vec3(1.0, 0.8, 0.5);\n         \n    float stuff = 0.0;\n    float point_light_radius = edge_thickness * 0.5;\n    float point_light = Circle(mouse_coord, point_light_radius, coord);\n    float circle = Circle(circle_position, circle_radius, coord);\n    float equilateral_triangle = Equilateral_Triangle(triangle_position, triangle_side_length, coord);\n\n    stuff = step(point_light, 0.0);\n    color = mix(color, stuff * vec3(1.0), stuff);\n\n    stuff = step(min(circle, equilateral_triangle), 0.0);\n    color = mix(color, stuff * texture(iChannel2, tex_coord).rgb * 1.4, stuff);\n\n    stuff = Edge(min(circle, equilateral_triangle), edge_thickness);\n    color = mix(color, stuff * edge_color, stuff);\n\n    color *= Ray_Marching_2D(mouse_coord, coord) * light_color + brightness;\n    color = pow(color, vec3(1.375));\n\n#ifdef Enable_iChannel3\n    //https://www.shadertoy.com/view/XsfGzn\n    vec3 video = texture(iChannel3, tex_coord).rgb;\n    float maxrb = max( video.r, video.b );\n    float k = clamp( (video.g-maxrb)*5.0, 0.0, 1.0 );\n    float dg = video.g; \n    video.g = min( video.g, maxrb*0.8 ); \n    video += dg - video.g;\n    \n    if (iMouse.z < 0.5)\n    {\n        color = mix(video, color, k);\n    }\n#endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 390, 480, 480, 668], [670, 670, 712, 712, 800], [802, 802, 882, 882, 955], [957, 957, 1051, 1051, 1839], [1841, 1841, 1949, 1949, 3584], [3586, 3586, 3653, 3653, 4196], [4198, 4198, 4253, 4253, 6052]], "test": "untested"}
{"id": "7l2Gzh", "name": "Color Squared", "author": "dmzmd", "description": "Color Math", "tags": ["fun"], "likes": 0, "viewed": 38, "published": "Public", "date": "1623374305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nuv*=10.;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(1,2,4));\n for(int i=0;i<int(floor(sin(iTime*2.)*5.+5.));i++){   col*=col;}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 367]], "test": "untested"}
{"id": "7l2GzW", "name": "My first ShadertoY", "author": "Vinicius_Jesus", "description": "Fireworks", "tags": ["explosion", "fireworks"], "likes": 7, "viewed": 133, "published": "Public", "date": "1623466500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_PARTICLES 60.\n\nvec2 R12(float t) \n{\n    float x = fract(sin(t*674.4)*453.2);\n    float y = fract(sin((t+x)*741.3)*263.2);\n    return vec2(x,y);\n}\n\nfloat R21(vec2 p) \n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nfloat Explosion(vec2 uv, float ft) \n{\n    float sparks = 0.;\n    for (float i = 0.; i < N_PARTICLES; i ++)\n    {\n        vec2 direction = R12(i+1.)-.5;\n\n        float dist = length(uv-direction*ft);\n        float brigthness = .0005;\n        \n        brigthness *= sin(ft*10.+i)*.5+.5;\n        \n        sparks += brigthness/dist;\n        \n        sparks *= smoothstep(1., .1, dist);\n    }\n    \n    return sparks;\n}\n\nvec3 FireWork(vec2 uv)\n{\n    float flt = floor(iTime);\n    float frt = fract(iTime);\n    \n    uv = uv - flt;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 cid = vec2(0.);\n    vec3 col = vec3(0.);\n    \n    vec3 color = sin(vec3(frt, uv.x, uv.y))*.56+.78;\n\n    for (float y = -1.; y <= 1.; y ++)\n    {\n        for(float x = -1.; x <= 1.; x++)\n        {\n            vec2 offset = vec2(x,y);\n\n            float rf = R21(id + offset);\n\n            float explosion = Explosion(gv-offset-rf, fract(iTime-rf));\n\n            float depth = 3. * rf;\n\n            col += explosion*depth*color;\n\n        }\n    }\n\n    col.rgb += color*.03;\n    col /= frt;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n    \n    uv *= 2.;\n     \n    vec3 col = vec3(0.);\n    \n    vec3 fireworks = FireWork(uv);\n    \n    col += fireworks;\n\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2GzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 155], [157, 157, 177, 177, 277], [279, 279, 316, 316, 692], [694, 694, 718, 718, 1380], [1382, 1382, 1439, 1439, 1650]], "test": "untested"}
{"id": "7lB3RV", "name": "Shapey Thangs Just Stewin", "author": "Makeavoy", "description": "More weird shape things", "tags": ["raymarching"], "likes": 0, "viewed": 41, "published": "Public", "date": "1624260531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Most foundational code built from the Art of Code tutorials https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec2 smin(float a,float b, float smoothing){\nfloat slope=clamp(.5+.5*(b-a)/smoothing,0.,1.);\n//float ease=slope*(1.-slope); //good boolean intersect\n//return slope*a+(1.-slope)*b-ease*.5;\nreturn vec2(mix(b,a,slope) - smoothing*slope*(1.-slope),slope);\n}\n\nmat2 rot(float a){\n    float s=sin(a);float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z){\n//l.x+=6.*sin(p.z*14.2);\n    //z=sin(p.y)*4.; warpy\n    vec3 f = normalize(l-p),\nr=normalize(cross(vec3(0,1,0),f)),\nu=cross(f,r),\nc=f*z,\ni=c+uv.x*r + uv.y*u,\nd=normalize(i);\nreturn d;\n}\n\nfloat sdPill(vec3 p,vec3 a, vec3 b, float r){\n    //float v=floor(sin(p.x*4.)*2.)*(1.+cos(iTime));//floor(sin(p.x*2.)*4.)*2;\n    vec3 offset=vec3(0,0,0);//+vec3(round(1.*abs(cos(iTime+p.x*2.))),0,0);\n    a+=offset;\n    b+=offset;\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    return length(p-c) -r;\n}\n\nfloat sdSphere(vec3 p,vec3 a, float r){\nreturn length(p-a) - r;\n}\n\nfloat sdTorus(vec3 p,vec2 r){\n    float i=length(p.xy)-r.x;\n    return length(vec2(i,p.z)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 a){\n    return length(max(abs(p)-a,0.)) -.2;\n}\n\nfloat sdOctahedron( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec2 getDist(vec3 p){\n    \n    vec3 a=vec3(4.,cos(iTime)*.5,2);//vec3(cos((p.y+iTime)*20.)/8.,sin(p.y*3.+iTime*3.)*2.+1.,6); //vec3(0,1,4);//\n    vec3 b=vec3(3.,cos(iTime*2.),-4.);\n    vec3 c=vec3(-3,0,2);\n\n    float sphere=sdSphere(p,a,1.)*.5;//sdPill(p,a,b,1.);\n    vec3 turn=(p+b);\n    mat2 rotVal= rot(iTime);\n    turn.xz*=rotVal;\n    float box=sdBox(turn,vec3(1,1,1));\n    turn=(p+c);\n    turn.xy*=rotVal;\n    float octa=sdOctahedron(turn,1.);\n    float bulbs=(smoothstep(.03,0.0,cos(sin(2.*(p.z+iTime*2.))+p.x*4.)*.02)*1.);\n    float planeDist=p.y+.92;\n    //float d=smin(sphereD,torusD,.5);\n    \n    float blend=clamp(0.,sin(iTime),1.);\n    vec2 mix1=smin(sphere,octa,blend);\n    vec2 mix2=smin(box,mix1.x,blend);\n    vec2 mix3=smin(planeDist,mix2.x,blend);\n       \n    vec2 mix4=smin(bulbs,mix3.x,.5*blend+.5);\n    //float d=d2.x;\n    //float last=mix4.y>.5?4.:(mix3.y>.5?3.:(mix2.y>.5?2.:(mix1.y>.5?1.:0.)));\n    float last=mix4.y>(.2+sin(iTime*4.)*0.1)?4.:\n    (mix3.y>.9?2.+(mix3.y):\n    (mix2.y>.9?1.+(mix2.y):\n    (mix1.y>.001?1.:0.) ));\n    return vec2(mix4.x,last); //mix1.y+mix2.y+mix3.y+mix4.y\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd){\n    int i=0;\n    float dO=0.;\n    float glowDist = 1e9;\n    for(i=0;i<MAX_STEPS;i++){\n        vec3 p = ro +rd*dO;\n        float dS =getDist(p).x;\n        glowDist = min(glowDist, dS);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST)break;\n    }\n    /*if (getDist(ro +rd*dO).x < SURF_DIST){\n        float col = (1.0 - float(i)/float(MAX_STEPS));\n        return vec4(col, 0.0, 0.0,dO);\n    }else{\n        float v=max((0.05 - glowDist)*20.0, 0.0);\n        return vec4(v,v,v,dO);\n    }*/\n    \n    return vec4(1,1,1,dO);\n}\n\nvec4 getNormal(vec3 p){\n    vec2 distOut=getDist(p);\n    float dist=distOut.x;\n    vec2 e=vec2(0.01,0);\n    vec3 n = dist - vec3(getDist(p-e.xyy).x,getDist(p-e.yxy).x,getDist(p-e.yyx).x);\n    return vec4(normalize(n),distOut.y);\n}\n\n//https://gist.github.com/patriciogonzalezvivo/20263fe85d52705e4530\nvec3 getTriPlanarBlend(vec3 _wNorm){\n\t// in wNorm is the world-space normal of the fragment\n\tvec3 blending = abs( _wNorm );\n\tblending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= vec3(b, b, b);\n\treturn blending;\n}\n\nvec3 getLight(vec3 p){\n    vec3 lightPos=vec3(cos(-iTime*2.)*3.,5,sin(iTime)); // 0 5 6 \n    vec3 l =normalize(lightPos-p);\n    vec4 nOut = getNormal(p);\n    vec3 n=nOut.rgb;\n    float diff=clamp(dot(l,n),0.,1.);\n    vec4 distOut=rayMarch(p+n*SURF_DIST*2.,l);\n    float dist=distOut.w;\n    if(dist<length(lightPos -p)) diff*=0.6;\n    \n    float normalRepeat=.2;\n    float normalScale=2.; \n    vec3 blending = getTriPlanarBlend(n);\n\tvec3 xaxis = texture( iChannel1, p.yz * normalRepeat).rgb;\n\tvec3 yaxis = texture( iChannel1, p.xz * normalRepeat).rgb;\n\tvec3 zaxis = texture( iChannel1, p.xy * normalRepeat).rgb;\n\tvec3 normalTex = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n\n    normalTex=mix(vec3(.6,.8,.8),normalTex,.2); //vec3(.6,.8,.8)\n    \n    //vec4 t=texture(iChannel1,n.xy);\n    //vec3(.99,.6,4.)\n    float r=sin(p.x*1.5)*.5 +1.;\n    float b=1.-r;\n    \n    float val=mod(nOut.w,1.);\n    vec3 c=vec3(.4,.3,.9); //octa\n    if(nOut.w==1.){ //sphere\n        c=vec3(0,1.,0);\n    }else if(nOut.w==2.){ //cube\n        c=vec3(.9,.1,.2);\n    }else if(nOut.w==3.){ //plane\n        c=vec3(.8,.7,1);\n    }else if(nOut.w==4.){ //wiggle\n        c=vec3(r,0,b); \n    }\n    \n    vec3 colOut=mix(normalTex,c,.7);\n    return mix(vec3(.2,.2,.2),colOut,diff);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //camera\n    vec3 ro=vec3(-1.+cos(iTime)*.5,6,sin(iTime)*.5-3.);\n\n    //vec3 rd=normalize(vec3(uv.x,uv.y-.4,1.));\n    vec3 rd=getRayDir(uv,ro,vec3(0,1,0),1.1);\n    \n    float dist=rayMarch(ro,rd).w;\n    \n    vec3 point = ro +rd*dist;\n    vec3 diffuse= getLight(point);\n\n    // Output to screen\n    fragColor = vec4(diffuse,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lB3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 186, 230, 230, 439], [441, 441, 459, 459, 523], [526, 526, 575, 627, 761], [763, 763, 808, 887, 1179], [1181, 1181, 1220, 1220, 1246], [1248, 1248, 1277, 1277, 1347], [1349, 1349, 1377, 1377, 1420], [1422, 1422, 1459, 1459, 1512], [1514, 1514, 1535, 1535, 2626], [2628, 2628, 2660, 2660, 3185], [3187, 3187, 3210, 3210, 3417], [3419, 3487, 3523, 3578, 3787], [3789, 3789, 3811, 3811, 5055], [5057, 5057, 5113, 5163, 5563]], "test": "untested"}
{"id": "7lBGD1", "name": "threeBox", "author": "ayaha401", "description": "I was inspired this movie.\nhttps://t.co/H8MN5F2JhH?amp=1\n\nI divided integer part of position of squares by even and odd.\nAnd based this value decided box rotation.\nI can only write a little English, so this sentence may be wrong.", "tags": ["box"], "likes": 6, "viewed": 75, "published": "Public", "date": "1623818290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n = 3.0;\nconst float PI = acos(-1.0);\n\n// function===============================================================\nvec2 rot(vec2 pos, float r)\n{\n    mat2 m = mat2(cos(r), sin(r), -sin(r), cos(r));\n    return m * pos + 0.5;\n}\n\n// primitive==============================================================\nfloat box(vec2 pos, vec2 size)\n{\n    vec2 leftbottom = vec2(0.5) - size;\n    vec2 uv = step(leftbottom, pos);\n    uv *= step(leftbottom, 1.0 - pos);\n    return uv.x* uv.y;\n}\n\nfloat makeThree(vec2 pos, float r)\n{\n    float d = 1e10;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    \n    vec2 rotate = rot(pos, r);\n    pos.xy = rotate;\n    d1 = box(vec2(pos.x + 0.3, pos.y), vec2(0.1, 0.55)) * (1.0 - box(vec2(pos.x + 0.3, pos.y), vec2(0.07, 0.47)));\n    d2 = box(vec2(pos.x, pos.y), vec2(0.1, 0.5)) * (1.0 - box(vec2(pos.x, pos.y), vec2(0.07, 0.47)));\n    d3 = box(vec2(pos.x - 0.3, pos.y), vec2(0.1, 0.55)) * (1.0 - box(vec2(pos.x - 0.3, pos.y), vec2(0.07, 0.47)));\n    \n    d = d1 + d2 + d3;\n    return d;\n}\n\nfloat wave(vec2 pos)\n{\n    float d = 0.0;\n    pos = vec2(pos.x + (iResolution.x)/2.0, pos.y - (iResolution.y)/2.0);\n    d = length((floor(pos * n) + 0.5) / n);\n    return 1.0 - (sin(d / 0.8 + iTime*1.5));\n}\n\n// map====================================================================\nfloat map(vec2 pos, float r)\n{\n    return makeThree(pos, r);\n}\n\nfloat map2(vec2 pos)\n{\n    return wave(pos);\n}\n\n//main====================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float mask = float(map2(pos));\n    \n    pos += 0.5;\n    \n    vec2 mulPos = pos * n;\n    pos = fract(pos * n);\n    \n    float switchNum = mod(floor(mulPos.x) + floor(mulPos.y), 2.0) + 1.0;\n    \n    float three = float(map(pos - 0.5, PI / switchNum));\n    vec3 mainCol = vec3(1.0, 1.0, 0.22);\n    \n    \n    vec3 endCol = vec3(mask * three * mainCol);\n\n    fragColor = vec4(endCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 120, 149, 149, 229], [231, 306, 338, 338, 479], [481, 481, 517, 517, 1029], [1031, 1031, 1053, 1053, 1237], [1239, 1314, 1344, 1344, 1376], [1378, 1378, 1400, 1400, 1424], [1426, 1501, 1558, 1558, 2014]], "test": "untested"}
{"id": "7lBGDK", "name": "ixd08_kaleidoscope", "author": "ixd08", "description": "kaleidoscope", "tags": ["kaleidoscope"], "likes": 1, "viewed": 44, "published": "Public", "date": "1624808776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nstruct Triangle {\n    vec2 v1;\n    vec2 v2;\n    vec2 v3;\n};\n\n#define S_RECT 0\n#define S_ELLIPSE 1\n#define S_TRIANGLE 3\n\nstruct Shape {\n    int type;\n    vec2 pos;\n    float angle;\n    vec2 size;\n    vec3 color;\n};\n\nvec4 drawShape(Shape shape, vec2 uv) {\n    uv -= shape.pos;\n    float c = cos(-shape.angle);\n    float s = sin(-shape.angle);\n    mat2 m = mat2(c, s, -s, c);\n    uv = m * uv;\n    uv /= shape.size / 2.0;\n    if (shape.type == S_RECT) {\n        if (abs(uv.x) <= 1.0 && abs(uv.y) <= 1.0) {\n            return vec4(shape.color, 1.0);\n        }\n    } else if (shape.type == S_ELLIPSE) {\n        if (dot(uv, uv) <= 1.0) {\n            return vec4(shape.color, 1.0);\n        }\n    } else {\n        if ((uv.y <= 1.0 + 2.0 * uv.x) && (uv.y <= 1.0 - 2.0 * uv.x) && (uv.y >= -1.0)) {\n            return vec4(shape.color, 1.0);\n        }\n    }\n    return vec4(0);\n}\n\nfloat rand(int a, int b) {\n    float x = float(a * 100 + b);\n    return fract(abs(sin(15123.9847 * x) * 9234.3521));\n}\n\n\nvec3 baseImage(vec2 uv) {\n    for (int i = 0; i < 100; ++i) {\n        vec2 A = vec2( rand(i,1)*2.0, rand(i,2)*2.0 );\n        vec2 k = vec2( rand(i,3)*0.3, rand(i,4)*0.3 );\n        vec2 pos = vec2( rand(i,5), rand(i,6) ) + A*sin(k*iTime);\n        vec2 size = vec2( rand(i,7)*0.2+0.1, rand(i,8)*0.2+0.1);\n        float angle = rand(i,9)*2.0*PI + (rand(i,10)*2.0-1.0)*PI*iTime;\n        vec3 color = vec3( rand(i,11)*0.9, rand(i,12)*0.9, rand(i,13)*0.9);\n        float r = rand(i,14);\n        int type;\n        if (r < 0.4) {\n            type = S_RECT;\n        } else if (r < 0.6) {\n            type = S_ELLIPSE;\n        } else {\n            type = S_TRIANGLE;\n        }\n        Shape s = Shape(type, pos, angle, size, color);\n        vec4 col = drawShape(s, uv);\n        if (col.a > 0.0) {\n            return col.rgb;\n        }\n    }\n    \n    return vec3(0);\n}\n\n\n/*\nvec3 baseImage(vec2 uv) {\n    if (distance(uv, vec2(0, 0)) < 0.2) {\n        return vec3(0, 1, 1);\n    }\n    if (distance(uv, vec2(1, 0)) < 0.2) {\n        return vec3(1, 1, 0);\n    }\n    if (distance(uv, vec2(0.5, 1.0)) < 0.2) {\n        return vec3(1, 0, 0);\n    }\n    return vec3(uv.y, uv.x, 1.0 - uv.x);\n    //return vec3(0);\n}\n*/\n\n// p -> q\nvec2 mapTriangle(vec2 uv, Triangle p, Triangle q) {\n    mat2 LP = mat2(p.v2 - p.v1, p.v3 - p.v1);\n    mat2 LQ = mat2(q.v2 - q.v1, q.v3 - q.v1);\n    return LQ * inverse(LP) * (uv - p.v1) + q.v1;\n}\n\n// triangle\nvec2 uvKaleidoscope0(vec2 uv) {\n    uv.y = mod(uv.y, 2.);\n    if (uv.y > 1.) {\n        uv.y = 2.-uv.y;\n    }\n    uv.x *= sqrt(3.) / 2.;\n    uv.x -= 0.5 * uv.y;\n    uv.x = mod(uv.x, 3.);\n    Triangle q = Triangle(vec2(0, 0), vec2(1, 0), vec2(.5, sqrt(3.0) / 2.0));\n    Triangle p;\n    if (uv.x < 1.) {\n        if (uv.y < 1.-uv.x) {\n            p = Triangle(vec2(0, 0), vec2(1, 0), vec2(0, 1));\n        } else {\n            p = Triangle(vec2(1, 1), vec2(1, 0), vec2(0, 1));\n        }\n    } else if (uv.x < 2.) {\n        uv.x -= 1.;\n        if (uv.y < 1. - uv.x) {\n            p = Triangle(vec2(0, 1), vec2(0, 0), vec2(1, 0));\n        } else {\n            p = Triangle(vec2(0, 1), vec2(1, 1), vec2(1, 0));\n        }\n    } else {\n        uv.x -= 2.;\n        if (uv.y < 1. - uv.x) {\n            p = Triangle(vec2(1, 0), vec2(0, 1), vec2(0, 0));\n        } else {\n            p = Triangle(vec2(1, 0), vec2(0, 1), vec2(1, 1));\n        }\n    }\n    uv = mapTriangle(uv, p, q);\n    return uv;\n}\n\n// square\nvec2 uvKaleidoscope1(vec2 uv) {\n    uv = mod(uv, 2.);\n    \n    if (uv.y > 1.) {\n        uv.y = 2. - uv.y;\n    }\n    if (uv.x > 1.) {\n        uv.x = 2. - uv.x;\n    }\n    if (uv.y > 1. - uv.x) {\n        Triangle p = Triangle(vec2(1, 1), vec2(1, 0), vec2(0, 1));\n        Triangle q = Triangle(vec2(0, 0), vec2(1, 0), vec2(0, 1));\n        uv = mapTriangle(uv, p, q);\n    }\n    return uv;\n}\n\n// hexagon\nvec2 uvKaleidoscope2(vec2 uv) {\n    uv.y = mod(uv.y, 2.);\n    if (uv.y > 1.) {\n        uv.y = 2.-uv.y;\n    }\n    uv.x *= sqrt(3.) / 2.;\n    uv.x -= 0.5 * uv.y;\n    uv.x = mod(uv.x, 3.);\n    Triangle q = Triangle( vec2(0.5,1.0), vec2(0.5-1.0/sqrt(3.0),0.0), vec2(0.5,0.0) );\n    Triangle p;\n    if (uv.x < 1.) {\n        if (uv.y < 1.-uv.x) {\n            if (uv.y < uv.x) {\n                p = Triangle( vec2(0,0), vec2(1,0), vec2(0.5,0.5) );\n            } else {\n                p = Triangle( vec2(0,0), vec2(0,1), vec2(0.5,0.5) );\n            }\n        } else {\n            if (uv.y < uv.x) {\n                p = Triangle( vec2(1,1), vec2(1,0), vec2(0.5,0.5) );\n            } else {\n                p = Triangle( vec2(1,1), vec2(0,1), vec2(0.5,0.5) );\n            }\n        }\n    } else if (uv.x < 2.) {\n        uv.x -= 1.;\n        if (uv.y < 1.0 - 2.0 * uv.x) {\n            p = Triangle( vec2(0,1), vec2(0,0), vec2(0.5,0.0) );\n        } else if (uv.y < 1.0 - uv.x) {\n            p = Triangle( vec2(0,1), vec2(1,0), vec2(0.5,0.0) );\n        } else if (uv.y < 1.0 - 0.5 * uv.x) {\n            p = Triangle( vec2(0,1), vec2(1,0), vec2(1.0,0.5) );\n        } else {\n            p = Triangle( vec2(0,1), vec2(1,1), vec2(1.0,0.5) );\n        }\n    } else {\n        uv.x -= 2.;\n        if (uv.y < 0.5 - 0.5 * uv.x) {\n            p = Triangle( vec2(1,0), vec2(0,0), vec2(0.0,0.5) );\n        } else if (uv.y < 1.0 - uv.x) {\n            p = Triangle( vec2(1,0), vec2(0,1), vec2(0.0,0.5) );\n        } else if (uv.y < 2.0 - 2.0 * uv.x) {\n            p = Triangle( vec2(1,0), vec2(0,1), vec2(0.5,1.0) );\n        } else {\n            p = Triangle( vec2(1,0), vec2(1,1), vec2(0.5,1.0) );\n        }\n    }\n    uv = mapTriangle(uv, p, q);\n    return uv;\n}\n\n// octagon\nvec2 uvKaleidoscope3(vec2 uv) {\n    uv = mod(uv, 3.0);\n    uv /= 3.0;\n    \n    if (uv.y > 0.5) {\n        uv.y = 1.0 - uv.y;\n        uv.x = 1.0 - uv.x;\n    }\n    if (uv.x > 0.5) {\n        uv.x = 1.0 - uv.x;\n        uv = uv.yx;\n    }\n    if (uv.y > 0.5 - uv.x) {\n        uv.x = 0.5 - uv.x;\n        uv.y = 0.5 - uv.y;\n        uv = uv.yx;\n    }\n    \n    float a = 1.0 / (cos(PI / 8.0) / sin(PI / 8.0) + 1.0);\n    float r = a / (2.0 * sin(PI / 8.0));\n    float h = a / (2.0 * tan(PI / 8.0));\n    \n    Triangle p;\n    if (uv.y > h) {\n        p = Triangle(vec2(0.0, h + a / 2.0), vec2(a / 2.0, h), vec2(-a / 2.0, h));\n    } else if (uv.y > 2.0 * h / a * uv.x) {\n        p = Triangle(vec2(0, 0), vec2(a / 2.0, h), vec2(-a / 2.0, h)); \n    } else if (uv.x > h) {\n        p = Triangle(vec2(h + a / 2.0, 0.0), vec2(h, -a / 2.0), vec2(h, a / 2.0));\n    } else if (uv.y < a / (2.0 * h) * uv.x) {\n        p = Triangle(vec2(0, 0), vec2(h, -a / 2.0), vec2(h, a / 2.0));\n    } else {\n        p = Triangle(vec2(0, 0), vec2(a / 2.0, h), vec2(h, a / 2.0));\n    }\n    \n    Triangle q = Triangle(vec2(0.5, 1.0), vec2(0, 0), vec2(1, 0));\n    \n    uv = mapTriangle(uv, p, q);\n    \n    return uv;\n}\n\n// oct star\nvec2 uvKaleidoscope4(vec2 uv) {\n    uv = mod(uv, 5.0);\n    uv /= 5.0;\n    \n    if (uv.y >= 0.5) {\n        uv.y = 1.0 - uv.y;\n    }\n    if (uv.x >= 0.5) {\n        uv.x = 1.0 - uv.x;\n    }\n    if (uv.y > uv.x) {\n        uv = uv.yx;\n    }\n    \n    float a = 1.0 / (3.0 * cos(PI / 8.0) / sin(PI / 8.0) + 1.0);\n    float r = a / (2.0 * sin(PI / 8.0));\n    float h = a / (2.0 * tan(PI / 8.0));\n    \n    Triangle p;\n    if (uv.x < h + a / 2.0 || uv.y < 2.0 * h - uv.x) {\n        if (uv.y > (h - a / 2.0) / (h + a / 2.0) * uv.x) { \n            p = Triangle(vec2(0, 0), vec2(h + a / 2.0, h - a / 2.0), vec2(h + a / 2.0));\n        } else {\n            p = Triangle(vec2(0, 0), vec2(h + a / 2.0, h - a / 2.0), vec2(0.5 - h - a / 2.0, 0.0));\n        }\n    } else if (uv.y > 2.0 * h || uv.y > 0.5 + h + a / 2.0 - uv.x) {\n        if (uv.y > (uv.x - 2.0 * h) * 2.0 * h / a) {\n            p = Triangle(vec2(0.5, 0.5), vec2(2.0 * h), vec2(0.5 - h + a / 2.0, 2.0 * h));\n        } else {\n            p = Triangle(vec2(0.5, 0.5), vec2(0.5, h + a / 2.0), vec2(0.5 - h + a / 2.0, 2.0 * h));\n        }\n    } else if (uv.y < uv.x - 2.0 * h - a) {\n        p = Triangle(vec2(0.5, 0.0), vec2(2.0 * h + a, 0.0), vec2(0.5, h - a / 2.0));\n    } else {\n        p.v1 = vec2(2.0 * h + a / 2.0, h);\n        vec2 d = uv - p.v1;\n        float ang = atan(d.y, d.x);\n        ang += PI / 8.0;\n        float n = floor(ang / PI * 4.0);\n        ang = n * PI / 4.0 + PI / 8.0;\n        p.v2 = p.v1 + vec2(r * cos(ang), r * sin(ang));\n        ang -= PI / 4.0;\n        p.v3 = p.v1 + vec2(r * cos(ang), r * sin(ang));\n        if (mod(n, 2.0) > 0.5) {\n            vec2 t = p.v2;\n            p.v2 = p.v3;\n            p.v3 = t;\n        }\n        \n    }\n    Triangle q = Triangle(vec2(0.5, 1.0), vec2(0, 0), vec2(1, 0));\n    uv = mapTriangle(uv, p, q);\n    \n    return uv;\n}\n\nvec3 kaleidoscope(float id, vec2 uv) {\n    id = mod(id, 5.0);\n    if (id < 1.0) {\n        return baseImage(uvKaleidoscope0(uv));\n    }\n    if (id < 2.0) {\n        return baseImage(uvKaleidoscope1(uv));\n    }\n    if (id < 3.0) {\n        return baseImage(uvKaleidoscope2(uv));\n    }\n    if (id < 4.0) {\n        return baseImage(uvKaleidoscope3(uv));\n    }\n    return baseImage(uvKaleidoscope4(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    uv *= 7.0;\n    \n    vec3 col;\n    float interval = 20.0;\n    float mixTime = 1.0;\n    float t = mod(iTime, interval);\n    float id = iTime / interval;\n    if (t < interval - mixTime) {\n        col = kaleidoscope(id, uv);\n    } else {\n        vec3 c1 = kaleidoscope(id, uv);\n        vec3 c2 = kaleidoscope(id + 1.0, uv);\n        float factor = smoothstep(interval - mixTime, interval, t);\n        col = mix(c1, c2, factor);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 299, 299, 913], [915, 915, 941, 941, 1033], [1036, 1036, 1061, 1061, 1893], [2232, 2242, 2293, 2293, 2437], [2439, 2451, 2482, 2482, 3434], [3436, 3446, 3477, 3477, 3831], [3833, 3844, 3875, 3875, 5579], [5581, 5592, 5623, 5623, 6765], [6767, 6779, 6810, 6810, 8602], [8604, 8604, 8642, 8642, 9002], [9004, 9004, 9061, 9111, 9668]], "test": "untested"}
{"id": "7lBGRD", "name": "Rainbow Pasta Hypnosis", "author": "rhaberli", "description": "Rainbow pasta, next shader will be more close down to earth but yet creative. ", "tags": ["color", "rainbow"], "likes": 1, "viewed": 41, "published": "Public", "date": "1623428089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float i3 = 0.5773502691896258;\nconst float r = 0.40824829046386302;\n\nconst float i = 0.3333333333333333;\nconst float j = 0.6666666666666666;\n\nconst float lrad = 0.015;\nconst float trad = 0.06;\nconst float fogv = 0.025;\n\nconst float dmax = 20.0;\nconst int rayiter = 60;\n\nconst float wrap = 64.0;\n\nvec3 L = normalize(vec3(0.1, 1.0, 0.5));\n\nconst vec3 axis = vec3(1.0, 1.0, 1.0);\nconst vec3 tgt = vec3(-0.0, 0.3, -0.15);\nconst vec3 cpos = tgt * axis+ axis*tgt + sin(axis);\n\nconst vec3 vel = 0.2*axis;\n\nconst float KEY_G = 71.5/256.0;\n\nfloat hash(in vec3 x) {\n\treturn fract(1123.5*dot(x, vec3(0.1, 0.9, 0.7)));\n}\n\nfloat line(in vec3 p0, in vec3 p1, in vec3 p) {\n\t\n\tvec3 dp0 = p-p0;\n\tvec3 d10 = p1-p0;\n\t\n\tfloat u = clamp(dot(dp0, d10)/dot(d10, d10), -5.0, 5.0);\n\treturn distance(mix(p0, p1, u), p)-0.5*lrad;\n\n}\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nfloat hueOf(vec3 pos) {\n\treturn cos( 2.0*dot(2.0*pos, vec3(0.3, 0.7, 0.4)) ) + cos(1.0*dot(1.0*pos, vec3(0.1, 0.5, 0.9))) * 0.49 + 0.5;\n}\n\nvec3 round2(in vec3 x, in vec3 a) {\n\treturn 2.0 * floor( 0.5 * (x + 1.0 - a) ) + a;\n}\n\nvec4 pdist(vec3 p, vec3 q) {\n\tvec3 pq = p-q;\n\treturn vec4(q, dot(pq,pq));\n}\n\nvec4 pselect(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\nfloat torus(in vec3 a, in vec3 b, in vec3 pos) {\n\tpos -= 0.5*(a+b);\n\tvec3 n = normalize(b-a);\n\treturn distance(pos, r*normalize(pos - n*dot(n, pos))) - trad;\n}\n\nmat4 permute(vec3 e, vec3 f, vec3 g, vec3 h, float p) {\n\treturn (p < i ? mat4(vec4(e,1.0), vec4(f,1.0), vec4(g, 1.0), vec4(h, 1.0)) :\n\t\t\t(p < j ? mat4(vec4(e,1.0), vec4(g,1.0), vec4(f, 1.0), vec4(h, 1.0)) :\n\t\t\t mat4(vec4(e,1.0), vec4(h,1.0), vec4(f, 1.0), vec4(g, 1.0))));\n}\n\nvec3 randomBasis(float p) {\n\treturn (p < i ? vec3(1.0, 0.0, 0.0) :\n\t\t\tp < j ? vec3(0.0, 1.0, 0.0) :\n\t\t\tvec3(0.0, 0.0, 1.0));\n}\n\nvec3 randomPerp(vec3 v, float p) {\n\treturn (v.x>0.0 ? (p < 0.5 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0)) :\n\t\t\tv.y>0.0 ? (p < 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0)) :\n\t\t\t(p < 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0)));\n}\n\n\nvec2 map(in vec3 pos) {\n\t\t\n\tvec3 orig = pos;\n\t\n\tpos = mod(pos + mod(iTime*vel, wrap), wrap);\n\t\t\n\t// a, b, c, d are octahedron centers\n\t// d, e, f, g are tetrahedron vertices\n\tvec3 a = round2(pos, vec3(1.0));\n\tvec3 h = round2(pos, vec3(0.0));\n\t\n\tvec3 b = vec3(a.x, h.y, h.z);\n\tvec3 c = vec3(h.x, a.y, h.z);\n\tvec3 d = vec3(h.x, h.y, a.z);\n\t\n\tvec3 e = vec3(h.x, a.y, a.z);\n\tvec3 f = vec3(a.x, h.y, a.z);\n\tvec3 g = vec3(a.x, a.y, h.z);\n\n\t// o is the closest octahedron center\n\tvec3 o = pselect(pselect(pdist(pos, a), pdist(pos, b)),\n\t\t\t\t\t pselect(pdist(pos, c), pdist(pos, d))).xyz;\n\t\n\t// t is the closest tetrahedron center\n\tvec3 t = floor(pos) + 0.5;\n\n\t// normal points towards o\n\t// so bd is positive inside octahedron, negative inside tetrahedron\n\tfloat bd = dot(pos - o.xyz, (o.xyz-t.xyz)*2.0*i3) + i3;\t\n\n\tmat4 m = permute(e,f,g,h,hash(mod(t, wrap)));\n\t\n\tfloat t1 = torus(m[0].xyz, m[1].xyz, pos);\n\tfloat t2 = torus(m[2].xyz, m[3].xyz, pos);\n\t\n\tfloat p = hash(mod(o, wrap));\n\tvec3 b1 = randomBasis(fract(8.1*p));\n\tvec3 b2 = randomPerp(b1, fract(636.1*p+4.2));\n\tvec3 b3 = randomPerp(b1, fract(4379.9*p+8.3));\n\n\tvec3 po = pos-o;\n\t\n\tfloat o1 = torus( b1,  b2, po);\n\tfloat o2 = torus( b1, -b2, po);\n\tfloat o3 = torus(-b1,  b3, po);\n\tfloat o4 = torus(-b1, -b3, po);\n\t\t\t\t\t\t \n\tvec2 noodle = vec2(min(max(bd, min(t1,t2)),\n\t\t\t\t\t\t   max(-bd, min(min(o1, o2), min(o3, o4)))),\n\t\t\t\t\t   hueOf(orig+0.5*vel*iTime));\n\t\t\t\t\t\t   \t\n\tif (texture(iChannel0, vec2(KEY_G, 0.75)).x > 0.0) {\n\t\t\t\t\n\t\tfloat dline = line(e, f, pos);\n\t\tdline = min(dline, line(e, g, pos));\n\t\tdline = min(dline, line(e, h, pos));\n\t\tdline = min(dline, line(f, g, pos));\n\t\tdline = min(dline, line(f, h, pos));\n\t\tdline = min(dline, line(g, h, pos));\n\t\t\n\t\tvec2 grid = vec2(dline, 2.0);\n\t\t\n\t\tnoodle.x += 0.5*trad;\n\t\tnoodle.y = hash(mod(bd < 0.0 ? t : o, wrap));\n\t\treturn opU(grid, noodle);\n\t\t\n\t} else {\n\t\t\n\t\treturn noodle;\n\t\t\n\t}\n\t\n}\n\nvec3 hue(float h) {\n\t\n\tvec3 c = mod(h*10.0 + vec3(2, 0, 4), 6.0);\n\treturn h > 1.0 ? vec3(0.5) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.0001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd ) {\n\tvec2 tm = castRay(ro, rd, dmax);\n\tif (tm.y >= 0.0) {\n\t\tvec3 n = calcNormal(ro + tm.x * rd);\n\t\tfloat fog = exp(-tm.x*tm.x*fogv);\n\t\tvec3 color = hue(tm.y) * 0.55 + 0.45;\n\t\tvec3 diffamb = (0.5*dot(n,L)+0.5) * color;\n\t\tvec3 R = 2.0*n*dot(n,L)-L;\n\t\tfloat spec = 0.2*pow(clamp(-dot(R, rd), 0.0, 1.0), 6.0);\n\t\treturn fog * (diffamb + spec);\n\t} else {\n\t\treturn vec3(1.0);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tconst float yscl = 720.0;\n\tconst float f = 900.0;\n\t\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * yscl / iResolution.y;\n\t\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\t\n\tvec3 rz = normalize(tgt - cpos);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n\t\n\tfloat thetax = 0.0;\n\tfloat thetay = 0.0;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * 3.14/iResolution.y; \n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * -6.28/iResolution.x; \n\t}\n\n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(1.0, 0.0, 0.0, \n\t\t\t\t   0.0, cx, sx,\n\t\t\t\t   0.0, -sx, cx);\n\t\n\tmat3 Ry = mat3(cy, 0.0, -sy,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sy, 0.0, cy);\n\n\tmat3 R = mat3(rx,ry,rz);\n\tmat3 Rt = mat3(rx.x, ry.x, rz.x,\n\t\t\t\t   rx.y, ry.y, rz.y,\n\t\t\t\t   rx.z, ry.z, rz.z);\n\n\tvec3 rd = R*Rx*Ry*normalize(vec3(uv, f));\n\t\n\tvec3 ro = tgt + R*Rx*Ry*Rt*(cpos-tgt);\n\n\tfragColor = vec4(shade(ro, rd), 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 561, 561, 614], [616, 616, 663, 663, 811], [813, 813, 839, 839, 868], [870, 870, 893, 893, 1007], [1009, 1009, 1044, 1044, 1094], [1096, 1096, 1124, 1124, 1171], [1173, 1173, 1203, 1203, 1232], [1234, 1234, 1282, 1282, 1393], [1395, 1395, 1450, 1450, 1669], [1671, 1671, 1698, 1698, 1797], [1799, 1799, 1833, 1833, 2038], [2041, 2041, 2064, 2064, 3921], [3923, 3923, 3942, 3942, 4053], [4055, 4055, 4110, 4110, 4409], [4411, 4411, 4443, 4443, 4665], [4667, 4667, 4705, 4705, 5075], [5077, 5077, 5134, 5134, 6105]], "test": "untested"}
{"id": "7lBGRK", "name": "Phased-Array Beamforming", "author": "axon", "description": "Adjustable Illustration of Phased-Array Beamforming.", "tags": ["physics"], "likes": 10, "viewed": 66, "published": "Public", "date": "1624240052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Illustration of Phased-Array Beamforming.\n */\n\nconst float ANTENNA_COUNT = 23.0;\nconst float ANTENNA_POWER = 1.0;\nconst float ANTENNA_GAP = 3.0;\n\nconst float PHASE_OFFSET = 0.4;\nconst float SPEED = 10.0;\nconst float FREQUENCY = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float score = 0.5;\n\n  for (float i = 0.0; i < ANTENNA_COUNT; i++) {\n    vec2 source = vec2(\n      ((iResolution.x - ANTENNA_COUNT * ANTENNA_GAP) / 2.0) + i * ANTENNA_GAP,\n      iResolution.y * 0.1\n    );\n\n    float deltaX = source.x - fragCoord.x;\n    float deltaY = source.y - fragCoord.y;\n\n    float distanceToCircle = sqrt(deltaX * deltaX + deltaY * deltaY);\n    float wave = (\n      (ANTENNA_POWER / ANTENNA_COUNT / 2.0) *\n      sin(\n        FREQUENCY * distanceToCircle / 3.0\n        - iTime * SPEED\n        + i * PHASE_OFFSET\n      )\n    );\n\n    score += distanceToCircle < ANTENNA_GAP * 0.3 ? 20.0 : wave;\n  }\n\n  fragColor = score > 10.0\n      ? vec4(0, 0.1, 0.8, 0.0)\n      : vec4(score, score, score, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 241, 296, 296, 1016]], "test": "untested"}
{"id": "7lf3Rs", "name": "DotGrid", "author": "samuelraub", "description": "DotGrid", "tags": ["dotgrid"], "likes": 4, "viewed": 116, "published": "Public", "date": "1622811319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define S smoothstep\n#define CAM_DIST 1.\n#define SIZE 0.02\n\n// Simplex 2D noise\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float ar = iResolution.x/iResolution.y;\n\n    vec2 myMouse = iMouse.xy / iResolution.xy;\n    myMouse -= 0.5;\n    myMouse.x *= ar;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= ar;\n    \n    vec2 origUV = uv;\n    \n    \n    vec4 myUV = vec4(uv.x, uv.y + snoise(uv + iTime * 0.2) * 0.1 + 0.5, 0., 1.);\n    \n    mat4 rotX = rotationX(PI / 4. + myMouse.y);\n    mat4 rotZ = rotationZ(PI / 7. + myMouse.x);\n    \n    myUV = myUV * rotX;\n\n    myUV = myUV * rotZ;\n\n\n    mat4 proj = mat4(\n        1. / (CAM_DIST - myUV.z), 0, 0, 0,\n        0, 1. / (CAM_DIST - myUV.z), 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n    \n    uv = (myUV * proj).xy;\n    \n    uv = fract(uv * 20.) - 0.5;\n    \n    vec3 col = vec3(0.);\n    \n    col = vec3(0.1) + vec3(S(0.105, 0.1, length(uv)) * map(myUV.z, 0., .7, .3, 0.2));\n    // col = vec3(myUV.xyz);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 105, 127, 127, 166], [168, 168, 189, 189, 1009], [1011, 1011, 1083, 1083, 1149], [1152, 1152, 1186, 1186, 1325], [1327, 1327, 1361, 1361, 1497], [1499, 1499, 1533, 1533, 1666], [1668, 1668, 1725, 1725, 2645]], "test": "untested"}
{"id": "7lj3RD", "name": "Pixel TV Static", "author": "SamyBencherif", "description": "Pixelated tv static effect intended for use in a game: https://editor.p5js.org/SamyBencherif/full/Lr-c2ATWb\nTechnique: use modulus to generate a grid of pixels, then use offsets and rotations to create a more interesting pattern & animate with time.", "tags": ["noise", "pixel", "monochrome"], "likes": 3, "viewed": 75, "published": "Public", "date": "1623478277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float T(float v)\n{\n    return 3. + mod(iTime/1000.*60.,v-3.);\n}\n\n// generate random looking grid\nfloat rgrid(vec2 pix)\n{\n    float b;\n\n    // horizontal bars every 5 pixels\n    b = mod(pix.x, T(5.))<1.?1.:0.;\n\n    // delete every other pixel in each bar\n    b = b * (mod(pix.y, 2.)<1.?1.:0.);\n\n    // delete every other group of four pixels\n    b = b * (mod(pix.y/T(4.), 2.)<1.?1.:0.);\n\n    // delete every other group of six\n    b = b * (mod(pix.y/6., T(2.))<1.?1.:0.);\n\n    // now delete alternating groups of four, but horizontally\n    b = b * (mod(pix.x/4., 2.)<1.?1.:0.);\n\n    return b;\n}\n\nfloat rrgrid(vec2 pix)\n{\n    // generate random grid of pixels\n    float b = rgrid(pix);\n    // add another pass with an offset\n    b += rgrid(vec2(pix.x-3.,pix.y-3.));\n    b += rgrid(vec2(pix.x+6.,pix.y-8.));\n    // add pass with rotation\n    float a = 1.3;\n    float c = cos(a);\n    float s = sin(a);\n    b += rgrid(vec2(pix.x * c - pix.y * s,pix.x * s + pix.y * c));\n    // pass with rotation and offset\n    a = T(-1.7);\n    c = cos(a);\n    s = sin(a);\n    b += rgrid(vec2(pix.x * c - pix.y * s-T(.4),pix.x * s + pix.y * c-3.));\n    return min(1.,max(b,0.));\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = gl_FragCoord.xy;\n    vec2 pix = floor(pos/4.);\n    \n    float b = rrgrid(pix);\n    b += rrgrid(vec2(pix.x+4., pix.y+10.));\n    b += rrgrid(vec2(pix.x+T(6.), pix.y+11.));\n    b += rrgrid(vec2(pix.x+2., pix.y+11.));\n    b += rrgrid(vec2(pix.x+2., pix.y+T(8.)));\n\n\n    fragColor = vec4(vec3(b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 63], [65, 97, 120, 120, 593], [595, 595, 619, 657, 1160], [1163, 1163, 1220, 1220, 1534]], "test": "untested"}
{"id": "7lj3Rt", "name": "Blinn Specular Model w/ RayMarch", "author": "muio", "description": "A bare-bones implementation of blinn specular model (which is based on phong's shading model) using ray-marching and SDFs.", "tags": ["raymarching", "sdf", "blinn"], "likes": 1, "viewed": 123, "published": "Public API", "date": "1624540385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Possible things one could add to this:\n/// * Rays should attenuate the further away they get from the camera.\n\n\n// Based on what I read from: https://paroj.github.io/gltut/Illumination/Tut11%20BlinnPhong%20Model.html\n\n//  Apparently, Blinn's model needs material.alpha to be higher than Phong's model\n// to create the same effect. I concluded this by comparing this with the one which\n// this shader is forked from\n\n// Colors should be in standard rgb format: 0. < rgb < 1.\n\n#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\nstruct PhongMaterial {\n    vec3 albedo;\n    float ks, kd, ka, alpha;\n};\n\nstruct PointLight {\n    vec3 pos;\n    vec3 col;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst PointLight light = PointLight(vec3(0, 5, 6),\n                                    vec3(1.000,0.878,0.878));\nconst PhongMaterial sphereMaterial = PhongMaterial(vec3(0.9,.3,0.94), \n                                                   .33, .64, .3, 64.);\nconst PhongMaterial globalMaterial = PhongMaterial(vec3(.4, .9, 1.), \n                                                   .1, .7, .2, 8.);\nconst PhongMaterial mats[2] = PhongMaterial[](globalMaterial, \n                                              sphereMaterial);\n                                                   \nconst vec3 rayOrigin = vec3(0, 1, 1);\n\n\n\nfloat SphereSDF(in vec3 p, in Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat SceneSDF(out int hitObject, in vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    hitObject = sphereDist == d ? 1 : 0;\n    return d;\n}\n\nfloat RayMarch(out int hitObject, in vec3 ro, in vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = SceneSDF(hitObject, p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\n/*\nvec3 GetNormalEulerTwoSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    \n    vec3 left = vec3(SceneSDF(_, p),\n                     SceneSDF(_, p - e.yxy),\n                     SceneSDF(_, p - e.yyx)),\n        right = vec3(SceneSDF(_, p + e.xyy),\n                     SceneSDF(_, p + e.yxy),\n                     SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n*/\n\nvec3 GetNormalEulerOneSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    vec3 center = vec3(SceneSDF(_, p)),\n          right = vec3(SceneSDF(_, p + e.xyy),\n                       SceneSDF(_, p + e.yxy),\n                       SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(right - center);\n    return n;\n}\n\n#define GetNormal GetNormalEulerOneSided\n//#define GetNormal GetNormalEulerTwoSided\n\n\n/*\n  p  -> position of point to shade\n  ro -> ray origin (position of the camera)\n*/\nvec3 PhongIllumination(in vec3 p, in vec3 ro, in int hitObject) {\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = light.pos + lightPosOffset;\n    // PhongMaterial mat = (hitObject == 1) ? sphereMaterial : globalMaterial; // bugs are great!\n    \n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    vec3 r = reflect(l, n);\n    vec3 v = normalize(ro - p);\n    \n    vec3 h = normalize(l + v); // the `half-angle` vector\n    \n    float dif  = clamp(dot(l, n), 0., 1.);\n    float spec = clamp(dot(h, n), 0., 1.);  // also called `blinn term`\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    int _;\n    float d = RayMarch(_, p + pOffset, l);\n    if (d < length(lightPos - p)) { // If true then we've shaded a point on some object before, \n                                    // so shade the currnet point as shodow.\n        dif *= .3; // no half-shadow because the light source is a point.    \n        spec = 0.; // shadows don't have specular component, I think.\n    }\n    \n    // Acutal Phong stuff\n    vec3 ambientDiffuse = light.col * mats[hitObject].albedo;\n    vec3 light1DiffuseComponent = dif * light.col;\n    vec3 light1SpecularComponent = vec3(pow(spec, mats[hitObject].alpha));\n    \n    vec3 col = mats[hitObject].ka * ambientDiffuse + \n               mats[hitObject].kd * light1DiffuseComponent + \n               mats[hitObject].ks * light1SpecularComponent;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = rayOrigin;\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    \n    // RayMarching stuff\n    int object;\n    float d = RayMarch(object, ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 col = PhongIllumination(p, ro, object);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 1427, 1468, 1468, 1504], [1506, 1506, 1552, 1574, 1755], [1757, 1757, 1816, 1816, 2204], [2206, 2690, 2730, 2779, 3080], [3168, 3253, 3318, 3318, 4796], [4798, 4798, 4855, 4855, 5243]], "test": "untested"}
{"id": "7lj3zt", "name": "五角星1", "author": "Tangguo", "description": "五角星", "tags": [], "likes": 4, "viewed": 36, "published": "Public", "date": "1624537817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BackgroundColor vec4(0.7358, 0.35, 0.0242, 1.0)\n#define LineColor vec4(0,0,0,1)\nvec4 drawline(vec2 p, vec2 p0, vec2 p1, float width) {\n    vec2 dir0 = p1 - p0;\n    vec2 dir1 = p - p0;\n    float h = clamp(dot(dir1, dir0)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return vec4(LineColor.rgb, 1.-smoothstep(-width, width, d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy / iResolution.yy;\n    \n    float width = iResolution.x/iResolution.y; \n    fragColor = BackgroundColor;\n\n        float w = 0.005;\n            float t = abs((iTime/2.0 - floor(iTime/2.0)) * 2.0 - 1.0);\n    vec2 center = vec2(width * 0.5,0.5);\n    vec2 point0 = vec2(width * 0.5, 1);\n    point0 = mix(point0,center,t);\n    vec2 point1 = vec2(width*0.3, 0);\n    point1 = mix(point1,center,t);\n    vec2 point2 = vec2(width*0.7, 0);\n    point2 = mix(point2,center,t);\n    vec2 point3 =vec2(width*0.8, 0.65);\n    point3 = mix(point3,center,t);\n    vec2 point4 = vec2(width * 0.2, 0.65);\n    point4 = mix(point4,center,t);\n        \n    vec4 c = drawline(uv, point0, point1,w);    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    c = drawline(uv, point0, point2,w);    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    c = drawline(uv, point1, point3,w);    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    c = drawline(uv, point4, point3,w);    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    c = drawline(uv, point2, point4,w);    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n      \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/1.8,1.0/1.8,1.0/1.8));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 142, 142, 377], [378, 378, 435, 435, 1652]], "test": "untested"}
{"id": "7lj3zz", "name": "Exploring Bitspace", "author": "Xor", "description": "Heavily inspired by KilledByAPixel: www.shadertoy.com/view/7ljGzR", "tags": ["voxel", "tiny"], "likes": 17, "viewed": 207, "published": "Public", "date": "1623276498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Heavily inspired by KilledByAPixel: www.shadertoy.com/view/7ljGzR\n*/\nvoid mainImage(out vec4 o,vec2 u)\n{\n    for(ivec4 b;(b.x^b.y^b.z)%81<99-b.z;)\n    b = ivec4((u/iResolution.y-.5)*o.a+iTime/.2,o+=.1);\n    o /= vec4(1e2,4e3/o);\n}\n\n\n\n//Original version\n/*\nvoid mainImage(out vec4 o,vec2 u)\n{\n    for(ivec4 b;(b.x^b.y^b.z)%81<99-b.z;)\n    b = ivec4((u/5e2-.5)*o.a+iTime/.2,o+=.1);\n    o /= vec4(7e3,3e5/o)/o;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 111, 111, 237]], "test": "untested"}
{"id": "7ljGDK", "name": "Three Link IK Robot Arm", "author": "oneshade", "description": "Solving for the inverse kinematics of a three link robot arm. Its not much different from the inverse kinematics of a two link arm except one angle must be *arbitrary* (*as long as it makes the rest of the system valid).", "tags": ["ik", "robot", "inversekinematics", "arm", "threelink"], "likes": 12, "viewed": 107, "published": "Public", "date": "1624772995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All fixed! :)\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Constants (used in solving)\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\n// In: r1: float(radius 1), r2: float(radius 2), p: vec2(position of circle 2)\n// Out: vec2(intersect angle 1, intersect angle 2)\n// Return: bool(intersecting)\nbool circleCircle(in float r1, in float r2, in vec2 p, out vec2 angles) {\n    float sqDist = dot(p, p);\n\n    float mid = atan(p.y, p.x);\n    float offs = (sqDist + r1 * r1 - r2 * r2) / (2.0 * r1 * sqrt(sqDist));\n    if (abs(offs) > 1.0) return false; // Not intersecting\n    offs = acos(offs);\n\n    angles = vec2(mid - offs, mid + offs);\n    return true;\n}\n\n// In: a: vec2(origin), b: vec2(target), l1: float(link 1 length), l2: float(link 2 length)\n// Out: vec4(left handed angles, right handed angles)\n// Return: int(number of solutions)\nint ikTwoLinkAngles(in vec2 a, in vec2 b, in float l1, in float l2, out vec4 angles) {\n    vec2 ba = b - a, t;\n    if (!circleCircle(l1, l2, ba, t)) return 0; // Solve with circle-circle intersection\n    angles.xy = vec2(t.x, atan(ba.y - sin(t.x) * l1, ba.x - cos(t.x) * l1)); // Deduce second angle\n    angles.zw = vec2(t.y, atan(ba.y - sin(t.y) * l1, ba.x - cos(t.y) * l1)); // Deduce second angle\n    return 2;\n}\n\n// Out: vec4(lower bound 1, upper bound 1, lower bound 2, upper bound 2)\n// Return: int(number of boundaries)\n// Once a valid solution is chosen, the remainder can be solved with 2 link kinematics\n// Interestingly similar to factoring polynomials eh? Except easier :D\nint ikThreeLinkSolutionBounds(in vec2 a, in vec2 b, in float l1, in float l2, in float l3, out vec4 bounds) {\n    float outer = abs(l3 + l2), inner = abs(l3 - l2);\n    vec2 ba = b - a;\n    int count = 0;\n\n    float dist = length(ba);\n    if (dist < outer - l1 && (dist < l1 - inner || dist > l1 + inner)) { // All angles are solutions\n        bounds.xy = vec2(0.0, TAU);\n        return 1;\n    }\n\n    if (circleCircle(l1, outer, ba, bounds.xy)) count++; // Outer bound of solution set\n    if (circleCircle(l1, inner, ba, bounds.zw)) { // Inner bound of solution set\n        if (count == 0) bounds.xy = vec2(bounds.w, bounds.z + TAU); // Change the interpolation direction\n        else bounds = bounds.xzwy; // Sort\n        count++;\n    }\n\n    return count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 0.5);\n\n    vec2 a = vec2(0.0); // Origin\n    vec2 b = mouse; // Target\n\n    // Link lengths\n    float l1 = 1.5;\n    float l2 = 0.8;\n    float l3 = 0.5;\n\n    vec4 foo;\n    if (ikThreeLinkSolutionBounds(a, uv, l1, l2, l3, foo) > 0) color.gb = vec2(0.75);\n\n    // Bound calculation\n    float R2inner = abs(l3 - l2); // Inner bound of last two links\n    float R2outer = l3 + l2; // Outer bound of last two links\n\n    float R3inner = l1 < R2inner ? abs(l1 - R2inner) : max(0.0, l1 - R2outer); // Inner bound of all three links\n    float R3outer = l1 + R2outer; // Outer bound of all three links\n\n    drawSDF(abs(sdDisk(uv, a, R3inner)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisk(uv, a, R3outer)), vec3(1.0, 0.0, 0.0));\n\n    // Diagrams\n    float inner = abs(l3 - l2), outer = abs(l3 + l2);\n    float radius = 0.5 * (inner + outer), thickness = 0.5 * (outer - inner);\n    drawSDF(sdRing(uv, b, radius, thickness), vec3(0.2, 0.8, 0.5)); // Fill\n    drawSDF(abs(sdRing(uv, b, radius, thickness)), vec3(0.0)); // Outline\n    drawSDF(abs(sdDisk(uv, a, l1)) - 0.01, vec3(1.0, 0.5, 0.0));\n\n    // Boundary angles are crossings with the boundaries of the two final links\n    vec2 anglesInner, anglesOuter;\n    vec2 ba = b - a;\n\n    if (circleCircle(l1, inner, ba, anglesInner)) {\n        vec2 c1 = a + vec2(cos(anglesInner.x), sin(anglesInner.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesInner.y), sin(anglesInner.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    if (circleCircle(l1, outer, ba, anglesOuter)) {\n        vec2 c1 = a + vec2(cos(anglesOuter.x), sin(anglesOuter.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesOuter.y), sin(anglesOuter.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    // Compute angles\n    vec4 bounds;\n    int numBounds = ikThreeLinkSolutionBounds(a, b, l1, l2, l3, bounds);\n    if (numBounds > 0) {\n        float transition = mix(1e-4, 1.0 - 1e-4, 0.5 + 0.5 * sin(iTime)); // Precision safety\n\n        float minAngle = bounds.x, maxAngle = bounds.y;\n        float angleOfChoice = mix(minAngle, maxAngle, transition); // Choose *arbitrary* angle\n\n        vec4 otherAngles;\n        vec2 p = a + vec2(cos(angleOfChoice), sin(angleOfChoice)) * l1;\n        int numSolutions = ikTwoLinkAngles(p, b, l2, l3, otherAngles);\n        if (numSolutions > 0) {\n            vec3 angles = vec3(angleOfChoice, otherAngles.xy);\n\n            // Joint positions\n            vec2 v1 = a;\n            vec2 v2 = v1 + vec2(cos(angles.x), sin(angles.x)) * l1;\n            vec2 v3 = v2 + vec2(cos(angles.y), sin(angles.y)) * l2;\n            vec2 v4 = v3 + vec2(cos(angles.z), sin(angles.z)) * l3;\n\n            // More diagrams\n            drawSDF(abs(sdDisk(uv, v2, l2)) - 0.01, vec3(0.0, 0.4, 0.4));\n            drawSDF(abs(sdDisk(uv, v4, l3)) - 0.01, vec3(0.0, 0.4, 0.4));\n\n            vec2 otherPos = v2 - reflect(v3 - v2, normalize(v4 - v2));\n            drawSDF(sdDisk(uv, otherPos, 0.05), vec3(0.75)); // Fill\n            drawSDF(abs(sdDisk(uv, otherPos, 0.05)), vec3(0.0)); // Outline\n\n            // Links\n            drawSDF(sdLine(uv, v1, v2, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v2, v3, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v3, v4, 0.05), vec3(0.0));\n\n            // Joints\n            drawSDF(sdDisk(uv, v1, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v2, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v3, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v4, 0.08), vec3(0.5));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 203, 251, 251, 283], [285, 285, 344, 344, 456], [458, 458, 518, 518, 559], [561, 721, 794, 794, 1077], [1079, 1261, 1347, 1347, 1676], [1678, 1946, 2055, 2055, 2703], [2705, 2705, 2760, 2779, 7056]], "test": "untested"}
{"id": "7ljGDw", "name": "Math Class", "author": "dmzmd", "description": "Prototype Graphing Calculator", "tags": ["test", "math", "tutorial"], "likes": 0, "viewed": 57, "published": "Public", "date": "1624040591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f1(float x){\nfloat y=sin(x+iTime)*2.5;\nreturn y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)-vec2(.5);\n    \n   uv=reflect(uv,vec2(sin(uv.x*5.),uv.y+.35));//Cool Effect\n   \n    float lw=.1;\n    float zoom=.5;//1.+sin(iTime)*.75;\n //   lw=lw/zoom;//Constant line screen width\n    uv*=(vec2(16,9))/zoom;\n    // Time varying pixel color\n        vec3 col = vec3(0.99);\n    vec3 blue =vec3(0.25,0.25,.99); \n //   col*=abs(uv.x-uv.y);\n //   col/=abs(uv.y);\n  //  col/=abs(uv.x);\n    //col*=sin(uv.x)+cos(uv.y*2.+iTime)+sin(uv.x*2.);//*blue;\n    float xaxis=min(step(0.,uv.y)+step(lw,-uv.y),step(0.,uv.x)+step(lw,-uv.x));\n    col*=xaxis;\n    float bline=1.-(step(1.-lw,fract(uv.y))*.3);\n    col*=vec3(bline,bline,1);\n     bline=1.-(step(1.-lw, fract(uv.x))*.3);\n    col*=vec3(bline,bline,1);\n\n   float fp=step(lw,-(uv.y-f1(uv.x)));//+step(0.,(uv.y-f1(uv.x)));\n    col*=vec3(fp,1,fp);\n\n\n//     fp=step(uv.y+lw,f1(uv.x+iTime));\n //   col*=vec3(fp,1,fp);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 56], [58, 58, 115, 165, 1114]], "test": "untested"}
{"id": "7ljGDy", "name": "Naive Vornoi", "author": "lukaszk159", "description": "Naive implementation of vornoi -study of noise.\n", "tags": ["vornoicellsnoise"], "likes": 3, "viewed": 39, "published": "Public", "date": "1624660394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p)\n{\n    vec3 a  = fract(p.xyx * vec3( 123.34, 234.34, 345.65));\n    a += dot( a, a+ 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.0 * fragCoord -iResolution.xy) / iResolution.y;\n    \n    //float m = N22(uv).x;\n    float m = 0.0;\n    float t = iTime * 0.2;\n    \n    float minDist = 100.0;\n    \n    for( float i = 0.0; i < 50.0; ++i)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin (n*t);\n        \n        float d = length( uv - p );\n        m += smoothstep( 0.02, 0.01, d);\n        \n        if ( d < minDist)\n        {\n        minDist = d;\n        }\n        \n    }\n    \n    vec3 col = vec3(minDist);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 150], [152, 152, 209, 259, 794]], "test": "untested"}
{"id": "7ljGzR", "name": "Sierpinski Towers - 134 Bytes", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["fractal", "voxel", "tiny", "1tc"], "likes": 17, "viewed": 304, "published": "Public API", "date": "1623264432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c,vec2 p)\n{\n  ivec4 b;\n  for(;(b.x^b.y&b.z)%200 > b.z-9;)\n    b = ivec4((p/5e2-.5)*c.a + iTime/.1, c+=.1);\n  c = vec4(b*b.x%2) + c/2e2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 161]], "test": "untested"}
{"id": "7lS3Dc", "name": "livecode demozoo jam - oliwi :3", "author": "bitnenfer", "description": "updated shader done during the launch of https://livecode.demozoo.org/\nmusic by lug00ber", "tags": ["livecode"], "likes": 6, "viewed": 141, "published": "Public", "date": "1624847491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// updated version of the shader I \n// made during the shader jam https://livecode.demozoo.org/\n// by bitnenfer\nfloat hash(float n) { return fract(sin(n) * 753.5); }\n\nstruct Hit\n{\n    float dist;\n    int id;\n};\n\nfloat fft = .0;\n//iq :D\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * ( 1. - h);\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s , c);\n}\n\nHit opUnion(Hit a, Hit b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nHit opaque(vec3 p)\n{\n    float t = iTime;\n    float blob = length(p) - 1. + cos(fft * 100.0 + sin(p.z * 10.0 + fft) + sin(p.x * 10.0 + fft * fft) + sin(p.y  * 12.0 + sin(iTime * 10.0 + fft))) * 0.05;\n    for (float i = 0.0; i < 3.0; i += 0.5)\n    {\n        blob = smin(blob, length(p + sin(p.x + p.y + p.z) * vec3(cos(t + i * 10.0), sin(t + i * 10.0), -cos(t - i * 10.0))) - 0.3, 0.5);\n    }\n    Hit blobHit = Hit(blob, 0);\n    return blobHit;\n}\n\nHit trans(vec3 p)\n{\n    vec3 p0 = p;\n    vec3 p1 = p;\n    p0.yz *= rot(iTime);\n    p1.xy *= rot(iTime);\n    float t0 = torus(p0, vec2(1.6, 0.1));  \n    float t1 = torus(p1, vec2(1.8, 0.1));  \n    Hit ringHit = Hit(abs(min(t0, t1)) - 0.01, 1);\n    return ringHit;\n}\n\nHit map(vec3 p) \n{\n    return opUnion(trans(p), opaque(p));\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nvec3 normOpaque(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        opaque(p + e.yxx).dist - opaque(p - e.yxx).dist,\n        opaque(p + e.xyx).dist - opaque(p - e.xyx).dist,\n        opaque(p + e.xxy).dist - opaque(p - e.xxy).dist\n    ));\n}\n\nbool trace(vec3 ro, vec3 rd, out Hit hit)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; ++i)\n    {\n        Hit h = map(ro + rd * t);\n        if (h.dist < 0.001) \n        {\n            hit.dist = t;\n            hit.id = h.id;\n            return true;\n        }\n        t+=h.dist;\n        if (t > 100.) break;\n    }\n    hit = Hit(t, -1);\n    return false;\n}\n\nbool traceOpaque(vec3 ro, vec3 rd, out Hit hit)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; ++i)\n    {\n        Hit h = opaque(ro + rd * t);\n        if (h.dist < 0.001) \n        {\n            hit.dist = t;\n            hit.id = h.id;\n            return true;\n        }\n        t+=h.dist;\n        if (t > 100.) break;\n    }\n    hit = Hit(t, -1);\n    return false;\n}\n\nvec3 render(vec2 uv)\n{\n    fft = texture(iChannel0, vec2(0.0)).r * 0.15;\n    vec3 ro = vec3(0, 0, -4. + sin(iTime) * 0.5);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 color = vec3(0.05);\n    ro.xz *= rot(iTime);\n    rd.xz *= rot(iTime);\n\n    Hit sceneHit;\n    if (trace(ro, rd, sceneHit))\n    {\n        vec3 p = ro + rd * sceneHit.dist;\n        vec3 matColor = vec3(0);\n        if (sceneHit.id == 0)\n        {\n            matColor = vec3(1, 205.0/255.0,178.0/255.0);\n        }\n        else if (sceneHit.id == 1)\n        {\n            matColor = vec3(1);\n        }\n        vec3 v = normalize(p - ro);\n        vec3 n = norm(p);\n        vec3 l = vec3(0.5, 0.2, 0.3);\n        vec3 l2 = -l;\n        l.xz *= rot(iTime);\n        l2.xz *= rot(iTime);\n        vec3 h = normalize(l2 + v);\n        float ndl = max(dot(n, l), 0.0);\n        float sp = pow(max(0.0, dot(n, h)), 1.0);\n\n        color = matColor * 0.02 + matColor * ndl + sp * vec3(0.0, 0.5, 0.9);\n\n        if (sceneHit.id == 0)\n        {\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n                for (int j = 0; j < 62; ++j)\n                {\n                    float d = map(ro2 + rd2 * 0.35).dist * 0.8;\n                    if (d < 0.0) break;\n                    color += (matColor + vec3(0.8, 0.2, 0.1)) * (d * 0.1) * 0.25;\n                }\n            }\n            \n            {\n                vec3 rd2 = l2;\n                vec3 ro2 = p + rd2 * 0.1;\n                for (int j = 0; j < 16; ++j)\n                {\n                    float d = map(ro2 + rd2 * 0.15).dist * 0.8;\n                    if (d < 0.0) break;\n                    color += (matColor + vec3(1.0, 0.5, 0.9)) * (d * 0.1) * 0.15;\n                }\n            }\n        }\n        else\n        {\n            color = vec3(0.0);\n            color += pow(max(0.0, dot(n, h)), 32.) * vec3(1);\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.1);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.r += col.r;\n            }\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.2);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.g += col.g;\n            }\n            \n            {\n                vec3 col = vec3(0);\n                vec3 rd3 = refract(rd, n+ 0.1*(hash(n.x * n.y * n.z) * 2.0 - 1.0), 1./1.3);\n                vec3 ro3 = p + rd3 * 0.2;\n                Hit refHit;\n                if (traceOpaque(ro3, rd3, refHit)) \n                {\n                    vec3 p1 = ro3 + rd3 * refHit.dist;\n                    vec3 matColor1 = vec3(0);\n                    matColor1 = vec3(1, 205.0/255.0,178.0/255.0);\n                    vec3 v1 = normalize(p1 - ro3);\n                    vec3 n1 = norm(p1);\n                    vec3 h1 = normalize(l2 + v1);\n                    float ndl1 = max(dot(n1, l), 0.0);\n                    float sp1 = pow(max(0.0, dot(n1, h1)), 1.0);\n                    col += matColor1 * 0.02 + matColor1 * ndl1 + sp1 * vec3(0.0, 0.5, 0.9);\n                }\n                else\n                    col = vec3(0.07);\n                \n                color.b += col.b;\n            }\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // oliwi :3\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 color = render(uv);\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [{"id": "XlXSDB", "previewfilepath": "https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lS3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 112, 133, 133, 165], [228, 236, 265, 265, 337], [339, 339, 378, 378, 477], [479, 479, 498, 498, 565], [567, 567, 594, 594, 645], [647, 647, 667, 667, 1092], [1094, 1094, 1113, 1113, 1358], [1360, 1360, 1378, 1378, 1421], [1423, 1423, 1442, 1442, 1660], [1662, 1662, 1687, 1687, 1923], [1925, 1925, 1968, 1968, 2283], [2285, 2285, 2334, 2334, 2652], [2654, 2654, 2676, 2676, 7427], [7429, 7429, 7486, 7502, 7709]], "test": "untested"}
{"id": "7lS3Rw", "name": "Voronoi V1", "author": "Vinicius_Jesus", "description": "try make smoke texture", "tags": ["voronoi"], "likes": 2, "viewed": 51, "published": "Public", "date": "1623535179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 R22(vec2 p) \n{\n    vec3 a = fract(p.xyx * vec3(2.34, 5.34, 123.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;    \n    uv *= 10.;\n    \n    vec3 col = vec3(.0);\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float minDist = 1.;\n    \n    for (float y = -4.; y <= 4.; y ++)\n    {\n        for(float x = -4.; x <= 4.; x++)\n        {\n        \n            vec2 offset = vec2(x,y);\n            vec2 n = R22(id + offset);\n            vec2 p = offset+sin(n*iTime)*2.;\n            \n            float dist = length(gv-p);\n            \n            if(dist < minDist)\n            {\n                minDist = dist;\n            }\n        }\n    }\n    \n    col += cos(minDist)*.8;\n    //col += .04/minDist;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lS3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 145], [147, 147, 204, 204, 899]], "test": "untested"}
{"id": "7ls3RX", "name": "little terrain map like", "author": "MrNissenDK", "description": "based on my Perlin noise", "tags": ["noise", "game", "terrain", "perlin", "smooth"], "likes": 3, "viewed": 146, "published": "Public API", "date": "1622556477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float res = 5.; // how many sqrs along the x axes\nint seed = 4294967295;\nint detail = 8; // keep less or equal to 62 and higher then 0;\nbool debug = false; // show the uv grid\n\nfloat[] heights =         float[](0. , 0.5, 0.6,  .7,  .8,  .85, 1.);\nint[] heightColorRelation = int[](0  , 1  , 1  , 2  , 3  , 3  , 4 );\nvec3[] colors = vec3[](\n    vec3(0.3176470588235294, 0.3215686274509804, 0.2980392156862745), \n    vec3(0.9294117647058824, 0.788235294117647, 0.6862745098039216), \n    vec3(0, 0.6039215686274509, 0.09019607843137255),\n    vec3(0.6588235294117647, 0.6470588235294118, 0.611764705882353),\n    vec3(1, 0.9803921568627451, 0.9803921568627451)\n);\n\nfloat pixelSize = 0.;\n\nfloat[] digitsPi = float[](14.159265,35.897932,38.462643,38.327950,28.841971,69.399375,10.582097,49.445923,78.16406,28.620899,86.280348);\n\nfloat getDigit(float index){\n    return digitsPi[int(abs(mod(index, float(digitsPi.length()))))];\n}\nfloat getDigit(int index){\n    return getDigit(float(index));\n}\nfloat getRandom(vec2 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec2(getDigit(id+265.), getDigit(id+159.))))* getDigit(id + 314.));\n}\nfloat getRandom(vec3 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec3(getDigit(id+265.), getDigit(id+159.), getDigit(id+582.))))* getDigit(id + 314.));\n}\nfloat smoothMix(vec2 from, vec2 to, vec2 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(getRandom(from), getRandom(vec2(to.x, from.y)), t.x),\n        mix(getRandom(vec2(from.x, to.y)), getRandom(to), t.x),\n    t.y);\n}\nfloat smoothMix(vec3 from, vec3 to, vec3 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(\n            mix(getRandom(from), getRandom(vec3(to.x, from.yz)), t.x),\n            mix(getRandom(vec3(from.x, to.y, from.z)), getRandom(vec3(to.xy, from.z)), t.x),\n        t.y),\n\n        mix(\n            mix(getRandom(vec3(from.xy, to.z)), getRandom(vec3(to.x, from.y, to.z)), t.x),\n            mix(getRandom(vec3(from.x, to.yz)), getRandom(to), t.x),\n        t.y),\n\n    t.z);\n}\nfloat getNoise(vec2 index){\n    vec2 low = floor(index);\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec2 low = floor(index);\n        _output += smoothMix(low, low + vec2(1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nfloat getNoise(vec3 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec3 low = floor(index);\n        _output += smoothMix(low, low + vec3(1,1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\n\nvec3 getColor(float height){\n    for(int i = 0; i < heights.length(); i++){\n        if(height <= heights[i])\n            return mix(colors[heightColorRelation[i-1]], colors[heightColorRelation[i]], (height - heights[i - 1]) / (heights[i] - heights[i -1]));\n    }\n    return vec3(colors[heightColorRelation[heights.length()-1]]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n    \n    float height = getNoise(vec3(uv, iTime/5.)) * 1.5;\n    \n    \n    vec3 col = getColor(height);\n    \n    if(height < .52) col.b = 1.;\n    \n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 822, 850, 850, 921], [922, 922, 948, 948, 985], [986, 986, 1014, 1014, 1253], [1254, 1254, 1282, 1282, 1540], [1541, 1541, 1585, 1585, 1772], [1773, 1773, 1817, 1817, 2254], [2255, 2255, 2282, 2282, 2655], [2656, 2656, 2683, 2683, 3029], [3031, 3031, 3059, 3059, 3361], [3362, 3362, 3419, 3419, 3907]], "test": "untested"}
{"id": "7ls3Wf", "name": "SDF Gradient Lighting Test", "author": "ENDESGA", "description": "using the gradient to get some sort of lighting effect", "tags": ["2d", "distancefield", "sdf", "lighting", "gradient", "distance", "smooth", "smoothminimum"], "likes": 3, "viewed": 311, "published": "Public API", "date": "1623043272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient of the smooth minimum\n// operator. This is for a quadratic polynomial smooth\n// minium function (https://iquilezles.org/www/articles/smin/smin.htm)\n//\n// Please note that the smooth-minimum is not a SDF\n// preserving operator. It's a good approximation when far\n// enough from the surfaces, but quickly distorts near them.\n//\n// Because of that, the gradient output from it, although \n// correct, has no longer length of 1.0\n//\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p)\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    return vec3( min(a.x,  b.x) - m, \n                 mix(a.yz, b.yz, (a.x<b.x)?n:1.0-n) );\n}\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x) ? a : b;\n}\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d,q/d);\n}\n\nvec3 scene(in vec2 p) {\n    vec3 dg1 = sdgBox(p,vec2(0.8,0.3));\n    vec3 dg2 = sdgSegment( p, vec2(sin(iTime),-0.5), vec2(cos(iTime*1.777),0.7) ) - vec3(0.15,0.0,0.0);\n    return sdgSMin(dg1,dg2,0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 1.5;\n\n    // sdf(p) and gradient(sdf(p))\n    \n\n  //vec3 dg = sdgMin(dg1,dg2);\n    vec3 dg = scene(p);//sdgSMin(dg1,dg2,0.1);\n    float d = dg.x;\n    vec2  g = dg.yz;\n    vec2 sun_pos = p - vec2(sin(iTime) * 2.5,cos(iTime) * 1.0);\n    vec3 sun = sdgCircle(sun_pos,0.01);//vec2(sin(iTime),cos(iTime));\n    \n    //if (abs(sun.x)-0.01 <= 0.0) {\n        //fragColor = vec4(0.25,1.0,1.0,1.0);\n    //}\n    //else\n    {\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    /*vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );*/\n    \n    vec3 col = vec3(1.0,0.0,0.25);\n    \n    /*if (d <= 0.0 && d >= -0.03) {\n        //if (dot(g,sun.yz) <= 0.0)\n        col = (vec3(1.0,0.0,0.25) / (sun.x)) * dot(-g,sun.yz);\n    } else\n    if (d > 0.0) {// && dot(g,sun.yz) <= 0.0) {\n        //float td = (clamp((0.92 / (sun.x * (4.0 - dot(g,sun.yz)))),0.0,1.0));// / (sun.x*32.0);\n        float td = sqrt(1.0 - (1.0 / (sun.x * sun.x * -4.0))) / 4.0;\n        td *= clamp(td,0.0,1.0);\n        col = vec3(td,0,td*0.25);\n    }*/\n    \n    //if () col *= 0.0;//((vec3(1.0,0.0,0.25) / (sun.x)) * dot(-g,sun.yz));// * smoothstep(0.0,sun.x,(scene(sun_pos)).x);\n    \n    col *= scene(sun_pos).x;\n    if (d >= 0.0 || d <= -0.03) col *= 0.333;\n    \n\tfragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3Wf.jpg", "access": "shaders20k", "license": "mit", "functions": [[1725, 1797, 1847, 1847, 2033], [2035, 2130, 2167, 2167, 2199], [2201, 2201, 2243, 2243, 2299], [2301, 2301, 2338, 2338, 2599], [2601, 2601, 2653, 2653, 2821], [2823, 2823, 2846, 2846, 3025], [3027, 3027, 3084, 3084, 4689]], "test": "untested"}
{"id": "7lsGD2", "name": "Lime", "author": "voxel", "description": "The rotation is sublime", "tags": ["2d", "fruit"], "likes": 21, "viewed": 241, "published": "Public API", "date": "1622919909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 BG    = vec3(.6);\nconst vec3 PEEL  = vec3(.0, .4, .0);\nconst vec3 PITH  = vec3(.95, 1, .9);\nconst vec3 FLESH = vec3(.7, .8, .0);\nconst int SECTIONS = 9;\n\nconst float PHI = 1.618033988749895; // (1+sqrt(5)) / 2\nconst float PI2 = 6.283185307179586; // 2*pi\n\n// gold noise (shadertoy.com/view/ltB3zD)\nfloat rand21(vec2 p, float seed) { return fract(tan(distance(p*PHI, p)*seed)*p.x); }\nfloat minc(vec2 p) { return min(p.x, p.y); }\nfloat noise(vec2 p, float seed) {\n    vec2 r = floor(p);\n    vec2 s = fract(p);\n    float h00 = rand21(r,             seed);\n    float h01 = rand21(r + vec2(0,1), seed);\n    float h10 = rand21(r + vec2(1,0), seed);\n    float h11 = rand21(r + vec2(1,1), seed);\n    return mix(mix(h00, h01, s.y),\n               mix(h10, h11, s.y),\n               s.x);\n}\n\nfloat height(float r, float angle) {\n    angle -= PI2 * float(SECTIONS) * .5; // section dividers are in the middle\n    float scaledAngle = fract(angle / PI2) * float(SECTIONS);\n    float section = floor(scaledAngle);\n    float subAngle = fract(scaledAngle);\n    return noise(vec2(r*8., subAngle * 15.), section + 100.);\n}\n\n// return the color of a lime with unit radius centered at the origin\nvec3 lime(vec2 p) {\n    float r = length(p);\n    float angle = atan(p.y, p.x) + iTime*.2;\n    \n    float subpos, idx;\n    {\n        float scaledAngle = fract(angle / PI2) * float(SECTIONS);\n        idx = floor(scaledAngle);\n        float hsh1 = rand21(vec2(idx, 10.), 1.);\n        float hsh2 = rand21(vec2(idx, 10.), 2.);\n        subpos = fract(scaledAngle) + 0.03*sin((10.+2.*hsh1)*(r+hsh2));\n    }\n\n    float thresh = .94 + .005 * sin(angle*20.) + .0015 * cos(angle*65.+4.);\n    float pthresh = thresh - .1*smoothstep(.2, -0.2, distance(subpos, .5));\n    \n    float flesh;\n    {\n        float width = atan(.015 / r);\n        flesh = smoothstep(0., width, distance(subpos, .5));\n        flesh *= smoothstep(pthresh-.02, pthresh-.04, r);\n        float center = .04 + .02*smoothstep(.4, -0.2, distance(subpos, .5));\n        flesh *= smoothstep(center, center + .02, r);\n    }\n\n    vec3 color;\n    {\n        float h = height(r, angle);\n        color = mix(FLESH*.85, FLESH*1.1, h);\n        vec2 p2 = p + vec2(-.02,.05);\n        float r2 = length(p2);\n        float angle2 = atan(p2.y, p2.x) + iTime*.2;\n        float h2 = height(r2, angle2);\n        color += .4 * smoothstep(.2, .6, h - h2);\n    }\n    color = mix(PITH, color, flesh);\n    color = mix(color, PEEL, smoothstep(thresh, thresh+.05, r));\n    color = mix(color, BG*.7, smoothstep(1., 1.015, r));\n    color = mix(color, BG, smoothstep(1., 1.3, r));\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy / 2.;\n    float scale = minc(res) * .8;\n    vec3 col = lime((fragCoord - res) / scale);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 309, 343, 343, 393], [394, 394, 414, 414, 438], [439, 439, 472, 472, 791], [793, 793, 829, 829, 1115], [1117, 1187, 1206, 1206, 2613], [2615, 2615, 2670, 2670, 2821]], "test": "untested"}
{"id": "7lSGD3", "name": "Interactive quadratic Julia set", "author": "sepehrnoor", "description": "Visualization of the convergence of f_c(z)=z^2+c\n\nz is screen UV normalized to [-3,3]. \nc is set by you by clicking the screen. You can also pause and click. x is real part, y is imaginary, and both are scaled to [-1,1].", "tags": ["2d", "fractal", "animated"], "likes": 3, "viewed": 45, "published": "Public", "date": "1624828664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 32\n#define TIMESCALE .5\n#define THRESHOLD 2.\n\n// Color scheme lifted from the default colors in Ultra Fractal\nvec3 color(int iter){\n    iter = iter % 16;\n    vec3 colors[16] = vec3[16](\n        vec3(0., 0., 0.),\n        vec3(25., 7., 26.),\n        vec3(9., 1., 47.),\n        vec3(4., 4., 73.),\n        vec3(0., 7., 100.),\n        vec3(12., 44., 138.),\n        vec3(24., 82., 177.),\n        vec3(57., 125., 209.),\n        vec3(134., 181., 229.),\n        vec3(211., 236., 248.),\n        vec3(241., 233., 191.),\n        vec3(248., 201., 95.),\n        vec3(255., 170., 0.),\n        vec3(204., 128., 0.),\n        vec3(153., 87., 0.),\n        vec3(106., 52., 3.)\n    );\nreturn colors[iter] / 255.;\n}\n\n// Iterate quadratic Julia set, return number of iterations before convergence (or divergence!)\nint julia(vec2 z){\n    int iter = 0;\n    vec2 mouseuv = iMouse.xy/iResolution.xy;\n    vec2 c = (mouseuv - 0.5) * 2.;\n    c *= vec2(sin(iTime* TIMESCALE), cos(iTime* TIMESCALE));\n    while (iter < MAX_ITER){\n        float re = z.x*z.x - z.y*z.y;\n        z.y = 2.*z.x*z.y;\n        z.x = re;\n        z += c;\n        if (length(z)>THRESHOLD) break;\n        iter++;\n    }\n    return iter;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // y in [-3,3], x somewhere like [-5.3, 5.3]\n    vec2 uv = (fragCoord - iResolution.xy/2.) / iResolution.y * 3.;\n    \n    // Output to screen\n    fragColor = vec4(color(julia(uv)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 127, 148, 148, 710], [712, 808, 826, 826, 1193], [1195, 1195, 1252, 1301, 1444]], "test": "untested"}
{"id": "7lSGDy", "name": "Spiral tentacles", "author": "gormonboza", "description": "Polar coordinates", "tags": ["polar"], "likes": 8, "viewed": 191, "published": "Public API", "date": "1624607889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = vec4(.0);\n\n\tvec2 res = iResolution.xy;\n\n\n\t//------ create polar coordinates -----\n\n\tvec2 nUV = (uv - .5) * res / res.y * 1.3;\n\n\tvec2 V = normalize(nUV);\n\n\tvec2 refV = vec2(1., 0.);\n\n\tfloat cosA = dot(refV, V);\n\n\tfloat alpha = acos(cosA);\n\n\talpha = alpha * step(.0, nUV.y) + (radians(360.) - alpha) * step(nUV.y, .0); // full 2PI circle\n\n\t//--------------------------------------\n\n\tfloat alphaP = alpha + length(nUV) * 16. / exp(length(nUV));\n\n\tfloat edge = cos(alphaP * 5. + iTime * 3.);\n\n\tedge += 1.;\n\n\tedge /= 2.;\n\n\tedge *= length(nUV) * exp(length(nUV) / 3.);\n\n\tvec3 rainbow;\n\n\trainbow.r = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) * 0. / 360.) + 1.) / 2.;\n\trainbow.g = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) * 120. / 360.) + 1.) / 2.;\n\trainbow.b = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) *240. / 360.) + 1.) / 2.;\n\n\n\n\tcolor.rgb = rainbow * edge;\n\n\tcolor.a = 1.;\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1125]], "test": "untested"}
{"id": "7lsGRX", "name": "drive_home_srp", "author": "sreejithpro", "description": "a recreation of BigWings Tutorial", "tags": ["tutorial"], "likes": 4, "viewed": 118, "published": "Public", "date": "1622571002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s(a,b,t) smoothstep(a,b,t)\n\nfloat N(float t){\n    return fract(sin(t*458.25)*2564.36);\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(123.34,345.45));\n    p += dot(p, p+34.3456);\n    return fract(p.x*p.y);\n}\n\nvec4 N14(float t){\n    return fract(sin(t*vec4(58.36, 623.25, 7198.23, 9486.64))*vec4(5689.74,2564.36,528.49,89.75));\n}\n\nstruct ray{\n    vec3 o, d;\n};\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    vec3 wup = vec3(0,1,0);\n\n    vec3 f = normalize(lookat-camPos);\n    vec3 r = normalize(cross(wup,f));\n    vec3 u = cross(f, r);\n\n    vec3 c = a.o + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    a.d = normalize(i-a.o);\n\n    return a;\n}\n\nvec3 closestPoint (ray r, vec3 p){\n    return r.o + max(0., dot(p-r.o,r.d))*r.d;\n}\n\nfloat distRay(ray r, vec3 p){\n   return length(p-closestPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    \n    float d = distRay(r, p);\n    size *= length(p);\n    float c = s(size,size*(1.-blur),d);\n    c *= mix(0.6, 1., s(size*.8,size,d));\n    return c;\n}\n\nvec3 streetLights(ray r, float t){\n    float side = step(r.d.x,0.);\n    r.d.x = abs(r.d.x);\n    \n    float s = 1./10.;\n    float m = 0.;\n    for(float i=0.; i<1.; i+=s){\n        float ti = fract(t+i+side*s*.5);\n        vec3 p = vec3(2,2,100.-ti*100.);\n        m += Bokeh(r,p,0.05,0.1)*ti*ti*ti;    \n    }\n    vec3 col = vec3(1,0.7,.3)*m;\n    return col;\n}\n\nvec3 headLights(ray r, float t){\n    t *= 2.;\n    float w1 = 0.25;\n    float w2 = w1*1.2;\n    float s = 1./30.;\n    float m = 0.;\n    \n    for(float i=0.; i<1.; i+=s){\n        float n = N(i);\n\n        if(n>0.25) continue; // limiting no. of headlights\n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = s(0.9,1.,ti);\n        float size = mix(0.05,0.03,focus);\n        \n        //headlights 1\n        m += Bokeh(r,vec3(-1.-w1,0.15,z),size,0.1)*fade; \n        m += Bokeh(r,vec3(-1.+w1,0.15,z),size,0.1)*fade; \n        \n        //headlights 2\n        m += Bokeh(r,vec3(-1.-w2,0.15,z),size,0.1)*fade; \n        m += Bokeh(r,vec3(-1.+w2,0.15,z),size,0.1)*fade;\n        \n        //reflections\n        float ref = 0.;\n        ref += Bokeh(r,vec3(-1.-w2,-0.15,z),size*3.,1.)*focus; \n        ref += Bokeh(r,vec3(-1.+w2,-0.15,z),size*3.,1.)*focus;\n        \n        m += ref*focus;\n    }\n    vec3 col = vec3(.9,.9,1.)*m;\n    return col;\n}\n\nvec3 tailLights(ray r, float t){\n    \n    t *= 0.25;\n    float w1 = 0.25;\n    float w2 = w1*1.2;\n    float s = 1./30.;\n    float m = 0.;\n    \n    for(float i=0.; i<1.; i+=s){\n        float n = N(i);\n\n        if(n>.5) continue; // limiting no. of headlights\n        \n        float lane = step(.25,n);\n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = s(0.9,1.,ti);\n        float size = mix(0.05,0.03,focus);\n        float laneShift = s(1.,0.96,ti);\n        \n        //headlights 1\n        float blinker = step(0.96,ti);\n        float x = 1.5 - lane * laneShift;\n        float blink = step(0.,sin(t*1000.))*lane*blinker*7.;\n        m += Bokeh(r,vec3(x-w1,0.15,z),size,0.1)*fade; \n        m += Bokeh(r,vec3(x+w1,0.15,z),size,0.1)*fade; \n        \n        //headlights 2\n        m += Bokeh(r,vec3(x-w2,0.15,z),size,0.1)*fade; \n        m += Bokeh(r,vec3(x+w2,0.15,z),size,0.1)*fade*(1.+blink);\n        \n        //reflections\n        float ref = 0.;\n        ref += Bokeh(r,vec3(x-w2,-0.15,z),size*3.,1.)*focus; \n        ref += Bokeh(r,vec3(x+w2,-0.15,z),size*3.,1.)*focus*(1.+blink*0.1);\n        \n        m += ref*focus;\n    }\n    vec3 col = vec3(1.,.1,.03)*m;\n    return col;\n}\n\nvec3 envLights(ray r, float t){\n    float side = step(r.d.x,0.);\n    r.d.x = abs(r.d.x);\n    \n    float s = 1./15.;\n    vec3 c = vec3(0.);\n    for(float i=0.; i<1.; i+=s){\n        float ti = fract(t+i+side*s*.5);\n        float fade = ti*ti*ti;\n        vec4 n = N14(i+side*100.);\n        float occlusion = sin(ti*6.283*10.*n.x)*0.5+0.5;\n        fade = occlusion;\n        float x = mix(2.5,10.,n.x);\n        float y = mix(0.1,1.5,n.y);\n        vec3 p = vec3(x,y,50.-ti*50.);\n        \n        vec3 col = n.wzy;\n        c += Bokeh(r,p,0.05,0.1)*fade*col*0.5;    \n    }\n   \n    return c;\n}\n\nvec2 Rain(vec2 uv, float t){\n    \n    t *= 40.;\n    uv *= 4.;\n    \n    vec2 a = vec2(3.,1.);\n    vec2 st = uv*a;\n    \n    vec2 id = floor(st);\n    st.y += t*0.22;\n    \n    st.y += N(id.x);\n    uv.y += N(id.x);\n    id = floor(st);\n    st = fract(st)-0.5;\n    \n    \n    \n    \n    float n = N21(id);\n    t += n*6.2831; \n    float w = uv.y*10.;\n    float x = (n - 0.45)*0.6;\n    x += (0.45*0.6-abs(x))*sin(3.*w)*pow(abs(sin(w)),6.)*0.45;\n    float y = -sin(t+sin(t+sin(t)*0.5))*0.40;\n    //y -= (st.x-x)*(st.x-x);\n    \n    vec2 p1 = vec2(x,y);\n    vec2 dropPos = (st-p1)/a;\n    float drop = s(0.07,0.05,length(dropPos));\n    \n    vec2 p2 = vec2(x,t*0.25);\n    vec2 trailPos = (st-p2)/a;\n    trailPos.y = (fract(trailPos.y*8.)-0.5)/8.;\n    float trail = s(0.06,0.0,length(trailPos));\n    float fogTrail = s(-0.05,.05,dropPos.y);\n    fogTrail *= s(0.5,y,st.y);\n    \n    \n    fogTrail *= s(0.05,0.04,abs(dropPos.x));\n    trail += fogTrail;\n    //if (st.x>0.46 || st.y > 0.49) drop = 1.;\n    \n    return vec2(drop*dropPos*30.+trail*trailPos*10.+fogTrail*dropPos*0.2*5.);\n\n\n}\n\nvec2 Rain2(vec2 uv, float t){\n    \n    t *= 40.;\n    uv *= 6.;\n    \n    vec2 a = vec2(2.,1.);\n    vec2 st = uv*a;\n    \n    vec2 id = floor(st);\n    st.y += t*0.22;\n    \n    st.y += N(id.x);\n    uv.y += N(id.x);\n    id = floor(st);\n    st = fract(st-0.5)-0.5;\n    \n    \n    \n    \n    float n = N21(id);\n    t += n*6.2831; \n    float w = uv.y*10.;\n    float x = (n - 0.45)*0.6;\n    x += (0.45*0.6-abs(x))*sin(3.*w)*pow(abs(sin(w)),6.)*0.45;\n    float y = -sin(t+sin(t+sin(t)*0.5))*0.40;\n    y -= (st.x-x)*(st.x-x);\n    \n    vec2 p1 = vec2(x,y);\n    vec2 dropPos = (st-p1)/a;\n    float drop = s(0.07,0.05,length(dropPos));\n    \n    vec2 p2 = vec2(x,t*0.25);\n    vec2 trailPos = (st-p2)/a;\n    trailPos.y = (fract(trailPos.y*8.)-0.5)/8.;\n    float trail = s(0.06,0.0,length(trailPos));\n    float fogTrail = s(-0.05,.05,dropPos.y);\n    fogTrail *= s(0.5,y,st.y);\n    \n    \n    fogTrail *= s(0.05,0.04,abs(dropPos.x));\n    trail += fogTrail;\n    //if (st.x>0.46 || st.y > 0.49) drop = 1.;\n    \n    return vec2(drop*dropPos*30.+trail*trailPos*10.+fogTrail*dropPos*0.2*5.);\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//*******************************************\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n//*******************************************\n    float t = iTime*.05;//+m.x;\n    float xoffs = (sin(t)*.5-0.5)*0.1;\n    vec3 camPos = vec3(.5+xoffs,.2,0.);\n    vec3 lookat = vec3(.5,.2,1);\n    \n    \n    \n    vec2 rainDistort = Rain(uv, t);\n    rainDistort += Rain2(uv,t);\n    \n    ray r= getRay(uv-rainDistort,camPos,lookat,2.);\n    \n    \n    \n    vec3 col = streetLights(r,t);\n    col += headLights(r,t);\n    col += tailLights(r,t);\n    col += envLights(r,t);\n    \n    col += (r.d.y+.25)*vec3(0.2,0.1,.5);\n    \n    //col = vec3(rainDistort,0.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 53, 53, 96], [98, 98, 116, 116, 211], [213, 213, 231, 231, 332], [365, 365, 423, 423, 691], [693, 693, 727, 727, 775], [777, 777, 806, 806, 847], [849, 849, 901, 901, 1056], [1058, 1058, 1092, 1092, 1413], [1415, 1415, 1447, 1447, 2412], [2414, 2414, 2446, 2446, 3657], [3659, 3659, 3690, 3690, 4243], [4245, 4245, 4273, 4273, 5311], [5313, 5313, 5342, 5342, 6382], [6384, 6384, 6441, 6487, 7228]], "test": "untested"}
{"id": "7lsGWf", "name": "atmospheric experiment 2", "author": "bloodnok", "description": "work in progress experiment to get some sort of semi-realistic planetary atmospheres.\nMouse to drag the sun around.", "tags": ["raytracing", "atmosphere"], "likes": 0, "viewed": 90, "published": "Public", "date": "1623103541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415927\n/*\n\t@geofftnz\n\n\tforking someone's raytraced sphere in order to do some material testing.\n\n    atmospheric scattering attempt\n\n*/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\tif (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection\n{\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n    uint mnear;    // material first hit (atmosphere?)\n    uint mfar;     // material on second hit (atmosphere or ground)\n    vec3 nor;      // normal at solid intersection (material dependent)\n};\n\n\n// intersect ray ro+rd with sphere sph, with a ground height sphgnd\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph, in float sphgnd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n    res.mnear = 0u;\n    res.mfar = 0u;\n    res.nor = vec3(0.0,0.0,0.0);\n    \n    // outer sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.mnear = 1u;  // atmospheric hit\n        \n        res.tfar = (-b + hsqrt)/2.0;\n        res.mfar = 1u;  // atmospheric exit\n        \n        // inner sphere intersection\n        r = sphgnd;\n        c = dot(oc,oc)-r*r;\n        h = b*b - 4.0*c;\n        \n        if (h >= 0.0){\n            // ground hit\n            res.tfar = (-b - sqrt(h)) / 2.0;\n            res.mfar = 2u;  // ground hit\n            res.nor = normalize(ro + rd * res.tfar - sph.xyz);  // ground normal\n        }\n    }\n\n    return res;\n}\n\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphere2 (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\n\nvec3 brdfRock(vec3 pos, vec3 norm, vec3 view, vec3 light, vec3 lightcol)\n{\n\t\n\t// perturb normal\n\tvec3 pnpos = pos * 100.0;\n\tvec3 pn = normalize(vec3(\tfbm(pnpos),fbm(pnpos.zxy + vec3(1.7,33.9,2.3)),fbm(pnpos.yzx + vec3(3.9,7.4,19.1)) ) - vec3(0.5));\n\tpnpos *= 20.0;\n\tvec3 pn2 = normalize(vec3(\tfbm(pnpos),fbm(pnpos.zxy + vec3(1.7,33.9,2.3)),fbm(pnpos.yzx + vec3(3.9,7.4,19.1)) ) - vec3(0.5));\n\t\n\tnorm = normalize(norm + pn * 0.02 + pn2 * 0.01);\n\t\n\t\n\tfloat a = sin(pos.y*17.0+fbm(pos * vec3(1.0,0.1,1.0)*3.5)*7.9) * 0.5 + 0.5;\n\tfloat b = sin(pos.y*9.3+fbm(pos * vec3(0.7,0.17,0.7)*7.58)*3.6) * 0.5 + 0.5;\n/*\t\nvec3(0.2549,0.1490,0.0863)\nvec3(0.2941,0.2000,0.1137)\nvec3(0.2941,0.1529,0.0980)\nvec3(0.3020,0.2000,0.1137)\nvec3(0.3216,0.2078,0.1686)\nvec3(0.3569,0.2078,0.1255)\nvec3(0.4196,0.2824,0.2275)\nvec3(0.4902,0.3961,0.2784)\nvec3(0.6549,0.5804,0.4667)\n\n\n\tvec3 c00 = vec3(0.2549,0.1490,0.0863);\n\tvec3 c10 = vec3(0.2941,0.2000,0.1137);\n\tvec3 c01 = vec3(0.3216,0.2078,0.1686);\n\tvec3 c11 = vec3(0.3569,0.2078,0.1255);\n*/\t\n\t\n\tvec3 c00 = vec3(0.2549,0.1490,0.0863);\n\tvec3 c10 = vec3(0.2941,0.2000,0.1137);\n\tvec3 c01 = vec3(0.2941,0.1529,0.0980);\n\tvec3 c11 = vec3(0.3020,0.2000,0.1137);\t\n\t\n\tvec3 diffCol = vec3(0.0);\n\tdiffCol = mix(mix(c00,c01,a),mix(c10,c11,a),b);\n\tdiffCol = mix(diffCol,vec3(0.2941,0.1529,0.0980),mod(a+b,0.3)*2.5);\n\tdiffCol = mix(diffCol,vec3(0.6549,0.5804,0.4667),mod(a*0.1,0.1)*0.2);\n\t\n\t\n\t// material\n\tfloat absorb = 0.5;\n\tfloat reflIntensity = 0.01;\n\tfloat diffIntensity = 1.0 - reflIntensity - absorb;\n\t\n\t\n\t// diffuse col\n\t//vec3 diffCol = vec3(0.6);\n\tvec3 ambCol = vec3(0.0);\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat roughness = 0.05;\n\tfloat diffuse = max(dot(norm, light),0.0) * diffIntensity;\n\tfloat ambient = 0.4;\n\t\n\tvec3 refl = reflect(-view,norm);\n\t//float fres = pow( clamp(1.0+dot(norm,-view),0.0,1.0), 2.0 );\n\tfloat ldotr = max(dot(light, refl),0.0);\n\tfloat spec = pow(ldotr,1.0/roughness) * reflIntensity;\n\t\n\t\n\tcol += lightcol * diffCol * ambCol * ambient * diffIntensity;\n\tcol += lightcol * diffCol * diffuse;\n\tcol += lightcol * spec;\n\t//col += skycol(refl) * fres;\n\t\n\t\n\treturn col;\n}\n\n\n// atmospheric scattering specifics\n\n// Rayleigh absorbtion constant.\nvec3 Kr = vec3(0.1287, 0.2698, 0.7216);\nfloat miePhase = 0.93;\nfloat ralPhase = -0.01;\nfloat absorbCoeff = 0.7;\n\nvec4 sph1 = vec4 (0.0,1.0,0.0,1.0);\nfloat sph1gnd = 0.92;  // radius of ground\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\niMediaIntersection mediaIntersect( in vec3 ro, in vec3 rd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.mnear = 0u;\n    res.tfar = -1.0;\n    res.mfar = 0u;\n    \n    iMediaIntersection res2 = mSphere(ro,rd,sph1,sph1gnd);\n    res = res2;\n    \n    return res;\n}\n\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g){\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\nfloat airDensity(float alt){\n    return 5.0 * exp(-7.0 * alt) * (1.0-alt);  // last factor is lies, but makes sure we end at 0.0 at edge of atmosphere\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 light = normalize( vec3(0.5,1.0,0.5));\n\tvec3 lightcol = vec3(10.0,9.0,8.0);\n\t//uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 lookAt = vec3(0.0, 1.0, 0.0);\n\tvec3 ro = vec3(0.0,1.1,2.0); //camera position\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n\n\tvec2 nMouse = (iMouse.xy / iResolution.xy) * PI;\n\t//nMouse.x += 3.1415927;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n\tlight.x = sin(th) * cos(ph);\n\tlight.z = sin(th) * sin(ph);\n\tlight.y = -cos(th);\n\tlight = normalize(light);\n\t\n\t\n\t//float id = intersect (ro,rd,t);\n    iMediaIntersection hit = mediaIntersect(ro,rd);\n\n\n    float sph1atmscale = 1.0 / (sph1.w - sph1gnd); \n\n\t\n\tvec3 col = vec3(0.5);\n    float density = 0.0;\n\t\n\tif (hit.tnear > 0.0){\n    \n        //col.g= 0.0; //(hit.tfar - 1.0) * 0.5;\n        //col.b = 0.0;\n        //col.r= 0.;//(hit.tfar - hit.tnear);\n        \n        \n\t\tvec3 pos = ro + hit.tnear*rd;\t//hit position\n    \n        if (hit.mnear == 1u){  // atmospheric hit\n        \n        \n            // calculate atmospheric height of mid-point in order to estimate path air mass.\n            //vec3 mpos = ro + rd * (hit.tnear * 0.5 + hit.tfar * 0.5);\n            //float malt = max(0.0,length(mpos - sph1.xyz) - sph1gnd) * sph1atmscale;\n            //float adensity = 4. * exp(-2.0 * malt);\n            //float athick = adensity * (hit.tfar - hit.tnear);\n            //col.r = adensity;\n            \n            // setup scattering            \n            float mie = phase(dot(rd,light),miePhase) * 0.005; // relative amount of Mie scattering.\n            float rayleigh = phase(dot(rd,light),ralPhase) * 1.4; // relative amount of Rayleigh scattering.\n                \n            // step through atmosphere, cast rays to lightsource to determine shadow.\n            float litDensity = 0.0;\n            float dt = (hit.tfar - hit.tnear) * 0.03;\n            float hh = hash(iTime + dot(rd,vec3(12.65898,37.3516781,17.651651)));  // add a little noise to the start of the ray traversal so smooth out banding.\n            \n            vec3 mieAccum = vec3(0.0);\n            vec3 rayleighAccum = vec3(0.0);\n            vec3 totalInflux = vec3(0.0);\n            \n            for(float t = hit.tnear + hh *0.015; t<hit.tfar-0.00001; t+=dt){\n            \n                vec3 apos = ro + rd * t;  // position along atmosphere ray\n                float alt = (length(apos - sph1.xyz) - sph1gnd) * sph1atmscale;  // altitude above ground (assume sph1 is only sphere in scene)                \n                \n                float lt = iSphere(apos, light, vec4(sph1.xyz,sph1gnd)); // cast ray to sun, intersect with ground. if lt < 0, then this point can see the sun\n                float sliceDensity = dt * airDensity(alt);  // estimate air mass over segment, based on altitude.\n                float litSlice = sliceDensity * (lt<0.0?1.0:0.0);  // ray miss == air mass lit directly by the sun\n\n                // calculate amount of light that has reached this point from the sun.\n                // need to estimate air-mass along the path from apos to intersection (apos + light * tsun)\n                //float tsun = iSphere(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                //float opticalDepthSun = (airDensity(alt) + airDensity((length((apos + light * tsun * 0.5) - sph1.xyz) - sph1gnd) * sph1atmscale)) * tsun;\n                //vec3 influx = absorb(opticalDepthSun, lightcol, absorbCoeff);\n                                \n                // for atmosphere samples getting sunlight directly, calculate lowest altitude.\n                //float tsun = iSphere(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                //float peakAirDensity = airDensity((pointRayDistance(apos,light,sph1.xyz)-sph1gnd) * sph1atmscale);                \n                //vec3 influx = absorb(peakAirDensity*0.001,lightcol,absorbCoeff);\n                \n                vec3 influx = vec3(0.0);\n                \n                // if we are in light, then calculate the amount of absorption along the path to the edge of the atmosphere\n                if (lt<0.0){\n                    // do another raycast towards the sun\n                    float tsun = iSphere2(apos, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n                    float dtl = tsun * 0.1; // keep it rather chunky, don't want to bog down\n                    float densitytosun = 0.0;\n                    \n                    for (float tl = 0.0; tl < tsun; tl += dtl){\n                        vec3 spos = apos + light * tl;  // raycasting from our atmosphere position in the outer loop, out to the edge of the atmosphere.\n                        densitytosun += dtl * airDensity((length(spos - sph1.xyz) - sph1gnd) * sph1atmscale);\n                    }\n                    \n                    influx = absorb(densitytosun,lightcol,absorbCoeff);                    \n                    \n                }\n                else\n                {\n                    influx = vec3(0.0); // todo: maybe fake multiple scattering here\n                }\n                \n                \n                //totalInflux += absorb(density,influx,absorbCoeff);\n                density += sliceDensity;  // accumulate optical depth\n                litDensity += litSlice;  // accumulate directly-it optical depth (for later debug)\n\n                mieAccum += absorb(density,influx * mie * litSlice,absorbCoeff);\n                \n                rayleighAccum += absorb(density,influx * Kr * rayleigh * litSlice,absorbCoeff);\n                \n            }\n        \n            vec3 acol = vec3(0.0);\n            //acol += vec3(0.4,0.05,0.02) * athick;\n            //acol += vec3(0.05,0.4,1.0) * litDensity;  // debug for atmosphere that can see the sun\n            acol += mieAccum;\n            acol += rayleighAccum;\n            //acol += vec3(1.0,0.0,0.0) * mie * 0.1;\n            //acol += vec3(0.01,0.001,0.0) * density;   // fake airglow\n            //acol += vec3(0.0,0.0,1.0) * litDensity;\n\n\n            //float prd = airDensity((pointRayDistance(ro,light,sph1.xyz)-sph1gnd) * sph1atmscale);\n            //acol += vec3(0.0,1.0,0.0) * prd;\n            //acol += absorb(prd,lightcol,absorbCoeff);\n            //col+=acol;\n            \n            //acol = vec3(0.0);\n            //float tsun = iSphere(ro, light, sph1); // cast ray to sun, intersect with edge of atmosphere\n            //acol += vec3(0.0,1.0,0.0) * tsun;\n            //col += acol;\n            \n            \n            if (hit.mfar == 1u){ // atmospheric exit\n                //col = vec3(0.0);\n                col = acol;// + absorb(density,lightcol,absorbCoeff);  // todo: need extinction\n            }\n            else if (hit.mfar == 2u){ // ground hit\n                col = vec3(0.0);\n                col += acol;\n                col += absorb(density,brdfRock(pos,hit.nor,-rd,light,lightcol),absorbCoeff);// + brdfRock(pos,hit.nor,-rd,hit.nor,acol*5.0);                \n            }\n            \n            //col = totalInflux*0.001;\n        }\n\n\t}else{\n        col = vec3(0.0);\n\t}\n\n\n    // fake some sun glow (bloom / mie scattering in eye?)\n    float sunVisible = iSphere(ro, light, vec4(sph1.xyz,sph1gnd)); // cast ray to sun, intersect with ground\n    float mie_eye = phase(dot(rd,light),0.9995) * 0.001; // relative amount of Mie scattering.\n    col += absorb(density,lightcol,absorbCoeff) * mie_eye * (sunVisible > 0.0 ? 0.:1.);\n    \n\t\n\n// reinhardt HDR tonemapping\n\tfloat whitelevel = 2.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n// gamma\t\n\tcol = pow(col,vec3(1.0/2.0));\n\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 151, 171, 171, 243], [245, 245, 265, 265, 345], [347, 366, 389, 389, 428], [431, 450, 476, 476, 878], [881, 881, 903, 903, 1106], [1109, 1109, 1159, 1159, 1322], [1696, 1764, 1845, 1845, 2795], [2799, 2799, 2851, 3064, 3291], [3293, 3293, 3346, 3559, 3786], [3788, 3788, 3828, 3828, 3863], [3865, 3865, 3902, 3941, 3963], [3965, 3965, 3991, 3991, 4020], [4024, 4024, 4098, 4119, 6127], [6372, 6393, 6450, 6450, 6724], [6727, 6727, 6786, 6786, 7000], [7003, 7147, 7181, 7181, 7358], [7360, 7473, 7517, 7517, 7794], [7796, 7796, 7824, 7824, 7948], [7950, 7950, 8007, 8007, 15972]], "test": "untested"}
{"id": "7lSGzm", "name": "Bulls Eyes", "author": "oneshade", "description": "Accidentally created this cool look while experimenting with voronoi patterns.", "tags": ["voronoi", "stripes", "target", "blobbies"], "likes": 8, "viewed": 75, "published": "Public", "date": "1623566494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 6.0 - 3.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat voronoi(in vec2 p, in float smoothness) {\n    vec2 cell = floor(p);\n    float minDist = 1e20;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCell = cell + vec2(i, j);\n            vec2 curPoint = getPoint(curCell);\n            minDist = smin(minDist, length(p - curPoint), smoothness);\n        }\n    }\n\n    return sin(minDist * 40.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(smoothstep(0.5, 0.0, voronoi(uv * 4.0, 0.2) - 0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 101, 101, 204], [206, 295, 321, 321, 407], [409, 434, 463, 463, 745], [747, 747, 794, 794, 1131], [1133, 1133, 1188, 1188, 1330]], "test": "untested"}
{"id": "7lsSzr", "name": "profile", "author": "e_Fediaieva", "description": "t", "tags": ["triangles"], "likes": 0, "viewed": 25, "published": "Public", "date": "1625084865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    float max_of_three(float a, float b, float c)\n    {\n        return max(a,max(b,c));\n    }\n             \n        float L(vec2 p, vec2 P0, vec2 P1)\n        {\n                float a = -(P1.y-P0.y);\n                float b =  (P1.x-P0.x);\n                float d =  P0.x*P1.y- P0.y*P1.x; \n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2)\n    {\n        return  max_of_three(\n                   L(p, P0, P1),\n                   L(p, P1, P2), \n                   L(p, P2, P0)\n                   );   \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//  digitalized my profile                      \n vec2 P[62];\n       P[ 0] = vec2(0.8966 ,    \t0.90457);\n       P[ 1] = vec2(0.83835,     \t0.94749);\n       P[ 2] = vec2(0.74804,     \t0.97120);\n       P[ 3] = vec2(0.60602,     \t0.97572);\n       P[ 4] = vec2(0.4928 ,    \t0.96725);\n       P[ 5] = vec2(0.4038 ,    \t0.95144);\n       P[ 6] = vec2(0.38416,     \t0.92716);\n       P[ 7] = vec2(0.31806,     \t0.88481);\n       P[ 8] = vec2(0.25131,     \t0.83682);\n       P[ 9] = vec2(0.22448,     \t0.80632);\n       P[10] = vec2(0.20484,     \t0.76906);\n       P[11] = vec2(0.18194,     \t0.70920);\n       P[12] = vec2(0.17343,     \t0.67871);\n       P[13] = vec2(0.1623 ,    \t0.67476);\n       P[14] = vec2(0.16492,     \t0.65951);\n       P[15] = vec2(0.17277,     \t0.64766);\n       P[16] = vec2(0.1695 ,    \t0.60757);\n       P[17] = vec2(0.17147,     \t0.58837);\n       P[18] = vec2(0.17081,     \t0.57199);\n       P[19] = vec2(0.1538 ,    \t0.55167);\n       P[20] = vec2(0.11453,     \t0.50536);\n       P[21] = vec2(0.098822,     \t0.48447);\n       P[22] = vec2(0.088351,     \t0.47149);\n       P[23] = vec2(0.085733,     \t0.45850);\n       P[24] = vec2(0.092277,     \t0.44212);\n       P[25] = vec2(0.11584,     \t0.42292);\n       P[26] = vec2(0.13809,     \t0.41728);\n       P[27] = vec2(0.14529,     \t0.40599);\n       P[28] = vec2(0.14725,     \t0.39074);\n       P[29] = vec2(0.13743,     \t0.38340);\n       P[30] = vec2(0.12696,     \t0.37719);\n       P[31] = vec2(0.13089,     \t0.36533);\n       P[32] = vec2(0.14202,     \t0.35347);\n       P[33] = vec2(0.14463,     \t0.34557);\n       P[34] = vec2(0.13874,     \t0.33540);\n       P[35] = vec2(0.13416,     \t0.31903);\n       P[36] = vec2(0.14332,     \t0.30491);   \n       P[37] = vec2(0.15641,     \t0.29814);\n       P[38] = vec2(0.16099,     \t0.28176);\n       P[39] = vec2(0.15903,     \t0.25861);\n       P[40] = vec2(0.1538 ,    \t0.24111);\n       P[41] = vec2(0.15641,     \t0.22021);\n       P[42] = vec2(0.1767 ,    \t0.19989);\n       P[43] = vec2(0.20681,     \t0.18521);\n       P[44] = vec2(0.25785,     \t0.17956);\n       P[45] = vec2(0.31872,     \t0.18012);   \n       P[46] = vec2(0.37435,     \t0.17335);\n       P[47] = vec2(0.41623,     \t0.13043);\n       P[48] = vec2(0.44372,     \t0.098814);\n       P[49] = vec2(0.45681,     \t0.061547);\n       P[50] = vec2(0.47055,     \t0.023151);\n       P[51] = vec2(0.48429,     \t-0.0062112);\n   // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y ;\n     \n     float mx = m.x * iResolution.x/iResolution.y;\n     float my = m.y ;\n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   \n\n      float  z = 1.0e25; //infinity?\n              for(int i=0;i<51-3;i++)\n                z = min(z, T(p,  P[i],P[i+1], P[i+3]) );   \n       float     f = 1.25/z; \n\n    // Time varying pixel color\n               vec3 col = vec3(1.0, 1.0, 1.0);\n                if(f >= 0.0)col.g = sin(iTime/10.0);\n                   else     col.r = f;\n                \n\n    // Output to screen\n                 fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 55, 55, 93], [116, 116, 159, 159, 417], [427, 427, 475, 475, 635], [637, 637, 694, 743, 3885]], "test": "untested"}
{"id": "7lX3Ds", "name": "Abstract triangle", "author": "z0rg", "description": "Description", "tags": ["3d", "triangle", "abstract", "pattern"], "likes": 8, "viewed": 152, "published": "Public API", "date": "1623956191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n#define PI 3.14159265\n\nfloat _bbox(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x,max(l.y,l.z));\n}\n\nvec2 map(vec3 p)\n{\n  float t = iTime*.01;\n  float shp = -p.y;//-texture2D(noise, p.xz*.01+vec2(sin(t),cos(t))).x*.05;\n  p+=vec3(0.,-.75,0.);\n  p.yz*= r2d(PI*.2);\n  p.xy*= r2d(PI*.25);\n\n  shp = min(shp,_bbox(p,vec3(1.)));\n  return vec2(shp,0.);\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n\n  vec3 ro = vec3(0.,-5.,-1.);\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n\n  vec3 res = trace(ro,rd,32);\n  if (res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    vec3 lpos = vec3(sin(iTime),-1./3.,cos(iTime))*10.;\n    vec3 ldir = lpos-p;\n    vec3 nldir = normalize(ldir);\n    vec3 h = normalize(rd-ldir);\n    col = vec3(1.)*pow(sat(-dot(n,h)),.75);\n    vec3 ressh = trace(p+n*0.02,nldir,64);\n    if (ressh.y >0.)\n    {\n\n       col*= .75;\n    }\n    col += vec3(.4,.5,.7)*.5;\n    float dao = 0.6;\n    col *= sat(pow(sat(map(p+n*dao).x/dao),.5)+.1);\n    col+= pow(1.-sat(-dot(rd,n)),.25)*vec3(1.,.5,.7).yzx*.25;\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  uv *= 2.;\n  vec3 col = rdr(uv);\n  vec3 o = col;\n  vec3 inv = 1.-sat(col.zyx);\n  inv = mix(inv,1.-inv,sat((uv.x-uv.y+sin((uv.y+uv.x)*5.+iTime*2.)*.1)*400.));\n  col = mix(col,inv,1.-sat((sin((uv.y+uv.x)*20.)+.4)*400.));\n  col = pow(col,vec3(.5));\n  col = mix(col,o,sat((length(uv)-.4)*400.));\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lX3Ds.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 427, 445, 445, 500], [524, 524, 553, 553, 608], [610, 610, 628, 628, 855], [857, 857, 898, 898, 1082], [1084, 1084, 1115, 1115, 1263], [1265, 1265, 1296, 1296, 1404], [1406, 1406, 1425, 1425, 2147], [2149, 2149, 2206, 2206, 2600]], "test": "untested"}
{"id": "7lXGW2", "name": "shpers_and_lights_ex1", "author": "qt1", "description": "My first shader - based on https://www.shadertoy.com/view/NlX3R2\n\nAn eclectic mix of 2d and 3d animation, light sources, geometry and sound\n\n", "tags": ["course"], "likes": 3, "viewed": 34, "published": "Public", "date": "1622847366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nSphere spheres[4];\nLight  lights[2];\nint numLights = 2;\nint numSpheres = 2;\n\nmat3 zRotation(float angle) {\n    return mat3(cos(angle),  sin(angle), 0,\n                -sin(angle), cos(angle), 0,\n                0,           0,          1);\n}\n\nvec3 tranformAroundCenter(mat3 transform, vec3 center, vec3 point) {\n    return center + transform * (point - center);\n}\n\n\nvoid makeScene(int f) {\n    spheres[0] = Sphere(0.5, vec3(0, 0, -6), vec3(1, 1, 0.2));\n    spheres[1] = Sphere(0.24, vec3(1, 1, -6), vec3(1, 0.2, 1));\n    //lights[0] = Light(vec3(-1.0, 0.0, -4.0), vec3(1, 1, 1));\n    lights[0] = Light(vec3(10.0*sin(float(f)*0.03), 0.0, 0.0), vec3(1, 0.5, 0));\n    lights[1] = Light(vec3(0.0, 10.0*sin(float(f)*0.01), 0.0), vec3(0, 0.5, 1));\n    numLights = 2;\n    \n    mat3 r = zRotation(float(f)*0.1);\n    \n    spheres[1].center = tranformAroundCenter(r, spheres[0].center, spheres[1].center);\n}\n\nint numSamples = 1;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float minT = 1000000.0;\n       int minI = 0;\n       \n       for(int i=0; i<numSpheres; i++) {\n           Sphere sphere = spheres[i];\n\n           float t = raySphereIntersect(ray, sphere);\n           if (t < minT) {\n               // TBD: verify hit is behind the screen\n               minT = t;\n               minI = i;\n           }\n       }\n       \n       if(minT<1000000.0) {\n           Sphere sphere = spheres[minI];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float rayCAngle = dot(norm, hitPointToEye);\n           for(int l=0;l<numLights; l++) {\n               vec3 hitPointToLight = normalize(lights[l].location-hit);         \n               float lightCAngle = dot(hitPointToLight,norm);          \n               if(lightCAngle>0.0) { /* back is black */\n                  samp = samp + rayCAngle*lightCAngle*(sphere.color * lights[l].color);\n               }\n           }\n       }\n       \n       // 2D overlay\n       //float ampl = 2.0*texture(iChannel0,vec2(0.8,.25)).x;\n       vec2 c = vec2(0.0, 0.0);\n       vec2 xy = vec2(x,y);\n       vec2 dxy = xy-c;\n       float r = length(dxy);\n       float a = atan(dxy.y, dxy.x)+3.1415;\n       float signal = 2.0*texture(iChannel0,vec2(a/2.0/3.1415, 0.75)).x;\n       float R = 0.5;\n       \n       /*spheres[1].radius = wave * 0.24; */\n       if(abs(signal*r-R)< 0.01)\n           samp += vec3(signal*0.5, r, float(iFrame%100)/100.0);\n   }\n   \n   \n/*   float wave = texelFetch( iChannel0, ivec2(float(512), 0),0 ).x;\n   spheres[1].radius = wave * 0.24; \n*/\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 83, 99, 99, 146], [497, 537, 593, 593, 1077], [1157, 1157, 1186, 1186, 1321], [1323, 1323, 1391, 1391, 1443], [1446, 1446, 1469, 1469, 1977], [2001, 2080, 2135, 2293, 4750]], "test": "untested"}
{"id": "7sfXDf", "name": "RmpRefract", "author": "sashasan", "description": "Reverse raytracing, ray march physically correct refraction.\nShow back surface. N beam bouncing depth", "tags": ["raytracing", "ray", "beam", "depth", "surface", "recursion", "march", "bouncing", "flip", "fraction", "physically", "back", "reverse", "correctre"], "likes": 11, "viewed": 241, "published": "Public", "date": "1622908401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright © 2021 Sashasan https://www.facebook.com/profile.php?id=100005029953825\n// Reverse raytracing ray march physically correct refraction. Show back surface.\n// There are lots of tips and forms here - https://iquilezles.org\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float NearP = 0.4;\nconst float FarP = 96.0;\nconst float MinD = 0.002;\nconst float NminR = 0.04;\nconst float NmaxR = 96.0;\nconst float stepB = 0.5;\n\nconst float kr_air = 1.0002926;\nconst float kr_glass = 1.4874;\n\nvec3\tlp;\n\n#define itime iTime*0.05\n\nstruct res\n{\n\tfloat\td;\n\tint\t\tm;\n};\n\n\n//func sdf\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p)-r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n\tp.xy = mat2x2(cos(itime),sin(itime),-sin(itime),cos(itime))*p.xy;\n\tvec3 q = abs(p);\n\treturn max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n\tp.xz = mat2x2(cos(-itime),sin(-itime),-sin(-itime),cos(itime))*p.xz;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//refract func\nvec3 refractk(vec3 I, vec3 N, float eta) {\n\tvec3 R;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n\treturn\tR = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n// to take negative steps into account, compare the absolute values\nres opU( res d1, res d2 )\n{\n\tif (abs(d1.d) < abs(d2.d)){\n\t\td2=d1;\n\t}\n\treturn d2;\n}\nres sceneSDF(vec3 p)\n{\n\tres oh,th;\n\tvec3 varp;\n\toh=res(sdPlane(p+0.5),1);\n\n\tvarp = p-vec3(-1.0+fract(itime*1.0)*14.0*(1.0-fract(itime*1.0)),fract(itime*0.1)*8.0*(1.0-fract(itime*0.1)),-1.0);\n\tth=res(sdSphere(varp,1.0),2);\n\toh=opU(oh,th);\n\n\tvarp = p-lp;\n\tth=res(sdSphere(varp,0.4),3);\n\toh=opU(oh,th);\n\n\tvarp = p-vec3(-8.0+fract(itime*1.0)*40.0*(1.0-fract(itime*1.0)),fract(itime*3.0)*10.0*(1.0-fract(itime*3.0)),-1.0);\n\tth=res(sdCapsule(varp,vec3(3.0,0.0,0.0),vec3(3.0,3.0,-1.0),0.05),4);\n\toh=opU(oh,th);\n    \n    varp = p-vec3(-2.5,fract(itime*0.1)*20.0*(1.0-fract(itime*0.1)),-1.5);\n\tth=res(sdTriPrism(varp,vec2(1.0,2.0)),2);\n\toh=opU(oh,th);\n    \n    varp = p-vec3(3.0,fract(itime*0.1)*15.0*(1.0-fract(itime*0.1)),-3.0);\n\tth=res(sdBox(varp,vec3(0.5,1.5,1.2)) ,2);\n\toh=opU(oh,th);\n    \n\treturn oh;\n}\n//Rey March + Neg. value\nres RayMarch(vec3 ro, vec3 rd, float Min_Dist, float Max_Dist) {\n\tres t0 = res(Min_Dist,0);\n\tres h;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS && t0.d<=Max_Dist; i++) {\n\t\th = sceneSDF(ro + t0.d * rd);\n\t\tif (abs(h.d) < MinD) {\n\t\t\tt0.m=h.m;\n\t\t\tbreak;\n\t\t}\n\t\tt0.d=abs(h.d)*stepB+t0.d;\n\t}\n\tif (t0.d > Max_Dist) {t0.m=0;t0.d=Max_Dist;}\n\treturn t0;\n}\n//MatView\nvec3 RayD(float fieldOfView, vec2 size, vec2 tc0) {\n\tvec2 xy = tc0 - size / 2.0;\n\tfloat z = size.y / tan(radians(fieldOfView) / 2.0);\n\treturn normalize(vec3(xy, -z));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n//GetNormal\nvec3 GradeSdfNormal(vec3 p) {\n\treturn normalize(vec3(\tsceneSDF(vec3(p.x + MinD, p.y, p.z)).d  - sceneSDF(vec3(p.x - MinD, p.y, p.z)).d,\n\t\t\t\t\t\t\tsceneSDF(vec3(p.x, p.y + MinD, p.z)).d  - sceneSDF(vec3(p.x, p.y - MinD, p.z)).d,\n\t\t\t\t\t\t\tsceneSDF(vec3(p.x, p.y, p.z  + MinD)).d - sceneSDF(vec3(p.x, p.y, p.z - MinD)).d));\n}\nvec3 RayRr (in vec3 ro, in vec3 rd, int dr) {\n\tvec3 n,col,r_d,io;\n\tcol=vec3(0.0);\n\tres t0 = RayMarch(ro,rd,NearP,FarP);\n\tfor (int i = 0; i < dr; i++) {\n\t\tif (t0.m==1) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n            if (dot(rd,n)>=0.0){n=-n;}\n\t\t\trd = normalize(lp-ro);\n\t\t\tr_d = vec3(dot(rd,n)*0.9);\n\t\t\tfloat f = mod( floor(2.0*ro.z) + floor(2.0*ro.x), 2.0);\n\t\t\tcol -= (vec3( 0.5*f)+vec3(0.2,0.2,0.2))*(1.0-r_d);\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse if (t0.m==2) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n\t\t\tif (dot(rd,n)<0.0){io.x=kr_air/kr_glass;}else{io.x=kr_glass/kr_air;n=-n;}\n\t\t\tr_d = vec3(dot(rd,n)*0.1);\n\t\t\tcol -= vec3(0.1,0.1,0.01)*(1.0-r_d);\n            vec3 rd2=rd;\n\t\t\trd = refract(rd,n,io.x);\n            if (rd==vec3(0.0)){rd=reflect(rd2,n);}\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse if (t0.m==3) {\n\t\t\tcol += vec3(1.0,1.0,0.9);\n\t\t\tbreak;\n\t\t}\n\t\tif (t0.m==4) {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tn = GradeSdfNormal(ro);\n\t\t\tif (dot(rd,n)>=0.0){n=-n;}\n\t\t\trd = normalize(lp-ro);\n\t\t\tr_d = vec3(dot(rd,n)*0.9);\n\t\t\tcol -= (vec3(0.1,0.3,0.2))*(1.0-r_d);;\n\t\t\tt0 = RayMarch(ro,rd,NminR,NmaxR);\n            continue;\n\t\t}\n\t\telse {\n\t\t\tro = ro + t0.d * rd;\n\t\t\tfloat sun =dot(rd,normalize(ro-lp));\n\t\t\tvec3 clo=0.9*(sun*(vec3(0.65,0.75,0.9)-(rd.y*0.5))) ;\n\t\t\tcol+=clo.xyz-vec3(0.01,0.01,0.01);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\n\n\treturn clamp(col,0.0,1.0) ;\n}\nvoid mainImage( out vec4 oC0, in vec2 tc0 ) \n{\n\tvec3 col;\n\tlp = vec3(10.0 * sin(itime*2.5),4.0,10.0 * cos(itime*2.5));\n\t// camera\n\tvec2 s_uv = (2.0*tc0-iResolution.xy)/iResolution.y;\n\tfloat cl2 = sin(0.5*itime);\n\tfloat an = 10.0*iMouse.x/iResolution.x+3.57 + 3.7*sin(0.15*itime);\n\tvec3  ta = vec3( 0.0, 0.35, cl2);\n\tvec3  ro = ta + vec3( 10.0*cos(an),2.250+10.0*cos(4.0*iMouse.y/iResolution.y), -10.0*sin(an)+cos(4.0*iMouse.y/iResolution.y) );\n\tfloat ti = fract(itime-0.15);\n\tti = 4.0*ti*(1.0-ti);\n\tta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl2);\n\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\t// ray direction\n\tvec3 rd = ca * normalize( vec3(s_uv,1.8) );\n\t//Render\n\tcol = RayRr(ro,rd,10);\n\n\toC0 = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[562, 573, 598, 598, 613], [614, 614, 649, 649, 672], [673, 673, 725, 725, 843], [844, 844, 880, 880, 1028], [1029, 1029, 1060, 1060, 1215], [1216, 1231, 1273, 1273, 1399], [1400, 1468, 1495, 1495, 1550], [1551, 1551, 1573, 1573, 2350], [2351, 2376, 2440, 2440, 2716], [2717, 2727, 2778, 2778, 2895], [2896, 2896, 2948, 2948, 3122], [3123, 3135, 3164, 3164, 3452], [3453, 3453, 3498, 3498, 4874], [4875, 4875, 4921, 4921, 5591]], "test": "untested"}
{"id": "7t23Rz", "name": "Fork COVID VictoryXR 763", "author": "VictoryXR", "description": "leave a comment if you want to help to improve this shader, I will appreciate it. ", "tags": ["fft", "audio", "virus", "cineshader", "coronavirus"], "likes": 1, "viewed": 928, "published": "Public API", "date": "1624069284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//Music: You're Not Leaving by La Josephine\n//https://soundcloud.com/lajosephine/youre-not-leaving\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat snoise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res * 2.0 - 1.0;\n}\n\n    \n\nmat2 Rot(float a){\n\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\nvec3 Transform ( vec3 p ,float time){\n    p.z -= time * .5;\n\n    \n    p += sin(p.x+p.z+time)*.03\n        +sin(p.y+time)*.05\n        +cos(p.x+p.z+time)*.03\n        -cos(p.x+time)*.03\n        +cos(p.y+time)*.05;\n        \n    //p.xy *= Rot(time*.15);\n    return p;\n    \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat line( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n   \n    float h = clamp( 0.5 + 0.5*(a-b)/k, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*k;\n}\nvec2 opUMin( vec2 a, vec2 b, float k ) { \n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); \n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), (a.x<b.x) ? a.y : b.y ); \n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n        float a=1./(1.+n.y);\n        float b=-n.x*n.z*a;\n        b1=vec3(1.-n.x*n.x*a,-n.x,b);\n        b2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nvec3 Background ( vec3 rd){\n    vec3 col = vec3(0);\n    float y = abs(rd.z)*.5+.5;\n    col += y*vec3(1,0.58,0.03);\n    return col;\n}\nvec3 opRep( in vec3 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\nvec2 e = vec2(.01, 0);\n\n\n\nvec2 Virus( vec3 p, float atime){\n    \n   \n    \n    p = p - vec3(sin(atime+2.0)*.1,sin(atime)*.1+sin(atime)*.02,0);\n    float t=mod(atime,1.5)/1.5;\n    p*=1.-0.05*clamp(sin(6.*t)*exp(-t*4.),-2.,2.);\n\n    p.xy *= Rot(0.04*atime);\n    p.xz *= Rot(0.06*atime);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*p.y;\n    \n    \n    \n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),20.);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*fibo.w*1.;\n    \n    float cvwidth = .54 +(- (sin(90.*p.x)*cos(40.*p.z)*sin(90.*p.y))*.06\n    - (cos(100.*p.x)*sin(100.*p.z)*sin(40.*p.y))*.06\n     - (sin(100.*p.y)*sin(100.*p.z)*sin(40.*p.x))*.06)*0.09;\n    \n    float sphere = sdSphere(p,cvwidth);\n     \n    vec2 d0Vector= vec2(sphere,2.0);\n \n   \n    \n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n\n\n   \n   \n   \n    q=q-vec3(0,-cvwidth+.08,0);\n    \n    float d1= sdRoundCone( q, 0.02,0.03 , 0.1);\n    \n    q=q-vec3(-.03,.12,0.0);\n    d1 = smin(sdSphere(q, 0.002)-0.003*snoise(q*83.),d1,.1);\n    \n  \n               \n    \n    vec2 d1Vector=vec2(d1,3.0);\n    \n    d1 = min(sdSphere(q-vec3(-.1,-.11,0.05), 0.02),\n             sdSphere(q-vec3(.1,-.11,.0), 0.02));\n    \n    d0Vector=opUMin( d0Vector,vec2(d1,4.0),0.02);\n    \n    d0Vector=opUMin( d0Vector,d1Vector,0.02);\n    \n    \n    return d0Vector;\n   \n}\n\nfloat cell(vec3 p, float atime){\n\n    vec3 c = mod(abs(p),1.5) - .75;\n    c.y += sin(c.z) * .15;\n    c.xy *= Rot( c.z*.95) ;\n\n    \n    float r = 0.1;\n   \n   \n    return sdSphere(c,r)*.8;\n}\n\nvec2 Bloodstream (vec3 p, float atime){\n    \n    p = p - vec3(snoise(p)*sin(atime)*.2,sin(atime)*snoise(p)*0.2,0.);\n    p.z += atime * .9;\n    p.xy *= Rot( p.z*.5) ;\n    \n    \n    if (abs(p.x) > 3. || abs(p.y) > 3.) {\n       return vec2(100.,-1.0);\n    }\n    \n\n    \n    return vec2(cell( p,  atime),5.0);\n}\n\n\nvec2 map(in vec3 p,float atime ){\n   \n\n    vec2 cv=Virus(p,atime);\n    vec2 b = Bloodstream (p,  atime);\n    \n    p = Transform(p,atime);\n    \n    float g1 = sdGyroid(p,1.3,.06,1.4);\n\n\n    float g2 = sdGyroid(p,10.76,.03,.3);\n    float g3 = sdGyroid(p,20.76,.03,.3);\n    float g4 = sdGyroid(p,35.76,.03,.3);\n    float g5 = sdGyroid(p,60.76,.03,.3);\n    \n    \n    g1 += g2 * .3 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    g1 -= g3 * .2;\n    g1 += g4 * .1;\n    g1 += g5 * .2;\n    \n    \n    float tunel = smax(PI*.9 - length(p.xy), .75-g1, 1.) - abs(1.-g1)*.175;\n    \n    tunel += g2 * .2 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    tunel -= g3 * .2;\n    tunel += g4 * .1;\n    tunel += g5 * .2;\n     \n    \n    g1 = smin(tunel, g1,.9); \n    \n    \n    vec2 vg1 = vec2(g1,1.);\n    \n    b = opUMin( b,vg1,.31);\n    return opU( cv, b);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec2 RayMarching(vec3 ro, vec3 rd,float time){\n\n\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.;\n    float tmax = 100.0;  \n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( abs(h.x)<(.001*t))\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n \nvec3 calcNormal(in vec3 pos,float time,float quality){\n    vec3 n = vec3(0.0);\n   for( int i=min(0,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+quality*e,time).x;\n    }    \n    return normalize(n);\n}\n\n\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{ \n    \n    \n    vec3 col = vec3(0.);\n        \n    vec2 res = RayMarching(ro,rd,time);\n    if(res.y>0.5){\n        \n        float fft  = texelFetch( iChannel0, ivec2(3.,0.75), 0 ).x;\n        fft = smoothstep( 0.8, 1., fft )*2.;\n\n        float fft1  = texelFetch( iChannel0, ivec2(5.,0.75), 0 ).x; \n        fft1 = smoothstep( 0.9, 1., fft1 )*1.5;\n\n        float fft2  = texelFetch( iChannel0, ivec2(6.,0.75), 0 ).x; \n        fft2 = smoothstep( 0.9, 1., fft2 );    \n\n        float fft3  = texelFetch( iChannel0, ivec2(7.,0.75), 0 ).x; \n        fft3 = smoothstep( 0.9, 1., fft3 )*2.2;\n\n        float flash =  texture( iChannel0, vec2(512, 0.25)).x;\n        flash = smoothstep(.45, .8, flash )*20.;\n        flash = clamp(flash,0.,1.);\n        \n        float d = res.x;\n        vec3 pos = ro + rd*d;\n        \n        \n        float quality = res.y < 1.5 ?  0.016 : 0.0025;\n        \n        vec3 nor = normalize(e.xyy*map(pos+e.xyy,time).x\n                     +e.yyx*map(pos+e.yyx,time).x\n                     +e.yxy*map(pos+e.yxy,time).x\n                     +e.xxx*map(pos+e.xxx,time).x); \n        \n         vec3 ref = reflect(rd,nor);\n        \n        vec3 light_pos = normalize(  vec3( 0., .5, 0.2 ));\n        \n        vec3 specular = vec3( max( .30, dot( light_pos, ref ) ) );\n        specular = pow( specular, vec3( 100.0 ) );\n        \n       col += vec3(1,.4,.1)* 20. * specular; \n         \n        vec3 lin = vec3(0.0);\n        \n        vec3  sun_lig = light_pos;\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0,1. );\n        \n        pos = Transform(pos,time);\n        if(res.y > 4.5) \n        { \n        \n            col += sun_dif *vec3(1.5,0.,.0);\n            \n        }\n        else if(res.y > 3.5)\n        {\n            col += vec3(1.00,0.24,0.0)*sun_dif;\n        }\n        else if(res.y > 2.5)\n        {\n            col += vec3(.79,0.0,0.0)*sun_dif;\n        }\n        else if(res.y > 1.5) \n        {\n            col += sun_dif;\n        }\n        else if(res.y > 0.5) \n        {\n            col += sun_dif *vec3(1.,0.,.0);\n            \n            float g2 = sdGyroid(pos,10.76,.03,.3);\n            col *= smoothstep(-.1,.1,g2);\n            \n            float beat = abs((g2 * .2 * sin(time*1.53) * cos(time*2.34) * pos.y));\n            col += beat*vec3(1.,0.031,.02);\n            \n            float crackWidth = -.019 + smoothstep(0.,-.1,nor.y)*.04;\n            float cracks = smoothstep(crackWidth,-.043,g2);\n            cracks *= .5 * smoothstep(.2,.5,nor.y) *.5 +5.5;\n            col += cracks*vec3(0.7,0.0,.0)*beat *15.;\n            \n            \n            float speed = 1.5;\n            float g5 = sdGyroid(pos+vec3(cos(time*speed),sin(time*speed),time), 1.75, .705, 0.);\n            g5 *= sdGyroid(pos+vec3(sin(time*speed),cos(time*speed),time), 1., 1.9, .1);\n            col += g5*vec3(.4, .0, .0);\n            \n     \n        }\n        \n        \n        \n        \n         \n       \n        \n       \n        //col *= vec3(fft);\n        \n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcOcclusion( pos, sun_lig, time );\n        lin += sun_dif*vec3(1,.4,.1)*sun_sha;\n        \n        \n        \n        float ks = .5;\n        float sun_spe = ks*\n            pow(clamp(dot(nor,sun_hal),0.0,1.0),9.0)\n            *sun_dif\n            *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        lin += sky_dif*vec3(1.0,0.5,.5);\n        \n        col *= lin;\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n\n\n\n        vec3 fog = (abs(rd.z)*.5+.5)\n            *(\n                + (vec3(1.0,0.2,0.0))\n                + (vec3(1.0) * flash * 2.)\n                + (vec3(2.0,0.5,0.0) * fft1 * 1.3)\n            \t+ (vec3(1.0,0.0,0.0) * fft2 * 1.3)\n            \t+ (vec3(1.0,0.0,0.1) * fft3 * 1.3)\n             )\n            ;\n       \n        \n    \n\t\t\n        fog = (fog*.5+.5);\n        \n        col = mix(col, fog,smoothstep(0.,10.,d));\n        col *= mix(Background(rd), fog,smoothstep(0.,10.,d));\n        \n    }\n    \n        \n    return vec4(col,res.x);\n}\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    \n    vec3 ro = vec3(0, 0, 3.);\n    \n    ro.xy *= Rot(sin(t*.1)*PI);\n    ro.xz *= Rot(sin(t*.1)*PI);\n    ro.yz *= Rot(sin(t*.1)*PI);\n    \n    \n    vec3 ta = vec3(0.0,0.,0.);\n    vec3 rd = GetRayDir(uv, ro, ta, .6);\n    \n    vec4 res = render( ro, rd, t );\n        \n    vec3 col = res.xyz ;\n    col = clamp(col, 0.0,1.0);\n    \n    \n    vec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), .5 );\n    \n    \n    col = pow(col,vec3(0.4545));\n    \n    float depth = min(10.0, res.w);\n    fragColor = vec4(col,1.0 - (depth - 0.5) / 2.0);\n    \n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": "MtXXzM", "previewfilepath": "https://soundcloud.com/lajosephine/youre-not-leaving", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lajosephine/youre-not-leaving", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t23Rz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[113, 279, 302, 302, 341], [343, 343, 370, 382, 787], [795, 795, 813, 813, 887], [888, 888, 925, 925, 1156], [1158, 1158, 1187, 1187, 1271], [1273, 1273, 1339, 1339, 1421], [1423, 1423, 1458, 1458, 1484], [1487, 1487, 1545, 1545, 1809], [1811, 1811, 1851, 1851, 1910], [1914, 1914, 1953, 1953, 2036], [2038, 2038, 2077, 2077, 2171], [2172, 2172, 2212, 2212, 2347], [2349, 2349, 2379, 2379, 2415], [2486, 2486, 2533, 2533, 2776], [2778, 2778, 2807, 2807, 3736], [3738, 3738, 3783, 3783, 3823], [3826, 3826, 3853, 3853, 3958], [3959, 3959, 3996, 3996, 4031], [4058, 4058, 4091, 4091, 5411], [5413, 5413, 5445, 5445, 5601], [5603, 5603, 5642, 5642, 5909], [5912, 5912, 5945, 5945, 6749], [6751, 6751, 6812, 6812, 7105], [7107, 7107, 7153, 7153, 7496], [7499, 7499, 7553, 7553, 7770], [7774, 7774, 7825, 7825, 11893], [11897, 11897, 11947, 11947, 12142], [12144, 12144, 12199, 12199, 12906]], "test": "untested"}
{"id": "7t2GRt", "name": "Level map exploration", "author": "kosua20", "description": "This is a small experiment in rendering isolines. After posting a first hacky version, I've stumbled upon https://www.shadertoy.com/view/Ms2XWc (posted by iapafoto the same day :)) referencing IQ's article on the topic of smooth isoline rendering.", "tags": ["2d", "lines", "map", "isolines", "level"], "likes": 6, "viewed": 189, "published": "Public API", "date": "1624530950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define HAS_DERIV\n\n#define BACKGROUND_INTENSITY 0.0\n#define THEME_COLOR vec3(0.670,0.513,0.007 )\n\n// Perlin\nfloat cnoise(vec3 P);\n\n// Wrapper (not really needed)\nfloat delta(float v, float fallback){\n#ifndef HAS_DERIV\n    return fallback;\n#else\n    return 2.0 * length(vec2(dFdx(v), dFdy(v)));\n#endif\n}\n\n// http://iquilezles.org/www/articles/distance/distance.htm\nfloat smoothLine(float val, float scale, float thickness, float fallback){\n    // Compute gradient using continuous val.\n    float deltaVal = delta(val, fallback);\n    // Line frequency.\n    float scaledVal = mod(val, scale);\n    float finalVal = abs(scaledVal) / max(deltaVal, 0.001) - thickness;\n    return 1.0 - smoothstep(0.1, 0.9, finalVal);\n}\n\nvec3 evaluate(vec2 ndc, float time, float ratio){\n    // Colors.\n    vec3 themeColor = THEME_COLOR;\n    vec3 backgroundColor = vec3(BACKGROUND_INTENSITY);\n    vec3 foregroundColor = vec3(1.0 - BACKGROUND_INTENSITY);\n\n    // Scaled UVs.\n    vec2 rawUV = 0.5 * ndc + 0.5;\n    vec2 ratioUV = 0.5 * vec2(ratio, 1.0) * ndc + 0.5;\n    vec2 gridUV = ratioUV + 0.5;\n\n    // Isolines landscape.\n    float noise = cnoise(vec3(3.0 * ratioUV, 0.000025 * time));\n    float mainLevelLine = smoothLine(noise, 0.4, 0.8, 0.015);\n    float secondLevelLine = smoothLine(noise, 0.1, 0.1, 0.01);\n    float intensityLines = max(mainLevelLine, secondLevelLine);\n\n    // Add a regular grid.\n    float gridXLine = smoothLine(gridUV.x, 0.35, 0.5, 0.005);\n    float gridYLine = smoothLine(gridUV.y, 0.35, 0.5, 0.005);\n    float intensityGrid = max(gridYLine, gridXLine);\n\n    // Extra point at random location.\n    // (could use proper disk SDF instead of a thick line circle)\n    float motionTime = 0.0001 * time;\n    float nx = cnoise(-vec3(8.2, 9.4, motionTime));\n    float ny = cnoise(-vec3(87.8, 13.1, motionTime));\n    vec2 position = 0.5 * 1.75 * vec2(nx, ny) + 0.5;\n    float dist = length(ratioUV - position);\n    float intensityPoint = smoothLine(dist, 10000.0 /* cheat, no repetition needed */, 4.0, 0.005);\n\n    // Combine everything.\n    float themeColorIntensity = max(intensityLines, intensityGrid);\n    float foregroundColorIntensity = intensityPoint;\n\n    vec3 color = mix(backgroundColor, themeColor, themeColorIntensity);\n    color = mix(color, foregroundColor, foregroundColorIntensity);\n\n    // Vignetting.\n    float attenuation = smoothstep(0.6, 1.0, length(rawUV - 0.5)*2.0);\n    return mix(color, backgroundColor, attenuation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert shadertoy inputs to my framework inputs.\n    vec2 ndc = 2.0 * fragCoord/iResolution.xy - 1.0;\n    float time = iTime * 1000.0f;\n    float ratio = iResolution.x/iResolution.y;\n   \n    fragColor.rgb = evaluate(ndc, time, ratio);\n    fragColor.a = 1.0;\n}\n\n// Perlin noise: Copyright (C) 2011-2016 by Stefan Gustavson \n// Licence: https://github.com/stegu/webgl-noise/blob/master/LICENSE\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec3 P);\n// Classic Perlin noise\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 163, 200, 200, 303], [305, 365, 439, 485, 713], [715, 715, 764, 779, 2441], [2443, 2443, 2500, 2556, 2767], [2769, 2900, 2921, 2921, 2968], [2970, 2970, 2991, 2991, 3038], [3040, 3040, 3061, 3061, 3096], [3098, 3098, 3126, 3126, 3176], [3178, 3178, 3197, 3197, 3235], [3259, 3283, 3305, 3305, 5717]], "test": "untested"}
{"id": "7t2GWc", "name": "IFS with Field of space", "author": "yasuo", "description": "IFS with Field of space", "tags": ["ifs"], "likes": 3, "viewed": 293, "published": "Public API", "date": "1624895212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_REFLECT 10\n\nconst float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 combine(vec2 val1, vec2 val2, float k){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    res1.x = smin(val2.x,val1.x,k);\n    res2.x = smin(val1.x,val2.x,k);\n    return (val1.x < val2.x)?res1:res2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n\nvec2 GetDist(vec3 p) {\n    float t = iTime*0.1;\n    \n    mat3 rot = matRotateZ(radians(-25.0)+t*2.0);\n    vec3 prevP = p*rot;\n\n    float d = 10000.0;\n    p.z = mod(p.z,5.)-2.5;\n    float maskd = sdBox(p,vec3(3.0,3.0,5.0));\n    \n    p = prevP;\n    p.z+=iTime*5.0;\n    p.xy = mod(p.xy,9.)-4.5;\n    p.z = mod(p.z,8.)-4.;\n    \n    mat3 rot2 = matRotateX(radians(-25.0)+t)*matRotateY(radians(30.0)+t);\n    \n    for(float i = 1.; i<=5.; i++){\n        p = abs(p);\n        p -= (0.5)*i;\n        p *= rot2;\n        d = min(d,sdBoundingBox(p, vec3(1.9,1.9,2.),.05));\n    }\n    \n    d = max(maskd,d);\n    p = prevP;\n    d = max(sdBox(p,vec3(5.0,5.0,19.0)),d);\n    \n    vec2 res = vec2(d, MATERIAL_REFLECT);\n        \n    vec2 model = res;\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    vec3 col = r;\n    \n    float nn = cnoise(p.xy*3.0);\n    col += nn*5.0;\n    float k = r.y*2.5+2.5;\n    col = mix(col*vec3(0.5),vec3(0.5),k);\n    return col;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -5.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(mod(iTime,20.0)<17.0){\n        ro.xz *= Rot(iTime*.1+1.0);\n    } else {\n        ro.xz *= Rot(radians(0.0));\n    }\n    \n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.5);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        \n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            col = diffuseMaterial(n,vec3(1.0));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.3545) );\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 711, 730, 730, 766], [767, 767, 788, 788, 825], [827, 827, 848, 848, 1925], [1927, 1927, 1968, 1968, 2059], [2061, 2061, 2105, 2105, 2263], [2265, 2265, 2296, 2296, 2383], [2385, 2385, 2410, 2410, 2429], [2430, 2430, 2477, 2477, 2850], [2852, 2852, 2874, 2874, 3598], [3600, 3600, 3645, 3645, 3905], [3907, 3907, 3931, 3931, 4132], [4134, 4134, 4181, 4181, 4371], [4373, 4373, 4415, 4415, 4610], [4612, 4612, 4652, 4652, 4735], [4737, 4737, 4794, 4794, 5762]], "test": "untested"}
{"id": "7t2Gz3", "name": "Fork 2d signed  Schuwi 673", "author": "Schuwi", "description": "forked from Maarten (nice work!)\nreduced shadow artifacts when light is close to edge\nremoved shadow artifact inside light globe", "tags": ["2d", "shadow", "distance", "occlusion", "penumbra", "ambient", "soft", "signed"], "likes": 4, "viewed": 105, "published": "Public", "date": "1624413823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*/\n\n// source: https://www.shadertoy.com/view/MsS3Wc (2021-06-23)\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n// investigate\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n// investigate\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n// investigate\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist + 0.5, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n\tfloat c = circleDist(\t\ttranslate(p, vec2(100, 250)), 40.0);\n\tfloat b1 =  boxDist(\t\ttranslate(p, vec2(200, 250)), vec2(40, 40), \t0.0);\n\tfloat b2 =  boxDist(\t\ttranslate(p, vec2(300, 250)), vec2(40, 40), \t10.0);\n\tfloat l = lineDist(\t\t\tp, \t\t\t vec2(370, 220),  vec2(430, 280),\t10.0);\n\tfloat t1 = triangleDist(\ttranslate(p, vec2(500, 210)), 80.0, \t\t\t80.0);\n\tfloat t2 = triangleDist(\trotateCW(translate(p, vec2(600, 250)), iTime), 40.0);\n\t\n\tfloat m = \tmerge(c, b1);\n\tm = \t\tmerge(m, b2);\n\tm = \t\tmerge(m, l);\n\tm = \t\tmerge(m, t1);\n\tm = \t\tmerge(m, t2);\n\t\n\tfloat b3 = boxDist(\t\ttranslate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = circleDist(\ttranslate(p, vec2(100, 100)),\t30.0);\n\tfloat s = substract(b3, c2);\n\t\n\tfloat b4 = boxDist(\t\ttranslate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = circleDist(\ttranslate(p, vec2(200, 100)), \t30.0);\n\tfloat i = intersect(b4, c3);\n\t\n\tfloat b5 = boxDist(\t\ttranslate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c4 = circleDist(\ttranslate(p, vec2(300, 100)), \t30.0);\n\tfloat a = merge(b5, c4);\n\t\n\tfloat b6 = boxDist(\t\ttranslate(p, vec2(400, 100)),\tvec2(40, 15), \t0.0);\n\tfloat c5 = circleDist(\ttranslate(p, vec2(400, 100)), \t30.0);\n\tfloat sm = smoothMerge(b6, c5, 10.0);\n\t\n\tfloat sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    \n    float b7 = boxDist(\t\ttranslate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c6 = circleDist(\ttranslate(p, vec2(600, 100)), \t30.0);\n\tfloat e = mergeExclude(b7, c6);\n    \n\tm = merge(m, s);\n\tm = merge(m, i);\n\tm = merge(m, a);\n\tm = merge(m, sm);\n\tm = merge(m, sc);\n    m = merge(m, e);\n\t\n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n    \n    // prevent shadow artifacts inside light source globe\n    if (dl < radius) return 1.0;\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(0.1, min(abs(sd), (dl - dt) - radius));\n        //dt += max(0.1, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall = fall * fall; // pow 2\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/iResolution.x);\n\t// grid\n\tcol *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\tcol += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t// shape fill\n\tcol = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\tcol = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n    \n    // highlight problems with SDF\n    //fragColor = vec4(hsv2rgb(vec3(dist / 100.0, 1.0, 1.0)), 1.0);\n    //if (dist > -0.5 && dist < 0.5) fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    //if (dist > 13.5 && dist < 14.5) fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Gz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 251, 278, 278, 405], [407, 526, 574, 574, 675], [678, 678, 711, 711, 734], [737, 737, 777, 777, 820], [822, 837, 874, 874, 898], [900, 915, 952, 952, 975], [978, 1073, 1106, 1106, 1173], [1176, 1176, 1208, 1208, 1274], [1277, 1277, 1309, 1309, 1326], [1329, 1424, 1456, 1456, 1563], [1566, 1566, 1606, 1606, 1636], [1639, 1639, 1681, 1681, 1763], [1765, 1780, 1835, 1835, 1944], [1947, 1947, 2017, 2017, 2129], [2132, 2132, 2180, 2180, 2296], [2299, 2299, 2358, 2358, 2546], [2549, 2623, 2651, 2651, 2691], [2694, 2694, 2742, 2758, 2871], [2874, 2874, 2922, 2938, 3051], [3054, 3104, 3129, 3129, 4910], [4913, 4913, 4949, 4949, 5159], [5162, 5233, 5279, 5279, 6441], [6445, 6445, 6530, 6552, 6859], [6862, 6862, 6889, 6889, 6949], [6952, 6952, 6998, 6998, 7037], [7040, 7040, 7101, 7101, 7269], [7272, 7328, 7385, 7385, 8873]], "test": "untested"}
{"id": "7t2Gzh", "name": "Voxel filaments", "author": "jarble", "description": "Alternative version of: https://www.shadertoy.com/view/7lj3zz", "tags": ["voxel", "tiny"], "likes": 6, "viewed": 124, "published": "Public API", "date": "1623374097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o,vec2 u)\n{\n    for(ivec4 b;(b.x<<b.y>>b.z)%90<99-b.z;)\n    b = ivec4((u/iResolution.y-.5)*o.a+iTime*2.,o+=.1);\n    o /= vec4(1e2,4e3/o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 163]], "test": "untested"}
{"id": "7tB3Rm", "name": "Raymarch baby-steps", "author": "muio", "description": "My first try at raymarching on shadertoy.", "tags": ["raymarch", "sdf"], "likes": 0, "viewed": 33, "published": "Public", "date": "1623562643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst vec3 lightPos = vec3(0, 5, 6);\n\n\nfloat SphereSDF(vec3 p, Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat GetDist(vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    \n    vec3 left = vec3(GetDist(p - e.xyy),\n                     GetDist(p - e.yxy),\n                     GetDist(p - e.yyx)),\n        right = vec3(GetDist(p + e.xyy),\n                     GetDist(p + e.yxy),\n                     GetDist(p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n\nfloat GetLight(vec3 p) { // using diffuse lighting model\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = lightPos + lightPosOffset;\n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    \n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    float d = RayMarch(p + pOffset, l);\n    if (d < length(lightPos - p)) // If true then we've shaded a point on some object before, \n                                  // so shade the currnet point as shodow.\n        dif *= .1; // no half-shadow because the light source is a point.\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = vec3(0, 1, 3);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    // RayMarching stuff\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // diffuse lighting\n    \n    vec3 col = vec3(dif); // gray\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tB3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 285, 285, 321], [323, 323, 346, 368, 508], [510, 510, 544, 544, 920], [922, 922, 946, 995, 1355], [1357, 1357, 1381, 1413, 2092], [2095, 2095, 2152, 2152, 2554]], "test": "untested"}
{"id": "7tB3WD", "name": "polar rave 2.5", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 1, "viewed": 144, "published": "Public API", "date": "1623902694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"polar rave 2.2\" by None. https://shadertoy.com/view/-1\n// 2021-06-17 04:03:47\n\n// Fork of \"polar rave 2.2\" by firebreathz. https://shadertoy.com/view/flSGDW\n// 2021-06-17 03:27:42\n\n// Fork of \"polar rave 2\" by firebreathz. https://shadertoy.com/view/slj3zw\n// 2021-06-16 18:27:30\n\n// Fork of \"polar rave\" by firebreathz. https://shadertoy.com/view/7l2Gzw\n// 2021-06-13 21:22:36\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 21:01:10\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 36\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,-1.5,20.5);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 5.0*uv-2.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.5;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 9.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band/band*band; \n    \n    band = band*0.03;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,-10.000) ).x;  \n    \n    if(band<0.0||band>=10.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 9;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.502,0.502,1.000);\n    colors[1] = vec3(0.235,0.000,0.235);\n    colors[2] = vec3(0.000,0.000,0.400);\n    colors[3] = vec3(0.000,0.000,0.627);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-0)/n)*n);\n    }\n    \n    float h = PI*0.4;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.1,0.75,f);\n    col *= smoothstep(1.875,0.025,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(3.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.x));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.y));\n\n    ref /= -8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(10.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.2)*smoothstep(1.0,0.0,length(p*2.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(6.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(0.10-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tB3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 596, 619, 619, 700], [702, 702, 744, 744, 805], [807, 807, 832, 832, 2382], [2384, 2384, 2441, 2441, 3708]], "test": "untested"}
{"id": "7tBGRm", "name": "Psychedelic Nip Corridor", "author": "Makeavoy", "description": "Ray marching tube of sorts, really rotten code experimenting based on \"Art of Code\" ray marching examples ", "tags": ["raymarching"], "likes": 5, "viewed": 74, "published": "Public", "date": "1623549376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Most foundational code built from the Art of Code tutorials https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\nfloat smin(float a,float b, float smoothing){\n    float slope=clamp(.5+.5*(b-a)/smoothing,0.,1.);\n    //float ease=slope*(1.-slope); //good boolean intersect\n    //return slope*a+(1.-slope)*b-ease*.5;\n    return mix(b,a,slope) - smoothing*slope*(1.-slope);\n}\n\nmat2 rot(float a){\n    float s=sin(a);float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z){\n//l.x+=6.*sin(p.z*14.2);\n    //z=sin(p.y)*4.; warpy\n    vec3 f = normalize(l-p),\nr=normalize(cross(vec3(0,1,0),f)),\nu=cross(f,r),\nc=f*z,\ni=c+uv.x*r + uv.y*u,\nd=normalize(i);\nreturn d;\n}\n\n\nfloat sdPill(vec3 p,vec3 a, vec3 b, float r){\n    //float v=floor(sin(p.x*4.)*2.)*(1.+cos(iTime));//floor(sin(p.x*2.)*4.)*2;\n    vec3 offset=vec3(0,0,0);//+vec3(round(1.*abs(cos(iTime+p.x*2.))),0,0);\n    a+=offset;\n    b+=offset;\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    return length(p-c) -r;\n}\n\nfloat sdTube(vec3 p,float r){\n    //p.x-=cos(p.z*.2)*3.;\n    //p.y+=sin(iTime*.8)*3.;\n    vec3 a=vec3(0,0,90.);\n    vec3 b = vec3(0,0,-90); //make this -900 for a cool effect\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    float moving=p.z*.2+iTime*10.;\n    float zWave=atan(p.y,(p.x));\n    float m=6.;//floor(abs(sin(moving*.1))*6.);\n    float scale=sin(zWave*m);//(sin(moving));\n    r-=2.*scale*(cos(t*p.z*.6 +iTime*10.));\n    return length(p-c) -r;\n}\n\nfloat sdSphere(vec3 p,vec3 a, float r){\nreturn length(p-a) - r;\n}\n\nfloat sdTorus(vec3 p,vec2 r){\n    float i=length(p.xy)-r.x;\n    return length(vec2(i,p.z)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n    p=abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.);\n}\n\nfloat getDist(vec3 p){\n    \n    vec3 a=vec3(0.,1.,.4);//vec3(cos((p.y+iTime)*20.)/8.,sin(p.y*3.+iTime*3.)*2.+1.,6); //vec3(0,1,4);//\n    vec3 b=vec3(0,-2.*sin(iTime),8);\n    //float sphereD=sdPill(p,a,b,1.);\n    //vec3 t=vec3(cos(p.x*1.),p.y+(sin(iTime-cos(p.x))*2.),cos(p.z));\n    //float torusD=sdTorus(b,vec2(1.5,.5));\n    float planeDist=p.y+10.;\n    //float sp1=sdSphere(p,a,1.);\n    \n    float tube=sdTube(p,20.);\n    float tubei=sdTube(p,7.5);\n    tube=max(tube,-tubei);\n    //float box=sdBox(p+vec3(0,-1,2),vec3(1,1,1));\n    //float d=min(tube,planeDist);\n    float d=tube;\n   // float d=min(torusD,planeDist);\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p = ro +rd*dO;\n        float dS =getDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST)break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p){\n    float dist=getDist(p);\n    vec2 e=vec2(0.01,0);\n    vec3 n = dist - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n    n=normalize(n);\n    /*n*=pow(n,vec3(10.));\n    n=normalize(n);*/\n    /*\n    vec3 o=n*10.;\n    vec3 guv=abs(fract(o)-.5);\n    \n    guv.x+=cos(iTime*2.)-sin(iTime*2.);\n    guv.z-=cos(iTime*2.)+sin(iTime*2.);\n    \n    vec3 id=floor(o);\n    float sp=sdSphere(p,guv,.1)/2.;\n    n+=vec3(sp);//dot(sp,sp);\n    n=normalize(n);*/\n    //n+=dot(guv,guv);\n    \n    return n;\n}\n\nvec3 getLight(vec3 p,vec2 uv){\n    vec3 lightPos=vec3(cos(iTime)*3.,5,0); // 0 5 6 \n    vec3 l =normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    n=abs(n);\n    p.z-=2.;//iTime;\n    //p.z+=iTime*10.;\n   \n   /*\n    n*=pow(n,vec3(10.));\n    //n/=n.x+n.y+n.z;\n    n=normalize(n);\n    vec3 c=texture(iChannel1,p.xy*.5 +.5).rgb*n.z \n    +texture(iChannel1,p.xz*.5 +.5).rgb*n.y\n    +texture(iChannel1,p.yz*.5 +.5).rgb*n.x;*/\n    \n    vec2 i =vec2(floor(p.z*.01),floor(length(p.xy)*1.4));\n    \n    vec2 v=hash22(i);\n    vec3 t=p;\n    float val=length(v);\n    //vec3 c=vec3(length(v));//-vec3(length(t));\n    vec3 c=vec3(val*.6+.8,val*1.,1.-val);\n    //vec3 c=abs(fract(p*.4)-0.);\n    \n    //float id=floor((c.z+.2)*2.)*.2;\n    //c=vec3((c.z-(id)));\n    \n    float c1=.3+floor(c.z*3.)*.3;\n    \n    //c=n;\n    //c=vec3(c1);\n    \n    \n    //c.xy-=v;\n    //c.z*=.5;\n    //c=normalize(c);\n    ///c.g=length(c);\n    \n    //c.b+=c1;\n    //c=normalize(c);\n    \n    /*float near=0.;\n    for(float i=-1.;i<-2.;i++){\n    for(float i=-1.;i<-2.;i++){\n    \n    }\n    }*/\n    \n    //c=(c*.34567);\n    //c=getNormal(n);\n    //c=n;\n    float diff=clamp(dot(l,c),0.,1.);\n    //c=vec3(diff);\n    float dist=rayMarch(p+n*SURF_DIST*2.,l);\n    //diff=smoothstep(0.,texture(iChannel1,p.xy).r,diff);\n    if(dist<length(lightPos -p)) diff*=0.6;\n    return c;\n\n}\n\n/*\nfloat checkers( in vec3 p )\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    \n    //camera 1\n   // vec3 ro=vec3(sin(iTime*.2)*2.,0.,cos(iTime*.2));//cos(iTime),5,sin(iTime)+iTime*1.);\n    vec3 ro=vec3(sin(iTime*1.2)*2.,cos(iTime*.5)*.8,5.);//cos(iTime),5,sin(iTime)+iTime*1.);\n    //ro.x-=2.+sin(3.14*rd.z*.06)*10.;\n    \n    //ro.yz*= rot(-m.y*3.14+1.);\n    //ro.xz*= rot(-m.x*6.28);\n       //ray diff\n    vec3 rd=getRayDir(uv,ro,vec3(0),1.);//normalize(vec3(uv.x,uv.y,1));\n    //rd.x-=2.+sin(3.14*rd.z*.06)*10.;\n    float dist=rayMarch(ro,rd);\n    \n    \n    vec3 point = ro +rd*dist;\n    vec3 diffuse=getLight(point,uv);\n\n    // Time varying pixel color\n    vec3 col = diffuse;//getNormal(point);//.99,.6,4.);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n        //col=vec3(diffuse);\n    //col=mix(col,vec3(1),vec3(diffuse));\n      // col.rg=texture(iChannel1,uv).rg;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 186, 207, 207, 341], [343, 343, 364, 364, 468], [471, 471, 516, 516, 729], [731, 731, 749, 749, 813], [815, 815, 864, 916, 1050], [1053, 1053, 1098, 1177, 1469], [1471, 1471, 1500, 1556, 2038], [2040, 2040, 2079, 2079, 2105], [2107, 2107, 2136, 2136, 2206], [2208, 2208, 2236, 2236, 2316], [2318, 2318, 2340, 2340, 2952], [2954, 2954, 2987, 2987, 3181], [3183, 3183, 3206, 3206, 3705], [3707, 3707, 3737, 3737, 5039], [5041, 5143, 5199, 5249, 6202]], "test": "untested"}
{"id": "7tBGRz", "name": "Sin explode", "author": "jaredly", "description": "Playing around with raymarching SDFs and sin waves 🎉", "tags": ["raymarching", "sdf", "sin"], "likes": 3, "viewed": 99, "published": "Public", "date": "1623210987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nprecision mediump float;\n\n\nconst float PI = 3.14159;\n\nuniform float u_time;\n\nuniform vec2 u_mouse;\n\nuniform vec3 u_camera;\n\nuniform vec2 u_resolution;\n\nstruct GLSLEnv_451d5252{\n    float time;\n    vec2 resolution;\n    vec3 camera;\n    vec2 mouse;\n};\n\n// skipping Div_5ac12902, contains type variables\n\n// skipping Neg_3c2a4898, contains type variables\n\n// skipping AddSub_b99b22d8, contains type variables\n\n// skipping Mul_1de4e4c0, contains type variables\n\nmat4 rotate_d804569c(float tx_0, float ty_1, float tz_2) {\n    float cg_3 = cos(tx_0);\n    float sg_4 = sin(tx_0);\n    float cb_5 = cos(ty_1);\n    float sb_6 = sin(ty_1);\n    float ca_7 = cos(tz_2);\n    float sa_8 = sin(tz_2);\n    return mat4(\n        vec4(\n            (ca_7 * cb_5),\n            (((ca_7 * sb_6) * sg_4) - (sa_8 * cg_3)),\n            (((ca_7 * sb_6) * cg_3) + (sa_8 * sg_4)),\n            0.0\n        ),\n        vec4(\n            (sa_8 * cb_5),\n            (((sa_8 * sb_6) * sg_4) + (ca_7 * cg_3)),\n            (((sa_8 * sb_6) * cg_3) - (ca_7 * sg_4)),\n            0.0\n        ),\n        vec4(-sb_6, (cb_5 * sg_4), (cb_5 * cg_3), 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvec4 V16557d10_1de4e4c0_0(mat4 mat_0, vec4 vec_1) {\n    return vec4(\n        dot(mat_0[0], vec_1),\n        dot(mat_0[1], vec_1),\n        dot(mat_0[2], vec_1),\n        dot(mat_0[3], vec_1)\n    );\n}\n\nvec3 xyz_1aedf216(vec4 v_0) {\n    return vec3(v_0.x, v_0.y, v_0.z);\n}\n\nvec3 rotate_6734d670(vec3 v_0, float x_1, float y_2, float z_3) {\n    return xyz_1aedf216(V16557d10_1de4e4c0_0(rotate_d804569c(x_1, y_2, z_3), vec4(v_0, 1.0)));\n}\n\nvec3 cross_54f2119c(vec3 one_0, vec3 two_1) {\n    return vec3(\n        ((one_0.y * two_1.z) - (two_1.y * one_0.z)),\n        ((one_0.z * two_1.x) - (two_1.z * one_0.x)),\n        ((one_0.x * two_1.y) - (two_1.x * one_0.y))\n    );\n}\n\nconst float EPSILON_17261aaa = 0.00010;\n\nfloat V59e3c5cf(GLSLEnv_451d5252 env_0, vec3 pos_1) {\n    vec3 pos_2 = rotate_6734d670(pos_1, 0.0, (env_0.time / 2.0), env_0.time);\n    float period_4 = (30.0 * (sin(env_0.time) + 1.0));\n    return ((length(pos_2) - 0.50) - (((sin((pos_2.x * period_4)) + sin((pos_2.z * period_4))) + sin(\n        (pos_2.y * period_4)\n    )) / (((sin((env_0.time / 2.0)) + 1.0) * 60.0) + 1.0)));\n}\n\nmat4 viewMatrix_c336d78c(vec3 eye_0, vec3 center_1, vec3 up_2) {\n    vec3 f_3 = normalize((center_1 - eye_0));\n    vec3 s_4 = normalize(cross_54f2119c(f_3, up_2));\n    vec3 u_5 = cross_54f2119c(s_4, f_3);\n    vec4 lambdaBlockResult_7;\n    vec3 spread_6 = -f_3;\n    lambdaBlockResult_7 = vec4(spread_6.x, spread_6.y, spread_6.z, 0.0);\n    return mat4(\n        vec4(s_4.x, s_4.y, s_4.z, 0.0),\n        vec4(u_5.x, u_5.y, u_5.z, 0.0),\n        lambdaBlockResult_7,\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvec3 rayDirection_6258178a(float fieldOfView_0, vec2 size_1, vec2 fragCoord_2) {\n    return normalize(\n        vec3((fragCoord_2 - (size_1 / 2.0)), -(size_1.y / tan((radians(fieldOfView_0) / 2.0))))\n    );\n}\n\nvec3 estimateNormal_1fd17220(GLSLEnv_451d5252 env_1, vec3 p_2) {\n    return normalize(\n        vec3(\n            (V59e3c5cf(env_1, vec3((p_2.x + EPSILON_17261aaa), p_2.y, p_2.z)) - V59e3c5cf(\n                env_1,\n                vec3((p_2.x - EPSILON_17261aaa), p_2.y, p_2.z)\n            )),\n            (V59e3c5cf(env_1, vec3(p_2.x, (p_2.y + EPSILON_17261aaa), p_2.z)) - V59e3c5cf(\n                env_1,\n                vec3(p_2.x, (p_2.y - EPSILON_17261aaa), p_2.z)\n            )),\n            (V59e3c5cf(env_1, vec3(p_2.x, p_2.y, (p_2.z + EPSILON_17261aaa))) - V59e3c5cf(\n                env_1,\n                vec3(p_2.x, p_2.y, (p_2.z - EPSILON_17261aaa))\n            ))\n        )\n    );\n}\n\nfloat shortestDistanceToSurface_94f41dfc(\n    GLSLEnv_451d5252 env_1,\n    vec3 eye_2,\n    vec3 marchingDirection_3,\n    float start_4,\n    float end_5,\n    int stepsLeft_6\n) {\n    for (int i=0; i<10000; i++) {\n        float dist_7 = V59e3c5cf(env_1, (eye_2 + (start_4 * marchingDirection_3)));\n        if ((dist_7 < EPSILON_17261aaa)) {\n            return start_4;\n        } else {\n            float depth_8 = (start_4 + dist_7);\n            if (((depth_8 >= end_5) || (stepsLeft_6 <= 0))) {\n                return end_5;\n            } else {\n                start_4 = depth_8;\n                stepsLeft_6 = (stepsLeft_6 - 1);\n                continue;\n            };\n        };\n    };\n}\n\nvec3 getWorldDir_92052fca(vec2 resolution_0, vec2 coord_1, vec3 eye_2, float fieldOfView_3) {\n    vec3 viewDir_4 = rayDirection_6258178a(fieldOfView_3, resolution_0, coord_1);\n    return xyz_1aedf216(\n        V16557d10_1de4e4c0_0(\n            viewMatrix_c336d78c(vec3(0.0, 0.0, 5.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n            vec4(viewDir_4.x, viewDir_4.y, viewDir_4.z, 0.0)\n        )\n    );\n}\n\nvec4 Vdb8cedd2(GLSLEnv_451d5252 env_9, vec2 coord_10) {\n    vec3 eye_11 = vec3(0.0, 0.0, 5.0);\n    vec3 worldDir_12 = getWorldDir_92052fca(env_9.resolution, coord_10, eye_11, 45.0);\n    float dist_13 = shortestDistanceToSurface_94f41dfc(env_9, eye_11, worldDir_12, 0.0, 100.0, 255);\n    if ((dist_13 > (100.0 - EPSILON_17261aaa))) {\n        return vec4(0.0);\n    } else {\n        return vec4(estimateNormal_1fd17220(env_9, (eye_11 + (worldDir_12 * dist_13))), 1.0);\n    };\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    fragColor = Vdb8cedd2(\n        GLSLEnv_451d5252(iTime, iResolution.xy, vec3(0.0), iMouse.xy),\n        fragCoord.xy\n    );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 460, 518, 518, 1153], [1155, 1155, 1206, 1206, 1351], [1353, 1353, 1382, 1382, 1422], [1424, 1424, 1489, 1489, 1586], [1588, 1588, 1633, 1633, 1817], [1860, 1860, 1913, 1913, 2240], [2242, 2242, 2306, 2306, 2743], [2745, 2745, 2825, 2825, 2952], [2954, 2954, 3018, 3018, 3651], [3653, 3653, 3828, 3828, 4340], [4342, 4342, 4435, 4435, 4748], [4750, 4750, 4805, 4805, 5224], [5226, 5226, 5283, 5283, 5414]], "test": "untested"}
{"id": "7tBGWc", "name": "On The River", "author": "andrew741", "description": "Ripples in a river using refraction with a nice atmosphere added on top. Theres also a nice night sky. I made this after getting inspired from another shader with water ripples and then added the atmosphere and stars on top. I also through on some clouds.", "tags": ["raytracing", "clouds", "refraction", "water", "sky", "night", "atmosphere", "volumetrics"], "likes": 4, "viewed": 118, "published": "Public", "date": "1624848134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe code for the atmospheric scattering came from some of my other projects and was modified to work on a flat world\nThe code for the clouds was writen fully for this program dispite using this same method to render volumetric clouds in some of my other shaders\nThe stary sky is using the same method as one of my space (earth) shaders (The method is to use triplanar mapping and taking the color of the stars and putting it to a large power to single out the stars)\nThe noise function was from another shadertoy as I'm not very good at making/inplementing gradient noise algerithms myself\n\nI hope you enjoy this shader as It took me over 4.5 hours\n*/\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoise(vec3 p)\n{\n    float h = noised(p).x;\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\nvec4 sampleNoise(vec3 p)\n{\n    vec4 h = noised(p);\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;  // the specular reflection/highlight\n    float diffuse;    // basic diffuse lighting (dosent give the best ouput in this shader and some others)\n};\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 6.5;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// uses ray marching to find the distance through the plannet (for a given position and direction)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float lp;\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    // stepping and moving the ray closer and closer\n    for (int s = 0; s < 80; s++)\n    {\n        dst = -(p.y - 5.);\n        \n        // checking if its super close (to speed it up some sense its called so many times)\n        if (dst < 0.01) break;\n        dfs += dst;\n        p += rd * dst;\n    }\n    // returning the distance through the sphere\n    return dfs;\n}\n\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    // the rays position\n    vec3 p = ro;\n    // the step size\n    float step_size = rl / 11.;\n    vec3 v3_step_size = rd * step_size;\n    // the optical depth\n    float odepth = 0.;\n    // the density\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += v3_step_size;\n        // sampling the atmospheric density\n        ldense = GetDensity(p.y);\n        // adding up the optical depth\n        odepth += ldense * step_size;\n    }\n    // returning the optical depth\n    return odepth;\n}\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStars(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 1.;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 5.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel1, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel1, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel1, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// gets the density of a cloud at a 3D point\nfloat CloudDensity(vec3 p)\n{\n    return max(noised(p * 0.01).z * 0.9 + 0.1, 0.);\n}\n\n\nfloat GetDst(vec3 p)\n{\n    return p.y + texture(iChannel0, p.xz * 0.5, 0.).g;\n}\n\n\n// returns the normal based on a signed distance feild\nvec3 GroundNoraml(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.075, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// finding the scattering coefficents based on the wave lengths of different light colors\nvec3 scatteringCoefficents = pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 1.5;  // the coefficents for the scattering of different wave lengths/colors of light\n\n\nvec4 RenderAtmo(vec3 rd, vec3 ro, vec3 waterCp, vec3 sun_dir, vec3 col)\n{\n    float dstThroughAtmosphere;\n    if (rd.y <= 0.)\n    {\n        dstThroughAtmosphere = min(length(waterCp - ro) / 20., 5.);\n    }\n    else dstThroughAtmosphere = 5.;  // - min(ro.y, 5.);\n    // finding the step size going through the atmosphere\n    float step_size_f = dstThroughAtmosphere / 11.;\n    vec3 step_size = rd * step_size_f;\n    vec3 p = vec3(0.);\n    \n    // initizalizing some terms\n    float density;\n    float sun_length;\n    vec3 transmittance;\n    float sunRayOpticalDepth;\n    float veiwRayOpticalDepth;\n    vec3 inScatteredLight = vec3(0.);\n    // stepping through the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += step_size;\n        // fining the length through the atmosphere in the direction of the sun\n        sun_length = raySphere(p, sun_dir);\n        // finding the optical depth for the view ray and sun ray\n        sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length);\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size_f * float(s));\n        // finding the transmittance\n        transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents);\n        // finding the atmospheric density at this point\n        density = GetDensity(p.y);\n        \n        // finding the amount of addition light\n        inScatteredLight += density * transmittance * scatteringCoefficents * step_size_f;\n    }\n    // applying the atmosphere\n    return vec4(inScatteredLight, exp(-veiwRayOpticalDepth));\n}\n\n\nvec3 renderSky(vec3 ro, vec3 rd, vec3 waterCp, vec3 sun_dir, vec3 sun_col, float time, vec3 col)\n{\n    // rendering atmosphere\n    // finding the distance through the atmosphere\n    float density;\n    vec4 inscat = RenderAtmo(rd, ro, waterCp, sun_dir, col);\n    col = col * inscat.w + inscat.rgb;\n    \n    // checking if the sky needs to be rendered\n    if (rd.y > 0.)\n    {\n        // adding the stars\n        col += pow(TriplannarStars(rd + time * 0.1, rd), vec3(2.75)) * pow(1. - length(col), 5.) * 0.7;\n        // adding the sun\n        col = mix(col, sun_col + inscat.rgb, pow(max(dot(rd, sun_dir), 0.), 275.));\n        \n        // rendering clouds\n        // finding the distance to the cloud layer\n        float toClouds = (40. - ro.y) / rd.y;\n        // checking if the cloud layer is within a reasonable range\n        if (toClouds < 920.)\n        {\n            // finding the distance throught the cloud layer\n            float throughClouds = 50. / rd.y;\n\n            // finding the step size going through the cloud layer\n            float step_size_f = min(throughClouds / 21., 15.);\n            vec3 step_size = rd * step_size_f;\n            \n            // finding where the point collides with the cloud layer (with some shifting so the cloud move)\n            vec3 p = vec3(-ro.x * 4. + iTime * 12., ro.y, -ro.z * 4. +  + iTime * 12.) + rd * toClouds;\n            float oy = p.y;\n            \n            // defining some terms\n            vec3 sun_p;\n            vec3 sunStep;\n            float sunStepF;\n\n            vec3 inScattered = vec3(0.);\n            float transmittion = 1.;\n            float totalLightDensity;\n\n            vec4 inscat2 = RenderAtmo(sun_dir, p, vec3(9999999999.), sun_dir, vec3(0.));\n\n            // stepping through the clouds\n            for (int s = 0; s < 20; s++)\n            {\n                // moving the point/ray\n                p += step_size;\n\n                // sampling the density\n                density = CloudDensity(p) * step_size_f;  // replace with noise function\n                \n                // stepping twords the sun\n                if (density >= 0.)\n                {\n                    // reseting some terms\n                    sun_p = p;\n                    totalLightDensity = 0.;\n                    if (sun_dir.y >= 0.)\n                    {\n                        sunStepF = min((50. - (p.y - 40.)) / sun_dir.y / 11., 10.);\n                    }\n                    else\n                    {\n                        sunStepF = min(((p.y - 40.) / abs(sun_dir.y) / 11.), 10.);\n                    }\n                    sunStep = sun_dir * sunStepF;\n                    // stepping through the cloud twords the sun\n                    for (int s = 0; s < 10; s++)\n                    {\n                        sun_p += sunStep;\n                        // sampling the density at the current point\n                        totalLightDensity += CloudDensity(sun_p) * sunStepF;\n                        // moving the ray/point\n                    }\n                    // finding the transmittance based on the amount of stuff (cloud) in the way e^-density\n                    transmittion *= exp(-density * 0.1);\n                    // finding the amount of inScatterd light\n                    //vec3 c = RenderAtmo(rd, p * vec3(1., 0.075, 1.), vec3(999999999.), sun_dir, vec3(0.)).rgb;\n                    // (vec3(1.) - vec3(0., 0.8, 1.) * (1. - c.b))\n                    inScattered += (vec3(1.) - vec3(0., 0.8, 1.) * (1. - inscat2.b)) * (density * transmittion * exp(-totalLightDensity * 0.1) * 0.1);\n                    //inScattered = sun_col + c;\n                    //col = c;\n                    //return col;\n                }\n\n                if (transmittion < 0.05) break;  // an optomization as the transmittion is so low that anything lower dosent vissually change much\n            }\n            // fading the clouds out at the edges so it looks like they are within the atmosphere\n            transmittion = mix(transmittion, 1., (toClouds / 920.));\n            // checking if the clouds are being shadowed by the planet (night time)\n            // add the clouds on top of the current color based on the transmittion\n            if (sun_dir.y <= 0.)\n            {\n                col = mix(col * transmittion, vec3(inScattered * 0.8 + 0.2), 1. - transmittion);\n                //col = mix(col * transmittion, mix(col * transmittion, vec3(inScattered * 0.8 + 0.2), 1. - transmittion), max(min(oy / abs(sun_dir.y) / 2500., 1.), 0.));\n            }\n            else\n            {\n                col = mix(col * transmittion, vec3(inScattered * 0.8 + 0.2), 1. - transmittion);\n            }\n            \n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv coord\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // the scaled time\n    float time = iTime * 0.1;\n\n    vec3 sun_col = vec3(1., 0.8, 0.65) * 1.4;\n    //vec3 sun_dir = normalize(vec3(0.2, 0.3, 1.));\n    vec3 sun_dir = normalize(vec3(sin(time) * 0.2 + 0.2, sin(time), cos(time)));\n\n    // the ray direction and ray orgin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 ro = vec3(2. - iMouse.x / iResolution.x * 4. - 2., 2., 2. - iMouse.y / iResolution.y * 4. - 2.);\n    \n    // the color (which will be the output)\n    vec3 col = vec3(0.);\n    \n    // the waters collide point\n    vec3 waterCp = ro + rd * (ro.y / rd.y);\n    if (rd.y <= 0.)\n    {\n        // finding a noise value at the position of where the ray collides with the water plane\n        vec4 noise = (1. - abs(sampleNoise(vec3(waterCp.xz - time, iTime * 0.5)))) * 2. - 1.;\n        // finding the water normal (for refraction)\n        vec3 waterNorm = normalize(vec3((noise.x * 0.5), 12., (noise.w * 0.5)));\n        // fining the refracted ray direction (to sample the texture)\n        vec3 refracted = refract(rd, waterNorm, 0.075);\n        // fidning where the refracted ray hits the bottom of the river\n        vec3 cp = waterCp + refracted * ((waterCp.y + 2.) / refracted.y);\n                \n        // fidning the river bottoms texture\n        vec3 text = texture(iChannel0, cp.xz * 0.5, 0.).rgb;\n        // setting the color to the texture\n        col = text;\n        // adding specular reflection/highlight to the waters surface\n        SpecularLight spec = Specular(0.6, waterNorm, rd, sun_dir);\n        col = col + spec.highlight;\n        \n        // add a bit of diffuse lighting to the river bed (i think its diffuse lighting at least)\n        vec3 groundNormal = GroundNoraml(cp);\n        col *= dot(groundNormal, sun_dir) * 0.25 + 0.75;\n        \n        float waterDepth = max(length(cp - waterCp) - groundNormal.y * 5., 0.);\n        \n        // haveing the water be dark during the night (sense the lighting dosent make it very dark)\n        col *= min(sun_dir.y * 0.3 - 0.7, 0.) + 1.;\n        \n        col = mix(col, vec3(0.1, 0.1, 0.4), 1. - exp(-waterDepth * 0.25));\n        \n        vec3 reflected = reflect(rd, waterNorm);\n        col = mix(col, renderSky(waterCp, reflected, waterCp, sun_dir, sun_col, time, col), min(1. + dot(-sun_dir, reflected), 1.));\n    }\n    col = renderSky(ro, rd, waterCp, sun_dir, sun_col, time, col);\n\n    // setting the final color to col\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[657, 690, 711, 711, 880], [882, 915, 941, 953, 2447], [2450, 2515, 2542, 2542, 2713], [2716, 2716, 2742, 2742, 2910], [3161, 3214, 3292, 3292, 3708], [3711, 3761, 3799, 3799, 4121], [4124, 4223, 4258, 4258, 4691], [4694, 4769, 4817, 4842, 5392], [5395, 5469, 5512, 5544, 6138], [6141, 6186, 6214, 6214, 6268], [6271, 6271, 6293, 6293, 6350], [6353, 6408, 6435, 6435, 6638], [6641, 6898, 6971, 6971, 8476], [8479, 8479, 8577, 8656, 13213], [13216, 13216, 13273, 13293, 15803]], "test": "untested"}
{"id": "7tBGzK", "name": "Cubic Equation Solver II", "author": "oneshade", "description": "Inspired by @TinyTexel's super cool and easy to understand construction for solving a cubic partially using an inverse smoothstep (a highly specialized cubic inverse).\n[url=https://www.shadertoy.com/view/3sBcDh]https://www.shadertoy.com/view/3sBcDh[/url]", "tags": ["math", "solver", "cubic", "equation", "inversesmoothstep"], "likes": 9, "viewed": 57, "published": "Public", "date": "1624242454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis turned out pretty clean, simple, and understandable! Also it never evaluates\nmore than four typically expensive functions (e.g. trig, square roots, etc.)\nwhich is one up on my other cubic solvers.\n\nI also added handling for when p=0 which simply blows up the whole thing but I'm not\nchecking for degenerate cubic equations (please don't solve linear equations\nwith this, ok? ;))\n*/\n\n// Special cube root to fix GLSL's negative pow() bug\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    // Depress to x^3 + px + q by substituting x-b/3a\n    // This can be found by substituting x+u and solving for u so that the x^2\n    // term gets eliminated (then of course dividing by the leading coefficient)\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    // Everything blows up when p=0 so give this case special treatment\n    if (abs(p) < 1e-9) { roots.x = cbrt(-q) - u; return 1; }\n\n    // In the case of one root, this construction does not work\n    float h = 0.25 * q * q + p * p * p / 27.0;\n    if (h > 0.0) { // Check depressed cubic discriminant\n        h = sqrt(h);\n        float o = -0.5 * q;\n        roots.x = cbrt(o - h) + cbrt(o + h) - u; // Cardano's formula (see https://en.wikipedia.org/wiki/Cubic_equation)\n        return 1;\n    }\n\n    // Solve by mapping an inverse smoothstep between the critical points\n    // I found a whole lot simplified right out so now it probably looks rather obfuscated\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    // Factor out the root to solve for the rest as a quadratic\n    h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u; // Undo the change in variable\n\n    return 3;\n}\n\n/* Without comments (for size comparison, giant solvers are no fun to tote around)\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    if (abs(p) < 1e-9) { roots.x = cbrt(-q) - u; return 1; }\n    float h = 0.25 * q * q + p * p * p / 27.0;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float o = -0.5 * q;\n        roots.x = cbrt(o - h) + cbrt(o + h) - u;\n        return 1;\n    }\n\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u;\n\n    return 3;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Animated coefficients\n    float a = sin(iTime) * 2.0;\n    float b = sin(iTime) * 5.0;\n    float c = cos(iTime * 0.75);\n    float d = sin(iTime * 0.5);\n\n    float f = a * uv.x * uv.x * uv.x + b * uv.x * uv.x + c * uv.x + d;\n    float g = 3.0 * a * uv.x * uv.x + 2.0 * b * uv.x + c; // Derivative for distance estimate\n    float cubic = abs(uv.y - f) / sqrt(1.0 + g * g); // Distance estimate\n\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(uv.y))); // X axis\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, cubic)); // Cubic function\n\n    // Solve for the roots of the derivative (a quadratic)\n    // to get the extrema\n    float da = 3.0 * a;\n    float db = 2.0 * b;\n    float dc = c;\n\n    float discr = db * db - 4.0 * da * dc;\n    vec2 ex1 = vec2(0.0), ex2 = vec2(0.0);\n    if (discr > 0.0) {\n        discr = sqrt(discr);\n        da *= 2.0;\n\n        // Extrema 1\n        ex1 = vec2((-db + discr) / da, 0.0);\n        ex1.y = ((a * ex1.x + b) * ex1.x + c) * ex1.x + d;\n\n        // Extrema 2\n        ex2 = vec2((-db - discr) / da, 0.0);\n        ex2.y = ((a * ex2.x + b) * ex2.x + c) * ex2.x + d;\n\n        // Draw the segment between the extrema where the inverse smoothstep\n        // gets fitted\n        if (min(ex1.x, ex2.x) < uv.x && uv.x < max(ex1.x, ex2.x)) {\n            color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, cubic - 0.025));\n        }\n\n        // Draw the extrema\n        color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - ex1) - 0.05));\n        color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - ex2) - 0.05));\n    }\n\n    // Draw roots\n    vec3 roots;\n    int nroots = solveCubic(a, b, c, d, roots);\n    for (int n=0; n < nroots; n++) {\n        vec3 rootColor = vec3(1.0);\n        if (n == 0 && sign(ex1.y) != sign(ex2.y)) rootColor.rb = vec2(0.0); // Draw inverse smoothstepped root in green\n        color = mix(color, rootColor, smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 445, 469, 469, 512], [513, 513, 593, 593, 1914], [1916, 2752, 2807, 2807, 5010]], "test": "untested"}
{"id": "7tBGzz", "name": "Sink", "author": "tono", "description": "Sink\n\nWhen I am lost in thought, my eyeballs are free under my closed eyelids.\nIt swims in the sea of thoughts while retaining its connection to itself, capturing various spaces in its eyes.\nIf there are eyeballs that swim in the sea of thoughts, I though", "tags": ["sea"], "likes": 20, "viewed": 114, "published": "Public", "date": "1623222570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nfloat frame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 min2(vec2 a , vec2 b)\n{\n    if(b.x < a.x)\n    {\n        a = b;\n    }\n    return a;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define PACKIN 1.\n#define WALLS  2.\n#define LIGHT  3.\n#define BODY   4.\n\nvec2 aquarium(vec3 p)\n{\n    vec2 o = vec2(1.);\n    p += vec3(0.,1.,0.);\n    o.x = frame(p , vec3(2.5,1.5,2.),0.001 ) - .03;\n    vec3 p2 = abs(p) - vec3(0.,2.5,0.);\n    vec3 p3 = abs(p) - vec3(3.5,0.,0.);\n    float walls = box(p2 , vec3(2.5,1.,2.));\n    walls = min(box(p3 , vec3(1.,2.,2.)),walls);\n    walls = min(box(p + vec3(0.,0.,3.),vec3(2.5,1.5,1.)),walls);\n    if(walls < .01)\n    {\n        walls -= simplex3d(p * 40.)/200.;\n    }\n    o = min2(o,vec2(walls,2.));\n    return o;\n}\n\nvec2 light(vec3 p)\n{\n    vec2 o = vec2(0.,LIGHT);\n    p -= vec3(0.,.5,.0);\n    o.x = length(p)-.1;\n    return o;\n}\n\nvec3 eyePos;\nvec2 fish(vec3 p)\n{\n    vec2 o = vec2(0.,BODY);\n    p -= vec3(0.,-1.3,5.);\n\tfloat tim = iTime / 3.;\n    float t = floor(tim) + pow(fract(tim),1.3);\n    float tt = noise(vec2(t/2.));\n    float ttt = noise(vec2(-iTime,iTime));\n    p.xz *= rot(sin(tt * pi * 2.)/2.);\n    p.yz *= rot(sin(tt/2. * pi * 2. + .1)/3.);\n    o.x = length(p) - 2.;\n    \n    vec3 p2 = p;\n    vec3 p3 = p;\n    //p.xz *= rot(.5);    \n    p.z += 1.3;\n    eyePos = p;\n    o.x = min(o.x , length(p) - 1.);\n    p2.y -= 1.;\n    p2.x = abs(p2.x) - 2.5;\n    p2.z += 0.5;\n    p2.y += sin(p2.x + iTime * 2.)/7.;\n    p2.yz *= rot(p2.x * 3.);\n    p2.xz *= rot(.0);\n    p2.yz *= rot(.7);\n    o.x = smoothMin(o.x , frame(p2,vec3(30,.1,.3),.1),3. );\n    \n    //float sp = length(p) - simplex3d(p/3. + iTime) * 1.;\n    //o.x = smoothMin(o.x , sp,4.);\n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = vec2(1.);\n    o = min2(o,aquarium(p));\n\to = min2(o,light(p));\n    o = min2(o,fish(p));\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n\tfloat depth = 0.;\n    for(int i = 0; i < 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n\t\tif(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 10.)break;\n        depth += d.x;\n    }\n    return vec2(-1.);\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y,p.x);\n  float r = 0.;\n  r = length(p);\n  return vec2(a/pi, r);\n}\n\nvec3 eye(vec3 p)\n{\n    vec3 col = vec3(1.);\n    if(p.z < 0.)\n    {\n        vec2 mpol = mPolar(p.xy);\n        vec3 blackCol = vec3(1.,1.,1.) * smoothstep( (sin(mpol.x * pi * 18. )+.5 )/2.,1.,.3);\n        blackCol = smoothstep(vec3(0.9,.8,.4),blackCol,vec3(min( .44 - length(p.xy)/2. ,1.)));\n        col = mix(blackCol *(1.3 -  mpol.y * 1.5),vec3(1.) , step(0.,length(p.xy) - .9) );\n        float t = floor(iTime/2.) + pow(fract(iTime/2.),2.);\n        float shrink = max(abs(sin(sin(t))),.5);\n    \tcol *= step(0.,length(p.xy) - .4 * shrink);\n        col += 1. - step(0.,length(p.xy) - .2 * shrink);\n        \n    }\n    col *= .8;\n    col += vec3(0.,0.,0.) * floor(simplex3d(p * vec3(30.,30.,1.)));\n    return col;\n}\n\nvec3 getColor(vec2 d, vec3 cp,vec3 rd)\n{\n     vec3 col = vec3(0.);\n    vec3 bcol = col;\n    vec3 mat = vec3(1.);\n    vec3 pos = cp + rd * d.x;\n    vec2 e = vec2(0.,0.01);\n    vec3 N = normalize(map(pos).x - vec3(map(pos + e.xyy).x,map(pos + e.yxy).x,map(pos + e.yyx).x) );\n    vec3 sun = normalize(vec3(2.,4.,8.));\n    sun.xz *= rot(iTime);\n\n    vec3 lightPos = vec3(0.,0.5,0.);\n\n    //vec3 lightDir = normalize(vec3(0.,pos.yz - lightPos.yz));\n    vec3 lightDir = normalize(pos - lightPos);\n    float lightDist = length(pos - lightPos);\n    float attenuation = (1. / pow(lightDist,2.) );\n    float diff = max(0.,dot(N , lightDir)) * attenuation;\n    vec3 halfvector = normalize(lightDir + rd);\n    float sp = max( 0.,dot(N,halfvector) );\n    //fromWater\n\n    float wattenuation = 1. / pow((3. - pos.z),1.3);\n    vec3 wlight = normalize(vec3(5.,-1.,-2.));\n    float wdiff = max(0.,dot(wlight,N)) * wattenuation ;\n    vec3 whalfvector = normalize(wlight + rd);\n    float wsp = max(0.,dot(whalfvector , N)) * wattenuation;\n\n\n    float up = max(0.,dot(vec3(0.,-1.,0.),rd));\n    float down = max(0.,dot(vec3(0.,1.,0.),rd));\n\n    // col = vec3(0.,1.,1.)/2.;\n    // col += up * vec3(.1);\n    // col -= down * vec3(3.);\n    // bcol = col;\n\n    if(d.y == PACKIN)\n    {\n        mat = vec3(0.1);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 10.);\n\n\n        col = mat * diff + sp;\n        col += bcol * wdiff + bcol * wsp; \n    }\n    else if(d.y == WALLS)\n    {\n        mat = vec3(0.8)/10.;\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 60.);\n\n\n        col = mat * diff + sp * vec3(0.2,.8,.9);\n\n        col += (bcol * wdiff + bcol * wsp)/2.; \n    }\n    else if(d.y == LIGHT)\n    {\n        mat = vec3(1.) * 1.;\n        diff = .8;\n\n\n        col = mat * diff + sp;\n    }\n\n    return col;\n}\n\nvec3 setColor(vec2 d , vec3 cp ,vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 bcol = col;\n    vec3 mat = vec3(1.);\n    vec3 pos = cp + rd * d.x;\n    vec2 e = vec2(0.,0.01);\n    vec3 N = normalize(map(pos).x - vec3(map(pos + e.xyy).x,map(pos + e.yxy).x,map(pos + e.yyx).x) );\n    vec3 sun = normalize(vec3(2.,4.,8.));\n    sun.xz *= rot(iTime);\n\n    vec3 lightPos = vec3(0.,0.5,0.);\n\n    //vec3 lightDir = normalize(vec3(0.,pos.yz - lightPos.yz));\n    vec3 lightDir = normalize(pos - lightPos);\n    float lightDist = length(pos - lightPos);\n    float attenuation = (1. / pow(lightDist,2.) );\n    float diff = max(0.,dot(N , lightDir)) * attenuation;\n    vec3 halfvector = normalize(lightDir + rd);\n    float sp = max( 0.,dot(N,halfvector) );\n    //fromWater\n\n    float wattenuation = 1. / pow((3. - pos.z),1.3);\n    vec3 wlight = normalize(vec3(5.,-1.,-2.));\n    float wdiff = max(0.,dot(wlight,N)) * wattenuation ;\n    vec3 whalfvector = normalize(wlight + rd);\n    float wsp = max(0.,dot(whalfvector , N)) * wattenuation;\n\n\n    float up = max(0.,dot(vec3(0.,-1.,0.),rd));\n    float down = max(0.,dot(vec3(0.,1.,0.),rd));\n\n    col = vec3(0.,1.,1.)/2.;\n    col += up * vec3(.1);\n    col -= down * vec3(3.);\n    bcol = col;\n\n    if(d.y == PACKIN)\n    {\n        mat = vec3(0.1);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 10.);\n\n\n        col = mat * diff + sp;\n        col += bcol * wdiff + bcol * wsp; \n    }\n    else if(d.y == WALLS)\n    {\n        mat = vec3(0.8)/10.;\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 60.);\n\n\n        col = mat * diff + sp * vec3(0.2,.8,.9);\n\n        col += (bcol * wdiff + bcol * wsp ); \n    }\n    else if(d.y == LIGHT)\n    {\n        mat = vec3(1.) * 1.;\n        diff = .8;\n\n\n        col = mat * diff + sp;\n    }\n\n    //col = N * .5 + .5;\n\n    if(d.y == BODY)\n    {\n        mat = eye(eyePos);\n        vec2 d2 = march(pos + N * 0.1 ,N);\n        vec3 ambCol = getColor(d2,cp,rd);\n        mat = mix(mat,ambCol,.5);\n        diff = mix(1.,diff,1.);\n        sp = pow(sp , 3.) * 10.;\n        col = mat * diff + sp;\n        col += up * vec3(2.) * mat;\n        //col += -down * vec3(3.3);\n        float tt = 1.- exp(-0.001 * d.x * d.x * d.x * d.x);\n        col = mix(col,bcol , tt);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.,0.,1.);\n    vec3 bcol = col;\n    vec3 mat = col;\n    \n    vec3 cp  = vec3(0.,0.,-1.5);\n    vec3 target = vec3(0.,-.3,.0);\n    vec3 cd = normalize(target - cp);\n    \n    vec3 cs = normalize( cross(cd , vec3(0.,1.,0.)) );\n    vec3 cu = normalize( cross(cd , cs) );\n    \n    float fov = 2.;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    \n    vec2 d  = march(cp,rd);\n    \n    //if(d.x > 0.)\n    {\n        col = setColor(d,cp,rd);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "MtlXzf", "previewfilepath": "https://soundcloud.com/tonoshake/period-space", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tonoshake/period-space", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [84, 84, 124, 124, 404], [406, 406, 435, 435, 522], [524, 524, 552, 552, 613], [615, 615, 637, 637, 834], [981, 1004, 1029, 1288, 2280], [2282, 2282, 2327, 2327, 2396], [2398, 2398, 2425, 2425, 2542], [2544, 2631, 2657, 2657, 3174], [3249, 3249, 3272, 3272, 3733], [3735, 3735, 3755, 3755, 3849], [3864, 3864, 3883, 3883, 4684], [4686, 4686, 4704, 4704, 4820], [4822, 4822, 4853, 4853, 5133], [5135, 5135, 5155, 5155, 5241], [5243, 5243, 5261, 5261, 5955], [5957, 5957, 5997, 5997, 7748], [7750, 7750, 7792, 7792, 9994], [9997, 9997, 10054, 10054, 10648]], "test": "untested"}
{"id": "7tf3Wj", "name": "Rock Noise3D", "author": "Beh_gin", "description": "3D noise and a sphere to make a rock like object to be seen from several angles and distances.\n\nThe 3D perlin noise may be wrong a little bit.", "tags": ["noise", "camera"], "likes": 1, "viewed": 44, "published": "Public", "date": "1623105089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS     420.0\n#define SURFACE_DIST  0.1\n#define MAX_DIST      10.0\n\nfloat smoothy(float t){return t*t*t*(3.-2.*t);}\n\nint octantX(vec3 point, vec3 center, out vec3[8] corners)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    corners = vec3[8](\n        vec3(center.x-res.x,center.y      ,center.z      ),vec3(center.x,center.y      ,center.z      ),\n        vec3(center.x-res.x,center.y-res.y,center.z      ),vec3(center.x,center.y-res.y,center.z      ),\n        vec3(center.x-res.x,center.y      ,center.z-res.z),vec3(center.x,center.y      ,center.z-res.z),\n        vec3(center.x-res.x,center.y-res.y,center.z-res.z),vec3(center.x,center.y-res.y,center.z-res.z));\n    \n    if (point.x > center.x+res.x ||\n        point.y > center.y+res.y ||\n        point.z > center.z+res.z ||\n        point.x < center.x-res.x ||\n        point.y < center.y-res.y ||\n        point.z < center.z-res.z)\n    {\n        return 8;\n    }\n    if (point.x > center.x)\n    {\n        if (point.y > center.y)\n        {\n            if (point.z > center.z)\n            {\n                for (int i = 0; i< 8; i++)\n                {\n                    corners[i].xyz += res.xyz;\n                }\n                return 0;\n            }\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].xy += res.xy;\n            }\n            return 1;\n        }\n        if (point.z < center.z)\n        {\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].xz += res.xz;\n            }\n            return 3;\n        }\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].x += res.x;\n        }\n        return 2;\n    }\n    if (point.y > center.y)\n    {\n        if (point.z > center.z)\n        {\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].yz += res.yz;\n            }\n            return 5;\n        }\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].y += res.y;\n        }\n        return 6;\n    }\n    if (point.z > center.z)\n    {\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].z += res.z;\n        }\n        return 4;\n    }\n    for (int i = 0; i< 8; i++)\n    {\n        //corners[i].x += res.x;\n    }\n    return 7;\n}\n\nint octant(vec3 point, vec3 center)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    \n    if (point.x > center.x+res.x ||\n        point.y > center.y+res.y ||\n        point.z > center.z+res.z ||\n        point.x < center.x-res.x ||\n        point.y < center.y-res.y ||\n        point.z < center.z-res.z)\n    {\n        return 8;\n    }\n    if (point.x > center.x)\n    {\n        if (point.y > center.y)\n        {\n            if (point.z > center.z)\n            {\n                return 0;\n            }\n            return 1;\n        }\n        if (point.z < center.z)\n        {\n            return 3;\n        }\n        return 2;\n    }\n    if (point.y > center.y)\n    {\n        if (point.z > center.z)\n        {\n            return 5;\n        }\n        return 6;\n    }\n    if (point.z > center.z)\n    {\n        return 4;\n    }\n    return 7;\n}\n\n\nfloat calcNoise3d(vec3[8] pos, vec3[8] height, vec3 center, vec3 point)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    float a, b, c, d, x, y, z;\n    x = smoothy((pos[0].x-point.x)/res.x);\n    y = smoothy((pos[0].y-point.y)/res.y);\n    z = smoothy((pos[0].z-point.z)/res.z);\n    a = mix(dot(point-pos[0],height[0]), dot(point-pos[1],height[1]), x);\n    b = mix(dot(point-pos[2],height[2]), dot(point-pos[3],height[3]), x);\n    c = mix(dot(point-pos[4],height[4]), dot(point-pos[5],height[5]), x);\n    d = mix(dot(point-pos[6],height[6]), dot(point-pos[7],height[7]), x);\n    return mix(mix(a,b,y),mix(c,d,y),z);\n}\n\nfloat calcNoise3(vec3[27] height, vec3 center, int octant, vec3 point)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    vec3[27] pos = vec3[27](\n                          vec3(center.x-res.x,center.y+res.y,center.z+res.z),vec3(center.x,center.y+res.y,center.z+res.z),vec3(center.x+res.x,center.y+res.y,center.z+res.z),\n                          vec3(center.x-res.x,center.y      ,center.z+res.z),vec3(center.x,center.y      ,center.z+res.z),vec3(center.x+res.x,center.y      ,center.z+res.z),\n                          vec3(center.x-res.x,center.y-res.y,center.z+res.z),vec3(center.x,center.y-res.y,center.z+res.z),vec3(center.x+res.x,center.y-res.y,center.z+res.z),\n                          \n                          vec3(center.x-res.x,center.y+res.y,center.z      ),vec3(center.x,center.y+res.y,center.z      ),vec3(center.x+res.x,center.y+res.y,center.z      ),\n                          vec3(center.x-res.x,center.y      ,center.z      ),vec3(center.x,center.y      ,center.z      ),vec3(center.x+res.x,center.y      ,center.z      ),\n                          vec3(center.x-res.x,center.y-res.y,center.z      ),vec3(center.x,center.y-res.y,center.z      ),vec3(center.x+res.x,center.y-res.y,center.z      ),\n                          \n                          vec3(center.x-res.x,center.y+res.y,center.z-res.z),vec3(center.x,center.y+res.y,center.z-res.z),vec3(center.x+res.x,center.y+res.y,center.z-res.z),\n                          vec3(center.x-res.x,center.y      ,center.z-res.z),vec3(center.x,center.y      ,center.z-res.z),vec3(center.x+res.x,center.y      ,center.z-res.z),\n                          vec3(center.x-res.x,center.y-res.y,center.z-res.z),vec3(center.x,center.y-res.y,center.z-res.z),vec3(center.x+res.x,center.y-res.y,center.z-res.z));\n    float a, b, c, d, x, y, z;\n    switch (octant) {\n    case 0: //1,2,4,5,10,11,13,14\n        x = smoothy((pos[1].x-point.x)/(res.x));\n        y = (pos[1].y-point.y)/(res.y);\n        z = (pos[1].z-point.z)/(res.z);\n        a = mix(dot(point-pos[1],height[1]), dot(point-pos[2],height[2]), x);\n        b = mix(dot(point-pos[4],height[4]), dot(point-pos[5],height[5]), x);\n        c = mix(dot(point-pos[10],height[10]), dot(point-pos[11],height[11]), x);\n        d = mix(dot(point-pos[13],height[13]), dot(point-pos[14],height[14]), x);\n        break;\n    case 1: //10,11,13,14,19,20,22,23\n        x = smoothy((pos[10].x-point.x)/(res.x));\n        y = (pos[10].y-point.y)/(res.y);\n        z = (pos[10].z-point.z)/(res.z);\n        a = mix(dot(point-pos[10],height[10]), dot(point-pos[11],height[11]), x);\n        b = mix(dot(point-pos[13],height[13]), dot(point-pos[14],height[14]), x);\n        c = mix(dot(point-pos[19],height[19]), dot(point-pos[20],height[20]), x);\n        d = mix(dot(point-pos[22],height[22]), dot(point-pos[23],height[23]), x);\n        break;\n    case 2: //13,14,16,17,22,23,25,26\n        x = smoothy((pos[13].x-point.x)/(res.x));\n        y = (pos[13].y-point.y)/(res.y);\n        z = (pos[13].z-point.z)/(res.z);\n        a = mix(dot(point-pos[13],height[13]), dot(point-pos[14],height[14]), x);\n        b = mix(dot(point-pos[16],height[16]), dot(point-pos[17],height[17]), x);\n        c = mix(dot(point-pos[22],height[22]), dot(point-pos[23],height[23]), x);\n        d = mix(dot(point-pos[25],height[25]), dot(point-pos[26],height[26]), x);\n        break;\n    case 3: //4,5,7,8,13,14,16,17\n        x = smoothy((pos[4].x-point.x)/(res.x));\n        y = (pos[4].y-point.y)/(res.y);\n        z = (pos[4].z-point.z)/(res.z);\n        a = mix(dot(point-pos[4],height[4]), dot(point-pos[5],height[5]), x);\n        b = mix(dot(point-pos[7],height[7]), dot(point-pos[8],height[8]), x);\n        c = mix(dot(point-pos[13],height[13]), dot(point-pos[14],height[14]), x);\n        d = mix(dot(point-pos[16],height[16]), dot(point-pos[17],height[17]), x);\n        break;\n    case 4: //3,4,6,7,12,13,15,16\n        x = smoothy((pos[3].x-point.x)/(res.x));\n        y = (pos[3].y-point.y)/(res.y);\n        z = (pos[3].z-point.z)/(res.z);\n        a = mix(dot(point-pos[3],height[3]), dot(point-pos[4],height[4]), x);\n        b = mix(dot(point-pos[6],height[6]), dot(point-pos[7],height[7]), x);\n        c = mix(dot(point-pos[12],height[12]), dot(point-pos[13],height[13]), x);\n        d = mix(dot(point-pos[15],height[15]), dot(point-pos[16],height[16]), x);\n        break;\n    case 5: //0,1,3,4,9,10,12,13\n        x = smoothy((pos[0].x-point.x)/(res.x));\n        y = (pos[0].y-point.y)/(res.y);\n        z = (pos[0].z-point.z)/(res.z);\n        a = mix(dot(point-pos[0 ],height[0 ]), dot(point-pos[1 ],height[1 ]), x);\n        b = mix(dot(point-pos[3 ],height[3 ]), dot(point-pos[4 ],height[4 ]), x);\n        c = mix(dot(point-pos[9 ],height[9 ]), dot(point-pos[10],height[10]), x);\n        d = mix(dot(point-pos[12],height[12]), dot(point-pos[13],height[13]), x);\n        break;\n    case 6: //9,10,12,13,18,19,21,22\n        x = smoothy((pos[9].x-point.x)/(res.x));\n        y = (pos[9].y-point.y)/(res.y);\n        z = (pos[9].z-point.z)/(res.z);\n        a = mix(dot(point-pos[9 ],height[9 ]), dot(point-pos[10],height[10]), x);\n        b = mix(dot(point-pos[12],height[12]), dot(point-pos[13],height[13]), x);\n        c = mix(dot(point-pos[18],height[18]), dot(point-pos[19],height[19]), x);\n        d = mix(dot(point-pos[21],height[21]), dot(point-pos[22],height[22]), x);\n        break;\n    case 7: //12,13,15,16,21,22,24,25\n        x = smoothy((pos[12].x-point.x)/(res.x));\n        y = (pos[12].y-point.y)/(res.y);\n        z = (pos[12].z-point.z)/(res.z);\n        a = mix(dot(point-pos[12],height[12]), dot(point-pos[13],height[13]), x);\n        b = mix(dot(point-pos[15],height[15]), dot(point-pos[16],height[16]), x);\n        c = mix(dot(point-pos[21],height[21]), dot(point-pos[22],height[22]), x);\n        d = mix(dot(point-pos[24],height[24]), dot(point-pos[25],height[25]), x);\n        break;\n    case 8:\n        return 1.;\n    }\n    y = smoothy(y);\n    z = smoothy(z);\n    return clamp(mix(mix(a,b,y), mix(c,d,y), z), 0., 1.); //done\n}\n\nfloat noise3simple(vec3 point)\n{\n    vec3 center = vec3(0., 0., 2.0);\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    \n    vec3[4] Parts = vec3[4](vec3(-1.,-1.,-1.),vec3(1.,1.,1.),vec3(.7,1.,-1.),vec3(.7,1.,.3));\n    vec3[8] height;\n    vec3[8] corners;\n    \n    int q = octantX(point, center, corners);\n    if (q == 8){return 1.;}\n    for (int i = 0; i < 8; i++)\n    {\n        height[i] = normalize(vec3(Parts[(i*q*23)%3].x, Parts[q*21*i%3].y, Parts[(i*755*q)%3].z));//*Parts[((i%2)*27)%2].y));\n    }\n    \n    return calcNoise3d(corners, height, center, point);\n}\n\nfloat noise3(vec3 point)\n{\n    vec3[4] Parts = vec3[4](vec3(-1.,-1.,-1.),vec3(1.,1.,1.),vec3(.7,1.,-1.),vec3(.7,1.,.3));\n    vec3[27] height;\n    for (int i = 0; i < 27; i++)\n    {\n        height[i] = normalize(vec3(Parts[(i*23)%2].x, Parts[21*i%2].y, Parts[(i*755)%4].z));//*Parts[((i%2)*27)%2].y));\n    }\n    \n    vec3 center = vec3(0., 0., 2.0);\n    int q = octant(point, center);\n    \n    return calcNoise3(height, center, q, point);\n}\n\nfloat getValue3(vec3 point)\n{\n    return (noise3simple(point))+distance(point, vec3(0.0, 0.0, 2.0))-.7;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float distFromOrigin = 0.0;\n    float dist;\n    for( float i=0.0; i<MAX_STEPS; i++ ){\n        vec3 point =vec3(ro.x, ro.y, ro.z);\n        point.xyz += rd.xyz * distFromOrigin;\n        //println(\"ray O: \" + rayOrigin);\n        //println(\"Point: \" + point);\n        dist = getValue3(point);\n        //println(dist);\n        distFromOrigin += MAX_DIST/MAX_STEPS;\n        if(dist < SURFACE_DIST || distFromOrigin>MAX_DIST){ break; }\n    }\n    return distFromOrigin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 objAt = vec3(0.,0.,2.);\n    vec3 camAt = vec3(cos(iTime/5.)*2.,sin(iTime/5.)*2., -iTime/50.);\n    vec2 screen = vec2(fragCoord/iResolution.xx*2. - iResolution.xy/iResolution.xx);\n    vec3 camDir = normalize(objAt - camAt);\n    camDir.xy += screen/2.;\n    camDir = normalize(camDir);\n    \n    float C = rayMarch(camAt, camDir)/MAX_DIST;\n    fragColor = vec4(vec3(C), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 105, 105, 129], [131, 131, 190, 190, 2229], [2231, 2231, 2268, 2268, 3067], [3070, 3070, 3143, 3143, 3690], [3692, 3692, 3764, 3764, 9706], [9708, 9708, 9740, 9740, 10276], [10278, 10278, 10304, 10304, 10717], [10719, 10719, 10748, 10748, 10824], [10826, 10826, 10860, 10860, 11328], [11330, 11330, 11387, 11387, 11769]], "test": "untested"}
{"id": "7tf3zl", "name": "Decic Bezier Curve", "author": "oneshade", "description": "Wanted to know what higher degree bezier curves look like. I find it hard to believe thats a polynomial.", "tags": ["2d", "bezier", "plot", "dash", "parametric", "decic"], "likes": 8, "viewed": 96, "published": "Public", "date": "1622609765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat anim(in float seed) {\n    float a = Hash11(seed * 193.84 + 673.48);\n    float b = Hash11(seed * 348.46 + 183.37);\n    float c = Hash11(seed * 275.35 + 741.69);\n    return 2.0 * sin(iTime * a + b) * c;\n}\n\nvec2 decicBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i, in vec2 j, in vec2 k, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv +\n           10.0 * b * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t +\n           45.0 * c * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t * t +\n           120.0 * d * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t * t * t +\n           210.0 * e * tInv * tInv * tInv * tInv * tInv * tInv * t * t * t * t +\n           252.0 * f * tInv * tInv * tInv * tInv * tInv * t * t * t * t * t +\n           210.0 * g * tInv * tInv * tInv * tInv * t * t * t * t * t * t +\n           120.0 * h * tInv * tInv * tInv * t * t * t * t * t * t * t +\n           45.0 * i * tInv * tInv * t * t * t * t * t * t * t * t +\n           10.0 * j * tInv * t * t * t * t * t * t * t * t * t +\n           k * t * t * t * t * t * t * t * t * t * t;\n\n    /*\n    vec2 a1 = mix( a,  b, t), a2 = mix( b,  c, t), a3 = mix( c,  d, t), a4 = mix( d,  e, t), a5 = mix( e,  f, t), a6 = mix( f,  g, t), a7 = mix( g,  h, t), a8 = mix( h,  i, t), a9 = mix( i,  j, t), a10 = mix( j,  k, t);\n    vec2 b1 = mix(a1, a2, t), b2 = mix(a2, a3, t), b3 = mix(a3, a4, t), b4 = mix(a4, a5, t), b5 = mix(a5, a6, t), b6 = mix(a6, a7, t), b7 = mix(a7, a8, t), b8 = mix(a8, a9, t), b9 = mix(a9, a10, t);\n    vec2 c1 = mix(b1, b2, t), c2 = mix(b2, b3, t), c3 = mix(b3, b4, t), c4 = mix(b4, b5, t), c5 = mix(b5, b6, t), c6 = mix(b6, b7, t), c7 = mix(b7, b8, t), c8 = mix(b8, b9, t);\n    vec2 d1 = mix(c1, c2, t), d2 = mix(c2, c3, t), d3 = mix(c3, c4, t), d4 = mix(c4, c5, t), d5 = mix(c5, c6, t), d6 = mix(c6, c7, t), d7 = mix(c7, c8, t);\n    vec2 e1 = mix(d1, d2, t), e2 = mix(d2, d3, t), e3 = mix(d3, d4, t), e4 = mix(d4, d5, t), e5 = mix(d5, d6, t), e6 = mix(d6, d7, t);\n    vec2 f1 = mix(e1, e2, t), f2 = mix(e2, e3, t), f3 = mix(e3, e4, t), f4 = mix(e4, e5, t), f5 = mix(e5, e6, t);\n    vec2 g1 = mix(f1, f2, t), g2 = mix(f2, f3, t), g3 = mix(f3, f4, t), g4 = mix(f4, f5, t);\n    vec2 h1 = mix(g1, g2, t), h2 = mix(g2, g3, t), h3 = mix(g3, g4, t);\n    vec2 i1 = mix(h1, h2, t), i2 = mix(h2, h3, t);\n    return mix(i1, i2, t);\n    */\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 a = vec2(anim( 1.0) * 3.0, anim( 2.0));\n    vec2 b = vec2(anim( 3.0) * 3.0, anim( 4.0));\n    vec2 c = vec2(anim( 5.0) * 3.0, anim( 6.0));\n    vec2 d = vec2(anim( 7.0) * 3.0, anim( 8.0));\n    vec2 e = vec2(anim( 9.0) * 3.0, anim(10.0));\n    vec2 f = vec2(anim(11.0) * 3.0, anim(12.0));\n    vec2 g = vec2(anim(13.0) * 3.0, anim(14.0));\n    vec2 h = vec2(anim(15.0) * 3.0, anim(16.0));\n    vec2 i = vec2(anim(17.0) * 3.0, anim(18.0));\n    vec2 j = vec2(anim(19.0) * 3.0, anim(20.0));\n    vec2 k = vec2(anim(21.0) * 3.0, anim(22.0));\n\n    bool dash = true;\n    vec2 prevPos = a;\n    for (float t=0.01; t < 1.01; t += 0.01) {\n        vec2 curPos = decicBezier(a, b, c, d, e, f, g, h, i, j, k, t);\n        if (dash) color = mix(color, hue2rgb(t + iTime), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos)));\n        prevPos = curPos;\n        dash = !dash;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 184, 184, 309], [311, 400, 426, 426, 512], [514, 514, 541, 541, 722], [724, 724, 875, 875, 2999], [3001, 3001, 3056, 3056, 4097]], "test": "untested"}
{"id": "7tf3zX", "name": "Fork Mauno mosaic 006", "author": "mosaic", "description": "A variation of the Mandelbrot fractal", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 137, "published": "Public API", "date": "1622501035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= 0.072;\n    st -= vec2(0.200,-0.990);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec2 z = st;\n    \n    for (int i=0; i<109; i++) {\n    \tvec2 z2;\n        z2.x = z.x*z.x - z.y*z.y * 1.01 + 0.011 * cos(iTime*2.123);\n        z2.y = z.x*z.y * 2.0 + 0.02 * sin(iTime);\n        z = z2;\n        z += st;\n        float d = z.x*z.x + z.y*z.y * (0.15*z.y+0.85);\n        if (d > 4.0) {\n            float step = 1.0 / 30.0;\n\t\t    color = vec3(float(i) * step);\n            vec3 cc = vec3(\n                1.0-(sqrt(cos(0.3*d))-2.0),\n                1.0-(sqrt(cos(0.6*d))-2.0),\n                1.0-(sqrt(cos(0.3*d))-2.0)\n            );\n            color += 0.4 * (0.5 + 0.5 * sin(-3.0 * iTime + 150.0 * step * cc ));\n            break;\n        }\n    }\n\n\n   return vec4(color, 1); // At the end of your shader, replace the fragColor with this return. \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 4.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 1023], [1025, 1025, 1082, 1082, 1384]], "test": "untested"}
{"id": "7tj3DG", "name": "Randon friday fractal", "author": "mrange", "description": "License CC0: Random friday fractal\nResult after a bit of random coding on friday afternoon\n", "tags": ["3d", "raymarching"], "likes": 12, "viewed": 181, "published": "Public API", "date": "1624645212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Random friday fractal\n// Result after a bit of random coding on friday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\n\nfloat df(vec3 p) {\n  float d = 1E6;\n\n  const float zf = 2.;\n  const vec3 nz = normalize(vec3(1.0, .0, -1.0));\n  const vec3 ny = normalize(vec3(1.0, -1., 0.0));\n  float z = 1.0;\n  const float rsm = 0.125*0.25;\n  const float a = 128.25; \n  const mat2 rxy = ROT(a);\n  const mat2 ryz = ROT(a*sqrt(0.5));\n  \n  for (int i = 0; i < 7; ++i) {\n    vec3 pp0 = p;\n    vec3 pp1 = p;\n    float dd0 = box(pp0, vec3(0.25))-0.01;\n    float dd1 = length(pp1)-0.3;\n    float dd  = dd0;\n    dd =  pmax(dd, -dd1, 0.05);\n    dd = min(dd, length(pp0)- 0.25);\n    dd  /= z;\n    \n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(0.85/zf, 0.0, 0.0);\n    d = pmax(d, -(dd-0.1/z), 0.05/z);\n    \n    if(i > 2)\n    d = min(d, dd);\n  \n  }\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  if (t >= MAX_RAY_LENGTH) {\n    return vec3(0.0);\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n\n  float ifade= 1.0-tanh_approx(1.25*ii);\n  vec3 hsv   = vec3(1.25-t*0.5, mix(0.25, 1.0, ii), 1.0);\n  vec3 color = hsv2rgb(hsv);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 5.0/ll2;\n  float dif = max(dot(nor,ld),0.0)*(dm+0.05);  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*sha;\n\n  return col*ifade;\n//  return vec3(ao);\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3DG.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 458, 486, 506, 582], [584, 637, 659, 659, 828], [830, 830, 866, 866, 1099], [1101, 1101, 1128, 1128, 1215], [1217, 1217, 1256, 1256, 1345], [1347, 1347, 1386, 1386, 1415], [1417, 1417, 1453, 1453, 1541], [1543, 1543, 1571, 1571, 1599], [1602, 1602, 1620, 1620, 2461], [2463, 2463, 2511, 2511, 2706], [2708, 2708, 2731, 2731, 2939], [2941, 2941, 3009, 3009, 3288], [3290, 3290, 3321, 3321, 4250], [4252, 4252, 4283, 4283, 4765], [4767, 4767, 4822, 4822, 5012]], "test": "untested"}
{"id": "7tj3R1", "name": "Diff Light w/ Spec Highlights", "author": "trigophers", "description": "MOVE WITH MOUSE!!", "tags": ["ray", "specular", "diffuse", "madness"], "likes": 2, "viewed": 46, "published": "Public", "date": "1623380545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define maxDist 10000.\n#define specAmount 0.988\nvec3 center;\nvec3 ray;\nfloat rdist;\nvec3 color;\nvec3 normal;\n\nvoid sphere(vec4 posRad, vec3 sColor) {\n    vec3 obj = posRad.xyz - center;\n    vec3 temp = vec3(dot(obj, ray), dot(obj, obj), 0.);\n    if ((temp.x>0.0) && (posRad.w*posRad.w > (temp.y - temp.x*temp.x))) {\n        temp.z = sqrt(posRad.w*posRad.w - (temp.y - temp.x*temp.x));\n        if ((temp.y > posRad.w*posRad.w) && rdist > temp.x - temp.z) {\n            rdist = temp.x - temp.z;\n            normal = normalize(center+ray*rdist-posRad.xyz);\n            color = sColor;\n        }\n    }\n}\n\nvoid scene() {\n    sphere(vec4(0, 5, 30, 5), vec3(1, 0, 0));\n    sphere(vec4(5, 4, 30, 4), vec3(0, 1, 0));\n    sphere(vec4(0, -1000000, 30, 1000000), vec3(0.2, 0.5, 0.5));\n}\n\nvec3 raytrace(vec2 uv) {\n    center = vec3(iMouse.x-iResolution.x/2., 5, iMouse.y-iResolution.y/2.);\n    ray = normalize(vec3(uv, 1));\n    rdist = maxDist;\n    scene();\n    if (rdist<maxDist) {\n        vec3 light = vec3(cos(iTime)*10., 30., sin(iTime)*10.+30.);\n        vec3 lightVec = normalize(light-(center+rdist*ray));\n        vec3 saveC = vec3(clamp(dot(lightVec, normal), 0., 1.));\n        vec3 saveOC = color;\n        vec3 specRef = normalize(reflect(ray, normal));\n        center = center+rdist*ray+normal/100000.;\n        ray = lightVec;\n        rdist = maxDist;\n        scene();\n        if (rdist<maxDist && rdist < length(center-light)) {\n            return saveOC*0.02;\n        } else {\n            float spec = dot(specRef, lightVec);\n            if (spec>specAmount) {return saveOC*saveC+smoothstep(0., 1.75, (spec-specAmount)*100.);}\n        }\n        return vec3((saveC+0.02)*saveOC);\n    } else {\n        return vec3(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.)/iResolution.yy;\n    vec3 superSample = vec3(0.);\n    superSample += raytrace(uv+vec2(1./iResolution.x/2., -1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(-1./iResolution.x/2., -1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(1./iResolution.x/2., 1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(-1./iResolution.x/2., 1./iResolution.x/2.));\n    superSample /= 4.;\n    fragColor = vec4(pow(superSample, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 149, 149, 599], [601, 601, 615, 615, 774], [776, 776, 800, 800, 1721], [1723, 1723, 1780, 1780, 2284]], "test": "untested"}
{"id": "7tj3z3", "name": "Spinning fractal spirals 2", "author": "jarble", "description": "These spirals spin in galaxy-like patterns.", "tags": ["fractal", "spiral", "galaxy", "spin"], "likes": 5, "viewed": 137, "published": "Public API", "date": "1624415920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//golfed version by FabriceNeyret2\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n         U = ( R/20. -.5*U ) / R.y;\n\n    float s = .5, t = 1./1.27,\n          S = 1./t + mod( iTime/16.*t, 2.);\n    O-=O;          \n    for( int N=12, i, c=0; \n         c++ < N; \n         O = ( vec4(O.rg,abs(U.y-U)) + O.gbra ) / 2.125\n       )        \n        for( i=0; i++ < N; )       \n            U = -fract( ( U.yx + U*mat2(s,s,t,t ) * s  ) * t * vec2(-S,1./S) );       \n \n    O *= 3.;    \n}\n\n/*\n//original by jarble\n\n#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.27;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = -(fragCoord.yx*10.0-iResolution.yx)/iResolution.y/20.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = (iTime)/16.;\n    float spin = scale1+fract(s1/scale1/2.)*2.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= -(-uv-((vec2(uv.x/scale+uv.y/scale,uv.y/scale1+uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -spin;\n            //uv = (uv);\n            uv.y /= spin;\n            uv = -fract(uv.yx);\n            //uv /= 1.01;\n        }\n        col[2] = abs((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 73, 73, 498]], "test": "untested"}
{"id": "7tjGDW", "name": "Fork CBM 3D hayesmaker 945", "author": "hayesmaker64", "description": "cbm logo", "tags": ["raymarch", "logo", "extrude", "cbm"], "likes": 1, "viewed": 129, "published": "Public API", "date": "1623937040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// yx's commodore shape from here - https://www.shadertoy.com/view/4lGfzK\n//\n// Raymarched by Del 25/11/2018\n\nfloat cbm(vec2 p)\n{\n    const float A = 10.;\n    const float B = 0.034 * A;\n    const float C = 0.166 * A;\n    const float E = 0.364 * A;\n    const float F = 0.52 * A;\n    const float G = 0.53 * A;\n    const float H = 75.636 * A;\n    const float I = 0.97 * A;\n    \n    p.y = abs(p.y);\n    \n    float outerCircle = length(p)-I*.5;\n    float innerCircle = length(p*vec2(F/G,1))-F*.5;\n    float verticalMask = p.x-(H-I*.5);\n    \n    float topMask = p.y-C-B*.5;\n    float bottomMask = p.y-B*.5;\n    float angleMask = ((p.x-p.y)-A+I*.5+E*.5)/sqrt(2.);\n    \n    float vents = max(max(angleMask,max(topMask,-bottomMask)), -verticalMask);\n    \n    float ring = max(max(outerCircle,-innerCircle),verticalMask);\n    \n    return min(vents, ring);\n}\n\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\n\nfloat map(vec3 p)\n{\n    float time = iTime+0.2;\n    p.z -= 13.0+sin(fract(time*0.15)*TAU)*2.0;\n    \n    float twist = 0.5+sin(fract(time*0.25)*TAU)*0.5;\n    twist *= p.y * 0.1;\n    p.xz *= rotate(twist+fract(time*0.26)*TAU);\n    \n    float dist = cbm(p.xy);\n    \n    float dep = 0.5;\n    vec2 e = vec2( dist, abs(p.z) - dep );\n    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    dist -= 0.07;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += d *0.75;\n\t}\n    \n    vec3 c = vec3(0.35,0.35,0.45);\n    c*= 1.2-abs(uv.y);\n    \n    if (t<100.0)\n    {\n\t   \tvec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n        vec3 nor = normal(p);\n\n        float dif = max(dot(nor, lightDir), 0.0);\n        c = vec3(0.5) * dif;\n\n        float tf = 0.02;\n        c += vec3(0.65,0.6,0.25) + reflect(vec3(p.x*tf, p.y*tf,tf), nor);\n\n        vec3 ref = reflect(rd, nor);\n        float spe = max(dot(ref, lightDir), 0.0);\n        c += vec3(2.0) * pow(spe, 32.);\n    }\n\n    c *= 1.0 - 0.3*length(uv);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 129, 129, 847], [850, 850, 872, 872, 939], [962, 962, 981, 981, 1380], [1383, 1455, 1481, 1596, 1792], [1793, 1793, 1815, 1815, 2584], [2586, 2586, 2643, 2643, 2803]], "test": "untested"}
{"id": "7tlGDj", "name": "PerlinPlasma", "author": "gombie", "description": "Old school plasma + perlin noise", "tags": ["plasma"], "likes": 3, "viewed": 40, "published": "Public", "date": "1622901629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float M_PI = 3.14159265358979323846264338327950288;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = vec2(uv*5.0);\n    float n = noise(pos);\n    float cx=uv.x+0.5*sin(iTime/5.0);\n    float cy=uv.y+0.5*cos(iTime/3.0);\n    float v=sin(sqrt(100.0*(cx*cx+cy*cy)+1.0)+iTime);\n    v+=sin(10.0*(uv.x*sin(iTime/2.0))+uv.x*cos(iTime/3.0)+iTime);\n    v+=sin(uv.x*10.0+iTime);\n    vec3 col=vec3(cos(v*M_PI), sin(v*M_PI*n),sin(v*M_PI));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 144], [146, 233, 259, 259, 776], [778, 778, 835, 835, 1309]], "test": "untested"}
{"id": "7tlGDs", "name": "Ray Marching - Intersection", "author": "ChaosOfZen", "description": "A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/", "tags": ["raymarching", "intersection", "boolean"], "likes": 0, "viewed": 19, "published": "Public", "date": "1623160311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n// The Art of Code: The Art Of Code Youtube\n// Inigo Quilez: http://www.iquilezles.org\n\n// Constants\n#define PI 3.1415925359\n//#define TWO_PI 6.2831852\n#define MAX_STEPS 100 // Mar Raymarching steps\n#define MAX_DIST 100. // Max Raymarching distance\n#define SURFACE_DIST .01 // Surface Distance\n \n///////////////////////\n// Boolean Operators\n///////////////////////\n \nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n \nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//////////////////////////\n \nmat2 Rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n \nfloat sphereSDF( vec3 p, float s ) {\n  return length(p)-s;\n}\n \nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n \nfloat GetDist(vec3 p) \n{   \n    // Rotate the whole scene\n    p.xz *=Rotate(iTime / 2.0);\n   \n    // Sphere. xyz is position w is radius\n    vec4 s0 = vec4(0,1,0,1);\n    float sphereDist_0 = sphereSDF(p-s0.xyz,s0.w);\n     \n    // Box\n    vec3 b0s = vec3(.8,.8,.8); //box size\n    vec3 b0p = vec3(0,1,0); // box position\n    float boxDist_0 = boxSDF(p-b0p,b0s);\n   \n    // Plane\n    float planeDist  = p.y;\n \n    float d = 0.0;\n    d = intersectSDF(boxDist_0,sphereDist_0);\n    // Uncomment to view the box\n    //d = min(boxDist_0,sphereDist_0);\n    d = min(d,planeDist);\n \n    return d;\n}\n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) \n            break;\n    }\n    return dO;\n}\n \nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),  // e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n \n    return normalize(n);\n}\n \nfloat GetLight(vec3 p)\n{ \n    // Directional light\n    vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n \n    // Shadows\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n     \n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro = vec3(0,1,-6); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n     \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n    d*= .2;\n    vec3 color = vec3(dif);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 446, 492, 492, 524], [527, 527, 569, 569, 601], [604, 604, 651, 651, 684], [685, 714, 736, 736, 809], [812, 812, 848, 848, 872], [875, 875, 907, 907, 994], [997, 997, 1021, 1054, 1585], [1588, 1588, 1623, 1623, 1892], [1895, 1895, 1919, 1919, 2212], [2215, 2215, 2239, 2265, 2675], [2678, 2678, 2735, 2735, 3146]], "test": "untested"}
{"id": "7tlGRs", "name": "Ray-Object Intersection", "author": "abi", "description": "I'm going to use this shader as a sandbox to learn Ray-Object Intersection. So far, I've got Ray-Sphere intersection working.", "tags": ["raytracing", "intersection"], "likes": 2, "viewed": 39, "published": "Public", "date": "1622680401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AMBIENT_LIGHTING 1.0\n\n// Map value to the [0, 1] range\nfloat map(float a, float b, float val)\n{\n    return (val - a) / (b - a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Map coordinates to the [-1, 1] range\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    // Even aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Default color (background)\n    vec3 diffColor = vec3(0.4);\n    \n    // Ray to be thrown\n    vec3 rayOrg = vec3(0);\n    vec3 rayDir = normalize(vec3(uv, 1));\n    \n    // Sphere properties\n    vec3 sphCenter = vec3(0, 0, 4);\n    sphCenter.xz += vec2(sin(iTime), cos(iTime));\n    float sphRadius = 1.5;\n    \n    //\n    // Ray-Sphere interesection calculation\n    //\n    \n    // Midpoint between the two intersection points\n    // NOTE: for rays tangent to the surface, it is the intersection point itself\n    float midPoint = dot(sphCenter - rayOrg, rayDir);\n    vec3 currPoint = rayOrg + rayDir * midPoint;\n    \n    // Compute color for the sphere fragments\n    float y = length(sphCenter - currPoint);\n    if (y < sphRadius)\n    {\n        float x = sqrt(sphRadius * sphRadius - y * y); \n        float intersectPoint = midPoint - x;\n        \n        float distToSphere = abs(sphCenter.z - rayOrg.z - sphRadius);\n        float distToPoint = abs(intersectPoint - rayOrg.z);\n        \n        vec3 localColor = vec3(AMBIENT_LIGHTING) * vec3(0.5, 1, 1);\n        diffColor = localColor * vec3(map(distToSphere + sphRadius, distToSphere, distToPoint));\n     }\n    \n    // Output to screen\n    fragColor = AMBIENT_LIGHTING * vec4(diffColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 63, 103, 103, 137], [139, 139, 194, 238, 1627]], "test": "untested"}
{"id": "7tS3Dw", "name": "strange ray marching", "author": "kali_22", "description": "i tried to make the model of rotating planets", "tags": ["raymarching"], "likes": 1, "viewed": 41, "published": "Public", "date": "1624000955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat getDist(vec3 p){\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float planeDist = p.y;\n    float speed = 0.1;\n    float dis = 2.0;\n    float d = distance(sphere.xyz,p) - sphere.w;\n    for (int i = 0; i < 10; i+=1){\n        float j = float(i);\n        sphere = vec4(0.0 + sin(iTime*j*speed)*dis*j,1.0, 6.0 + cos(iTime*j*speed)*dis*j, 1.0-j*0.05);\n        d = min(distance(sphere.xyz, p) - sphere.w,d);\n    }\n    d = min(d, planeDist);\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    for(int i = 0; i < 100; i+=1){\n        vec3 p = ro + rd*dO;\n        dO += getDist(p);\n        if(dO > 100.0 || dO < 0.1) break;\n    }\n    return dO;\n}\nvec3 getNormal(vec3 p){\n    float d = getDist(p);\n    vec2 e = vec2(0.01,0.0);\n    vec3 n = d - vec3(getDist(p - e.xyy), getDist(p - e.yxy), getDist(p - e.yyx));\n    return normalize(n);\n}\nfloat getLight(vec3 p){\n    vec3 lo = vec3(0, 8, 2);\n    vec3 l = normalize(lo - p);\n    vec3 n = getNormal(p);\n    return dot(n,l);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n    \n    vec3 ro = vec3(0, 2.0+sin(iTime),-3.0+cos(iTime));\n    vec3 dr = normalize(vec3(uv, 1.0));\n    float d = RayMarch(ro, dr);\n    vec3 p = ro + dr * d;\n    fragColor.rgb = vec3(d/12.0, getLight(p), d/5.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 449], [450, 450, 483, 483, 658], [659, 659, 682, 682, 847], [848, 848, 871, 871, 982], [983, 983, 1040, 1040, 1315]], "test": "untested"}
{"id": "7tS3Dy", "name": "polyhedron Frame", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 13, "viewed": 263, "published": "Public API", "date": "1624610223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,n=vec3(-.5,-.707,.5),\n    d=normalize(vec3((C-.5*r.xy),r.y));  \n    for(float i=0.,e,g=0.;\n        ++i<99.;\n        O.xyz+=mix(vec3(1),H(length(p)*.5+iTime*3.),.7)*.05*exp(-.03*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=10.;\n        p=R(p,normalize(vec3(-1,-2,2)),iTime*.5);\n        for(int j=0;j<4;j++)\n            p.xy=abs(p.xy),\n            p-=2.*min(0.,dot(p,n))*n;\n        p.z=fract(log(p.z)-iTime*.5)-.5;\n        g+=e=abs(min(length(p.yz),length(p.xz))-.03)+.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 664]], "test": "untested"}
{"id": "7tS3RG", "name": "mandelbrot 001", "author": "RiceFields", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 65, "published": "Public", "date": "1624099815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B 10.0\n#define N 200\n#define PERIOD 10.0\n\nfloat mandelbrot(vec2 c) {\n   vec2 z = vec2(.0);\n   float n = .0;\n   for(int i = 0; i < N; ++i) {\n     z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; // z = z^2 + c\n     if( dot(z,z)>(B*B) ) break; // break if z is too high\n     n += 1.0;\n   }\n   return (n == 200.0)? .0: n/float(N);\n}\n\nvec3 image(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0; // remap uv to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // calculate and apply zoom\n    float zoom = .62 + .38*cos(iTime/PERIOD);\n    zoom = pow(zoom, 7.0);\n    vec2 c = vec2(-.745,.186) + uv*zoom;\n    \n    float f = mandelbrot(c)*2.0 - .5;\n    \n    // calculate color\n    vec3 col = mix(vec3(.81,.06,.13), vec3(.80,.40,.0), f*f);\n\n    return (f*f*(8.0 - 5.0*f))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// anti-aliasing\n\tfragColor = vec4(image(fragCoord.xy + vec2(0,0)), 1.0f);\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.0));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.0,.5));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.5));\n    fragColor.rgb += image(fragCoord.xy + vec2(.25,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.25,.75));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.75));\n\tfragColor.rgb /= 8.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 76, 76, 336], [338, 338, 366, 366, 815], [818, 818, 875, 893, 1358]], "test": "untested"}
{"id": "7tS3WG", "name": "Glowing confetti", "author": "jarble", "description": "A shower of brightly-colored objects.", "tags": ["fractal", "confetti"], "likes": 3, "viewed": 137, "published": "Public API", "date": "1624582433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = -1.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/9.0;\n    float s1 = (uv.y*4.+iTime)/32.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv.y /= scale;\n            uv = (uv+vec2(s1-uv.x+uv.y)/scale);\n            //uv.y -= col.x/16.;\n            uv.x *= -scale*1.01;\n            \n            uv = fract(uv.yx);\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 698]], "test": "untested"}
{"id": "7tS3Wh", "name": "Simple Spherical Harmonics", "author": "weasel", "description": "Very simple viewer for spherical harmonics of any degree l, m. Use Mouse to move.\n\nIn the code I have some superpositions of the functions to explore for interested students.", "tags": ["3d", "sphere", "physics"], "likes": 12, "viewed": 128, "published": "Public", "date": "1623795232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plot Spherical Harmonics (in the simplest way possible on GPU)\n\n/*** math heavy part for spherical harmonics ***/\n\n//#define PI 3.14159265359\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(1.0-x*x, float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n/*** now all the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotate(vec3 pos, float phi, float theta) {\n    return rotateX(rotateX(pos, theta).yzx, phi).zxy;\n}\n\nvec3 colormap(float v) {\n    return vec3(1.0) - smoothstep(0., 1., sqrt(abs(v)))*(v > 0.0 ? vec3(1,1,0) : vec3(0,1,1));\n}\n\nvec3 sphere(vec2 uv, float phi, float theta, int l, int m) {\n    if (length(uv) < 1.0 && abs(m) <= l) {\n        vec3 pos = vec3(uv, sqrt(1.0-dot(uv,uv)));\n        float z = pos.z;\n        \n        // rotate sphere\n        pos = rotate(pos, phi, theta);\n        \n        // get spherical coordinates\n        float sin_theta = length(pos.xz);\n        float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.z) : 0.0;\n        float ball_theta = atan(sin_theta, pos.y);\n        \n        // evaluate spherical harmonics\n        float off = m == 0 ? 0.0 : iTime/float(m);\n        vec2 sph_harm = sphere_harm(ball_theta, ball_phi + off, l, m);\n        \n        // normalization for visual purposes\n        sph_harm *= SQRT2PI/2.0;\n        \n        // return color mapped real part of the function (.x)\n        return colormap(sph_harm.x) * sqrt(sqrt(z));\n    }\n    return vec3(0.0);\n}\n\nvec3 sphere_superposition(vec2 uv, float phi, float theta) {\n    if (length(uv) < 1.0) {\n        vec3 pos = vec3(uv, sqrt(1.0-dot(uv,uv)));\n        float z = pos.z;\n        \n        // rotate sphere\n        pos = rotate(pos, phi, theta);\n        \n        // get spherical coordinates\n        float sin_theta = length(pos.xz);\n        float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.z) : 0.0;\n        float ball_theta = atan(sin_theta, pos.y);\n        \n        // evaluate spherical harmonics\n        vec2 tmul = cexp(vec2(0.0,iTime));\n        \n        vec2 Y00 = sphere_harm(ball_theta, ball_phi, 0, 0);\n        vec2 Y10 = sphere_harm(ball_theta, ball_phi, 1, 0);\n        vec2 Y11 = sphere_harm(ball_theta, ball_phi, 1, 1);\n        vec2 Y1n1 = sphere_harm(ball_theta, ball_phi, 1, -1);\n        \n        vec2 s = Y00; // s orbit\n        vec2 px = 1.0/sqrt(2.0)*(Y11+conj(Y11)); // px orbit\n        vec2 py = -cmul(vec2(0,1),1.0/sqrt(2.0)*(Y11-conj(Y11))); // py orbit\n        vec2 pz = Y10; // pz orbit\n        \n        vec2 sph_harm = cmul(tmul, 0.25*(s + px + py + pz)); // sp3 hybrid\n        //vec2 sph_harm = cmul(tmul, (Y11 + Y1n1) / sqrt(2.0));\n        //vec2 sph_harm = vec2(sqr(Y10) + sqr(Y11) + sqr(Y1n1)) / 3.0 - sqr(Y00); // zero\n        \n        // normalization for visual purposes\n        sph_harm *= SQRT2PI/2.0;\n        \n        // return color mapped real part of the function (.x)\n        return colormap(sph_harm.x) * sqrt(sqrt(z));\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // This value selects the visible region\n    float zoom = 5.0;\n    vec2 move = iMouse.z > 0.0 ? vec2(2.0, 3.0)*(m-vec2(0.8, 0.5)) : vec2(0.0);\n    vec2 uv2 = (uv - move - vec2(0.0, 0.5))*zoom-vec2(0.5,0.0);\n    uv = uv * 2.0 - 1.0;\n    \n    m = m * 2.0 - 1.0;\n    \n\tm.x *= iResolution.x/iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;\n    uv2.x *= iResolution.x/iResolution.y;\n    \n    // draw grid of all spherical harmonics\n    ivec2 cell = ivec2(floor(uv2 + 0.5));\n    vec2 cell_local = fract(uv2 + 0.5) * 2.0 - 1.0;\n    vec3 col = sphere(cell_local, m.x, -m.y*0.6, cell.x, cell.y);\n    \n    // superposition of spherical harmonics for atomic orbits\n    //vec3 col = sphere_superposition(uv, m.x, -m.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 190, 208, 208, 304], [306, 326, 345, 345, 442], [444, 481, 507, 507, 717], [719, 742, 761, 761, 809], [811, 837, 864, 864, 929], [931, 954, 973, 973, 999], [1001, 1035, 1055, 1055, 1069], [1070, 1070, 1089, 1089, 1108], [1110, 1145, 1189, 1189, 1655], [1657, 1689, 1745, 1745, 1923], [1925, 1958, 1995, 1995, 2058], [2060, 2060, 2107, 2107, 2163], [2165, 2165, 2189, 2189, 2286], [2288, 2288, 2348, 2348, 3160], [3162, 3162, 3222, 3222, 4645], [4647, 4647, 4702, 4752, 5613]], "test": "untested"}
{"id": "7tS3z1", "name": "Dancing Floor", "author": "Holanderman", "description": "Sphere traced sdf", "tags": ["sdf"], "likes": 2, "viewed": 43, "published": "Public", "date": "1623341934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Thanks Iquizles\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Thanks Iquizles\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Thanks Iquizles\nfloat opRepBox( in vec3 p, vec3 b, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox( q, b );\n}\n\n// Thanks Iquizles\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Thanks Iquizles\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n// For complex scenes features such as as shadows become more difficult in shadertoy since\n// each reflecting / refreacting ray needs to be tested against the rest of the scene,\n// it's for this reason that I'm opting to move the entire scene into a single sdf\nfloat sceneSDF(vec3 testPoint)\n{\n    float cubeSet0Time = iTime;\n    float cubeSet1Time = iTime + 3.14159;\n    float cubeSet2Time = iTime - 2.0;\n    float cubeSet0Y = sin(cubeSet0Time) * 0.25;\n    float cubeSet0X = cos(cubeSet0Time);\n    float cubeSet1Y = sin(iTime * 0.7 + 3.14159) * 0.25;\n    float cubeSet2Y = sin(cubeSet2Time) * 0.25;\n    float cubeSet2z = cos(cubeSet2Time);\n    \n    float sdfSphere = sdSphere(testPoint - vec3(0.0, 1.0, 0.0), 1.0);\n    float frame = sdBoxFrame(testPoint - vec3(0.0, 1.0, 0.0), vec3(4.0, 4.0, 4.0), 0.2);\n    float sdfCubeSet0 = opRepBox(testPoint + vec3(cubeSet0X, cubeSet0Y, 0.0),vec3(0.5, 0.5, 0.5), vec3(2.0, 0.0, 2.0));\n    float sdfCubeSet1 = opRepBox(testPoint + vec3(0.0, cubeSet1Y, 0.0),vec3(0.5, 0.75, 0.5), vec3(2.0, 0.0, 2.0));\n    float sdfCubeSet2 = opRepBox(testPoint + vec3(0.0, cubeSet2Y, cubeSet2z),vec3(0.5, 0.5, 0.5), vec3(2.0, 0.0, 2.0));\n   \n   \n    float sdf = opSmoothUnion(sdfCubeSet0, sdfCubeSet1, 0.2);\n    sdf = opSmoothUnion(sdf, sdfCubeSet2, 0.2);\n    sdf = opSmoothUnion(sdf, sdfSphere, 0.5);\n    sdf = opSmoothUnion(sdf, frame, 0.5);\n    return sdf;\n}\n\n// Thanks Iquizles\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\n\n\n//\n\nbool sphereCast(vec3 rayOrigin, vec3 rayDirection, int iterations, out vec3 hitPosition)\n{\n    const float epsilon = 0.001;\n\n    vec3 currentPosition = rayOrigin;\n    for(int i = 0; i < iterations; ++i)\n    {\n        float distanceFrom = sceneSDF(currentPosition);\n        if(distanceFrom <= epsilon)\n        {\n            hitPosition = currentPosition;\n            return true;\n        }\n        \n        currentPosition += (rayDirection * distanceFrom);\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera_pos = vec3(0.0, 3.0, -7.0);\n    vec3 camera_lookat = vec3(0.0, 0.0, 0.0);\n\n    // Animate camera\n    camera_pos.x += sin(iTime * 0.3) * 5.0;\n    camera_pos.y += sin(iTime * 0.7);\n\n    // Screen\n    vec3 camera_z = normalize(camera_lookat - camera_pos);\n    vec3 camera_x = normalize(cross(vec3(0.0, 1.0, 0.0), camera_z));\n    vec3 camera_y = normalize(cross(camera_z, camera_x));\n\n    float fov_y = 1.0;\n    float fov_x = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 screen_uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    vec3 pos_on_screen = camera_pos + camera_z + camera_x * fov_x * screen_uv.x + camera_y * fov_y * screen_uv.y;\n\n    vec3 ray_origin = camera_pos;\n    vec3 ray_dir = normalize(pos_on_screen - camera_pos);\n\n    vec3 lightPosition1 = vec3(0.0, 3.0, -1.0);\n    lightPosition1.x += sin(iTime) * 2.0;\n    lightPosition1.z += cos(iTime) * 2.0;\n    \n    // Collect our first ray color\n    vec3 castHitPosition;// The position in worldspace if the sdf intersection\n    if (sphereCast(ray_origin, ray_dir, 64, castHitPosition))\n    {\n        vec3 lightToHitPostitionDirection = normalize(castHitPosition - lightPosition1);\n        // Cast a ray from our lightsource in the direction of the hit point on the sdf\n        vec3 lightHitPosition;\n        bool lightHit = sphereCast(lightPosition1, lightToHitPostitionDirection, 32, lightHitPosition);\n        \n        if(lightHit)\n        {\n            vec3 normal = calcNormal(castHitPosition);\n            float cosAng = dot(-normal, lightToHitPostitionDirection);\n            cosAng = clamp(cosAng, 0.0, 1.0);\n\n            // Hit sphere.\n            fragColor = vec4(vec3(231.0 / 255.0, 236.0 / 255.0, 134.0 / 255.0) * cosAng, 1.0) * float( (distance(lightHitPosition, castHitPosition) < 0.01));\n            fragColor.a = 1.0;\n        }\n    }\n    \n\n\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 54, 54, 78], [80, 99, 130, 130, 217], [219, 238, 286, 286, 349], [351, 370, 422, 422, 521], [527, 546, 591, 591, 873], [876, 1137, 1169, 1169, 2259], [2261, 2280, 2331, 2331, 2647], [2651, 2655, 2745, 2745, 3141], [3143, 3143, 3200, 3200, 5100]], "test": "untested"}
{"id": "7tsGD2", "name": "NEO", "author": "EDragon", "description": "Yo>\nyet another Maplestory shader\nmade one for the AWAKE update and now for the NEO update !\nthis one might seem a bit lazy but tbh, there isn't much aesthetic points that goes to that update ;;", "tags": ["maplestory"], "likes": 5, "viewed": 101, "published": "Public", "date": "1622919528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define s smoothstep\n#define pi 3.1415\n#define res iResolution.xy\n#define t iTime\n\n\n/////////////// changeable variables ////////////////\n\nfloat num = 25.;\n#define zoom 1.1\n#define have_fun .0\n#define have_fun2 .0\n\n/////////////////////////////////////////////////////\n\n\nmat2 rot(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat rand(float f){\n    return fract(sin(f*254.343)*532.327);\n}\n\nvec3 ember(vec2 uv, float brightness, float size, float num){\n    vec3 flare;\n    float d, b;\n    float a = res.x/res.y;\n    float yanker = sin(t*2.)*.1+.1;\n\n    for (float i; i<=num; i++){\n        b = (brightness*rand(i*362.123))*(sin(t*rand(i*135.13)*10.)*.5+.75);\n        d = b/length(uv-vec2(\n            sin(t*1.+i)*.1+mix(-.5*a, .5*a, rand(i+1.)),\n            fract(t*mix(.3, 1., rand(i))*.2+i*532.632)*1.5-.75)\n        );\n        flare += vec3(d)*\n        vec3(1., s(-.5+yanker, .5+yanker, uv.y)*.3+.2*rand(i*651.4134), .0);\n    }\n    return flare;\n}\n\nfloat N(vec2 uv, vec2 p){\n\tuv -= p;\n\tfloat lr = step(uv.x, .185)*step(-.185, uv.x);\n\tfloat tb = step(uv.y, .225)*step(-.225, uv.y);\n\tfloat tt = step(uv.x+uv.y-.025, .0)+step(.15, uv.x);\n\tfloat bt = step(.0, uv.x+uv.y+.025)+step(uv.x, -.15);\n\n\treturn clamp(lr*tb*tt*bt, .0, 1.);\n}\n\nfloat E(vec2 uv, vec2 p){\n\tuv -= p;\n\tfloat lr = step(uv.x, .14)*step(-.14, uv.x);\n\tfloat tb = step(uv.y, .225)*step(-.225, uv.y);\n\tfloat ts = 1.-step(.0225, uv.y)*step(uv.y, .185)*step(-.1, uv.x);\n\tfloat bs = 1.-step(-.185, uv.y)*step(uv.y, -.0225)*step(-.1, uv.x);\n\tfloat sculp = 1.-step(uv.x-uv.y,.1)*step(.06, uv.x-uv.y)*step(uv.y,-.1);\n\n\treturn lr*tb*ts*bs*sculp;\n}\n\nfloat O(vec2 uv, vec2 p){\n\tuv -= p;\n\tfloat d = s( .2275, .2225,length(uv))*s(.18, .185, length(uv));\n\tfloat sculp = 1.-step(uv.x-uv.y,.025)*step(-.025, uv.x-uv.y)*step(.0,uv.y);\n\n\treturn d*sculp;\n}\n\nuniform vec2 resolution;\nuniform float time;\n\nvoid mainImage(out vec4 color, in vec2 coord){\n\tvec2 uv = (coord.xy-.5*res)/res.y;\n\tvec2 uv2 = uv;\n\n\tuv2 *= \tzoom;\n\n    uv2 *= rot(have_fun2);\n\n\tvec3 col = vec3(.0);\n\n\tvec3 NEO_Shade = vec3(s(-.5, .3, uv2.y), s(-.2, .5, uv2.y)*.75, s(.0, -1., uv2.y));\n\n\tfloat n = clamp(N(uv2, vec2(-.5, .0)), .0, 1.);\n\tfloat e = E(uv2, vec2(.0));\n\tfloat o = O(uv2, vec2(.5, .0));\n\n\tcol += n*NEO_Shade;\n\tcol += e*NEO_Shade;\n\tcol += o*NEO_Shade;\n\n\tcol += s(.1*sin(t)+.25, 1.5, length(uv))*vec3(.5, .1, .0);\n\n    uv *= rot(have_fun);\n\n\t// holy shit I can layer stuff now????????????\n    col += clamp(ember(uv, .004, .1, num), .0, 1.-(n+e+o));\n\n\tcolor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 367, 385, 385, 437], [439, 439, 459, 459, 503], [505, 505, 566, 566, 1062], [1064, 1064, 1089, 1089, 1343], [1345, 1345, 1370, 1370, 1714], [1716, 1716, 1741, 1741, 1913], [1961, 1961, 2007, 2007, 2611]], "test": "untested"}
{"id": "7tSGDD", "name": "Arc - distance L-inf", "author": "iq", "description": "Distance to an arc in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url].", "tags": ["2d", "distancefield", "sdf", "arc", "linf"], "likes": 6, "viewed": 348, "published": "Public API", "date": "1623906295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an arc of a circle in the L-infinity metric space.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\nfloat dist( in vec2 p, in vec2 c )\n{\n    p = abs(p-c);\n    return max(p.x,p.y);\n}\n\nfloat sdArc( in vec2 p, float rb, float w, float an )\n{\n    vec2 u = vec2(cos(an),sin(an));\n    vec2 v = vec2(-u.y,u.x);\n    float h = sqrt(rb*rb-w*w);\n\n    // bounding points: arc extremes\n    float d = min(dist(p, u*w+h*v),\n                  dist(p, u*w-h*v));\n    // bounding points: cardinals\n    if( -rb*u.x<w ) d = min(d,dist(p,vec2(-rb,0.0)));\n    if(  rb*u.x<w ) d = min(d,dist(p,vec2( rb,0.0)));\n    if( -rb*u.y<w ) d = min(d,dist(p,vec2(0.0,-rb)));\n    if(  rb*u.y<w ) d = min(d,dist(p,vec2(0.0, rb)));\n    \n    // circular section\n    float b1 = 0.5*(p.x+p.y);\n    float b2 = 0.5*(p.x-p.y);\n    float c = dot(p,p) - rb*rb;\n    float h1 = b1*b1-c*0.5;\n    float h2 = b2*b2-c*0.5;\n    if( h1>0.0 )\n    {\n        vec2 t = vec2(-b1,b1)+sqrt(h1);\n        if( dot(p+vec2( 1, 1)*t.x,u)<w ) d=min(d,abs(t.x));\n        if( dot(p+vec2(-1,-1)*t.y,u)<w ) d=min(d,abs(t.y));\n    }\n    if( h2>0.0 )\n    {\n        vec2 t = vec2(-b2,b2)+sqrt(h2);\n        if( dot(p+vec2( 1,-1)*t.x,u)<w ) d=min(d,abs(t.x));\n        if( dot(p+vec2(-1, 1)*t.y,u)<w ) d=min(d,abs(t.y));\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 1.5;\n    m *= 1.5;\n\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,1));\n\n    float ra = 0.9;\n    float w = 0.5 + 0.35*cos(iTime);\n    float an = iTime*0.7;\n\n    \n    float d = sdArc(p, ra, w, an);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    d = sdArc(m, ra, w, an);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGDD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1246, 1282, 1282, 1327], [1329, 1329, 1384, 1384, 2417], [2419, 2419, 2474, 2474, 3278]], "test": "untested"}
{"id": "7tSGDy", "name": "Spiral tunnel", "author": "gormonboza", "description": "Polar coordinates", "tags": ["polar"], "likes": 7, "viewed": 178, "published": "Public API", "date": "1624607398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = vec4(.0);\n\n\tvec2 res = iResolution.xy;\n\n\n\t//------ create polar coordinates -----\n\n\tvec2 nUV = (uv - .5) * res / res.y;\n\n\tvec2 V = normalize(nUV);\n\n\tvec2 refV = vec2(1., 0.);\n\n\tfloat cosA = dot(refV, V);\n\n\tfloat alpha = acos(cosA);\n\n\talpha = alpha * step(.0, nUV.y) + (radians(360.) - alpha) * step(nUV.y, .0); // full 2PI circle\n\n\t//--------------------------------------\n\n\tfloat alphaP = alpha * 2. + length(nUV) * 7. * (1. + sin(iTime / 3.) * .4);\n\tfloat alphaM = alpha * 3. - length(nUV) * 5. * (1. + cos(iTime / 4.) * .5);\n\n\tfloat edge = cos(alphaP * 3. - iTime * 7.) * sin(alphaM * 3. + iTime * 5.);\n\n\tedge += 1.;\n\n\tedge /= 1.;\n\n\tedge *= length(nUV)  + .1;\n\n\tvec3 rainbow;\n\n\trainbow.r = (sin(iTime / 2. + edge * 16. + radians(360.) * 0. / 360.) + 1.) / 2.;\n\trainbow.g = (sin(iTime / 3. + edge * 16. + radians(360.) * 120. / 360.) + 1.) / 2.;\n\trainbow.b = (sin(iTime / 4. + edge * 16. + radians(360.) * 240. / 360.) + 1.) / 2.;\n\n\tcolor.rgb = rainbow * edge;\n\n\tcolor.a = 1.;\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1145]], "test": "untested"}
{"id": "7tSGRV", "name": "20210620_training_SPACE_GARDEN", "author": "FMS_Cat", "description": "Actual outcome: https://www.shadertoy.com/view/stSGRV", "tags": ["3d", "raymarcher"], "likes": 6, "viewed": 105, "published": "Public", "date": "1624247236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define lofi(i,j) (floor((i)/(j))*(j))\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\nfloat time;\nfloat seed;\n\nfloat random(){\n  seed=fs(seed+1.);\n  return seed;\n}\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 x=normalize(cross(abs(z.y)>.99?vec3(0,0,1):vec3(0,1,0),z));\n  return mat3(x,cross(z,x),z);\n}\n\nvec3 randomSphere(){\n  float phi=TAU*random();\n  float theta=acos(random()*2.-1.);\n  return vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));\n}\n\nvec3 sampleLambert(vec3 n){\n  float phi=TAU*random();\n  float cosTheta=random();\n  cosTheta=cos(asin(sqrt(cosTheta)));\n  float sinTheta=sqrt(1.0-sqrt(cosTheta*cosTheta));\n  return orthBas(n)*vec3(\n    cos(phi)*sinTheta,\n    sin(phi)*sinTheta,\n    cosTheta\n  );\n}\n\nvec3 randomHemisphere(vec3 n){\n  vec3 d=randomSphere();\n  \n  return dot(d,n)<.0?-d:d;\n}\n\nfloat sdbox(vec3 p,vec3 s){\n  vec3 d=abs(p)-s;\n  return min(0.,max(d.x,max(d.y,d.z)))+length(max(d,vec3(0.)));\n}\n\nvec3 ifs(vec3 p,vec3 r,vec3 s){\n  mat3 b=orthBas(r);\n  for(int i=0;i<7;i++){\n    p.xyz=p.zyx;\n    s*=b;\n    s*=0.58;\n    p=abs(p)-abs(s);\n    p.xy=p.x<p.y?p.yx:p.xy;\n    p.yz=p.y<p.z?p.zy:p.yz;\n    p.zx=p.z<p.x?p.xz:p.zx;\n  }\n  return p;\n}\n\nfloat ease(float t){\n  return 0.5+0.5*cos(PI*exp(-t*5.0));\n}\n\nvec4 map1(vec3 p){\n  vec3 pt=p;\n  pt.zx=r2d(0.1*time)*pt.zx;\n  vec3 cell=lofi(pt+1.0,2.0);\n  pt-=cell;\n  float w=abs(pt.x+pt.y+pt.z);\n  float ph=time+step(0.0,sign(p.y))*0.5;\n  ph*=140.0/120.0;\n  vec3 rot=2.0+mix(\n    fs(vec3(.7,.5,-.3)+sign(p.y)+floor(ph)),\n    fs(vec3(.7,.5,-.3)+sign(p.y)+floor(ph+1.0)),\n    ease(fract(ph))\n  );\n  vec3 s=1.0+1.0*mix(\n    fs(vec3(.1,.5,.7)+sign(p.y)+floor(ph)),\n    fs(vec3(.1,.5,.7)+sign(p.y)+floor(ph+1.0)),\n    ease(fract(ph))\n  );\n  pt=ifs(pt,rot,s);\n  pt=mod(pt-0.2,0.4)-0.2;\n  float d=sdbox(pt,vec3(.05));\n  d=max(d,0.2-abs(p.y));\n  //d=min(d,1.0-abs(p.y));\n  return vec4(d,1,min(abs(pt.x),abs(pt.z)),w);\n}\n\nvec4 map(vec3 p){\n  vec4 isect=map1(p);\n  //vec4 isectb=map2(p);\n  //isect=isectb.x<isect.x?isectb:isect;\n  return isect;\n}\n\nvec3 nmap1(vec3 p,vec2 d){\n  return normalize(vec3(\n    map1(p+d.yxx).x-map1(p-d.yxx).x,\n    map1(p+d.xyx).x-map1(p-d.xyx).x,\n    map1(p+d.xxy).x-map1(p-d.xxy).x\n  ));\n}\n\nfloat aomap(vec3 p,vec3 n){\n  float accum=0.;\n  for(int i=0;i<20;i++){\n    vec3 pt=p+sampleLambert(n)*(0.1+0.5*random()*random());\n    accum+=smoothstep(0.0,-0.01,map(pt).x)/20.;\n  }\n  return 1.0-sqrt(2.*accum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  seed=10.0*texture(iChannel0,4.0*uv).x;\n  seed+=fract(iTime);\n\n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1);\n  \n  time=iTime;\n  time+=0.02*random();\n  \n  vec3 rd=normalize(vec3(p,-1.+0.5*length(p)));\n  rd.xy=r2d(0.1*iTime)*rd.xy;\n  vec3 ro=vec3(0,0,5);\n  \n  for(int iR=0;iR<2;iR++){\n    float rl=1E-2;\n    vec3 rp=ro+rd*rl;\n    vec4 isect;\n    \n    for(int i=0;i<96;i++){\n      isect=map(rp);\n      rl+=.7*isect.x;\n      rp=ro+rd*rl;\n      \n      if(abs(isect.x)<1E-4){break;}\n    }\n    \n    float fog=exp(-0.02*max(rl-0.0,0.0));\n    col+=colRem*(1.0-fog)*10.0*vec3(0.8,1.1,1.8);\n\n    vec3 n=nmap1(rp,vec2(0,1E-4));\n    float f=1.0-max(0.0,dot(rd,-n));\n    f=pow(f,5.0);\n    col+=colRem*f*vec3(0.8,1.1,1.8);\n    \n    if(abs(isect.x)<1E-3){\n      if(isect.y==1.){\n        float ao=1.0;//aomap(rp,n);\n        float edge=smoothstep(0.001,0.0005,isect.z);\n        col+=colRem*vec3(0.1)*(1.0-edge)*fog*vec3(ao);\n        col+=colRem*4.0*vec3(.2,.8,2.1)*fog*edge*exp(-5.0*fract(isect.w+time));\n        colRem*=0.1+0.9*f;\n        \n        ro=rp+n*1E-2;\n        rd=reflect(rd,n);\n        rd=normalize(rd+0.04*randomSphere());\n      }\n    }else{\n      break;\n    }\n  }\n  \n  col=pow(col,vec3(.4545));\n  col*=1.-.2*length(p);\n  col=vec3(\n    smoothstep(0.1,0.96,col.x),\n    smoothstep(0.06,0.98,col.y),\n    smoothstep(-0.04,1.04,col.z)\n  );\n  \n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 179, 179, 216], [218, 218, 236, 236, 283], [285, 285, 306, 306, 424], [426, 426, 446, 446, 577], [579, 579, 606, 606, 841], [843, 843, 873, 873, 930], [932, 932, 959, 959, 1044], [1046, 1046, 1077, 1077, 1285], [1287, 1287, 1307, 1307, 1347], [1349, 1349, 1367, 1367, 1998], [2000, 2000, 2017, 2017, 2123], [2125, 2125, 2151, 2151, 2294], [2296, 2296, 2323, 2323, 2509], [2511, 2511, 2567, 2567, 4060]], "test": "untested"}
{"id": "7tsGWf", "name": "Attempt at a voxel ray marcher", "author": "Kelvin285", "description": "should work with a voxel grid.  Didn't include one in the shader though since I don't know how to add things like that into ShaderToy right now.\nThere are also a few weird shadow artifacts as well", "tags": ["voxel"], "likes": 2, "viewed": 85, "published": "Public", "date": "1623035959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 sphere = vec3(0, -2.5f, 15);\nfloat radius = 1.0f;\n\nvec2 last_mouse = vec2(-1, -1);\n\nfloat yaw = 0.0f;\n\nfloat GetWhiteNoise(float x, float y) {\n    float nx = cos(x * 1759710525.0f + 1000000.0f);\n    float ny = sin(y * 1677591740.0f + 1000000.0f);\n    return (nx + ny) / 2.0f;\n}\n\nfloat GetSmoothNoise(float x, float y) {\n    float xp = floor(x);\n    float yp = floor(y);\n    \n    float bl = GetWhiteNoise(xp, yp);\n    float tl = GetWhiteNoise(xp, yp + 1.0f);\n    float br = GetWhiteNoise(xp + 1.0f, yp);\n    float tr = GetWhiteNoise(xp + 1.0f, yp + 1.0f);\n    \n    float b = mix(bl, br, x - xp);\n    float t = mix(tl, tr, x - xp);\n    float n = mix(b, t, y - yp);\n    \n    return n;\n}\n\nfloat GetHeight(vec2 pos) {\n    return GetSmoothNoise(pos.x / 10.0f, pos.y / 10.0f) * 10.0f;\n}\n\nfloat GetSDF(vec3 test_pos) {\n    //return distance(test_pos, sphere) - radius;\n    return test_pos.y - (GetHeight(test_pos.xz));\n}\n\nvec2 BoxIntersection(vec3 origin, vec3 box_pos, vec3 dir, float d) {\n    \n    vec3 box_min = floor(box_pos * d) / d;\n    vec3 box_max = box_min + vec3(1.0f);\n    \n    vec3 tMin = (box_min - origin) / dir;\n    vec3 tMax = (box_max - origin) / dir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    \n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tNear, tFar);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float deg_to_rad = 3.14f / 180.0f;\n    \n    if (last_mouse.x == -1.0f) {\n        last_mouse = vec2(iMouse.x, iMouse.y);\n    }\n    \n    vec3 sun = vec3(cos(iTime), -sin(iTime), 0);\n    sun = vec3(0.0f, -1.0f, 1.0f);\n    sun = normalize(sun);\n    \n    vec3 pos = vec3(iTime, 15, 0);\n    vec3 look = vec3(fragCoord.x - iResolution.x / 2.0f, fragCoord.y - iResolution.y / 2.0f, length(iResolution));\n    \n    look = normalize(look);\n    \n    int iterations = 100;\n    \n    vec3 test_pos = vec3(pos.x, pos.y, pos.z);\n    vec3 vox_pos = floor(test_pos);\n    \n    bool hit = false;\n    bool sun_hit = false;\n    \n    float lambda = 0.05f;\n    \n    float dist_mul = 1.0f;\n    \n    for (int i = 0; i < iterations; i++) {\n        \n        float sdf = GetSDF(floor(vox_pos * dist_mul) / dist_mul);\n        \n        if (sdf <= lambda) {\n            hit = true;\n            break;\n        }\n        \n        vec2 intersect = BoxIntersection(pos, vox_pos + look * sdf * 0.75f, look, dist_mul);\n        \n        vox_pos = pos + look * (intersect.y + lambda);\n        \n    }\n    \n    vec3 cur_pos = floor(vec3(vox_pos.x, vox_pos.y, vox_pos.z));\n    float height = GetHeight(cur_pos.xz) / 10.0f;\n\n    vec3 stpos = vec3(vox_pos.x, vox_pos.y, vox_pos.z);\n    vox_pos -= sun * 0.4f;\n    \n    for (int i = 0; i < iterations / 2; i++) {\n        float sdf = GetSDF(floor(vox_pos * dist_mul) / dist_mul);\n        \n        if (sdf < 0.0f) {\n            sun_hit = true;\n            break;\n        }\n        \n        vec2 intersect = BoxIntersection(stpos, vox_pos - sun * sdf * 0.75f, -sun, dist_mul);\n        \n        vox_pos = stpos - sun * (intersect.y + lambda);\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    if (hit) {\n        \n        col = vec3(1, 0.5f, 0.25f);\n        if (cur_pos.y >= height) col = vec3(0.0f, 1.0f, 0.0f);\n        if (sun_hit) col *= 0.5f;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    last_mouse = vec2(iMouse.x, iMouse.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 147, 147, 282], [284, 284, 324, 324, 688], [690, 690, 717, 717, 784], [786, 786, 815, 865, 917], [919, 919, 987, 987, 1360], [1362, 1362, 1419, 1419, 3514]], "test": "untested"}
{"id": "7tsGzl", "name": "Coordinates example", "author": "abi", "description": "It seemed fitting to play around with coordinates for my first shader.", "tags": ["coordinates"], "likes": 1, "viewed": 35, "published": "Public", "date": "1622663034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // NOTE: by default fragment coordinates range from 0.5 to resolution - 0.5\n    // However, we can normalize them like so... [0, 1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Distance of fragment to the center\n    float ftc = distance(uv, vec2(0.5));\n    \n    // Colors\n    vec3 col;\n    vec3 purple = vec3(1.0, 0.0, 0.5);\n    vec3 blue = vec3(0.0, 0.5, 1.0);\n    \n    // Split in half horizontally and add vignette effect\n    if (uv.x >= 0.0 && uv.x <= 0.5) \n    { \n        col = 1.0 - vec3(ftc) + 0.5 * purple;\n    }\n    else \n    {\n        col = 1.0 - vec3(ftc) + 0.5 * blue;\n    }\n    \n    // Color fade in / fade out\n    col += 0.5 * cos(iTime);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 191, 787]], "test": "untested"}
{"id": "7tSGzm", "name": "XOR Towers 156 chars", "author": "GregRostami", "description": "Another fork of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\n\nIt's REALLY amazing how many patterns an XOR can create without repeats.\nUse the Mouse to move around.", "tags": ["3d", "voxels", "xor", "tiny", "short", "1tc"], "likes": 7, "viewed": 217, "published": "Public API", "date": "1623561168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 u)\n{ \n  ivec4 b;\n  for (;(b.x^b.y^b.z)%99 > b.z-8;)\n    b = ivec4(3.*--u/iResolution.y*o.a + 2.*iTime + .1*iMouse.xy, o+=.1);\n  o = o/70. - .02*vec4(b%3);\n}", "image_inputs": [{"id": "XlfSRs", "previewfilepath": "https://soundcloud.com/sanya89/jean-michel-jarre-04-en-attendant-cousteau", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sanya89/jean-michel-jarre-04-en-attendant-cousteau", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 188]], "test": "untested"}
{"id": "7tsSRn", "name": "My First RayMarch", "author": "gabor", "description": "First attempt to create a ray marcher including\n- SDF with sdSphere and sdRoundBox (by IQ)\n- 3 point and an ambient light sources with diffuse and specular\n- cast shadows\n- fade into sky color at max distance\n- SDF also returns a material index (coloring)", "tags": ["raymarching", "test", "beginner"], "likes": 3, "viewed": 77, "published": "Public", "date": "1625078307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Finally I got into creating a ray marcher after watching and reading stuff by IQ and Art of Coding\n\n#define PI 3.1415926535897932384626433832795\n\n#define MAX_STEP 100\n#define MAX_DISTANCE 12.0\n#define MAX_VISIBILITY .8*MAX_DISTANCE\n#define MIN_DISTANCE 0.004\n\n#define skyColor vec3(.5, .72, 0.9)\n#define AMBIENT_FACTOR .2\n\n//#define AA <-- buggy\n//#define USE_BRANCHING <-- if vs step() doesn't seem to make a difference\n//#define FX\n\n\n#define nsin(a) .5*(1. + sin(a)) \n\nfloat ambient = .0;\n\nvec3 colors[] = vec3[](\n    vec3(.8, .2, .2),\n    vec3(.9, .8, .2),\n    vec3(.2, .2, .8),\n    vec3(.9, .4, .8),\n    vec3(.5, .6, .6)\n);\n\nvec3 lights[] = vec3[](\n    vec3(0.), vec3(0.), vec3(0.)\n);\n\nmat2 rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//thx IQ\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nvec2 getDistance(vec3 p) {\n\n    vec2 p1 = vec2(sdPlane(p, normalize(vec3(0.0, 1.0, 0.0))), 4);\n    vec2 res = vec2(.0);\n\n    vec3 s1t = vec3(-.0, .15,  0.0);\n    vec3 s2t = vec3(-.3, .2, -0.3);\n\n    vec3 b1t = vec3( .3, .2,  0.3);\n    vec3 b2t = vec3( .3, .1, -0.3);    \n\n    vec2 s1 = vec2(sdSphere(p - s1t, 0.1), 0);\n    vec2 s2 = vec2(sdSphere(p - s2t, 0.13), 1);\n\n    vec3 b1p = p - b1t; b1p.xz *= rotate(1.1*iTime); b1p.yz *= rotate(-0.1*iTime);\n    vec2 b1 = vec2(sdRoundBox(b1p, vec3(.1), 0.01), 3);\n\n    vec3 b2p = p - b2t; b2p.xz *= rotate(-4.1*iTime);\n    vec2 b2 = vec2(sdRoundBox(b2p, vec3(.1, 0.02, .05), 0.01), 3);\n\n#ifdef USE_BRANCHING\n    vec2 s = s1;\n    if (s2.x < s.x) s = s2;\n\n    vec2 b = b1;\n    if (b2.x < b.x) b = b2;\n\n    res = s;\n    if (b.x < res.x) res = b;\n    if (p1.x < res.x) res = p1;\n\n#else\n    float sd = min(s1.x, s2.x);\n    float sm = s1.y*step(s1.x, sd + MIN_DISTANCE) + s2.y*step(s2.x, sd + MIN_DISTANCE);\n\n    float bd = min(b1.x, b2.x);\n    float bm = b1.y*step(b1.x, bd + MIN_DISTANCE) + b2.y*step(s2.x, bd + MIN_DISTANCE);\n\n    float d1 = min(sd, bd);\n    float m1 = sm*step(sd, d1+MIN_DISTANCE) + bm*step(bd, d1+MIN_DISTANCE);\n\n    res.x = min(p1.x, d1);\n    res.y = p1.y*step(p1.x, res.x+MIN_DISTANCE) + m1*step(d1, res.x+MIN_DISTANCE);\n\n#endif\n\n    return res;\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    float d = .0;\n    for (int i=0; i<MAX_STEP; i++) {\n        vec3 p = ro + d*rd;\n        float ds = getDistance(p).x;\n        d += ds;\n        if (d > MAX_DISTANCE || ds < MIN_DISTANCE) break;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec3 v = vec3(MIN_DISTANCE, .0, .0);\n    return normalize(d - vec3(\n        getDistance(p - v.xyy).x,\n        getDistance(p - v.yxy).x,\n        getDistance(p - v.yyx).x\n    ));\n}\n\nvec3 getLight(vec3 p, vec3 lightPos, vec3 lightCol) {\n    vec3 col = vec3(.8, .82, 1.0);\n    \n    vec2 dm = getDistance(p);\n    if (dm.x < MAX_VISIBILITY) {\n        int mat = int(dm.y);\n        // ambient\n        vec3 ambColor = ambient * skyColor;\n        // diffuse\n        vec3 l = normalize(lightPos - p);\n        vec3 n = getNormal(p, dm.x);\n        float diff = clamp(dot(l, n), 0., 1.);\n        vec3 diffColor = clamp(vec3(lightCol) * 0.8 * diff, .0, .5);\n        // specular\n        vec3 lightReflect = reflect(-l, n);\n        float sf = max(dot(normalize(p), lightReflect), .0);\n        float spec = pow(sf, 20.0);\n        vec3 specColor = vec3(lightCol * 1.2 * spec);\n        // cast shadow\n        float sd = castRay(p + 2.*n*MIN_DISTANCE, l);\n        //float falloff = 10.*(1.0 - clamp(length(lightDir - p), .0, 1.));\n        float sh = 1.;\n        if (sd < MAX_DISTANCE) sh = clamp(4.*sd, .0, 1.);\n\n        col = colors[mat] * (ambColor + sh*(clamp(diffColor + specColor, .0, 1.)));\n        if (mat == 4) {\n            col *= .5 + .5*step(.5, fract(2.*p.x + .5*step(.5, fract(2.*p.z))));\n        }\n    }\n\n    return clamp(col, .0, 1.);\n}\n\nvec3 render(vec3 p) {\n    vec3 col  = getLight(p, lights[0], vec3(.6, .4, .4));\n         col += getLight(p, lights[1], vec3(.0, .6, .0));\n         col += getLight(p, lights[2], vec3(.0, .0, .7));\n    return col;    \n}\n\nvec3 sky(vec3 p) {\n    vec3 col = vec3(skyColor);\n    //col.rg = noise(;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ambient = AMBIENT_FACTOR;//*nsin(.5*iTime);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n#ifdef FX\n    vec2 q = vec2(sin(5.*PI*uv.x + 4.3*iTime), sin(3.*PI*uv.y + 2.*iTime + .5));\n    uv += .02*q;\n    float f = 450.*nsin(0.2*PI*iTime) + 50.;\n    uv = floor(uv*f)/f;\n#endif\n    float angle = 0.2*iTime;\n    vec3 ro = vec3(.0, .0, -1.);\n    ro.xz *= 1.2*rotate(angle);\n    ro += vec3(.0, 0.3, .0);\n\n    vec3 rt = vec3(uv.x, uv.y, 1.);\n    rt.yz *= rotate(.1*3.14);\n    rt.xz *= rotate(angle);\n    vec3 rd = normalize(rt);\n\n    float d = castRay(ro, rd);\n    vec3 p = ro + d*rd;\n\n    vec3 center = vec3(.0, 1., .0);\n\n    float theta = iTime * 1.0;\n    // #1 light\n    lights[0] = vec3(vec2(.2, -.2)*rotate(theta), .0).xzy + center;\n    // #2 light\n    lights[1] = vec3(vec2(.3, .2)*rotate(theta), .0).xzy + center;\n    // #3 light\n    lights[2] = vec3(vec2(-.1, .0)*rotate(theta), .0).xzy + center;\n    \n    vec3 col  = render(p);\n#ifdef AA\n    vec3 cd = vec3(2.*MIN_DISTANCE, .0, 0.);\n         col += render(p+cd.xyy, lp1, lp2, lp3);\n         col += render(p+cd.yxy, lp1, lp2, lp3);\n         col /= 3.;\n#endif\n\n    col = mix(col, (.1 + 4.*ambient)*sky(p), smoothstep(.01*MAX_DISTANCE, MAX_VISIBILITY, d));\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 693, 719, 719, 803], [805, 814, 847, 847, 871], [873, 873, 916, 916, 1008], [1010, 1010, 1041, 1041, 1065], [1067, 1067, 1093, 1093, 2375], [2377, 2377, 2410, 2410, 2627], [2629, 2629, 2662, 2662, 2845], [2847, 2847, 2900, 2900, 3997], [3999, 3999, 4020, 4020, 4216], [4218, 4218, 4236, 4236, 4308], [4310, 4310, 4367, 4367, 5676]], "test": "untested"}
{"id": "7tX3D2", "name": "First Quad Tree Attempt", "author": "Yusef28", "description": "Is this even a quadtree?\nI'd love to hear some opinions on what I could have done better. ", "tags": ["2d", "comments", "quadtree", "quadtree", "wellcommented"], "likes": 11, "viewed": 142, "published": "Public", "date": "1622865234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    //fisheye update 2021 06 17\n    uv = normalize(uv) * tan(asin(length(uv) * 0.9));\n    //move the world with time\n    uv.x+=iTime/10.;\n    \n    //prepare a vector for coordinate subsystem updates\n    \n    //scale world by 4 to see more stuff\n    vec2 newST = uv*5.;\n    //get init ID for quads\n    vec2 newID = floor(newST);\n    //get the decimal part and shift it to -0.5 to 0.5 (not super nessesary)\n    vec2 newCoor = fract(newST)-0.5;\n    \n    \n        \n    //7 levels\n    //At each level you partition the space into for subspaces\n    //each with coord -0.5 to 0.5 for x and y\n    //you get an ID for each quad using floor\n    //send the ID to rand and get a random number between 0 and 1\n    //if the rand number is less than half then end at this level and\n    //move on to colouring otherwise keep going.\n    for(float k = 1.; k < 8.; k++){\n    \n        //scaled up pixel coord X2 each time through loop\n        newST = newST*2.;\n        //get 2d vector id for this pixel's 1x1 block\n        newID = floor(newST);\n        //get the -0.5 - 0.5 coord of this pixel for quad partitioning\n        newCoor = fract(newST)-0.5;\n\n        //start by checking that the whole quadrant should be partitioned\n        float rnd = rand(newID);\n        //if not then break out of the loop and move to coloring\n        if(step(0.5, rnd) < 0.5){\n            break;\n            }\n\n    }\n    //black as init color\n    vec3 col = vec3(0.);\n    //thickness for the black borders around each square\n    float th = 0.05;\n    \n    //decide with the quad should be colored at all\n    //newID is left from the last reached level\n    float rnd = rand(newID);\n    //I check if it's less than 0.2 so I am basically leaving\n    //lot's of squares not colored but mostly in lower levels.\n    //For some reason I needed to push the threshhold way down to even\n    //affect the top layer quads.\n    if(rnd < 0.2){\n    \n    //calculate a color using the intro color palete with a shift based on the \n    //random value from each quad ID\n    vec3 pallete = 0.5 + 0.5*cos(vec3(rnd)+vec3(0,2,4)/2.+rnd*1000.+iTime);\n    \n    //cut out black borders on x axis\n    float f = 1.0-step(0.5-th, newCoor.x)+step(-0.5+th, newCoor.x);\n    //mix the black in\n    col = mix(pallete, vec3(0.), f);\n    //cut out black borders on y axis\n    f = 1.0-step(0.5-th,newCoor.y)+step(-0.5+th,newCoor.y);\n    //mix the black in\n    col = mix(col, vec3(0.), f);\n    }\n    \n    //you could delete the else statement and be fine it's just there to\n    //show the logic\n    else{\n    \n    //y'know!\n    col = vec3(0.);\n    \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [93, 93, 150, 200, 2911]], "test": "untested"}
{"id": "7tX3Df", "name": "Texture Movement (I)", "author": "sarabase", "description": "This shader shows how a texture can be moved using a variable time.", "tags": ["shader", "movement"], "likes": 0, "viewed": 27, "published": "Public", "date": "1622989394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n    //The output must be between 0.0 and 1.0\n\treturn -1.0 + 2.0*fract(sin(p) * 43758.5453123);\n}\n\nfloat noise( in vec2 p ) { //Simplex noise\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y) * K1 );\n\n    vec2 a = p - i + (i.x+i.y) * K2;\n    vec2 o = step(a.yx,a.xy);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.; //lacunarity: steps in which we increment de frequencies\n        amplitude *= .5; //gain: decreases the amplitude\n    }\n    return value * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float color = 0.;\n    //Normalize fragment coordinates\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //These variables are used to modify the speed at which the texture moves\n    float strength = floor(uv.x+1.);\n    float t = max(3.,1.25*strength)*iTime;\n    \n    color += fbm(uv*strength-vec2(0,t));\n\n    float c1=clamp(color,0.,1.);\n\n    //Gives it a fire appearence\n\tvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1*c1*c1);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 189], [191, 191, 217, 233, 685], [705, 705, 729, 729, 1057], [1059, 1059, 1116, 1116, 1596]], "test": "untested"}
{"id": "7tX3zf", "name": "Class 3: Complex Scene", "author": "xarmalarma", "description": "Sphereflake", "tags": ["sphereflake"], "likes": 2, "viewed": 95, "published": "Public", "date": "1622574685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXX 1000000.0\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = MAXX; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nconst int NUM_SPHERE = 43;\nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\nfloat theta = 0.0;\n\nvoid rotateSceneTenDegrees(int f) {\n    theta += float(f)/5.0 * 3.1415/45.0;\n    //theta = 0.0;\n    for (int i=0; i<6; i++) {\n        // rotate each child sphere about y-axis \n        // through the center of the large one\n        vec3 v1 = spheres[i+1].center - spheres[0].center;\n        vec3 axis = normalize(vec3(0.0, spheres[0].radius, 0.0));\n        vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));\n        spheres[i+1].center = newv + spheres[0].center;\n    }\n}\n\nint addSixSpheres(Sphere parentSphere, int count) {\n    float radius = parentSphere.radius;\n    vec3 center = parentSphere.center;\n    float childRadius = radius/2.8;\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y+radius+childRadius-0.1, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y-radius-childRadius+0.1, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x+radius+childRadius-0.1, center.y, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x-radius-childRadius+0.1, center.y, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z+radius+childRadius-0.1), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z-radius-childRadius+0.1), vec3(random(), random(), random()));\n    return count;\n}\n\nvoid makeScene(int f) {\n    float radius=0.8;\n    vec3 center = vec3(0, 0, -6); \n    vec3 color = vec3(random(), random(), random());\n    int count = -1;\n    spheres[++count] = Sphere(radius, center, color);\n    count = addSixSpheres(spheres[0], count);\n    count = addSixSpheres(spheres[1], count);\n    count = addSixSpheres(spheres[2], count);\n    count = addSixSpheres(spheres[3], count);\n    count = addSixSpheres(spheres[4], count);\n    count = addSixSpheres(spheres[5], count);\n    count = addSixSpheres(spheres[6], count);\n\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1));\n    rotateSceneTenDegrees(f);   \n}\n\n\n\nint numSamples = 2;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   if (iFrame==0) theta = 0.0;\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = MAXX;\n       int iSphere = -1;\n       float minT = MAXX;\n       for (int i=0; i < NUM_SPHERE; i++) {\n           Sphere sphere = spheres[i];\n         \n           t = raySphereIntersect(ray, sphere);\n         \n           if (t < minT) {\n               minT = t;\n               iSphere = i;\n           }\n       }\n       if (iSphere > -1 && minT < MAXX) {\n           Sphere sphere = spheres[iSphere];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float angle = dot(hitPointNormal, hitPointToEye);\n           samp = samp + angle*sphere.color;\n          \n       }\n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 107, 123, 123, 170], [521, 561, 617, 617, 1096], [1193, 1193, 1228, 1228, 1707], [1709, 1709, 1760, 1760, 2729], [2731, 2731, 2754, 2754, 3355], [3381, 3460, 3515, 3673, 5289]], "test": "untested"}
{"id": "7tXGWj", "name": "Triangle Grid Learning", "author": "oneshade", "description": "Learning about how to make triangle grids. [url=https://thebookofshaders.com/11/]https://thebookofshaders.com/11/[/url]", "tags": ["grid", "triangles", "animation", "skew"], "likes": 4, "viewed": 74, "published": "Public", "date": "1622835019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 6.0 / iResolution.y; // Approximately pixel size\n    float transition = 0.5 + 0.5 * sin(iTime);\n\n    // The grid is complete when skew=0.5 and stretch=sqrt(0.75)\n    float skew = 0.5 * transition;\n    uv.x /= mix(1.0, sqrt(0.75), transition); // Scale width to form equilateral triangles\n    uv.y += skew * uv.x; // Skew vertically\n\n    uv *= 2.0; // Zoom out to see more cells\n    uv = fract(uv); // Subdivide into a grid\n\n    float sTriId = step(0.0, uv.x - uv.y); // Upper left of the cell: 0, lower right of the cell: 1\n\n    // Cell coloring show UVs and local IDs\n    fragColor = mix(vec4(uv, 0.0, 1.0), vec4(sTriId, 0.0, 1.0 - sTriId, 1.0), transition);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0), smoothstep(unit, 0.0, abs(uv.y - uv.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 892]], "test": "untested"}
{"id": "7tXXRr", "name": "light cross", "author": "ejosiah", "description": "cell noise with using minimum of absolute distances between points", "tags": ["noisecellworley"], "likes": 2, "viewed": 38, "published": "Public", "date": "1625060209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.283185307179586\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 8.0;\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n   float minDist = 100.0;\n   for(int y = -1; y <= 1; y++){\n       for(int x = -1; x <= 1; x++){\n           vec2 neigbhour = vec2(float(x), float(y));\n           vec2 p = hash22(i + neigbhour);\n           \n           p = 0.5 + 0.5*sin(iTime + TWO_PI*p);\n           \n           p += neigbhour;\n           vec2 d = f - p;\n           float dist = min(abs(d.x) , abs(d.y));\n           minDist = min(minDist, dist);\n       }\n   }\n    vec3 col = vec3(minDist);\n\n    fragColor = vec4(1. - col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 55, 55, 189], [192, 192, 249, 249, 850]], "test": "untested"}
{"id": "fdlGzH", "name": "Raytracer - Base", "author": "SpinningCube", "description": "Converted my raymarching code into raytracing code.\n\nAdded fresnel, ggx, and gamma correction.\n\nLacking multiple bounces, I'll make that later", "tags": ["raytracing", "fresnel"], "likes": 5, "viewed": 131, "published": "Public API", "date": "1624424212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 85.;\nconst float pi = 3.141592653589793;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.2, 0.4, 0.6);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness ) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 6), 1.), vec3(0.4,.2, 0.01), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.1,0.2, 0.8), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.5,0.03, 0.01), .1 );\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), 0.1 );\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 1., surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    \n    vec3 finalCol = mix(surfCol * (diffuse + ambient), specular + ambient, fresnel(1.5, surfRoughness, surfNormal, -rayDir));\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/5.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n\n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 356, 399, 399, 442], [444, 454, 522, 522, 931], [933, 933, 1001, 1001, 1211], [1213, 1213, 1277, 1277, 1543], [1545, 1545, 1588, 1588, 2112], [2114, 2114, 2195, 2195, 2479], [2481, 2481, 2525, 2525, 2638], [2640, 2640, 2752, 2752, 3141], [3143, 3143, 3234, 3234, 3378], [3380, 3380, 3438, 3438, 3590], [3592, 3652, 3677, 3697, 3754], [3756, 3756, 3831, 3831, 3972], [3974, 3974, 4029, 4029, 4466], [4468, 4468, 4525, 4525, 5202]], "test": "untested"}
{"id": "fl23Rt", "name": "Patterned Spiral", "author": "scry", "description": "it just keeps going and going", "tags": ["2d", "fractal", "spiral", "atan", "kifs"], "likes": 4, "viewed": 147, "published": "Public API", "date": "1624506981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime iTime*0.1\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    //tv -= 0.5;\n    //tv = vec2((length(tv)), atan(tv.x,tv.y));\n    //tv.y = abs(tv.y+iTime*0.02);\n    //tv *= r2d(iTime*0.91);\n    //tv = vec2(tv.x*sin(tv.y),tv.x*cos(tv.y));\n    //tv += 0.5;\n    //tv = abs(tv-0.5)+0.5;\n    //vec3 bak = texture(texture1,tv).rgb;\n    uv -= 0.5;\n    uv.x *= ar;\n    //uv *= 0.2;\n    //uv += 0.5;\n    uv *= 1.;\n    float ac = length(uv);\n    float udt = iTime*0.2;\n    vec2 uvd = uv/mix(vec2(sin(udt),cos(udt*0.9238)*9.)*0.5,vec2(1.,0.5),1.-ac);\n    //uv = mix(uvd,uv,sin(iTime*0.1+1.)*0.5+0.5);\n    //uv *= (1.-ac)*(1.-ac);\n    //uv *= vec2(sin(udt),cos(udt*0.9238)*4.)*0.2;\n    //uv *= r2d(ac*2.+iTime*0.5);\n    //uv.x *= 0.1;\n    float c = length(uv);\n    float lc = log(c)*0.093;\n    //uv *= 20.1;\n    float scrolltime = iTime*0.;\n    float zoomtime = iTime*0.9;\n    //scrolltime += sin(lc*9+iTime*1)*0.1;\n    //uv /= c;\n    //uv.x += iTime;\n    tv -= 0.5;\n    tv *= 1.+lc*0.09;\n    tv += 0.5;\n    //vec3 bakd = texture(texture1,tv).rgb;\n    vec2 cuv = vec2(lc,atan(uv.x,uv.y)/6.27831853071);\n    //uv.x *= 0.9;\n    //uv = mix(uv,cuv,sin(iTime)*0.5+0.5);\n    //uv *= 0.1;\n    //cuv.x *= 0.1;\n    uv = cuv;\n    //uv *= 0.5;\n    \n    uv.x *= 1.;\n    uv.y *= 1.;\n    vec2 uvb = uv;\n    //uv *= 0.1;\n    uv.x -= zoomtime*0.2;\n    //uv.x *= 1.7;\n    vec2 uvc = uv+0.5;\n    //uv.y /= 6.28318;\n    uv = fract(uv-0.5);\n    //uv.x += iTime;\n    //uvc = fract(uvc-0.5);\n    //uv = vec2(lc,atan(uv.x,uv.y));\n    //uv.x *= 0.4;\n    vec3 col = vec3(0.);\n    float ct = 20.;\n    //uv *= r2d(lc);\n    float b = 0.;\n    //uv *= 0.6;\n    vec2 rud = uv;\n    uv *= r2d(1./ct);\n    uvc *= r2d(1./ct);\n    uvb *= r2d(1./ct);\n    //uv *= 0.3;\n    //uv.x *= 0.03;\n    //uv *= r2d((3.141/180.)*(90/ct));\n    vec2 uvf = floor(uv*ct)/ct;\n    vec2 fr = fract(rud);\n    //uvc.x += .9;\n    float uvxf = floor(uvc.x*ct)/ct;\n    float uvtf = floor(uvc.x*ct);\n    float sy = uvxf;\n    sy -= ((uvc.y)/ct);\n    //uvtf = uvxf;\n    //uvtf -= sin(((uvc.y)/ct)*iTime);\n    float dist = (sin(c*8.+iTime*23.)*0.004);\n    //sy += sin(sy*0.0002)*iTime;\n    //sy += sin(floor(uvc.x*ct))*iTime*0.5;\n    //sy -= sin(uvxf/3.14159)*iTime;\n    //sy += dist*(dist+lc*2);\n    //sy += sin(uvxf*4.14+iTime*0.1);\n    //sy += sin(uvtf*iTime*0.01)*iTime*0.51;\n    //sy = ((fract(sy*400.)/400.)-(0.5/40))+sy;\n    //sy -= 0.5/40;\n    //sy = abs(fract(sy))-0.55;\n    //sy += sin(floor(uvc.x*ct)*62.9+2)*iTime*0.3;\n    sy += sin(sy*0.5)*1.;\n    sy *= 01.25;\n    //sy += sin(uvc.x*02.2)*0.01;\n    //sy += sin(iTime*0.5)*2.;\n    //sy *= r2d(iTime);\n    //sy = sin(sy*4)*40;\n    sy -= scrolltime*0.05;\n    //sy += iTime*c*0.00002;\n    //sy *= c;\n    //sy += (rud.y-0.5);\n    //sy -= (-rud.y-iTime)/ct;\n    //sy = fract(sy);\n    //sy *= 2;\n    vec2 uvs = fract(vec2((uvc.x)*20.,sy));\n    //uvs.y *= 0.5;\n    //uvs.y += sin(uvc.x*0.03);\n    uvs.y = abs(uvs.y-0.5)+0.5;\n    uvs.y *= ct*ct;\n    \n    //uvs.x *= 1./ct;\n    //uvs.y = abs(uvs.y)-1.;\n    //sy += (-rud.y)/ct;\n    //sy = rud.y;\n    //uvf -= uv.y*0.05;\n    //uvf *= 0.9;\n    //uvf += ((rud.y)/ct);\n    //uvf += abs((rud.y)/ct);\n    //b *= 0.;\n    //b = (rud.y);\n    //b = 1.-smoothstep(0.,0.02,abs(uvs.x-0.5)-0.4);\n    b = 1.-smoothstep(0.,0.06,abs(uvs.x-0.5)-0.1);\n    vec2 uvg = uvs;\n    //uvg.x += 0.3;\n    //uvg.y += 2.;\n    uvg.y += sin(sin(sin(uvg.x*3.141)+uvg.y*0.004)*3.)*0.2;\n    //uvg.x = abs(uvg.x);\n    //uvg.x *= 2.2;\n    uvg.y *= 01.5;\n    //uvg.x *= (sin(sin(uvs.y*0.01)*2.)*0.5+1.)*3.;\n    uvg = fract(uvg);\n    //uvg.x *= 2.;\n    uvg = abs(uvg-0.5);\n    //uvg *= 3.;\n    //uvg.y += c;\n    uvs.y *= 0.2;\n    //uvg.x *= 1*sin(uvs.y*0.1);\n    uvg -= 0.5*sin(uvs.y*0.01);\n    uvg *= r2d(uvs.y*sin(uvs.y*0.00101+0.)*2.);\n    uvg = abs(uvg)-0.2;\n    uvg *= r2d(uvs.y*cos(uvs.y*0.001)*0.1);\n    uvg = abs(uvg)-0.2;\n    uvg *= sin(uvs.y*0.01)*0.5+0.8;\n    uvg *= r2d(uvs.y*sin(uvs.y*0.0001)*1.);\n    for (int i=0;i<5;i++) {\n        uvg *= r2d(uvs.y*cos(uvs.y*0.001)*0.1);\n        uvg = abs(uvg)-0.2;\n    }\n    uvg += 0.5;\n    //uvg.x += lc;\n    b *= smoothstep(0.02,0.04,abs(uvg.x-0.5));\n    float bh = smoothstep(1.,0.0,abs(uvg.x-.5));;\n    //b *= smoothstep(0.02,0.01,abs(uvg.x-0.5));\n    //uvs *= 10.;\n    \n    //col.rg = sin(uvs);\n    col = vec3(b);\n    //col = sin(col);\n    col = rgb2hsv(col);\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    \n    col = hsv2rgb(vec3((uvs.y*0.02)+bh*10.+iTime*0.1,1.,((sin(uvs.y*sin(uvs.x*02.2+0.6)*.15+4.5)*.5+0.5)*0.5+0.5)*b));\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    //bak = mix(bak,bakd,0.08);\n    \n    //if (b < 0.95) {\n        //col = bak*0.997;\n        //col \n        //col = fract(col+0.01);\n        //col = mix(col,bak,01.4);\n    //}\n    //col = mix(col,bak,0.6*(1.-((lc+1)*.15)));\n    //col = mix(vec3(b),col,0.4);\n    //col.rg = sin(uvs*30);\n    //col = vec3(sin(uvs.y)+sin(uvs.x));\n    //col.rg = sin(uvs*6+iTime*2);\n    //col.b = sin((uv.x+uv.y)*9*4);\n    //col.rg = vec2(sin(vec2(uvc.x,uvx.y)/2));\n    //col.rg = uv;\n    //col.rg = uv*0.2;\n    //col.b = sy+iTime*0.5;\n    //col.b = sin(sy*0.7);\n    //col.b = sy;\n    //col.r = rud.y;\n    //col.b = sin(sy*220)*0.3+sin(sy);\n    //col = vec3(abs(uvc.y-0.5));\n    //col.b = sin(col.b*2000)+sin(col.b*4.);\n    //col.b = sin(col.b+iTime);\n    //col.b = sin(col.b*3.14)*0.5+0.5;\n    //col.b = sin(col.b*62.9+1.)+sin(col.b*2+iTime)*0.5;\n    //col = vec3(sin(uv.x*20));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 92], [94, 231, 253, 253, 584], [589, 648, 670, 670, 839], [842, 842, 897, 897, 6544]], "test": "untested"}
{"id": "fl23WK", "name": "Random saturday shader", "author": "mrange", "description": "License CC0: Random saturday shader\nResult after a bit of random coding on saturday afternoon\n", "tags": ["3d", "raymarching"], "likes": 16, "viewed": 210, "published": "Public API", "date": "1624738306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Random saturday shader\n// Result after a bit of random coding on saturday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n\nconst vec3  std_gamma  = vec3(2.2);\nconst float smoothing  = 0.043;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat boxf(vec3 p, vec3 b, float e) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nvec3 refl(vec3 p, vec3 n) {\n  p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;\n  return p;\n}\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat df(vec3 p) {\n  const float zf = 2.5;\n  const int mid  = 1;\n  const int end  = 3;\n  const vec3 n0  = normalize(vec3(-1.0,  1.0,  1.0));\n  const vec3 n1  = normalize(vec3( 1.0, -1.0,  1.0));\n  const vec3 n2  = normalize(vec3( 1.0,  1.0, -1.0));\n  const vec3 off = normalize(vec3(1.0, 1.0, 1.0)); \n\n  float d = 1E6;\n  float z = 1.0;\n  vec3  cp = off;\n  \n  for (int i = 0; i < mid; ++i) {\n    p = pabs(p, smoothing);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p = refl(p, n2);\n    p -= off*0.33;\n    p *= zf;\n    z *= zf;\n  }\n\n  for (int i = mid; i < end; ++i) {\n    p = pabs(p, smoothing);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p = refl(p, n2);\n    p -= off*0.24;\n    p *= zf;\n    z *= zf;\n\n    vec3 pp = p;\n    float dd0 = boxf(pp, 0.1*vec3(1.0), 0.0125)-0.0125;\n    float dd1 = length(pp)- 0.075;\n    float dd = dd0;\n    dd = min(dd, dd1);\n    dd /= z;\n    d = min(d, dd);\n  }\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n\n  float sr    = 0.4;\n  float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);\n\n  vec3 gcol   = sd*1.5*vec3(2.0, 1.0, 0.75)*1.0;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n  float ifade = 1.0-tanh_approx(1.25*ii);\n  float h     = fract(-1.0*length(pos)+0.1);\n  float s     = 0.25;\n  float v     = tanh_approx(0.4/(1.0+40.0*sd));\n  vec3 color  = hsv2rgb(vec3(h, s, v));\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*exp(-20.0*sd)*sha;\n//  return vec3(ao);\n  return gcol+col*ifade;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = 1.2*vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23WK.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 529, 557, 577, 653], [655, 708, 730, 730, 899], [901, 901, 937, 937, 1170], [1172, 1172, 1209, 1209, 1491], [1493, 1493, 1532, 1532, 1621], [1623, 1623, 1662, 1662, 1691], [1693, 1693, 1729, 1729, 1817], [1819, 1819, 1847, 1847, 1875], [1877, 1877, 1904, 1904, 1964], [1966, 1966, 2024, 2024, 2505], [2507, 2507, 2525, 2525, 3414], [3416, 3416, 3464, 3464, 3659], [3661, 3661, 3684, 3684, 3892], [3894, 3894, 3962, 3962, 4241], [4243, 4243, 4274, 4274, 5416], [5418, 5418, 5449, 5449, 5935], [5937, 5937, 5992, 5992, 6183]], "test": "untested"}
{"id": "fl2GDd", "name": "Balthazaurus test", "author": "vonba", "description": "This is an api test", "tags": ["test"], "likes": 5, "viewed": 165, "published": "Public API", "date": "1624994730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 lookup(sampler2D src, float x, float y)\n{\n\treturn texture(src, vec2(x / iResolution.x, y / iResolution.y));\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n\t\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\nfloat bubbleStrength(vec2 startPos, vec2 waveOffset, float radius, float speed, vec2 coord)\n{\n\tvec2 curPos = vec2(\n\t\tmod(startPos.x + waveOffset.x * 0.5, iResolution.x + radius * 2.0) - radius,\n\t\tmod(waveOffset.y - iTime * speed, iResolution.y + radius * 2.0) - radius);\n\treturn 1.0 - smoothstep(0.0, radius, length(coord - curPos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\t\n\t// Calculate the lookup transformation offset for the current fragment\n\tfloat offsetX = (0.1112 * iResolution.x * cos(1.44125 * (iTime + uv.y))) + (26.77311 * iTime);\n\tfloat offsetY = (0.08447 * iResolution.y * sin(2.14331 * (iTime + uv.x)));\n\t\n\t// Use parallax transformed lookup on the texture layers\n\tvec4 tex1 = lookup(iChannel0, coord.x + offsetX, coord.y + offsetY);\n\tvec4 tex2 = lookup(iChannel1, coord.x * 2.0 + offsetX * 1.6, coord.y * 2.0 + offsetY * 1.5);\n\tvec4 tex3 = lookup(iChannel2, coord.x * 3.0 + offsetX * 1.3, coord.y * 3.0 + offsetY * 1.2);\n\tvec4 tex4 = lookup(iChannel3, coord.x * 0.5 + offsetX * 0.8, coord.y * 0.5 + offsetY * 0.9);\n\t\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.1, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 1.5;\n\t\n\tvec2 rayPos2 = vec2(iResolution.x * 1.2, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tfloat raySeedA2 = 22.39910;\n\tfloat raySeedB2 = 18.0234;\n\tfloat raySpeed2 = 1.1;\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\tvec4 rays1 =\n\t\tvec4(1.2, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n\t \n\tvec4 rays2 =\n\t\tvec4(1.0, 1.2, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n\t\n\t\n\t// Calculate the colours contribution of each bubble on the current fragment.\n\tfloat bubbleScale = iResolution.x / 600.0;\n\t\n\tvec4 bubble1 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * 0.2312, 0.0), 20.0 * bubbleScale, 60.0, coord);\n\t\n\tvec4 bubble2 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(40.0, 400.0), vec2(offsetX * -0.06871, offsetY * 0.301), 7.0 * bubbleScale, 25.0, coord);\n\t\n\tvec4 bubble3 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(300.0, 70.0), vec2(offsetX * 0.19832, offsetY * 0.1351), 14.0 * bubbleScale, 45.0, coord);\n\t\n\tvec4 bubble4 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(500.0, 280.0), vec2(offsetX * -0.0993, offsetY * -0.2654), 12.0 * bubbleScale, 32.0, coord);\n\t\n\tvec4 bubble5 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(400.0, 140.0), vec2(offsetX * 0.2231, offsetY * 0.0111), 10.0 * bubbleScale, 28.0, coord);\n\t\n\tvec4 bubble6 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(200.0, 360.0), vec2(offsetX * 0.0693, offsetY * -0.3567), 5.0 * bubbleScale, 12.0, coord);\n\t\n\tvec4 bubble7 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * -0.32301, offsetY * 0.2349), 16.0 * bubbleScale, 51.0, coord);\n\t\n\tvec4 bubble8 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(130.0, 23.0), vec2(offsetX * 0.1393, offsetY * -0.4013), 8.0 * bubbleScale, 24.0, coord);\n\t\t\n\t\n\t// Blend all of the elements together.\n\t// This deliberately saturates the colour in places.\n\tfragColor = \n\t\ttex1 * 0.45 +\n\t\ttex2 * 0.25 +\n\t\ttex3 * 0.15 +\n\t\ttex4 * 0.1 +\n\t\trays1 * 0.5 +\n\t\trays2 * 0.4 +\n\t\tbubble1 * 0.25 +\n\t\tbubble2 * 0.1 +\n\t\tbubble3 * 0.18 +\n\t\tbubble4 * 0.13 +\n\t\tbubble5 * 0.15 +\n\t\tbubble6 * 0.05 +\n\t\tbubble7 * 0.12 +\n\t\tbubble8 * 0.11;\n\t\n\t// Uncomment this line if you want to see just the rays:\n\t//fragColor = rays1 * 0.5 + rays2 * 0.5;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\tfloat brightness = 1.0 - (coord.y / iResolution.y);\n\tfragColor.x *= 0.2 + (brightness * 0.8);\n\tfragColor.y *= 0.3 + (brightness * 0.7);\n\tfragColor.z *= 0.4 + (brightness * 0.6);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2GDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 114], [116, 116, 224, 224, 554], [556, 556, 649, 649, 891], [893, 893, 950, 950, 4647]], "test": "untested"}
{"id": "flB3DD", "name": "Transformed Box AABB", "author": "oneshade", "description": "Maybe not so useful but it can help in avoiding unneccessary matrix inverse computations or maybe in collision detections. I was mainly interested in trying to generalize [url=https://www.shadertoy.com/view/stSGDh]this[/url] SDF to 3D.", "tags": ["3d", "aabb", "boundingbox", "transformed"], "likes": 9, "viewed": 100, "published": "Public", "date": "1623881401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Desmos graph: https://www.desmos.com/calculator/peu1crmp2n\n\n// Constants\n#define EPSILON 1e-3\n#define INFINITY 1e20\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define ZOOM 1.0\n#define AA 2\n\n// Convenience structs\nstruct Ray { vec3 pos; vec3 dir; };\nstruct Light { vec3 pos; vec3 color; };\nstruct TraceInfo { bool hit; float dist; vec3 pos; vec3 nor; vec3 mat; };\n\n// Axis aligned bbox of a transformed box\n// The vector returned gives the upper and lower bounds\n// relative to the box's center\nvec3 transformedBoxAABB(in vec3 dims, in mat3 mat) {\n    vec3 w = mat[0] * dims.x;\n    vec3 h = mat[1] * dims.y;\n    vec3 d = mat[2] * dims.z;\n    vec3 a = w + h, b = w - h;\n    return max(max(abs(a + d), abs(a - d)),\n               max(abs(b + d), abs(b - d)));\n}\n\n// Box intersector adapted from https://www.shadertoy.com/view/ld23DV\nbool testAABB(in vec3 pos, in vec3 dims, in Ray ray) {\n    ray.pos -= pos;\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid addBox(in vec3 pos, in vec3 dims, in mat3 transform, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    mat3 inv = inverse(transform);\n    ray.pos = inv * ray.pos;\n    ray.dir = inv * ray.dir;\n\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    vec3 nor = -sign(ray.dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0.0 && (scene.hit ? tN < scene.dist : true)) {\n        scene.hit = true;\n        scene.dist = tN;\n        scene.pos = transform * (ray.pos + ray.dir * tN);\n        scene.nor = transform * nor;\n        scene.mat = mat;\n        scene.pos += pos;\n    }\n}\n\n// Very inefficient\nvoid addCylinder(in vec3 pos, in int align, in float height, in float radius, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n    if (align == 0) {\n        ray.pos.xy = ray.pos.yx;\n        ray.dir.xy = ray.dir.yx;\n    }\n\n    if (align == 2) {\n        ray.pos.yz = ray.pos.zy;\n        ray.dir.yz = ray.dir.zy;\n    }\n\n    // Quadratic coefficients\n    float a = dot(ray.dir.xz, ray.dir.xz);\n    float b = 2.0 * dot(ray.pos.xz, ray.dir.xz);\n    float c = dot(ray.pos.xz, ray.pos.xz) - radius * radius;\n\n    // Solve with a plane for the base and top\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float hh = 0.5 * height;\n        float tBase = +(hh - ray.pos.y) / ray.dir.y;\n        float tTop  = -(hh + ray.pos.y) / ray.dir.y;\n        vec4 roots = vec4(-(vec2(-1, 1) * sqrt(discr) + b) / a * 0.5, tBase, tTop);\n\n        float t = INFINITY;\n        vec3 hitPos, nor = vec3(0.0, -1.0, 0.0);\n        int nClosest;\n        for (int n=0; n < 4; n++) {\n            vec3 hitCandid = ray.pos + ray.dir * roots[n];\n            if (roots[n] > 0.0 && roots[n] < t  && abs(hitCandid.y) < hh + EPSILON && dot(hitCandid.xz, hitCandid.xz) < radius * radius + EPSILON) {\n                t = roots[n];\n                hitPos = hitCandid;\n                nClosest = n;\n            }\n        }\n\n        if (nClosest < 2) nor = vec3(hitPos.xz / radius, 0.0).xzy; // Sides\n        else nor.y = sign(2.5 - float(nClosest)); // Base and top\n        if (t > 0.0 && t < INFINITY && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = hitPos + pos;\n            scene.nor = nor;\n            scene.mat = mat;\n            if (align == 0) {\n                scene.pos.xy = scene.pos.yx;\n                scene.nor.xy = scene.nor.yx;\n            }\n\n            if (align == 2) {\n                scene.pos.yz = scene.pos.zy;\n                scene.nor.yz = scene.nor.zy;\n            }\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(false, -1.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\n    vec3 dims = vec3(1.0);\n    dims = vec3(0.75, 1.5, 0.75);\n\n    float y = iTime; // Yaw\n    float p = 0.5;   // Pitch\n    float r = iTime; // Roll\n\n    float cy = cos(y), sy = sin(y);\n    float cp = cos(p), sp = sin(p);\n    float cr = cos(r), sr = sin(r);\n\n    mat3 mat = mat3(cy * cr + sy * sp * sr, cp * sr,  sy * cr - cy * sp * sr,\n                    sy * sp * cr - cy * sr, cp * cr, -sy * sr - cy * sp * cr,\n                                  -sy * cp,      sp,                 cy * cp);\n\n    mat[0].x += sin(iTime);\n    mat[2].y += cos(iTime);\n\n    vec3 bbox = transformedBoxAABB(dims, mat);\n    if (testAABB(vec3(0.0), bbox, ray)) addBox(vec3(0.0), dims, mat, vec3(1.0, 0.5, 0.0), ray, scene);\n\n    float width = 2.0 * bbox.x;\n    addCylinder(vec3(0.0, -bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0, -bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n\n    float height = 2.0 * bbox.y;\n    addCylinder(vec3(-bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n\n    float depth = 2.0 * bbox.z;\n    addCylinder(vec3(-bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Light light = Light(vec3(-10.0, 10.0, 10.0), vec3(0.8, 0.2, 0.2));\n\n    // Mouse rotation\n    vec2 c = cos(mouse), s = sin(mouse);\n    mat2 yaw = mat2(c.x, -s.x, s.x, c.x);\n    mat2 pitch = mat2(c.y, -s.y, s.y, c.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -ZOOM)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Render the scene\n            TraceInfo scene = traceScene(camRay);\n            if (scene.hit) {\n                vec3 lightDir = normalize(light.pos - scene.pos);\n                float shade = max(0.0, dot(scene.nor, lightDir));\n                fragColor.rgb += light.color * scene.mat * shade;\n            }\n\n            // Sample the background on a miss\n            else fragColor += 1.15 - length(uv);\n        }\n    }\n\n    // Average and tonemap\n    fragColor.rgb = pow(fragColor.rgb / float(AA * AA), vec3(0.75));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 519, 571, 571, 783], [785, 855, 909, 909, 1149], [1151, 1151, 1258, 1258, 1943], [1945, 1965, 2092, 2092, 3944], [3946, 3960, 3994, 3994, 5921], [5923, 5923, 5978, 5978, 7461]], "test": "untested"}
{"id": "flB3Wt", "name": "Mandelbrot set zoom by swiiz", "author": "Swiiz", "description": "Mandelbrot set visualization", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 135, "published": "Public API", "date": "1624911206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 colorPalette = -vec4(0,23,21,0);\nconst vec4 finalColor = vec4(.0);\nconst int hueModulus = 30;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = exp(-iTime/10.0)*5.0;\n    int recursion = int(iTime*iTime*8.0) + 50, i = 0;\n    vec2 c = (fragCoord / iResolution.x - 0.5) * -zoom + -iMouse.xy/iResolution.xy, z = c;\n    for(; i <= recursion && length(z) <= 2. ; i++ ) z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    fragColor =  i - 1 == recursion ? finalColor : .6 + .6 * cos( 6.3 *  (float((i - 1) % hueModulus) / float(hueModulus)) + colorPalette);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 163, 585]], "test": "untested"}
{"id": "flB3zV", "name": "Distance Function Visualizer", "author": "01000001", "description": "A handy tool\n\nReplace the return value at line 130 with your own distance function to see it visualized\n\nThis is my first attempt at 3D in shadertoy, so the camera is distorted since I used polar coordinates rather than figuring out how to do it properly.", "tags": ["raymarching"], "likes": 2, "viewed": 40, "published": "Public", "date": "1624233457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Input Variables\nconst float pi = 3.14159;\nfloat minDistance = 0.000001;\nfloat cameraFarPlane = 500.0;\nvec3 cameraCoords = vec3(0, 0, -15.0);\nconst float maxSteps = 255.0;\nfloat fieldOfView = 45.0;\nfloat mouseSensitivity = 1.0;\n\nconst float glow = 1.0;\nconst float light = 0.8;\nvec3 glowColor = vec3(0.0, 0.6, 1.0);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\nstruct vec5 {\n    vec4 a;\n    float v;   \n};\n\nvec3 debugCol( float v )\n{\n    return vec3(v, v, v);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat mengerSpongeDF(int n, vec3 pos) { //by recursively digging a box\n\tfloat x=pos.x, y=pos.y, z=pos.z;\n\tx=x*0.5+0.5;y=y*0.5+0.5;z=z*0.5+0.5; //center it by changing position and scale\n\n\tfloat xx=abs(x-0.5)-0.5, yy=abs(y-0.5)-0.5, zz=abs(z-0.5)-0.5;\n\tfloat d1=max(xx,max(yy,zz)); //distance to the box\n\tfloat d=d1; //current computed distance\n\tfloat p=1.0;\n\tfor (int i=1; i<=n; ++i) {\n\t\tfloat xa = mod(3.0*x*p,3.0);\n\t\tfloat ya = mod(3.0*y*p,3.0);\n\t\tfloat za = mod(3.0*z*p,3.0);\n\t\tp*=3.0;\n\n\t\t//we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n\t\tfloat xx=0.5-abs(xa-1.5), yy=0.5-abs(ya-1.5), zz=0.5-abs(za-1.5);\n\t\td1=min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n\t\td=max(d,d1); //intersection\n\t}\n\t//return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n\treturn d;\n}\n\nfloat boxDF( vec3 p, vec3 b, vec3 s, vec3 o )\n{\n  vec3 q = s + abs(p - o) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxFrameDF( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphereDF(vec3 spherePos, float radius, vec3 point)\n{\n    return length(point - spherePos) - radius;\n}\n\nfloat torusDF( vec3 p, vec2 t, vec3 o )\n{\n  p -= o;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat octahedronDF( vec3 p, float s, vec3 o )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d2, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float size = 2.5;\n    return boxFrameDF( q , vec3(size, size, size), 0.025);\n}\n\nfloat sdf_blend(float d1, float d2, float a)\n{\n    return a * d1 + (1.0 - a) * d2;\n}\n\nfloat yourDistanceFunctionHere( vec3 p )\n{\n    return sphereDF(vec3(sin(iTime*0.2)*10.0, 2, 0.0+cos(iTime*0.2)*10.0), (sin(iTime)+1.0)*2.5, p);\n}\n\nvec2 DF(vec3 point)\n{\n    float distance1 = yourDistanceFunctionHere(point);\n    float distance2 = point.y +  3.0;\n    \n    \n    float final = min(distance1, distance2);    \n    \n    //final  = smin(partial, distance3, 3.0);\n\n    \n    return vec2(final, distance1);\n}\n\n//*\nfloat evaluateLight( vec3 origin)\n{\n    return (1.0+sin(DF(origin).y-pi/2.0))/2.0;\n    //return sin(DF(origin).y);\n\n}//*/\n\n\nvec5 depth( vec3 origin, vec3 direction )\n{\n    float depth = 0.0;\n    float light = 0.0;\n    float iterations = 0.0;\n    vec2 closestPoint = vec2(cameraFarPlane, 0);\n    \n    \n    vec3 b = direction/length(direction);//b = normalized direction\n    vec3 p = origin; //point or direction vector times depth\n    \n    float d = cameraFarPlane; //Distance\n    \n    float didCollide = 1.0;\n    \n    for(float i=0.;i<maxSteps;i++)\n    {\n        p = origin + (b*depth);\n        d = DF(p).x;\n        \n        iterations++;\n        \n        if (d < closestPoint.x) closestPoint.x = d;\n        \n        if (d < minDistance || depth > cameraFarPlane)\n        {\n            if ((d > minDistance))\n            {\n                didCollide = 0.0;\n            }\n            \n            break;\n        }\n        \n        depth += d;\n\n    }\n    \n    if (depth < cameraFarPlane)\n    {\n        light = evaluateLight(p);\n    }\n    \n    \n    depth /= cameraFarPlane;\n    \n    \n    return vec5(vec4(depth, light, iterations/maxSteps, closestPoint.x), didCollide);\n}\n\nvec2 circle( vec2 centrePos, float radius, float deg)\n{\n  float x = centrePos.x + radius * cos(deg * pi / 180.0);\n  float y = centrePos.y + radius * sin(deg * pi / 180.0);\n  return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = (iMouse.xy/iResolution.xy) * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= mouseSensitivity*fieldOfView;    \n    \n\n    vec2 dirY = circle(vec2(0, 0), 1.0, mouse.y + uv.y *fieldOfView);\n    vec2 dirXY = circle(vec2(0, 0), dirY.x, mouse.x*5.0 + uv.x*fieldOfView);\n    vec3 dirV = vec3(dirXY.y, dirY.y, dirXY.x);//Polar Coordinate Spherical Projection\n\n    \n    vec4 pixelInfo =depth(cameraCoords, dirV).a;\n    \n    vec3 lightCol = /*debugCol(0.0);*/lightColor * pixelInfo.y * light;\n    vec3 glowCol = glowColor * pixelInfo.z * glow;\n    vec3 col = lightCol + glowCol;\n\n    \n    fragColor = vec4(col.xyz, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 403, 429, 429, 457], [459, 459, 500, 500, 586], [588, 588, 627, 658, 1489], [1491, 1491, 1538, 1538, 1633], [1635, 1635, 1680, 1680, 1962], [1964, 1964, 2022, 2022, 2071], [2073, 2073, 2114, 2114, 2189], [2191, 2191, 2238, 2238, 2518], [2520, 2520, 2557, 2557, 2578], [2580, 2580, 2623, 2623, 2645], [2647, 2647, 2691, 2691, 2712], [2714, 2714, 2766, 2766, 2865], [2867, 2867, 2925, 2925, 3025], [3027, 3027, 3086, 3086, 3185], [3187, 3187, 3223, 3223, 3341], [3343, 3343, 3389, 3389, 3427], [3429, 3429, 3471, 3471, 3574], [3576, 3576, 3597, 3597, 3843], [3845, 3849, 3884, 3884, 3966], [3966, 3973, 4016, 4016, 5017], [5019, 5019, 5074, 5074, 5213], [5215, 5215, 5272, 5322, 6072]], "test": "untested"}
{"id": "flBGDc", "name": "Smile Glitch", "author": "sorunokoe", "description": "This my tutorial project", "tags": ["tutorial"], "likes": 0, "viewed": 135, "published": "Public API", "date": "1624817309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\nfloat Smile(vec2 uv, vec3 col, vec2 position) {\n    float mask = Circle(uv, position, 0.3, 0.003);\n    mask -= Circle(uv, position-vec2(-0.1, -0.08), 0.05, 0.003);\n    \n    float leftEye = Circle(uv, position-vec2(0.1, -0.07), 0.05, 0.003);\n    leftEye -= Circle(uv, position-vec2(0.1, -0.06), 0.05, 0.003);\n    col *= leftEye;\n    mask -= leftEye;\n    \n    float smile = Circle(uv, position-vec2(0,0), 0.02, 0.003);\n    smile -= Circle(uv, position-vec2(0,-0.02), 0.02, 0.003);\n    col *= smile;\n    mask -= smile;\n    return mask;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.4, 0.5, 0.5);\n    col /= 0.6 + 0.4*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 position = vec2(0,0);\n    \n    position += vec2(0.5,0.5);\n    position *= cos(iTime/uv.x)*uv.x*0.1;\n    \n    float mask = Smile(uv, col, position);\n    vec3 col2 = col*mask;\n    col -= col2;\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 136], [137, 137, 184, 184, 671], [672, 672, 727, 777, 1239]], "test": "untested"}
{"id": "flBGR3", "name": "Monochrome dithered phong", "author": "sepehrnoor", "description": "Simple phong shader with dithered color", "tags": ["dither"], "likes": 6, "viewed": 60, "published": "Public", "date": "1624459298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* MONOCHROME PHONG LIGHTING\n   DITHERING ALGORITHM BY ALEX CHARLTON \n   http://alex-charlton.com/posts/Dithering_on_the_GPU/\n*/\n\nstruct {\n    vec2 screen;\n} globals;\n\nconst int indexMatrix4x4[16] = int[](0,  8,  2,  10,\n                                     12, 4,  14, 6,\n                                     3,  11, 1,  9,\n                                     15, 7,  13, 5);\n\nfloat indexValue() {\n    int x = int(globals.screen.x) % 4;\n    int y = int(globals.screen.y) % 4;\n    return float(indexMatrix4x4[(x + y * 4)]) / 16.0;\n}\n\nfloat dither(float color) {\n    float closestColor = (color < 0.5) ? 0. : 1.;\n    float secondClosestColor = 1. - closestColor;\n    float d = indexValue();\n    float distance = abs(closestColor - color);\n    return (distance < d) ? closestColor : secondClosestColor;\n}\n\nfloat dist_sphere(vec3 center, float radius, vec3 eye, vec3 dir){\n    vec3 oc = eye - center;\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc,oc) - radius*radius;\n    float d = b*b - 4.*a*c;\n    if(d < 0.0){\n        return -1.0;\n    }\n    else{\n        float num = -b - sqrt(d);\n        if (num > 0.0) {\n        return num / (2.0 * a);\n    }\n\n    num = -b + sqrt(d);\n    if (num > 0.0) {\n        return num / (2.0 * a);\n    }\n    else {\n        return -1.;\n    }\n\n    }\n}\n\nvec3 sphere_normal(vec3 eye, vec3 dir, float dist, vec3 center){\n    return normalize((eye + dist * dir) - center);\n}\n\n\nfloat dist_plane(vec3 center, vec3 normal, vec3 eye, vec3 dir)\n{\n    \n    float d = dot(normal, dir);\n    if (abs(d) > 0.001f)\n    {\n        float t = dot(normal, (center - eye)) / d;\n        if (t >= 0.001f) return t;\n    }\n    return -1.;\n}\n\nbool trace(vec3 eye, vec3 dir, vec3[3] sphere_center, float[3] sphere_radius, vec3 plane_center, vec3 plane_normal){\n    \n    for (int i = 0; i < 3; i++){\n        float new_depth = dist_sphere(sphere_center[i], sphere_radius[i], eye, dir);\n        if (new_depth != -1.) {\n            return true;\n        }\n    }\n    if (dist_plane(plane_center, plane_normal, eye, dir) > 0.) return true;\n    return false;\n}\n\nvec3 raytrace(  vec3 eye, vec3 dir,\n                vec3[3] sphere_center, float[3] sphere_radius, \n                vec3 plane_center, vec3 plane_normal, \n                vec3 light_pos, int iteration){\n\n    float bias = 0.01;\n    if (iteration < 1) return vec3(0.);\n    vec3 col = vec3(0.);\n    float depth = 99999.;\n    vec3 normal = vec3(0.);    \n    bool hit = false;\n    int color_index = -1;\n\n    // sphere intersection\n    for (int i = 0; i < 3; i++){\n        float new_depth = dist_sphere(sphere_center[i], sphere_radius[i], eye, dir);\n        if (new_depth != -1. && new_depth < depth) {\n            hit = true;\n            depth = new_depth;\n            normal = sphere_normal(eye, dir, new_depth, sphere_center[i]);\n            color_index = i;\n        }\n    }\n    \n    // plane intersection\n    float new_depth = dist_plane(plane_center, plane_normal, eye, dir);\n        if (new_depth != -1. && new_depth < depth) {\n            hit = true;\n            depth = new_depth;\n            normal = plane_normal;\n            color_index = -1;\n    }\n    \n    if (hit){    \n        vec3 hit_point = eye + depth * dir;\n        vec3 shadow_point = hit_point + normal * bias;\n        vec3 light = vec3(0.);\n        vec3 light_dir = light_pos - hit_point;\n\n        // check shadow\n        bool in_shadow = trace(shadow_point, light_dir, sphere_center, sphere_radius, plane_center, plane_normal);\n        \n        if (color_index == -1) col = vec3(1.);\n        else {\n            float phong = clamp(dot(normalize(light_pos - hit_point), normal), 0., 1.);\n            phong = dither(phong);\n            col = vec3(phong);\n        }\n        col = col * float(!in_shadow);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    globals.screen = fragCoord;\n    \n    float angle = radians(-30.);\n    \n    mat3 rotate = mat3(\n        vec3(1, 0,          0),\n        vec3(0, cos(angle),-sin(angle)),\n        vec3(0, sin(angle), cos(angle))\n    );\n\n    vec3 eye = vec3(0.,5.,-10.);\n    vec3 pixel = eye + rotate * vec3((fragCoord - iResolution.xy / 2. ) / iResolution.y, 1.);\n    vec3 dir = normalize(pixel - eye);\n    vec3 light_pos = vec3(cos(iTime / 5.) * 10., 10. + sin(iTime / 5.) * sin(iTime / 5.) * 5., 0.);    \n    vec3 plane_center = vec3(0.,-5.,0.);\n    vec3 plane_normal = normalize(vec3(0.,1.,0.));\n    \n    vec3[] sphere_center = vec3[](\n        vec3(sin(iTime * 1.2 + 0.3) * 3., 0., cos(iTime * 1.2 + 0.3) * 3.), \n        vec3(sin(iTime * 0.87) * 2., 2., cos(iTime * 0.87) * 2.), \n        vec3(sin(-iTime), 3., cos(-iTime)));\n    float[] sphere_radius = float[](.5, 1., .2);\n    \n    vec3 col = vec3(0.);\n    col = raytrace(eye, dir, sphere_center, sphere_radius, plane_center, plane_normal, light_pos, 1);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 379, 399, 399, 533], [535, 535, 562, 562, 803], [805, 805, 870, 870, 1312], [1314, 1314, 1378, 1378, 1431], [1434, 1434, 1498, 1498, 1676], [1678, 1678, 1794, 1794, 2086], [2088, 2088, 2290, 2290, 3781], [3783, 3783, 3840, 3840, 4871]], "test": "untested"}
{"id": "flBGRD", "name": "Ripple test 1", "author": "zengqh", "description": "ripple test", "tags": ["ripple"], "likes": 1, "viewed": 42, "published": "Public", "date": "1623405847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = 8.;\n\tvec2 uv = (fragCoord.xy / iResolution.y - .5) * res;\n    \n    uv -= 0.5;\n    vec2 p0 = floor(uv);\n\n    vec2 circles = vec2(0.);\n    vec2 pi = p0;\n    vec2 hsh = pi;\n    vec2 p = pi + hash22(hsh);\n\n    float t = fract(hash12(hsh));\n    vec2 v = p - uv;\n    float d = length(uv) - mod(iTime, 2.);\n\n    float h = 1e-3;\n    float d1 = d - h;\n    float d2 = d + h;\n    float p1 = sin(31.*d1);// * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);\n    float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);\n    circles += (p1) * 5.;\n    circles /= 118.;\n\n    float intensity = .3;//mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*iTime + 0.5)*2.-1.)));\n    vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));\n    vec3 color = texture(iChannel0, uv/res - intensity*n.xy).rgb + 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 93, 93, 215], [217, 217, 238, 238, 357], [359, 359, 416, 416, 1346]], "test": "untested"}
{"id": "flf3WS", "name": "Worley noise 1D __", "author": "Envy24", "description": "worley, noise, random, cellular", "tags": ["noise", "random", "worley", "cellular"], "likes": 2, "viewed": 53, "published": "Public", "date": "1622683515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  \n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 12345u;\n    const uint enthropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat WorleyNoise1D(float u)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n\n    // Integer part.\n    u = floor(u);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float y = -1.0f; y < 2.0f; y += 1.0f)\n    {\n        for (float x = -1.0f; x < 2.0f; x += 1.0f)\n        {\n            // Pseudorandom sample coordinates in corresponding cell.\n            float xSample = x + sample1DHashUI32(uint(u + x));\n\n            // Distance from pixel to pseudorandom sample.\n            //float _distance = \n                //sqrt((fractU - xSample) * (fractU - xSample));\n                \n            float _distance = \n                (fractU - xSample) * (fractU - xSample);\n\n            // Mistance from pixel to pseudorandom sample.\n            minDistance = min(minDistance, _distance);\n        }\n    }\n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 6.0f;\n    \n    float _u = uv.x + iMouse.x * 0.1f + iTime * 0.1f;\n\n    float gray = WorleyNoise1D(_u) * 0.5f;\n    gray += WorleyNoise1D(_u * 2.054f) * 0.25f;\n    gray += WorleyNoise1D(_u * 4.554f) * 0.125f;\n      \n    // Notscalable anti-aliasing.\n    //gray = smoothstep(0.0f, 1.0f, abs((uv.y - 2.5f) - gray) * 100.0f);\n    \n    // Scalable anti-aliasing (from FabriceNeyret2 advice).\n    float lineWidth = 16.0/iResolution.y;\n    gray = smoothstep(0.0, lineWidth, abs((uv.y - 2.5) - gray));\n    \n    // No anti-aliasing\n    //gray = 1.0f - float(abs(uv.y - gray) < 0.003f);\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 82, 152, 421], [423, 423, 453, 475, 1287], [1289, 1289, 1346, 1396, 2077]], "test": "untested"}
{"id": "flfGDs", "name": "Ray Marching - Normal", "author": "ChaosOfZen", "description": "A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/", "tags": ["raymarching", "sphere", "color"], "likes": 1, "viewed": 37, "published": "Public", "date": "1623076263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n\n\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n \nfloat GetDist(vec3 p) \n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasn’t hit an object it also breaks out of the loop.\n*/  \n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\n/*\n\nNormals\nTo get the normals the point where the raymarch hits is used and a small amount (Epsilon) \nis added to the point in the right, up and forward direction. This new offset point is \nthen normalized to turn it into a unit vector/direction.\n*/\n \nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n    vec3 n = d - vec3(\n    GetDist(p-e.xyy),  \n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n   \n    return normalize(n);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n   \n    vec3 p = ro + rd * d;\n    //float dif = GetLight(p); // Diffuse lighting\n    //d/= 10.;\n    vec3 color = vec3(0);\n    //color = vec3(dif);\n    color = GetNormal(p);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 215, 239, 239, 454], [457, 847, 882, 882, 1138], [1140, 1393, 1417, 1417, 1616], [1619, 1619, 1676, 1676, 2136]], "test": "untested"}
{"id": "flj3Wm", "name": "Synchronized Line Animation", "author": "Shane", "description": "Rendering repeat line sequences within triangle cells to create a synchronized line animation.", "tags": ["triangle", "line", "hexagon", "geometry"], "likes": 47, "viewed": 385, "published": "Public API", "date": "1624032012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tSynchronized Line Animation\n\t---------------------------    \n    \n    Rendering repeat line sequences within triangle cells to create a synchronized \n    line animation.\n    \n    This particular sequence is a rough recreation of an animation that I've seen \n    in various reincarnations before. I'm pretty sure the original was conceived by \n    a visual artist known as Admiral Potato, who has an awesome body of work... and \n    a Shadertoy account, from what I can see. The link to his work is below.\n    \n    It's based on a very simple idea: Partition space into some kind of grid, then\n    use the vertex, midpoint, etc, geometry to render node based line animations. \n    I've done similar things before with a simple square grid, but hadn't tried it \n    with a more interesting tiling arrangement.\n    \n    Aesthetically, I adhered to the spirit of the original, but rendered it in a way\n    that was more condusive to realtime constraints. Anyway, this was just a simple\n    but rushed geometric animation example, so don't worry about the code itself too \n    much. It was a spur of the moment thing, which meant it was hacked together with \n    old routines of mine and without a lot of forethought. Hopefully, Admiral Potato \n    himself will one day convert his original to pixel shader form and post it on \n    Shadertoy. \n\n\n\n    Reference link:\n    \n    // Admiral Potato's Tumblr page. If you're interested in graphics, then \n    // you've probably seen versions of his work floating around the net.\n    http://admiralpotato.tumblr.com/\n    \n    // The link to the original animation.\n    Hex Doctor - Admiral Potato\n    http://nuclearpixel.com/motion/hex-doctor/\n    \n \n\n*/\n\n\n// Color palette: Pink\\Green: 0, Copper\\Gold: 1, Silver: 2\n#define PALETTE 0\n\n// Display the triangle cell borders.\n//#define SHOW_CELLS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// IQ's line distace formula. \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n*/ \n\n// Global distance values for the two colored lines and end points.\n// This was hacked in at the last minutes... I'll incorporate it\n// into the structure below at some stage.\nfloat line = 1e5;\nfloat line2 = 1e5;\nfloat circle = 1e5;\nfloat circle2 = 1e5;\n \n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./2.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 idi, cntr;\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Unskewed block corner postions.\n    vec2[4] vert = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    // Unskewing to enable rendering back in normal space.\n    vert[0] = unskewXY(vert[0]*dim, sk);\n    vert[1] = unskewXY(vert[1]*dim, sk);\n    vert[2] = unskewXY(vert[2]*dim, sk);\n    vert[3] = unskewXY(vert[3]*dim, sk); \n    \n    // Skewed local coordinates.\n    vec2 skqxy = skewXY(q.xy, sk);\n    \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n \n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    // Initialize the various distance field values to a maximum.\n    line = 1e5;\n    line2 = 1e5;\n    circle = 1e5;\n    circle2 = 1e5;\n    \n\n    // End point width and line width values.\n    const float cw = .02;\n    const float lw = .007;\n    \n    // Fractional time for the four nodes. \n    const int ttm = 4;\n    float tm = 2. - iTime;\n    float modtm = mod(tm, float(ttm));\n    int index = int(modtm);\n    // Another animation thread.\n    float tm2 = iTime;\n    float modtm2 = mod(tm2, float(ttm));\n    int index2 = int(modtm2);\n \n\n    // Iterate through four neighboring grid squares -- Each square is skewed\n    // and subdivided diagonally to determine the nearest triangle. Yeah, it's\n    // annoying work, but the lines are rendered outside the confines of each\n    // triangle cell, which means neighboring cells need to be accounted for.\n    for(int i = min(0, iFrame); i<4; i++){    \n        \n        // Block center.\n        cntr = ps4[i]/2.;\n\n        // Skewed local coordinates.\n        p = skqxy;\n        //ip = floor(p/s - cntr) + .5 + cntr; // Local tile ID.\n        // Correct positional individual tile ID.\n        idi = (floor(p/s - cntr) + .5 + cntr)*s;\n        p -= idi; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);       \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi, sk);  \n\n        \n        // Partioning the rectangle into two triangles.\n        for(int triJ = min(0, iFrame); triJ<2; triJ++){\n        \n            // Vertices for triangle one or two.\n            if(triJ==0) tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n            else tri1.v = vec2[3](vert[0], vert[2], vert[3]);\n            \n            tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n            tri1.triID = float(i + triJ*4); // Triangle ID. Not used here.\n            tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n            tri1.p = p; // 2D coordinates.\n\n            // Mid edge points.\n            vec2[3] mid = vec2[3](mix(tri1.v[0], tri1.v[1], .5), mix(tri1.v[1], tri1.v[2], .5), mix(tri1.v[2], tri1.v[0], .5));\n\n            // Animating three edge lines and three vertex based lines.\n            for(int j = min(0, iFrame); j<3; j++){\n\n                 \n                // Three edge lines. Each map out a rhomboid path between four nodes.\n                //\n                // Rhombic nodal points -- These are hand picked.\n                vec2[4] pnt = vec2[4](mix(tri1.v[(0 + j)%3], mid[(2 + j)%3], .5), mix(mid[(2 + j)%3], mid[(0 + j)%3], .5), \n                                mix(mid[(2 + j)%3], mid[(1 + j)%3], .5), mid[(2 + j)%3]);\n                vec4 vAng = vec4(6.2831/3., 6.2831/6., 6.2831/3., 6.2831/6.); // Sweep angle.\n                vec2 p0 = p - pnt[(index + 1)%4]; // Pivot point.\n                float ang = mix(0., vAng[index], (fract(tm))); // Angular position.\n                p0 *= rot2(-ang); // Angular pivot.\n                vec2 p1 = (pnt[index] - pnt[(index + 1)%4]); // Anchor point.\n\n                // Line and circular end points for this edge.\n                float ln = sdLine(p0, vec2(0), p1);\n                float cir = min(length(p0), length(p0 - p1));  \n\n                // Add the line and end points for this edge to the total.\n                circle = min(circle, cir - cw);\n                line = min(line, ln - lw); \n\n                // Three vertex-based lines. Each map out a rhomboid path between four nodes.\n                //\n                // Do the same as above.\n                pnt = vec2[4](tri1.v[(0 + j)%3], mix(tri1.v[(0 + j)%3], tri1.v[(1 + j)%3], .25), \n                              mix(tri1.v[(0 + j)%3], tri1.v[(2 + j)%3], .25), vec2(0));\n                vec2 refDir = mix(pnt[0], pnt[2], .5) - pnt[1];\n                pnt[3] = pnt[1] + length(refDir)*normalize(refDir)*2.;\n\n                p0 = p - pnt[(index2 + 1)%4];\n                vAng = vAng.wzyx;\n                ang = mix(0., vAng[index2], (fract(tm2)));\n                p0 *= rot2(-ang);\n                p1 = (pnt[index2] - pnt[(index2 + 1)%4]);\n                ln = sdLine(p0, vec2(0), p1);\n\n                cir = min(length(p0), length(p0 - p1));  \n              \n                circle2 = min(circle2, cir - cw);\n                line2 = min(line2, ln - lw); \n                \n                \n                // If applicable, update the overall minimum distance value,\n                // then return the correct triangle information.\n                if(tri1.dist<d){\n                    d = tri1.dist;\n                    gT = tri1;\n                    //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n                }\n                \n                \n            } \n        }\n        \n        if(line>1e6) break; // Fake break to help the compiler.\n    \n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n// A simpler triangle routine to help render the background.\nfloat gTri;\n\nvec4 getTri(vec2 p, float sc){\n \n    \n    // Rectangle stretch.\n    vec2 rect = vec2(2./sqrt(3.), 1)*sc; \n    //const vec2 rect = vec2(.85, 1.15)*scale; \n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x/2./sc, 0); // 12 x .2\n    //p.x += rect.x/2.; \n     \n     p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    return vec4(p, id);\n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n     \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = rot2(3.14159/6.)*uv*gSc;// + vec2(0, iTime/24.);//rot2(3.14159/6.)*\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Sun direction and shadow sample.\n    vec2 sDir = rot2(3.14159/6.)*normalize(vec2(-1));\n    triS gTSh = blocks(p - sDir*.025);\n    \n    // Shadow field values.\n    float lineSh = line, line2Sh = line2, circleSh = circle, circle2Sh = circle2;\n    \n    // Take a function sample. \n    triS gT = blocks(p); \n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene to a dark background color.\n    vec3 bg = vec3(.07);\n    vec3 col = bg;  \n    \n  \n    #ifdef SHOW_CELLS\n    // Triangle edge lines.\n    float ln = 1e5;\n    ln = min(ln, sdLine(svP, svV[0], svV[1]));\n    ln = min(ln, sdLine(svP, svV[1], svV[2]));\n    ln = min(ln, sdLine(svP, svV[2], svV[0]));\n    ln -= .0015; \n     \n    // Render the triangle cell edges.\n    col = mix(col, col*1.6, (1. - smoothstep(0., sf*4.*iRes/450., ln - .0005)));\n    col = mix(col, col*.3, (1. - smoothstep(0., sf*2., ln)));\n    #endif\n    \n \n    // The triangle background pattern.\n    //\n    // Sunken holes.\n    vec2 q = oP;\n    float tSc = 1./2./4.;\n    vec2 offs = vec2(sqrt(3.), 1)/3./16.;\n    vec4 triSh = getTri(q - sDir*.025*tSc, tSc);\n    float dotsSh = length(triSh.xy - offs) - .02;\n    if(gTri<.5) dotsSh = length(triSh.xy + offs) - .02;\n    \n    vec4 tri = getTri(q, tSc); \n    \n    float dots = length(tri.xy - offs) - .02;\n    if(gTri<.5) dots = length(tri.xy + offs) - .02;\n    \n    // Render the sunken holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, (bg + .03)*(max(dots - dotsSh, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n \n    // Raised holes.\n    q = oP; \n    q += vec2(sqrt(3.), 1)/2.*tSc;\n    triSh = getTri(q - sDir*.025*tSc, tSc);\n    dotsSh = length(triSh.xy) - .02;\n    \n    tri = getTri(q, tSc);\n    dots = length(tri.xy) - .02;\n    \n     // Render the raised holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, 1.3*(bg + .03)*(max(dotsSh - dots, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n\n\n    // Render the drop shadow over the background.\n    float shadow = min(min(lineSh, line2Sh), min(circleSh, circle2Sh));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., shadow - .006))*.5);\n \n    // Back texture. Not used.\n    //vec3 tx = texture(iChannel0, oP).xyz; tx *= tx;\n    //tx = smoothstep(-.1, .5, tx);\n    //col *= tx*2.;\n    \n    // Color palette.\n    vec3 col1 = vec3(.75, 1, .3);//vec3(.3, 1, .5);//vec3(1, .75, .3)\n    vec3 col2 = vec3(1, .2, .4);//vec3(1, .2, .4);\n    #if PALETTE == 1\n    col1 = vec3(1, .65, .25);\n    col2 = vec3(.75, .35, .15);\n    #elif PALETTE == 2\n    col1 = vec3(.6);\n    col2 = col1;\n    #endif\n     \n    // Render the hexagon line layers -- AO, stroke, color, etc.\n    float sh2 = max(.2 - line2/.006, 0.);\n    sh2 *= max(line2Sh - line2, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, line2));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line2 + .007)); // Extra shine.\n   \n    // Render the triangle line layers with a higher Z value.\n    float sh = max(.2 - line/.006, 0.);\n    sh *= max(lineSh - line, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, line));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line + .007)); // Extra shine.\n    \n    \n    \n    // Silver end points.\n    col1 = vec3(1); col2 = col1;\n    // Gold ends.\n    //col1 = vec3(1.2, .95, .5); col2 = col1;\n    // Silver fluorescent ends.\n    //col1 = mix(col1*3., vec3(1), .65); col2 = mix(col2*4., vec3(1), .65);\n    \n    // Render the hexagonal end points.\n    sf *= 1.5;\n    sh2 = max(.7 - circle2/.016, 0.);\n    sh2 *= max(circle2Sh - circle2, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, circle2));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle2 + .01));\n   \n    // Render the triangle end points.\n    sh = max(.7 - circle/.016, 0.);\n    sh *= max(circleSh - circle, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, circle));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle + .01));\n    \n    \n    // Fake overhead lighting to roughly match the shadows.\n    col *= max(1.25 - length(uv + sDir*.5)*.5, 0.);\n    \n    \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    \n    \n    // Rought gamma correction and presentation.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1839, 1872, 1894, 1894, 1952], [1955, 1983, 2004, 2004, 2067], [2070, 2112, 2171, 2171, 2751], [2754, 2789, 2831, 2857, 3136], [3138, 3169, 3217, 3217, 3295], [3299, 3362, 3390, 3390, 3434], [3436, 3501, 3531, 3669, 3717], [4440, 4696, 4716, 4716, 11004], [11006, 11080, 11110, 11143, 12112], [12114, 12114, 12168, 12227, 17783]], "test": "untested"}
{"id": "flj3WR", "name": "Mountain rivers", "author": "jarble", "description": "Yet another fractal terrain experiment.", "tags": ["fractal", "terrain", "river", "mountain"], "likes": 4, "viewed": 171, "published": "Public API", "date": "1623704656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat noise(in vec2 uv)\n{\n    \n    return sin(uv.x*1.25)+cos(uv.y/1.25);\n}\n\n\n#define OCTAVES 6\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.5;\n    float freq = 0.8;\n    uv /= amplitude;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.45-abs(noise(uv * freq)-.45) * amplitude));\n        \n        amplitude *= -.27;\n        \n        freq *= 3.5-value/8.0;\n        \n        uv += uv.yx/freq;\n        //uv += vec2(cos(uv.x/freq),sin(uv.y/freq));\n    }\n    \n    return value-2.6;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 410, 435, 435, 484], [505, 505, 528, 577, 1068], [1143, 1143, 1181, 1181, 1241], [1243, 1243, 1276, 1276, 1496], [1498, 1498, 1536, 1536, 1763], [1765, 1765, 1803, 1803, 2027], [2029, 2029, 2058, 2058, 2153], [2155, 2155, 2192, 2192, 2251], [2254, 2322, 2341, 2341, 2380], [2382, 2382, 2402, 2402, 2478], [2480, 2480, 2499, 2499, 2538], [2540, 2540, 2597, 2597, 2832], [2834, 2834, 2869, 2869, 3263], [3265, 3265, 3319, 3319, 3985], [3988, 3988, 4040, 4040, 4475], [4477, 4477, 4534, 4534, 5725]], "test": "untested"}
{"id": "fljGDW", "name": "Maxnorm Distance to Ellipse", "author": "oneshade", "description": "I found this one was very intuitive and also made a deconstruction of the method (running by default).", "tags": ["2d", "sdf", "distance", "ellipse", "maxnorm", "deconstruction"], "likes": 4, "viewed": 60, "published": "Public", "date": "1623921408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DECONSTRUCT\n\n// Drawing utility\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    //p = abs(p);\n    //p = max(p, (p - ab).yx);\n    //float ba = ab.y / ab.x, a = ba * ba + 1.0;\n    //float b = p.y - p.x, bb = b * b;\n    //return p.x - (sqrt(bb - (bb - ab.y * ab.y) * a) - b) / a;\n\n    // Simpler ellipse distance by iq\n    p = abs(p);\n    p = max(p, (p - ab).yx);\n    float a = dot(ab, ab);\n    float b = p.y - p.x;\n    return p.x - (ab.y * sqrt(a - b * b) - ab.x * b) * ab.x / a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #ifdef DECONSTRUCT\n    float shift = 0.5 - 0.5 * cos(0.1 * iTime);\n    float scale = mix(1.0, 2.0, shift);\n\n    vec2 uv = abs((fragCoord - 0.5 * shift * iResolution.xy) / iResolution.y) * scale;\n    float unit = 2.0 * scale / iResolution.y;\n\n    vec2 ab = vec2(1.25, 0.4);\n    float dist = sdEllipse(uv, ab) / scale;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(dist));\n    color *= 0.8 + 0.2 * cos(240.0 * dist);\n    drawSDF(abs(dist) * scale, vec3(1.0));\n\n    // Sample point\n    vec2 p = vec2(1.5, 0.5);\n    float r = (0.5 + 0.5 * sin(0.25 * iTime)) + 0.25;\n    float c = cos(r), s = sin(r);\n    p *= mat2(c * ab.x, -s * ab.x, s * ab.y, c * ab.y);\n\n    // Sample Distance\n    float pDist = abs(sdEllipse(p, ab));\n    drawSDF(length(uv - p) - 0.008, vec3(0.0, 1.0, 0.0));\n    drawSDF(abs(max(abs(uv.x - p.x), abs(uv.y - p.y)) - pDist), vec3(0.0, 1.0, 0.0));\n\n    // Vertical edge touching\n    if (abs(p.x) - ab.x > abs(p.y)) {\n        float seg = length(uv - vec2(p.x - pDist, clamp(uv.y, p.y - pDist, p.y + pDist)));\n        drawSDF(seg - 0.008, vec3(1.0, 0.0, 0.0));\n        if (abs(uv.x) - ab.x > abs(uv.y)) color.b += 0.5;\n        drawSDF(abs(uv.y - uv.x + ab.x) * sqrt(0.5) - 0.003, vec3(0.0));\n    }\n\n    // Horizontal edge touching\n    else if (abs(p.y) - ab.y > abs(p.x)) {\n        float seg = length(uv - vec2(clamp(uv.x, p.x - pDist, p.x + pDist), p.y - pDist));\n        drawSDF(seg - 0.008, vec3(1.0, 0.0, 0.0));\n        if (abs(uv.y) - ab.y > abs(uv.x)) color.b += 0.5;\n        drawSDF(abs(uv.x - uv.y + ab.y) * sqrt(0.5) - 0.003, vec3(0.0));\n    }\n\n    // Corner touching\n    else {\n        drawSDF(abs(uv.y - uv.x + p.x - p.y) * sqrt(0.5) - 0.001, vec3(0.0));\n        drawSDF(length(uv - p + pDist) - 0.015, vec3(1.0, 0.0, 0.0));\n    }\n\n    #else\n    // Alternate reality! :D\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time);\n\n    vec2 dims = vec2(0.3 + 0.05 * sin(iTime), 0.2 + 0.1 * cos(0.5 * iTime));\n    float dist = sdEllipse(uv, dims);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(dist));\n    color *= 0.8 + 0.2 * cos(240.0 * dist);\n    drawSDF(abs(dist), vec3(1.0));\n\n    float mDist = abs(sdEllipse(mouse, dims));\n    drawSDF(length(uv - mouse) - 0.008, vec3(0.0, 1.0, 0.0));\n    drawSDF(abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist), vec3(0.0, 1.0, 0.0));\n\n    #endif\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 121, 161, 401, 565], [567, 567, 622, 622, 3408]], "test": "untested"}
{"id": "fljGR3", "name": "Cubic Bezier 4 Methods", "author": "Yusef28", "description": "A Cubic Bezier Segment Visualization\nAs linear interpolation, binomial form, matrix form and using mix functions\n4rknova also made a pretty one of these\nA good resource: https://pomax.github.io/bezierinfo/\n\n", "tags": ["bezier", "cubic", "casteljau"], "likes": 7, "viewed": 73, "published": "Public", "date": "1624419127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Version by 4rknova: Interpolation: Bezier, Cubic: https://www.shadertoy.com/view/ll23Wt\n//Version by oneshade: Cubic Bezier to \"y=\":  https://www.shadertoy.com/view/Nd2Gzw\n//version by fluxatron: Day11: Cubic Bezier: https://www.shadertoy.com/view/WdlBD8\n\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n\n//Edit: 24-06-2021 added a matrix representation to the casteljau's segmentation algo\n\n#define numSegments 20.\n#define showSeg\n/*\n//black and light blue\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n\n#define segRingRadius 0.006\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - 0.004);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9));\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//original version with notes\n\nvec3 drawSegmentsOrig(vec2 p, vec2 p1,vec2 p2,vec2 p3,vec2 p4,vec3 col){\n    \n    float t = 0.;\n \n    //basic linear interpolation form\n    vec2 d1 = p1*t + (1.0-t)*p2;\n    vec2 d2 = p2*t + (1.0-t)*p3;\n    vec2 d3 = p3*t + (1.0-t)*p4;\n    \n    vec2 m1 = d1*t + (1.0-t)*d2; \n    vec2 m2 = d2*t + (1.0-t)*d3; \n    \n    vec2 g = m1*t + (1.0-t)*m2;\n\n    \n    //or \n    //vec2 g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(t*t) + p4*(1.-t)*(1.-t)*(1.-t);\n    \n    //because if you substitute the right side of the d points\n    //into the d's in the right side of the m points\n    //and did that for the the m points into the g\n    //and add like terms you get the above!\n    \n    //p1*t*t + (1.0-t)*p2*t + p2*(1.0-t)*t + (1.0-t)*(1.0-t)*p3;\n    //p2*t*t + (1.0-t)*p3*t + p3*(1.0-t)*t + (1.0-t)*(1.0-t)*p4;\n    //p1*t*t*t + (1.0-t)*p2*t*t + p2*(1.0-t)*t*t + (1.0-t)*(1.0-t)*t*p3;\n    //p2*(1.0-t)*t*t + (1.0-t)*(1.0-t)*p3*t + p3*(1.0-t)*(1.0-t)*t + (1.0-t)*(1.0-t)*(1.0-t)*p4;\n    \n    \n    float dt = 1./numSegments;\n    \n    vec2 prev = g;\n    vec2 next;\n\n    col = drawRing(0.01, 0.003, p, p1, col, magikCol*1.5);\n    \n    for(float i = 0.; i < numSegments; i++){\n    \n        t += dt;\n        //basic linear interpolation form\n        d1 = p1*t + (1.0-t)*p2;\n        d2 = p2*t + (1.0-t)*p3;\n        d3 = p3*t + (1.0-t)*p4;\n    \n        m1 = d1*t + (1.0-t)*d2;\n        m2 = d2*t + (1.0-t)*d3;\n    \n        g = m1*t + (1.0-t)*m2;\n        \n        //or \n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n    \n        next = g;\n        \n        col = drawLine(prev,next,p,col,segCol*vec3(t, 0.7, 0.9));\n        col = drawRing(segRingRadius, 0.003, p, next, col, segCircleCol);\n        prev = next;\n    }\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    float x =0.4, y=1.2, z=2.6, w=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+x),cos(iTime/2.+x))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+y),cos(iTime+y))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+z),cos(iTime+z))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+w),cos(iTime/2.+w))/2.;\n    \n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n   \n    \n    vec3 col = bgCol;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n\n    col = drawLine(p1,p2,uv,col,lineCol*0.5);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, magikCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, magikCol);\n    \n    \n    col = drawSegments(uv, p1, p2, p3, p4, col);\n    \n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, dddPoint, col, magik_farber);\n    col = pow(col, vec3(0.75));\n    //vignett from ApoorvalJ https://www.shadertoy.com/view/4lSXDm\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[744, 1072, 1113, 1113, 1315], [1317, 1317, 1404, 1404, 1636], [1638, 1638, 1702, 1773, 1910], [1913, 2033, 2105, 2105, 3514], [3516, 3547, 3619, 3619, 5322], [5323, 5323, 5380, 5430, 7772]], "test": "untested"}
{"id": "fljGRd", "name": "Point to Point", "author": "Yusef28", "description": "Named after [Point to Point ~ Animals as Leaders] \nYou can change the number of points in the define at the top\nIt's faster with less points", "tags": ["wave", "line", "circle", "sine", "curve", "segment", "linesegments"], "likes": 12, "viewed": 167, "published": "Public", "date": "1624518731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define numSegments 23.\n#define showSeg\n#define PI 3.141592653589793238462643\n\n#define bgCol   vec3(60, 47, 47)/255.*0.9\n#define lineCol vec3(130., 144., 121.)/255.\n#define circleCol vec3(237., 227., 185.)/255.*0.6\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat dotLineDist(vec2 A, vec2 B, vec2 p){\n\n    vec2 pa = p - A;\n    vec2 AB = B - A;\n    \n    //clamp = segment!\n    float t = clamp(dot(pa, AB)/dot(AB,AB), 0., 1.);\n    \n    vec2 normal = pa - t*AB;\n    float dist = length(normal);\n   \n    return dist;\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, circleCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col){\n    \n    float dist = dotLineDist(A,B,p);\n    //dist = 1.0-smoothstep(0.001, 0.002, dist);\n    dist = abs(1.0-smoothstep(0., fwidth(dist), dist - 0.0012));\n    return mix(col, lineCol, dist);\n}\n\nvec3 drawGradedLine(vec2 A, vec2 B, vec2 p, vec3 gradient, vec3 col){\n    \n    float dist = dotLineDist(A,B,p);\n    \n    //dist = 1.0-smoothstep(0.001, 0.002, dist);\n    dist = abs(1.0-smoothstep(0., fwidth(dist), dist - 0.0012));\n    return mix(col, gradient, dist);\n}\n\n/*\n\n//loopless version by oneshade using floor to create cells\n//because every point is fixed on the x axis\n//Just need to make it aligned to start and end of screen\n//for any number of segments.\nvec3 drawSegments(vec2 viewDim, vec2 uv) {\n    \n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n\n    float dt = aspect / numSegments;\n    uv.x += fract(0.5 * numSegments) * dt;\n    col = drawLine(vec2(0.0, -0.25), vec2(0.0, 0.25), uv, col);\n\n    float cell = floor(uv.x / dt) * dt;\n    vec2 p1 = vec2(cell, sin(2.25 * PI * cell + iTime) * 0.25);\n    vec2 p2 = vec2(cell + dt, sin(2.25 * PI * (cell + dt) + iTime) * 0.25);\n    col = drawLine(p1, p2, uv, col);\n\n    #ifdef showSeg\n    col = drawRing(0.01, 0.003, uv, p1, col);\n    col = drawRing(0.01, 0.003, uv, p2, col);\n    #endif\n\n    return col;\n}\n*/\n//Original version\n\nvec3 drawSegments(vec2 viewDim, vec2 uv, float r){\n\n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n    float dx;\n\n    float dt;\n    vec2 firstPoint = vec2(r, 0);\n    vec2 lastPoint = vec2(r, 0);\n\n    vec2 tmp;\n    float t = 0.;\n    \n    for(float i = 1.; i <= numSegments; i++){\n        \n        dt = 2.*PI*(i/numSegments)+3.*PI/2.;\n        //t = dt;\n        //dx = (aspect*dt-aspect/2.);\n\n        vec2 newPoint = rot(dt)*firstPoint;\n        \n        col = drawLine(lastPoint, newPoint, uv, col);\n        \n        #ifdef showSeg\n        col = drawRing(0.01, 0.003, uv, newPoint, col);\n        #endif\n        \n        \n        for(float i = 1.; i <= numSegments; i++){\n        \n            dt = 2.*PI*(i/numSegments);//+iTime/16.;\n            tmp = rot(dt)*newPoint;\n            col = drawGradedLine(newPoint, tmp, uv, cos(lineCol+dt*2.+vec3(0,2,4)/4.+iTime*2.)*0.5+0.75, col);\n            }\n        //t += numSegments;\n        lastPoint = newPoint;\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = drawSegments(iResolution.xy, uv, .6);\n   \n    //col = pow(col, vec3(0.75));\n   \n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 234, 234, 286], [288, 288, 330, 330, 544], [546, 546, 619, 619, 853], [855, 855, 903, 903, 1097], [1099, 1099, 1168, 1168, 1368], [1370, 2204, 2254, 2254, 3200], [3203, 3203, 3260, 3260, 3670]], "test": "untested"}
{"id": "fljGzd", "name": "Rainbow Flares", "author": "GrantD", "description": "Slightly Tweaked Shader to get a softer and more even effect of rainbow flares with less noise\n\nAll credit goes to the original author ~> benoitM on Shadertoy \n\nOriginal Shader Source - https://www.shadertoy.com/view/WtjyzR", "tags": ["rainbow"], "likes": 22, "viewed": 373, "published": "Public API", "date": "1624649198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ALL CREDIT GOES TO benoitM ON SHADERTOY - https://www.shadertoy.com/view/WtjyzR\n\n#define NUM_LAYERS 7.\n#define ITER 15\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .1;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(5.,.5,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(1.5,0.75,2.25);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 122, 140, 140, 360], [362, 362, 419, 419, 881]], "test": "untested"}
{"id": "fll3WX", "name": "Fire movement - shader", "author": "sarabase", "description": "Fire shader.  With some parameters to give a more realistic approach.\nFollowed this \"tutorial\": https://greentec.github.io/shadertoy-fire-shader-en/", "tags": ["texture", "shader", "movement", "normalmapping"], "likes": 2, "viewed": 66, "published": "Public", "date": "1623341880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made using https://www.shadertoy.com/view/MdKfDh (minimum changes)\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n    //The output must be between 0.0 and 1.0\n\treturn -1.0 + 2.0*fract(sin(p) * 43758.5453123);\n}\n\nfloat noise( in vec2 p ) { //Simplex noise\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y) * K1 );\n\n    vec2 a = p - i + (i.x+i.y) * K2;\n    vec2 o = step(a.yx,a.xy);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.; //lacunarity: steps in which we increment de frequencies\n        amplitude *= .5; //gain: decreases the amplitude\n    }\n    return value * 0.5 + 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    #define fireMovement \t\tvec2(-0.1, -0.5)\n    #define distortionMovement\tvec2(-0.01, -0.2)\n    #define distortionStrength\t0.1\n    \n    float color = 0.;\n    //Normalize fragment coordinates\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //These variables are used to modify the speed at which the texture moves\n    float strength = floor(uv.x+1.);\n    float t = max(2.,1.25*strength)*iTime*0.75;\n    \n    color += fbm(uv * vec2(1.0, 0.3) + distortionMovement * t);\n    vec2 displacement = clamp((vec2(color) - .5) * distortionStrength, -1., 1.);\n    uv += displacement;\n\n    vec2 uvT = (uv * vec2(1.0, 0.5)) + fireMovement * t * 0.55;\n    float col = pow(fbm(8.0 * uvT), 1.0);\n    \n    float gradient = pow(1.0 - uv.y, 2.0) * 5.;\n    float finalNoise = col * gradient;\n    \n    vec3 colorFinal = finalNoise * vec3(col, col*col*col, col*col*col*col*col*col*col*col);\n    colorFinal = clamp(colorFinal, 0., 1.);\n    fragColor = vec4(colorFinal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 90, 90, 258], [260, 260, 286, 302, 754], [774, 774, 798, 798, 1126], [1129, 1129, 1186, 1186, 2145]], "test": "untested"}
{"id": "fls3Dl", "name": "Trip to London2", "author": "dmzmd", "description": "Simple texture example.", "tags": ["simple", "basic", "tutorial", "texture", "uv"], "likes": 1, "viewed": 30, "published": "Public", "date": "1623111257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 o=uv*sin(uv.x+iTime);\n   \tvec3 tex = texture(iChannel0,vec2(o.x,o.y)).rgb;\n    // Output to screen\n    fragColor = vec4(tex+col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 381]], "test": "untested"}
{"id": "flS3Dy", "name": "Limacon Intersection 2D II", "author": "oneshade", "description": "Even more generalized version of my limacon intersector. Except now its not technically a limacon.\nI've changed my mind about the formulation, anyway I'd rather not reformulate it :D", "tags": ["intersection", "trigonometric", "quartic", "trochoid", "generalized", "limacon", "uglycode"], "likes": 12, "viewed": 86, "published": "Public", "date": "1624574613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Convenience struct\nstruct Hit4 {\n    int nHit;\n    vec2[4] pHit;\n};\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sqLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 toProj = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return dot(toProj, toProj);\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// Parametric equation\nvec2 posLimacon(in float t, in float alpha, in float beta) {\n    float t2 = 2.0 * t;\n    return vec2(cos(t2) + alpha * cos(t),\n                sin(t2) +  beta * sin(t));\n}\n\n// Intersection\nint solveReducedQuartic(in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d -   0.5 * b * c + 0.125 * bb * b;\n    float r = e -  0.25 * b * d +         bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = (ra * ra / 4.5 - rb) * ru + rc;\n\n    float lambda;\n    float sp = sqrt(3.0 / abs(rp)), k = 1.5 * rq * sp / rp;\n    if (rp * rp * rp + 6.75 * rq * rq > 0.0) {\n        if (rp < 0.0) lambda = cosh(acosh(abs(k)) / 3.0) * sign(rq);\n        else lambda = sinh(asinh(k) / 3.0);\n        lambda /= -sp;\n    }\n\n    else lambda = cos(acos(k) / 3.0) / sp;\n    lambda = 2.0 * lambda - ru;\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nHit4 iLimacon(in vec2 ro, in vec2 rd, in float alpha, in float beta) {\n    Hit4 isect = Hit4(0, vec2[4](vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0)));\n\n    vec2 uv = normalize(rd);\n    float y = ro.x * uv.y - ro.y * uv.x; // Rotate ray so its parallel and we can solve for y only\n                                         // instead of a trigonometric system (trig was meant for geometry! not algebra)\n\n    float u = 0.5 * atan(rd.y, rd.x); // Translation in x to reduce\n    float s = length(vec2(beta, alpha) * uv); // Amplitude of cosine (\"s\" for scale)\n    float o = atan(beta * uv.x, alpha * uv.y) + u; // Offset of cosine\n    float sso = s * sin(o);\n\n    float b = sso;\n    float c = 0.25 * s * s - 1.0;\n    float d = -sso - 0.5 * y * s * cos(o);\n    float e = 0.25 * (y * y - sso * sso);\n\n    vec4 roots;\n    isect.nHit = solveReducedQuartic(b, c, d, e, roots);\n    for (int n=0; n < isect.nHit; n++) {\n        float t = acos(roots[n]); // Undo change of variable to cos(x)\n\n        // \"Manually\" select sign because acos() gives abs(cosineRoot)\n        // (asin() is even more irrational, it sometimes gives sineRoot or π-sineRoot)\n        t *= sign(abs(s * cos(t + o) - sin(2.0 * t) - y) - abs(s * cos(t - o) + sin(2.0 * t) - y));\n        t -= u; // Undo change of variable to t+u\n\n        float t2 = 2.0 * t;\n        isect.pHit[n] = vec2(cos(t2) + alpha * cos(t), -sin(t2) - beta * sin(t));\n    }\n\n    return isect;\n}\n\n// Animation\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 getRay(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    float tInv = 1.0 - local;\n    vec2 pos = mid1 * tInv * tInv + 2.0 * b * tInv * local + mid2 * local * local;\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return vec4(pos, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float animTime = 0.5 * iTime;\n    float alpha = 2.5 * sin(animTime);\n    float beta = 2.5 * cos(animTime);\n\n    // Because this is my favorite shape it makes :)\n    float trefoilTransition = 0.5 + 0.5 * sin(0.1 * iTime);\n    alpha = mix(alpha, -1.35, trefoilTransition);\n    beta = mix(beta, 1.35, trefoilTransition);\n\n    vec4 ray = getRay(iTime * 0.25);\n    vec2 ro = ray.xy * 8.0 - 4.0, rd = ray.zw;\n    if (iMouse.z > 0.0) ro = mouse.zw, rd = mouse.xy - mouse.zw;\n\n    // Draw limacon\n    float limacon = 1e20;\n    vec2 prev = posLimacon(-3.14, alpha, beta);\n    float tStep = 0.1;\n    for (float t=tStep - 3.14; t < 3.14 + tStep; t += tStep) {\n        vec2 cur = posLimacon(t, alpha, beta);\n        limacon = min(limacon, sqLine(uv, prev, cur));\n        prev = cur;\n    }\n\n    drawSDF(sqrt(limacon) * 0.5 - 0.015, vec3(0.0, 0.0, 1.0));\n\n    // Draw ray\n    drawSDF(sdInfLine(uv * 0.5, ro * 0.5, (ro + rd) * 0.5) - 0.001, vec3(1.0, 0.8, 0.0));\n    drawSDF(sdVectorArrow((uv - ro) * 0.5, rd * 0.5), vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iLimacon(ro, rd, alpha, beta);\n    for (int n=0; n < hit.nHit; n++) {\n        drawSDF(length(uv - hit.pHit[n]) - 0.1, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 182, 236, 236, 512], [514, 514, 561, 561, 700], [702, 702, 747, 747, 815], [817, 817, 867, 867, 936], [938, 938, 981, 981, 1169], [1171, 1194, 1254, 1254, 1365], [1367, 1383, 1474, 1666, 3239], [3241, 3241, 3311, 3311, 4666], [4668, 4681, 4706, 4706, 4835], [4837, 4837, 4862, 4862, 5260], [5262, 5262, 5317, 5317, 6839]], "test": "untested"}
{"id": "flS3R3", "name": "Square Drawing Test", "author": "UwULydia", "description": "Just figuring out how to draw shapes haha.", "tags": ["beginner", "squares"], "likes": 4, "viewed": 72, "published": "Public", "date": "1624374767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Rectangle drawing method\n// Author: Lydia \nfloat rect(in vec2 uv, in vec2 pos, in vec2 size) {\n    // bottom-left\n    vec2 bl = step(pos, uv) * step(pos, uv);\n    float rect = bl.x * bl.y;\n\n    // top-right\n    vec2 tr = step(uv, pos + size) * step(uv, pos + size);\n    rect *= tr.x * tr.y;\n    \n    return rect;\n}\n\n// Make Square\n// Author: Lydia \n// Adjust coordinates to compensate for 16:9\nvec2 mksq(in vec2 co) {\n    return vec2(co.x * (iResolution.y / iResolution.x), co.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Draw squares\n    float sp = float(0.9);\n    vec2 amp = mksq(vec2(0.3));\n    vec2 size = mksq(vec2(0.3));\n    vec2 cen = vec2(0.5) - (size / 2.0);\n    \n    vec2 pos = vec2(cen.x + amp.x * sin(iTime * sp), cen.y + amp.y * cos(iTime * sp)); \n    float mvsqs = rect(uv, pos, size);\n    \n    pos = vec2(cen.x + amp.x * sin((iTime * sp) + PI), cen.y + amp.y * cos((iTime * sp) + PI)); \n    mvsqs += rect(uv, pos, size);\n    \n    pos = vec2(cen.x + amp.x * sin((-iTime * sp) + (PI / 2.0)), cen.y + amp.y * cos((-iTime * sp) + (PI / 2.0))); \n    mvsqs += rect(uv, pos, size);\n    \n    pos = vec2(cen.x + amp.x * sin((-iTime * sp) - (PI / 2.0)), cen.y + amp.y * cos((-iTime * sp ) - (PI / 2.0))); \n    mvsqs += rect(uv, pos, size);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0.0, 2.0, 4.0));\n    col = mix(vec3(0.0), col, mvsqs); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 72, 123, 142, 343], [345, 423, 446, 446, 511], [513, 513, 569, 619, 1590]], "test": "untested"}
{"id": "fls3WB", "name": "Rainbow Sinus", "author": "trashy", "description": "A 2D sinus rainbow", "tags": ["rainbow", "step"], "likes": 3, "viewed": 59, "published": "Public", "date": "1622748810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n//RGB: 1/255\n#define RGB 0.0039\n\nfloat sharpRainbow(float y, vec2 st, float offset, float width) {\n    float edge = y-(offset*width);\n    return step(edge-width, st.y) - step(edge, st.y);\n}\n  \n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    float width = (1.0/20.0);\n    float y = 0.5 + (8.0*width/2.0) + sin(iTime+st.x*PI)*sin(iTime*1.5)*0.25;\n\n    //original 1978 colors\n    //TIL the original 1978 pride flag actually had 8 colors, until hot pink was dropped due to fabric shortage!\n    //https://en.wikipedia.org/wiki/Rainbow_flag_(LGBT)\n    vec3 pink   = vec3(255.0*RGB, 105.0*RGB, 180.0*RGB);\n    vec3 red    = vec3(255.0*RGB, 000.0*RGB, 000.0*RGB);\n    vec3 orange = vec3(255.0*RGB, 142.0*RGB, 000.0*RGB);\n    vec3 yellow = vec3(255.0*RGB, 255.0*RGB, 000.0*RGB);\n    vec3 green  = vec3(000.0*RGB, 142.0*RGB, 000.0*RGB);\n    vec3 turq   = vec3(000.0*RGB, 192.0*RGB, 192.0*RGB);\n    vec3 indigo = vec3(064.0*RGB, 000.0*RGB, 152.0*RGB);\n    vec3 violet = vec3(142.0*RGB, 000.0*RGB, 142.0*RGB);\n\n    vec3 color = mix(pink, indigo, (1.0 + sin(iTime))/2.0);\n    color = mix(color, pink,    sharpRainbow(y, st, 0.0, width));\n    color = mix(color, red,     sharpRainbow(y, st, 1.0, width));\n    color = mix(color, orange,  sharpRainbow(y, st, 2.0, width));\n    color = mix(color, yellow,  sharpRainbow(y, st, 3.0, width));\n    color = mix(color, green,   sharpRainbow(y, st, 4.0, width));\n    color = mix(color, turq,    sharpRainbow(y, st, 5.0, width));\n    color = mix(color, indigo,  sharpRainbow(y, st, 6.0, width));\n    color = mix(color, violet,  sharpRainbow(y, st, 7.0, width));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 58, 123, 123, 214], [220, 220, 277, 327, 1778]], "test": "untested"}
{"id": "flS3zt", "name": "Github like planet", "author": "z0rg", "description": "I love the planet that appears on the github's front page so I decided to do mine :).\nWill proabably make it as a Windows terminal background at some point.", "tags": ["planet", "github"], "likes": 11, "viewed": 260, "published": "Public API", "date": "1624731090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n    \n    \n    return vec2(_sph(p, 1.), 0.);\n}\n\nvec3 accLight;\n\nvec3 lPos = vec3(5.,-5.,5.);\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.0001)\n            return vec3(res.x, distance(p, ro), res.y);\n        vec3 h = normalize(rd+(lPos-p));\n        accLight += vec3(1.)*(1.-sat(res.x/.5))*.1*sat(sat(dot(normalize(p),h))+.3);//*sat(dot(normalize(p), rd));\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    \n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    accLight = vec3(0.);\n    vec3 col = vec3(0.078,0.063,0.137);\n    \n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(.3))-.1)*3.));\n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(-.3,.3))-.1)*3.));\n    col = mix(col, vec3(0.408,0.216,0.565), 1.-sat((length(uv-vec2(.3,-.3))-.1)*3.));\n    col += sat(length(uv*.75))*sat(pow(texture(iChannel1, uv*4.).x,20.)*5.*2500./iResolution.x)*texture(iChannel1, uv*5.+vec2(iTime*.25, 0.)).x;\n   \n    float rad = 5.;\n    float t = 1.5+0.*iTime*.25;\n    vec3 ro = vec3(sin(t)*rad,-3.,cos(t)*rad);\n    vec3 ta = vec3(0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float depth = -1.0f;\n    // Might be good to use raytracing here, may be way lighter\n    vec3 res = trace(ro, rd, 50);\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        //col = n*.5+.5;\n        // If you look carefully and move the camera you'll notice \n        // that I don't account for seamless transition as originally \n        // I used a custom texture that does it pretty well\n        // You know shadertoy custom texture...\n        vec2 coords = vec2(atan(p.x, p.z)+iTime*.25, acos(p.y))*vec2(1./(PI*2.),1./(PI))-vec2(0.,PI);\n        \n       // float earth = 1.-texture(iChannel0, coords)-).x;\n        vec2 deform = vec2(1., 2.);\n        vec2 rep = deform*.003;\n        vec2 id = floor((coords+rep*.5)/rep);\n\n        vec2 mapcoord = mod(coords+rep*.5,rep)-rep*.5;\n        \n        float earth2 = 1.-texture(iChannel0, id*rep*.5).x;\n        earth2 = sat(pow(earth2, 10.)*10.);\n        vec3 h = normalize(rd+(lPos-p));\n        float NdH =dot(n,h);\n        vec3 rgb = vec3(0.239,0.216,0.565)*sat(sat(NdH)+.2);\n        \n        col = rgb;\n        if (earth2 > 0.01)\n        col = mix(rgb, vec3(0.843,0.643,0.918), 1.-sat(_cir(mapcoord/deform,sat(earth2)*.0005)*4000.));\n        \n        col += 2.*vec3(0.239,0.216,0.565)*(1.-sat(-dot(rd, n)*1.5))*sat(sat(NdH*1.)+.25);\n        col += vec3(0.408,0.216,0.565)*(1.-sat(-dot(rd, n)*3.5));\n    }\n    else\n        col += mix(vec3(0.239,0.216,0.565)*.1, vec3(0.408,0.216,0.565), 1.)*accLight;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*3.);\n    if (true) // Not so cheap antialiasing\n    {\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3zt.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 451, 480, 480, 506], [508, 508, 537, 537, 563], [564, 564, 582, 582, 662], [710, 710, 751, 751, 1129], [1131, 1131, 1162, 1162, 1298], [1300, 1300, 1331, 1331, 1448], [1450, 1450, 1469, 1469, 3673], [3675, 3675, 3732, 3732, 4139]], "test": "untested"}
{"id": "flSGDd", "name": "Glowing Star 🌟", "author": "inspirnathan", "description": "Glowing star 🌟. Check out my tutorial on glow to learn more: [url]https://inspirnathan.com/posts/65-glow-shader-in-shadertoy[/url]", "tags": ["star", "glow", "inspirnathan"], "likes": 2, "viewed": 139, "published": "Public", "date": "1624941419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Check out my tutorial to learn more: https://inspirnathan.com/posts/65-glow-shader-in-shadertoy\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nfloat sdStar5(vec2 p, float r, float rf)\n// Credit: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // x: <0, 1>, y: <0, 1>\n  uv -= 0.5; // x: <-0.5, 0.5>, y: <-0.5, 0.5>\n  uv.x *= iResolution.x/iResolution.y; // x: <-0.5, 0.5> * aspect ratio, y: <-0.5, 0.5>\n\n  float d = sdStar5(rotate(uv, iTime), 0.12, 0.45); // signed distance function\n\n  vec3 col = vec3(step(0., -d));\n  \n  col += clamp(vec3(0.001/d), 0., 1.) * 12.; // add glow\n\n  col *= vec3(1, 1, 0);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 132, 132, 191], [193, 193, 322, 322, 681], [683, 683, 740, 740, 1169]], "test": "untested"}
{"id": "flSGDK", "name": "Procedural 3D Voronoi noise", "author": "Zyphery", "description": "A procedural generation of Voronoi noise.\n\neval generates 2 values\nx: distance of uv to point (without the square root)\ny: hash value of closest point (the z calculated in rehash3())\n\nthe y can be used in rehash3() to generate a random color", "tags": ["voronoi", "proceduralnoise"], "likes": 6, "viewed": 223, "published": "Public API", "date": "1624679763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float x) { return fract(x + 1.3215f * 1.8152f); }\n\nfloat hash3(vec3 a) { return fract((hash(a.z * 42.8883f) + hash(a.y * 36.9125f) + hash(a.x * 65.4321f)) * 291.1257f); }\n\nvec3 rehash3(float x) { return vec3(hash(((x + 0.5283f) * 59.3829f) * 274.3487f), hash(((x + 0.8192f) * 83.6621f) * 345.3871f), hash(((x + 0.2157f) * 36.6521f) * 458.3971f)); }\n\nfloat sqr(float x) {return x*x;}\nfloat fastdist(vec3 a, vec3 b) { return sqr(b.x - a.x) + sqr(b.y - a.y) + sqr(b.z - a.z); }\n\nvec2 eval(float x, float y, float z) {\n    vec4 p[27];\n    for (int _x = -1; _x < 2; _x++) for (int _y = -1; _y < 2; _y++) for(int _z = -1; _z < 2; _z++) {\n        vec3 _p = vec3(floor(x), floor(y), floor(z)) + vec3(_x, _y, _z);\n        float h = hash3(_p);\n        p[(_x + 1) + ((_y + 1) * 3) + ((_z + 1) * 3 * 3)] = vec4((rehash3(h) + _p).xyz, h);\n    }\n    float m = 9999.9999f, w = 0.0f;\n    for (int i = 0; i < 27; i++) {\n        float d = fastdist(vec3(x, y, z), p[i].xyz);\n        if(d < m) { m = d; w = p[i].w; }\n    }\n    return vec2(m, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y * 5.0f;\n    \n    vec2 n = eval(uv.x, uv.y, iTime);\n    vec3 col = (1.0 - sqrt(n.x)) * rehash3(n.y);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [62, 62, 83, 83, 181], [183, 183, 206, 206, 359], [361, 361, 381, 381, 393], [394, 394, 426, 426, 485], [487, 487, 525, 525, 1038], [1040, 1040, 1097, 1097, 1271]], "test": "untested"}
{"id": "flSGDW", "name": "polar rave 2.2", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 3, "viewed": 164, "published": "Public API", "date": "1623868105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"polar rave 2\" by firebreathz. https://shadertoy.com/view/slj3zw\n// 2021-06-16 18:27:30\n\n// Fork of \"polar rave\" by firebreathz. https://shadertoy.com/view/7l2Gzw\n// 2021-06-13 21:22:36\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 21:01:10\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 5.0*uv-2.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.5;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 9.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band/band*band; \n    \n    band = band*0.03;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,-10.000) ).x;  \n    \n    if(band<0.0||band>=10.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(0.608,0.000,0.608);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-0)/n)*n);\n    }\n    \n    float h = PI*0.4;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.1,0.75,f);\n    col *= smoothstep(1.875,0.025,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(3.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.x));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.y));\n\n    ref /= -8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(10.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.2)*smoothstep(1.0,0.0,length(p*2.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(6.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(0.10-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 403, 426, 426, 507], [509, 509, 551, 551, 610], [612, 612, 637, 637, 2180], [2182, 2182, 2239, 2239, 3496]], "test": "untested"}
{"id": "flSGDy", "name": "Ball of Saturation 2", "author": "egon", "description": "Color-wheel using hsv for the ball and outer circle.", "tags": ["colorwheel"], "likes": 0, "viewed": 38, "published": "Public", "date": "1624568546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (2.0*3.1415926538)\n\nvec2 rot(vec2 pos, float a) {\n\tfloat sn = sin(a);\n\tfloat cs = cos(a);\n\treturn mat2(cs, -sn, sn, cs) * pos;\n}\n\nfloat map(float p, float ss, float se, float ds, float de)\n{\n    return ds + (p-ss)*(de-ds)/(se-ss);\n}\n\nfloat shade(vec2 pos, float dir) {\n    pos = rot(pos, dir);\n    float h = cos(pos.x);\n    return map(pos.y, h, -h, 0.0, 1.0);\n}\n\n//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsv2rgb_subtractive( in vec3 c ) {\n    float frac = fract(c.x)*6.0;\n    vec3 col = smoothstep(vec3(3,0,3),vec3(2,2,4),vec3(frac));\n    col += smoothstep(vec3(4,3,4),vec3(6,4,6),vec3(frac)) * vec3(1, -1, -1);\n    return mix(vec3(1), col, c.y) * c.z;\n}\n\n\n// CIELab to rgb conversion from https://www.shadertoy.com/view/llcXDN\n\nfloat ref_X = 95.047;\nfloat ref_Y = 100.000;\nfloat ref_Z = 108.883;\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float inside  = 0.3 * iResolution.y;\n    float mid     = 0.35 * iResolution.y;\n    float outside = 0.45 * iResolution.y;\n    \n    vec2 off = center - uv;\n\n    float h = mod(iTime*0.1, 1.0);\n    if(iMouse.z > 0.0){\n        vec2 p = normalize(center - iMouse.xy);\n        h = atan(-p.y, -p.x) / TAU;\n    }\n\n    float d = length(off);\n    if(d < inside){\n        off /= inside;\n\n        float v = shade(off, 0.0/3.0 * TAU);\n        float s = shade(off, -1.0/4.0 * TAU);\n\n        fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n    } else if (mid < d && d < outside) {\n        off = normalize(off);\n        float h = atan(-off.y, -off.x) / TAU;\n        fragColor = vec4(hsv2rgb_subtractive(vec3(h, 0.85, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.13, 0.15, 1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 61, 61, 140], [142, 142, 202, 202, 244], [246, 246, 280, 280, 373], [375, 471, 493, 493, 824], [826, 826, 848, 848, 1017], [1020, 1020, 1059, 1059, 1275], [1278, 1419, 1443, 1443, 2115], [2117, 2117, 2144, 2144, 2753], [2755, 2755, 2782, 2782, 2821], [2823, 2823, 2880, 2880, 3736]], "test": "untested"}
{"id": "flSGRw", "name": "Colors Colors Colors", "author": "Fireblaster21", "description": "This is my first shader. I just used the script that was already in the code. Anyway, hope you enjoy.", "tags": ["color", "boring"], "likes": 0, "viewed": 28, "published": "Public", "date": "1623497233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //play iChannel0\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 320]], "test": "untested"}
{"id": "flsGzX", "name": "spatial judo", "author": "Shellderr", "description": "use mouse to maneuver", "tags": ["fractal", "space"], "likes": 0, "viewed": 39, "published": "Public", "date": "1622539208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define ft float\n\nft hm(vec2 uv, vec2 m){\n    ft a = dot(uv,uv);\n    ft b = (sin(iTime+uv.x/a/m.x))-cos(uv.y/a/m.y);\nreturn abs(b*10.4)-a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 10.*(2.*fragCoord.xy-res.xy)/res.y;\n    vec2 m = vec2(.9);\n    vec2 mouse = iMouse.y < 1.? vec2(.5,.05): iMouse.xy/res.xy;\n    ft a = hm(uv, m);\n    for(ft i; i < 2.; i++){\n    uv = abs(uv/hm(uv,m+i*.2)-.4*mouse);\n    }\n    fragColor = vec4(1.-1./uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 164], [166, 166, 222, 222, 498]], "test": "untested"}
{"id": "flX3D2", "name": "babysteps round2 BetterCircle", "author": "stephenhalker", "description": "Yay, Art of Code! I fixed the mouth issue with a clamp()!!!! \nYup. i'm a professional now!", "tags": ["beginner"], "likes": 0, "viewed": 26, "published": "Public", "date": "1622833331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n  float d = length(uv-p);\n  float c = smoothstep(r, r-blur, d);\n   \n   return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    uv-= .5;\n   uv.x *= iResolution.x/iResolution.y;\n    \n    float c = Circle(uv,vec2(0.0,0.0),0.45,0.1);\n    \n    c+= Circle(uv, vec2(-0.15,0.1), 0.2 , 0.2);\n    c+= Circle(uv, vec2(0.15,0.1), 0.2 , 0.2);   \n    c-= Circle(uv,vec2(-0.15,0.1), 0.1 , 0.1)*2.0;\n    c-= Circle(uv, vec2(0.15,0.1), 0.1 , 0.1)*2.0;\n    \n    float mouth = Circle(uv, vec2(0.0,0.020), 0.35,0.1);\n    mouth -= Circle(uv, vec2(0.0,0.25),0.45,0.1);//topMouth\n    mouth =clamp(mouth,0.0,1.0);\n   \n   c-= mouth;\n    \n    fragColor = vec4(vec3(c*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 134], [136, 136, 193, 193, 878]], "test": "untested"}
{"id": "flX3Ds", "name": "Ray Marching - Shadows", "author": "ChaosOfZen", "description": "A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/", "tags": ["raymarching", "sphere", "color"], "likes": 2, "viewed": 27, "published": "Public", "date": "1623077121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n// The Art of Code: The Art Of Code Youtube\n// Inigo Quilez: http://www.iquilezles.org\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n \nfloat GetDist(vec3 p) \n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasn’t hit an object it also breaks out of the loop.\n*/ \n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\n/*\n\nNormals\nTo get the normals the point where the raymarch hits is used and a small amount (Epsilon) \nis added to the point in the right, up and forward direction. This new offset point is \nthen normalized to turn it into a unit vector/direction.\n*/\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n    vec3 n = d - vec3(\n    GetDist(p-e.xyy),  \n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n   \n    return normalize(n);\n}\n\n/*\nLight (directional diffuse)\nTo calculate diffuse light, the angle between the surface normal and the light vector \nfrom a raymarched point is used. To get the angle, the Dot product is used which returns \nthe angle in a -1 <> 1 range. So when the light vector is perpendicular to the normal \nvector the Dot product is 1 and if its parralel to the normal vector it is 0.\n\nShadows\nTo check if a point is in the shade, we raymarch from that point into the direction of the \nlight and if the dist we get out of it is smaller than the distance to the light than we \nknow we hit something in between the light and that point. The line below almost works \nbut because the point were raymarching from is already closer to the surface than what \nwe allow it to be in the ray march loop, it kicks out of the marching loop immediately…:\n\nfloat d = RayMarch(p,l);\n\nBy moving the point away from the surface a little bit (in the direction of the normal) \nwe can make sure they raymarch loop starts normally!:\n\nfloat d = RayMarch(p+nSURF_DIST2., l);\n\n*/\n\nfloat GetLight(vec3 p)\n{ \n    // Light (directional diffuse)\n    vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n \n     // Shadows\n    float d = RayMarch(p+n*SURFACE_DIST*2., l); \n     \n    if(d<length(lightPos-p)) dif *= .1;\n \n    return dif;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n   \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n    d *= .2;\n    vec3 color = vec3(0);\n    color = vec3(dif);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 301, 325, 325, 540], [543, 932, 967, 967, 1223], [1225, 1477, 1501, 1501, 1700], [1702, 2748, 2772, 2808, 3222], [3226, 3226, 3283, 3283, 3711]], "test": "untested"}
{"id": "flX3Wn", "name": "Circular Waves - 2d SDF", "author": "eurigilberto", "description": "Just a little test to see how to make a 2d sdf look like a 3d object by creating a 3d normal from the 2d sdf and applying a simple diffuse plus ambient lighting to it.", "tags": ["2d", "sdf"], "likes": 1, "viewed": 47, "published": "Public", "date": "1622587279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define xCenter (iResolution.x/iResolution.y)/2.\n#define yCenter (iResolution.y/iResolution.y)/2.\n\nfloat easeInOutCirc(float x) {\n    return x < 0.5\n      ? (1. - sqrt(1. - pow(2. * x, 2.))) / 2.\n      : (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nfloat easeOutBack(float x){\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}\n\nfloat easeInOutBack(float x){\n    float c1 = 5.;//prev 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat easeInBack(float x) {\n    float c1 = 1.70158;\n    float c3 = c1 + 1.;\n\n    return c3 * x * x * x - c1 * x * x;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}//from https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.htm\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}//from https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.htm\n    \nfloat distortion(vec2 p, float mult, vec2 timeMult, float yMult){\n    return sin(mult * p.x + sin(iTime * timeMult.x + p.y * yMult)) + cos(mult * p.y + iTime * timeMult.y);\n}\n\nfloat InvLerp( float a, float b, float v){\n    return (v - a)/(b - a);\n}\n\nfloat circle_sdf(vec2 p, vec2 center, float rad){\n    float dist = length(p - center) - rad;\n    return dist;\n}\n\nfloat fluid_sdf(vec2 p){\n    float d = distortion(p, 20., vec2(5., 10.), 10.) * 0.01;\n    \n    float circle1 = circle_sdf(p, vec2(xCenter,yCenter), 0.25) + d;\n    \n    \n    float duration = 3.;\n    float dropAnimTime = mod(iTime, duration)/duration;\n    //dropAnimTime = easeInOutBack(dropAnimTime);\n    \n    float yPosChange;\n    float sizeChange;\n    float dMultiplier;\n    \n    //dropAnimTime = 1.2;\n    \n    if(dropAnimTime < 0.5){\n        float animT = dropAnimTime/0.5;\n        animT = easeInOutBack(animT);\n        \n        yPosChange = mix(yCenter * 0.4, yCenter, animT);\n        sizeChange = abs(mix(0.1, 0.15, animT));\n        dMultiplier = animT;\n    }else{\n        float animT = (dropAnimTime - 0.5)/0.5;\n        animT = easeInOutBack(animT);\n        \n        yPosChange = mix(yCenter, yCenter * 0.4, animT);\n        sizeChange = abs(mix(0.15, 0.1, animT));\n        dMultiplier = 1.-animT;\n    }\n    \n    float dropDistortion = distortion(p, 20., vec2(20., 2.), 2.);\n    \n    float circle2 = circle_sdf(p, vec2(xCenter,yPosChange), sizeChange) + d;\n    \n    return sminCubic(circle1, circle2, mix(0.2, 0.6, dMultiplier));\n}\n\nfloat sMinFluidSDF(vec2 p){\n    return fluid_sdf(p);// sminCubic(fluid_sdf(p), -0.07, 0.002);\n}\n\nvec3 fluidNormal(vec2 p, float minVal){\n    float epsilon = 0.05;\n\n    vec2 right = vec2(epsilon, 0);\n    vec2 up = vec2(0, epsilon);\n    \n    float center = sMinFluidSDF(p); \n    float north = sMinFluidSDF(p + up);\n    float south = sMinFluidSDF(p - up);\n    float east = sMinFluidSDF(p + right);\n    float west = sMinFluidSDF(p - right);\n    \n    float xAxis = (east - center) - (west - center);\n    float yAxis = (north - center) - (south - center);\n    \n    return normalize(vec3(xAxis, yAxis, sMinFluidSDF(p) * 1.0));\n}\n\nvec3 directionalLight(vec3 lightDir, vec3 lightColor, vec3 normal, float bands){\n    float light = dot(normal, lightDir);\n    light = InvLerp(-0.4, 1., light);\n    light = bands == 0. ? light : round(light * bands)/bands;\n    \n    return lightColor * clamp(light, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float circle = fluid_sdf(uv);\n    float step_circle = step(0., circle);\n    \n    if(step_circle < 0.5){\n        vec3 normal = fluidNormal(uv, -0.1);\n        \n        float bands = 0.;\n        \n        vec3 lightDir1 = normalize(vec3(1,1,0));\n        vec3 light1 = directionalLight(lightDir1, vec3(1,1,1), normal, bands);\n        \n        //vec3 lightDir2 = normalize(vec3(0,-1,0));\n        //vec3 light2 = directionalLight(lightDir2, vec3(0.1,0.6,0.9), normal, bands);\n        \n        vec3 light2 = vec3(0.1,0.1,1.) * 0.4;\n        \n        vec3 color = vec3(0.1,1,0.5) * ((light1 + light2));\n        //vec3 color = vec3(0.1,1,0.5) * light1;\n        \n        //fragColor = vec4(sin(circle * 100.));\n        //fragColor = vec4(rawX*100.,rawY*100.,-circle * 2., 1);\n        fragColor = vec4(color.xyz,1);\n    }else{\n        fragColor = vec4(0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 129, 129, 251], [253, 253, 280, 280, 392], [394, 394, 423, 423, 642], [644, 644, 671, 671, 762], [764, 764, 816, 816, 915], [915, 1002, 1048, 1048, 1134], [1134, 1225, 1290, 1290, 1399], [1401, 1401, 1443, 1443, 1473], [1475, 1475, 1524, 1524, 1586], [1588, 1588, 1612, 1612, 2723], [2725, 2725, 2752, 2752, 2820], [2822, 2822, 2861, 2861, 3346], [3348, 3348, 3428, 3428, 3622], [3624, 3624, 3681, 3731, 4630]], "test": "untested"}
{"id": "flX3WS", "name": "Worley Noise 2D __", "author": "Envy24", "description": "noise, random, worley, cellular", "tags": ["noise", "random", "worley", "cellular"], "likes": 2, "viewed": 45, "published": "Public", "date": "1622682809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample2DHashUI32(uint x, uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * enthropy2 + x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat WorleyNoise2D(float u, float v)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float y = -1.0f; y < 2.0f; y += 1.0f)\n    {\n        for (float x = -1.0f; x < 2.0f; x += 1.0f)\n        {\n            // Pseudorandom sample coordinates in corresponding cell.\n            float xSample = x + sample2DHashUI32(uint(u + x), uint(v + y));\n            float ySample = y + sample2DHashUI32(uint(u + x), uint(v + y));\n\n            // Distance from pixel to pseudorandom sample.\n            //float _distance = \n                //sqrt(\n                    //(fractU - xSample) * (fractU - xSample) +\n                    //(fractV - ySample) * (fractV - ySample));\n                    \n            float _distance = \n                    (fractU - xSample) * (fractU - xSample) +\n                    (fractV - ySample) * (fractV - ySample);\n\n            // Mistance from pixel to pseudorandom sample.\n            minDistance = min(minDistance, _distance);\n        }\n    }\n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;\n    \n    if (fragCoord.x < iResolution.x * 0.5) { uv = fragCoord/iResolution.xy * 6.0f; }\n    else { uv = fragCoord/iResolution.xy * 18.0f; }\n\n    float _u = uv.x + iMouse.x * 0.1f + iTime * 0.1f;\n    float _v = uv.y + iMouse.y * 0.1f + iTime * 0.2f;\n\n    float gray = WorleyNoise2D(_u, _v) * 0.5f;\n    gray += WorleyNoise2D(_u * 2.054f, _v * 2.210f) * 0.25f;\n    gray += WorleyNoise2D(_u * 4.554f, _v * 4.710f) * 0.125f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 84, 154, 541], [543, 543, 582, 604, 1713], [1715, 1715, 1772, 1822, 2322]], "test": "untested"}
{"id": "flXGW2", "name": "Gooey Goo", "author": "trashy", "description": "Based on https://thebookofshaders.com/11/\n\nThis shader simply mixes two 2d noises", "tags": ["noise", "goo"], "likes": 3, "viewed": 39, "published": "Public", "date": "1622820628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n            vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    vec2 stc = st - vec2(0.5);\n\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(stc*vec2(\n        map(sin(iTime/2.0), -1.0, 1.0, 8.0, 12.0), \n        map(cos(iTime/2.0), -1.0, 1.0, 4.0, 8.0)\n    ) + vec2(0.0, -iTime));\n\n    // Use the noise function\n    float n = noise(pos);\n\n    //ALLES KLAR WIR SPIELEN DEN SELBEN SONG NOCH MAL!!1\n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos2 = vec2(stc*vec2(\n        map(sin(iTime/3.0), -1.0, 1.0, 12.0, 18.0), \n        map(cos(iTime/3.0), -1.0, 1.0, 4.0, 8.0)\n    ) + vec2(0.0, -iTime/4.0));\n\n    // Use the noise function\n    n += noise(pos2) * map(sin(iTime/4.0), -1.0, 1.0, 0.1, 0.9);\n    //n = mix(n, noise(pos2), map(sin(u_time/4.0), -1.0, 1.0, 0.0, 1.0));\n\n    //n = smoothstep(0.2, 0.2 + abs(sin(u_time/4.0)*0.6), n);\n    //float squeeze = map(sin(iTime), -1.0, 1.0, 0.0001, 0.05);\n    float squeeze = map(smoothstep(0.0, 1.0, st.y), 0.0, 1.0, 0.0001, 0.1);\n    n = smoothstep(0.5-squeeze, 0.5+squeeze, n);\n\n    float g = n*1.4;\n    float b = n*1.1;\n\n    fragColor = vec4(vec3(n, g, b), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 40, 40, 143], [145, 232, 258, 258, 775], [777, 846, 918, 918, 986], [988, 988, 1043, 1093, 2255]], "test": "untested"}
{"id": "ft23Rw", "name": "Phong Shading Model w/ RayMarch", "author": "muio", "description": "A bare-bones implementation of phong shadeing model using ray-marching and SDFs.", "tags": ["raymarching", "phong", "sdf"], "likes": 2, "viewed": 82, "published": "Public API", "date": "1623584693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Possible things one could add to this:\n/// * Rays should attenuate the further away they get from the camera.\n/// * \n\n// Colors should be in standard rgb format: 0. < rgb < 1.\n\n#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\nstruct PhongMaterial {\n    vec3 albedo;\n    float ks, kd, ka, alpha;\n};\n\nstruct PointLight {\n    vec3 pos;\n    vec3 col;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst PointLight light = PointLight(vec3(0, 5, 6),\n                                    vec3(1.000,0.878,0.878));\nconst PhongMaterial sphereMaterial = PhongMaterial(vec3(0.94,1.,0.12), \n                                                   .3, .64, .3, 16.);\nconst PhongMaterial globalMaterial = PhongMaterial(vec3(.4, .9, 1.), \n                                                   .1, .7, .2, 4.);\nconst PhongMaterial mats[2] = PhongMaterial[](globalMaterial, \n                                              sphereMaterial);\n                                                   \nconst vec3 rayOrigin = vec3(0, 1, 1);\n\n\n\nfloat SphereSDF(in vec3 p, in Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat SceneSDF(out int hitObject, in vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    hitObject = sphereDist == d ? 1 : 0;\n    return d;\n}\n\nfloat RayMarch(out int hitObject, in vec3 ro, in vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = SceneSDF(hitObject, p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\n/*\nvec3 GetNormalEulerTwoSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    \n    vec3 left = vec3(SceneSDF(_, p),\n                     SceneSDF(_, p - e.yxy),\n                     SceneSDF(_, p - e.yyx)),\n        right = vec3(SceneSDF(_, p + e.xyy),\n                     SceneSDF(_, p + e.yxy),\n                     SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n*/\n\nvec3 GetNormalEulerOneSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    vec3 center = vec3(SceneSDF(_, p)),\n          right = vec3(SceneSDF(_, p + e.xyy),\n                       SceneSDF(_, p + e.yxy),\n                       SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(right - center);\n    return n;\n}\n\n#define GetNormal GetNormalEulerOneSided\n//#define GetNormal GetNormalEulerTwoSided\n\n\n/*\n  p  -> position of point to shade\n  ro -> ray origin (position of the camera)\n*/\nvec3 PhongIllumination(in vec3 p, in vec3 ro, in int hitObject) {\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = light.pos + lightPosOffset;\n    // PhongMaterial mat = (hitObject == 1) ? sphereMaterial : globalMaterial; // bugs are great!\n    \n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    vec3 r = reflect(l, n);\n    vec3 v = normalize(p - ro);\n    \n    float dif  = clamp(dot(l, n), 0., 1.);\n    float spec = clamp(dot(v, r), 0., 1.);\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    int _;\n    float d = RayMarch(_, p + pOffset, l);\n    if (d < length(lightPos - p)) { // If true then we've shaded a point on some object before, \n                                    // so shade the currnet point as shodow.\n        dif *= .3; // no half-shadow because the light source is a point.    \n        spec = 0.; // shadows don't have specular component, I think.\n    }\n    \n    // Acutal Phong stuff\n    vec3 ambientDiffuse = light.col * mats[hitObject].albedo;\n    vec3 light1DiffuseComponent = dif * light.col;\n    vec3 light1SpecularComponent = vec3(pow(spec, mats[hitObject].alpha));\n    \n    vec3 col = mats[hitObject].ka * ambientDiffuse + \n               mats[hitObject].kd * light1DiffuseComponent + \n               mats[hitObject].ks * light1SpecularComponent;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = rayOrigin;\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    // RayMarching stuff\n    int object;\n    float d = RayMarch(object, ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 col = PhongIllumination(p, ro, object);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 1129, 1170, 1170, 1206], [1208, 1208, 1254, 1276, 1457], [1459, 1459, 1518, 1518, 1906], [1908, 2392, 2432, 2481, 2782], [2870, 2955, 3020, 3020, 4406], [4409, 4409, 4466, 4466, 4854]], "test": "untested"}
{"id": "ft23Ry", "name": "Line Distance Heron's Formula", "author": "Yusef28", "description": "https://www.cuemath.com/herons-formula/\nThe line extends to infinitely beyond the line points so it's not a \"segment\".", "tags": ["2d", "triangle", "line", "area", "semi"], "likes": 2, "viewed": 66, "published": "Public", "date": "1624146230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Update 29-05-2021: 1 sqrt Heron's version from IQ added\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)*0.95;\n#define COL0 vec3(236./255., 200./255., 146./255.)*0.7\n#define COL1 vec3(30./255.,132./255.,127./255.)*1.3\n#define COL3 vec3(1.)\n\n\n//based on one by 4rknova: https://www.shadertoy.com/view/Ml23Dt\nfloat circleUnfilled(float r, vec2 p){\n\n    float eps = 1./min(iResolution.x, iResolution.y);\n    float in_out_cut = 0.01;\n    return smoothstep(-eps, +eps, abs(r - length(p))-in_out_cut );\n    }\n\n\nfloat DistToLine(vec2 p, vec2 start, vec2 ende){\n    //area of a triangle is half the base X the height\n    //we know this because if we take a square and cut it in\n    //half on the diagonal we get half two triangles we can\n    //then place side by side. This gives us a triangle\n    //with a base = 2 X the length of one side of the square\n    //this works for any triangle\n    \n    //here base is the distance between two points on the line in question\n    float base = length(start - ende);\n    \n    //the other two sides then are\n    float side2 = length(start-p);\n    float side3 =  length(ende-p);\n    \n    //with all three sides known we calculate semi perimeter (s)\n    //https://www.cuemath.com/measurement/area-of-equilateral-triangle/\n    float s = (base+side2+side3)/2.;\n    //Then area of triangle using Heron's formula\n    float area = sqrt(s*(s-base)*(s-side2)*(s-side3));\n    \n    //cool\n    //then with area we find the height of the triangle\n    //and in our case that means the distance of our input point\n    //to the base (the shortest distance to be exact)\n    \n    //IQ's Heron's Version with only 1 squareroot\n    //https://iquilezles.org/www/articles/trianglearea/trianglearea.htm\n    //https://www.iquilezles.org/blog/?p=1579\n    vec2 pp = start - ende;\n    vec2 si2 = start-p;\n    vec2 si3 = ende-p;\n    \n    float A = pp.x*pp.x + pp.y*pp.y;\n    float B = si2.x*si2.x + si2.y*si2.y;\n    float C = si3.x*si3.x + si3.y*si3.y;\n    float s2 = (2.*A*B + 2.*B*C + 2.*C*A - A*A - B*B - C*C)/16.;\n    area = sqrt(s2);\n    \n    //a = (h*b)/2. -> (a*2.)/b = h\n    float dist = (area*2.)/base;\n    return dist;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.y;\n\n\n    \n    vec2 lineA = vec2(0.4, 0.5);\n    vec2 lineB = vec2(-0.5, -0.5);\n    \n    //and let's animate them because that's cool\n    lineA += vec2(sin(iTime/2.),cos(iTime/2.))/5.;\n    lineB += vec2(sin(iTime/2.+9.),cos(iTime/2.+9.))/5.;\n    //let's plot the points first so we know what we're talking about\n    float pointA = circleUnfilled(0.03, uv-lineA);\n    float pointB = circleUnfilled(0.03, uv-lineB);//smoothstep(0.05, 0.055, length(uv-lineB));\n    \n    vec3 col = BG;\n    col = mix(col, COL0, 1.0-pointA);\n    col = mix(col, COL0, 1.0-pointB);\n    \n    //now let's get our line\n    float dists = DistToLine(uv, lineA, lineB);\n    float line = smoothstep(0.008, 0.01, dists);\n    col = mix(col, COL1, 1.0-line);\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 304, 342, 342, 499], [502, 502, 550, 957, 2133], [2136, 2136, 2193, 2243, 3299]], "test": "untested"}
{"id": "ft23zK", "name": "Boze Tower", "author": "kaiware007", "description": "Boze Tower", "tags": ["raymarching", "boze"], "likes": 5, "viewed": 71, "published": "Public", "date": "1624286587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rendering Option\n//#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n#define USE_BRDF_1\n//#define USE_RAYCAST\n//#define ENABLE_FOG\n\n#define AA 1\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nconst float CAMERA_SPEED = 0.1;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, 0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n#define SURF_DIFFUSE(d, c) \t(surface(d, c, \t\t vec3(0), 0.2, 0.5, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\nsurface SURF_BG2(float d, vec3 pos)\n{\n    vec4 col = vec4(sinebow(pos.x * 0.1), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n/*\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n*/\n\n//#define SURF_LOAD(d) \t(surface(d, vec4(0.2,0.2,0.2,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\nsurface SURF_LOAD(float d, vec3 p, vec3 cp)\n{\n\tfloat len = length(cp - p);\n        \n    vec3 col = mix(vec3(0), vec3(0,0.4,1), smoothstep(0.4, 0.41, len));\n    \n    return surface(d, vec4(0.2,0.2,0.2,1), \tcol, 0.01, 0.5, 0, false, 0.5, true);\n}\n\n//#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n#define SURF_SHARI(d) \t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.3, 0.1, 0, false, 1.1, true))\n#define SURF_NETA(d, col) \t(surface(d, vec4(col,1), vec3(0), 0.01, 0.2, 0, false, 1.1, true))\n\n#define SURF_PUMPKIN(d) \t\t(surface(d, vec4(0.9,0.3,0.1,1), vec3(0), 0.5, 0.0, 0, false, 1.1, true))\n#define SURF_PUMPKIN_STALK(d) \t(surface(d, vec4(0.5,0.9,0.2,1), vec3(0), 0.5, 0.0, 0, false, 1.1, true))\n\n//==================================================================\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +\n            (p0*2. - p1*5. + p2*4. - p3)*t*t +\n            (-p0 + p2)*t + p1*2.)*.5;\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\n//https://www.shadertoy.com/view/NdS3Dh\n//SmoothSymmetricPolarMod aka smoothRot\n//\n//s repetitions\n//m smoothness (0-1)\n//c correction (0-1)\n//d object displace from center\n//\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  //float half_angle = (angle * 0.5) * 3.14159 / 180.0;\n    float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{ \n  vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec2 foldRotate(in vec2 p, in float s, out float index) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    index = floor(a / n);\n    a = index * n;\n    p *= rot(a);\n    return p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\nfloat sdMouseTunnel(vec3 p, float ms)\n{\n    //vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(p - vec3(0,0,0.2), vec3(0.08, 0.01 * ms,2));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 color)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo.rgb = color;\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n*/\n\nsurface sdBozeGate(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouseTunnel(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n// Base Pumpkin Distance function @ P_Malin\n// https://www.shadertoy.com/view/MdBXR3\nfloat sdPumpkinBody(vec3 p, float radius, float height)\n{\n\tfloat fAngle1 = atan(p.x, p.z);\n    float fSin = sin(fAngle1 * 16.0);\n    fSin = 1.0 - sqrt(abs(fSin));\n    vec3 sc = 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n    p *= sc;\n    p.y *= height + 0.5 * (radius - length(p.xz)) / radius;\n    \n    return length(p) - radius;\n}\n\nsurface sdPumpkinBoze(vec3 p, float ms)\n{\n    surface result = SURF_NOHIT(1e5);\n    \n    float fSphereRadius = 0.2;\n\t\n\tvec3 vOffset = p;\n\tfloat fFirstDist = length(vOffset);\n\t\n\t//float fOutDist;\n\tif(fFirstDist < 1.5)\n\t{\n        // body\n        float bottom = sdPumpkinBody(vOffset, fSphereRadius, 1.75);\n        float top = sdPumpkinBody(vOffset + vec3(0, -0.075, 0), fSphereRadius * 0.65, 0.5);\n        \n        result = SURF_PUMPKIN(smin(bottom, top, 0.05));\n\n        // stalk(heta)\n        vec3 vStalkOffset = p;\n        vStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n        float fDist2d = length(vStalkOffset.xz);\n        float fStalkDist = fDist2d - 0.02;\n        fStalkDist = max(fStalkDist, p.y - 0.25 + p.x * 0.2);\n        fStalkDist = max(fStalkDist, -p.y);\n        surface stalk = SURF_PUMPKIN_STALK(fStalkDist);\n        \n        result = opSU(result, stalk, 0.02);\n        \n        vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n        // ear\n        float d2 = sdEar(mxp + vec3(0.01,-0.01,0));\n        result.dist = smin(result.dist, d2, 0.005);\n\n        // eye\n#define eyeZ 0.12\n        //float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n        float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, eyeZ+0.01), vec3(-EYE_SPACE, 0.1, eyeZ), 0.0175);\n        surface eye = SURF_BLACK(d4);\n\n        // mouse\n        float d6 = sdMouse(p, ms);\n        surface mouse = SURF_MOUSE(d6);\n\n        // cheep\n        float d7 = sdCheep(mxp + vec3(0,0,-0.015));\n        surface cheep = SURF_CHEEP(d7);\n\n        // eyebrows\n        float d9 = sdEyeBrow(mxp);\n        eye.dist = opU(eye.dist, d9);\n\n        // integration\n        mouse = opU(eye, mouse);\n        result = opS(mouse, result);\n        //result = opU(mouse, result);\n        result = opU(cheep, result);\n\t}\n\t\t\n\n\treturn result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdSushi(vec3 p, vec3 sc, vec3 col) {\n    surface result = SURF_NOHIT(1e5);\n    \n\tfloat minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // shari\n    float shari = sdRoundBox(p, vec3(0.75,0.5,1.75), 0.125);\n    \n    result = SURF_SHARI(shari);\n    \n    //float neta = sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05);\n    \n    surface neta = SURF_NETA(sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05), col);\n    \n    result = opU(result, neta);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 lookAt(vec3 ro, vec3 ta, vec3 camUp)\n{\n    vec3 w = normalize(ta - ro);\n\tvec3 u = abs(dot(w, camUp)) > 1e-7 ? normalize(cross(camUp, w)) : w.yzx * vec3(1,1,-1);\n\tvec3 v = normalize(cross(w, u));\n\treturn mat3(u, v, w);\n}\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t\t);\n}\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 rotateWithQuaternion(vec3 v, vec4 r)\n{\n\tvec4 r_c = r * vec4(-1, -1, -1, 1);\n\treturn qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\n\nvec4 getAngleAxisRotation(vec3 v, vec3 axis, float angle) {\n\taxis = normalize(axis);\n\tfloat s, c;\n\t//sincos(angle, s, c);\n\ts = sin(angle);\n\tc = cos(angle);\n\treturn vec4(axis.x*s, axis.y*s, axis.z*s, c);\n}\n\nvec3 rotateAngleAxis(vec3 v, vec3 axis, float angle) {\n\tvec4 q = getAngleAxisRotation(v, axis, angle);\n\treturn rotateWithQuaternion(v, q);\n}\n\nvec4 fromToRotation(vec3 from, vec3 to) {\n\tvec3\n\t\tv1 = normalize(from),\n\t\tv2 = normalize(to),\n\t\tcr = cross(v1, v2);\n\tvec4 q = vec4(cr, 1. + dot(v1, v2));\n\treturn normalize(q);\n}\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    float ms = sin(iTime * 0.4 * M_PI2) * 0.5 + 0.5;\n    \n    // boze tower\n    vec3 q = p;\n    q = rotate(p, RAD90, vec3(0,1,0));\n    q = opRep(q, vec3(1000,0.5,1000));\n        \n    q.xz = smoothRot(q.xz, 16., 0.0125, 0., 0.5);\n    \n    surface boze = sdBoze(q, vec3(2), ms);\n    \n    boze = opSU(boze, sdBoze(q + vec3(0,0.5,0), vec3(2), ms), 0.05);\n    boze = opSU(boze, sdBoze(q - vec3(0,0.5,0), vec3(2), ms), 0.05);\n    \n    result = opU(result, boze);\n\n    // boze wall\n    q = p;\n    q = opRep(q, vec3(1000,0.5,1000));\n    \n    q.xz = smoothRot(q.xz, 64., 0.0125, 0., 5.5);\n    q = rotate(q, M_PI, vec3(0,1,0));\n    \n    boze = sdColorBoze(q, vec3(2), ms, vec3(0.02,0.02,0.2));\n    \n    boze = opSU(boze, sdColorBoze(q + vec3(0,0.5,0), vec3(2), ms, vec3(0.02,0.02,0.2)), 0.05);\n    boze = opSU(boze, sdColorBoze(q - vec3(0,0.5,0), vec3(2), ms, vec3(0.02,0.02,0.2)), 0.05);\n    \n    result = opU(result, boze);    \n    \n    return result;\n}\n/*\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n*/\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    /*\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    */\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t\n}\n#endif\n\n/*\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n*/\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).dist;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 500., 0.99 ));\n    */\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n#ifdef USE_BRDF_1\n//------------------------------------------------------------------------------\n// BRDF 1\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n#else\n//------------------------------------------------------------------------------\n// BRDF 2\n//------------------------------------------------------------------------------\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//surface surf\n//vec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\nvec3 shade(vec3 pos, vec3 N, vec3 V, vec3 L, vec3 Lradiance, surface surf)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), surf.roughness);\n\tfloat D = ndfGGX(NdotH, surf.roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, surf.roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * surf.albedo.rgb / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 N, vec3 V, float t, vec3 ambientColor, surface surf)\n{\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), surf.roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    //vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    //ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    //ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * surf.albedo.rgb * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    //vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 col = ambientColor;\n    vec3 ref = EnvBRDFApprox(F0, surf.roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, surf.roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n#endif\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n#ifdef USE_RAYCAST\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n*/\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    p = opRep(p, vec3(0.5,100,100.0));\n    p = rotate(p + vec3(0,0.04,0.2), RAD90, vec3(1,0,0));\n    float d = 10000.;\n    for(int i = 0; i < 5; i++)\n    {\n        float k = fract(float(i) / 5. + iTime * 0.25);\n        vec3 q = p + vec3(0, -2.8*k, -0.1*k);\n        //surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n        //surface r = sdBoze(p, vec3(1.2), 1.);\n        //float d = sdCapsule(p, vec3(0,0.01,0.2), vec3(0,0.1,1.0), 0.01, 0.1);\n        //float d = sdTorus(p, vec2(0.2 + sin(iTime) * 0.1, 0.05));\n        float d2 = sdTorus(q, vec2(0.2*k, 0.05*k));\n        //return fbm(p * 25. + iTime * 2.2) - min(d, 1.) * 25.;\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.y * 20.);\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.x * 20.);\n        d = min(d, d2);\n    }\n    return fbm(p * (25. + p.z * 25.) * vec3(1,1,0.5)+ vec3(0, 0, iTime * -5.2)) - min(d, 1.) * 25.;\n}\n\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0,0,0);\n    const vec3 boxSize = vec3(100., 0.5, 10.);\n    vec2 sd = GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\t//const float lightStep = 2.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 5.5) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 2. - dd * absorption;\n                if(transmittance < 0.001)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                //result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(1,0.3,0.05) * (150. * dd * transmittance);\n                result.emission.rgb += vec3(0.1,0.3,1.0) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n#endif\n\n#define fog_density(x) (1.0 - saturate(exp2(5.5 - (x) * 0.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(1.0,0.5,1.0));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d * 1.0;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n\n#ifdef USE_BRDF_1\n        // BRDF 1\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n#else\n        // BRDF 2\n        //Shade \n        hit.albedo.rgb = shade(pos, nor, -direction, normalize(lightPos), lightColor, hit);\n        // Calc Ambient\n        hit.albedo.rgb += calcAmbient(pos, nor, -direction, hit.dist, vec3(0.5), hit);\n#endif\n        \n#ifdef ENABLE_FOG\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n#endif\n    }\n    \n#ifdef USE_RAYCAST\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        hit.isHit = volume.isHit;\n    }\n    \n    if(d <= EPS || volume.isHit){\n#else\n    if(d <= EPS){\n#endif\n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a <= EPS) {\n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                nor = normalize(nor + hash33(ray*3823.) * mat.roughness);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                //orientingNormal = normalize(orientingNormal + hash33(pos) * mat.roughness * 0.05);\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    //ray = normalize(ray + hash33(ray) * mat.roughness * 0.05);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n        float t = mix(-3.0, 3.0, (fragCoord.y / iResolution.y));\n        float y = iTime * 0.5;\n        float r = 4.5;\n\t\t//float phi   = RAD90;\n        float theta = iTime * 0.2 * M_PI2;\n        \n        vec3 ro = vec3(cos(theta) * r, y, sin(theta) * r);\n        vec3 ta = vec3(0., y + t, 0);\n        vec3 up = vec3(0, 1, 0);\n        \n        mat3 c = camera(ro, ta, 0.0);\n        //mat3 c = lookAt(ro, ta, up);\n        \n        // Perspective\n        //float fov = 1.75 - dot(p,p);\n        //vec3 ray = c * normalize(vec3(p, fov*1.8)); \n        vec3 ray = c * normalize(vec3(p, 2.5)); \n        // Orthographic\n        //vec3 ray = c * vec3(0, 0, 1.0);\n        //ro += c * vec3(p,0);\n        \n        vec3 col = render(ro, ray, fragCoord.xy);\n       \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 966, 989, 989, 1062], [1601, 2547, 2584, 2649, 2867], [2868, 2868, 2905, 2905, 3020], [3480, 3583, 3628, 3628, 3827], [4901, 4977, 4999, 4999, 5330], [5333, 5521, 5544, 5544, 5629], [5631, 5650, 5672, 5672, 5789], [5791, 5810, 5833, 5833, 5936], [5938, 5958, 5979, 5979, 6113], [6115, 6134, 6156, 6156, 6289], [6291, 6311, 6333, 6333, 6458], [6460, 6460, 6481, 6481, 6551], [6553, 6553, 6576, 6576, 6655], [6658, 6658, 6680, 6680, 7097], [7208, 7208, 7229, 7229, 7370], [7372, 7372, 7402, 7402, 7532], [7534, 7534, 7595, 7595, 7733], [7735, 7735, 7761, 7761, 8070], [8072, 8132, 8158, 8158, 9024], [9026, 9106, 9147, 9147, 9318], [9320, 9320, 9377, 9377, 9512], [9514, 9614, 9650, 9650, 9678], [9680, 9680, 9726, 9726, 9782], [9784, 9784, 9815, 9815, 9906], [9908, 9908, 9958, 9958, 10076], [10078, 10078, 10139, 10139, 10270], [10272, 10272, 10309, 10309, 10398], [10400, 10400, 10470, 10470, 10604], [10606, 10606, 10670, 10670, 10787], [10789, 10789, 10841, 10841, 10948], [10950, 10950, 10983, 11009, 11040], [11042, 11042, 11067, 11067, 11086], [11087, 11087, 11112, 11112, 11131], [11132, 11132, 11168, 11168, 11196], [11198, 11198, 11257, 11257, 11570], [11572, 11572, 11605, 11605, 11670], [11672, 11696, 11748, 11748, 11867], [11869, 11979, 12011, 12011, 12105], [12107, 12107, 12141, 12141, 12292], [12294, 12294, 12328, 12328, 12476], [12478, 12478, 12512, 12512, 12647], [12649, 12649, 12677, 12677, 12762], [12763, 12821, 12892, 12892, 13220], [13222, 13222, 13304, 13304, 13672], [13674, 13759, 13803, 13803, 14027], [14029, 14086, 14123, 14164, 14247], [14249, 14249, 14288, 14460, 14569], [14571, 14571, 14620, 14620, 15179], [15181, 15181, 15220, 15266, 15351], [15353, 15353, 15394, 15504, 15618], [15633, 15684, 15717, 15717, 15739], [15741, 15741, 15774, 15774, 15796], [15798, 15798, 15831, 15831, 15852], [15854, 15854, 15897, 15897, 15996], [16000, 16176, 16231, 16231, 16398], [16401, 16401, 16446, 16446, 16875], [16877, 16877, 16898, 16898, 16962], [16964, 16964, 17015, 17015, 17267], [17269, 17269, 17293, 17293, 17335], [17339, 17339, 17373, 17373, 17688], [17690, 17690, 17758, 17758, 18010], [18012, 18012, 18069, 18069, 18213], [18215, 18215, 18250, 18250, 18398], [18400, 18400, 18434, 18434, 18610], [18612, 18612, 18647, 18647, 18682], [18684, 18684, 18721, 18721, 18756], [18758, 18929, 19014, 19014, 19091], [19093, 19136, 19211, 19211, 19630], [19632, 20210, 20294, 20294, 20637], [20639, 20645, 20697, 20697, 20853], [20855, 20855, 20915, 20915, 20956], [20958, 21173, 21204, 21204, 21253], [21255, 21255, 21282, 21282, 21320], [21322, 21322, 21351, 21351, 21389], [21391, 21391, 21418, 21418, 21467], [21470, 21699, 21720, 21720, 21859], [21885, 21885, 21917, 21917, 22030], [22032, 22032, 22064, 22064, 22204], [22206, 22206, 22239, 22239, 22471], [22472, 22472, 22511, 22544, 22736], [22738, 22738, 22761, 22761, 23332], [23334, 23334, 23359, 23359, 23520], [23522, 23522, 23565, 23565, 24571], [24572, 25273, 25333, 25333, 26369], [26576, 32921, 32968, 32968, 33980], [33982, 34067, 34124, 34124, 34392], [34394, 34394, 34435, 34435, 36235], [36236, 36454, 36498, 36498, 36979], [36981, 36981, 37023, 37023, 37201], [37203, 37203, 37246, 37246, 37427], [37429, 37507, 37536, 37536, 37650], [37652, 37747, 37790, 37790, 37873], [37875, 37875, 37934, 37934, 38079], [38081, 38081, 38135, 38135, 38221], [38223, 38223, 38264, 38264, 38400], [38402, 38402, 38423, 38423, 39409], [42188, 42542, 42578, 42578, 42911], [43177, 43245, 43273, 43273, 43400], [43402, 43492, 43555, 43555, 43761], [43763, 43829, 43893, 44063, 44694], [44696, 44696, 44733, 44733, 44823], [44825, 44825, 44851, 44851, 46911], [54829, 55031, 55064, 55120, 55306], [55308, 55308, 55347, 55347, 55390]], "test": "untested"}
{"id": "ft2GR1", "name": "Exploring Bitspace 2 - 172 chars", "author": "Xor", "description": "Alternative version of: https://www.shadertoy.com/view/7lj3zz", "tags": ["voxel", "tiny"], "likes": 4, "viewed": 105, "published": "Public", "date": "1623356313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Remix of: https://www.shadertoy.com/view/7lj3zz\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u=u/iResolution.y/.8-.6;\n    for(ivec4 b=ivec4(o-=o);(b.x^b.x/8&62&b.y|b.z)%88<99-b.z;)\n    b = ivec4(u*o.a+iTime*vec2(9,2),o+=.1);\n    o /= 1e2/(++u).xyyx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 86, 86, 249]], "test": "untested"}
{"id": "ft2GRD", "name": "Maxnorm Distance to Cubic Curve", "author": "oneshade", "description": "First try at computing maxnorm distances.", "tags": ["2d", "distance", "curve", "cubic", "maxnorm", "exact"], "likes": 9, "viewed": 115, "published": "Public", "date": "1623444739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 solveQuadratic(in float a, in float b, in float c) {\n    if (abs(a) < 1e-6) return vec3(-c / b, 0, 1);\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return vec3(0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(h) - b) * 0.5 / a, 2.0);\n}\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    if (abs(a) < 1e-9) return vec4(solveQuadratic(b, c, d), 0.0).xywz;\n    float u = b / (3.0 * a);\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n    if (abs(p) < 1e-3) return vec4(-sign(q) * pow(abs(q), 1.0 / 3.0) - u, 0, 0, 1);\n\n    if (4.0 * p * p * p + 27.0 * q * q > 0.0) {\n        float ip = 3.0 / abs(p), sp = sqrt(ip), k = 0.5 * q * ip * sp, x;\n        if (p > 0.0) x = -2.0 / sp * sinh(asinh(k) / 3.0) - u;\n        else x = -2.0 / sp * cosh(acosh(abs(k)) / 3.0) * sign(q) - u;\n        return vec4(x, 0, 0, 1);\n    }\n\n    float m = sqrt(-p / 3.0);\n    float x1 = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    float h = sqrt(-3.0 * x1 * x1 - 4.0 * p);\n    float x2 = 0.5 * (h - x1), x3 = 0.5 * (-h - x1);\n\n    return vec4(x1 - u, x2 - u, x3 - u, 3);\n}\n\nfloat evalDist(in vec2 p, in float t, in float tmin, in float tmax, in bool limit, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    if (limit) t = clamp(t, tmin, tmax);\n    vec2 toCurve = p - (((a * t + b) * t + c) * t + d);\n    return max(abs(toCurve.x), abs(toCurve.y));\n}\n\nfloat sdCubic(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float tmin, in float tmax, in bool limit) {\n    // Solving for the global minimum of max(|a.x*t^3 + b.x*t^2 + c.x*t + d.x - p.x|, |a.y*t^3 + b.y*t^2 + c.y*t + d.y - p.y|)\n    // Minima and maxima are either intersections of the two with different combinations of signs where the derivative jumps from one to the other\n    // or the minima and maxima of one of the cubics (sign flip due to abs() does not change them)\n    vec2 dp = d - p;\n\n    // |a.x*t^3 + b.x*t^2 + c.x*t + d.x - p.x| = |a.y*t^3 + b.y*t^2 + c.y*t + d.y - p.y|\n    // All combinations of signs on both sides degenerate into either +/+ or +/-\n    vec4 minMax1 = solveCubic(a.x - a.y, b.x - b.y, c.x - c.y, dp.x - dp.y);\n    vec4 minMax2 = solveCubic(a.x + a.y, b.x + b.y, c.x + c.y, dp.x + dp.y);\n\n    // Minima and maxima of both cubics\n    // Remember that they CAN have a global minimum because of abs() forcing them\n    // to bounce back up when they go below the x axis\n    vec3 minMax3 = solveQuadratic(3.0 * a.x, 2.0 * b.x, c.x);\n    vec3 minMax4 = solveQuadratic(3.0 * a.y, 2.0 * b.y, c.y);\n\n    // Find minimum\n    float dist = evalDist(p, minMax1[0], tmin, tmax, limit, a, b, c, d);\n    for (int n=1; n < int(minMax1.w); n++) dist = min(dist, evalDist(p, minMax1[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax2.w); n++) dist = min(dist, evalDist(p, minMax2[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax3.z); n++) dist = min(dist, evalDist(p, minMax3[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax4.z); n++) dist = min(dist, evalDist(p, minMax4[n], tmin, tmax, limit, a, b, c, d));\n\n    return dist;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 2.0 * sin(time)) * cos(time);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 v1 = vec2(c2, s3 * 1.5 - 0.25);\n    vec2 v2 = vec2(-2.0, 0.5);\n    vec2 v3 = vec2(2.0, 0.5);\n    vec2 v4 = vec2(s2, c3 * 1.5 - 0.25);\n\n    // To power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1;\n\n    float dist = sdCubic(uv, a, b, c, d, 0.0, 1.0, true);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * dist);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dist)));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - v1) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - v4) - 0.05));\n\n    float mDist = sdCubic(mouse, a, b, c, d, 0.0, 1.0, true);\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.03));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.005));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 244], [246, 246, 311, 311, 1121], [1123, 1123, 1251, 1251, 1398], [1400, 1400, 1515, 1888, 3118], [3120, 3120, 3167, 3167, 3275], [3277, 3277, 3332, 3332, 4983]], "test": "untested"}
{"id": "ft2GW3", "name": "Bicomplex Mandelbrot", "author": "kibitz9", "description": "Bicomplex Mandelbrot", "tags": ["bicomplexmandelbrot"], "likes": 1, "viewed": 60, "published": "Public", "date": "1624854765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//a bicomplex mandelbrot\n\nvec4 square(vec4 B){\n    //Bicomplex square\n    return vec4(\n         B.x* B.x- B.y* B.y- B.z* B.z+ B.w* B.w\n        ,2.* B.x* B.y-2.* B.z* B.w\n        ,2.* B.x* B.z-2.* B.y* B.w\n        ,2.* B.x* B.w+2.* B.y* B.z\n     );\n}\nfloat biComplexMB(in vec4 c, int itr){\n    vec4 z=vec4(0);\n    //ye old z=z^2+c\n    for (int a=0;a<itr;a++){\n        z=square(z);\n        z=z+c;\n        float sqrd = dot(z,z);\n        if (sqrd>4.){\n            return float(a)/float(itr);\n        }\n        \n    }\n    return 0.;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv-=vec2(.6,.5);\n    uv *=2.5;\n    uv.x *=iResolution.x/iResolution.y;\n    \n    float aaLevel = 4.;\n    \n    float px = 1./iResolution.x;\n    float hp = px/aaLevel;\n    \n    float i=0.;\n    for (float aa=0.;aa<px;aa+=hp){\n        for (float bb=0.;bb<px;bb+=hp){\n            //2 coords are screen coords, 2 coords based on time...\n            \n            \n            i+=biComplexMB(vec4(uv.x+aa,uv.y+bb,sin(iTime/13.)*.6,sin(iTime/17.)*.6),75);\n            \n            \n           \n        }\n    }\n    i/=(aaLevel*aaLevel);\n    i=pow(i,.6);\n    \n    fragColor = vec4(i,pow(i,.5),pow(i,.25),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 46, 69, 249], [250, 250, 288, 288, 534], [535, 535, 592, 642, 1296]], "test": "untested"}
{"id": "ft2GWR", "name": "- Floating Circles-", "author": "Mihaha", "description": "In fact, this is just a distorted result from the function (cosx + cosy), plus coloring", "tags": ["procedural", "distortion", "circle", "monochrome", "soft", "relax"], "likes": 3, "viewed": 64, "published": "Public", "date": "1623755172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n> by MihasGames, 15.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float map = 5. * pow(cos(iTime/5.), 2.) + 5.;\n    \n    // Pixel Normalizations //\n    vec2 uv01 = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv01 - vec2(1, 1)/2.;\n    vec2 uv = uv0*map * vec2(iResolution.x / iResolution.y, 1);\n    uv /= length(uv0)+1.; // Length Distorsion\n\n    float xpos = sin(iTime/10.)*20., ypos = cos(iTime/8.4)*30.; // Camera Position\n    \n    // Main Distorsion and Filtering // \n    float col = pow(cos( uv.x + xpos + sin(uv.y) + uv0.x*1.5 ), 2.) + \n                pow(cos( uv.y + ypos - sin(uv.x/1.2) - uv.y*2. ), 2.);\n    \n    if (col > pow(sin(iTime/3.0), 2.)*0.3 + 0.7) col = 1.;\n    else col = 0.;\n    \n    float colmap = 0.5;\n    vec3 c = vec3(col+uv01.x*0.5+(sin(iTime/1.5)*0.5+0.5)*0.5, \n                  col+(1.-uv01.y)*0.5+(cos(iTime/1.5)*0.5+0.5)*0.5, 1);\n    \n    fragColor = vec4(c, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 127, 127, 962]], "test": "untested"}
{"id": "ft2GWV", "name": "Tater @ livecode Release Jam", "author": "Tater", "description": "It turned out not so good but I had a lot of fun, I will probably fix it up and make a pretty version later. \nhttps://livecode.demozoo.org/\nhttps://www.twitch.tv/psenough", "tags": ["raymarch", "jam", "livecode", "demozoo"], "likes": 5, "viewed": 160, "published": "Public API", "date": "1624747675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 250.0\n#define MDIST 550.0\n#define pi 3.1415926\n\n#define pmod(p,x) (mod(p,x) - (x)*0.5)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat smin(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return min(a,b)-h*h*0.25/k;\n}\nfloat anim(){\n  return sin(iTime); \n}\nfloat rand(vec2 a){\n  return fract(sin(dot(a,vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\nfloat ssRemap(float t, float s1, float s2, float c){\n  return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)*s1*t;\n}\nfloat wave(vec3 p, float t){\n  float dist = length(p.xz)-fract(t+0.5)*50.0;\n  dist = min(dist,0.0);\n  float wave = sin(dist)*exp(-abs(length(dist*0.2)));\n  wave*=max(0.,1.0-fract(t-0.5)*2.0);\n  return wave;\n}\nfloat ball(vec3 p, float t){\n  float mag = 80.0;\n  p.y += (fract(t)-0.5)*mag;\n  float a = length(p)-3.0;\n  return a;\n}\n\nvec2 map(vec3 p){\n  vec3 po = p;\n  \n  float t= mod(iTime,300.0)*0.6;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  \n  //Bending\n  p.y = pmod(p.y,60.0);\n  \n  float th = atan(p.x,p.z)/(2.0*pi)+0.5;\n  th*=300.0;\n  float r = length(p.xz)-60.0;\n  p.x = r;\n  //p.z = th;\n  p.xy*=rot(sin(t));\n  //p.xy*=rot(p.z*0.01*sin(t));\n  p.xy = abs(p.xy)-5.0;\n  p.xy*=rot(-pi/4.0);\n  p.y=mix(p.y,ssRemap(p.y,0.01,0.4,0.3),0.5+0.5*anim());\n  \n  vec3 po2 = p;\n  float count = 6.0;\n  float wav =0.0;\n  for(float i =0.0; i < count; i++){\n    p = po2;\n    t+=1.0/count;\n    float mag = 10.0;\n    p.x+=rand(vec2(floor(t),i))*mag;\n    p.z+=(rand(vec2(floor(t),i*1.5)))*mag*30.0;\n    a.x = smin(a.x,ball(p,t),0.5);\n    wav +=wave(p,t)*1.5;\n  }\n  p = po2;\n  t = mod(iTime,300.0)*4.0;\n  wav+=sin(p.z+t)*0.1+sin(p.x+t)*0.1;\n  wav+=sin(p.z*0.5-t)*0.2+sin(p.x*0.5-t)*0.2;\n  \n  //a.x = ball(p,t);\n  b.x = p.y-wav;\n  \n  \n  a=(a.x<b.x)?a:b;\n  \n  return a;\n}\n\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0);\n  return normalize(map(p).x-vec3(\n  map(p-e.xyy).x,\n  map(p-e.yxy).x,\n  map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n  float t= mod(iTime,300.0);\n  vec3 col = vec3(0.1);\n  vec3 ro = vec3(0,70,-150);\n  \n  float drop = 0.0;\n  drop = 0.0;\n  ro.y-=drop;\n  \n  //ro.z*=sin(t);\n  //ro.y += sin(t)*20.0;\n  ro.xz*=rot(t*0.3);\n  vec3 lk = vec3(0,0,0);\n  \n  lk.y-=drop;\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = f*1.0+uv.x*r+uv.y*cross(f,r);\n  \n  vec3 p = ro;\n  float dO, shad;\n  vec2 d;\n  \n  for(float i = 0.0; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    dO+=d.x*0.9;\n    \n    if(abs(d).x<0.01){\n      shad = i/STEPS;\n      break;\n    }\n    if(dO>MDIST){\n      dO = MDIST;\n      p = ro+rd*dO;\n      d.y=0.0;\n      break;\n    }\n  }\n  shad = 1.0-shad;\n  vec3 n = norm(p);\n  vec3 ld = normalize(vec3(1,1,0));\n  vec3 h = normalize(ld - rd);\n  float spec = pow(max(dot(n,h),0.0),20.0);\n  \n  vec3 al = vec3(0);\n  if(d.y==1.0) al = vec3(0,0.8,0.2);\n  if(d.y==2.0) al = vec3(0,0,0.9)*1.5;\n  p.y-=5.0;\n  vec3 back = mix(vec3(0.1,0.1,0.5),vec3(0.0,0.4,0.6),clamp(p.y*0.05,0.0,1.0))*0.9;\n  //back = vec3(0);\n  \n  col = shad*al;\n  col+=spec*0.5;\n  \n  col = mix(col,back*2.0,(dO/MDIST));\n\n  fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 191, 191, 256], [257, 257, 270, 270, 294], [295, 295, 314, 314, 384], [385, 385, 437, 437, 503], [504, 504, 532, 532, 712], [713, 713, 741, 741, 831], [833, 833, 850, 850, 1752], [1754, 1754, 1772, 1772, 1889], [1891, 1891, 1948, 1948, 3138]], "test": "untested"}
{"id": "ftB3Rw", "name": "Volcanic islands", "author": "jarble", "description": "This fractal terrain looks volcanic.", "tags": ["fractal", "terrain", "island", "volcano", "volcanic"], "likes": 4, "viewed": 150, "published": "Public API", "date": "1623504841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 1.0;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-(noise(uv * freq)) * amplitude));\n        \n        amplitude *= .3;\n        \n        freq *= 1.3+value/2.;\n        \n        uv = uv.yx;\n    }\n    \n    return (value-2.8)/4.0;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 411, 436, 436, 470], [490, 490, 513, 562, 983], [1058, 1058, 1096, 1096, 1156], [1158, 1158, 1191, 1191, 1411], [1413, 1413, 1451, 1451, 1678], [1680, 1680, 1718, 1718, 1942], [1944, 1944, 1973, 1973, 2068], [2070, 2070, 2107, 2107, 2166], [2169, 2237, 2256, 2256, 2295], [2297, 2297, 2317, 2317, 2393], [2395, 2395, 2414, 2414, 2453], [2455, 2455, 2512, 2512, 2747], [2749, 2749, 2784, 2784, 3178], [3180, 3180, 3234, 3234, 3900], [3903, 3903, 3955, 3955, 4390], [4392, 4392, 4449, 4449, 5640]], "test": "untested"}
{"id": "ftB3zR", "name": "Double Slit", "author": "milesWaugh", "description": "A little thingy for fun", "tags": ["light", "slit"], "likes": 4, "viewed": 194, "published": "Public API", "date": "1623177673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589793\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = 2.*(fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col, col1, col2;\n    \n        col1 = vec3(cos(pi*uv.x*8.-iTime)); //Initial waves\n        vec2 a = vec2(uv.x,uv.y-0.5);\n        vec2 b = vec2(uv.x,uv.y+0.5);\n        float c = dot(a,a);\n        float d = dot(b,b);\n        col2 = vec3(cos(pi*sqrt(c)*8.-iTime)*exp(-c*.4)+cos(pi*sqrt(d)*8.-iTime)*exp(-d*.4))*.5; //Interference\n    \n    col = mix(col1,col2,smoothstep(0.,1.,uv.x*15.)); //Interpolate\n    col *= min(smoothstep(0.,1.,abs(uv.x)*16.)/smoothstep(0.,1.,abs(abs(uv.y)-0.5)*20.),1.); //Barrier\n    \n    col = col*col; //PDF\n    \n    col = vec3((-cos(pi*(col.r))/2.+.5),col.r,(1.-(acos(2.*col.r-1.))/pi)); //color\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 84, 84, 813]], "test": "untested"}
{"id": "ftBGD3", "name": "Hommage à Tyler Hobbs 2", "author": "DrNoob", "description": "Animated reproduction of \"Remembrance in Points\" by Tyler Hobbs:\nhttps://tylerxhobbs.com/selected-works/generative-digital/2", "tags": ["reproduction"], "likes": 6, "viewed": 55, "published": "Public", "date": "1624804181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Hommage à Tyler Hobbs (Remembrance in Points 2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Animated reproduction of \"Remembrance in Points\" by Tyler Hobbs:\n// https://tylerxhobbs.com/selected-works/generative-digital/2\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat time() {\n    return 1.5 * iTime;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    p.x *= ar;\n    \n    vec3 col = vec3(0.9);\n    \n    const int N = 40;\n    const float INV_N = 1.0 / float(N);\n    for (int i = 0; i < N; ++i) {\n        // Stripe fraction\n        float fi = float(i) * INV_N;\n        \n        // Stripe-dependent random numbers\n        float r1 = hash(13.0 * float(i));\n        float r2 = hash(37.0 * float(i));\n        \n        // Stripe-dependent random direction\n        float dir = sign(r1 - 0.5);\n        \n        // Modulate horizontal offset per stripe\n        float off = 4.0 * fi;\n        \n        // Modulate sine amplitude per stripe (stronger emphasis near the bottom)\n        float amp = 0.025 * pow(1.0 - fi, 3.0);\n        \n        // Modulate stripe using offset and amplitude\n        vec2 q = vec2(p.x + off, p.y + amp * sin(10.0 * p.x + 3.5));\n        \n        // Stripe start and end points\n        vec2 start = vec2(off, -INV_N + (1.0 + INV_N) * fi);\n        vec2 end = vec2(off + ar, -INV_N + (1.0 + INV_N) * fi);\n        \n        // Animated stripe thickness with random left/right direction\n        float th = 0.025 + 0.0075 * sin(10.0 * q.x - 11.0 + dir * time());\n        \n        // Stripe SDF as oriented box\n        float d = sdOrientedBox(q, start, end, th);\n        \n        // Modulate stripe color (gradually darker from horizon to top/bottom)\n        const float HORIZ = 0.6;\n        float low = clamp(\n            (fi > HORIZ) ? 0.15 + pow(1.0 - fi, 0.2) : pow(0.3 + fi, 3.0),\n            0.0, 1.0);\n        float c = low + 0.8 * (1.0 - low) * r2;\n        \n        // Add noise (gradually stronger near bottom)\n        float inten = 0.3 + pow(1.0 - fi, 1.5);\n        c += -0.5 * inten + inten * vfbm(750.0 * q + dir * time());\n        c = clamp(c, 0.0, 1.0);\n        \n        // Mix in stripe color\n        col = mix(col, vec3(c), smoothstep(fwidth(d), 0.0, d));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[308, 390, 414, 414, 497], [499, 581, 606, 606, 724], [726, 803, 828, 828, 1282], [1284, 1397, 1420, 1420, 1757], [1759, 1759, 1823, 1823, 2036], [2038, 2038, 2052, 2052, 2078], [2080, 2080, 2135, 2135, 4101]], "test": "untested"}
{"id": "ftBGDK", "name": "Oil Spill Vortices", "author": "doodlestein", "description": "Just playing around", "tags": ["oil"], "likes": 10, "viewed": 140, "published": "Public API", "date": "1624679665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original credit to Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define NUM_LAYERS 3.\n#define ITER 25\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*tan(t*.1),0,0,.14*tan(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .3;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(25.,.25,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(2,1.,2.);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 170, 188, 188, 408], [410, 410, 467, 467, 925]], "test": "untested"}
{"id": "ftBGDt", "name": "Polygon Interpolation (Trigless)", "author": "oneshade", "description": "Messing with [url=https://www.shadertoy.com/view/7ljGDc]https://www.shadertoy.com/view/7ljGDc[/url]. Also eliminated all the trigonometry (not much difference on a fast GPU, maybe in other contexts though). Left side: original, right side: trigless.", "tags": ["test", "barycentric", "polygon", "interpolation", "meanvaluecoordinates", "trigless"], "likes": 14, "viewed": 107, "published": "Public", "date": "1624915608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Try clicking with the mouse to see the weights interpolate it\n// back to its original position (purple is the original position,\n// green is the interpolated position, both should align)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Number of vertices\n#define N 6\n\n// Trigless version\nvoid polyLerpWeightsTrigless(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    float norm = 0.0;\n    for(int n = 0; n < N; n++) {\n        vec2 a = poly[(n - 1 + N) % N] - p;\n        vec2 b = poly[n] - p;\n        vec2 c = poly[(n + 1) % N] - p;\n\n        float d = length(b);\n        float ab = dot(a, b), bc = dot(b, c), ad = length(a) * d, dc = d * length(c);\n        float u = sqrt(max(0.0, (ad - ab) / (ad + ab))) * sign(a.x * b.y - a.y * b.x);\n        float v = sqrt(max(0.0, (dc - bc) / (dc + bc))) * sign(b.x * c.y - b.y * c.x);\n\n        weights[n] = (u + v) / d;\n        norm += weights[n];\n    }\n\n    for(int n = 0; n < N; n++) weights[n] /= norm;\n}\n\n// Original (slightly modified to match the interface of the trigless one)\nfloat cr2(vec2 A, vec2 B) {\n    return A.x*B.y-A.y*B.x;\n}\n\nfloat getAngle(vec2 A, vec2 B) {\n    return atan(cr2(A, B), dot(A, B));\n}\n\nvoid polyLerpWeightsOriginal(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    vec2 vi, vi_min1, vi_plus1;\n    float sumweights = 0.0;\n    float ang1, ang2;\n    float t1, t2;\n    vec2 vi_p;\n    \n    for(int i = 0; i < N; i++) {\n        vi = poly[i];\n        vi_min1 = poly[(i-1 + N) % N];\n        vi_plus1 = poly[(i+1) % N];\n        vi_p = normalize(vi-p);\n        \n        \n        //ang1 = acos(dot(normalize(vi_min1-p), vi_p));\n        //ang2 = acos(dot(normalize(vi_plus1-p), vi_p));\n        ang1 = getAngle(normalize(vi_min1-p), vi_p);\n        ang2 = getAngle(vi_p, normalize(vi_plus1-p));\n        \n        \n        t1 = tan(ang1*0.5);\n        t2 = tan(ang2*0.5);\n        weights[i] = (t1 + t2) / distance(vi, p);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n}\n\n// Simple point in polygon test extracted from @iq's polygon\n// distance shader: https://www.shadertoy.com/view/wdBXRW\nbool pointInPolygon(in vec2 p, in vec2[N] v) {\n    bool res = false;\n    for (int i=0, j=N - 1; i < N; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n\n        // Winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 c = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(c) || all(not(c))) res = !res;  \n    }\n    \n    return res;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = 0.5 * iTime;\n    vec3 color = vec3(1.0);\n\n    // Create polygon\n    float t1 = 0.5 * time, t2 = 1.25 * time, t3 = 1.5 * time;\n    float c1 = 0.4 * cos(t1), s1 = 0.4 * sin(t1);\n    float c2 = 0.4 * cos(t2), s2 = 0.4 * sin(t2);\n    float c3 = 0.4 * cos(t3), s3 = 0.4 * sin(t3);\n\n    vec2[N] poly;\n    poly[0] = vec2(1.0, 0.0);\n    poly[1] = vec2(0.5, sqrt(0.75));\n    poly[2] = vec2(-0.5, poly[1].y);\n    poly[3] = vec2(-1.0, 0.0);\n    poly[4] = vec2(-0.5, -poly[1].y);\n    poly[5] = vec2(0.5, -poly[1].y);\n\n    // Distort the vertices\n    for (int n=0; n < N; n++) {\n        float id = float(n + 3);\n        float freq = Hash11(id * 393.84) * 10.0 - 5.0;\n        float phase = Hash11(id * 183.37);\n        float amp = Hash11(id * 275.35) * 2.0;\n        float ang = iTime * freq + phase;\n        poly[n] += vec2(cos(ang), sin(ang)) * amp;\n        poly[n] *= 0.25;\n    }\n\n    if (pointInPolygon(uv, poly)) {\n        // Compute interpolation weights\n        float[N] weights1, weights2;\n        polyLerpWeightsOriginal(uv, poly, weights1);\n        polyLerpWeightsTrigless(uv, poly, weights2);\n\n        // Interpolate colors from vertices\n        vec3 polyLerp = vec3(0.0);\n        float side = step(0.0, uv.x); // Which side of the screen (left: 0, right: 1)\n        for (int n=0; n < N; n++) polyLerp += hue2rgb(float(n) / float(N)) * mix(weights1[n], weights2[n], side);\n        color = polyLerp;\n    }\n\n    // Get distance to edges\n    float d = 1000000.0;\n    for (int n=0; n < N; n++) d = min(d, sdLine(uv, poly[n], poly[(n + 1) % N]));\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, d));\n\n    if (iMouse.z > 0.0) {\n        // Compute weights for the mouse position\n        float[N] weights;\n        polyLerpWeightsTrigless(mouse, poly, weights);\n\n        // Exact mouse position (to test)\n        float distMouse = length(uv - mouse) - 0.015;\n        color = mix(color, vec3(0.6, 0.0, 0.8), smoothstep(unit, 0.0, distMouse));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouse))); // Outline\n\n        // Test to see if it interpolates back to its original position\n        vec2 mouseLerp = vec2(0.0);\n        for (int n=0; n < N; n++) mouseLerp += poly[n] * weights[n];\n\n        float distMouseLerp = length(uv - mouseLerp) - 0.015;\n        color = mix(color, vec3(0.0, 0.8, 0.6), smoothstep(unit, 0.0, distMouseLerp));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouseLerp))); // Outline\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 385, 465, 465, 1047], [1049, 1124, 1151, 1151, 1181], [1183, 1183, 1215, 1215, 1256], [1258, 1258, 1338, 1338, 2145], [2147, 2266, 2312, 2312, 2675], [2677, 2718, 2744, 2744, 2830], [2832, 2832, 2879, 2879, 2987], [2989, 2989, 3044, 3063, 5756]], "test": "untested"}
{"id": "ftBGzw", "name": "Cubemap step1", "author": "kithy", "description": "cubemap texture and projection.", "tags": ["raymarching", "cubemap", "morphing"], "likes": 1, "viewed": 34, "published": "Public", "date": "1623511556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100.0\n#define EPS 0.001\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-1.0;\n}\n\nfloat sdCube(vec3 p){\n\tfloat r=0.7;\n\tvec3 q=abs(p)-r;\n\treturn length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat mainDist(vec3 p){\n\t\n\tfloat s=sdSphere(p);\n\tfloat c=sdCube(p);\n\treturn mix(s,c,cos(iTime*2.0)*0.5+0.5);\n}\n\nvec3 GetRayDir(vec2 uv,vec3 ro){\n\tvec3 f=normalize(vec3(0.0)-ro),\n\tr=normalize(cross(vec3(0.0,1.0,0.0),f)),\n\tu=cross(f,r),\n\tc=ro+f,\n\ti=c+uv.x*r+uv.y*u,\n\trd=normalize(i-ro);\n\treturn rd;\n}\n\nvec3 WorldToCube(vec3 p){\n\tvec3 ap=abs(p);\n\tvec3 sp=sign(p);\n\tfloat m=max(ap.x,max(ap.y,ap.z));\n\tvec3 st;\n\tif(m==ap.x)\n\t\tst=vec3(p.zy,1.0*sp.x);\n\telse if(m==ap.y)\n\t\tst=vec3(p.zx,2.0*sp.y);\n\telse\n\t\tst=vec3(p.xy,3.0*sp.z);\n\tst.x/=m;\n\tst.xy*=(1.45109572583-0.451095725826*abs(st.xy));\n\treturn st;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-2.5);\n\tvec3 rd=GetRayDir(uv,ro);\n\n\tfloat dO=0.0,dS;\n\tvec3 p;\n\n\tfor(float i=0.0;i<MAX_STEPS;i++){\n\n\t\tp=ro+rd*dO;\n\t\tdS=mainDist(p);\n\t\tdS=min(dS,-(length(p)-4.0));\n\t\tif(dS<EPS)break;\n\t\tdO+=dS;\n\t}\n\n\tvec3 col=WorldToCube(p);\n\n\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 61, 61, 121], [123, 123, 146, 146, 171], [173, 173, 194, 194, 287], [289, 289, 312, 312, 399], [401, 401, 433, 433, 587], [589, 589, 614, 614, 884], [886, 886, 939, 939, 1271]], "test": "untested"}
{"id": "ftf3WX", "name": "Babystepsrectangle", "author": "stephenhalker", "description": "Trying the old rectangle", "tags": ["beginner"], "likes": 1, "viewed": 23, "published": "Public", "date": "1623124636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv *=2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n   vec2 c = smoothstep(vec2(0.7),vec2(0.2),uv);\n   vec2 d = smoothstep(vec2(-0.4),vec2(-0.35),uv);\n      //  c*= smoothstep(0.4,0.2,uv.y);\n      ///  c*= smoothstep(-0.4,-0.2,uv.y);\n   float e =c.x*c.y*d.x*d.y;\n        \n    // Output to screen\n    fragColor = vec4(col*e,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftf3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 588]], "test": "untested"}
{"id": "ftj3WG", "name": "Cubic Shell with Slits", "author": "Kamoshika", "description": "I also posted this on NEORT.\nhttps://neort.io/art/c3aotts3p9f8s59beu00", "tags": ["raymarching"], "likes": 16, "viewed": 110, "published": "Public", "date": "1624614407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://twitter.com/kamoshika_vrc/status/1362976717350924290\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 rayPos = vec3(0, 0, 2);\n    vec3 col = vec3(0);\n    float d, a, e;\n    float c = 0.;\n    \n    for(float i = 0.;i < 99.;i++){\n        e = length(max(abs(rayPos) - .5, 0.)) - .1;\n        a = acos(rayPos.y / length(rayPos)) * 5. + sign(rayPos.z) * acos(rayPos.x / length(rayPos.zx));\n        a += iTime * 3.;\n        d = max(abs(e) - .05, sin(a * 3.) * .01);\n        if(d < 1e-4){\n            break;\n        }\n        rayPos += normalize(vec3(p, -2)) * d;\n        c++;\n    }\n    \n    if(e < 0.){\n        col = vec3(1., 1., 0.);\n    }else if(e < 0.3){\n        col = vec3(0., 0., 1.);\n    }\n    \n    fragColor = vec4(col * 30. / c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftj3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 122, 122, 849]], "test": "untested"}
{"id": "ftj3Wh", "name": "Raytracing: Class 6", "author": "spr", "description": "Our 9 spheres are _inside_ a large reflective sphere.\nClick and drag horizontally/vertically to move the outer large sphere in the x/z-direction.\n(The middle of the screen  (red sphere) is the neutral position; start from there!)", "tags": ["raytracing"], "likes": 2, "viewed": 57, "published": "Public", "date": "1623945124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXX 10000000.0\n\nfloat seed = 0.0;\n\nstruct Material {\nvec3 baseColor;      \nfloat metallic;      \nfloat subsurface;    \nfloat specular;      \nfloat roughness;     \nfloat specularTint;  \nfloat anisotropic;   \nfloat sheen;         \nfloat sheenTint;     \nfloat clearcoat;     \nfloat clearcoatGloss;\n};\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0-u, 0.0, 1.0);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.0) return 1.0/PI;\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a)\n{\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)\n{\n    return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG)\n{\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)\n{\n    return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y, Material m)\n{\n    //float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n    //float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n    //float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n    //float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n    ///float dot_ht\t= h_ts.x;\n    ///float dot_hb\t= h_ts.y;\n    \n    float NdotL = clamp(L.z, 0.0, 1.0); // dot(N,L);\n    float NdotV = clamp(V.z, 0.0, 1.0); // dot(N,V);\n    if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0, 0.0, 0.0);\n\n    vec3 H = normalize(L+V);\n    float NdotH = clamp(H.z, 0.0, 1.0); // dot(N,H);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0); // dot(L,H);\n    \n    float HdotX = H.x;\n    float HdotY = H.y; \n    \n\n    vec3 Cdlin = mon2lin(m.baseColor);\n    Cdlin = m.baseColor;\n    float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n    vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(m.specular*.08*mix(vec3(1), Ctint, m.specularTint), Cdlin, m.metallic);\n    vec3 Csheen = mix(vec3(1), Ctint, m.sheenTint);\n\n    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n    // and mix in diffuse retro-reflection based on roughness\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    float Fd90 = 0.5 + 2.0 * LdotH*LdotH * m.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n    \n    float fd_90_minus_1 = 2.0 * LdotH * LdotH * m.roughness - 0.5;\n    \n    Fd  = (1.0 + fd_90_minus_1 * pow(1.0 - NdotL, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - NdotV, 5.0));\n\n\n    // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n    // 1.25 scale is used to (roughly) preserve albedo\n    // Fss90 used to \"flatten\" retroreflection based on roughness\n    float Fss90 = LdotH*LdotH*m.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n    // specular\n    float aspect = sqrt(1.0-m.anisotropic*.9);\n    float ax = max(.001, sqr(m.roughness)/aspect);\n    float ay = max(.001, sqr(m.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, HdotX, HdotY, ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n    Gs = 1.0; \n    // sheen\n    vec3 Fsheen = FH * m.sheen * Csheen;\n\n    // clearcoat (ior = 1.5 -> F0 = 0.04)\n    float Dr = GTR1(NdotH, mix(.1,.001,m.clearcoatGloss));\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n    //return 1.0/PI * Fd*Cdlin * (1.0-m.metallic);\n    \n    return ((1.0/PI) * mix(Fd, ss, m.subsurface)*Cdlin + Fsheen)\n        * (1.0-m.metallic)\n        + Gs*Fs*Ds + .25*m.clearcoat*Gr*Fr*Dr;\n}\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    //return vec3(0.05, 0.05, 0.2);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n\n\n\n\n\n\nvec3 Rotate(in vec3 axis, in float angle, in vec3 v) \n{\n    return v*cos(angle) + cross(axis, v)* sin(angle) + axis*dot(axis, v)*(1.0-cos(angle));;\n}\n\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n    float radius;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\n\nconst int NUM_LIGHTS = 1;\nconst int NUM_SPHERE = 10;\nSphere spheres[NUM_SPHERE+NUM_LIGHTS];\nMaterial materials[NUM_SPHERE+NUM_LIGHTS];\nLight  lights[1];\n\nconst int special_sphere = NUM_SPHERE - 1;\nconst int light_sphere = NUM_SPHERE;\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n\n// Checks if the Ray origin is inside the sphere, and returns time when it intersects boundary.\nfloat raySpecialSphereIntersect(in Ray ray, in Sphere sphere) {\n    vec3 rayToSphere = ray.origin - sphere.center;\n        \n    float dist_from_center = dot(rayToSphere, rayToSphere);\n    float radius_squared = sphere.radius * sphere.radius;\n    \n    if(dist_from_center <= radius_squared)\n        return sqrt( dist_from_center + radius_squared);\n    else\n        return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray, bool shadow) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE+NUM_LIGHTS; i++) {\n       Sphere sphere = spheres[i];\n       \n       \n       float t=MAXX;\n       if(i==special_sphere)\n           {\n            if(!shadow)\n               t = raySpecialSphereIntersect(ray, sphere);\n           }\n       else {\n           if(!shadow || (i != light_sphere) )\n               t = raySphereIntersect(ray, sphere);\n       }\n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n \n// create 4 spheres at different locations in different colors\nvoid makeScene(int f, vec3 mouse_input) {\n    int count = 0;\n    float radius = 0.2;\n    float x = -0.5;\n    float y = -.5; \n    float z = -4.0;\n    // place 9 spheres in a grid with some separation\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            spheres[count] = Sphere(radius,vec3(x, y, z), vec3(0.0));\n            materials[count].baseColor = vec3(random(), random(), random());\n            x = x + (radius+0.3);\n            count++;\n        }\n        x = -0.5;  // reset x for the next row\n        z = z - (radius+0.5);\n        y = y + 0.3;\n    }\n    spheres[4].radius *= 1.5;\n    \n    // Sphere[NUM_SPHERE-1] is special. We are inside it.\n    \n    spheres[special_sphere] = Sphere(70.0, vec3(0, 0, -8.8)+mouse_input, vec3(1.0, 0.3, 0.3));\n   \n   \n    vec3 rotated_pos = Rotate(vec3(0,1,0), float(f)/80.-0.3, vec3(1.,0.,0.));    \n    vec3 light_pos = rotated_pos+vec3(0.0,.3,-3.6);\n    //vec3(x+.8-mod(float(f)/200.,2.), y-.5, z+5.- 2.*mod(float(f)/200.,2.5) );\n    vec3 light_col = vec3(1.);\n    float light_rad = 0.2;\n    lights[0] = Light(light_pos, light_col, light_rad);\n    spheres[light_sphere] = Sphere(light_rad*0.5,light_pos, light_col);\n\n\n\n    int l = 0;\n\n    materials[l].baseColor = vec3(0,1,0);\n    materials[l].metallic = 0.2; // .0; \n    materials[l].subsurface = 1.;\n    materials[l].specular = 0.2;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 0.4;\n    materials[l].anisotropic = 0.3;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.3;\n    materials[l].clearcoat = 0.4;\n    materials[l].clearcoatGloss = 0.5;\n    \n    \n    l = 1;\n    \n    materials[l].baseColor = vec3(1.,.1,0.2);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.4;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 1.0;\n    materials[l].anisotropic = 0.7;\n    materials[l].sheen = 0.3;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    l = 2;\n    \n    materials[l].baseColor = vec3(0., 0.0, 1.0);\n    materials[l].metallic = .0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.;\n    materials[l].roughness = 0.5;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.4;\n    materials[l].sheen = 0.3;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.;\n    \n    l = 4;\n    \n    materials[l].baseColor = vec3(1., 0.0, 0.0);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.5;\n    materials[l].specular = 0.0;\n    materials[l].roughness = 0.5;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    \n    l = 5;\n    \n    materials[l].baseColor = vec3(1., 1.0, 1.0);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.0;\n    materials[l].roughness = 1.0;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 0.0;\n    \n    \n    l = 6;\n    \n    materials[l].baseColor = vec3(0.,1.,1);\n    materials[l].metallic = 0.8; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 1.;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 1.0;\n    materials[l].anisotropic = 1.;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    l = 8;\n    \n    materials[l].baseColor = vec3(0.,1.,0);\n    materials[l].metallic = 0.8; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 1.;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 0.0;\n    \n    \n    \n    \n    //Outer sphere\n    l = 9;\n    \n    materials[l].baseColor = vec3(0., 0.0, 0.0);\n    materials[l].metallic = 1.; // .0; \n  \n}\n\n// samples per pixel\nconst int numSamples=10;\n\n// convert directionToLight and directionToView to tangent space\n//\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS)\n{\n    // use a matrix to convert\n    vec3 t = normalize(dFdx(hitPoint));\n    vec3 b = normalize(dFdy(hitPoint));\n    vec3 n = normalize(cross(t, b));\n    mat3 xformMatrix = transpose(mat3(t, b, n));\n    \n    toLightTS = xformMatrix * toLight;\n    toViewTS = xformMatrix * toView;\n    nTS = n;\n}\n\nfloat checkLightVisibility(in Light light, vec3 hitPoint, vec3 hitNormal) {\n    float visible = 0.;\n    vec3 lightDir = normalize(light.location - hitPoint);\n    Ray ray;\n    ray.origin = hitPoint+lightDir*0.01;\n    ray.direction = lightDir;\n    Intersection intersection = intersectAllObjects(ray, true);\n    int iSphere = intersection.obj;\n    if (iSphere == -1 || iSphere == light_sphere) { \n        // no object was hit, light is visible\n        visible = 1.0;\n    } \n    return visible;\n}\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n  \n   vec3 mouse_input = vec3( iMouse.z > 0. ? 4.*(iMouse.x/width - 0.5) : 0.,\n                            0.,\n                            iMouse.z > 0. ? 3.*(iMouse.y/height - 0.5) : 0.);\n   makeScene(iFrame, mouse_input);\n   \n   \n   \n\n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n              \n       \n       vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n              \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       bool check_for_shadows = false;\n       Intersection intersection = intersectAllObjects(ray, check_for_shadows);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       if(iSphere == -1){\n           samp += bgColor(ray.direction);\n           continue;\n       }\n       \n       Sphere sphere = spheres[iSphere];\n       \n       \n       vec3 hit = ray.origin + minT*ray.direction;\n       vec3 hitPointNormal = normalize(hit-sphere.center);\n       if(iSphere == special_sphere) hitPointNormal *= -1.;\n\n        \n       //If we hit the special sphere, we keep bouncing;\n       int NUM_BOUNCES = 100;\n       //To have correct \"shadows\" in the outer sphere, we have to remember the first ray hit\n       bool first_hit_special_sphere = iSphere == special_sphere;\n       vec3 first_hit = hit;\n       vec3 first_normal = hitPointNormal;\n       \n       if(iSphere == special_sphere){\n           for(int k=0; k<NUM_BOUNCES; ++k){\n               vec3 reflDir = ray.direction - 2.0*hitPointNormal*dot(ray.direction, hitPointNormal);\n\n               ray.origin = hit;\n               ray.direction = reflDir;\n\n               intersection = intersectAllObjects(ray, false);\n               iSphere = intersection.obj;\n               if(iSphere == -1) break;\n               \n               minT = intersection.t;\n               sphere = spheres[iSphere];\n\n               hit = ray.origin + minT*ray.direction;\n               hitPointNormal = normalize(hit-sphere.center);\n\n               if(iSphere != special_sphere) break;\n               else hitPointNormal *= -1.;\n       }}\n       \n       if (iSphere > -1 && iSphere < NUM_SPHERE) { // if there is an intersection\n       \n           // to get around iSphere not being constant\n           /* for (int i=0; i<NUM_SPHERE+NUM_LIGHTS; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           */\n           \n\n           // vector from intersection to light\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           vec3 hitPointToView = ray.origin-hit;\n           \n           vec3 toViewTS;\n           vec3 toLightTS;\n           vec3 nTS;\n           convertToTangentSpace(hitPointToLight, hitPointToView, hit, toLightTS, toViewTS, nTS); \n           vec3 h_ts \t\t= normalize(toLightTS + toViewTS);\n           float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n           float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n           float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n           float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n           float dot_ht\t= h_ts.x;\n           float dot_hb\t= h_ts.y;\n           Material m = materials[iSphere];\n           vec3 wi;\n           float lightPdf;\n      \n           float lightVisible;\n           if(!first_hit_special_sphere)\n               lightVisible = checkLightVisibility(lights[0], hit, hitPointNormal);\n           else\n               lightVisible = checkLightVisibility(lights[0], first_hit, first_normal);\n\n           vec3 brdf = BRDF(toLightTS, toViewTS, nTS, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), m);\n          \n           vec3 col = brdf*dot_nl*lightVisible;\n           vec3 toneMappedColor = col * (1.0 / (col + 1.0));\n           float gamma = 1.0/2.2;\n           vec3 finalColor = vec3(pow(toneMappedColor.x, gamma), \n                                  pow(toneMappedColor.y, gamma), \n                                  pow(toneMappedColor.z, gamma));\n\n           samp += finalColor; \n       } \n       else if(iSphere == light_sphere) {\n           samp += lights[0].color;\n       }\n       else{\n           samp += bgColor(ray.direction);\n       }\n\n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftj3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 493, 513, 513, 527], [529, 529, 560, 560, 652], [654, 654, 688, 688, 823], [825, 825, 859, 859, 951], [953, 953, 1030, 1030, 1116], [1118, 1118, 1163, 1163, 1267], [1269, 1269, 1352, 1352, 1433], [1435, 1435, 1457, 1457, 1524], [1527, 1527, 1591, 1888, 4420], [4423, 4423, 4450, 4450, 4592], [4598, 4631, 4647, 4647, 4694], [4702, 4702, 4757, 4757, 4851], [5506, 5546, 5602, 5602, 6045], [6048, 6144, 6207, 6207, 6522], [6524, 6610, 6666, 6666, 7305], [7308, 7371, 7412, 7412, 11646], [11695, 11763, 11886, 11917, 12179], [12181, 12181, 12256, 12256, 12674], [12676, 12755, 12810, 12810, 17769]], "test": "untested"}
{"id": "ftjGRt", "name": "Shimmering rainbow bubbles", "author": "jarble", "description": "These bubbles rise like balloons.", "tags": ["fractal", "wave", "sea", "bubble"], "likes": 4, "viewed": 136, "published": "Public API", "date": "1624499142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/4.)/4.0;\n    uv.y -= s1;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (uv.yx+vec2(uv.x/scale+uv.y/scale1,-uv.y/scale+uv.x/scale1)/scale)/scale1;\n            uv *= -scale1;\n            uv = fract((uv.yx+s1)/scale1);\n            //uv.y /= -scale1;\n        }\n        col[2] = (uv.y-uv.x);\n        col = (abs(col-col_prev.yzx))/1.125;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 735]], "test": "untested"}
{"id": "ftjGWV", "name": "anticore 26/06 shader jam", "author": "anticore", "description": "for livecode.demozoo.org party", "tags": ["raymarching", "shader", "jam"], "likes": 13, "viewed": 228, "published": "Public API", "date": "1624747537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 cam(vec3 ro, vec3 rd, vec2 uv) {\n  vec3 f = normalize(rd - ro);\n  vec3 l = normalize(cross(vec3(0,1,0), f));\n  vec3 u = normalize(cross(f, l));\n  \n  return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat ni(float a){\n    //return texture(texFFTIntegrated, a).x;\n    return iTime;\n}\n\n\nvoid mo(inout vec2 p,vec2 d){p = abs(p)-d;if(p.y>p.x)p=p.yx;}\nvec3 rep(vec3 p, vec3 c) { return mod(p + .5 * c, c) - .5 * c; }\nvec3 repl(vec3 p,vec3 c,vec3 l){return p-c*clamp(round(p/c),-l,l);}\nmat2 rot(float t) { return mat2(cos(t), sin(t), -sin(t), cos(t)); }\nfloat sdBox(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.); }\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdPlane(vec3 p, vec3 n, float h) { return dot(p,n) + h; }\nfloat rnd(float p) { p = fract(p * .131); p *= p + 333.33; return fract(2. * p * p); }\nfloat dirlight(vec3 n, vec3 ld) {\n  ld = normalize(ld);\n  return clamp(max(dot(n, ld), 0.), 0., 1.);\n }\nfloat spec(vec3 p, vec3 n, vec3 ld, float k) {\n    ld = normalize(ld);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    return pow(max(dot(r,n), 0.), k);\n}\nvec3 palette(float t) {\n    vec3 a= vec3(1);\n    vec3 b= vec3(1);\n    vec3 c = vec3(2);\n    vec3 d = vec3(0,.1, .2);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 ground(vec3 p) {\n    float plane = sdPlane(p, vec3(0,1,0), 0.);\n    float cracks = texture(iChannel0, p.xz * 0.05).r;\n    float crack = 0.28;\n  \n    return vec2(\n    plane + texture(iChannel1, p.xz * .7).r * 0.03\n      + texture(iChannel0, p.zx * 0.1).r * 1.\n      + texture(iChannel0, p.xz * 0.01).r * 4.,\n      \n       cracks > crack && cracks < crack + 0.01 ? 4 : 0\n    );\n}\n\n\nfloat bid;\nfloat tunnel(vec3 p) {\n    vec3 bp = p;\n    bp.xy *= rot(bp.z * 0.1);\n    mo(bp.xy, vec2(0.5));\n    mo(bp.zy, vec2(0.5));\n    bid = rnd(round(p.z + 0.5) * 120.);\n    float b = sdBox(rep(bp + vec3(-1.5, 0, 0), vec3(0, 0, 2)), vec3(0.1, 1.5, 0.1));\n    return b;\n}\n\n\nfloat sid;\nvec2 sphrs(vec3 p) {\n  p = p + vec3(0,0,-iTime - 7.);\n  p.xz *= rot(iTime);\n  p.yz *= rot(iTime);\n  sid = rnd(round(p.x - 0.75) * 10. + round(p.y - 0.75) * 20. +  round(p.z - 0.75) * 10.);\n  p = repl(p, vec3(.5), vec3(2));\n  float s = sdSphere(p + vec3(sin(iTime * 10. + p.x / 10.) * 0.05), .2 - abs(sin(sid * 60. + iTime)) * .15);\n  return vec2(s, fract(sid + iTime) < 0.9 ? 2 : 3);\n}\n\nvec2 map(vec3 p) {\n    float m = 999.;\n    float mm = 0.;\n    \n    vec2 g = ground(p);\n    if (g.x < m) { m = g.x; mm = g.y; }\n    \n    float t = tunnel(p);\n    if (t < m) { m = t; mm = 1.; }\n    \n    vec2 s = sphrs(p);\n    if (s.x < m) { m = s.x; mm = s.y; }\n    \n    return vec2(m, mm);\n}\nvec3 norm(vec3 p) {\n    float E = 0.01; vec2 k = vec2(1, -1);\n    \n    return normalize(\n      k.xyy * map(p + k.xyy * E).x +\n      k.yyx * map(p + k.yyx * E).x +\n      k.yxy * map(p + k.yxy * E).x +\n      k.xxx * map(p + k.xxx * E).x \n    );\n}\n\nvec3 bg(vec2 uv) {\n    float h = uv.y;\n    float n = texture(iChannel0, vec2(uv.x, uv.y - iTime * 0.05)).x;\n    float s = texture(iChannel0, uv * 6. + vec2(sin(iTime) + iTime, cos(iTime))).x > 0.45 ? 1. : 0.;\n  \n    return vec3(n * h*2. * palette(uv.y / 2.1));\n}\n\n\nvec3 ld = vec3(0, 30, 10);\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n    vec4 c = vec4(0);\n    vec4 g = vec4(0);\n    int bnc = 0;\n    float en = 1.;\n  \n    for (int i = 0; i < 1000; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x * 0.3;\n      \n        if (h.y == 1.) {\n            g += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * exp(-h.x * 10.) * .07, 1.);\n        }\n        \n        if (h.y == 3.) {\n          g += vec4(palette(sid / 10.) * exp(-h.x * 10.) * .07, 1.);\n        }\n        if (h.y == 4.) {\n          g += vec4(palette(0.63 + sin(ip.x / 10. + iTime * 0.2)) * exp(-h.x * 10.) * (.5 + abs(sin(ip.x + ip.z + iTime)) * .5), 1.);\n        }\n       \n      \n        if (h.x < 0.01) {\n          vec3 inorm = norm(ip);\n          \n          if (h.y == 0.) {\n              c += vec4(dirlight(inorm, ld) * palette(ip.y * 0.2 + 0.45) * en * 0.7 + spec(ip, inorm, ld, 20.), 1.) * en;\n           }\n           \n           if (h.y == 1.) {\n                c += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * en, 1.);\n           }\n           \n           if (h.y == 2.) {\n             c += vec4(0.2) * en;\n             ro = ip;\n             rd = reflect(rd, inorm);\n             td = .1;\n             bnc += 1;\n             en = max(en - .7, 0.);\n           }\n           \n           if (h.y == 3.) {\n               c += vec4(palette(sid / 10.) * en, 1.);\n            }\n            \n            if (h.y == 4.) {\n                c += vec4(0.9);\n            }\n        }\n        \n        if (td > 200.) {\n            return vec4(bg(uv) + vec3(g) * exp(-td * 0.05), td/1000.);\n        }\n      \n        if (c.a >= 1. || bnc > 1 || en < 0. || td > 1000.) break;\n    }\n    \n    return vec4((vec3(c) + vec3(g)) * exp(-td * 0.05), td/1000.);\n}\n\n/*\nvoid main(void)\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n\tvec3 ro = vec3(fract(t / 10) > 0.5 ? 10 : 0, 0, t);\n  vec3 rd = cam(ro, vec3(0,0,t + 10), uv);\n  out_color = tr(ro, rd, uv);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(fract(iTime / 10.) > 0.5 ? 10. : 0., 0., iTime);\n      vec3 rd = cam(ro, vec3(0,0,iTime + 10.), uv);\n    fragColor = tr(ro, rd, uv);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 199], [201, 201, 219, 264, 284], [287, 287, 316, 316, 348], [349, 349, 375, 375, 413], [414, 414, 446, 446, 481], [482, 482, 501, 501, 549], [550, 550, 579, 579, 664], [665, 665, 698, 698, 722], [723, 723, 763, 763, 786], [787, 787, 807, 807, 873], [874, 874, 907, 907, 977], [978, 978, 1024, 1024, 1146], [1147, 1147, 1170, 1170, 1312], [1314, 1314, 1335, 1335, 1696], [1710, 1710, 1732, 1732, 1972], [1986, 1986, 2006, 2006, 2371], [2373, 2373, 2391, 2391, 2663], [2664, 2664, 2683, 2683, 2908], [2910, 2910, 2928, 2928, 3172], [3202, 3202, 3238, 3238, 4970], [4972, 5287, 5344, 5394, 5689]], "test": "untested"}
{"id": "ftjGzW", "name": "gammatest2", "author": "hellotanjent", "description": "This shader generates test bars for calibrating your monitor against the sRGB standard and also serves as a torture-test for monitor response time. See code comments for details.", "tags": ["test", "gamma", "monitor", "calibration", "responsetime"], "likes": 3, "viewed": 42, "published": "Public", "date": "1623440176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader generates test bars for calibrating your monitor against the sRGB\nstandard and also serves as a torture-test for monitor response time.\n\nTo use, click the \"Go Fullscreen\" button at the bottom right of the shader and\nview the monitor from 3-5 feet away.\n\nIn a \"perfect\" result the color blocks will appear flat and motionless.\nIn a \"decent\" result the blocks will appear to have a faint wave pattern.\nIn a \"bad\" result will have very bright or dark waves.\n\nA monitor can be perfectly color-calibrated and still display waves in this test\n- the test is _very_ picky about the monitor is displaying _exactly_ what the\nGPU is sending it.\n\nThe following things will all cause the waves to be more visible:\n\n- Non-native resolution\n- Display scaling not at 100%\n- Non-sRGB color space\n- Compressed color signals like YUV422, YUV420 YCbCr422, YCbCr420, etcetera.\n- \"Limited\" dynamic range color output\n- Too-high or too-low contrast, brightness, or gamma\n- Very high refresh rates\n- \"Fastest\" monitor overdrive modes\n- GSYNC or FreeSync turned on (in some cases, not all)\n- Sharpening filters\n- Black stabilizer filters\n- Inter-pixel interference inside the panel itself (mostly on VA panels)\n\n*/\n\nfloat gamma(float x) {\n  x = clamp(x, 0.0, 1.0);\n  // srgb standard\n  x = (x < 0.0031308) ? 12.92 * x : (1.0 + 0.055) * pow(x, 1.0 / 2.4) - 0.055;\n  \n  // gamma 2.2\n  //x = pow(x, 1.0 / 2.2);\n  return x;\n}\n\nfloat bit(float x, int bit) {\n    x = fract(x * exp2(float(-bit - 1)));\n    return x < 0.5 ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Divide the screen into 7 vertical stripes and make each one a different color.\n    float barX = floor(7.0 * fragCoord.x / iResolution.x) + 1.0;\n    float r = bit(barX, 0);\n    float g = bit(barX, 1);\n    float b = bit(barX, 2);\n    vec4 barColor = vec4(r, g, b, 1.0);\n\n    // Make each horizontal region 1/2 the brightness of the one above it.\n    int barY = int(8.0 * fragCoord.y / iResolution.y);\n    barColor *= exp2(float(barY - 8));\n    \n    // Make a moving horizontal wave pattern with a bit of a flat top and bottom.\n    float waveX = sin((iTime * 2.7 + 15.0 * fragCoord.x / iResolution.x) * 2.0 * 3.14159);\n    waveX *= 1.05;\n    waveX = clamp(waveX * 0.5 + 0.5, 0.0, 1.0);\n\n    // Interpolate between the pure color and a \"checkerboard\" version of the color\n    // based on the wave pattern.\n    float checker = (bit(fragCoord.x, 0) + bit(fragCoord.y, 0)) == 1.0 ? 0.0 : 1.0;\n    \n    // Invert the checkerboard every other frame - this will cause the monitor's\n    // response time to have a huge effect on the wave visibility.\n    if ((iFrame & 1) == 0) checker = 1.0 - checker;\n    checker = checker * 2.0 - 1.0;\n\n    fragColor = mix(barColor, barColor + barColor * float(checker), waveX);\n    \n    // Convert from linear color to inverse-gamma-corrected color.\n    // When displayed on a calibrated monitor, this will turn back into linear color.\n    fragColor.r = gamma(fragColor.r);\n    fragColor.g = gamma(fragColor.g);\n    fragColor.b = gamma(fragColor.b);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1206, 1228, 1228, 1411], [1413, 1413, 1442, 1442, 1518], [1520, 1520, 1577, 1663, 3065]], "test": "untested"}
{"id": "ftl3Ws", "name": "I think i broke it", "author": "lmno", "description": "UH", "tags": ["2d", "sdf", "truchet", "distance", "parametrization"], "likes": 3, "viewed": 28, "published": "Public", "date": "1623119499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(1.12031, 1.103, 1.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy).x;\n}\n\nvec2 sdTruchet(in vec2 p) {\n    vec2 cId = floor(p);\n    vec2 cUv = fract(p) - 0.6;\n\n    cUv.x *= sign(Hash21(cId) - 0.5);\n    cUv -= cUv.x < -cUv.y ? -0.5 : 0.5;\n\n    float t = atan(cUv.y, cUv.x);\n    t *= sign(mod(cId.x + cId.y, 1.0) - 0.5);\n\n    return vec2(abs(length(cUv) - 0.9), t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.7 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0 + 0.25 * iTime;\n\n    vec2 truchet = sdTruchet(uv);\n    float d = truchet.x - 0.05;\n\n    // Nice colors from me\n    vec3 color = 12.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 0.5 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.3 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d) * 0.6));\n\n    if (d < 0.02) {\n        truchet.y -= 0.6 * iTime;\n        float fade = 0.5 + 0.5 * sin(iTime);\n        float vertStripes = abs(mod(d + 0.0333, 0.0666) - 0.0333);\n        float horiStripes = abs(mod(truchet.y + 0.1, 0.2) - 0.1) * 0.5;\n        color += fade * smoothstep(0.033, 0.0, min(vertStripes, horiStripes));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 114, 114, 252], [254, 254, 281, 281, 544], [546, 546, 601, 601, 1375]], "test": "untested"}
{"id": "ftlSzr", "name": "Simple function vizualizer", "author": "mrange", "description": "License CC0: Simple function vizualizer\nI had the need to visualize some functions so created a simple visualizer\nThought perhaps someone else could find use for it. I am sure examples\nalready exists on shadertoy but I didn't find them", "tags": ["2d", "simple"], "likes": 3, "viewed": 127, "published": "Public API", "date": "1625074992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----------------------------------------------------------------------------\n// License CC0: Simple function vizualizer\n//  I had the need to visualize some functions so created a simple visualizer\n//  Thought perhaps someone else could find use for it. I am sure examples\n//  already exists on shadertoy but I didn't find them\n// -----------------------------------------------------------------------------\n\n#define ZOOM 0.5\n#define TIME 1.0*iTime\n\n// f - the function that is visualized\nfloat f(float x) {\n  return sin(x)*sin(x*sqrt(0.5));\n}\n\n// -----------------------------------------------------------------------------\n\n// From: http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// From: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 df(vec2 p, float z, float aa) {\n  p /= z;\n  vec2 gp = p;\n  float m = aa*2.0;\n  float n = mod1(p.x, m);\n  float d = 1E3;\n  \n  const int reps = 3;\n\n  for (int i = -reps; i <= reps; ++i) {\n    float x0 = (n + float(i))*m + TIME*0.5;\n    float x1 = (n + float(i + 1))*m + TIME*0.5;\n  \n    float y0 = 0.5*f(2.0*x0);\n    float y1 = 0.5*f(2.0*x1);\n    \n    float dd = segment(p, vec2(-m*0.5 + m * float(i), y0), vec2(m*0.5 + m * float(i), y1))-2.0*aa/z;\n    \n    d = min(d, dd);\n  }\n  \n  gp.x += TIME*0.5;\n  mod1(gp.x, 0.5);\n  mod1(gp.y, 0.5);\n  float dgrid = min(abs(gp.x), abs(gp.y))-aa/z;\n  return vec2(d, dgrid)*z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  float aa = 2.0/iResolution.y;\n  \n  vec2 d = df(p, ZOOM, aa);\n \n  vec3 col = mix(vec3(0.05), vec3(0.1), q.y);\n  col = mix(col, vec3(0.5, 0.75, 1.0), smoothstep(-aa, aa, -d.y));\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d.x));\n  \n  col = pow(col, vec3(1.0/2.0));\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSzr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[455, 494, 512, 512, 548], [632, 669, 708, 708, 833], [835, 916, 955, 955, 1068], [1070, 1070, 1106, 1106, 1688], [1690, 1690, 1745, 1745, 2150]], "test": "untested"}
{"id": "ftS3DD", "name": "Capsule - distance L-inf 2", "author": "iq", "description": "Distance to an capsule in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. [b]This code is VERY innefficient[/url]. Feel free to simplifying this.", "tags": ["2d", "distancefield", "sdf", "capsule", "oriented", "linf"], "likes": 6, "viewed": 314, "published": "Public API", "date": "1623890994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a capsule in the L-infinity metric space. Compare\n// to euclidean: https://www.shadertoy.com/view/3tdSDj\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n// -------------------------------\n// THIS CODE IS VERY INNEFICIENT, RIGHT NOW IT'S DOING A BRUTE\n// FORCE COMPUTATION. SOME OTHER DAY I'll GIVE IT A TRY\n// -------------------------------\n\n\nfloat sdCapsule( in vec2 p, vec2 va, vec2 vb, float rb )\n{\n    // recenter primitive\n    p -= (vb+va)*0.5;\n    const float k = sqrt(0.5);\n    float l = length(vb-va);\n    vec2 u = (vb-va)/l;\n    vec2 v = vec2(-u.y,u.x);\n    l *= 0.5;\n    vec2 a = u*l;\n    vec2 w = v*rb;\n\n    // distance to body sides\n    float ss = (u.x*u.y>0.0)?1.0:-1.0;\n    float de = 1.0/(a.y+ss*a.x);\n    vec2 w1 = p-a-w;\n    vec2 w2 = p-a+w;\n    vec2 q1 = abs(w1+a*clamp(-(w1.y+ss*w1.x)*de, 0.0, 2.0));\n    vec2 q2 = abs(w2+a*clamp(-(w2.y+ss*w2.x)*de, 0.0, 2.0));\n    float d1 = max(q1.x,q1.y);\n    float d2 = max(q2.x,q2.y);\n    float d = min(d1,d2);\n\n    // inside circular caps\n    vec2 pa = p - a;\n    vec2 pb = p + a;\n    float da = dot(pa,pa);\n    float db = dot(pb,pb);\n    if( min(da,db)<rb*rb )\n    {\n        float s = 1.0; if( db<da ) {pa=pb;s=-1.0;}\n        float b1 = 0.5*(pa.x+pa.y);\n        float b2 = 0.5*(pa.x-pa.y);\n        float c = dot(pa,pa) - rb*rb;\n        vec2  t1 = vec2(-b1,b1)+sqrt(b1*b1-c*0.5);\n        vec2  t2 = vec2(-b2,b2)+sqrt(b2*b2-c*0.5);\n        // 4 solution. Up to 3 can be valid\n        if( s*dot(pa+vec2( 1, 1)*t1.x,-u)<0.0 ) d=min(d,t1.x);\n        if( s*dot(pa+vec2(-1,-1)*t1.y,-u)<0.0 ) d=min(d,t1.y);\n        if( s*dot(pa+vec2( 1,-1)*t2.x,-u)<0.0 ) d=min(d,t2.x);\n        if( s*dot(pa+vec2(-1, 1)*t2.y,-u)<0.0 ) d=min(d,t2.y);\n        d = -d;\n    }\n    // outside circular caps\n    else \n    {\n        vec2  qa = abs(mat2(u.x,-u.y,u.y,u.x)*p) - vec2(l,rb);\n        float di = max(qa.x, qa.y);\n        // outside circular caps AND outside of body\n        if( di>0.0 )\n        {\n            float dc;\n            \n            // first cap\n            pa = abs(pa);\n            if( abs(pa.y-pa.x)<rb )\n            {\n                float b = 0.5*(pa.x+pa.y);\n                float c = dot(pa,pa) - rb*rb;\n                dc = b - sqrt(b*b-c*0.5);\n            }\n            else\n            {\n                dc = max(pa.x,pa.y)-rb;\n            }\n            d = min(d,dc);\n\n            // sadly, we still need to test the second cap\n            pb = abs(pb);\n            if( abs(pb.y-pb.x)<rb )\n            {\n                float b = 0.5*(pb.x+pb.y);\n                float c = dot(pb,pb) - rb*rb;\n                dc = b - sqrt(b*b-c*0.5);\n            }\n            else\n            {\n                dc = max(pb.x,pb.y)-rb;\n            }            \n            d = min(d,dc);\n        }\n        d *= sign(di);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 1.9;\n    m *= 1.9;\n\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2  v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2  v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float ra = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    \n    float d = sdCapsule(p, v1, v2, ra);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    d = sdCapsule(m, v1, v2, ra);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3DD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1300, 1491, 1549, 1575, 3941], [3943, 3943, 3998, 3998, 4890]], "test": "untested"}
{"id": "ftS3Dt", "name": "Fake noise", "author": "marquizzo", "description": "Super simple noise-faking shader by using 3 cos() waves.", "tags": ["noise"], "likes": 3, "viewed": 56, "published": "Public", "date": "1624918154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float one;\n    one  = cos(iTime * 1.000 + distance(uv, vec2(0.0, 0.0)) * 8.0) * 0.5 + 0.5;\n    one += cos(iTime * 0.666 + distance(uv, vec2(1.0, 0.0)) * 8.0) * 0.5 + 0.5;\n    one += cos(iTime * 0.777 + distance(uv, vec2(0.5, 1.3)) * 8.0) * 0.5 + 0.5;\n    one = one / 3.0;\n\n    // Output to screen\n    fragColor = vec4(one, one, one, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 584]], "test": "untested"}
{"id": "ftS3Dy", "name": "Fissures", "author": "jarble", "description": "A metallic morphing fractal.", "tags": ["fractal", "metal", "shiny", "iridescent"], "likes": 2, "viewed": 119, "published": "Public API", "date": "1624573083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = .95;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/16.)/8.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx);\n            uv = (uv+vec2(s1-uv.x+uv.y)/scale);\n            //uv.x = scale;\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 607]], "test": "untested"}
{"id": "ftS3Dz", "name": "Fork Class5: Re qt1 881", "author": "qt1", "description": "Reflections + some minor animation", "tags": ["reflections"], "likes": 5, "viewed": 53, "published": "Public", "date": "1623745408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXX 10000000.0\n\nfloat seed = 0.0;\n\nmat3 zRotation(float angle) {\n    return mat3(cos(angle),  sin(angle), 0,\n                -sin(angle), cos(angle), 0,\n                0,           0,          1);\n}\n\nmat3 rotAxis(vec3 axis, float angle) {\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 tranformAroundCenter(mat3 transform, vec3 center, vec3 point) {\n    return center + transform * (point - center);\n}\n\nvec3 rotAxisCenter(vec3 axis, float angle, vec3 center, vec3 point) {\n    return tranformAroundCenter(rotAxis(axis,angle),center, point);\n}\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    //return vec3(0.05, 0.05, 0.2);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\nconst int NUM_SPHERE = 4;\nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\n// create 4 spheres at different locations in different colors\nvoid makeScene(int iFrame) {\n    spheres[0] = Sphere(1.0, vec3(0.2, 0, -7), vec3(1, 1, 0));\n    spheres[1] = Sphere(0.3, vec3(-0.4, -0.5, -2.5), vec3(1, 0, 0));\n    spheres[2] = Sphere(0.2, vec3(0, 0, -2), vec3(0, 1, 0));\n    spheres[3] = Sphere(0.8, vec3(1., 1, -5.5), vec3(0, 0, 1));\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1));\n    \n    float f = float(iFrame);\n    vec3 axis=vec3(0,0,1);\n    vec3 axis3=vec3(0,0,1);\n    float w1=0.01;\n    float w2=w1*1.1;\n    float w3=w1*1.3;\n    spheres[1].center = rotAxisCenter(axis, w1*f, spheres[0].center, spheres[1].center);\n    spheres[2].center = rotAxisCenter(axis, w2*f, spheres[0].center, spheres[2].center);\n    spheres[3].center = rotAxisCenter(axis3, w3*f, spheres[2].center, spheres[3].center);\n}\n\n// samples per pixel\nconst int numSamples=4;\n\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n  \n   makeScene(iFrame);\n   \n   //vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<1*numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       // ray Origin for is at (0, 0, 0)\n       vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       vec3 col = vec3(1.0, 1.0, 1.0);\n       for (int k=0; k<100; k++) { // 100 bounces\n       \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       Intersection intersection = intersectAllObjects(ray);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       Sphere sphere;\n       \n       if (iSphere > -1) { \n           // to get around iSphere not being constant\n           for (int i=0; i<NUM_SPHERE; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           \n           // hit coordinates\n           vec3 hit = ray.origin + minT*ray.direction;\n           // normal at the point of ray-sphere intersection\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 xnorm = hitPointNormal;\n           vec3 reflDir = ray.direction - 2.0*xnorm*dot(ray.direction, xnorm);\n           ray.origin = hit;\n           ray.direction = reflDir;\n           /****\n           // vector from eye to the intersection point\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           // cosine of the angle between ray and nornal\n           float angle = dot(hitPointNormal, hitPointToEye);\n           // use the cosine of the angle to modulate color for \n           // a simple diffuse shading effect\n           samp = samp + angle*sphere.color;\n           ***/\n           //samp = sphere.color;\n           col = col*(0.4*sphere.color+0.9*vec3(1,1,1)); \n       } \n       else {\n           samp = samp + col*bgColor(ray.direction);\n           break;\n       }\n   }\n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 73, 208], [210, 210, 248, 316, 788], [790, 790, 858, 858, 910], [912, 912, 981, 981, 1051], [1054, 1054, 1081, 1081, 1223], [1229, 1262, 1278, 1278, 1325], [1797, 1837, 1893, 1893, 2336], [2338, 2424, 2467, 2467, 2866], [2871, 2934, 2962, 2962, 3698], [3748, 3827, 3882, 4040, 6700]], "test": "untested"}
{"id": "fts3Wf", "name": "SunLollyVortex", "author": "darch", "description": "Shader made after workshop with Char Stiles", "tags": ["2d", "rgb", "cospalette"], "likes": 1, "viewed": 44, "published": "Public", "date": "1623008643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by sørenpeter (www.darch.dk) 06-06-2021\n\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm \n// to see this function graphed out go to: https://www.desmos.com/calculator/rz7abjujdj\nvec3 cosPalette( float t , vec3 brightness, vec3 contrast, vec3 osc, vec3 phase)\n{\n    return brightness + contrast*cos( 6.28318*(osc*t+phase) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0);\n    vec2 pos = uv;\n    pos *= clamp(sin(iTime*0.3),50.,.5); // change the clamp for zooming\n\n    float pos_t = iTime * 0.1 ;\n    pos.x -= sin(pos_t)*0.5;\n    pos.y += cos(pos_t)*0.5;\n    //pos.x = sin(cos(pos.y + iTime * 0.7) + pos.x + iTime * 0.2);\n    //pos.y = cos(pos.y + pos.x + iTime * 0.1);\n    \n    float rgb_t = iTime * 0.2 ;\n    float angle = atan(pos.y/pos.x);\n    float r = sin(angle + rgb_t);\n    float g = cos(length(pos)*10. - rgb_t);\n    float b = cos(angle + cos(length(pos)*10. + rgb_t));\n\n\n    vec3 brightness = vec3(0.3);\n    vec3 contrast = vec3(1.,0.5,0.1);\n    vec3 osc = vec3(0.3,0.5,0.1);\n    vec3 phase = vec3(0.5,0.3,0.9);\n    \n    float rgbMix = g+(b/r); // line\n    rgbMix /= g+(r/b); // vortex\n    color = cosPalette(rgbMix, brightness, contrast, osc, phase);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 199, 281, 281, 346], [348, 348, 405, 455, 1345]], "test": "untested"}
{"id": "ftS3WG", "name": "20210625_CLUB-CAVE-06", "author": "FMS_Cat", "description": "Originally written in Bonzomatic, in 45 minutes. Slightly modified afterward\n\nhttps://twitter.com/CLUBCAVE_/status/1406826707324051457?s=20", "tags": ["3d", "pathtracer", "livecoding", "quadtree"], "likes": 32, "viewed": 383, "published": "Public", "date": "1624555516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CAVE 06\n// 2021-06-24\n//\n// It's a pleasant rainy day.\n//\n// DJ: LateFair\n//\n// ENTER THE CAVE\n\n#define lofi(i,j) (floor((i)/(j))*(j))\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\nconst float PI=3.14159265;\nconst float EPSILON=1E-3;\nconst float TAU=PI*2.;\nconst float FAR=1E2;\n\nfloat time;\nfloat seed;\n\nfloat random(){\n  seed++;\n  return fs(seed);\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.99?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nvec3 randomSphere(){\n  float phi=TAU*random();\n  float theta=acos(2.0*random()-1.);\n  return vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));\n}\n\nvec3 randomLambert(vec3 n){\n  float phi=TAU*random();\n  float cosTheta=sqrt(random());\n  float sinTheta=sqrt(1.0-cosTheta*cosTheta);\n  return orthBas(n)*vec3(cos(phi)*sinTheta,sin(phi)*sinTheta,cosTheta);\n}\n\nfloat quadTree(vec2 p){\n  float mul=0.5;\n  for(int i=0;i<4;i++){\n    vec2 pt=lofi(p,mul);\n    float s=dot(vec2(11.2,22.3),pt);\n    s=fs(s)-0.1;\n    if(s>mul){\n      return mul;\n    }\n    mul*=0.5;\n  }\n  return mul;\n}\n\nfloat isectPlane(vec3 ro,vec3 rd,vec3 n){\n  float d=dot(ro,n)/dot(-rd,n);\n  return d<0.?FAR:d;\n}\n\nfloat drawPattern(vec2 p){\n  float hcell=lofi(p.x,0.5);\n  float phase=time+hcell;\n  p.y+=(cos(phase)+phase)/PI*cos(hcell*PI*2.0);\n  float q=quadTree(p);\n  vec2 cell=lofi(p,q);\n\n  p/=q;\n  p=fract(p);\n  p-=0.5;\n  p/=1.0-0.01/q;\n  \n  float r1=fs(dot(cell,vec2(12.3,44.5)));\n  float r2=fs(dot(cell,vec2(33.3,55.5)));\n\n  float sub=0.002/q;\n  \n  float ptn=1.0;\n  \n  if(r1<.3){\n    ptn*=smoothstep(0.5,0.5-sub,length(p));\n    ptn*=smoothstep(0.5-3.*sub,0.5-2.*sub,length(p));\n  }else if(r1<.6){\n    p=abs(p);\n    ptn*=smoothstep(0.5,0.5-sub,max(p.x,p.y));\n    ptn*=smoothstep(0.5-3.*sub,0.5-2.*sub,max(p.x,p.y));\n  }else if(r1<.8){\n    p=abs(p);\n    ptn*=smoothstep(0.5,0.5-sub,max(p.x,p.y));\n    ptn*=smoothstep(2.1*sub,1.4*sub,abs(p.x-p.y));\n  }else{\n    ptn*=0.0;\n  }\n  \n  float haha=0.5+0.5*sin(cell.x/4.0-2.0*time+4.0*r2);\n  ptn*=0.01+0.99*pow(haha,3.);\n  \n  return ptn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  time=iTime;\n  \n  seed=texture(iChannel0,8.0*uv).x;\n  seed+=fract(time);\n  \n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1.);\n  vec3 ro0=vec3(0,1,2);\n  \n  vec3 rd0=orthBas(vec3(0.05*sin(time)+0.5*sin(time/7.),0.05*cos(time),1.))*normalize(vec3(p,-1));\n  \n  for(int iS=0;iS<100;iS++){\n    colRem=vec3(1.);\n    vec3 ro=ro0;\n    vec3 rd=rd0;\n    rd.xy+=(vec2(random(),random())-.5)/iResolution.y*2.0;\n    vec3 fp=ro+mix(2.0,4.0,smoothstep(-0.5,0.5,sin(time/1.2)))*rd;\n    ro.xy+=0.05*randomSphere().xy;\n    rd=normalize(fp-ro);\n    \n    for(int iR=0;iR<4;iR++){\n      float dWall=isectPlane(ro,rd,vec3(0,0,1));\n      float dFloor=isectPlane(ro,rd,vec3(0,1,0));\n      float d=min(dWall,dFloor);\n      \n      if(d<FAR){\n        if(dWall<dFloor){\n          vec3 n=vec3(0,0,1);\n          ro=ro+rd*d+n*EPSILON;\n          rd=randomLambert(n);\n          float pattern=drawPattern(ro.xy);\n          col+=colRem*10.0*pattern;\n        }else{\n          vec3 n=vec3(0,1,0);\n          ro=ro+rd*d+n*EPSILON;\n          if(random()<0.04){\n            rd=reflect(rd,normalize(n+0.05*random()*randomSphere()));\n          }else{\n            rd=randomLambert(n);\n          }\n        }\n      }\n    }\n  }\n  \n  col/=100.;\n  col=pow(col,vec3(.4545));\n  col*=1.0-0.2*length(p);\n  col=vec3(\n    smoothstep(0.2,0.8,col.x),\n    smoothstep(0.0,1.0,col.y),\n    smoothstep(-0.2,1.2,col.z)\n  );\n\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 311, 326, 326, 357], [359, 359, 380, 380, 512], [514, 514, 534, 534, 666], [668, 668, 695, 695, 874], [876, 876, 899, 899, 1092], [1094, 1094, 1135, 1135, 1190], [1192, 1192, 1218, 1218, 2062], [2064, 2064, 2121, 2121, 3603]], "test": "untested"}
{"id": "fts3Wl", "name": "Eroded mountain terrain (v1)", "author": "jarble", "description": "A modified version of an FBM terrain demo, using a much simpler noise function.", "tags": ["noise", "terrain", "fbm", "mountain", "erosion"], "likes": 15, "viewed": 268, "published": "Public API", "date": "1623101324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    return vec2(sin(uv.x),cos(uv.y));\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        vec2 n1 = noise(uv * freq);\n        value += (.25-abs(n1.x+n1.y-.3) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.05;\n        \n        uv += uv.yx/16.0;\n        uv += (n1.yx)/freq;\n        uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n    rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 44, 84], [104, 104, 127, 127, 589], [591, 591, 611, 611, 657], [659, 659, 692, 692, 886], [888, 888, 955, 955, 1165], [1167, 1167, 1219, 1219, 1764], [1766, 1766, 1817, 1817, 2018], [2020, 2020, 2046, 2046, 2122], [2190, 2190, 2247, 2247, 4094]], "test": "untested"}
{"id": "ftS3zD", "name": "Neon curve", "author": "SimpleMurad", "description": "Neon curve.", "tags": ["line", "sinusoid", "neon"], "likes": 14, "viewed": 342, "published": "Public", "date": "1623412128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistancePointToLine(vec2 p, vec2 A, vec2 B)\n{\n        float l2 = distance(A, B);\n        l2 *= l2;\n        if (l2 == 0.0f) \n            return distance(p, A);  \n                                                       \n        float t = max(0.0f, min(1.0f, dot(p - A, B - A) / l2));\n        vec2 projection = A + t * (B - A); \n        return distance(p, projection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //[-1;1]\n    vec2 uv = fragCoord/(iResolution.xy /2.0)-1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 col;\n    float dx = 0.1;\n    for (float x = -1.5f-dx; x<=1.5f+dx; x+=dx){\n        vec2 lineA_1 = vec2(x, cos((x+iTime)*4.0f)/5.0f);\n        vec2 lineB_1 = vec2(x+dx, sin((x+iTime+dx)*3.0f)/5.0f);\n        float p = DistancePointToLine(uv, lineA_1, lineB_1);\n        \n        col += vec3(0.01f/p)*vec3(abs((cos(iTime)+1.0)/5.0f),0.2f,0.7f);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 372], [374, 374, 431, 444, 927]], "test": "untested"}
{"id": "ftS3zG", "name": "The Dark Mark [HP]", "author": "Yusef28", "description": "Inspiration: [url]https://pottermore.fandom.com/wiki/The_Dark_Mark_(object)?file=Screenshot_-_10_5_2013_%252C_3_57_20_PM.png[/url]\nOriginal Cloud Shader: [url]https://www.shadertoy.com/view/MljXDw[/url]\n", "tags": ["clouds", "sky", "volumetric", "snake", "glow", "stars", "night", "scary", "skull", "teeth", "harrypotter", "schadel", "darkmark", "schlange"], "likes": 35, "viewed": 712, "published": "Public", "date": "1624119167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\nfloat glow = 0.;\nfloat glow2 = 0.;\n// iq's noise\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p*0.05, vec2(14.52, 76.38)))*43256.2895);   \n}\n\nvec3 hash13( float n )\n{\n    vec3 m = n*vec3(23.0,41.0,17.0) + vec3(9.0,1.0,31.0);\n    return fract( m*fract( m*0.3183099 ) );\n}\n\n\n\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(vec2 st)\n    {\n    float f = noise(st)*1.;st*=2.02;\n     f += noise(st)*0.5;st*=2.04;\n     f += noise(st)*0.25;st*=2.03;\n     f += noise(st)*0.125;st*=2.04;\n     f += noise(st)*0.0625;///st*=2.01;\n    \nreturn f;\n}\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n#define FAR 55.\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n// https://www.shadertoy.com/view/tl23RK\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\n\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.02;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n    \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\nfloat snake(vec3 pos)\n{\n    //the max distance so this is a blank world before\n    //I start adding in torus\n    float alle = 100.;\n    //theta, sin and cos for rotation\n    float th, si, cs;\n    vec3 p; //tmp position\n\n     //Snake going through eye hole because that's edgy\n     //translate pos\n     p=pos+vec3(0.3,0.,.3);\n     th = 1.14;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     //th = 1.14;\n     //cs = cos(th), si = sin(th);\n     //p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.14;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     float an = 1.9;\n     //c is how that is applied to the torus \n     vec2 c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     float tmp = sdCappedTorus(p, c, .2, 0.1);\n     //add it in\n     alle = min(alle, tmp);\n     \n     //Snake going through mouth because that's edgy\n     //translate pos\n     p=pos+vec3(0.15,0.29,.5);\n     th = -1.;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -.4;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 2.4;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 3.;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .25, 0.08);\n     //add it in\n     alle = min(alle, tmp);\n     \n     //Snake going through eye hole because that's edgy\n     //translate pos\n     p=pos+vec3(-0.25,0.85,.2);\n     th = -0.4;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -0.6;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.5;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 2.;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .29, 0.06);\n     //add it in\n     alle = min(alle, tmp);\n        \n        \n     //Tail (h)whip\n     //translate pos\n     p=pos+vec3(-0.35,1.1,.3);\n     th = 3.8;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = 0.;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = 1.5;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 1.9;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .25, 0.03);\n     //add it in\n     alle = min(alle, tmp);\n     \n     pos.y+=0.05;\n     //Upper Body\n     //translate pos\n     p=pos+vec3(-0.5,0.3,.27);\n     th = 1.2;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = 3.;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = -0.1;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 2.4;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .19, 0.1);\n     //add it in\n     alle = min(alle, tmp);\n     \n     \n     \n     //Neck Head\n     //translate pos\n     p=pos+vec3(-0.5, -0.03, .53);\n     th = 1.6;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     \n     th = -.7;\n     cs = cos(th), si = sin(th);\n     p.xy = mat2(cs, si, -si, cs)*p.xy;\n          \n     th = .3;\n     cs = cos(th), si = sin(th);\n     p.yz = mat2(cs, si, -si, cs)*p.yz;\n     \n     // an is like how long the torus is out of pi = 100% , or something        \n     an = 1.2;\n     //c is how that is applied to the torus \n     c = vec2(sin(an),cos(an));\n     // make torus (position, length, outer radius, inner radius\n     tmp = sdCappedTorus(p, c, .2, 0.12);\n     //add it in\n     alle = smin(alle, tmp, 0.07);\n     \n     \n     pos*=0.9;\n     th = .0;\n     cs = cos(th), si = sin(th);\n     pos.yz = mat2(cs, si, -si, cs)*pos.yz;\n     \n     //shere for head\n     p=pos+vec3(-0.47, -0.17, .52);\n     \n     th = -.2;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     tmp = length(p)-0.25;\n     alle = smin(alle, tmp,0.03);\n     \n     \n     //shaping the head with minus sheres\n     p=pos+vec3(-0.5, -0.1, .59);\n     \n     th = -.1;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     p.x = abs(p.x)-0.13;\n     tmp = length(p)-0.218;\n     alle = smax(alle, -tmp, 0.05);\n     \n     p=pos+vec3(-0.5, -0.28, .7);\n     tmp = length(p)-0.03;\n     alle = smin(alle, tmp, 0.05);\n     \n     \n     //shaping the head with minus sheres\n     p=pos+vec3(-0.5, -0.1, .5);\n     \n     th = -.1;\n     cs = cos(th), si = sin(th);\n     p.xz = mat2(cs, si, -si, cs)*p.xz;\n     tmp = length(p)-0.2;\n     alle = smax(alle, -tmp, 0.05);\n     \n    //jaw\n    p=pos;\n    th = -.14;\n    p.y+=sin(p.z*30.-.6)/40.;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    tmp = knochen(p, vec3(0.4, 0.26, -.65), vec3(0.08, 0.01, 0.14), \n                -1.2, -0.35, -0., 0., 0.0);\n    alle = smin(alle, tmp, 0.1);\n    \n    //teeth / zhane\n    //upper\n    p=pos;\n    th = -.17;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    \n    tmp = knochen(p, vec3(0.38, 0.22, -.78), vec3(0.005, 0.04, 0.005), \n                -0., -0., -0., 0.04, 0.0);\n    alle = smin(alle, tmp, 0.01);\n    //lower\n    p=pos;\n    th = -.17;\n    cs = cos(th), si = sin(th);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    tmp = knochen(p, vec3(0.38, 0.22, -.7), vec3(0.005, 0.05, 0.005), \n                -0., -0., -0., 0.04, 0.0);\n    alle = smin(alle, tmp, 0.01);\n    \n    return alle;\n}\nfloat map(vec3 p){\n    \n    float PosX, PosY;\n    PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);\n    PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;\n    \n    p.z+=1.;\n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    \n\tp*=0.6;\n    \n    p.y-=0.2;\n    \n\n    \n    vec3 sp = p;\n    float k = length(sp*vec3(1., 0.95, 0.9)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    \n    //schadel seite\n    sp = p;\n    sp.x = abs(sp.x) - 0.65;\n    k = length(sp - vec3(0., -0.05, -0.28)) - 0.3;\n    alle = smax(alle, -k, 0.09);\n\n    \n    \n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.05 - 0.04 , \n                        -0.48 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., 0., 0.14, 0.04);\n    alle = smin(alle, k, 0.09);\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.15, -0.22), vec3(0.005, 0.005, 0.25), \n                -0.5, 0., 0., 0.28, 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.48), vec3(0.005, 0.08, 0.02), \n                0.0, 0.0, 0.1, 0.3, 0.01);\n    alle = smin(alle, k, 0.07);\n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.45), vec3(0.13, 0.06, 0.05), \n                -0.3, -0.1, -0.2, 0.15, 0.03);\n    alle = smin(alle, k, 0.1);\n    \n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.33, -0.32), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.32 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.05);\n    \n    float zahnNum = 12.;\n    //cyl oben\n    sp = p - vec3(0., -0.43, -0.4);\n    k = sdCappedCylinder(sp, 0.17\n                         + cos(sp.y*12. -5.3)*0.05\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.06 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02);\n    alle = smin(alle, k, 0.08);\n    \n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*5.4, 24, 1.);\n    float zahn = k;\n    \n    \n    \n\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.16;\n    float loche = length(sp - vec3(0., -0.14, -0.4)) - 0.16;\n    alle = smax(alle, -loche, 0.07);\n    \n    //gluende augen\n    //sp = p;\n    //sp.x = abs(sp.x) - 0.16;\n    //float augen = length(sp - vec3(0., -0.22, -.65)) - 0.04;\n    //alle = min(alle, augen);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    //KEIFER / JAW\n    \n    PosY = 0.4;\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    p.y-=0.08;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.54, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.14, 0.1), \n                0.0, -0.45, -0.25, 0.32, 0.01);\n    alle = smin(alle, k, 0.05);\n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.69, -0.34), vec3(0.012, 0.04, 0.22), \n                -0.3, -0.5, 0., 0.22, 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.74, -0.53), vec3(0.05, 0.04, 0.015), \n                0., 0., 0., 0., 0.03);\n    alle = smin(alle, k, 0.09);\n    \n    \n    //cyl unten\n    sp = p - vec3(0., -0.68, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.08 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    alle = smin(alle, k, 0.06);\n    \n  \n    //unten zahn\n    sp = p - vec3(0.0, -0.58, -0.4);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*5.6, 24, -1.);\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, 0, 0);\n    alle =  smin(zahn,alle, 0.09);\n    \n    float ball_of_subtraction = length(p-vec3(0., -0.32, -0.2))-0.34;\n    alle = max(alle, -ball_of_subtraction);\n    \n    //if(min(augen, alle) == augen){\n    alle = min(alle, snake(p));\n    alle += fpn(p*100.+iTime*10.) * (0.03+0.03*sin(iTime));\n    \n    glow += abs(max(0.0001,(0.0001/(0.0075*pow((alle),.7 - 0.2*sin(iTime))))));//* (.5-augen*1.5);\n    //}\n    return alle;\n}\n\nfloat augenMap(vec3 p, float alle){\n\nfloat PosX, PosY;\n    //PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);\n    //PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;\n    \n    //p.z+=1.;\n\n    //float alle = 100.;\n\tp*=0.8;\n    //p.y-=0.2;\n//gluende augen\n    vec3 sp = p;\n    //sp.x = abs(sp.x) -1.2;\n    float augen = length(sp - vec3(-1.2, 0.2, 5.94)) - 0.1;\n    alle = min(alle, augen);\n    if(min(augen, alle) == augen){\n        glow2 += abs(max(0.0001,(0.00005/(0.005*pow((augen),1.)))));//* (.5-augen*1.5);\n    }\n    \n    //snake eye\n    sp=p+vec3(1.3, -0.41, .51);\n    sp.x = abs(sp.x)-0.15;\n    float tmp = length(sp)-0.001;\n    if(min(tmp,alle) == tmp){\n    //glow2 += abs(max(0.0001,(0.00005/(0.005*pow((tmp),1.)))))/4.;//* (.5-augen*1.5);\n    \n    }\n    alle = min(alle, tmp);\n    \n    return alle;\n}\n\n\n\n/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((gl_FragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   vec2 uv = (gl_FragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./64.) {\n       //break if you either\n       //get through all the loop calls, the total density is 95%  or more Y\n       // or both\n       //don't break only if both conditions are not met Y\n\t   if(!((i<1.) && (td < .95)))\n\t\t   break;\n      // evaluate distance function\n       //l for length to point\n       \n       //why take only 50% of the length?Y\n      l = map(p) * 0.55;\n      \n      \n      const float h = .025;\n       \n       // check whether we are close enough (step)\n      // compute local density and weighting factor\n       //if distance to point \"l\" is less than h, (step(h, l) would be the opposite Y\n       //h - l meaning difference between threshold and length\n       //that equals the \"local density\"\n       // otherwise local density = 0\n       //local density is relative to the threshhold 0.05.\n       //l will always be less than h, based on the step condition,\n       \n      ld = (h - l) * step(l, h);\n       \n       //total density\n       //density will be like how dark solid(colored in) the cloud is Y\n       //td will always be less than 0.95 based on the break condition\n      w = (1. - td) * ld;   \n     \n      //accumulate color and density\n      tc += w; // * hsv(w, 1., 1.); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.003);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }  \n    \n    \n   vec3 lookAt = vec3(.0, -1.0, .0);\n    \n    vec3 campos = lookAt + vec3(0., .0, -4.);\n    \n\n    \n   // lookAt.xy += path(lookAt.z);\n   // campos.xy += path(campos.z);\n    \n   // light1.xy += path(light1.z);\n\t//light2.xy += path(light2.z);\n    //I've ommitted adding path to the lights because it seems redundant\n    //although it does make a difference somehow.\n    \n    float FOV = 3.14/3.;//is a bit more than one so multiplying this by right and up in ray\n    //direction increases those vector components (x and y) so it kinda stretches the screen\n    //so you can see more.\n    vec3 forward = normalize(lookAt - campos);\n    vec3 right = normalize(vec3(forward.z, 0.0, 0.0));//don't really need -forward.x?\n    \t\t\t\t\t\t\t//pretty cool using forward.z as the x component in this vector\n    vec3 up = cross(forward, right);\n    \n    \n    vec3 rd = normalize(forward + FOV*right*uv.x + FOV*up*uv.y);\n  //  rd.xy*=rot(iTime);\n    //rd.yz*=rot(-1.8);\n    \n    \n    float t = 0.0, dt;\n    for(int i = 0;i<128; i++)\n    {\n        dt = augenMap(campos + rd*t,td);\n    if(dt<0.005 || t > 150.){break;}\n    \n    t += dt*0.75;\n    }\n    \n   #ifdef SCATTERING\n   // simple scattering approximation\n   tc *= 1. / exp( ld * 0.4 ) * 1.5;\n   #endif\n   \n   \n   vec2 st = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n   vec3 sky = vec3(.0);\n   sky = mix(vec3(0.,0.1,0.0),sky, uv.y);\n   sky += vec3(step(0.99,hash(fragCoord/10.0)));\n   \n   st.x/=2.;\n   st.x+=iTime/16.;\n   vec3 skyGrad = mix(vec3(0., 0., 0.2),vec3(0.2,0.7,0.3),uv.y*2.);\n   float cloud = 0.04+fbm(st*4.+fbm(st*2.)/2.)*(noise(st));\n   sky = mix(sky, vec3(6.0)+skyGrad, clamp(cloud,0., 1. ));\n   \n   \n   //sky += fpn(uv.xyx+iTime*10.);\n   vec3 col  = mix(tc*vec3(0.3,0.7,0.37)+0.2 + glow/800. + glow2, sky, 1.0-tc.x);\n   //gamma\n   \n   col = pow(col,vec3(1.5));\n   \n   uv.x*=0.95;\n   uv.y*=1.2;\n   float baumen = 1.0-smoothstep(0.8, 0.85, length(uv)-fbm(vec2(atan(uv.y/uv.x)*9.,length(uv))+sin(iTime/5.))/5.);\n   col *= baumen;\n   //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "ltlXRs", "previewfilepath": "https://soundcloud.com/user-17441338/forest-at-night-crickets-owls-rain-wind-in-trees-nature-sounds-to-relax-stud", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-17441338/forest-at-night-crickets-owls-rain-wind-in-trees-nature-sounds-to-relax-stud", "ctype": "musicstream"}, {"id": "lllSzs", "previewfilepath": "https://soundcloud.com/thebirthdaymassacre/black", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thebirthdaymassacre/black", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 532, 552, 552, 621], [623, 623, 647, 647, 751], [755, 755, 778, 778, 996], [998, 1081, 1103, 1103, 1242], [1243, 1325, 1347, 1347, 1753], [1754, 1754, 1778, 1778, 1977], [1979, 1979, 1998, 1998, 2061], [2079, 2079, 2130, 2130, 2237], [2238, 2238, 2278, 2278, 2385], [2386, 2386, 2426, 2426, 2533], [2535, 2576, 2646, 2646, 2786], [2787, 2787, 2901, 2901, 3299], [3301, 3301, 3359, 3359, 3899], [3901, 3901, 3927, 3927, 4140], [4305, 4366, 4389, 4474, 10714], [10715, 10715, 10733, 10733, 15892], [15894, 15894, 15929, 15929, 16730], [16734, 16889, 16946, 17007, 21208]], "test": "untested"}
{"id": "ftS3zh", "name": "Simple ocean waves", "author": "jarble", "description": "A simple ocean animation based on a procedural terrain demo.", "tags": ["waves", "sea", "fbm", "ocean"], "likes": 7, "viewed": 207, "published": "Public API", "date": "1623293043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    uv.x -= iTime/2.0;\n    return sin(uv.x);\n}\n\n#define OCTAVES 4\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-abs(noise(uv * freq)-.3) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 3.+1./3.;\n        \n        uv += uv.yx/10.0;\n        //uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z);\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 92], [112, 112, 135, 135, 605], [607, 607, 627, 627, 673], [675, 675, 708, 708, 902], [904, 904, 971, 971, 1181], [1183, 1183, 1235, 1235, 1780], [1782, 1782, 1833, 1833, 2034], [2036, 2036, 2062, 2062, 2138], [2141, 2141, 2198, 2198, 3930]], "test": "untested"}
{"id": "ftsGDl", "name": "Voxel Fractal City [2TC]", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["voxel", "city", "tiny", "2tc"], "likes": 9, "viewed": 236, "published": "Public API", "date": "1623125489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n  ivec4 b = ivec4(c -= c);\n  for(;(b.x&=b.y^b.z-99)%99>b.z-64;)\n    b = ivec4(p/iResolution.xy*2.*c.z - c.z + iTime*vec2(49, 9), c += .1);\n  c = sin(float(b))*.5 +8e2*vec4(b%8)/c/c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 220]], "test": "untested"}
{"id": "ftsGWB", "name": "Simple Bitfield test", "author": "grufkork", "description": "Found a post talking about generating patterns with simple mathematical functions, and thought it would be perfect to make a shader out of. Crazy how maths works...", "tags": ["bitfield"], "likes": 6, "viewed": 169, "published": "Public API", "date": "1622746890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float divisor = 9.; // Try different values here!\n    \n    int x = int(fragCoord.x / 3. + iTime * 10.);\n    int y = int(fragCoord.y / 3. + iTime * 5.);\n            \n    float a = mod(float(x ^ y), divisor);\n\n    // Output to screen\n    fragColor = vec4(vec3(a),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 330]], "test": "untested"}
{"id": "ftSGWt", "name": "Sun Tracks", "author": "DrNoob", "description": "Inspired by this long exposure photograph by Martin Cann:\nhttps://twitter.com/MartinCann1/status/1408139994972278788", "tags": ["noise", "fbm", "oklab"], "likes": 32, "viewed": 291, "published": "Public", "date": "1624909848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Thomas Stehle\n// Title: Sun Tracks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by this long exposure photograph by Martin Cann:\n// https://twitter.com/MartinCann1/status/1408139994972278788\n\n// Constants\nconst vec3 INNER = vec3(131, 118, 117) / 255.0;\nconst vec3 OUTER = vec3(  1,  34,  46) / 255.0;\nconst vec3 SUN   = vec3(224, 229, 180) / 255.0;\nconst vec3 GLOW  = vec3(247, 251, 238) / 255.0;\n\nconst int NLINES     = 100;\nconst float NLINES_F = float(NLINES);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// OKLAB-based color mixing by iq\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix( vec3 colA, vec3 colB, float h ) {\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(\n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    \n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    \n    // gain in the middle (no oaklab anymore, but looks better?)\n    // lms *= 1.0+0.2*h*(1.0-h);\n    \n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 distort(in vec2 p) {\n    vec2 q = 0.8 * p + vec2(-0.2, 0.2);\n    float amp = -0.4;\n    float freq = 1.0 + 4.0 * q.y;\n    float phase = 0.0;\n    return vec2(q.x, q.y + amp * sin(freq * q.x + phase));\n}\n\nfloat suntracks(in vec2 p) {\n    vec2 st = vec2(p.x, p.y * NLINES_F);\n    st.y = max(st.y, 0.1 * NLINES_F);\n    st.y = min(st.y, 0.55 * NLINES_F);\n    \n    vec2 gv = vec2(st.x, fract(st.y));\n    float id = floor(st.y);\n    int idx = int(id);\n    \n    float r1 = hash(13.1 * float(idx));\n    float r2 = hash(37.3 * float(idx));\n    \n    float speed = 0.25 + 0.25 * r2;\n    \n    const float W = 0.25;\n    float d = sdOrientedBox(gv, vec2(-1.0, 0.5), vec2(2.0, 0.5), W);\n    float n = vfbm(vec2(30.0 * (gv.x + id) - speed * iTime, 0.0));\n    d += 0.25 * r2 + smoothstep(0.55, 0.65, n);\n\n    return d;\n}\n\nfloat foreground(in vec2 p) {\n    vec2 q = vec2(p.x, p.y + 0.2 * vfbm(10.0 * p));\n    const float W = 0.25;\n    return sdOrientedBox(q, vec2(-1.0, 0.0), vec2(2.0, 0.0), W);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordinate normalization\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n\n    // Background\n    float bg = pow(10.0 * length(0.15 * uv - vec2(0.075, 0.1)), 1.5);\n    vec3 col = oklab_mix(INNER, OUTER, clamp(bg, 0.0, 1.0));\n    \n    // Foreground\n    float fgd = foreground(uv);\n    fgd = smoothstep(0.15, 0.1, fgd);\n    col = mix(col, vec3(0.05), fgd);\n    \n    // Distort\n    vec2 p = distort(uv);\n    \n    // Fade out factors\n    float fade = smoothstep(0.75, 0.25, length(p - vec2(0.5))); // Fade out to the sides\n    \n    // Sun tracks\n    float td = suntracks(p);\n    td  = smoothstep(0.5, -0.5, td) * fade;\n    td *= smoothstep(0.05, 0.2, uv.y); // Additional fade out near bottom\n    col = mix(col, SUN, clamp(td, 0.0, 1.0));\n    \n    // Gas tracks\n    float n = vfbm(2.0 * p - vec2(0.15 * iTime, 0.0));\n    n *= (1.0 - fgd);\n    col = oklab_mix(col, SUN, pow(n, 3.0));\n    \n    // Glow\n    float gl = vnoise(2.0 + sin(1.5 * iTime) * p);\n    gl  = pow(gl, 2.0) * fade;\n    gl *= smoothstep(0.7, 0.4, p.y) * smoothstep(-0.1, 0.2, p.y); // Additional fade in sun space\n    gl *= smoothstep(0.05, 0.2, uv.y); // Additional fade in screen space\n    col = mix(col, GLOW, clamp(gl, 0.0, 1.0));\n    \n    // Add animated noise\n    float r = hash31(vec3(fragCoord.xy, fract(0.001 * iTime)));\n    col.rgb += 0.1 * vec3(r - 0.5);\n    \n    // Vignetting\n    // https://www.shadertoy.com/view/lsKSWR\n    vec2 st = uv * (vec2(1.0, ar) - uv.yx);\n    float vig = st.x * st.y * 10.0;\n    col *= pow(vig, 0.2);\n    \n    // Final color\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[532, 614, 638, 638, 721], [723, 805, 830, 830, 948], [950, 974, 999, 999, 1102], [1104, 1181, 1206, 1206, 1660], [1662, 1775, 1798, 1798, 2135], [2137, 2212, 2261, 2308, 3081], [3083, 3083, 3147, 3147, 3360], [3362, 3362, 3387, 3387, 3567], [3569, 3569, 3597, 3597, 4168], [4170, 4170, 4199, 4199, 4344], [4346, 4346, 4401, 4433, 6025]], "test": "untested"}
{"id": "ftSGzd", "name": "Superposition of Waves", "author": "Kamoshika", "description": "I analytically determined the normal vector of the waves.", "tags": ["waves", "wave"], "likes": 10, "viewed": 103, "published": "Public", "date": "1624461188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://twitter.com/kamoshika_vrc/status/1407268416277282817\n\nconst float PI2 = acos(-1.)*2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 n = vec2(0);\n    \n    float N = ceil(mod(iTime, 10.));\n    for(float i = 0.; i < 10.; i++){\n        if(i >= N){\n            break;\n        }\n        float a = i / N * PI2;\n        vec2 q = (uv - vec2(cos(a), sin(a)) * 0.6) * 50.;\n        float R = length(q);\n        float T = iTime * 10.;\n        float c = 0.05;\n        n += q * (sin(R - T) * c - cos(R - T)) * exp(-R * c) / R;\n    }\n    \n    vec3 lightDir = normalize(vec3(-1, 2, 5));\n    vec3 normal = normalize(vec3(n, 1));\n    \n    float s = max(dot(lightDir, normal), 0.);\n    vec3 col = vec3(pow(s, 60.) + s * 0.7);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 155, 155, 858]], "test": "untested"}
{"id": "ftSGzz", "name": "2d-Isolinea--v1", "author": "jorge2017a1", "description": "2d-Isolinea--v1", "tags": ["2disolineav1"], "likes": 0, "viewed": 26, "published": "Public", "date": "1623184619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia\n//https://iquilezles.org/www/articles/distance/distance.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n  \n\n//Corrected by FabriceNeyret2,\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = distObj > 0. ? colOut : pColObj;\n  colOut = mix(colOut,vec3(0) ,smoothstep( fwidth(distObj), 0., abs(distObj) ));\n  return colOut;\n}\n\n/*\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n*/\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat f(vec2 x)                                 \n{\n    float r = length(x);\n    float a = atan(x.y,x.x);\n    return r - 1.0 + 0.5*sin(3.0*a+2.0*r*r);\n}                                                   \n\nvec2 grad( vec2 x )\t\t\t\t\t\t\t\t\t\t\t\t \n{\n    float r = length(x);\n    float a = atan(x.y,x.x);\n    vec2 da = vec2(x.y,-x.x)/(r*r);\n    return (x/r) + (1.5*da+2.0*x)*cos(3.0*a+2.0*r*r);\n}\n\n\nfloat colorIsolinea( in vec2 x )\n{\n    float v = f( x );\n    vec2  g = grad( x );\n    float de = abs(v)/length(g);\n    float eps =1.0; /*size_of_a_pixel*/;\n    return smoothstep( 1.0*eps, 2.0*eps, de );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv*=1.5;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float cisl1=colorIsolinea(uv);\n    col= ponerBorde(vec3(0.5), col, cisl1 );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 272, 308, 308, 353], [358, 389, 450, 450, 594], [596, 789, 849, 849, 975], [977, 977, 1027, 1027, 1128], [1181, 1181, 1215, 1215, 1361], [1364, 1364, 1398, 1398, 1568], [1570, 1570, 1627, 1677, 2020]], "test": "untested"}
{"id": "ftX3DS", "name": "Circle demo1", "author": "sean1998", "description": "show circle", "tags": ["2d", "circle"], "likes": 1, "viewed": 133, "published": "Public API", "date": "1622769917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 uv, vec2 center, in float radius){\n    vec2 dist = uv - center;\n\treturn 1.-smoothstep(radius-(radius*0.01), radius+(radius*0.01), dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //scale up\n    uv = uv * 20.0 - 10.0;    \n    float f = fract(length(uv));\n    vec3 col = vec3(f, sin(f + iTime), cos(f + iTime));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 173], [175, 175, 232, 282, 514]], "test": "untested"}
{"id": "ftXGDs", "name": "Ray Marching - Distance", "author": "ChaosOfZen", "description": "A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/", "tags": ["raymarching", "sphere"], "likes": 0, "viewed": 20, "published": "Public", "date": "1623075950", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n \nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere. xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasn’t hit an object it also breaks out of the loop.\n*/\n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/ Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    float d = RayMarch(ro,rd); // Distance\n    d/= 10.;\n    vec3 color = vec3(d);\n     \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 136, 159, 159, 374], [377, 842, 877, 877, 1133], [1137, 1137, 1194, 1194, 1500]], "test": "untested"}
{"id": "NdjGDz", "name": "Teeth1", "author": "dirkadirkadan", "description": "sdf for tooth types", "tags": ["teeth"], "likes": 2, "viewed": 39, "published": "Public", "date": "1624572132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n\nfloat max_distance = 30.0;\nfloat epsilon = 0.015;\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere (vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat molar(vec3 p, vec3 pos) {\n    p = p-pos;\n    \n    float main = sdSphere(p, 1.25);\n    \n    float cusp1 = sdEllipsoid(p-vec3(.39, .39, .69), vec3(.6, .9, .53));\n    float cusp2 = sdEllipsoid(p-vec3(-.59, .39, -.69), vec3(.6, .9, .53));\n    float cusp3 = sdEllipsoid(p-vec3(-.59, .39, .69), vec3(.6, .9, .53));\n    float cusp4 = sdEllipsoid(p-vec3(.19, .39, .69), vec3(.6, .9, .53));\n\n    float d = main;\n    d = smin(d, cusp1, 0.2);\n    d = smin(d, cusp2, 0.2);\n    d = smin(d, cusp3, 0.2);\n    d = smin(d, cusp4, 0.2);\n    return d;\n}\n\nfloat de(vec3 p)\n{\n    return molar(p, vec3(0.));\n}\n\nfloat march(vec3 start_pos, vec3 ray_dir)\n{\n\tfloat d = 0.0;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 ray_pos = start_pos + ray_dir*d;\n\t\tfloat s = de(ray_pos);\n\t\t\n\t\td += s;\n\t\tif (s < epsilon)\n\t\t\treturn d;\t\n\t}\n\t\n\treturn max_distance;\n}\n\nvec3 getNormal(vec3 point)\n{\n  float d0 = de(point);\n  float dX = de(point - vec3(epsilon, 0.0, 0.0));\n  float dY = de(point - vec3(0.0, epsilon, 0.0));\n  float dZ = de(point - vec3(0.0, 0.0, epsilon));\n\t\n  vec3 r = vec3(dX-d0, dY-d0, dZ-d0);\n  return normalize(r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy -iResolution.xy) / iResolution.y;\n    \n    float angle = iMouse.x * 4.*3.1416 / iResolution.x;\n    \n    float k = .6;\n    float f = 20.;\n    float h = .8;\n    \n    angle = -(k/f)*cos(f*iTime)+h*iTime;\n    \n    float ca = cos(angle);\n    float sa = sin(angle);\n    \n    mat2 rot = mat2(ca, -sa, sa, ca);\n\t\n\tvec3 eye_pos = vec3(0.0, 0.0, 3.75);\n    eye_pos.xz = rot*eye_pos.xz;\n\t\n\tvec3 ray_dir = vec3(uv, -1.);\n    ray_dir.xz = rot*ray_dir.xz;\n\n\tfloat d = march(eye_pos, ray_dir);\n\tvec3 point = eye_pos + ray_dir*d;\n    \n    vec3 normal = getNormal(point);\n\n\tvec3 color = .2+vec3(1.)*clamp(dot(normal, ray_dir), 0., 1.);\n    color = mix(color, vec3(.4), 1.-exp(-.01*d*d));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 126, 126, 247], [249, 249, 286, 286, 369], [371, 371, 405, 405, 431], [433, 433, 474, 474, 567], [569, 569, 600, 600, 1109], [1111, 1111, 1129, 1129, 1162], [1164, 1164, 1207, 1207, 1405], [1407, 1407, 1435, 1435, 1674], [1677, 1677, 1734, 1734, 2474]], "test": "untested"}
{"id": "Nl23Dy", "name": "- Sphere Rotation -", "author": "Mihaha", "description": "...", "tags": ["2d", "3d", "sphere", "circle", "vignette", "rotation"], "likes": 1, "viewed": 134, "published": "Public API", "date": "1624874196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n> by MihasGames, 25.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.9);\n    float t = iTime*3.5;\n    \n    // Pixel Normalizations //\n    vec2 uv101 = fragCoord.xy/iResolution.xy,\n         uv = (uv101 - 0.5) * vec2(iResolution.x / iResolution.y, 1);\n   \n    float rotate_radius = (cos(t/7.)*0.5+0.5)*0.3 + 0.7; \n    vec2 sphere_position = vec2(sin(t)*0.55, cos(t)*0.2-0.04);\n    float sphere_size = ((cos(t)*0.5+0.5)*0.4*rotate_radius+0.6/rotate_radius)*0.45;\n    \n    if (sqrt(length( uv + sphere_position*rotate_radius )) < sphere_size) col = vec3(uv.xy/-3.+0.5, 1.);\n\n    // Vignette //\n    uv = uv101 * (1. - uv101);    \n    col *= pow(uv.x*uv.y * 25., 0.07);\n        \n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl23Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 127, 127, 785]], "test": "untested"}
{"id": "Nl2GRt", "name": "Emoji_wxy", "author": "wxy", "description": "Hello shadertoy!\n(learned from BigWIngs)", "tags": ["learn"], "likes": 4, "viewed": 75, "published": "Public", "date": "1624501524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Part 1 - Creating the Smiley \n// Part 2 - Animating the Smiley \n\n#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile) {\n    float offs = mix(.2, 0., smile);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile);\n    uv.x -= mix(.0, .1, smile);\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n   \tfloat d1 = length(uv);\n    float s1 = S(.45, .45-blur, d1);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    colMask *= smile;\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n   \n    uv.y += .15-offs*.5;\n    blur += mix(.0, .1, smile);\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile) {\n    uv -= .5;\n    uv.x *= side;\n    \n\tfloat d = length(uv);\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5);\t\t// gradient in eye-white\n    col.a = S(.5, .48, d);\t\t\t\t\t\t\t\t\t// eye mask\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5*sat(-uv.y-uv.x*side); \t// eye shadow\n    \n    d = length(uv-m*.4);\t\t\t\t\t\t\t\t\t// offset iris pos to look at mouse cursor\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); \t\t// iris outline\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\t\t\t\t\t\t// iris lighter in center\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\t\t\t// blend in iris\n    \n    d = length(uv-m*.45);\t\t\t\t\t\t\t\t\t// offset pupile to look at mouse cursor\n    \n    float pupilSize = mix(.4, .16, smile);\n    float pupilMask = S(pupilSize, pupilSize*.85, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\t\t// blend in pupil\n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-smile);\n    \n    uv += offs;\n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\t\t\t// blend in highlight\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*(1.-smile);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv) {\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n    \n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25, -.2));\n    float cheek = S(.2,.01, d)*.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile) {\n\tvec4 col = vec4(0.);\n    \n    if(length(uv)<.5) {\t\t\t\t\t// only bother about pixels that are actually inside the head\n        float side = sign(uv.x);\n        uv.x = abs(uv.x);\n        vec4 head = Head(uv);\n        col = mix(col, head, head.a);\n\n        if(length(uv-vec2(.2, .075))<.175) {\n            vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n            col = mix(col, eye, eye.a);\n        }\n\n        if(length(uv-vec2(.0, -.15))<.3) {\n            vec4 mouth = Mouth(within(uv, vec4(-.3, -.43, .3, -.13)), smile);\n            col = mix(col, mouth, mouth.a);\n        }\n\n        if(length(uv-vec2(.185, .325))<.18) {\n            vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)), smile);\n            col = mix(col, brow, brow.a);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x<-.49 && m.y<-.49) {\t\t\t// make it that he looks around when the mouse hasn't been used\n    \tfloat s = sin(t*.5);\n        float c = cos(t*.38);\n        \n        m = vec2(s, c)*.4;\n    }\n    \n    if(length(m) > .707) m *= 0.;\t\t// fix bug when coming back from fullscreen\n    \n    float d = dot(uv, uv);\n    uv -= m*sat(.23-d);\n    \n    float smile = sin(t*.5)*.5+.5;\n\tfragColor = Smiley(uv, m, smile);\n\n    //if(fragColor.x==0.&&fragColor.y==0.&&fragColor.z==0.)\n    //if(fragCoord.z ==0.)\n    //    fragColor+=vec4(.5,.5,1.,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2GRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 208, 250, 250, 278], [280, 280, 338, 338, 378], [380, 380, 413, 413, 455], [457, 457, 490, 490, 1463], [1465, 1465, 1517, 1517, 2787], [2789, 2789, 2823, 2823, 3352], [3354, 3354, 3374, 3374, 4026], [4028, 4028, 4071, 4071, 4870], [4872, 4872, 4929, 4929, 5656]], "test": "untested"}
{"id": "Nl2GWy", "name": "Spherical Shell with Slits (3)", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/Nt2GWy[/url]\nantialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. [url]https://shadertoy.com/view/Nt2GWG[/url]", "tags": ["raymarching", "sphere", "short"], "likes": 11, "viewed": 172, "published": "Public API", "date": "1624629631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/Nt2GWy\n// antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. https://shadertoy.com/view/Nt2GWG\n\n\n                                      // distance to strips + AA blending\n#define S(s) P = vec3(0, 0, 5) + ( s sqrt(r) - b ) * D,                    \\\n             a = acos(P.y/2.) - sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n             d = sin(a/.1),   d =  1.- d/fwidth(d),                        \\\n             O += ( clamp(1.+ s abs(d-1.),0.,1.) -O ) * clamp( d, 0.,1. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3  P = iResolution,\n          D =  normalize( vec3( ( u+u - P.xy ) / P.y, -2 ) );\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    r > 0. ? S( ), // *(1.+P.z/3.),   // back sphere  \n             S(-)                     // front sphere\n           : O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2GWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 555, 593, 593, 859]], "test": "untested"}
{"id": "NlB3Rz", "name": "Voxel Fractal in 127 Bytes", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["fractal", "voxel", "tiny", "1tc"], "likes": 16, "viewed": 329, "published": "Public API", "date": "1623183432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n  for(ivec4 b = ivec4(c -= c); (b.x^b.y&b.z)%99 > b.z-9;)\n    b = ivec4((p/5e2-.5)*c.a + iTime/.1, ++c);\n  c /= 99.;\n}\n\n/* smaller version that may not work on some machines\n\nvoid mainImage(out vec4 c,vec2 p){\nfor(ivec3 b;(b.x^b.y&b.z)%99>b.z-9;)\nb=ivec3((p/5e2-.5)*c.a+iTime/.1,c++);\nc/=99.;}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 155]], "test": "untested"}
{"id": "NlB3WK", "name": "Cubic Bezier and Derivative", "author": "Yusef28", "description": "A Cubic Bezier Derviative Visualization\nfor every t it should be 3*([the bezier of p2,p3,p4 at t] minus [the bezier of p1,p2,p3 at t])\nwhere p1,p2,p3,p4 are p's from the cubic. \nCorrect me if I'm wrong anyone.\n\nFrom: https://pomax.github.io/bezierinfo/\n\n", "tags": ["bezier", "derivative", "cubic", "casteljau", "hodograph"], "likes": 4, "viewed": 51, "published": "Public", "date": "1624747528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n//For this one I also found this:https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/bezier-der.html\n//to be helpful\n\n//Also this example of a 1 dimentional cubic bezier\n// was very helpful\n//I thought there had to be some mistake when every source\n//said you have to multiply the difference by n because\n//when I did that the curve \"looked wrong\" but it was just scaled\n//properly according to the gradient \n\n\n//Looks Legit according to:\n//https://www.google.com/imgres?imgurl=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~sequin%2FCS284%2FIMGS%2Fbezier_hodograph.gif&imgrefurl=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~sequin%2FCS284%2FLECT12%2FL3.html&tbnid=OrMwiwUL8Pr-yM&vet=12ahUKEwiO_YvSxLTxAhXMWKwKHf2jDZcQMygKegUIARDKAQ..i&docid=Mu9GR-_iDH6WNM&w=1083&h=594&q=bezier%20curve%20derivative%20example&ved=2ahUKEwiO_YvSxLTxAhXMWKwKHf2jDZcQMygKegUIARDKAQ\n\n#define numSegments 20.\n#define showSeg\n/*\n//black and light blue\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n#define lineThickness 0.004\n#define gradLineThickness 0.004*3.\n#define segRingRadius 0.006\n#define gradRingRadius 0.03\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float th){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - th);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9),lineThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//find tangent\nvec3 drawTangentLine(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t, vec3 col){\n    vec2 g1,g2,beforeT, afterT;\n    float EPS = 0.001;\n    \n    float t0 = max(t-EPS,0.);\n    float t1 = min(t+EPS,1.);\n    \n    \n    g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n    g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n\n\n    //get the direction so I can extend the line\n    vec2 dir = normalize(g2-g1);\n    \n    //extend the line in both directions past the end of screen\n    g1 += dir*10.;\n    g2 += dir*(-10.);\n    \n    //draw that line\n    col = drawLine(g1,g2,p,col,segCol*vec3(t, .7, .9),lineThickness);\n    return col;\n}\n   \n//derivative segment function\n//n-1 order bezier \nvec3 drawBezierDerivative(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g1,g2,gEnd, prev = p1;\n    float dt = 1./numSegments;  \n    \n    //this could be wrong\n    float t = 0.;\n    //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n    //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n    //prev = g2-g1;\n    \n    prev = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n    prev*=3.;\n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n        //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n        //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n\n        gEnd = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n        //(g2-g1);\n        gEnd*=3.;\n        col = drawLine(prev,gEnd,p,col,segCol*vec3(t, .7, .9),gradLineThickness);\n        col = drawRing(gradRingRadius, .003, p, gEnd, col, segCircleCol);\n        \n        prev = gEnd;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 st = uv;\n    uv.y*=2.;\n    \n    //splitting screen into two sides\n    float side = step(0.,uv.x);\n    uv.x = mod(uv.x*2.,2.)-1.;\n    \n    float x =0.4, y=1.2, z=2.6, w=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+x),cos(iTime/2.+x))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+y),cos(iTime+y))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+z),cos(iTime+z))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+w),cos(iTime/2.+w))/2.;\n    \n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n   \n    \n    vec3 col = bgCol;\n    col = drawLine(vec2(0.,-1.),vec2(0., 1.),st,col,lineCol*0.,lineThickness);\n    //col = drawLine(vec2(-2.,0.),vec2(2.,0.),st,col,lineCol*0.);\n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n    if(side == 0.){\n    col = drawLine(p1,p2,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7,lineThickness);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7,lineThickness);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol,lineThickness);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, magikCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, magikCol);\n    \n    \n    col = drawSegments(uv, p1, p2, p3, p4, col);\n    \n    //Marker\n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, dddPoint, col, magik_farber);\n    \n    \n    col = drawTangentLine(uv, p1, p2, p3, p4, t, col);\n   }\n   else{\n   \n   //scaling up the space so all of the derivative shows up\n   uv*=3.;\n   col = vec3(0.1);\n   col = drawBezierDerivative(uv,p1,p2,p3,p4,col);\n   \n   //calculating the derivative again just for the marker\n   vec2 g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n   vec2 g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n   \n   //vec2 gEnd = g2-g1; <- this works too btw but you need *3. after!\n   vec2 gEnd; \n   \n   //second more compact way\n   gEnd = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n   //(g2-g1);\n   \n   gEnd*=3.;\n   \n   col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, gEnd, col, magik_farber);\n    \n   }\n   col = pow(col, vec3(0.75));\n    \n   \n\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1259, 1677, 1718, 1718, 1920], [1923, 1923, 2010, 2010, 2242], [2244, 2244, 2318, 2389, 2523], [2526, 2646, 2718, 2718, 4141], [4143, 4158, 4242, 4242, 4790], [4795, 4845, 4925, 4925, 5765], [5767, 5767, 5824, 5874, 9282]], "test": "untested"}
{"id": "NlB3zw", "name": "Spin things", "author": "Vinicius_Jesus", "description": "test...", "tags": ["rotate", "spin"], "likes": 5, "viewed": 100, "published": "Public", "date": "1623530944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 spin(vec2 uv,float t){\n\treturn vec2(uv.x*cos(t)-uv.y*sin(t),uv.y*cos(t)+uv.x*sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; //-1 <> 1\n\n\tuv=spin(uv,iTime);\n    \n    vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\tfloat s=0.1;\n\tfor(int i=0;i<5;i++){\n\t\tuv=abs(uv)-s;\n\t\tuv=spin(uv,cos(iTime));\n\t}\n\n    vec3 col = vec3(0.);\n\n    col += vec3(0.03/abs(uv.x) + abs(uv.y));\n    col *= color;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 92], [94, 94, 151, 151, 516]], "test": "untested"}
{"id": "NlBGRd", "name": "2D Fluid Rotation Visualizer", "author": "ccincotti3", "description": "Positive '2d-curl' in our case signifies fluid rotation in the counter clockwise direction\nGreen represents positive 2d-curl, red is negative.\nThe bright squares are where there is 0 2d-curl, and thus there is no rotational aspect.", "tags": ["fluid", "curl", "calculus", "multivariable"], "likes": 2, "viewed": 64, "published": "Public", "date": "1624729705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 field(vec2 uv) {\n    float y = uv.y;\n    float x = uv.x;\n    float v1 = pow(y, 3.) - 9.*y; // x component of vector field\n    float v2 = pow(x, 3.) - 9.*x; // y component of vector field\n    return vec2(v1, v2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col;\n\n    \n    // BACKGROUND\n    vec2 v = field(uv);\n    \n    // -- Take derivatives with respect to x and y\n    float dv1 = dFdy(v.x);\n    float dv2 = dFdx(v.y);\n    \n    // -- calculate '2d curl'\n    float c = dv2 - dv1;\n    \n    // -- build background\n    // Positive '2d-curl' in our case signifies flow in the counter clockwise direction\n    // Green represents where we find positive 2d-curl.\n    // Red represents where we find negative 2d-curl.\n\n    float pos = sign(c);\n    if(pos > 0.) {\n        col = vec3(c, 1., c); // green background\n    } else {\n        col = vec3(1., abs(c), abs(c)); // red background\n    }\n    \n    // FLOW\n    vec2 p = uv*10.+0.5; // create grid\n    vec2 fp = fract(p)-0.5; // uv coords WITHIN each box 0.5 <> 0.5\n    vec2 id = floor(p); // coords OF each box (x,y)\n\n\n    // This was the result of playing around until something looked nice\n    // The janky animation was fixed by just speeding everything up.\n    for(int y=-10;y<=10;y++){\n        for(int x=-10; x<=10;x++) {\n            vec2 offs = vec2(x, y);\n            vec2 w = field(id);//id+offs);\n            vec2 nw = normalize(w);\n            \n            float d = length(fp-offs-nw*1.*mod(iTime, .1)/0.1);\n            float m = smoothstep(1., 0.1, d);\n            col -= m*0.8;\n        }\n    }\n    \n    // grid lines to make the bad animation be less in your face.\n    if(fp.x > .43 || fp.y > .43) {\n        col = vec3(.2);\n    }\n\n    col = pow( col, vec3(1.0/2.2) );\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 218], [220, 220, 277, 277, 1843]], "test": "untested"}
{"id": "Nlf3Wj", "name": "Expanding and Shrinking Tiles", "author": "wildniklin", "description": "Quick project in 2 minutes", "tags": ["tiles"], "likes": 6, "viewed": 213, "published": "Public API", "date": "1622806044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415;\n\nvoid mainImage(out vec4 o, vec2 i) {\n    float a = 1.0 / min(iResolution.x, iResolution.y);\n    a *= 10.0;\n    vec2 uv = (i - (0.5 * iResolution.xy)) * a;\n    \n    vec2 d = floor(uv);\n    vec2 f = uv - d;\n    f = abs(f - 0.5);\n\n    float value = cos((d.x + 0.5) * PI * 0.25) * sin((d.y + 0.5 + (iTime * 4.0)) * PI * 0.25);\n    \n    float size = (value * 0.25) + 0.25;\n\n    float r = smoothstep(size, size - a, f.x) * smoothstep(size, size - a, f.y);\n\n    o = vec4(r, r, r, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 62, 62, 506]], "test": "untested"}
{"id": "NlfGDs", "name": "Ray Marching - Diffuse Light", "author": "ChaosOfZen", "description": "A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/", "tags": ["raymarching", "sphere", "color"], "likes": 1, "viewed": 36, "published": "Public", "date": "1623076711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n \nfloat GetDist(vec3 p) \n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasn’t hit an object it also breaks out of the loop.\n*/ \n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\n/*\n\nNormals\nTo get the normals the point where the raymarch hits is used and a small amount (Epsilon) \nis added to the point in the right, up and forward direction. This new offset point is \nthen normalized to turn it into a unit vector/direction.\n*/\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n    vec3 n = d - vec3(\n    GetDist(p-e.xyy),  \n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n   \n    return normalize(n);\n}\n\n/*\nDiffuse light (Directional)\nTo calculate diffuse light, the angle between the surface normal and the light vector \nfrom a raymarched point is used. To get the angle, the Dot product is used which returns \nthe angle in a -1 <> 1 range. So when the light vector is perpendicular to the normal \nvector the Dot product is 1 and if its parralel to the normal vector it is 0.\n*/\n\nfloat GetLight(vec3 p)\n{ \n    // Light (directional diffuse)\n    vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n \n    return dif;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n   \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n    d *= .2;\n    vec3 color = vec3(0);\n    color = vec3(dif);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 215, 239, 239, 454], [457, 846, 881, 881, 1137], [1139, 1391, 1415, 1415, 1614], [1616, 1993, 2017, 2053, 2354], [2358, 2358, 2415, 2415, 2843]], "test": "untested"}
{"id": "NlfGWs", "name": "Soft Flesh SDF", "author": "ENDESGA", "description": "more tests", "tags": ["3d", "raymarching", "distancefield", "sdf"], "likes": 0, "viewed": 140, "published": "Public API", "date": "1623072626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    d1 *= -1.0;\n    return (d1 > d2) ? d1 : d2;\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat opSmoothUnion(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n    //k *= 0.15;\n    //return max(a, (a + k - abs(b))*sqrt(0.5));\n    /*float n = 4.0;\n    if ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.0);\n\t\tif (mod(n,2.0) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}*/\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nvec3 rotate(vec3 uv, float th) {\n  return vec3(mat2(cos(th), sin(th), -sin(th), cos(th)) * uv.xy, uv.z);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    //float d = 0.0, d2 = 0.0;\n    p = rotate(p,iTime);\n    const float phi = (1.+sqrt(5.))*.5;\n    p = abs(p);\n    p += phi*p.zxy;\n    return ((max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.));\n    //r *= 2.0;\n    //d2 = ((max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.)) * 0.1;\n    //return length(vec2(d, d2)) - 0.02;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//---------------------------------\n\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime) * 2.5;\n    \n    // opSmoothUnion\n    {\n    vec3 q = pos - vec3(0.0,0.0,1.0);\n    float d1 = sdSphere( q-vec3(0.0,2.5+0.3*an,0.0), 2.5 );\n    float d2 = sdRoundBox(q - vec3(0.0,-4.0,0.0), vec3(4.5,4.0,1.0), 0.1 ); \n    float dt = opSmoothSubtraction(d1,d2, 3.0) - 0.2;\n    d = min( d, dt );\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 7777777.7777;\n    float t = tmin;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res * 0.777, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.1, 4.0, 32.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.5,0.0,0.25)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot += tot * 0.25;\n    tot *= tot * tot * tot * tot * tot;\n\n\tfragColor = vec4( tot * 2.0, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfGWs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1138, 1702, 1739, 1739, 1764], [1766, 1766, 1809, 1809, 1859], [1861, 1861, 1905, 1905, 1930], [1932, 1932, 1957, 1957, 1997], [1999, 1999, 2039, 2039, 2160], [2162, 2162, 2210, 2210, 2993], [2995, 2995, 3053, 3053, 3131], [3133, 3133, 3192, 3192, 3268], [3270, 3270, 3302, 3302, 3376], [3378, 3431, 3472, 3503, 3795], [3798, 3798, 3843, 3843, 3934], [3936, 3974, 3998, 3998, 4367], [4369, 4433, 4465, 4465, 4699], [4701, 4763, 4850, 4850, 5126], [5143, 5143, 5200, 5200, 6530]], "test": "untested"}
{"id": "Nlj3Dm", "name": "Jelly Character", "author": "propagant", "description": "Raymarched - random - 'cartoony' - jelly/bloby character. Another practice shader...", "tags": ["raymarching", "cartoon", "character", "toon"], "likes": 4, "viewed": 161, "published": "Public API", "date": "1624102488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---By Matt - regular raymarching shader\n\n#define ITER 64\n#define MAXD 64.0\n#define SURD 0.005\n#define BGC vec3(0.45,0.24,0.1) * 4.\n\nstruct ray\n{\n    vec3 o,d;\n    float l;\n};\n\n//Simplest rotation matrix\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n//Iq's smooth opu\nvec4 opu(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n//Iq's smooth ops\nvec4 ops(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, -d1, h ) + k*h*(1.0-h));\n}\n\n//Custom noise method\nfloat noise(float p, float a, float s, float d)\n{\n\treturn cos(-p * a + iTime * s) * d;\n}\n\n//Full geometry generation\nvec4 geo(vec3 p)\n{\n    p.x += noise(p.x, 39.,6.0,0.003);\n    p.y = p.y + sin(iTime * 1.5) * 0.05;\n    vec3 objCenter = vec3(0.,0.,1.0);\n    //---head\n    vec3 headCenter = objCenter + vec3(0.,0.32,-0.03);\n    vec4 s0 = vec4(vec3(.45,.34,.1), length(p - headCenter) - 0.1);\n    //mouth\n    vec4 b0 = vec4(vec3(.45,.14,.1)*0.5, length(max(abs(vec3(p.xy * rot(25.), p.z) - headCenter - vec3(0.15, -.03, -.1)) - vec3(0.12,cos(iTime * 1.5) * 0.015,.08),0.0))-0.02);\n    vec4 s0b0 = ops(b0,s0,0.05);\n\n    //---body\n    //center\n    vec4 b1 = vec4(vec3(.45,.26,.1), length(max(abs(p - objCenter - vec3(0., .0, .0)) - vec3(0.15,.2,.1),0.0))-0.01);\n    //r-l subtracted curves\n    vec4 b2 = vec4(vec3(-0.2), length(max(abs(vec3(abs(p.x),p.yz) - objCenter - vec3(0.6, -0.3, 0.0)) - vec3(0.2,.2,.1),0.0))-0.25);\n    vec4 b1b2 = ops(b2,b1,0.15) + noise(p.y, -38.,8.0,0.001);\n    //lHand\n    vec4 b3 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-35.),p.z) - objCenter - vec3(-0.215, .01, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b4 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(-94.1),p.z) - objCenter - vec3(0.25, -.12, -.02)) - vec3(0.001,.07,.001),0.0))-0.03);\n    //rHand\n    vec4 b5 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-30.7),p.z) - objCenter - vec3(-0.24, -.08, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b6 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(30.5),p.z) - objCenter - vec3(-0.18, .1, -.04)) - vec3(0.001,.07,.001),0.0))-0.03);\n    \n    //---legs\n    vec4 b7 = vec4(mix(vec3(.85,.54,.0), vec3(0.25,0.14,0.1), smoothstep(p.x+0.1 ,-0.25,0.01)), length(max(abs(p - objCenter - vec3(0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -38.8,12.5,0.008);\n    vec4 b8 = vec4(vec3(.85,.1,.1)*2., length(max(abs(p - objCenter - vec3(-0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -32.8,12.5,0.008);\n    \n    //---body joints\n    vec4 Lhand = opu(b4,b3,.05);\n    vec4 Rhand = opu(b5,b6,.05);\n    vec4 legs = opu(b7,b8,0.2);\n    \n    //---body connection\n    vec4 hands = opu(Rhand,Lhand,.05);\n    vec4 body = opu(b1b2,hands,.05);\n    vec4 full = opu(body, legs,.2);\n    \n    return opu(s0b0,full,0.05);\n}\n\n//Normals generation\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001,0.);//slight offset\n    float c = geo(p).w;\n    return normalize(c - vec3(geo(p - o.xyy).w, geo(p - o.yxy).w, geo(p - o.yyx).w));\n}\n\n//Simples lighting + BlinnPhong specs\nfloat light(vec3 p)\n{\n    vec3 LP = vec3(0.2,0.5,0.5);\n    vec3 lp = normalize(LP - p);\n    vec3 n = normal(p);\n    \n    float l = clamp(dot(n,lp),0.25,1.);\n    float s = pow(max(dot(n,lp),0.),80.)*3.0;\n    \n    return pow(l + s,0.25);\n}\n\n//Raymarching core\nvec4 march(ray r)\n{\n    vec3 c = vec3(0.);\n    for(int i = 0; i < ITER; i++)\n    { \n        if(r.l > MAXD ) \n        {\n            c = BGC * 2.;\n            break;\n        }\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        if(g.w < SURD) \n        {\n            c = g.rgb * 2.5;\n            break;\n        }\n        r.l += g.w;\n    }\n    return vec4(c, r.l);\n}\n\n//Output img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    ray r = ray(vec3(0.),vec3(uv,1.0),0.);\n    vec4 m = march(r);\n    vec3 p = r.o + r.d * m.w;\n    vec3 col = vec3(m.rgb) * light(p);\n\n    fragColor = vec4(col,1.0) + 0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 205, 224, 224, 276], [278, 296, 331, 331, 512], [514, 532, 567, 567, 749], [751, 773, 822, 822, 861], [863, 890, 908, 908, 3107], [3109, 3130, 3151, 3151, 3307], [3309, 3347, 3368, 3368, 3584], [3586, 3605, 3624, 3624, 3982], [3984, 3997, 4054, 4054, 4300]], "test": "untested"}
{"id": "Nlj3Wy", "name": "Mini planet (SDF sphere)", "author": "omegasbk", "description": "Simple SDF example showing how to morph the distance function using a texture as a heightmap.", "tags": ["sdf", "sphere"], "likes": 7, "viewed": 144, "published": "Public", "date": "1624631049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by Darko Supe (omegasbk)\n// Playing with SDF to show how parallax effects can be achieved \n// with ray marching.\n// 25.6.2021.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n\nconst vec3 lightPosition = vec3(0, 3, 6);\nconst vec3 lightColor    = vec3(0.1, 0.2, 0.2) * 2.;\n\nvec2 getSphereCoords(in vec3 normal)\n{\n    vec2 coords = vec2((atan(normal.z, normal.x) / PI + 0.5) / 2.,\n                       (asin(normal.y) / PI + 0.5));  \n                \n    return coords;  \n}\n\nfloat getDepth(in vec3 normal)\n{                              \n    vec2 depthCoords = getSphereCoords(normal);\n    //depthCoords.x = clamp(depthCoords.x, 0.1, 0.9);\n    return texture(iChannel1, fract(depthCoords)).r / 10.;   \n}\n\nfloat getDist(in vec3 p) \n{\n    float time = iTime * 3.;\n\n    vec4 s = vec4(0, 0, 0, 1.);\n   \n    vec3 normal = normalize(p - vec3(0, 0, 0));\n    s.w += getDepth(normal);         \n    \n    float sphereDist = length(p - s.xyz) - s.w;    \n    return sphereDist;\n}\n\nvec3 getNormal(in vec3 p) \n{\n    float d = getDist(p);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy), \n        getDist(p - e.yxy), \n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n\n        float dS = getDist(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nvec3 getLight(in vec3 p, in vec3 rd)\n{    \n\tvec3 normal = getNormal(p);\n    vec3 lightDir = normalize(p - lightPosition);\n    \n    float cosa = pow(0.5+0.5*dot(normal, -lightDir), 3.0);\n    float cosr = max(dot(-rd, reflect(lightDir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.02);\n    vec3 diffuse = vec3(0.7 * cosa);\n    vec3 phong = vec3(0.3 * pow(cosr, 16.0));\n    \n    return lightColor * (ambiant + diffuse + phong);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime * 3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0., 0., 0.);\n    \n    // Camera movement\n    float focalLength = 4.;\n        \n    float rotation = iTime;\n    \n    // Uncomment this to rotate with your mouse\n    //float rotation = iMouse.x / 100.;    \n    \n    ro = vec3(cos(rotation), 0., sin(rotation)) * focalLength;\n    vec3 rd = normalize(vec3(0.) - ro);\n    vec3 right = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 up = cross(right, rd);\n   \trd =  normalize(uv.x * right + uv.y * up + rd);\n        \n    int body;\n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;        \n        \n        vec3 n = getNormal(p);\n        col = vec3(getLight(p, rd)) * vec3(0.6, 0.7, 0.7) * 3.;        \n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 326, 364, 364, 526], [528, 528, 560, 560, 756], [758, 758, 785, 785, 1019], [1021, 1021, 1049, 1049, 1259], [1261, 1261, 1301, 1301, 1554], [1556, 1556, 1594, 1594, 1984], [1986, 1986, 2041, 2041, 2983]], "test": "untested"}
{"id": "NljGRc", "name": "Soft Shadows - Andrew", "author": "andrew741", "description": "Soft shadow and ray tracing. The soft shadows are create using an area light which uses a fibonacci sphere to find uniform points on the outside of the sphere to sample the shadows. The size fo the area light changes based on a sign wave.", "tags": ["raytracing", "softshadows"], "likes": 3, "viewed": 56, "published": "Public", "date": "1624390287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\nfloat RayPlane(vec3 ro, vec3 dir, vec3 p, vec2 s)\n{\n    // front or back\n    float depth = (p.z - ro.z) / dir.z;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xy + dir.xy * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    /*\n    // left or right\n    float depth = (p.x - ro.x) / dir.x;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.yz + dir.yz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    */\n    // top or bottom\n    /*\n    float depth = (p.y - ro.y) / dir.y;\n\n    if (depth < 0.) depth = 99999999.;\n    else\n    {\n        vec2 cp = ro.xz + dir.xz * depth;\n        if (!(cp.y < p.y + s.y && cp.y > p.y - s.y && cp.x < p.x + s.x && cp.x > p.x - s.x))\n        {\n            depth = 99999999.;\n        }\n    }\n    \n    return depth;\n    */\n}\n\n\nfloat AreaLight(vec3 p, float r, int samples, vec3 ro)\n{\n    // fidning the goldan ratio\n    const float pi = 3.14159;\n    const float phi = pi * (3. - sqrt(5.));\n\n    float x;\n    float y;\n    float z;\n    float yR;\n    float theta;\n    \n    float unHit = 0.;\n    // generating the points on the sphere\n    for (int i = 0; i < samples; i++)\n    {\n        y = 1. - (float(i) / float(samples - 1)) * 2.;\n        yR = sqrt(1. - y * y);\n        theta = phi * float(i);\n\n        x = cos(theta) * yR;\n        z = sin(theta) * yR;\n        // adding the points to the list\n        vec3 pos = vec3(x, y, z) * r + p;\n        vec3 dif = pos - ro;\n        float lp = length(dif);\n        vec3 dir = dif / lp;\n        float rs1 = RaySphere(ro, dir, vec3(0, 0, 6), 2.).x;\n        float rs2 = RaySphere(ro, dir, vec3(0, -20, 0), 20.).x;\n        float rp3 = RayPlane(ro, dir, vec3(1.6, 0.25, 0), vec2(1., 1.));\n        unHit += min(min(rs1, rs2), rp3) > lp ? 1. : 0.;\n    }\n    return unHit / float(samples);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.4, 1));\n    vec3 ro = vec3(-1, 2, -6);\n\n    vec3 col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n\n    vec2 rs1 = RaySphere(ro, rd, vec3(0, 0, 6), 2.);\n    vec2 rs2 = RaySphere(ro, rd, vec3(0, -20, 0), 20.);\n    float rp3 = RayPlane(ro, rd, vec3(1.6, 0.25, 0), vec2(1., 1.));\n    \n    vec2 rs;\n    if (rs1.x < rs2.x && rs1.x < rp3) rs = rs1;\n    else if (rp3 < rs2.x) rs = vec2(rp3, 0.);\n    else rs = rs2;\n    \n    if (rs.x < 500.)\n    {\n        col = vec3(0.8, 0.2, 0.2);\n        float shadow = AreaLight(vec3(sin(iTime * 6.), 4, cos(iTime * 6.) + 6.), sin(iTime) + 1., 750, ro + rd * rs.x - rd * 0.01);\n        col *= shadow * 0.7 + 0.3;\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 54, 54, 555], [558, 558, 609, 630, 1632], [1635, 1635, 1691, 1723, 2630], [2633, 2633, 2690, 2690, 3643]], "test": "untested"}
{"id": "NljGWG", "name": "ColorGridDrag", "author": "paulhindt", "description": "Drag the mouse to pan the grid around.", "tags": ["mouse", "grid", "colors"], "likes": 1, "viewed": 64, "published": "Public", "date": "1624612355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.yy;\n    \n    uv.xy -= iMouse.xy / iResolution.xy;    \n    \n    float tile_size = 1.0 / 8.0;\n    \n    float edge = tile_size / 24.0;\n    \n    uv = (mod(uv, tile_size) - mod(uv - edge, tile_size) - edge) * (1.0 / tile_size);\n    vec4 grid_frag = vec4(1.0 - length(uv) * 0.5); // 0.9 for the face of the tile, 0.5 for the edge\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.75 + 0.50 * cos(\n        iTime + uv.xyx + vec3(2,0,0)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0) - grid_frag;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 695]], "test": "untested"}
{"id": "Nll3DS", "name": "Captain Harlock's maiden voyage", "author": "evvvvil", "description": "Captain Harlock's maiden voyage - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["demoscene", "space", "planet", "ghost", "organic", "monster", "world", "skull", "spaceship", "other", "ship", "creature", "flying", "albator"], "likes": 42, "viewed": 1063, "published": "Public", "date": "1622743764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Captain Harlock's maiden voyage - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"We will not pray for anything. Nor will we seek help from anyone.\" - Captain Harlock\n\nvec2 z,v,e=vec2 (.00035,-.00035);float t,tt,b,bb,g,gg,tn;vec3 np,bp,pp,op,po,no,ld,al,sp;\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin(float a,float b, float k){ float h=max(0.,k-abs(a-b));return min(a,b)-h*h*.25/k;}\nfloat smax(float a,float b, float k){ float h=max(0.,k-abs(-a-b));return max(-a,b)+h*h*.25/k;}\nvec2 smin( vec2 a, vec2 b,float k ){ float h=clamp(.5+.5*(b.x-a.x)/k,.0,1.);return mix(b,a,h)-k*h*(1.0-h);}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p ,float ga){  \n  op=p;\n  p.z-=b;p.xy*=r2(sin(op.z*.3)*.5);\n  float disp=cos(p.z*.2);             //DISPLACEMENT\n  float gr=clamp(sin(p.z*2.),-.5,.5)*.1; //GREEBLE\n  sp=vec3(abs(atan(p.x,p.y))*4.,p.z,length(p.xy)-2.2+disp);    //CYLINDRICAL POSITION  \n  sp.xy*=r2(.2+cos(p.z*.1)+gr*.5);\n  sp.xy=abs(abs(abs(sp.xy)-8.)-4.)-2.;  \n  vec2 h,t=vec2(length(p.xy)-2.+disp+clamp(sin(sp.x*5.-.5),-.5,.5)*.1,0); //MAIN CYLINDER   \n  t.x=abs(t.x)-.1;  \n  t.x=max(t.x,.7*(abs(sin(sp.x*5.-.5))-.8));\n  pp=p; pp.z=abs(abs(abs(pp.z)-4.)-1.)-.5;\n  float cut=abs(p.z)-10.;\n  float topTube=max(abs(length(pp.xz)-.2)-.1,abs(p.y)-4.+disp); //TOP TUBES\n  pp.y=min(pp.y,mod(pp.y-tt*2.+disp-sin(p.z*.2),10.)-5.);\n  float bro=min(4.,abs(max(0.,abs(p.y*.5)-2.3+disp)));\n  pp.xz-=sin(p.y*2.5+p.z*.5)*bro*.15;pp.y*=.3*(.2+bro);\n  float glo=(length(pp)+cos(bro+1.6)*.5)*.6;    \n  g+=0.1/(0.1+glo*glo*40.)*ga;\n  t.x=min(t.x,glo);\n  h=vec2(topTube,1);    \n  pp=p; pp.xy=abs(pp.xy)-(2.3-disp)*.8;   //TUBESSSSSSSSSSSS on SIDE\n  pp.yz*=r2(gr*.5); pp.xz*=r2(gr*.5);\n  float tubesSide=length(pp.xy)-.3; \n  glo=max(tubesSide+0.15,cut);\n  tubesSide=max(tubesSide,-(abs(pp.y)-.05));\n  t.x=smin(t.x,tubesSide,.4);  \n  gg+=0.1/(0.1+glo*glo*40.)*ga;\n  t.x=min(t.x,glo);\n  pp.xy=abs(pp.xy)-.3+min(.0,cos(p.z*.5)*.2);\n  float smallTubesSide=length(pp.xy)-.1;\n  h.x=smin(h.x,smallTubesSide,.2);    \n  float connect=length(sp.xz)-.4; //CYLINDRICAL TUBES AROUND\n  bp=sp; bp.z-=.3+cos(sp.y)*.5;\n  float nip=max(length(bp.xz)-.02,cut);\n  t.x=smin(t.x,nip,0.1);\n  gg+=0.1/(0.1+nip*nip*50.)*ga;\n  sp.x=abs(sp.x)-.5;\n  connect=smin(connect,length(sp.xz)-.1,.1);\n  h.x=smin(h.x,connect,.2);   \n  t.x=max(t.x,cut);\n  h.x=max(h.x,cut);                                \n  pp=p;pp.z=abs(pp.z)-11.;//SKULL\n  pp.y*=0.8;\n  float skDisp=sin(pp.y*2.+3.)*.3;  \n  float blackS=length(pp)-2.8+skDisp; //BLACK SPHERE AROUND SKULL\n  blackS=smax(length(pp-vec3(0,0,1.))-2.7+skDisp,blackS,.5);\n  h.x=smin(h.x,blackS,.5);  \n  tn=texNoise(pp.xy*.05+1.,iChannel0).r; //TEX NOISE\n  pp=p;pp.y*=0.8;pp.z-=11.; \n  float whiteS=length(pp+vec3(0,0,1.))-2.7+skDisp+tn*1.5;  \n  vec3 ep=pp-vec3(0,0.,.8);ep.x=abs(ep.x)-.8;\n  float smile=cos(p.z)*.5;            \n  whiteS=smax(max(length(ep)-.4-tn,p.y-.7+smile*2.5),whiteS,.5);             //EYES                \n  whiteS=smax((abs(p.y+1.9-smile)-.01),whiteS,.2);//SMILE\n  whiteS=smax(max(abs(abs(abs(abs(p.x)-.8)-.4)-.2)-.1+abs(p.y+1.7)*0.12,abs(p.y+1.9-smile)-1.),whiteS,.1);\n  t.x=smin(t.x,whiteS,.5);  \n  t=smin(t,h,.2);  t.x*=0.8;  \n  h=vec2(length(p.xy)-1.2+disp,2); //INSIDE CORE GLOW\n  h.x=max(h.x,cut);\n  pp=p+vec3(0,.5,10);pp.y=abs(pp.y)-1.;\n  h.x=smin(h.x,(length(pp.xy)-1.+sin(p.z*4.+p.y*2.+tt*5.)*.1+abs(pp.z)*.3)*.5,.5);    \n  vec3 ssp=p;ssp.xy*=r2(sin((p.z)*.2)-tt);  \n  g+=0.1/(0.1*h.x*h.x*(20.-sin(ssp.x-tt)*18.))*ga;\n  pp=p;pp.z=op.z;pp.z=mod(pp.z+tt,4.)-2.;pp.x=abs(pp.x)-1.;\n  float bit=.7*length(pp.xz);\n  glo=max(bit,p.y+6.2+sin(op.z));\n  float part=max(length(cos(op*.5)+sin(op.z*.2+op.x*.2)*.5),-op.y+10.); //PARTICLES\n  glo=min(glo,part);\n  g+=0.1/(0.1*glo*glo*1000.)*ga;  \n  h.x=smin(h.x,glo,1.);  \n  if(abs(p.x)-35.<0.){\n  float ter=(p.y+5.+.4*sin((op.z+tt)*1.5)+tn+cos(p.x*.2)*4.)*.45;\n  ter=smin(ter,max(bit-.15,p.y+7.),.5);\n  h.x=min(h.x,ter); //TERRAIN \n  }  \n  t=t.x<h.x?t:h;  \n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>60.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>60.) t.y=-1.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get uv\n  tt=mod(iTime,40.);\n  b=-20.+mod(tt*2.,40.);\n  vec3 ct=vec3(0,0,b);\n  vec3 ro=mix(vec3(4,-2.+sin(tt*.4)*2.,5),vec3(-7,sin(tt*.4)*2.,5),ceil(sin(tt*3.14159/20.))),\n  cw=normalize(ct-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.1,.12,.13)-length(uv)*.15-rd.y*.2+texNoise(rd.xz*.5,iChannel0).r*.2;\n  ld=normalize(vec3(-.5,.5,.5));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>-1.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    al=mix(vec3(.75),vec3(.0),z.y);    \n    if(z.y>1.) al=vec3(.8,.9,1)-exp(tn)*.7;\n    float dif=max(0.,dot(no,ld)),    \n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+al*(a(.2)+.2)*(dif+s(1.))*vec3(.7,.8,1.),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.00003*t*t*t));\n  }\nco=mix(co,co.zxy,length(uv)*.5);\n\tfragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 383, 400, 400, 443], [444, 444, 481, 481, 536], [537, 537, 574, 574, 631], [632, 632, 668, 668, 739], [740, 740, 778, 778, 1072], [1073, 1073, 1100, 1100, 4379], [4380, 4380, 4408, 4408, 4575], [4671, 4671, 4728, 4728, 5834]], "test": "untested"}
{"id": "NllGRX", "name": "backdraft", "author": "Carandiru", "description": "fork of shader by Brady ^^^^^^ link above\n\nplaying with fire, trying to get a good effect.\n", "tags": ["fire", "volumetric", "raymarcher"], "likes": 4, "viewed": 291, "published": "Public API", "date": "1622530776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////\n// ORIGINALLY - BRADY'S VOLUMETRIC FIRE //\n/////////////////////////////\n\n// thanks brady, great shader btw.\n\nfloat noise( vec3 P )\n{\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat fnoise(vec3 p, float time)\n{\n    float f = 0.0;\n    p = p - vec3(0.0, 1.0, 0.0) * .5 * time;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p); p = 2.0 * p;\n    f += 0.015625 * noise(p);\n    \n    return f;\n}\n\nfloat model( in vec3 p )\n{\n    p.y *= 0.75;\n    p.xz *= 0.5;\n\n    float sphere = length(p)-1.05;\n    float fire = fnoise(p*4.5, iTime*3.);\n    \n    float res = sphere + fire * 0.5f;\n    return res * 0.633f;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 40; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .001) return dist;\n        //else if(dist > 2.) break;\n    }\n    return -1.;\n}\n\nvec3 background(in vec2 p)\n{\n\treturn vec3(0.);\n}\n\nvec3 blackbody(float t){\n    // http://en.wikipedia.org/wiki/Planckian_locus\n\n    vec4 vx = vec4( -0.2661239e9, -0.2343580e6, 0.8776956e3, 0.179910   );\n    vec4 vy = vec4( -1.1063814,   -1.34811020,  2.18555832, -0.20219683 );\n    //vec4 vy = vec4(-0.9549476,-1.37418593,2.09137015,-0.16748867); //>2222K\n    float it = 1. / t;\n    float it2= it * it;\n    float x = dot( vx, vec4( it*it2, it2, it, 1. ) );\n    float x2 = x * x;\n    float y = dot( vy, vec4( x*x2, x2, x, 1. ) );\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 xyzToSrgb = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n\n    vec3 srgb = vec3( x/y, 1., (1.-x-y)/y ) * xyzToSrgb;\n\n    return max( srgb, 0. );\n}\n\nvec3 volume(in vec3 p, in vec3 rd, in vec3 ld, in vec2 sp)\n{\n    vec3 op = p;\n    float trans = 1.0;\n    float td = 0.0;\n    float emit = 0.0;\n    float steps = 30.; // increase to smooth\n    \n    // march\n    for(float i = 0.; i < steps; i++)\n    {\n        float m = model(p);\n        p += rd*.03;\n        \n        float dens = exp2(-m * 0.85f) * 0.85f;\n        td += dens * trans;\n        trans *= dens;\n        \n        if(trans < 0.001f)\n        {\n            break;\n        }\n    }\n    \n    vec3 extreme;\n    extreme = mix(vec3(0), blackbody(400.0f * td * (1.0f - trans)), trans);\n    \n    extreme = mix(extreme, blackbody(450.0f * td), trans);\n    \n    extreme += extreme * extreme;\n    \n    return extreme;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float rs = .5;\n    vec3 ro = vec3(cos(iMouse.x/100.), 1., sin(iMouse.x/100.))*1.35;\n    vec3 ta = vec3(0., 0.1, .0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.));\n    \n    float dist = raymarch(ro, rd);\n    vec3 ld = vec3(-1., 1., 0.);\n    vec3 col = dist > 0. ? volume(ro+rd*dist, rd, ld, p) : background(p);\n    \n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 140, 163, 163, 897], [899, 899, 933, 933, 1266], [1268, 1268, 1294, 1294, 1476], [1478, 1478, 1518, 1518, 1730], [1732, 1732, 1760, 1760, 1780], [1782, 1782, 1806, 1858, 2585], [2587, 2587, 2647, 2647, 3302], [3304, 3304, 3361, 3361, 3942]], "test": "untested"}
{"id": "NlS3Dm", "name": "Class 7 Soft Shadows", "author": "xarmalarma", "description": "Soft Shadows", "tags": ["disneybrdf"], "likes": 3, "viewed": 68, "published": "Public", "date": "1624044057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXX 10000000.0\n\nfloat seed = 0.0;\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nstruct Material {\nvec3 baseColor;      \nfloat metallic;      \nfloat subsurface;    \nfloat specular;      \nfloat roughness;     \nfloat specularTint;  \nfloat anisotropic;   \nfloat sheen;         \nfloat sheenTint;     \nfloat clearcoat;     \nfloat clearcoatGloss;\n};\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0-u, 0.0, 1.0);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.0) return 1.0/PI;\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a)\n{\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)\n{\n    return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG)\n{\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)\n{\n    return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y, Material m)\n{\n    float NdotL = dot(N,L);\n    float NdotV = dot(N,V);\n    if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.);\n\n    vec3 H = normalize(L+V);\n    float NdotH = dot(N,H);\n    float LdotH = dot(L,H);\n\n    vec3 Cdlin = mon2lin(m.baseColor);\n    Cdlin = m.baseColor;\n    float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n    vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(m.specular*.08*mix(vec3(1), Ctint, m.specularTint), Cdlin, m.metallic);\n    vec3 Csheen = mix(vec3(1), Ctint, m.sheenTint);\n\n    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n    // and mix in diffuse retro-reflection based on roughness\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    float Fd90 = 0.5 + 2.0 * LdotH*LdotH * m.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n    \n    float fd_90_minus_1 = 2.0 * LdotH * LdotH * m.roughness - 0.5;\n    \n    Fd  = (1.0 + fd_90_minus_1 * pow(1.0 - NdotL, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - NdotV, 5.0));\n\n\n    // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n    // 1.25 scale is used to (roughly) preserve albedo\n    // Fss90 used to \"flatten\" retroreflection based on roughness\n    float Fss90 = LdotH*LdotH*m.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n    // specular\n    float aspect = sqrt(1.0-m.anisotropic*.9);\n    float ax = max(.001, sqr(m.roughness)/aspect);\n    float ay = max(.001, sqr(m.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n    Gs = 1.0; \n    // sheen\n    vec3 Fsheen = FH * m.sheen * Csheen;\n\n    // clearcoat (ior = 1.5 -> F0 = 0.04)\n    float Dr = GTR1(NdotH, mix(.1,.001,m.clearcoatGloss));\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n    //return 1.0/PI * Fd*Cdlin * (1.0-m.metallic);\n    \n    return ((1.0/PI) * mix(Fd, ss, m.subsurface)*Cdlin + Fsheen)\n        * (1.0-m.metallic)\n        + Gs*Fs*Ds + .25*m.clearcoat*Gr*Fr*Dr;\n}\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n    float radius;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\nconst int NUM_SPHERE = 11;\nSphere spheres[NUM_SPHERE];\nMaterial materials[NUM_SPHERE];\nLight  lights[1];\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\n// create 4 spheres at different locations in different colors\nvoid makeScene(int f) {\n    int count = 0;\n    float radius = 0.2;\n    float x = -0.5;\n    float y = -0.3; \n    float z = -2.0;\n    // place 9 spheres in a grid with some separation\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            spheres[count] = Sphere(radius,vec3(x, y, z), vec3(0.0));\n            materials[count].baseColor = vec3(random(), random(), random());\n            x = x + (radius+0.3);\n            count++;\n        }\n        x = -0.5;  // reset x for the next row\n        z = z - (radius+0.5);\n        y = y + 0.3;\n    }\n    spheres[9] = Sphere(0.0, vec3(0.0, -10.0, -70.0), vec3(1.0, 0.3, 0.3));\n    spheres[10] = Sphere(0.2, vec3(1.0, 0.5, -2.20*float(f)/200.0), vec3(1, 1, 1)); \n    //spheres[0] = Sphere(0.2, vec3(0.0, 0, -1.0), vec3(1, 1, 0));\n    lights[0] = Light(vec3(1.0, 0.5, -2.20*float(f)/200.0), vec3(10, 10, 10), 0.2);\n    materials[0].baseColor = vec3(0.81, 0.42, 0.0);// 0.815, .418501512, .00180012\n    materials[0].metallic = 0.2; // .0; \n    materials[0].subsurface = 0.0;\n    materials[0].specular = 0.0;\n    materials[0].roughness = 0.2;\n    materials[0].specularTint = 0.0;\n    materials[0].anisotropic = 0.0;\n    materials[0].sheen = 0.0;\n    materials[0].sheenTint = 0.0;\n    materials[0].clearcoat = 0.0;\n    materials[0].clearcoatGloss = 0.0;\n    materials[9].baseColor = vec3(0.25, 0.25, 0.25);\n  \n}\n\n// samples per pixel\nconst int numSamples=16;\n\n// convert directionToLight and directionToView to tangent space\n//\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS)\n{\n    // use a matrix to convert\n    vec3 t = normalize(dFdx(hitPoint));\n    vec3 b = normalize(dFdy(hitPoint));\n    vec3 n = normalize(cross(t, b));\n    mat3 xformMatrix = transpose(mat3(t, b, n));\n    \n    toLightTS = xformMatrix * toLight;\n    toViewTS = xformMatrix * toView;\n    nTS = n;\n}\n\nfloat checkLightVisibility(in Light light, vec3 wi, vec3 hitPoint, vec3 hitNormal) {\n    float visible = 0.0;\n    vec3 lightDir = wi; \n    Ray ray;\n    ray.origin = hitPoint+lightDir*0.01;\n    ray.direction = lightDir;\n    Intersection intersection = intersectAllObjects(ray);\n    int iSphere = intersection.obj;\n    if (iSphere == 10) { \n        // light was hit, light is visible\n        visible = 1.0;\n    }\n    return visible;\n}\n\nvoid\nmakeOrthonormalBasis(vec3 normal, out vec3 tangent, out vec3 binormal) {\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    else {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    \n    binormal = cross(normal, tangent);\n}\n\n\n\nvec3 sampleCone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * 2.0*PI;\n    vec3 sphericald = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    return sphericald.x * xbasis + sphericald.y * ybasis + sphericald.z * zbasis;\n}\n\n\nvec3 sampleLight(Light light, vec3 hitPoint, vec3 hitNormal, out vec3 wi, out float lightPdf) {\n    vec2 u = vec2(random(), random());\n    \n    vec3 tangent = vec3(0.);\n    vec3 binormal = vec3(0.);\n    vec3 lightDir = normalize(light.location - hitPoint);\n    makeOrthonormalBasis(lightDir, tangent, binormal);\n    \n    float d = length(light.location-hitPoint);\n    float sinThetaMax2 = light.radius * light.radius / (d*d);\n    float cosThetaMax = sqrt(max(0.00001, 1. - sinThetaMax2));\n    wi = sampleCone(u, cosThetaMax, tangent, binormal, lightDir);\n    \n    if (dot(wi, hitNormal) > 0.) {\n        lightPdf = 1. / (2.0*PI * (1. - cosThetaMax));\n    }\n    \n\treturn light.color;\n}\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n  \n   makeScene(iFrame);\n   //materials[0].roughness = iMouse.x/iResolution.x;\n   //materials[0].metallic = iMouse.y/iResolution.y;\n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<1*numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n        \n       seed = float(iFrame) +  hash12(vec2(x,y));\n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       \n       vec3 L = vec3(0.0, 0.0, 0.0);\n       for (int bounces=0; bounces<2; bounces++) {\n              \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       Intersection intersection = intersectAllObjects(ray);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       Sphere sphere;\n       \n       if (iSphere > -1) { // if there is an intersection\n       \n           // to get around iSphere not being constant\n           for (int i=0; i<NUM_SPHERE; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           \n           if (iSphere == 10 && bounces==0) {\n               // direct hit to the light from view\n               L = lights[0].color; // 'show' the light\n               break;\n           }\n           if (iSphere==10) break; // otherwise ignore it\n           \n           \n           Material m = materials[iSphere];\n           vec3 wi;\n           float lightPdf = 0.0;\n           vec3 Ld = vec3(0.0, 0.0, 0.0);\n           \n           // hit coordinates\n           vec3 hit = ray.origin + minT*ray.direction;\n           // normal at the point of ray-sphere intersection\n           vec3 hitPointNormal = normalize(hit-sphere.center);         \n           // vector from intersection to light\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           vec3 hitPointToView = ray.origin-hit;\n           // calculate tangent and binormal at hit point\n           vec3 tangent = cross(hitPointNormal, vec3(1.,0.,1.));\n           vec3 binormal = normalize(cross(hitPointNormal, tangent));\n           tangent = normalize(cross(hitPointNormal,binormal));\n           \n           \n           // sample the light (get new direction and pdf)\n           vec3 Li = sampleLight(lights[0], hit, hitPointNormal, wi, lightPdf);\n           //wi = hitPointToLight;\n           float lightVisible = checkLightVisibility(lights[0], wi, hit, hitPointNormal);\n           Li = Li * lightVisible;\n           \n           // compute the brdf at intersection\n           vec3 f = BRDF(wi, hitPointToView, hitPointNormal, tangent, binormal, m);\n           f = f * abs(dot(wi, hitPointNormal));\n           \n           if (lightVisible > 0. && lightPdf > 0.0001)\n               Ld = Li * f  / lightPdf;  // direct light contribution\n           \n           \n           L = L + Ld; // accumulate direct light\n           // the new ray\n           ray.direction = wi;\n           ray.origin = hit + .01 * ray.direction;\n          \n           \n       } \n       else {\n           L = bgColor(ray.direction); // nothing was hit\n\n       }\n       \n       } // end of bounces\n       samp = samp + L;\n   } // end of spp\n   // average all the samples per pixel\n   samp = samp/float(numSamples);\n   // tone map\n   vec3 toneMappedColor = samp * (1.0 / (samp + 1.0));\n   // gamma correct\n   float gamma = 1.0/2.2;\n   vec3 finalColor = vec3(pow(toneMappedColor.x, gamma), \n                          pow(toneMappedColor.y, gamma), \n                          pow(toneMappedColor.z, gamma));\n                          \n   fragColor = vec4(finalColor, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 90, 90, 215], [480, 666, 686, 686, 700], [702, 702, 733, 733, 825], [827, 827, 861, 861, 996], [998, 998, 1032, 1032, 1124], [1126, 1126, 1203, 1203, 1289], [1291, 1291, 1336, 1336, 1440], [1442, 1442, 1525, 1525, 1606], [1608, 1608, 1630, 1630, 1697], [1700, 1700, 1764, 1764, 4125], [4128, 4128, 4155, 4155, 4261], [4267, 4300, 4316, 4316, 4363], [4888, 4928, 4984, 4984, 5427], [5429, 5515, 5558, 5558, 5957], [5962, 6025, 6048, 6048, 7392], [7441, 7509, 7632, 7663, 7925], [7927, 7927, 8011, 8011, 8359], [8361, 8361, 8438, 8438, 8668], [8672, 8672, 8757, 8757, 9063], [9066, 9066, 9161, 9161, 9749], [9752, 9831, 9886, 10044, 14227]], "test": "untested"}
{"id": "NlS3Dw", "name": "Spherical Harmonics Viewer", "author": "weasel", "description": "A new raymarching spherical harmonics viewer for all functions up to l~30 with |m|<17. Select the spherical harmonic you want using your mouse. Only a few are available with the mouse selection directly, others need to be selected in the code.", "tags": ["3d", "raymarching", "physics"], "likes": 13, "viewed": 206, "published": "Public API", "date": "1623960949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(1.0-x*x, float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n/*** Now the rendering ***/\n\nfloat map(float t, float a, float b, float A, float B) {\n    if (A - B == 0. || a - b == 0.)\n        return (A+B)*0.5;\n    return A + (t - a) * (B - A) / (b - a);\n}\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    return vec3(cmul(pos.xy, cexp(vec2(0.,-angle))), pos.z);\n}\n\nfloat sphereSdf(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\n#define SELECT_GRID 7.0\nvoid get_lm(out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t = int(iTime);\n    \n    if (mouse.x + mouse.y > 0.0) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        l = cell.x;\n        m = cell.y;\n        return;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = int(floor(float(t) - 0.5*float(l + l*l)));\n}\n\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    // get spherical coordinates\n    float sin_theta = length(pos.xy);\n    float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float ball_theta = atan(sin_theta, pos.z);\n\n    int m, l;\n    get_lm(l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    float off = m == 0 ? 0.0 : iTime/float(m);\n    vec2 sph_harm = sphere_harm(ball_theta, ball_phi + off, l, m);\n\n    // normalization for visual purposes\n    sph_harm *= SQRT2PI;\n    float occ = abs(sph_harm.x);\n    \n    float crit = float(1+max(abs(m), l-abs(m)));\n    float crit2 = 1.0 / (3.0 + crit);\n    float max_abs_sd = (length(pos)+0.01)*PI*2.0/crit;\n    \n    float sdx = sphereSdf(pos, max(sph_harm.x, 0.))*crit2;\n    float sdy = sphereSdf(pos, -min(sph_harm.x, 0.))*crit2;\n    color = vec3(float(sdx < sdy),occ,0);\n    float sd = min(sdx, sdy);\n    return min(max_abs_sd, abs(sd)) * sign(sd);\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), color.r );\n\n    float occ = min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = 0.0;//pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/2.1;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 122, 140, 140, 236], [238, 258, 277, 277, 374], [376, 413, 439, 439, 649], [651, 674, 693, 693, 741], [743, 769, 796, 796, 861], [863, 886, 905, 905, 931], [933, 967, 987, 987, 1001], [1002, 1002, 1021, 1021, 1040], [1042, 1077, 1121, 1121, 1587], [1589, 1621, 1677, 1677, 1855], [1857, 1886, 1942, 1942, 2050], [2052, 2052, 2089, 2089, 2152], [2154, 2154, 2191, 2191, 2254], [2256, 2256, 2292, 2292, 2320], [2346, 2346, 2400, 2400, 2873], [2875, 2875, 2937, 2970, 3808], [3810, 3810, 3883, 3883, 4295], [4297, 4297, 4357, 4423, 4912], [5012, 5012, 5074, 5074, 6348], [6350, 6350, 6405, 6405, 7949]], "test": "untested"}
{"id": "NlS3RR", "name": "Mandelbrot Try 1", "author": "trashy", "description": "This is probably poorly coded 😅\nPossible TODOs:\n* Infinite/longer Zoom\n* Fix resolution at high zoom levels\n* Dynamic centerpoint\n\nCouldn't have done it without the Shiff\nhttps://www.youtube.com/watch?v=6z7GQewK-Ks", "tags": ["mandelbrot"], "likes": 1, "viewed": 49, "published": "Public", "date": "1623172915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 256.0 \n#define PI 3.14159265359\n#define MIN_X -2.0\n#define MAX_X  2.0\n#define MIN_Y -1.5\n#define MAX_Y  1.5\n\nprecision highp float;\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                            6.0)-3.0)-1.0,\n                    0.0,\n                    1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n// https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat crosshair(vec2 st, vec2 m) {\n    return (step(st.x-0.001, m.x) - step(st.x+0.001, m.x)) + (step(st.y-0.002, m.y) - step(st.y+0.002, m.y));\n}\n\n//map 0-1 to mandelbrot space\nvec2 normalToMandelCoord(vec2 norm, vec2 center, float zoom) {\n    return center + vec2(\n        map(norm.x, 0.0, 1.0, MIN_X, MAX_X),\n        map(norm.y, 0.0, 1.0, MIN_Y, MAX_Y)\n     ) / zoom;\n}\n\n//map mandelbrot space to 0-1\nvec2 mandelToNormalCoord(vec2 norm, float zoom) {\n    return vec2(\n        map(norm.x, MIN_X/zoom, MAX_X/zoom, 0.0, 1.0),\n        map(norm.y, MIN_Y/zoom, MAX_Y/zoom, 0.0, 1.0)\n     );\n}\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    //resolution breaks at ~38 seconds\n    float maxZoomTime = (1.0 + sin(iTime/72.0 * PI*2.0 - PI/2.0))*18.0;\n\n    //float zoom = 2.0;\n    //float zoom = 1.25 + sin(iTime) * 0.25;\n    float zoom = 0.1 + pow(maxZoomTime, maxZoomTime/10.0);\n    \n    //I want to zoom to this point 🤔\n    vec2 center = vec2(-0.745156, 0.112574);\n    vec2 stCoords = normalToMandelCoord(st, center, zoom);\n    \n    float a = stCoords.x;\n    float b = stCoords.y;\n\n    float ca = a;\n    float cb = b;\n    float n = 0.0;\n    \n    for(float i=0.0;i<MAX_ITER;i++) {\n        float real = pow(a, 2.0) - pow(b, 2.0);\n        float imag = 2.0 * a * b;\n\n        a = real + ca;\n        b = imag + cb;\n        n = i;\n\n        if(a*a + b*b > 4.0) break;\n    }\n    //while is not working on iOS 🤔\n    //} while(abs(a + b) < 4.0 && n < MAX_ITER);\n\n    vec3 color = hsb2rgb( vec3((n/MAX_ITER), 1.0, 1.0 - (n/MAX_ITER)) );\n    \n    //color += crosshair(st, mandelToNormalCoord(center, zoom))*0.4;\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 224, 250, 250, 480], [483, 552, 624, 624, 692], [694, 694, 728, 728, 840], [842, 872, 934, 934, 1066], [1068, 1098, 1147, 1147, 1283], [1294, 1294, 1351, 1401, 2515]], "test": "untested"}
{"id": "NlS3Ry", "name": "Redstone", "author": "been_jamming", "description": "I really like redstone!", "tags": ["3d", "minecraft"], "likes": 23, "viewed": 278, "published": "Public API", "date": "1624081884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct face{\n    vec3 p;\n    vec3 side0;\n    vec3 side1;\n};\n\nstruct ray{\n\tvec3 p;\n\tvec3 vec;\n};\n\nvec4 create_orientation(vec3 axis, float angle){\n\tfloat len;\n\tvec4 outvec;\n\t\n\tlen = length(axis);\n\taxis *= sin(angle)/len;\n\toutvec.yzw = axis;\n\toutvec.x = cos(angle);\n\t\n\treturn outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n\treturn vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n\tvec4 outvec;\n\t\n    outvec.x = dot(a, b.xyzw*vec4(1.0, -1.0, -1.0, -1.0));\n    outvec.y = dot(a, b.yxwz*vec4(1.0, 1.0, 1.0, -1.0));\n    outvec.z = dot(a, b.zwxy*vec4(1.0, -1.0, 1.0, 1.0));\n    outvec.w = dot(a, b.wzyx*vec4(1.0, 1.0, -1.0, 1.0));\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n\tvec4 v;\n\t\n\tv.x = 0.0;\n\tv.yzw = p.xyz;\n\treturn compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nvoid ray_face_intersect(face f, ray r, out float t, out vec2 face_coords, out vec3 intersect_pos){\n    vec3 normal_vec;\n    \n    normal_vec = cross(f.side0, f.side1);\n    t = dot(f.p - r.p, normal_vec)/dot(r.vec, normal_vec);\n    intersect_pos = r.vec*t + r.p;\n    face_coords.x = dot(intersect_pos - f.p, f.side0)/(dot(f.side0, f.side0));\n    face_coords.y = dot(intersect_pos - f.p, f.side1)/(dot(f.side1, f.side1));\n}\n\nfloat hash(const float n){\n    return fract(cos(2.0734*n)*sin(n*1.1234512)*12111.312);\n}\n\n//The number of rectangular faces in the scene\n#define NUM_FACES 51\n\n//For each face, I have defined a corner of the face and two vectors for the sides of the face\nconst face faces[NUM_FACES] = face[NUM_FACES](\n    //The smooth stone block\n    face(vec3(0.0625, 0.0625, -0.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(-0.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(1.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 0.0625, 1.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 1.0001, 0.0625), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.0, 0.875)),\n    face(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The grass ground\n    //This is just a plane that lies a the bottom of the scene\n    face(vec3(50.0, 0.0, 50.0), vec3(-100.0, 0.0, 0.0), vec3(0.0, 0.0, -100.0)),\n    \n    //The wood on the redstone torch\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.5625, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.25, 0.1251), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    \n    //The redstone on the redstone torch\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.5627, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.3749), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.6249), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, 0.125)),\n    \n    //The redstone dust!\n    face(vec3(-1.25, 0.0001, 0.5625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125)),\n    face(vec3(-1.25, 0.0001, 0.625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.0625)),\n    face(vec3(-1.25, 0.0001, 0.375), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, 0.0625)),\n    \n    //The redstone repeater\n    face(vec3(-1, 0, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, 0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(0, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0.125, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The wood on the repeater\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    face(vec3(-0.625, 0.1256, -0.5625), vec3(0.5, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //The wood on the repeater\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //More redstone dust\n    face(vec3(-1.25, 0.0001, 0.75), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.25, 0.0001, -0.25), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.4375, 0.0001, -0.25), vec3(-0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.5)),\n    face(vec3(-1.25, 0.0001, -0.4375), vec3(0.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125))\n);\n\n//Each face gets a default color\nvec3 face_colors[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    \n    //The grass ground\n    vec3(0.2, 0.4, 0.05),\n    \n    //The wood on the redstone torch\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    vec3(0.4, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //More redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0)\n);\n\n//Since I can't store the actual textures in the shader, I instead resort to adding the\n//\"roughness\" that you see in Minecraft's textures to try to make it look like the same\n//textures. I compensate by adding more faces when I need more detail\nconst vec3 material_variation[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    \n    //The grass ground\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the redstone torch should only vary in \"brown-ness\"\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.25, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    vec3(0.0, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //More redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\n//This stores how many \"mc pixels\" across each face is\n//This will determine the resolution of the material variation\nconst vec2 texture_dims[NUM_FACES] = vec2[NUM_FACES](\n    //The smooth stone block\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    \n    //The grass ground\n    vec2(1600.0, 1600.0),\n    \n    //The wood on the redstone torch\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    \n    //The redstone on the redstone torch\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //The redstone dust\n    vec2(20.0, 2.0),\n    vec2(20.0, 1.0),\n    vec2(20.0, 1.0),\n    \n    //The redstone repeater\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 16.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    vec2(1.0, 1.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //More redstone dust\n    vec2(8.0, 8.0),\n    vec2(8.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(4.0, 2.0)\n);\n\n//This stores which materials are transparent to light\nconst bool material_transparent[NUM_FACES] = bool[NUM_FACES](\n    //The smooth stone block is not transparent\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The grass is not transparent\n    false,\n    \n    //The wood on the redstone is not transparent\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone dust\n    true,\n    true,\n    true,\n    \n    //The redstone repeater\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    true,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //More redstone dust\n    true,\n    true,\n    true,\n    true\n);\n\n//The chance that a pixel of the block will be transparent\n//This is pretty much only for redstone dust (I might use this for particle effects later though)\nconst float material_pixel_invisible_chance[NUM_FACES] = float[NUM_FACES](\n    //The smooth stone block is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The grass is not transparent\n    0.0,\n    \n    //The wood on the redstone is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone dust\n    0.5,\n    0.8,\n    0.8,\n    \n    //The redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //More redstone dust\n    0.5,\n    0.5,\n    0.6,\n    0.5\n);\n\n//The number of light sources\n#define NUM_LIGHT_SOURCES 4\n\n//This stores the different light source colors\nvec3 light_source_color[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.25, 0.03125, 0.03125),\n    vec3(2.0, 4.0, 4.0),\n    vec3(0.1, 0.0125, 0.0125),\n    vec3(0.1, 0.0125, 0.0125)\n);\n\n//This stores each light source position\nvec3 light_source_position[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.5, 0.775, -0.5),\n    vec3(-2.0, 4.0, 4.0),\n    vec3(-0.8125, 0.375, -0.5),\n    vec3(-0.1875, 0.375, -0.5)\n);\n\n//This stores whether each light source is active\nbool light_source_active[NUM_LIGHT_SOURCES] = bool[NUM_LIGHT_SOURCES](\n    true, true, true, true\n);\n\nray get_camera_ray(vec2 pixel){\n\tfloat least_side;\n\t\n\tpixel -= vec2(0.5);\n\tleast_side = min(iResolution.x, iResolution.y);\n\treturn ray(vec3(0), vec3(pixel.x*iResolution.x/least_side, pixel.y*iResolution.y/least_side, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 camera_orientation;\n    vec3 camera_position;\n    vec4 look_down;\n    ray camera_ray;\n    face f;\n    int face_num;\n    int texture_id;\n    vec3 intersect_pos;\n    vec2 face_coords;\n    float intersect_time;\n    float best_dist = 25.0;\n    vec3 face_pos;\n    vec3 face_color;\n    vec3 face_normal;\n    int face_intersect;\n    ray shadow_ray;\n    vec3 current_color;\n    vec3 emission;\n    int light_id;\n    float pix_x;\n    float pix_y;\n    vec2 texture_dim;\n        \n    camera_orientation = create_orientation(vec3(0.0, 1.0, 0.0), iTime/5.0 + 0.125);\n    look_down = create_orientation(vec3(1.0, 0.0, 0.0), 0.3);\n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    camera_ray.vec = apply_orientation(camera_ray.vec, look_down);\n    camera_ray.vec = apply_orientation(camera_ray.vec, camera_orientation);\n    camera_ray.p = apply_orientation(vec3(-0.25, 1.75, -2.875), camera_orientation);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for(face_num = 0; face_num < NUM_FACES; face_num++){\n        f = faces[face_num];\n        ray_face_intersect(f, camera_ray, intersect_time, face_coords, intersect_pos);\n        if(intersect_time > 0.0 && length(intersect_pos - camera_ray.p) < best_dist && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0){\n            texture_dim = texture_dims[face_num];\n            pix_x = floor(face_coords.x*texture_dim.x);\n            pix_y = floor(face_coords.y*texture_dim.y);\n            if(material_pixel_invisible_chance[face_num] > hash((pix_x + 4.0 + 2.0*float(face_num))*(pix_y + 1.0 + float(face_num))))\n                continue;\n            best_dist = length(intersect_pos - camera_ray.p);\n            face_pos = intersect_pos;\n            face_color = face_colors[face_num] + material_variation[face_num]*hash(pix_x + 16.0*pix_y);\n            face_intersect = face_num;\n            face_normal = normalize(cross(f.side0, f.side1));\n        }\n    }\n    \n    if(best_dist != 25.0){\n        current_color = vec3(1.0/dot(face_pos - camera_ray.p, face_pos - camera_ray.p))*face_color;\n        light_source_active[0] = mod(iTime, 1.0) < 0.5;\n        light_source_active[2] = mod(iTime - 0.4, 1.0) < 0.5;\n        light_source_active[3] = mod(iTime - 0.4, 1.0) < 0.5;\n        if(mod(iTime, 1.0) < 0.5 && face_intersect >= 15 && face_intersect <= 19)\n            current_color += 2.0*face_color;\n        if(mod(iTime - 0.4, 1.0) < 0.5 && ((face_intersect >= 32 && face_intersect <= 36) || (face_intersect >= 20 && face_intersect <= 22) || face_intersect >= 42))\n            current_color += 2.0*face_color;\n        for(light_id = 0; light_id < NUM_LIGHT_SOURCES; light_id++){\n            if(!light_source_active[light_id])\n                continue;\n            if(light_id == 0 && face_intersect >= 15 && face_intersect <= 19)\n                continue;\n            if(light_id == 2 && face_intersect >= 32 && face_intersect <= 36)\n                continue;\n            if(light_id == 3 && face_intersect >= 42 && face_intersect <= 46)\n                continue;\n            shadow_ray = ray(face_pos, light_source_position[light_id] - face_pos);\n            for(face_num = 0; face_num < NUM_FACES; face_num++){\n                if(material_transparent[face_num] || face_num == face_intersect)\n                    continue;\n                f = faces[face_num];\n                ray_face_intersect(f, shadow_ray, intersect_time, face_coords, intersect_pos);\n                if(intersect_time > 0.0 && intersect_time < 1.0 && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0)\n                    break;\n            }\n            if(face_num == NUM_FACES)\n                current_color += light_source_color[light_id]*vec3(abs(dot(face_normal, shadow_ray.vec))/(length(shadow_ray.vec)*dot(shadow_ray.vec, shadow_ray.vec)))*face_color;\n        }\n        fragColor = vec4(current_color, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 145, 145, 283], [285, 285, 328, 328, 377], [379, 379, 420, 420, 692], [694, 694, 733, 733, 858], [860, 860, 958, 958, 1280], [1282, 1282, 1308, 1308, 1370], [14674, 14826, 14857, 14857, 15051], [15053, 15053, 15107, 15107, 19073]], "test": "untested"}
{"id": "NlS3Wc", "name": "Brmlab logo", "author": "lanikjo", "description": "logo of prague hackerspace brmlab", "tags": ["logo"], "likes": 1, "viewed": 135, "published": "Public API", "date": "1624810415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// GLSL Brmlab logo\n// Copyright (c) 2021 Jovan Lanik\n//\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nfloat doCircle(vec2 uv, float x, float y, float size) {\n    return floor(length(uv+vec2(x, y)) - size + 0.988);\n}\n\nfloat doRing(vec2 uv, float x, float y, float size, float thicc) {\n    float ring = length(uv+vec2(x, y)) - size;\n    ring = abs(ring) * thicc;\n    ring = floor(ring);\n    return ring;\n}\n\nfloat doBrm(vec2 uv, float x, float y, float size) {\n    float ringSize = 0.425;\n    float detailThicc = 80.0;\n\n    uv += vec2(x, y);\n    uv *= size;\n    \n    float ring = doRing(uv, 0.0, 0.0, ringSize, 40.0);\n    \n    float small = doRing(uv, 0.0, 0.0, ringSize - 0.1, detailThicc);\n    \n    small = max(small, 1.0 - doCircle(uv, 0.0, -0.33, 0.07));\n    small = min(small, doRing(uv, 0.0, -0.33, 0.07, detailThicc));\n    \n    small = max(small, 1.0 - doCircle(uv, 0.25, 0.21, 0.07));\n    small = min(small, doRing(uv, 0.25, 0.21, 0.07, detailThicc));\n    \n    small = max(small, 1.0 - doCircle(uv, -0.25, 0.21, 0.07));\n    small = min(small, doRing(uv, -0.25, 0.21, 0.07, detailThicc));\n    \n    small = max(small, doCircle(uv, 0.0, 0.0, ringSize - 0.1));\n    \n    vec2 boxV = uv * 1.0;\n    boxV = abs(boxV) * 1.0;\n    boxV -= 0.04;\n    boxV.x -= 0.04;\n    boxV = abs(boxV) * 80.0;\n    boxV = floor(boxV);\n    boxV.x = max(boxV.x, floor(abs(uv.y)*19.0));\n    boxV.y = max(boxV.y, floor(abs(uv.x)*12.0));\n    float box = min(boxV.x, boxV.y);\n \n    float put = min(ring, small);\n    put = min(put, box);\n    put = min(put, doRing(uv, 0.0, -0.16, 0.035, detailThicc));\n    put = min(put, doRing(uv, 0.15, -0.16, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.15, -0.16, 0.035, detailThicc));\n    \n    put = min(put, doRing(uv, 0.20, 0.05, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.20, 0.05, 0.035, detailThicc));\n    \n    put = min(put, doRing(uv, 0.08, 0.20, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.08, 0.20, 0.035, detailThicc));\n    \n    return put;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float var = (sin(iTime*20.0)+1.0)*0.01 + 1.0;\n    \n    float put = doBrm(uv, 0.0, 0.0, var);\n    \n    put = 1.0 - put;\n    fragColor = vec4(put, put, put, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Wc.jpg", "access": "shaders20k", "license": "mit", "functions": [[61, 1134, 1189, 1189, 1247], [1249, 1249, 1315, 1315, 1435], [1437, 1437, 1489, 1489, 3025], [3027, 3027, 3084, 3084, 3347]], "test": "untested"}
{"id": "NlS3zG", "name": "Hell Gate_", "author": "Vinicius_Jesus", "description": "using textures ", "tags": ["texture", "smoothnoise"], "likes": 4, "viewed": 63, "published": "Public", "date": "1624072286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float R21 (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(2.3245,5.234)))*12.5632145);\n}\n\nfloat NoiseValue (vec2 uv) {\n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    \n    gv = gv * gv * (3. - 2. * gv);\n\n    float a = R21(id);\n    float b = R21(id + vec2(1., 0.));\n    float c = R21(id + vec2(0., 1.));\n    float d = R21(id + vec2(1., 1.));\n\n    return mix(a, b, gv.x) + (c - a)* gv.y * (1. - gv.x) + (d - b) * gv.x * gv.y;\n}\n\nfloat SmoothNoise (vec2 uv) {\n\n    float value = 0.;\n    float amplitude = .1;\n\n    for (int i = 0; i < 10; i++) {\n        value += NoiseValue(uv) * amplitude;\n        uv *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\nfloat Circle(vec2 uv, vec2 p) {\n    float dist = length(uv-p);\n    float mask = smoothstep(.03, .29, dist);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    vec2 rn = vec2(0.);\n    rn.x = SmoothNoise(uv + 1.2 * vec2(1.) + vec2(2.)+ 0.15*iTime );\n    rn.y = SmoothNoise(uv + 1. * vec2(1.) + vec2(2.)+ 0.12*iTime);\n    \n    col += SmoothNoise(uv+rn*2.5);\n\n    col += vec3(0.4/length(uv-vec2(-1., .5)));\n    col += texture(iChannel0, col.xy).rgb;\n    col -= Circle(uv, vec2(-1., .5));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [89, 89, 117, 117, 430], [432, 432, 461, 461, 665], [667, 667, 698, 698, 793], [795, 795, 852, 852, 1309]], "test": "untested"}
{"id": "NlsGDl", "name": "Turbulent seas", "author": "jarble", "description": "The wind is blowing over the waves.", "tags": ["noise", "waves", "fbm", "ocean"], "likes": 7, "viewed": 192, "published": "Public API", "date": "1623107612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nfloat random(vec2 p)\n{\n    return fract(p.x*p.y*fract(p.x*0.1183099));\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x+iTime)+cos(uv.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-abs(noise(uv * freq)-.3) * amplitude);\n        \n        amplitude *= (.47+value)/2.0;\n        \n        freq *= 2.;\n        \n        uv += uv.yx/16.0;\n        uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 92], [94, 94, 119, 119, 159], [179, 179, 202, 202, 676], [678, 678, 698, 698, 744], [746, 746, 779, 779, 973], [975, 975, 1042, 1042, 1252], [1254, 1254, 1306, 1306, 1851], [1853, 1853, 1904, 1904, 2105], [2107, 2107, 2133, 2133, 2209], [2212, 2212, 2269, 2269, 4009]], "test": "untested"}
{"id": "NlSGWV", "name": "symmetric linking", "author": "kajbostrom", "description": "testing symmetry of linking closest neighbors across two hexagonal lattices/simplices.", "tags": ["geometry", "symmetry", "lattice"], "likes": 2, "viewed": 36, "published": "Public", "date": "1624776913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Kaj Bostrom, 2021\n\n#define scale 20.0\n#define PI 3.1415926535898\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nuint hashi(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nmat2 rotate(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n// non-branching mod3\nint mod3(int n) {\n    int two_if_neg = int(n < 0)*2;\n    int sg = 1-two_if_neg;\n    return two_if_neg + sg*((two_if_neg + sg*n)%3);\n}\n\n// tweaked from iq's hexagonal grid traversal to be non-branching\nivec2 closestLatticeCoords(vec2 p, vec2 origin, float angle) \n{\n    p = rotate(angle)*(p - origin);\n\tvec2 q = vec2(p.x, p.x*0.5 + p.y*0.8660254037);\n\n    ivec2 i = ivec2(floor(q));\n\tvec2 f = fract(q);\n    \n\tint v = mod3(i.x + i.y);\n    ivec2 lc = i + v;\n    lc -= int(v == 2) * (ivec2(2, 1) + int(f.x > f.y)*ivec2(-1, 1));\n    \n    return ivec2( lc.x, (2*lc.y-lc.x)/3 );\n}\n\nvec2 latticePoint(ivec2 lc, vec2 origin, float angle )\n{\n    vec2 pt = vec2(float(lc.x),float(lc.y)*1.732050807);\n    return rotate(-angle)*pt + origin;\n}\n\n/*\n// Parallelogram lattice basis, doesn't provide accurate closest point\nivec2 closestLatticeCoords(vec2 uv, vec2 origin, float angle) {\n    uv = rotate(uv - origin, angle);\n    float row = uv.y / sin(PI/3.);\n    vec2 lp = vec2(uv.x + row*0.5, row);\n    return ivec2(round(lp.x), round(lp.y));\n\n}\n\nvec2 latticePoint(ivec2 lc, vec2 origin, float angle) {\n    vec2 pt = vec2(float(lc.x)-float(lc.y)*0.5, float(lc.y)*sin(PI/3.));\n    pt = rotate(pt, -angle) + origin;\n    return pt;\n}\n*/\n\nfloat tSegment( in vec2 p, in vec2 a, in vec2 b, out float ud)\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float t =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    ud = length(p - (a+t*ba));\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv *= scale;\n    \n    float pixd = scale/iResolution.x;\n    \n    vec2 lattice1Origin = vec2(0, 0);\n    float lattice1Angle = 0.0 + 0.01*iTime;\n    vec2 lattice2Origin = vec2(7.5, 2.5);\n    float lattice2Angle = 0.25*PI + 0.02*iTime;\n\n    //ivec2 lc = ivec2(0, 0);\n    ivec2 lc1 = closestLatticeCoords(uv, lattice1Origin, lattice1Angle);\n    ivec2 lc2 = closestLatticeCoords(uv, lattice2Origin, lattice2Angle);\n    //ivec2 lc = latticeCoords(vec2(0, 5));\n    vec2 lp1 = latticePoint(lc1, lattice1Origin, lattice1Angle);\n    vec2 lp2 = latticePoint(lc2, lattice2Origin, lattice2Angle);\n    float d1 = distance(uv, lp1);\n    float d2 = distance(uv, lp2);\n    float f1 = hash(hashi(uint(lc1.y)) + uint(lc1.x));\n    float f2 = hash(hashi(uint(lc2.y)) + uint(lc2.x));\n    float rg = 1.0;\n    ivec2 lc = lc1;\n    vec2 lp = lp1;\n    float d = d1;\n    float f = f1;\n    vec2 latticeOrigin = lattice1Origin;\n    float latticeAngle = lattice1Angle;\n    vec2 lattice3Origin = lattice2Origin;\n    float lattice3Angle = lattice2Angle;\n    if (d2 < d) {\n        d = d2;\n        lc = lc2;\n        lp = lp2;\n        f = f2;\n        rg = 0.0;\n        latticeOrigin = lattice2Origin;\n        latticeAngle = lattice2Angle;\n        lattice3Origin = lattice1Origin;\n        lattice3Angle = lattice1Angle;\n    }\n    ivec2 lc3 = closestLatticeCoords(lp, lattice3Origin, lattice3Angle);\n    vec2 lp3 = latticePoint(lc3, lattice3Origin, lattice3Angle);\n    ivec2 lc4 = closestLatticeCoords(lp3, latticeOrigin, latticeAngle);\n    float f3 = hash(hashi(uint(lc3.y)) + uint(lc3.x));\n    float dSeg = 0.0;\n    float tSeg = tSegment(uv, lp, lp3, dSeg);\n    float b = f;\n    if (lc == lc4) { //symmetric link\n        d = min(d, dSeg+0.1);\n        b = (1. - tSeg)*f + tSeg*f3;\n        rg += (1. - 2.*rg)*tSeg;\n    }\n    b = .75*b + .25;\n    vec4 colIn = vec4(rg*b,0.5+0.5*b,(1.0-rg)*b,1.0);\n    float bgBlend = smoothstep(0., 1., (d - 0.2)/pixd);\n    //float mix = smoothstep(0., 1., (d1 - 0.2)/pixd)*.5;\n    fragColor = (1.0-bgBlend)*colIn + bgBlend * vec4(1,1,1,1);\n    //fragColor = (1.0-mix)*vec4(1,1,1,1) + mix * vec4(f1, f1, f1, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 134, 154, 154, 268], [270, 270, 296, 296, 364], [366, 388, 405, 405, 521], [523, 589, 652, 652, 961], [963, 963, 1019, 1019, 1117], [1119, 1606, 1670, 1670, 1810], [1812, 1812, 1869, 1869, 4021]], "test": "untested"}
{"id": "NlX3Ds", "name": "20210607 circular orb", "author": "kamonumber", "description": "Light spheres arranged in a circle\n\nreference\nhttps://qiita.com/doxas/items/f3f8bf868f12851ea143", "tags": ["orb", "for"], "likes": 4, "viewed": 41, "published": "Public", "date": "1623106760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/min(iResolution.x,iResolution.y);\n    uv.y-= 0.5;\n    uv.x-= iResolution.x/iResolution.y/2.;\n    float PI = 3.141592553589793;\n\n    vec3 col = vec3(0.0);\n    for(float i = 0.0;i<12.0;i++){\n    float angle = i*PI/6.0+iTime;\n        vec2 pos = vec2(cos(angle),sin(angle))*vec2(sin(iTime+i/12.0)*0.5);\n        col += vec3(0.005/(length(pos-uv)));\n    }\n;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 466]], "test": "untested"}
{"id": "NlX3Wf", "name": "Perlin Practice (False Perlin)", "author": "IceSelkie", "description": "Perlin noise generator written in a few minutes, just to make sure I have the algorithm down before I try to implement it in another language.", "tags": ["perlin"], "likes": 3, "viewed": 36, "published": "Public", "date": "1622955906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\n// Not the best way to do random, but it should be good enough here.\nfloat random(vec3 st) {\n    return fract(sin(dot(st, vec3(53.81125,6.42648,24.40232)))*73424.64639);\n}\n\n// Linear interpolation\nfloat mid_lin(vec4 corners, vec2 location) {\n    vec2 mid = corners.xz*location.x+corners.yw*(1.-location.x);\n    return mid.x*location.y+mid.y*(1.-location.y);\n}\n\n// Cosine interpolation\nfloat mid_sin(vec4 corners, vec2 location) {\n    return mid_lin(corners, (cos(PI*(1.-location))+1.)/2.);\n}\n\n// Interpolate to find midpoint value.\nfloat midlicate(vec4 corners, vec2 location) {\n    return mid_sin(corners, location);\n}\n\nvec4 falsePerlin(vec2 fragCoord) {\n    int depth = 12;\n    float scaleCoeff = 5.;\n    vec2 shaderSize = vec2(1600./350., 900./350.)/scaleCoeff;\n    vec2 offset = vec2(iTime*0.75,iTime*0.5)/scaleCoeff;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*shaderSize + offset;\n    \n    float total = 0.;\n    float power = 0.5;\n    for (int level=0; level<depth; level++) {\n        vec2 uvf = fract(uv/power);\n        vec3 uvi = vec3(floor(uv/power), level);\n        vec4 corners = vec4(random(uvi+vec3(1,1,0)),\n                            random(uvi+vec3(0,1,0)),\n                            random(uvi+vec3(1,0,0)),\n                            random(uvi+vec3(0,0,0)));\n        \n        total += power*midlicate(corners,uvf);\n        power /= 2.;\n    }\n    \n    float totalWeight = 1.-1./float(2<<depth);\n    total /= totalWeight;\n    \n    return vec4(vec3(1.-total),1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = falsePerlin(fragCoord);\n    //fragColor = perlin(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 104, 127, 127, 206], [208, 232, 276, 276, 394], [396, 420, 464, 464, 526], [528, 567, 613, 613, 654], [656, 656, 690, 690, 1575], [1577, 1577, 1632, 1632, 1711]], "test": "untested"}
{"id": "NlX3Wj", "name": "Breathing tiles", "author": "_t4sty", "description": "A simple background effect of breathing colored tiles.\nClick somewhere to get things started.", "tags": ["background", "tiles"], "likes": 0, "viewed": 57, "published": "Public", "date": "1622803165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// UTILS\nfloat pong(in float x)\n{\n    return abs(mod(x, 2.0)-1.0);\n}\n\n// GRID\nfloat falloff(in float x, in float limit) {\n    if (x < limit) return 1.0;\n    return 1.0 - pow(abs(limit-x)/limit, 2.0);\n}\n\nfloat size(in vec2 xy, in float t, in vec2 m)\n{\n    return pow(xy.y, pong(t)) * m.y + m.x;\n}\n\nvec3 color(in vec2 xy, in float t, in vec2 m)\n{\n    return vec3(pong(xy.x), pong(xy.y), pong(t));\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float density = 20.0;\n    float radius = 0.5/density;\n    float t = iTime * 0.3;\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 m = vec2(1.0, 1.0) - iMouse.xy/iResolution.xy;\n    vec2 nearest = ceil(uv * density)/density;\n    float d = distance(uv, nearest);\n    float limit = radius * size(nearest, t, m);\n    float c = falloff(d, limit);\n    vec3 col = color(uv, t, m) * c;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 33, 33, 68], [70, 78, 121, 121, 201], [203, 203, 250, 250, 295], [297, 297, 344, 344, 396], [398, 406, 463, 463, 903]], "test": "untested"}
{"id": "Nt23DK", "name": "Tim Apple's Tunnel", "author": "visy", "description": "tunnel", "tags": ["tunnel"], "likes": 3, "viewed": 41, "published": "Public", "date": "1624747211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR_CLIPPING_PLANE 0.001\n#define FAR_CLIPPING_PLANE 1000.0\n#define NUMBER_OF_MARCH_STEPS 600\n#define EPSILON 0.15\n#define DISTANCE_BIAS 0.2\n\nfloat time = 0.0;\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nconst float kHashScale1 = 443.8975;\n\nfloat hash11(float p) {\n  vec3 p3 = fract(vec3(p) * kHashScale1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\nvec2 scene1(vec3 pos)\n{\n    vec3 translate = vec3(-0.1, fract(pos.z), 0.);\n\n    vec3 opos = pos - translate;\n\n    float finalDist = sdSphere(cos(opos*0.2),1.1+sin(pos.z*0.01+cos(pos.x*1.1)*0.1)*0.2)*3.91;\n    \t\n    return vec2(finalDist, 0.0);\n}\n\n\nvec2 scene(vec3 pos) {\n    float mat = 0.0;\n\tvec2 res1 = scene1(pos);\n    mat = res1.y;\n\treturn vec2(res1.x,mat);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat err(float dist){ return min(EPSILON, pow(dist*0.02, 2.0)); }\n\nvec3 discontinuity_reduction(vec3 origin, vec3 direction, vec3 position){ for(int i = 0; i < 3; i++)position = position + direction * (scene(position).x - err(distance(origin, position))); return position; }\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.0;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        //pos = discontinuity_reduction(position,direction,pos);\n        vec2 result = scene(pos);\n\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, acc,result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec3(FAR_CLIPPING_PLANE, acc, 0.0);\n}\n\nvec3 normal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n    time = fmod(iTime,30.0);\n\n    vec3 direction = normalize(vec3(uv, 0.0));\n    float cx = 0.0;\n    float cy = 0.0;\n    float cz = -time*1.9;\n    \n    vec3 camera_origin = vec3(cx, cy, cz);\n\tvec3 lookAt = vec3(cx,cy,cz+0.1);\n    \n    vec3 forward = normalize(lookAt-camera_origin);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    float FOV = 5.;\n\n    vec3 ro = camera_origin;\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec3 result = raymarch(ro, rd);\n            \n    float fog = pow(1.0 / (1.0 + result.x), 0.2);\n    \n    vec3 materialColor = vec3(1.0, 1.0, 1.0);\n\t\t\n\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    float occ = calcAO( intersection, nrml );\n    vec3 light_dir = normalize(vec3(0.5,0.3,-1.0));\n    vec3 ref = reflect( rd, nrml );\n    float dom = smoothstep( -0.1, 0.9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0.0, 0.3 ),32.0);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,0.4,0.6);\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 ambient_color = vec3(1.0,1.0, 1.0);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*occ*fog+dom*0.2+spe*0.3;\n\tif (result.x >= FAR_CLIPPING_PLANE) outColor = vec3(0.0);\n\tfragColor = vec4(outColor, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 202, 202, 229], [231, 231, 262, 262, 358], [360, 360, 393, 393, 424], [427, 427, 457, 457, 542], [581, 581, 604, 604, 719], [721, 721, 753, 753, 795], [797, 797, 845, 845, 930], [933, 933, 956, 956, 1178], [1181, 1181, 1203, 1203, 1296], [1299, 1299, 1341, 1341, 1642], [1644, 1644, 1666, 1666, 1710], [1712, 1712, 1785, 1785, 1919], [1922, 1922, 1968, 1968, 2561], [2563, 2563, 2591, 2591, 2822], [2826, 2826, 2953, 2953, 3433], [3436, 3436, 3493, 3493, 4948]], "test": "untested"}
{"id": "Nt23R3", "name": "Leispiach", "author": "Amy_CoolDog", "description": "My first shader, making a waving lesbian pride flag :)\nInspired by UwULydia", "tags": ["beginner", "flag", "lgbtq", "lesbian"], "likes": 7, "viewed": 56, "published": "Public", "date": "1624382530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Abigail Cisowska\n// Title: Leispiach\n\n#define PI 3.14159265359\n\n// define colours\nconst vec3 red = vec3(0.83, 0.17, 0.0);\nconst vec3 orange = vec3(0.99, 0.59, 0.33);\nconst vec3 white = vec3(1.0, 1.0, 1.0);\nconst vec3 pink = vec3(0.82, 0.38, 0.63);\nconst vec3 purple = vec3(0.63, 0.0, 0.38);\n\nfloat wave(in vec2 uv) {\n    return (uv.y + (0.08 * sin(iTime + (uv.x * (PI * 3.0)))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // setting each colour, starting with purple (working from the bottom up)\n    vec3 colour = purple;\n    // pink\n    float w = step(0.2, wave(uv));\n    colour = (1.0 - w) * colour + w * pink;\n    // white\n    w = step(0.4, wave(uv));\n    colour = (1.0 - w) * colour + w * white;\n    // orange\n    w = step(0.6, wave(uv));\n    colour = (1.0 - w) * colour + w * orange;\n    // red\n    w = step(0.8, wave(uv));\n    colour = (1.0 - w) * colour + w * red;\n\n    // output to screen\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 303, 327, 327, 392], [394, 394, 449, 499, 1060]], "test": "untested"}
{"id": "Nt23Ry", "name": "Voroflies", "author": "ENDESGA", "description": "Detecting voronoi vertices.", "tags": ["2d", "voronoi", "edgedetection", "edges"], "likes": 5, "viewed": 163, "published": "Public API", "date": "1624150488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getPoint(in vec2 cell) {\n    return cell + 0.5 + 0.5 * vec2(\n    sin((cell.x - cell.y + iTime + fract(length(cell))) * 7.777),\n    sin((cell.x - fract(length(cell))) * 7.777) * sin((cell.x + cell.y * iTime) * 7.777));\n}\n\nfloat getId(in vec2 cell) {\n    return fract(sin(cell.x * 4647.543 + cell.y * 2435.32) * 9658.65);\n}\n\nfloat voronoi(in vec2 pixel) {\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y * (2.0);\n    \n    uv *= distance(uv, vec2(0.0));\n    uv += vec2(cos(iTime * 0.777) + 0.777);\n    vec2 cell = floor(uv);\n\n    float minDist = 1e20;\n    float id = 0.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCell = cell + (vec2(i, j));\n            float curDist = length(uv - getPoint(curCell));\n            if (curDist < minDist) {\n                id = getId(curCell);\n                minDist = curDist;\n            }\n        }\n    }\n\n    return id;\n}\n\nvec4 render(in vec2 px) {\n    float  d1 = voronoi(px + vec2(1.0, 0.0)),\n           d2 = voronoi(px - vec2(1.0, 0.0)),\n           d3 = voronoi(px + vec2(0.0, 1.0)),\n           d4 = voronoi(px - vec2(0.0, 1.0)),\n           n = (abs(d1-d2)>0.?1.:0.) \n                +(abs(d1-d3)*abs(d2-d3)>0.?1.:0.)\n                +(abs(d1-d4)*abs(d2-d4)*abs(d3-d4)>0.0?1.:0.);\n    return step(vec4(2,2,2,0),vec4(n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (render(fragCoord));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 224], [226, 226, 253, 253, 326], [328, 328, 358, 358, 921], [923, 923, 948, 948, 1325], [1327, 1327, 1382, 1382, 1421]], "test": "untested"}
{"id": "Nt23Wh", "name": "Breathing Colors", "author": "Sudospective", "description": "I figured I'd mess with the ShaderToy's default for a new shader to give it a more serene breathe between the colors, as well as add an extra. I literally learned about creating my own shaders a little while ago, and I'm just starting to get my feet wet.", "tags": ["2d", "colors", "beginner", "rainbow"], "likes": 2, "viewed": 38, "published": "Public", "date": "1623899963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 3.0;\n\n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5*cos((iTime*0.5)+uv.xyx+vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5*sin((iTime*0.5)+uv.yxy+vec3(2,4,0));\n    vec3 col3 = 0.5 + 0.5*cos((iTime*0.5)+uv.xyx+vec3(4,0,2));\n    \n    float clamp1 = clamp(sin(iTime * 0.75) * 0.1 + 0.5, 0.0, 1.0);\n    float clamp2 = clamp(cos(iTime * 0.25) * 0.1 + 0.5, 0.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(mix(mix(col1, col2, clamp1), col3, clamp2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 611]], "test": "untested"}
{"id": "Nt2GDR", "name": "Value Noise in 147 chars", "author": "Xor", "description": "Based on my [url=https://www.shadertoy.com/view/WsGyRW]other[/URL] noise shaders.", "tags": ["2d", "noise", "short", "tweet", "golf"], "likes": 3, "viewed": 66, "published": "Public", "date": "1623714083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//FabriceNeyret2 - 145 chars\n\nvoid mainImage(out vec4 O, vec2 I)   \n{\n    vec4 i = floor( O = vec4(I+=iTime/.01,-I)/32. );\n    O += dot((O-=i)*O.yzwx, fract(sin(vec4(93,92,0,1) + i.x+92.*i.y)*7e4) )-O;\n}\n\n/*\n//Original - 147 chars\n\nvoid mainImage(out vec4 O, vec2 I)   \n{\n\tO = vec4(I+=iTime/.01,-I)/32.; vec4 i;\n\tO -= i = floor(O);\n    O += dot(O*O.yzwx, fract(sin(vec4(93,92,0,1) + i.x+92.*i.y)*7e4) )-O;\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 69, 69, 203]], "test": "untested"}
{"id": "Nt2GRW", "name": "Mountain lakes", "author": "jarble", "description": "Yet another fractal terrain experiment.\nThis landscape isn't very realistic: I prefer [url=https://www.shadertoy.com/view/NljXWK]this one[/url].", "tags": ["fractal", "terrain", "river", "mountain"], "likes": 8, "viewed": 209, "published": "Public API", "date": "1623436913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 1.5;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)-.3) * amplitude));\n        \n        amplitude *= .27;\n        \n        freq *= 3.-value/8.0;\n        \n        //uv = uv.yx;\n    }\n    \n    return (value*2.0-3.15)/2.0;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 410, 435, 435, 469], [490, 490, 513, 562, 997], [1072, 1072, 1110, 1110, 1170], [1172, 1172, 1205, 1205, 1425], [1427, 1427, 1465, 1465, 1692], [1694, 1694, 1732, 1732, 1956], [1958, 1958, 1987, 1987, 2082], [2084, 2084, 2121, 2121, 2180], [2183, 2251, 2270, 2270, 2309], [2311, 2311, 2331, 2331, 2407], [2409, 2409, 2428, 2428, 2467], [2469, 2469, 2526, 2526, 2761], [2763, 2763, 2798, 2798, 3192], [3194, 3194, 3248, 3248, 3914], [3917, 3917, 3969, 3969, 4404], [4406, 4406, 4463, 4463, 5654]], "test": "untested"}
{"id": "Nt2GWy", "name": "Spherical Shell with Slits (AA+g", "author": "FabriceNeyret2", "description": "antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. [url]https://shadertoy.com/view/Nt2GWG[/url]", "tags": ["raymarching", "sphere", "short"], "likes": 8, "viewed": 195, "published": "Public API", "date": "1624628529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. https://shadertoy.com/view/Nt2GWG\n// 2021-06-25 13:38:48   ( 703 chars )\n\n                                      // distance to strips + AA blending\n#define S(s,C) P = vec3(0, 0, 5) + ( s sqrt(r) - b ) * D,                    \\\n               a = acos(P.y/2.) - sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n               d = sin(a/.1),                                                \\\n               O = mix(O, C, clamp( 1.- d/fwidth(d), 0.,1. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 P = iResolution,\n         D =  normalize( vec3( ( u+u - P.xy ) / min(P.x, P.y), -2 ) );\n\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    if (r < 0.) return;                                                  // out of sphere     \n    S( , ( .5 +  .7* cos( a  + vec4(0,23,21,0)  ) ) * (.5+P.z*P.z/4.) ); // back sphere\n    S(-,  vec4(P.z*P.z/2.) );                                            // front sphere\n}\n\n\n\n\n\n\n\n/* // --- 404 chars\n\n           // distance to strips\n#define S  a = acos(P.y/2.) -sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n           d = sin(a/.1) \n           \n#define A  clamp( 1.- (d-3e-5)/fwidth(d), 0.,1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec3 P = vec3(0, 0, 5),\n         D =  normalize( vec3( ( u+u - R) / min(R.x, R.y), -2 ) );\n\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    if (r < 0.) return;                // out of sphere\n    \n    r = sqrt(r);\n    P += ( r - b ) * D; S;             // intersection on back sphere\n    O += ( .5 +  .7* cos( a  + vec4(0,23,21,0)  ) )  * A * (.5+P.z*P.z/4.);\n\n    P -= 2.*r * D; S;                  // intersection on front sphere\n    O = mix(O, vec4(P.z*P.z/2.), A );   \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 540, 578, 578, 1000]], "test": "untested"}
{"id": "Nt2Gzh", "name": "ray marching city scene", "author": "katila4", "description": "ray marching, learning", "tags": ["raymarching"], "likes": 4, "viewed": 86, "published": "Public", "date": "1623784049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 800;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 950.0;\nconst float EPSILON = 0.5;\n\nvec3 EMPTY_COLOR = vec3(207.0 / 255.0, 212.0 / 255.0, 222.0 / 255.0);\nvec4 EMPTY_COLOR_4 = vec4(207.0 / 255.0, 212.0 / 255.0, 222.0 / 255.0, 0.0);\n\nvec3 CAMERA_OFFSET = vec3(-3.0, 2.0, -66.0);\n\n// floor\nvec3 FLOOR_COLOR = vec3(142.0 / 255.0, 82.0 / 255.0, 245.0 / 255.0);\nvec3 FLOOR_SIZE = vec3(1400.0, 2.0, 600.0);\nvec3 FLOOR_POS = vec3(0.0, 6.0, -0.0);\n\n// back building\nvec3 BUILDING_BACK_COLOR = vec3(18.0 / 255.0, 44.0 / 255.0, 90.0 / 255.0);\nvec3 BUILDING_BACK_SIZE = vec3(10.0, 200.0, 20.0);\nvec3 BUILDING_BACK_POS = vec3(0.0, 80.0, -400.0);\n\n// building 1 right\nvec3 BUILDING_1_COLOR = vec3(18.0 / 255.0, 44.0 / 255.0, 90.0 / 255.0);\nvec3 BUILDING_1_SIZE = vec3(26.0, 13.5 + 50.0 + 100.0, 10.0);\nvec3 BUILDING_1_POS = vec3(32.0 + 6.0, -12.0 - 50.0 + 100.0, -13.0);\n\nvec3 BUILDING_1_1_COLOR = vec3(56.0 / 255.0, 251.0 / 255.0, 219.0 / 255.0);\nvec3 BUILDING_1_1_SIZE = vec3(2.0, 2.0, 2.0);\nvec3 BUILDING_1_1_POS = vec3(7.5 + 6.0, -1.5, -17.0 + 2.2);\n\nvec3 BUILDING_1_2_POS = vec3(7.5 + 6.0, -1.5, -17.0 + 9.0 + 2.2);\n\n// building 2 left\nvec3 BUILDING_2_COLOR = vec3(12.0 / 255.0, 30.0 / 255.0, 62.0 / 255.0);\nvec3 BUILDING_2_SIZE = vec3(26.0, 7.5 + 100.0, 14.0);\nvec3 BUILDING_2_POS = vec3(-30.0 - 9.0, -6.0 + 100.0, -16.0);\n\nvec3 BUILDING_2_1_COLOR = vec3(252.0 / 255.0, 15.0 / 255.0, 245.0 / 255.0);\nvec3 BUILDING_2_1_SIZE = vec3(1.2, 1.2, 1.2);\nvec3 BUILDING_2_1_POS = vec3(-3.5 - 9.0, -0.5, -17.0 + 2.2 - 9.0);\n\n// building 3 left\nvec3 BUILDING_3_COLOR = vec3(41.0 / 255.0, 65.0 / 255.0, 106.0 / 255.0);\nvec3 BUILDING_3_SIZE = vec3(26.0, 9.5 + 100.0, 6.0);\nvec3 BUILDING_3_POS = vec3(-30.0 - 7.0, -8.0 + 100.0, 6.0);\n\n// building 4 right\nvec3 BUILDING_4_COLOR = vec3(83.0 / 255.0, 102.0 / 255.0, 135.0 / 255.0);\nvec3 BUILDING_4_SIZE = vec3(26.0, 9.5 + 100.0, 10.0);\nvec3 BUILDING_4_POS = vec3(32.0 + 6.0, -8.0 + 100.0, 11.0);\n\n// building 5 right\nvec3 BUILDING_5_COLOR = vec3(58.0 / 255.0, 71.0 / 255.0, 94.0 / 255.0);\nvec3 BUILDING_5_SIZE = vec3(26.0, 17.5 + 100.0, 10.0);\nvec3 BUILDING_5_POS = vec3(32.0 + 7.0, -16.0 + 100.0, 34.0);\n\n// building 6 left\nvec3 BUILDING_6_COLOR = vec3(34.0 / 255.0, 42.0 / 255.0, 56.0 / 255.0);\nvec3 BUILDING_6_SIZE = vec3(26.0, 17.5 + 10.0 + 100.0, 16.0);\nvec3 BUILDING_6_POS = vec3(-30.0 - 7.0, -16.0 - 10.0 + 100.0, 30.0);\n\n// building 7 left\nvec3 BUILDING_7_COLOR = vec3(83.0 / 255.0, 102.0 / 255.0, 135.0 / 255.0);\nvec3 BUILDING_7_SIZE = vec3(26.0, 17.5 + 100.0, 24.0);\nvec3 BUILDING_7_POS = vec3(-30.0 - 7.0, -16.0 + 100.0, -58.0);\n\n// building 8 right\nvec3 BUILDING_8_COLOR = vec3(41.0 / 255.0, 65.0 / 255.0, 106.0 / 255.0);\nvec3 BUILDING_8_SIZE = vec3(26.0, 3.5 + 5.0 + 100.0, 20.0);\nvec3 BUILDING_8_POS = vec3(32.0 + 7.0, -2.0 - 5.0 + 100.0, -47.0);\n\n// sign\nvec4 SIGN_COLOR = vec4(142.0 / 255.0, 82.0 / 255.0, 245.0 / 255.0, 1.0);\nvec3 SIGN_SIZE = vec3(4.0, 2.0, 0.5);\nvec3 SIGN_POS = vec3(0.0 - 2.0 - 4.0, 60.0 - 30.0 - 30.0 - 20.0 - 8.0, -47.0 + 15.0 - 4.5);\n\n// sign 2\nvec4 SIGN_2_COLOR = vec4(142.0 / 255.0, 82.0 / 255.0, 245.0 / 255.0, 1.0);\nvec3 SIGN_2_SIZE = vec3(8.0, 2.0, 0.5);\nvec3 SIGN_2_POS = vec3(0.0 - 2.0 - 4.0 + 10.0 + 4.0 + 1.0, \n                        60.0 - 30.0 - 30.0 - 20.0 - 8.0 + 30.0, \n                        -47.0 + 15.0 - 4.5 + 20.0 + 20.0 + 25.0);\n                        \n// sign 3\nvec4 SIGN_3_COLOR = vec4(44.0 / 255.0, 200.0 / 255.0, 175.0 / 255.0, 1.0);\nvec3 SIGN_3_SIZE = vec3(4.0, 10.0, 0.5);\nvec3 SIGN_3_POS = vec3(0.0 - 2.0 - 4.0 + 10.0 + 4.0 + 1.0, \n                       60.0 - 30.0 - 30.0 - 20.0 - 8.0 + 30.0 + 50.0, \n                       -47.0 + 15.0 - 4.5 + 20.0 + 20.0 + 25.0 - 50.0);\n\nfloat TOTAL_PLAY_TIME = 0.85;\nfloat JUMP_PLAY_TIME = 10.02;\nfloat JUMP_ON_FLY_TIME = 0.4;\nfloat JUMP_OFF_FLY_TIME = 0.4;\nfloat JUMP_WAIT_TIME = 0.1;\n\nfloat GetTime()\n{\n    return iTime;\n}\n\nfloat GetCurrentTime()\n{\n    return mod(GetTime(), TOTAL_PLAY_TIME) / TOTAL_PLAY_TIME;\n}\n\nint GetCurrentCycle()\n{\n    return int(GetTime() / TOTAL_PLAY_TIME);\n}\n\nfloat GetCurrentJumpTime()\n{\n    return mod(GetTime(), JUMP_PLAY_TIME) / JUMP_PLAY_TIME;\n}\n\nfloat EaseOut(float x)\n{\n\treturn 1.0 - pow(1.0 - x, 3.0);   \n}\n\nfloat EaseOutQuad(float x)\n{\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nfloat EaseInQuad(float x)\n{\n    return x * x;\n}\n\nfloat EaseInCubic(float x) \n{\n    return x * x * x;\n}\n\nvec3 Lerp(vec3 from, vec3 to, float t) {\n    vec3 res = mix(from, to, t);\n    return res;\n}\n\nfloat LerpF(float from, float to, float t) {\n    float res = mix(from, to, t);\n    return res;\n}\n\nfloat quadSDF(vec3 p, vec3 pos, vec3 size) {\n    p += pos;\n    vec3 d = abs(p) - size;\n\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nvec3 sceneColorBySDF(float sdf, vec3 color)\n{\n    return step(sdf, EPSILON) * color;\n}\n\nvec4 sceneColorBySDF4(float sdf, vec4 color)\n{\n    return step(sdf, EPSILON) * color;\n}\n\nvec4 building1SDF(vec3 p, vec3 pos, float tColor) {\n    float b1 = quadSDF(p, pos + BUILDING_1_POS, BUILDING_1_SIZE);\n    \n    float sdf = b1;\n    \n    vec3 color = sceneColorBySDF(b1, mix(BUILDING_1_COLOR, EMPTY_COLOR, tColor));\n                 \n    return vec4(color, sdf);\n}\n\nvec4 building2SDF(vec3 p, vec3 pos, float tColor) {\n    float b2 = quadSDF(p, pos + BUILDING_2_POS, BUILDING_2_SIZE);\n\n    float sdf = b2;\n    \n    vec3 color = sceneColorBySDF(b2, mix(BUILDING_2_COLOR, EMPTY_COLOR, tColor));\n                 \n    return vec4(color, sdf);\n}\n\nvec4 backBuildingSDF(vec3 p, vec3 pos, float tColor) {\n    float b2 = quadSDF(p, pos + BUILDING_BACK_POS, BUILDING_BACK_SIZE);\n    \n    float sdf = b2;\n    \n    vec3 color = sceneColorBySDF(b2, mix(BUILDING_BACK_COLOR, EMPTY_COLOR, tColor));\n    \n    return vec4(color, sdf);\n}\n\nvec4 signSDF(vec3 p, vec3 pos, float tColor, out float dist) {\n    dist = quadSDF(p, pos + SIGN_POS, SIGN_SIZE);\n    \n    vec4 color = sceneColorBySDF4(dist, mix(SIGN_COLOR, EMPTY_COLOR_4, tColor));\n    return color;\n}\n\nvec4 sign2SDF(vec3 p, vec3 pos, float tColor, out float dist) {\n    dist = quadSDF(p, pos + SIGN_2_POS, SIGN_2_SIZE);\n    \n    vec4 color = sceneColorBySDF4(dist, mix(SIGN_2_COLOR, EMPTY_COLOR_4, tColor));\n    return color;\n}\n\nvec4 sign3SDF(vec3 p, vec3 pos, float tColor, out float dist) {\n    dist = quadSDF(p, pos + SIGN_3_POS, SIGN_3_SIZE);\n    \n    vec4 color = sceneColorBySDF4(dist, mix(SIGN_3_COLOR, EMPTY_COLOR_4, tColor));\n    return color;\n}\n\nvec4 sceneSDF(vec3 samplePoint, out float dist) {\n    float t = GetCurrentTime();\n    float appearT = LerpF(1.0, 0.5, t);\n    float appearT2 = LerpF(0.5, 0.0, EaseOut(t));\n    \n    int cycle = GetCurrentCycle();\n    \n    float tt = LerpF(0.0, 1.2, sin(t * 3.14));\n    \n    float jt = GetCurrentJumpTime();\n    float jwt = (max(0.0, GetCurrentJumpTime() - JUMP_WAIT_TIME)) / (1.0 - JUMP_WAIT_TIME);\n    \n    float jtt = min(1.0, jwt / JUMP_ON_FLY_TIME);\n    float jtl = 1.0 - (JUMP_ON_FLY_TIME + JUMP_OFF_FLY_TIME);\n    float jtt2 = min(1.0, max(0.0, (jwt - jtl - JUMP_ON_FLY_TIME) / JUMP_OFF_FLY_TIME));\n    \n    float MOVE = 140.0;\n    \n    vec3 cameraMove = vec3(0.0, 0.0, MOVE * t) + CAMERA_OFFSET + vec3(6.0 * jtt - 6.0 * jtt2, 12.0 * sin(jt * 3.14 * 2.0), 0.0);\n    vec3 dublicate_offset = vec3(0.0, 0.0, -MOVE);\n    \n    float b3 = quadSDF(samplePoint, BUILDING_3_POS + cameraMove, BUILDING_3_SIZE);\n    float b4 = quadSDF(samplePoint, BUILDING_4_POS + cameraMove, BUILDING_4_SIZE);\n    float b5 = quadSDF(samplePoint, BUILDING_5_POS + cameraMove, BUILDING_5_SIZE);\n    float b6 = quadSDF(samplePoint, BUILDING_6_POS + cameraMove, BUILDING_6_SIZE);\n    float b7 = quadSDF(samplePoint, BUILDING_7_POS + cameraMove, BUILDING_7_SIZE);\n    float b8 = quadSDF(samplePoint, BUILDING_8_POS + cameraMove, BUILDING_8_SIZE);\n\n    float b3_c = quadSDF(samplePoint, BUILDING_3_POS + cameraMove + dublicate_offset, BUILDING_3_SIZE);\n    float b4_c = quadSDF(samplePoint, BUILDING_4_POS + cameraMove + dublicate_offset, BUILDING_4_SIZE);\n    float b5_c = quadSDF(samplePoint, BUILDING_5_POS + cameraMove + dublicate_offset, BUILDING_5_SIZE);\n    float b6_c = quadSDF(samplePoint, BUILDING_6_POS + cameraMove + dublicate_offset, BUILDING_6_SIZE);\n    float b7_c = quadSDF(samplePoint, BUILDING_7_POS + cameraMove + dublicate_offset, BUILDING_7_SIZE);\n    float b8_c = quadSDF(samplePoint, BUILDING_8_POS + cameraMove + dublicate_offset, BUILDING_8_SIZE);\n\n    float b3_c_2 = quadSDF(samplePoint, BUILDING_3_POS + cameraMove + dublicate_offset * 2.0, BUILDING_3_SIZE);\n    float b4_c_2 = quadSDF(samplePoint, BUILDING_4_POS + cameraMove + dublicate_offset * 2.0, BUILDING_4_SIZE);\n    float b5_c_2 = quadSDF(samplePoint, BUILDING_5_POS + cameraMove + dublicate_offset * 2.0, BUILDING_5_SIZE);\n    float b6_c_2 = quadSDF(samplePoint, BUILDING_6_POS + cameraMove + dublicate_offset * 2.0, BUILDING_6_SIZE);\n    float b7_c_2 = quadSDF(samplePoint, BUILDING_7_POS + cameraMove + dublicate_offset * 2.0, BUILDING_7_SIZE);\n    float b8_c_2 = quadSDF(samplePoint, BUILDING_8_POS + cameraMove + dublicate_offset * 2.0, BUILDING_8_SIZE);\n    \n    float f1 = quadSDF(samplePoint, FLOOR_POS + cameraMove + vec3(0.0, 0.0, -MOVE * t), FLOOR_SIZE);\n    \n    vec4 bb = backBuildingSDF(samplePoint, cameraMove + vec3(0.0, 0.0, -MOVE * t), 0.5);\n    \n    vec4 b1 = building1SDF(samplePoint, cameraMove, 0.0);\n    vec4 b1_1 = building1SDF(samplePoint, cameraMove + dublicate_offset, appearT2);\n    vec4 b1_2 = building1SDF(samplePoint, cameraMove + dublicate_offset * 2.0, appearT);\n    \n    vec4 b2 = building2SDF(samplePoint, cameraMove, 0.0);\n    vec4 b2_1 = building2SDF(samplePoint, cameraMove + dublicate_offset, appearT2);\n    vec4 b2_2 = building2SDF(samplePoint, cameraMove + dublicate_offset * 2.0, appearT);\n    \n    float sSDF = 0.0;\n    float sSDF_1 = 0.0;\n    float sSDF_2 = 0.0;\n    \n    float signMult_1_2 = step(0.1, mod(float(cycle + 2), 4.0)) * step(mod(float(cycle + 2), 4.0), 1.9);\n    float signMult_1_1 = step(1.1, mod(float(cycle + 2), 4.0)) * step(mod(float(cycle + 2), 4.0), 2.9);\n    float signMult_1 = step(2.1, mod(float(cycle + 2), 4.0)) * step(mod(float(cycle + 2), 4.0), 3.9);\n    \n    vec4 s = signSDF(samplePoint, cameraMove, 0.0, sSDF);\n    vec4 s_1 = signSDF(samplePoint, cameraMove + dublicate_offset, appearT2, sSDF_1);\n    vec4 s_2 = signSDF(samplePoint, cameraMove + dublicate_offset * 2.0, appearT, sSDF_2);\n    \n    float s2SDF = 0.0;\n    float s2SDF_1 = 0.0;\n    float s2SDF_2 = 0.0;\n    \n    float signMult2 = step(0.1, mod(float(cycle), 4.0)) * step(mod(float(cycle), 4.0), 1.9);\n    float signMult1 = step(1.1, mod(float(cycle), 4.0)) * step(mod(float(cycle), 4.0), 2.9);\n    float signMult = step(2.1, mod(float(cycle), 4.0)) * step(mod(float(cycle), 4.0), 3.9);\n    \n    vec4 s2 = sign2SDF(samplePoint, cameraMove, 0.0, s2SDF);\n    vec4 s2_1 = sign2SDF(samplePoint, cameraMove + dublicate_offset, appearT2, s2SDF_1);\n    vec4 s2_2 = sign2SDF(samplePoint, cameraMove + dublicate_offset * 2.0, appearT, s2SDF_2);\n    \n    float s3SDF = 0.0;\n    float s3SDF_1 = 0.0;\n    float s3SDF_2 = 0.0;\n    \n    float signMult_3_2 = step(0.1, mod(float(cycle + 1), 4.0)) * step(mod(float(cycle + 1), 4.0), 1.9);\n    float signMult_3_1 = step(1.1, mod(float(cycle + 1), 4.0)) * step(mod(float(cycle + 1), 4.0), 2.9);\n    float signMult_3 = step(2.1, mod(float(cycle + 1), 4.0)) * step(mod(float(cycle + 1), 4.0), 3.9);\n    \n    vec4 s3 = sign3SDF(samplePoint, cameraMove, 0.0, s3SDF);\n    vec4 s3_1 = sign3SDF(samplePoint, cameraMove + dublicate_offset, appearT2, s3SDF_1);\n    vec4 s3_2 = sign3SDF(samplePoint, cameraMove + dublicate_offset * 2.0, appearT, s3SDF_2);\n    \n    vec4 res = vec4(\n                bb.rgb +\n                b1.rgb +\n                b1_1.rgb +\n                b1_2.rgb +\n                b2.rgb +\n                b2_1.rgb +\n                b2_2.rgb +\n                \n                sceneColorBySDF(b3, BUILDING_3_COLOR) + \n                sceneColorBySDF(b4, BUILDING_4_COLOR) + \n                sceneColorBySDF(b5, BUILDING_5_COLOR) + \n                sceneColorBySDF(b6, BUILDING_6_COLOR) + \n                sceneColorBySDF(b7, BUILDING_7_COLOR) + \n                sceneColorBySDF(b8, BUILDING_8_COLOR) + \n\n                sceneColorBySDF(b3_c, mix(BUILDING_3_COLOR, EMPTY_COLOR, appearT2)) + \n                sceneColorBySDF(b4_c, mix(BUILDING_4_COLOR, EMPTY_COLOR, appearT2)) + \n                sceneColorBySDF(b5_c, mix(BUILDING_5_COLOR, EMPTY_COLOR, appearT2)) + \n                sceneColorBySDF(b6_c, mix(BUILDING_6_COLOR, EMPTY_COLOR, appearT2)) + \n                sceneColorBySDF(b7_c, mix(BUILDING_7_COLOR, EMPTY_COLOR, appearT2)) + \n                sceneColorBySDF(b8_c, mix(BUILDING_8_COLOR, EMPTY_COLOR, appearT2)) + \n                \n                sceneColorBySDF(b3_c_2, mix(BUILDING_3_COLOR, EMPTY_COLOR, appearT)) + \n                sceneColorBySDF(b4_c_2, mix(BUILDING_4_COLOR, EMPTY_COLOR, appearT)) + \n                sceneColorBySDF(b5_c_2, mix(BUILDING_5_COLOR, EMPTY_COLOR, appearT)) + \n                sceneColorBySDF(b6_c_2, mix(BUILDING_6_COLOR, EMPTY_COLOR, appearT)) + \n                sceneColorBySDF(b7_c_2, mix(BUILDING_7_COLOR, EMPTY_COLOR, appearT)) + \n                sceneColorBySDF(b8_c_2, mix(BUILDING_8_COLOR, EMPTY_COLOR, appearT)), 0.0);\n    \n    res = res + s * signMult_1 + s_1 * signMult_1_1 + s_2 * signMult_1_2 + s2 * signMult + s2_1 * signMult1 + s2_2 * signMult2 + s3 * signMult_3 + s3_1 * signMult_3_1 + s3_2 * signMult_3_2;\n    \n    dist = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(\n                min(b1.a, b2.a), b1_1.a), b1_2.a), b2_1.a), b2_2.a), b3), b4), b5), b6), b7), b8), b3_c), b4_c), b5_c), b6_c), b7_c), b8_c), \n                b3_c_2), b4_c_2), b5_c_2), b6_c_2), b7_c_2), b8_c_2), bb.a);\n                \n    if (signMult_1 > 0.0)\n    {\n        dist = min(dist, sSDF);\n    }\n    \n    if (signMult_1_1 > 0.0)\n    {\n        dist = min(dist, sSDF_1);\n    }\n    \n    if (signMult_1_2 > 0.0)\n    {\n        dist = min(dist, sSDF_2);\n    }\n\n    if (signMult > 0.0)\n    {\n        dist = min(dist, s2SDF);\n    }\n    \n    if (signMult1 > 0.0)\n    {\n        dist = min(dist, s2SDF_1);\n    }\n    \n    if (signMult2 > 0.0)\n    {\n        dist = min(dist, s2SDF_2);\n    }\n    \n    if (signMult_3 > 0.0)\n    {\n        dist = min(dist, s3SDF);\n    }\n    \n    if (signMult_3_1 > 0.0)\n    {\n        dist = min(dist, s3SDF_1);\n    }\n    \n    if (signMult_3_2 > 0.0)\n    {\n        dist = min(dist, s3SDF_2);\n    }\n    \n    return res;\n}\n\nvec4 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = 0.0;\n        vec4 col = sceneSDF(eye + depth * marchingDirection, dist);\n        if (dist < EPSILON) {\n\t\t\treturn col;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return EMPTY_COLOR_4;\n        }\n    }\n    return EMPTY_COLOR_4;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 0.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0 * 1.5, iResolution.xy, fragCoord);\n    \n    float t = GetCurrentTime();\n    float tt = sin(t * 3.14 * 2.0);\n\n    float jt = GetCurrentJumpTime();\n    \n    float jwt = (max(0.0, GetCurrentJumpTime() - JUMP_WAIT_TIME)) / (1.0 - JUMP_WAIT_TIME);\n    \n    \n    float jtt = min(1.0, jwt / JUMP_ON_FLY_TIME);\n    float jtl = 1.0 - (JUMP_ON_FLY_TIME + JUMP_OFF_FLY_TIME);\n    float jtt2 = min(1.0, max(0.0, (jwt - jtl - JUMP_ON_FLY_TIME) / JUMP_OFF_FLY_TIME));\n\n    vec3 eye = vec3(-0.25, -0.25, -4.0);\n\n    float rotX = 0.25 * sin(jt * 3.14 * 2.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(-0.1, 0.2, 0.2), vec3(rotX, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec4 col = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    float st = max(fragCoord.y / iResolution.y - 0.5, 0.0);\n    col = mix(col, vec4(1.0, 0.0, 1.0, 0.2), st);\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3377, 3857, 3874, 3874, 3894], [3896, 3896, 3920, 3920, 3984], [3986, 3986, 4009, 4009, 4056], [4058, 4058, 4086, 4086, 4148], [4150, 4150, 4174, 4174, 4212], [4214, 4214, 4242, 4242, 4284], [4286, 4286, 4313, 4313, 4333], [4335, 4335, 4364, 4364, 4388], [4390, 4390, 4430, 4430, 4481], [4483, 4483, 4527, 4527, 4579], [4581, 4581, 4625, 4625, 4826], [4828, 4828, 4873, 4873, 4914], [4916, 4916, 4962, 4962, 5003], [5005, 5005, 5056, 5056, 5283], [5285, 5285, 5336, 5336, 5559], [5561, 5561, 5615, 5615, 5838], [5840, 5840, 5902, 5902, 6058], [6060, 6060, 6123, 6123, 6285], [6287, 6287, 6350, 6350, 6512], [6514, 6514, 6563, 6563, 14577], [14579, 14579, 14669, 14669, 15023], [15025, 15025, 15090, 15090, 15222], [15224, 15224, 15273, 15273, 15501], [15503, 15503, 15560, 15560, 16506]], "test": "untested"}
{"id": "NtB3DG", "name": "Ball of Saturation", "author": "egon", "description": "Color-wheel using hsv for the ball and outer circle.", "tags": ["colorwheel"], "likes": 1, "viewed": 256, "published": "Public", "date": "1624563526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (2.0*3.1415926538)\n\nvec2 rot(vec2 pos, float a) {\n\tfloat sn = sin(a);\n\tfloat cs = cos(a);\n\treturn mat2(cs, -sn, sn, cs) * pos;\n}\n\nfloat map(float p, float ss, float se, float ds, float de)\n{\n    return ds + (p-ss)*(de-ds)/(se-ss);\n}\n\nfloat shade(vec2 pos, float dir) {\n    pos = rot(pos, dir);\n    float h = cos(pos.x);\n    return map(pos.y, h, -h, 0.0, 1.0);\n}\n\n//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsv2rgb_subtractive( in vec3 c ) {\n    float frac = fract(c.x)*6.0;\n    vec3 col = smoothstep(vec3(3,0,3),vec3(2,2,4),vec3(frac));\n    col += smoothstep(vec3(4,3,4),vec3(6,4,6),vec3(frac)) * vec3(1, -1, -1);\n    return mix(vec3(1), col, c.y) * c.z;\n}\n\n\n// CIELab to rgb conversion from https://www.shadertoy.com/view/llcXDN\n\nfloat ref_X = 95.047;\nfloat ref_Y = 100.000;\nfloat ref_Z = 108.883;\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float inside  = 0.3 * iResolution.y;\n    float mid     = 0.35 * iResolution.y;\n    float outside = 0.45 * iResolution.y;\n    \n    vec2 off = center - uv;\n\n    float h = mod(iTime*0.1, 1.0);\n    if(iMouse.z > 0.0){\n        vec2 p = normalize(center - iMouse.xy);\n        h = atan(-p.y, -p.x) / TAU;\n    }\n\n    float d = length(off);\n    if(d < inside){\n        off /= inside;\n\n        float v = shade(off, 0.0/3.0 * TAU);\n        float s = shade(off, -1.0/4.0 * TAU);\n\n        fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n    } else if (mid < d && d < outside) {\n        off = normalize(off);\n        float h = atan(-off.y, -off.x) / TAU;\n        fragColor = vec4(hsv2rgb_subtractive(vec3(h, 0.85, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.13, 0.15, 1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 61, 61, 140], [142, 142, 202, 202, 244], [246, 246, 280, 280, 373], [375, 471, 493, 493, 824], [826, 826, 848, 848, 1017], [1020, 1020, 1059, 1059, 1275], [1278, 1419, 1443, 1443, 2115], [2117, 2117, 2144, 2144, 2753], [2755, 2755, 2782, 2782, 2821], [2823, 2823, 2880, 2880, 3736]], "test": "untested"}
{"id": "NtB3Rz", "name": "2d-Isolinea--v0", "author": "jorge2017a1", "description": "2d-Isolinea--v0", "tags": ["2disolineav0"], "likes": 1, "viewed": 28, "published": "Public", "date": "1623184611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia\n//https://iquilezles.org/www/articles/distance/distance.htm\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n//Corrected by FabriceNeyret2,\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = distObj > 0. ? colOut : pColObj;\n  colOut = mix(colOut,vec3(0) ,smoothstep( fwidth(distObj), 0., abs(distObj) ));\n  return colOut;\n}\n\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\n\n\nfloat IsoLineaFra(vec2 p)\n{\n    float x,y;\n    float a, r;\n    x=p.x; y=p.y;\n    \n    \n    r = length(p); //sqrt(x*x+y*y);\n    a = atan(y,x);\n    \n    float fra = r - 1.0 + sin(3.0*a+2.0*r*r)/2.0;\n    return fra;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv*=1.5;\n     \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float isf1= IsoLineaFra(uv);\n    col= ponerBorde2(vec3(0.5), col, isf1 );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 273, 309, 309, 354], [360, 391, 452, 452, 596], [600, 600, 660, 660, 786], [790, 790, 817, 817, 1004], [1006, 1006, 1063, 1113, 1464]], "test": "untested"}
{"id": "NtB3Wc", "name": "Circle Overlap Pattern", "author": "DrDesten", "description": "Inspired by a video from \"Art of Code\"", "tags": ["circles", "colorful", "trippy"], "likes": 4, "viewed": 75, "published": "Public", "date": "1624813357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Controls (Play with these)\n//////////////////////////////////////////////////////////////////\n#define PROXIMITY_CHECK 2\n#define GRID_SIZE 35.\n\n#define SPEED 0.3\n#define WAVE_SIZE 3.\n\n#define MAX_RADIUS 1.8\n#define MIN_RADIUS 0.03\n\n#define ROTATION_SPEED .01\n\n\n// Constants\n#define PI 3.14159265359\n\nfloat circle(vec2 p, float r, vec2 c) {\n    vec2 d = p - c;\n    return step(dot(d, d), r*r);\n}\nfloat circle(vec2 p, float r, vec2 c, vec2 px) {\n    vec2 d = p - c;\n    return step(dot(d, d), r*r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = (fragCoord - iResolution.xy * .5)/iResolution.x;\n    \n    \n    float ang      = PI * ROTATION_SPEED * iTime;\n    float s        = sin(ang);\n    float c        = cos(ang);\n    mat2  rotation = mat2(c, s, -s, c);\n    \n    uv = rotation * uv;\n    uv *= sin(iTime * .3) * .3 + 1.;\n    \n    vec2 guv = fract(uv * GRID_SIZE) - 0.5;\n    vec2 gid = floor(uv * GRID_SIZE);\n    \n    float sinArgument = iTime * SPEED + length(uv * WAVE_SIZE);\n    float radius      = sin(sinArgument) * .5 + .5;\n    \n    //radius            = fract(sin(sinArgument)); // This creates an interesting Effect\n    \n    radius            = radius * (MAX_RADIUS - MIN_RADIUS) + MIN_RADIUS;\n \n    vec3 col = vec3(0);\n    \n    float circles = 0.;\n    for (int x = -PROXIMITY_CHECK; x <= PROXIMITY_CHECK; x++) {\n        for (int y = -PROXIMITY_CHECK; y <= PROXIMITY_CHECK; y++) {\n            \n            vec2 relativeUV = guv + vec2(x, y);\n            \n            circles += circle(vec2(0), radius, relativeUV);\n        \n        }\n    }\n    \n    vec3 tint = vec3(0.97, 1, 0.9);\n    \n    col.r = mod(circles, 2. ) / 1. * tint.r;\n    col.g = mod(circles, 2.5) / 1. * tint.g;\n    col.b = mod(circles, 3. ) / 1. * tint.b;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 302, 341, 341, 396], [397, 397, 445, 445, 500], [503, 503, 560, 560, 1822]], "test": "untested"}
{"id": "NtB3WK", "name": "Circuit waves", "author": "jarble", "description": "It's psychedelic!", "tags": ["fractal", "wave", "sea", "bubble"], "likes": 5, "viewed": 150, "published": "Public API", "date": "1624675345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.27;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/8.)/4.0;\n    //uv.y -= s1/scale1;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (uv.yx+vec2(uv.x/scale+uv.y/scale,uv.y/scale1+uv.x/scale1)/scale)/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv/scale+s1)*scale;\n            uv.y /= scale1;\n        }\n        col[2] = (uv.y-uv.x);\n        col = (abs(col-col_prev.yzx))/1.25;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 741]], "test": "untested"}
{"id": "NtB3z3", "name": "Quadratic Bezier (Casteljau)", "author": "Yusef28", "description": "A skeletal visualization\nA good resource: https://pomax.github.io/bezierinfo/\n\n", "tags": ["bezier", "quadratic", "casteljau"], "likes": 1, "viewed": 50, "published": "Public", "date": "1624340653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Pallete: Timeless & Nautical\n#define bgCol   vec3(0,41,60)/255.*0.8;\n#define lineCol vec3(30,101,109)/255.\n#define circleCol vec3(241,243,206)/255.\n#define magikCol vec3(246,42,0)/255.\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    float eps = 1./min(iResolution.x, iResolution.y);\n    vec2 p1 = vec2(-0.5, -0.3);\n    vec2 p2 = vec2(0.0, 0.3);\n    vec2 p3 = vec2(0.5, -0.3);\n    \n    vec2 line1 = p2-p1;\n    vec2 line2 = p3-p2;\n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    \n    vec2 magik = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    \n    \n    vec3 col = bgCol;\n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float line1Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p1, p2, uv));\n    float line2Dist = 1.0-smoothstep(0.004, 0.005, distToLine(p2, p3, uv));\n    float line3Dist = 1.0-smoothstep(0.004, 0.005,\n    distToLine(dLinePoint1, dLinePoint2, uv));\n    \n    //float line4Dist = 1.0-smoothstep(0.004, 0.005,\n    //distToLine(magik, p2, uv));\n    \n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol*1.2);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol*1.2);\n    \n    col = mix(col, lineCol, line1Dist);\n    col = mix(col, lineCol, line2Dist);\n    col = mix(col, lineCol, line3Dist);\n    //col = mix(col, circleCol, line4Dist);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, magik, col, magikCol);\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 189, 230, 230, 432], [434, 434, 521, 521, 753], [755, 755, 812, 862, 2610]], "test": "untested"}
{"id": "NtB3zK", "name": "LookingGlass: Cloudy SpikeBall", "author": "xjorma", "description": "Original shader from Duke\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["volume", "tutorial", "cloud", "pouet", "glass", "ball", "looking", "lookingglass"], "likes": 0, "viewed": 83, "published": "Public API", "date": "1624216685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// port from http://glslsandbox.com/e#1802.0 with some modifications\n//--------------\n// Posted by las\n// http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n//vec3 n1 = vec3(1.000,0.000,0.000);\n//vec3 n2 = vec3(0.000,1.000,0.000);\n//vec3 n3 = vec3(0.000,0.000,1.000);\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\nvec3 n14 = vec3(0.000,0.851,0.526);\nvec3 n15 = vec3(0.000,-0.851,0.526);\nvec3 n16 = vec3(0.526,0.000,0.851);\nvec3 n17 = vec3(-0.526,0.000,0.851);\nvec3 n18 = vec3(0.851,0.526,0.000);\nvec3 n19 = vec3(-0.851,0.526,0.000);\n\nfloat spikeball(vec3 p) {\n   vec3 q=p;\n   p = normalize(p);\n   vec4 b = max(max(max(\n      abs(vec4(dot(p,n16), dot(p,n17),dot(p, n18), dot(p,n19))),\n      abs(vec4(dot(p,n12), dot(p,n13), dot(p, n14), dot(p,n15)))),\n      abs(vec4(dot(p,n8), dot(p,n9), dot(p, n10), dot(p,n11)))),\n      abs(vec4(dot(p,n4), dot(p,n5), dot(p, n6), dot(p,n7))));\n   b.xy = max(b.xy, b.zw);\n   b.x = pow(max(b.x, b.y), 140.);\n   return length(q)-2.5*pow(1.5,b.x*(1.-mix(.3, 1., sin(iTime*2.)*.5+.5)*b.x));\n}\n\nfloat f(vec3 p) {\n   p.z += 6.;\n   R(p.xy, iTime);\n   R(p.xz, iTime);\n   return spikeball(p) + fpn(p*50.+iTime*15.) * 0.45;\n}\n\n/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, vec3 _ro, vec3 _rd)\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((fragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   \n   p = _ro;\n   d = _rd;\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./64.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 50.)&& (td < .95)))\n\t\t   break;\n      // evaluate distance function\n      l = f(p) * 0.5;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .05;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w; // * hsv(w, 1., 1.); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }  \n    \n   #ifdef SCATTERING\n   // simple scattering approximation\n   tc *= 1. / exp( ld * 0.4 ) * 1.25;\n   #endif\n      \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}\n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 8.0;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 6.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - vec3(0, 0, 6) - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 659, 682, 682, 900], [903, 903, 922, 922, 985], [987, 1678, 1703, 1703, 2166], [2168, 2168, 2185, 2185, 2293], [2295, 2450, 2526, 2587, 3887], [4142, 4142, 4198, 4198, 4912]], "test": "untested"}
{"id": "NtBGDd", "name": "Polygon Interpolation II", "author": "oneshade", "description": "Experimenting more, this time with texture mapping and visualizing UV grid lines.", "tags": ["test", "texture", "barycentric", "uvs", "polygon", "interpolation", "meanvaluecoordinates"], "likes": 14, "viewed": 110, "published": "Public", "date": "1624934459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Number of vertices\n#define N 6\n\nvoid polyLerpWeights(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    float norm = 0.0;\n    for(int n = 0; n < N; n++) {\n        vec2 a = poly[(n - 1 + N) % N] - p;\n        vec2 b = poly[n] - p;\n        vec2 c = poly[(n + 1) % N] - p;\n\n        float d = length(b);\n        float ab = dot(a, b), bc = dot(b, c), ad = length(a) * d, dc = d * length(c);\n        float u = sqrt(max(0.0, (ad - ab) / (ad + ab))) * sign(a.x * b.y - a.y * b.x);\n        float v = sqrt(max(0.0, (dc - bc) / (dc + bc))) * sign(b.x * c.y - b.y * c.x);\n\n        weights[n] = (u + v) / d;\n        norm += weights[n];\n    }\n\n    for(int n = 0; n < N; n++) weights[n] /= norm;\n}\n\n// Simple point in polygon test extracted from @iq's polygon\n// distance shader: https://www.shadertoy.com/view/wdBXRW\nbool pointInPolygon(in vec2 p, in vec2[N] v) {\n    bool res = false;\n    for (int i=0, j=N - 1; i < N; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n\n        // Winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 c = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(c) || all(not(c))) res = !res;  \n    }\n    \n    return res;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = 0.5 * iTime;\n    vec3 color = vec3(0.0);\n\n    // Create polygon\n    float t1 = 0.5 * time, t2 = 1.25 * time, t3 = 1.5 * time;\n    float c1 = 0.4 * cos(t1), s1 = 0.4 * sin(t1);\n    float c2 = 0.4 * cos(t2), s2 = 0.4 * sin(t2);\n    float c3 = 0.4 * cos(t3), s3 = 0.4 * sin(t3);\n\n    vec2[N] poly;\n    poly[0] = vec2(1.0, 0.0);\n    poly[1] = vec2(0.5, sqrt(0.75));\n    poly[2] = vec2(-poly[1].x, poly[1].y);\n    poly[3] = vec2(-1.0, 0.0);\n    poly[4] = -poly[1];\n    poly[5] = vec2(poly[1].x, -poly[1].y);\n    vec2[N] anim = poly; // Copy original positions for animating\n\n    // Distort the vertices\n    for (int n=0; n < N; n++) {\n        float id = float(n + 3);\n        float freq = Hash11(id * 393.84) * 2.0 - 1.0;\n        float phase = Hash11(id * 183.37);\n        float amp = Hash11(id * 275.35) * 1.25;\n        float ang = iTime * freq + phase;\n        anim[n] += vec2(cos(ang), sin(ang)) * amp;\n        anim[n] *= 0.25;\n    }\n\n    // Compute interpolation weights\n    float[N] weights;\n    polyLerpWeights(uv, anim, weights);\n\n    // Interpolate texture coordinates from vertices\n    vec2 texUv = vec2(0.0);\n    for (int n=0; n < N; n++) texUv += poly[n] * weights[n];\n    color = texture(iChannel0, texUv).rgb;\n    color -= smoothstep(1.25 * fwidth(texUv.x), 0.0, abs(mod(texUv.x, 0.2) - 0.1));\n    color -= smoothstep(1.25 * fwidth(texUv.y), 0.0, abs(mod(texUv.y, 0.2) - 0.1));\n\n    // Get distance to edges\n    float d = 1000000.0;\n    for (int n=0; n < N; n++) d = min(d, sdLine(uv, anim[n], anim[(n + 1) % N]));\n\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 174, 246, 246, 828], [830, 949, 995, 995, 1358], [1360, 1401, 1427, 1427, 1513], [1515, 1515, 1562, 1562, 1670], [1672, 1672, 1727, 1746, 3570]], "test": "untested"}
{"id": "NtBGDV", "name": "mandelbrot 001 perturbation", "author": "RiceFields", "description": " mandelbrot perturbation", "tags": ["mandelbrot", "perturbation"], "likes": 2, "viewed": 83, "published": "Public", "date": "1624698471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define B 4.0\n#define N 200\n#define PERIOD 12.0\n#define C_MUL(a,b) vec2(a.x*b.x - a.y*b.y, a.x*b.y+a.y*b.x)\n\n\n// Ref:\n// https://www.shadertoy.com/view/ttVSDW\n// https://mathr.co.uk/blog/2018-03-12_perturbation_algebra.html\n\nfloat mandelbrot_pert(vec2 c, vec2 dc) {\n   vec2 z = vec2(.0);\n   vec2 dz = vec2(.0);\n   float n = .0;\n   for(int i = 0; i < N; ++i) {\n     // p(Z) = 2*Z*dz + dz^2 + c \n     dz = C_MUL((2.0*z+dz),dz) + dc;\n     // f(z) = z^2 + c\n     z = C_MUL(z, z) + c; \n     // check if perturbation escapes\n     if( dot(dz,dz)>(B*B) ) {\n         n = float(i)/float(N);\n         break;\n     }\n   }\n   return n;\n}\n\nvec3 image(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0; // remap uv to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // calculate and apply zoom\n    float fzoom = .62 + .38*cos(iTime/PERIOD);\n    float zoom = pow(fzoom, 12.0);\n    \n    vec2  c = vec2(-.745,.186);\n    vec2 dc = uv*zoom;\n    \n    float f = mandelbrot_pert(c, dc)*2.0*fzoom-0.7; \n    \n    // calculate color\n    vec3 col = mix(vec3(.81,.06,.13), vec3(.80,.40,.0), f*f);\n\n    return (f*f*(2.0 - 4.0*f))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// anti-aliasing\n\tfragColor = vec4(image(fragCoord.xy + vec2(0,0)), 1.0f);\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.0));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.0,.5));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.5,.5));\n    fragColor.rgb += image(fragCoord.xy + vec2(.25,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.25));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.25,.75));\n\tfragColor.rgb += image(fragCoord.xy + vec2(.75,.75));\n\tfragColor.rgb /= 8.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 225, 265, 265, 623], [625, 625, 653, 653, 1145], [1148, 1148, 1205, 1223, 1688]], "test": "untested"}
{"id": "NtBGz3", "name": "Galaxy waves", "author": "jarble", "description": "These galaxy-waves are mesmerizing.", "tags": ["fractal", "wave", "spiral", "galaxy"], "likes": 5, "viewed": 166, "published": "Public API", "date": "1624329210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.275;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = scale1*scale+uv.y+iTime/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= -fract(-uv-((vec2(uv.x/scale1-uv.y/scale1,uv.y/scale-uv.x/scale)/(scale))))/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx/s1)*s1;\n            uv.y /= scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 776]], "test": "untested"}
{"id": "Ntf3DX", "name": "Motion Blurred Disk", "author": "oneshade", "description": "Wanted to do my own derivation of analytic motion blur for a disk.", "tags": ["motionblur", "analytic", "disk"], "likes": 7, "viewed": 84, "published": "Public", "date": "1622941412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis is not totally correct since it is not moving perfecty linearly\nbut its good enough.\n\nIt does becomes obvious with with high velocity (or low framerate) and nonlinear\nturns though.\n\nThe problem consists of finding how much of the frame duration the\nsample point was over the disk which involves computing the intersection\nof the relative path of the sample point with the disk and computing the gap\nbetween the two intersections.\n*/\n\n// I'm getting lazy on my derivatives :P\nvec2 var2dual(in float x) { return vec2(x, 1.0); }\nvec2 fMul(in vec2 a, in vec2 b) { return vec2(a.x * b.x, a.x * b.y + a.y * b.x); }\nvec2 fDiv(in vec2 a, in vec2 b) { return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x)); }\nvec2 fPow(in vec2 a, in vec2 b) { float q = pow(a.x, b.x); return vec2(q, q * (b.x * a.y / a.x + b.y * log(a.x))); }\nvec2 fSquare(in vec2 z) { return vec2(z.x * z.x, 2.0 * z.x * z.y); }\nvec2 fExp(in vec2 z, in float base) { float q = pow(base, z.x); return vec2(q, q * z.y); }\nvec2 fSin(in vec2 z) { return vec2(sin(z.x), cos(z.x) * z.y); }\nvec2 fCos(in vec2 z) { return vec2(cos(z.x), -sin(z.x) * z.y); }\nvec2 fMin(in vec2 a, in vec2 b) { return a.x < b.x ? a : b; }\nvec2 fMax(in vec2 a, in vec2 b) { return a.x > b.x ? a : b; }\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) { return fMax(edge0, fMin(edge1, z)); }\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) { z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0)); vec2 sq = fSquare(z); return 3.0 * sq - 2.0 * fMul(sq, z);}\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) { return a + fMul(b - a, t); }\n\n// p: sample point\n// o: disk origin\n// r: disk radius\n// v: disk velocity\n// dt: frame duration\nfloat movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float dt) {\n    vec2 p0 = p - o, p1 = v * dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 diskX = 0.5 * fCos(6.0 * var2dual(iTime));\n    vec2 diskY = 0.5 * fMul(fCos(6.0 * var2dual(iTime)), fSin(6.0 * var2dual(iTime)));\n    color += movingDisk(uv, vec2(diskX.x, diskY.x), 0.1, vec2(diskX.y, diskY.y), iTimeDelta);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 483, 510, 510, 533], [534, 534, 567, 567, 616], [617, 617, 650, 650, 715], [716, 716, 749, 749, 832], [833, 833, 858, 858, 901], [902, 902, 939, 939, 992], [993, 993, 1015, 1015, 1056], [1057, 1057, 1079, 1079, 1121], [1122, 1122, 1155, 1155, 1183], [1184, 1184, 1217, 1217, 1245], [1246, 1246, 1300, 1300, 1338], [1339, 1339, 1398, 1398, 1529], [1530, 1530, 1574, 1574, 1603], [1605, 1702, 1778, 1778, 2073], [2075, 2075, 2130, 2130, 2495]], "test": "untested"}
{"id": "Ntf3Rs", "name": "MyFirstShaderToy_Karp", "author": "Karp", "description": "Premier essaie sur ShaderToy\nFirst Try on ShaderToy", "tags": ["newbie"], "likes": 0, "viewed": 23, "published": "Public", "date": "1622583390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void disk(vec2 uv, vec2 center, float radius, vec3 color, inout vec3 pixel) \n{\n    if( length(uv-center) < radius) \n    {\n        pixel = color;\n    }\n}\nvoid centerPixCoord(inout vec2 coord)\n{\n    //OffSet to center\n    coord -= 0.5 * iResolution.xy;\n    //Remap for y [-1 ; 1]  \n    coord /= 0.5 * iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    centerPixCoord(uv);\n    \n    vec3 pixel = vec3(uv.x>.0,uv.y>.0,.0);\n    \n    vec2 mousePos = iMouse.xy;\n    centerPixCoord(mousePos);\n    \n    vec2 lastClick = iMouse.zw;\n    centerPixCoord(lastClick);\n    \n    disk(uv, lastClick, 0.2 + abs(0.2 * sin(1.0*iTime)), vec3(1.0)-vec3(uv.x>0.,uv.y>0.,.0), pixel);\n    disk(uv, mousePos, 0.2 + abs(0.1 * sin(2.0*iTime)), vec3(1.0)-vec3(uv.x>0.,uv.y>0.,.0), pixel);\n\n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 78, 78, 152], [153, 153, 192, 215, 315], [317, 317, 374, 374, 871]], "test": "untested"}
{"id": "Ntf3WB", "name": "Simple Rotating Cross", "author": "igorodi", "description": "A simple rotating cross", "tags": ["rotate", "cross"], "likes": 1, "viewed": 34, "published": "Public", "date": "1622699926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = 5.;\n\nvec2 rotate(in float angle, inout vec2 st)\n{\n    st -= .5;\n    st = mat2(cos(angle), -sin(angle),\n              sin(angle), cos(angle)) * st;\n    st += .5;\n    return st;\n}\n\nvec4 box(in vec2 size, in vec2 st) \n{\n    size = vec2(.5) - size*.5;\n    vec2 uv = smoothstep(size, size+vec2(.001), st);\n    uv *= smoothstep(size, size+vec2(.001), vec2(1.)-st);\n    \n    return vec4(uv.x * uv.y);\n}\n\nvec4 cross(in float size, in vec2 st)\n{\n    return box(vec2(size, size/4.), st) + box(vec2(size/4., size), st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n    uv.x *= 1.5;\n    uv.x -= .25;\n    \n    uv.y += sin(iTime) * .1;\n    uv.x += cos(iTime) * .1;\n    \n    uv = rotate(iTime * speed, uv);\n    \n    fragColor = cross(.25, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 63, 63, 191], [193, 193, 230, 230, 409], [411, 411, 450, 450, 524], [526, 526, 583, 583, 809]], "test": "untested"}
{"id": "Ntf3WS", "name": "Worley Noise 3D __", "author": "Envy24", "description": "noise, random, worley, cellular", "tags": ["noise", "random", "worley", "cellular"], "likes": 1, "viewed": 62, "published": "Public", "date": "1622683124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * enthropy3 * enthropy2 +\n        y * enthropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat WorleyNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float z = -1.0f; z < 2.0f; z += 1.0f)\n    {\n        for (float y = -1.0f; y < 2.0f; y += 1.0f)\n        {\n            for (float x = -1.0f; x < 2.0f; x += 1.0f)\n            {\n                // Pseudorandom sample coordinates in corresponding cell.\n                float xSample = x + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float ySample = y + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float zSample = z + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n\n                // Distance from pixel to pseudorandom sample.\n                //float distance = \n                    //sqrt(\n                        //(fractU - xSample) * (fractU - xSample) +\n                        //(fractV - ySample) * (fractV - ySample) +\n                        //(fractW - zSample) * (fractW - zSample));\n                        \n                float distance = \n                        (fractU - xSample) * (fractU - xSample) +\n                        (fractV - ySample) * (fractV - ySample) +\n                        (fractW - zSample) * (fractW - zSample);\n\n                // Mistance from pixel to pseudorandom sample.\n                minDistance = min(minDistance, distance);\n            }\n        }\n    }\n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;\n    \n    if (fragCoord.x < iResolution.x * 0.5) { uv = fragCoord/iResolution.xy * 6.0f; }\n    else { uv = fragCoord/iResolution.xy * 18.0f; }\n\n    float _u = uv.x + iMouse.x * 0.1f;\n    float _v = uv.y + iMouse.y * 0.1f;\n    float _w = uv.x + iMouse.y * 0.1f + iTime * 0.2f;\n\n    float gray = WorleyNoise3D(_u, _v, _w) * 0.5f;\n    gray += WorleyNoise3D(_u * 2.054f, _v * 2.210f,  _w * 2.210f) * 0.055f;\n    gray += WorleyNoise3D(_u * 4.554f, _v * 4.710f,  _w * 2.210f) * 0.0325f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 92, 162, 635], [637, 637, 685, 707, 2256], [2258, 2258, 2315, 2365, 2923]], "test": "untested"}
{"id": "NtfGDl", "name": "Zoomer Fire shader", "author": "lumic", "description": "Modified fire shader from https://www.shadertoy.com/view/MdKfDh with some polar coordinate stuff", "tags": ["fire"], "likes": 1, "viewed": 46, "published": "Public", "date": "1623067538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is just a spin off from https://www.shadertoy.com/view/XsXSWS applying some distortion and minor tweaks\n\n#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.01, -0.5)\n#define distortionMovement\tvec2(-0.01, -0.3)\n#define normalStrength\t\t40.0\n#define distortionStrength\t0.1\n\n// #define DEBUG_NORMAL\n\n/** NOISE **/\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm ( in vec2 p ) {\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise(p); p = m*p;\n    f += 0.2500*noise(p); p = m*p;\n    f += 0.1250*noise(p); p = m*p;\n    f += 0.0625*noise(p); p = m*p;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/** DISTORTION **/\nvec3 bumpMap(vec2 uv) { \n    vec2 s = 1. / iResolution.xy;\n    float p =  fbm(uv);\n    float h1 = fbm(uv + s * vec2(1., 0));\n    float v1 = fbm(uv + s * vec2(0, 1.));\n       \n   \tvec2 xy = (p - vec2(h1, v1)) * normalStrength;\n    return vec3(xy + .5, 1.);\n}\n\n/** MAIN **/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - (iResolution * 0.5).xy)/iResolution.yy;\n    \n    // Reflect Hor/vertical\n    uv.x = abs(uv.x);\n    uv.y= abs(uv.y);\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    \n    uv = vec2(radius * 1.0, angle / (2.0 * 3.141592));\n    uv = vec2(angle / (2.0 * 3.141592), radius * (-0.5 + 1.0 * sin(iTime)));\n\n    vec3 normal = bumpMap(uv * vec2(1.0, 0.3) + distortionMovement * timeScale);\n    \n    #ifdef DEBUG_NORMAL\n    \tfragColor = vec4(normal, 1.0);\n    \treturn;\n    #endif\n    \n    vec2 displacement = clamp((normal.xy - .5) * distortionStrength, -1., 1.);\n    uv += displacement; \n    \n    vec2 uvT = (uv * vec2(1.0, 0.5)) + timeScale * fireMovement;\n    float n = pow(fbm(8.0 * uvT), 1.0);    \n    \n    float gradient = pow(1.0 - uv.y, 2.0) * 5.;\n    float finalNoise = n * gradient;\n    \n    vec3 color = finalNoise * vec3(2.*n, n*n*n*n, 2.*n*n*n);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 332, 353, 353, 423], [425, 425, 446, 446, 567], [569, 569, 595, 595, 1048], [1050, 1050, 1075, 1075, 1317], [1319, 1338, 1361, 1361, 1595], [1597, 1610, 1667, 1667, 2604]], "test": "untested"}
{"id": "NtfGRf", "name": "Plasma studies", "author": "Bjorn", "description": "original idea: https://www.bidouille.org/prog/plasma", "tags": ["test", "zau"], "likes": 1, "viewed": 53, "published": "Public", "date": "1622563071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    // Time varying pixel color\n    \n    // x sinus:\n    float pop1 = sin(uv.x*10. + iTime)*.5+.5;\n    // rotate sinus : \n    float pop2 = sin(10.*(uv.x*sin(iTime)-.5 + uv.y*cos(iTime)-.5))*.5+.5;\n    // circles\n    vec2 c =vec2(uv.x-.5+sin(iTime), uv.y-.5+cos(iTime));\n    float pop3 = sin(sqrt(100.*(c.x*c.x+c.y*c.y)))*.5+.5;\n    // merge waves\n    float pop4 = (pop1 + pop2 + pop3);\n    \n    vec3 col = vec3(sin(pop4*3.),cos(pop4*3.),.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 648]], "test": "untested"}
{"id": "NtfXzn", "name": "Ten Intersecting Tetrahedra", "author": "dr2", "description": "Chiral stellation of the icosahedron - 'Compound of Five Tetrahedra' - used twice", "tags": ["tetrahedron", "symmetry", "polyhedron", "stellation"], "likes": 12, "viewed": 188, "published": "Public API", "date": "1625045508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ten Intersecting Tetrahedra\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrTetDf (vec3 p, float d);\nfloat PrDodecDf (vec3 p, float r);\nfloat Maxv2 (vec2 p);\nmat3 VToRMat (vec3 v, float a);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir[4], ltCol[4];\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TetFrameDf (vec3 p, float w)\n{\n  vec3 q;\n  q = p;\n  p = abs (p);\n  q = mix (q, q.yzx, step (Maxv2 (p.yz), p.x));\n  q = mix (q, q.zxy, step (Maxv2 (p.zx), p.y));\n  q = mix (q, vec3 (q.x, - q.yz).yxz, step (q.z, 0.)) - vec3 (-1., 1., 1.) / sqrt (3.);\n  return PrBox2Df (vec2 (0.5 * (q.x + q.y), q.z), vec2 (w));\n}\n\nfloat ObjDf (vec3 p)\n{\n  mat3 m;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  m = VToRMat (vec3 (0., sin (atan (2. / (sqrt (5.) + 1.)) + vec2 (0.5 * pi, 0.))), 2. * pi / 5.);\n  // rotation matrix from \"Ico-Twirl\", where atan (1. / phi) = 0.55357435\n  q = p;\n  for (int k = 0; k < 5; k ++) {\n    d = TetFrameDf (q, 0.03);\n    DMIN (1);\n    d = PrTetDf (q, 0.27);\n    DMIN (2);\n    q = m * q;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  return PrDodecDf (p, 0.74);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat SphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  return (w > 0.) ? - b - sqrt (w) : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 sumD, sumS, col, colB, vn, roo;\n  float dstObj, dstTrObj, nDotL, sh, s;\n  roo = ro;\n  s = SphHit (ro, rd, 1.2);\n  dstObj = (s < dstFar) ? ObjRay (ro, rd) : dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (128. * ro, vn, 0.2);\n    if (idObj == 1) col4 = vec4 (0.9, 0.9, 0.9, 0.5);\n    else if (idObj == 2) col4 = vec4 (1., 1., 1., 0.2);\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      sh = ObjSShadow (ro, ltDir[k]);\n      sumD += ltCol[k] * col4.rgb * sh * nDotL * nDotL *\n         smoothstep (0.95, 0.98, dot (normalize (3. * ltDir[k] - ro), ltDir[k]));\n      sumS += ltCol[k] * col4.a * step (0.95, sh) * pow (max (0., dot (ltDir[k],\n         reflect (rd, vn))), 32.);\n    }\n    col = 0.05 * col4.rgb + 0.95 * sumD + sumS;\n  } else {\n    col = vec3 (0.1);\n  }\n  ro = roo;\n  dstTrObj = (s < dstFar) ? TrObjRay (ro, rd) : dstFar;\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    colB = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      colB += ltCol[k] * nDotL * nDotL *\n         smoothstep (0.9, 0.95, dot (normalize (3. * ltDir[k] - ro), ltDir[k]));\n    }\n    colB = vec3 (0.05) + 0.95 * colB;\n    col = mix (col, colB, 0.05 + 0.95 * pow (1. - max (- dot (rd, vn), 0.), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.3 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -7.);\n  zmFac = 6.;\n  dstFar = 30.;\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 0.2, 0.2);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (1., -1.) / sqrt (3.);\n  return max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d;\n}\n\nfloat PrDodecDf (vec3 p, float d)\n{\n  vec3 e;\n  float s;\n  e = vec3 ((sqrt (5.) + 1.) / 2., 1., 0.) / sqrt (5.);\n  s = 0.;\n  for (int k = 0; k < 4; k ++) {\n    s = max (s, max (dot (p, e), max (dot (p, e.yzx), dot (p, e.zxy))));\n    e.x = - e.x;\n    if (k == 1) e.y = - e.y;\n  }\n  return s - d;\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2, bp, bm;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.xzy * v.yxz;\n  b2 = - cs.y * v.zyx;\n  bp = b1 + b2;\n  bm = b1 - b2;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[0][1] = bp.x;  m[1][0] = bm.x;\n  m[2][0] = bp.y;  m[0][2] = bm.y;\n  m[1][2] = bp.z;  m[2][1] = bm.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 589, 625, 625, 906], [908, 908, 930, 930, 1320], [1322, 1322, 1355, 1355, 1538], [1540, 1540, 1561, 1561, 1816], [1818, 1818, 1842, 1842, 1874], [1876, 1876, 1911, 1911, 2095], [2097, 2097, 2120, 2120, 2377], [2379, 2379, 2416, 2416, 2645], [2647, 2647, 2691, 2691, 2812], [2814, 2814, 2849, 2849, 4313], [4315, 4315, 4371, 4371, 5662], [5664, 5664, 5686, 5686, 5713], [5715, 5715, 5748, 5748, 5832], [5834, 5834, 5867, 5867, 6008], [6010, 6010, 6045, 6045, 6306], [6308, 6308, 6340, 6340, 6718], [6720, 6720, 6756, 6756, 6962], [6964, 6964, 6994, 6994, 7107], [7141, 7141, 7165, 7165, 7277], [7279, 7279, 7304, 7304, 7490], [7492, 7492, 7521, 7521, 7733], [7735, 7735, 7774, 7774, 8026]], "test": "untested"}
{"id": "Ntj3RD", "name": "Galactic black hole station", "author": "Willisburg", "description": "A spiral of numbers from 0 to infinity, only numbers that are divisible by given criteria are drawn", "tags": ["spiralpatterns"], "likes": 5, "viewed": 69, "published": "Public", "date": "1623445539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Finds the value of bottom right \n// corner of a ring with given depth\n// Will also find upper left corner, \n// if negative depth is given\nint calcBR(int depth)\n{\n    return 4 * depth * depth - 2 * depth;\n}\n\n// Finds the value of upper right \n// corner of a ring with given depth\n// Will also find botton left corner,\n// if negative depth is given\nint calcUR(int depth)\n{\n    int flag = depth > 0 ? 1 : 0;\n    return 4 * (depth + 1 * flag) * (depth + 1 * flag) - 4 * (depth + 1) * flag;\n}\t\n\n// Given coordinates x and y, \n// returns a value from a grid \n// spiral of numbers\nint calcNum(int x, int y) \n{\nif(x == y)\n    return calcBR(x);\nelse if(-x == y)\n    return calcUR(x);\nelse if(abs(y) > abs(x))\n    return calcBR(y) + abs(y) + x * (y<0?1:-1);\nelse\n    return calcBR(x) - abs(x) - y * (x<0?1:-1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -iResolution/2 to iResolution/2)\n    vec2 uv = fragCoord - iResolution.xy/2.0;//+ vec2(iResolution.y / 2.0, -iResolution.y / 2.0);\n    float scale = 4.0;\n    \n    // Scales pixel coordinates by a given amount\n    uv *= float(scale);\n    \n    ///CRITERIA///\n    // The criteria, have fun and test out different values\n    int criteria = int(uv.x*uv.y/(iTime*100.0));// + int(iTime*2.0);\n    \n    // Nested for loops make sure that no values \n    // are skipped when scaling up the resolution\n    for(int i = 0; i < int(scale); i+=1)\n    {\n        for(int j = 0; j < int(scale); j+=1)\n        {\n            int num = calcNum(int(uv.x)+i, int(uv.y)+j);\n            \n            // Checks whether a number is divisible by criteria\n            // if so draw it and return\n            \n            // Edit: checking whether the modulus of num divided by criteria is equal \n            // to modulus of time divided by criteria, creates a shifting effect:\n            // int(mod(-iTime*50.0, float(criteria)))\n            if(num%criteria == 0)\n            {\n                fragColor = vec4(1.0);\n                return;\n            }\n        }\n    }\n    fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntj3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 141, 164, 164, 208], [210, 350, 373, 373, 490], [493, 577, 605, 605, 805], [807, 807, 864, 939, 2079]], "test": "untested"}
{"id": "Ntj3RW", "name": "River channels", "author": "jarble", "description": "This fractal landscape has many fluvial landforms.", "tags": ["fractal", "terrain", "river"], "likes": 3, "viewed": 183, "published": "Public API", "date": "1623437588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat fprand(vec2 uv, float f){\n    return sin(uv.y*f)+cos(uv.x*f);\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 6.0;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)) * amplitude));\n        \n        amplitude *= .55;\n        \n        freq *= 1.75+value;\n        \n        uv = uv.yx;\n    }\n    \n    return 1.-value;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntj3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 410, 441, 441, 479], [481, 481, 506, 506, 540], [561, 561, 584, 633, 1049], [1124, 1124, 1162, 1162, 1222], [1224, 1224, 1257, 1257, 1477], [1479, 1479, 1517, 1517, 1744], [1746, 1746, 1784, 1784, 2008], [2010, 2010, 2039, 2039, 2134], [2136, 2136, 2173, 2173, 2232], [2235, 2303, 2322, 2322, 2361], [2363, 2363, 2383, 2383, 2459], [2461, 2461, 2480, 2480, 2519], [2521, 2521, 2578, 2578, 2813], [2815, 2815, 2850, 2850, 3244], [3246, 3246, 3300, 3300, 3966], [3969, 3969, 4021, 4021, 4456], [4458, 4458, 4515, 4515, 5706]], "test": "untested"}
{"id": "NtjGWG", "name": "Ball of Saturation 3", "author": "egon", "description": "Color-wheel using oklab for the ball and outer circle.", "tags": ["colorwheel"], "likes": 0, "viewed": 65, "published": "Public", "date": "1624612755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (2.0*3.1415926538)\n\nvec2 rot(vec2 pos, float a) {\n\tfloat sn = sin(a);\n\tfloat cs = cos(a);\n\treturn mat2(cs, -sn, sn, cs) * pos;\n}\n\nfloat map(float p, float ss, float se, float ds, float de)\n{\n    return ds + (p-ss)*(de-ds)/(se-ss);\n}\n\nfloat shade(vec2 pos, float dir) {\n    pos = rot(pos, dir);\n    float h = cos(pos.x);\n    return map(pos.y, h, -h, 0.0, 1.0);\n}\n\n//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsv2rgb_subtractive( in vec3 c ) {\n    float frac = fract(c.x)*6.0;\n    vec3 col = smoothstep(vec3(3,0,3),vec3(2,2,4),vec3(frac));\n    col += smoothstep(vec3(4,3,4),vec3(6,4,6),vec3(frac)) * vec3(1, -1, -1);\n    return mix(vec3(1), col, c.y) * c.z;\n}\n\n#define cbrtf(x)  ( sign(x)*pow(abs(x),1./3.) )\n\n// linear_srgb_to_oklab\nvec3 rgb2oklab(vec3 c) \n{\n    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n    float l_ = cbrtf(l);\n    float m_ = cbrtf(m);\n    float s_ = cbrtf(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\n// oklab_to_linear_srgb\nvec3 oklab2rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float inside  = 0.3 * iResolution.y;\n    float mid     = 0.35 * iResolution.y;\n    float outside = 0.45 * iResolution.y;\n    \n    vec2 off = center - uv;\n\n    float h = mod(iTime*0.1, 1.0);\n    if(iMouse.z > 0.0){\n        vec2 p = normalize(center - iMouse.xy);\n        h = atan(-p.y, -p.x) / TAU;\n    }\n\n    float d = length(off);\n    if(d < inside){\n        off /= inside;\n\n        float v = shade(off, 0.0/3.0 * TAU);\n        float s = shade(off, -1.0/4.0 * TAU);\n\n        //fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n        fragColor = vec4(oklab2rgb(vec3(v, s, h)), 1.0);\n    } else if (mid < d && d < outside) {\n        off = normalize(off);\n        float h = atan(-off.y, -off.x) / TAU;\n        fragColor = vec4(hsv2rgb_subtractive(vec3(h, 0.9, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.13, 0.15, 1.0);\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 61, 61, 140], [142, 142, 202, 202, 244], [246, 246, 280, 280, 373], [375, 471, 493, 493, 824], [826, 826, 848, 848, 1017], [1020, 1020, 1059, 1059, 1275], [1326, 1350, 1375, 1375, 1900], [1902, 1926, 1951, 1951, 2428], [2431, 2431, 2488, 2488, 3402]], "test": "untested"}
{"id": "NtjGWw", "name": "SDF Implementation", "author": "Ondra09", "description": "Test implementation of SDF.\nFeatures:\ngluLookAt like camera position\nphong lighting\nsoft shadows\nreflections\nambient occlusion\ngamma correction\nantialiasing \n\n", "tags": ["sdf"], "likes": 3, "viewed": 91, "published": "Public", "date": "1624959755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////////////////////////////////\n// Intro tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// https://www.shadertoy.com/view/4dSfRc\n// TODO: add checkerbox texture and filter it: https://www.shadertoy.com/view/XlcSz2\n//===============================================================================================\n// Scene objects\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m =  p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n//------------------------------------------------------------------\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// worldMap defintion\n\nvec3 worldMap( in vec3 pos )\n{\n    vec3 res = vec3(1e10, 0.0, 1.0);\n    \n    res = opU(res, vec3( sdPlane(pos-vec3(0, -0.5, 0)), 2.95, 0. ) ); // pos, color, reflection\n    res = opU(res, vec3( sdSphere(pos-vec3(.0,-0.25, 0.0), 0.25 ), 10.2, 1.) );\n    res = opU(res, vec3( sdBoundingBox(pos-vec3( -1.0, -0.25, 0.0), vec3(0.3,0.25,0.2), 0.025), 11.12, 1.0) );\n    res = opU(res, vec3( sdTorus((pos-vec3(-0.3, -0.25, 1.0)).xzy, vec2(0.25,0.05) ), 25.0, 1.0) );\n    \n    res = opU(res, vec3( sdOctahedron(pos-vec3(.750,0.25, 0.0), 0.4325 ), 10.8, 1.0) );\n    \n    \n    return res;\n}\n\nvec3 rayCast(in vec3 ro, in vec3 rd) \n{\n    vec3 res = vec3(-1.0, 0.0, 0.0);\n    \n    float tmin = 1.0;\n    float tmax = 20.0; // max step distance    \n    \n    int steps = 0;\n    for (float tstep = tmin; tstep < tmax;) \n    {   \n        vec3 h = worldMap(ro + tstep * rd);       \n        \n        if (h.x < 0.0001 )\n        {\n            res.x = tstep;\n            res.y = h.y;\n            res.z = h.z;\n            return res;\n        }            \n        \n        tstep += h.x;\n        \n        // just to be sure we do not end in endless loop if during development\n        steps++;        \n        if (steps > 1750)\n            return vec3(20000.0, 1.0, 0.0);\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// https://www.shadertoy.com/view/lsKcDD\n// it still suffers from some self shadow and minro light bleeding artifats however, even with  Sebastian Aaltonen's improvement\nfloat softShadows(in vec3 ro, in vec3 lightPos) \n{\n    vec3 rd = normalize(lightPos - ro);           \n    const float k = 8.0;\n    float tmin = 0.0090;\n    float tmax = 2.0; // max step distance    \n    \n    float res = 1.0;\n    float prevh = 1e20; // infinity\n    for( float t = tmin; t < tmax; )\n    {\n        float h = worldMap(ro + rd * t).x;\n        if(h < 0.001*t)\n            return 0.0;            \n        \n        float y = h * h / (2.0 * prevh);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0.0,t-y));\n        prevh = h;\n        t += h;\n    }\n    \n    res = clamp(res, 0.0, 1.0);\n    return res * res * (3.0 - 2.0 * res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    // central differencing\n    // line 444: https://www.shadertoy.com/view/Xds3zN\n    return normalize( e.xyy * worldMap( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx * worldMap( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy * worldMap( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx * worldMap( pos + e.xxx ).x );\n}\n\n\nfloat ambientOcclusion(in vec3 ro, in vec3 normal)\n{\n    float sum = 0.0;\n    float pointWeight = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        float normalStep = 0.001 + 0.15 * float(i) / 4.0; // we perform step along normal\n        \n        float distanceToNormalPoint = worldMap(ro + normalStep * normal).x;\n        sum += (normalStep - distanceToNormalPoint) * pointWeight;\n        pointWeight *= 0.95;\n    }\n    \n    return clamp(1.0-1.5*sum, 0.0, 1.0);\n}\n\nvec3 colorFromMaterial(in float mat)\n{\n    return 0.2 + 0.2*sin(mat*2.0 + vec3(0.0,1.0,2.0));\n}\n\n// https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\n// interesting post pointing to this article:\n// https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\nvec4 computeBlinnPhongLighting(in vec3 depthMaterial, in vec3 ro, in vec3 rd, in vec3 lightPos) \n{    \n    vec3 col = colorFromMaterial(depthMaterial.y);\n    \n    vec3 surfacePoint = ro + rd * (depthMaterial.x);\n    \n    vec3 normal = calcNormal(surfacePoint);\n    \n    vec3 lightDir = normalize(lightPos - surfacePoint);\n    \n    float diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n    \n    const float kShininess = 16.0;\n    const float kPi = 3.1415926;\n    const float kEnergyConservation = ( 2.0 + kShininess ) / ( 2.0 * kPi );\n    \n    vec3 reflectV = normalize(reflect(-lightDir, normal));\n    float specular = pow(clamp(dot(-rd, reflectV), 0.0, 1.0), kShininess);\n    \n    float amb = clamp(0.2+0.5*depthMaterial.y, 0.0, 1.0) * 0.2;\n    float shadow = softShadows(surfacePoint, lightPos);\n    float ao = ambientOcclusion(surfacePoint, normal);\n    vec3 reflected = reflect(rd, normal);\n    \n    float dom = smoothstep(-1.50, 0.51, reflected.y);\n    \n    float reflection = softShadows(surfacePoint, reflected);\n    \n    float lightning =  ao * shadow *( diffuse + diffuse * (kEnergyConservation*specular)) // * (0.04 + 0.96*pow( clamp(1.0+dot(reflectV,rd),0.0,1.0), 5.0 ))) \n                      + amb;\n                      \n    /*\n    vec3 lin = 0.090 * dom * vec3(0.80, 0.7, 1.0) * ao + 0.0031; // this gives objects glossy look \n    \n    col += lin;\n    col += depthMaterial.z * 0.01 * reflection * vec3(0.8, 0.7, 1.0) * ao;    \n    col *= lightning; \n    */\n    \n    vec3 lin = vec3(0.0);\n    \n    lin += col * 0.750 * dom * vec3(0.80, 0.7, 1.0) * ao; \n    \n    lin += col * depthMaterial.z * 0.35 * reflection * vec3(0.8, 0.7, 1.0) * ao;    \n    \n    col = lin;\n    \n    col *= lightning; \n    \n    return vec4(col, 1.0);\n}\n\n\nmat4 lookAt(in vec3 pos, in vec3 target, in vec3 up) \n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward, up));\n    vec3 y = normalize(cross(right, forward));   \n   \n    return mat4(vec4(right, 0.0),\n                vec4(y, 0.0),\n                vec4(-forward, 0.0),\n                vec4(0.0, 0.0, 0.0, 0.1));\n}\n\nmat3 rotateY(in float alpha) \n{\n    return mat3(cos(alpha), 0., sin(alpha),\n                0         , 1.,          0, \n                -sin(alpha), 0., cos(alpha));\n}\n\nvec3 castVector(in vec3 uv, in vec3 cameraOrigin) \n{\n    // orthogonal to origin by setting z = 1\n    return  normalize(uv - cameraOrigin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)    \n    float ratio = iResolution.x / iResolution.y;\n    \n        \n    vec3 camPos = vec3(0.0, 0.8, 2.7);\n    vec3 lightPos = vec3(10.0, 10.0, 10.0);\n    mat3 rotM = rotateY(iTime * 0.5);\n    lightPos = rotM * lightPos;\n    \n    vec4 color = vec4(0.0);\n    //mulitsampling\n    const int MULTISAMPLE = 2;\n    for (int i = 0; i < MULTISAMPLE; ++i) \n    {\n        for (int j = 0; j < MULTISAMPLE; ++j)\n        {                           \n            vec2 shift = (vec2(float(i), float(j)) / float(MULTISAMPLE) - 0.5f);            \n            vec2 uv = (fragCoord+shift)/iResolution.xy;            \n            \n            uv = uv - 0.5;    \n            uv.x *= ratio;\n            \n            // focal length from camera is -z\n            vec4 uvPos = vec4(uv.xy, -1.0, 1.0);           \n\n            mat4 viewM = lookAt(camPos, vec3(0.0, .2, 0), vec3(0,1,0));\n\n            uvPos = (viewM) * uvPos;    \n            uvPos.xyz += camPos.xyz;\n\n            vec3 rd = castVector(uvPos.xyz, camPos);\n\n            vec3 res = rayCast(camPos, rd);\n\n            color += computeBlinnPhongLighting(res, camPos, rd, lightPos * 1.0);\n        }\n    }\n    \n    color /= float(MULTISAMPLE * MULTISAMPLE);\n    // gamma\n    color = pow(color, vec4(0.4545)); // value 1/2.22 is good for LCD displays\n    \n    // Output to screen    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 472, 497, 497, 516], [517, 517, 542, 542, 561], [562, 562, 598, 598, 626], [628, 628, 653, 653, 668], [670, 670, 705, 705, 731], [733, 733, 770, 770, 1365], [1367, 1367, 1415, 1415, 1703], [1705, 1705, 1738, 1738, 1793], [1794, 1864, 1894, 1894, 1927], [1929, 1952, 1982, 1982, 2532], [2534, 2534, 2573, 2573, 3226], [3228, 3461, 3511, 3511, 4124], [4126, 4126, 4156, 4156, 4475], [4478, 4478, 4530, 4530, 4943], [4945, 4945, 4983, 4983, 5040], [5042, 5224, 5322, 5322, 6965], [6968, 6968, 7023, 7023, 7315], [7317, 7317, 7348, 7348, 7485], [7487, 7487, 7539, 7584, 7628], [7631, 7631, 7688, 7742, 9076]], "test": "untested"}
{"id": "NtjGzz", "name": "Into the colour", "author": "Bupeldox", "description": "idk just kinda randomly made this", "tags": ["tan"], "likes": 4, "viewed": 64, "published": "Public", "date": "1623245193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat wtan(float x){\n    if(x<3.14/2.0){\n        return tan(x);\n    }\n    else{\n        return tan(-x);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pTime = iTime*2.0;\n    float modT = -1.0*(0.3*sin(pTime*1.2)+pTime*1.3);\n    float p = 20.0*wtan(3.14*fragCoord.x/iResolution.x);\n    \n    float r = sin(modT+p*1.0);\n    float g = sin(modT+p*1.02);\n    float b = sin(modT+p*1.03);\n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 112], [114, 114, 171, 171, 451]], "test": "untested"}
{"id": "Ntl3zX", "name": "spatial judo - 2", "author": "Shellderr", "description": "use mouse to maneuver", "tags": ["fractal", "space"], "likes": 2, "viewed": 64, "published": "Public", "date": "1622539351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define ft float\n\nft hm(vec2 uv, vec2 m){\n    ft a = dot(uv,uv);\n    ft b = (sin(iTime+uv.x/a/m.x))-cos(uv.y/a/m.y);\nreturn abs(b*1.4)+a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 10.*(2.*fragCoord.xy-res.xy)/res.y;\n    vec2 m = vec2(.9);\n    vec2 mouse = iMouse.y < 1.? vec2(.5,.05): iMouse.xy/res.xy;\n    ft a = hm(uv, m);\n    for(ft i; i < 3.; i++){\n    uv = abs(uv/hm(uv,m+i*.2)-.4*mouse);\n    }\n    fragColor = vec4(1.-1./uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntl3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 163], [165, 165, 221, 221, 497]], "test": "untested"}
{"id": "NtlSzr", "name": "Poligonal Face(x)", "author": "DimKA3102", "description": "Don't work", "tags": ["poligon"], "likes": 0, "viewed": 21, "published": "Public", "date": "1625085975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float _(float a, float b, float c){\n                  return max(a,max(b,c));\n        }\n             \n        float L(vec2 p, vec2 P0, vec2 P1){\n                float a = -(P1.y-P0.y);\n                float b =  (P1.x-P0.x);\n                float d =  P0.x*P1.y- P0.y*P1.x; \n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2){\n          return  _(\n                     L(p, P0, P1),\n                     L(p, P1, P2), \n                     L(p, P2, P0)\n                   );   \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//  digitalized Pi profile                      \n vec2 P[56];\n       P[ 0] = vec2(-0.99687 ,      0.71875);\n       P[ 1] = vec2(-0.93437 ,   0.70313);\n       P[ 2] = vec2(-0.88438 ,   0.70313);\n       P[ 3] = vec2(-0.8375  ,   0.70313);\n       P[ 4] = vec2(-0.79063 ,      0.68125);\n       P[ 5] = vec2(-0.75    ,   0.66250);\n       P[ 6] = vec2(-0.70937 ,    0.65625);\n       P[ 7] = vec2(-0.68125 ,    0.64063);\n       P[ 8] = vec2(-0.65312 ,    0.62187);\n       P[ 9] = vec2(-0.61562 ,    0.59062);\n       P[10] = vec2(-0.59688 ,    0.55000);\n       P[11] = vec2(-0.6     ,      0.52187);\n       P[12] = vec2(-0.625   ,    0.50937);\n       P[13] = vec2(-0.64375 ,    0.49375);\n       P[14] = vec2(-0.64063 ,    0.47500);\n       P[15] = vec2(-0.63125 ,    0.44688);\n       P[16] = vec2(-0.625   ,   0.41563);\n       P[17] = vec2(-0.61562 ,    0.40312);\n       P[18] = vec2(-0.61562 ,    0.38125);\n       P[19] = vec2(-0.62187 ,    0.36250);\n       P[20] = vec2(-0.62813 ,    0.34375);\n       P[21] = vec2(-0.61875 ,    0.31250);\n       P[22] = vec2(-0.60938 ,    0.28750);\n       P[23] = vec2(-0.6     ,   0.26875);\n       P[24] = vec2(-0.58437 ,    0.24375);\n       P[25] = vec2(-0.58125 ,    0.20937);\n       P[26] = vec2(-0.58437 ,    0.19062);\n       P[27] = vec2(-0.60625 ,    0.18750);\n       P[28] = vec2(-0.62187 ,    0.18437);\n       P[29] = vec2(-0.62813 ,    0.16562);\n       P[30] = vec2(-0.61875 ,    0.14375);\n       P[31] = vec2(-0.6375  ,   0.12500);\n       P[32] = vec2(-0.64063 ,    0.10625);\n       P[33] = vec2(-0.65    ,   0.090625);\n       P[34] = vec2(-0.66875 ,    0.078125);\n       P[35] = vec2(-0.66875 ,    0.053125);\n       P[36] = vec2(-0.66562 ,    0.040625);   \n       P[37] = vec2(-0.675   ,   0.0062500);\n       P[38] = vec2(-0.69375 ,    -0.015625);\n       P[39] = vec2(-0.71875 ,    -0.028125);\n       P[40] = vec2(-0.74687 ,    -0.034375);\n       P[41] = vec2(-0.77187 ,    -0.034375);\n       P[42] = vec2(-0.80312 ,    -0.034375);\n       P[43] = vec2(-0.83437 ,    -0.034375);\n       P[44] = vec2(-0.86875 ,    -0.043750);\n       P[45] = vec2(-0.87813 ,    -0.062500);\n       P[46] = vec2(-0.89063 ,    -0.087500);\n       P[47] = vec2(-0.90625 ,    -0.10313);\n       P[48] = vec2(-0.92188 ,    -0.12813);\n       P[49] = vec2(-0.9375  ,   -0.16563);\n       P[50] = vec2(-0.99687 ,    -0.17500);\n       P[51] = vec2(-0.99687 ,    0.012500);\n       P[52] = vec2(-1       ,      0.20625);\n       P[53] = vec2(-0.9875  ,   0.37500);\n       P[54] = vec2(-0.99687 ,    0.52500);\n       P[55] = vec2(-0.99687 ,    0.71562);\n   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    //vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y ;\n    /* \n     float mx = m.x * iResolution.x/iResolution.y;\n     float my = m.y ;\n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   */\n\n      float  z = 1.0e25; //infinity?\n              for(int i=0;i<40-4;i++)\n                z = min(z, T(p,  P[i],P[i+1], P[i+3]) );   \n       float     f = 1.25/z; \n\n    // Time varying pixel color\n               vec3 col = vec3(1.0, 1.0, 1.0);\n                if(f >= 0.0)col.g = sin(iTime/10.0);\n                   else     col.r = f;\n                \n\n    // Output to screen\n                 fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 87], [110, 110, 144, 144, 402], [412, 412, 455, 455, 612], [614, 614, 671, 720, 4069]], "test": "untested"}
{"id": "NtS3Dm", "name": "Class 6 Homework BRDF (gerrit)", "author": "celeph", "description": "SIGGRAPH Frontiers Introduction to Ray Tracing by Rajesh Sharma \ncontinued last scene with a few more spheres orbiting the perlin planet, move light, mouse coords to tweak metallic property (x-coord) and roughness (y-coord) ", "tags": ["brdf"], "likes": 0, "viewed": 44, "published": "Public", "date": "1623981757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/******************************************************************************\n * constants\n */\n#define MAXX 10000000.0\n\nconst float PI = 3.14159265358979323846;\nconst float ONE_OVER_PI = 1.0 / PI;\n\n// array sizes\nconst int NUM_SPHERES = 10;\n\n// samples per pixel\nconst int NUM_SAMPLES = 1;\n\n\n/******************************************************************************\n * counters\n */\n// seed for random numbers \nfloat seed = 0.0;\n\n/******************************************************************************\n * objects and collections\n */\nstruct Material {\n  vec3 baseColor;      \n  float metallic;      \n  float subsurface;    \n  float specular;      \n  float roughness;     \n  float specularTint;  \n  float anisotropic;   \n  float sheen;         \n  float sheenTint;     \n  float clearcoat;     \n  float clearcoatGloss;\n} materials[NUM_SPHERES];\n\n// a Light is defined by a location, color, radius\nstruct Light {\n  vec3 location;\n  vec3 color;\n  float radius;\n} lights[1];\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n  float radius;\n  vec3 center;\n  vec3 color;\n} spheres[NUM_SPHERES];\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\n/******************************************************************************\n * misc functions\n */\n// background gradient color\nvec3 bgColor(vec3 rayDir) {\n  float u =  0.5*(1.0 + rayDir[1]);\n  return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n  return fract(sin(seed++)*43758.5453123);\n}\n\n// square number\nfloat sqr(float x) { return x*x; }\n\n/******************************************************************************\n * transformations\n */\n// translate\nmat4 transformTranslate(in vec3 t) {\n  mat4 ret = mat4(1.0);\n  ret[3] = vec4(t, 1.0);\n  return ret;\n}\n\n// scale\nmat4 transformScale(in vec3 s) {\n  return mat4(s.x, 0.0, 0.0, 0.0,\n              0.0, s.y, 0.0, 0.0,\n              0.0, 0.0, s.z, 0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\n// rotate\nmat4 transformRotate(in float angle, in vec3 axis) {\n  float radians = PI * angle / 180.0;\n  vec3 a = normalize(axis);\n\n  mat3 id = mat3(1.0);\n  mat3 aat = mat3(a.x*a.x, a.x*a.y, a.x*a.z,\n                  a.x*a.y, a.y*a.y, a.y*a.z,\n                  a.x*a.z, a.z*a.z, a.z*a.z);\n\n  mat3 astar = mat3( 0.0, -a.z,  a.y,\n                     a.z,  0.0, -a.x,\n                    -a.y,  a.x,  0.0);\n\n  return mat4(cos(radians) * id + (1.0 - cos(radians)) * aat + sin(radians) * astar);\n}\n\n// rotate about an arbitrary axis in 3 dimensions (verbose)\n// see also http://paulbourke.net/geometry/rotate/\nvec3 rotate(in float angle, in vec3 point, in vec3 axis, in vec3 U) {\n  // 1. translate space so that the rotation axis passes through the origin\n  mat4 T = transformTranslate(axis * -1.0);\n  mat4 Ti = inverse(T);\n\n  // 2. rotate space about the x axis so that the rotation axis lies in the xz plane\n  float t = float(angle) * PI / 180.0;\n  float a = U.x;\n  float b = U.y;\n  float c = U.z;\n  float d = sqrt(b*b + c*c);\n\n  mat4 Rx = mat4(1.0, 0.0, 0.0, 0.0, \n                 0.0, c/d, -b/d, 0.0,\n                 0.0, b/d, c/d, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n  mat4 Rxi = inverse(Rx);\n\n  // 3. rotate space about the y axis so that the rotation axis lies along the z axis\n  mat4 Ry = mat4(d, 0.0, -a, 0.0,\n                 0.0, 1.0, 0.0, 0.0,\n                 a, 0.0, d, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n  mat4 Ryi = inverse(Ry);\n\n  // 4. perform the desired rotation by theta about the z axis\n  mat4 Rz = mat4(cos(t), -sin(t), 0.0, 0.0,\n                 sin(t), cos(t), 0.0, 0.0,\n                 0.0, 0.0, 1.0, 0.0,\n                 0.0, 0.0, 0.0, 1.0);\n\n  // 5. apply the inverse of step (3)\n  // 6. apply the inverse of step (2)\n  // 7. apply the inverse of step (1)\n\n  vec4 pos = vec4(point, 1.0);\n  vec4 newPos = Ti * Rxi * Ryi * Rz * Ry * Rx * T * pos;\n  return vec3(newPos);\n}\n\n\n/******************************************************************************\n * brdf code\n */\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nfloat SchlickFresnel(float u) {\n  float m = clamp(1.0-u, 0.0, 1.0);\n  float m2 = m*m;\n  return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a) {\n  if (a >= 1.0) return 1.0/PI;\n  float a2 = a*a;\n  float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n  return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a) {\n  float a2 = a*a;\n  float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n  return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n  return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG) {\n  float a = alphaG*alphaG;\n  float b = NdotV*NdotV;\n  return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {\n  return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x) {\n  return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y, Material m) {\n  //float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n  //float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n  //float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n  //float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n  ///float dot_ht\t= h_ts.x;\n  ///float dot_hb\t= h_ts.y;\n  \n  float NdotL = clamp(L.z, 0.0, 1.0); // dot(N,L);\n  float NdotV = clamp(V.z, 0.0, 1.0); // dot(N,V);\n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0, 0.0, 0.0);\n\n  vec3 H = normalize(L+V);\n  float NdotH = clamp(H.z, 0.0, 1.0); // dot(N,H);\n  float LdotH = clamp(dot(L, H), 0.0, 1.0); // dot(L,H);\n  \n  float HdotX = H.x;\n  float HdotY = H.y; \n  \n  vec3 Cdlin = mon2lin(m.baseColor);\n  Cdlin = m.baseColor;\n  float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n  vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1); // normalize lum. to isolate hue+sat\n  vec3 Cspec0 = mix(m.specular*.08*mix(vec3(1), Ctint, m.specularTint), Cdlin, m.metallic);\n  vec3 Csheen = mix(vec3(1), Ctint, m.sheenTint);\n\n  // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n  // and mix in diffuse retro-reflection based on roughness\n  float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n  float Fd90 = 0.5 + 2.0 * LdotH*LdotH * m.roughness;\n  float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n  \n  float fd_90_minus_1 = 2.0 * LdotH * LdotH * m.roughness - 0.5;\n  \n  Fd  = (1.0 + fd_90_minus_1 * pow(1.0 - NdotL, 5.0))\n      * (1.0 + fd_90_minus_1 * pow(1.0 - NdotV, 5.0));\n\n  // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n  // 1.25 scale is used to (roughly) preserve albedo\n  // Fss90 used to \"flatten\" retroreflection based on roughness\n  float Fss90 = LdotH*LdotH*m.roughness;\n  float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n  float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n  // specular\n  float aspect = sqrt(1.0-m.anisotropic*.9);\n  float ax = max(.001, sqr(m.roughness)/aspect);\n  float ay = max(.001, sqr(m.roughness)*aspect);\n  float Ds = GTR2_aniso(NdotH, HdotX, HdotY, ax, ay);\n  float FH = SchlickFresnel(LdotH);\n  vec3 Fs = mix(Cspec0, vec3(1), FH);\n  float Gs;\n  Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n  Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n  Gs = 1.0; \n  // sheen\n  vec3 Fsheen = FH * m.sheen * Csheen;\n\n  // clearcoat (ior = 1.5 -> F0 = 0.04)\n  float Dr = GTR1(NdotH, mix(.1,.001,m.clearcoatGloss));\n  float Fr = mix(.04, 1.0, FH);\n  float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n  //return 1.0/PI * Fd*Cdlin * (1.0-m.metallic);\n  \n  return ((1.0/PI) * mix(Fd, ss, m.subsurface)*Cdlin + Fsheen)\n      * (1.0-m.metallic)\n      + Gs*Fs*Ds + .25*m.clearcoat*Gr*Fr*Dr;\n}\n\n// BRDF code from last lecture\n// vec3 calc_fresnel_schlick(vec3 f0, float dot_vn) {\n//   return f0 + (1.0 - f0) * pow(1.0 - dot_vn, 5.0);\n// }\n\n// vec3 calc_diffuse_term(float dot_nl, float dot_nv, float dot_lh, vec3 base_color, float rough_s) {\n//   float fd_90_minus_1 = 2.0 * dot_lh * dot_lh * rough_s - 0.5;\n  \n//   return base_color * ONE_OVER_PI \n//     * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nl, 5.0))\n//     * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nv, 5.0));\n// }\n\n// // anisotropic GGX / Trowbridge-Reitz\n// float calc_distribution_ggx(float dot_nh, float dot_ht, float dot_hb, vec2 linear_roughness) {\n//   float rought_x  = linear_roughness.x * linear_roughness.x;\n//   float rought_y  = linear_roughness.y * linear_roughness.y;\n//   float rough_x_s = rought_x * rought_x;\n//   float rough_y_s = rought_y * rought_y;\n    \n//   float d = (dot_nh * dot_nh\n//     + dot_ht * dot_ht * (1.0 / rough_x_s)\n//     + dot_hb * dot_hb * (1.0 / rough_y_s));\n  \n//   return ONE_OVER_PI * (1.0 / (rought_x * rought_y * d * d));\n// }\n\n// float calc_smith_lambda(float a2, float cos_angle) {\n//   if (cos_angle < 0.01) return 0.0;\n    \n//   float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n//   float tan_angle = sin_angle * (1.0 * cos_angle);\n\n//   return sqrt(1.0 + a2 * tan_angle * tan_angle) * 0.5 - 0.5;\n// }\n\n// float calc_masking_shadow_factor(float dot_nl, float dot_nv, float rought_s) {\n//   // smith correlated\n//   float a2     = rought_s * 0.5;\n//   float lambda_l   = calc_smith_lambda(a2, dot_nl);\n//   float lambda_v   = calc_smith_lambda(a2, dot_nv);\n//   return 1.0f / (1.0 + lambda_l + lambda_v);\n// }\n\n// vec3 calc_specular_term(vec3 fresnel, float dot_nl, float dot_nv, float dot_nh, float dot_lh, \n//                         float dot_ht, float dot_hb, vec2 linear_roughness, float rough_s) {\n//   float v_1_over_denom = 1.0 / (4.0 * dot_nl * dot_nv);\n\n//   return fresnel\n//     * calc_distribution_ggx(dot_nh, dot_ht, dot_hb, linear_roughness)\n//     * calc_masking_shadow_factor(dot_nl, dot_nv, rough_s)\n//     * v_1_over_denom;\n// }\n\n// vec3 mon2lin(vec3 x) {\n//   return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n// }\n\n\n/******************************************************************************\n * intersections\n */\nstruct Intersection {\n  int obj;\n  float t;\n};\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n  vec3 rayToSphere = ray.origin - sphere.center;\n  float b = dot(rayToSphere, ray.direction);\n  float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n  float disc = b*b - c;\n  float t;\n\n  if (disc > 0.0) {\n    t = -b - sqrt(disc);\n    if (t > 0.00001) return t;\n\n    t = -b + sqrt(disc);\n    if (t > 0.00001) return t;\n  }\n  return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n  float minT = MAXX;\n  int iSphere = -1;\n    \n  for (int i=0; i < NUM_SPHERES; i++) {\n    Sphere sphere = spheres[i];\n      \n    float t = raySphereIntersect(ray, sphere);\n        \n    if (t < minT && t >= 0.001) {\n      // keep track of the closest sphere and intersection\n      iSphere = i;\n      minT = t;\n    }\n  }\n  \n  return Intersection(iSphere, minT);\n}\n\n/******************************************************************************\n * lights, shadows, colors\n */\n// convert directionToLight and directionToView to tangent space\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS) {\n  // use a matrix to convert\n  vec3 t = normalize(dFdx(hitPoint));\n  vec3 b = normalize(dFdy(hitPoint));\n  vec3 n = normalize(cross(t, b));\n  mat3 xformMatrix = transpose(mat3(t, b, n));\n  \n  toLightTS = xformMatrix * toLight;\n  toViewTS = xformMatrix * toView;\n  nTS = n;\n}\n\n// returns 1.0 if light visible, 0.0 otherwise\nfloat checkLightVisibility(in Light light, vec3 hitPoint, vec3 hitNormal) {\n  float visible = 0.0;\n  vec3 lightDir = normalize(light.location - hitPoint);\n  Ray ray;\n  ray.origin = hitPoint + lightDir * 0.01;\n  ray.direction = lightDir;\n  Intersection intersection = intersectAllObjects(ray);\n  int iSphere = intersection.obj;\n  if (iSphere == -1) { \n      // no object was hit, light is visible\n      visible = 1.0;\n  }\n  return visible;\n}\n\n\n// Classic Perlin 3D Noise \n// by Stefan Gustavson\n// see https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n\n  return 2.2 * n_xyz;\n}\n\nvec3 addMyPerlinTexture1(in vec2 fragCoord, int f) {\n  vec2 uv = fragCoord/iResolution.xy;\n\n  // Displace the UV\n  vec2 displacedUv = uv + cnoise(vec3(uv * 5.0, iTime * .1));\n\n  // Perlin noise\n  float strength = cnoise(vec3(displacedUv * 5.0, iTime * .2));\n  \n  float outerGlow = distance(uv, vec2(0.5)) * 5.0 - 1.2;\n  //gl_FragColor = vec4(outerGlow, outerGlow, outerGlow, 1.0);\n  \n  strength += outerGlow;\n\n  // Apply cool step\n  strength += step(-0.2, strength) * .8;\n\n  strength = clamp(strength, 0.0, 1.0);\n\n  vec3 colorStart = vec3(0.2,0.2,.2);\n  vec3 colorEnd = vec3(1.,1.,1.);\n\n  vec3 colorMixed = 1./mix(colorStart, colorEnd, strength);\n  return colorMixed;\n}\n\n/******************************************************************************\n * the scene and main entry point\n */\n// create 4 spheres at different locations in different colors\nvoid makeScene(int f) {\n  float width = iResolution.x;\n  float height = iResolution.y; \n  float aspectRatio = width/height;\n\n  spheres[0] = Sphere(0.2, vec3(0.0, 0.0, -1.0), vec3(1, 1, 0));\n\n  // See also Blender: Principled BSDF\n  materials[0].baseColor = vec3(.8, 0.0, 0.011);\n  materials[0].metallic = 0.5;\n  materials[0].specular = 0.5;\n  materials[0].specularTint = 0.796;\n  materials[0].roughness = 0.5;\n  materials[0].anisotropic = 0.181;\n  materials[0].sheen = 0.218;\n  materials[0].sheenTint = 0.5;\n  materials[0].clearcoat = .720;\n  materials[0].subsurface = 1.;\n  materials[0].clearcoatGloss = .161;\n\n  float xs = -0.4;\n\n  for(int i=1; i<8; i++) {\n    float x = xs + float(i-1) * .1;\n    spheres[i] = Sphere(min(.1*random(), 0.05), vec3(x, 0.0, -1.4), vec3(0.,0.,1.));\n    materials[i].baseColor = vec3(random(), random(), random());\n    materials[i].metallic += (iMouse.x / width * aspectRatio * 2.0 - 1.0) * .1;\n    materials[i].roughness += (iMouse.y / height * 2.0 - 1.0) * .1; // TODO\n\n    materials[i].specular = .5;\n    materials[i].specularTint = .2;\n    materials[i].anisotropic = .1;\n    materials[i].sheen = .1;\n    materials[i].sheenTint = .1;\n    materials[i].clearcoat = .12;\n    materials[i].subsurface = 1.;\n    materials[i].clearcoatGloss = 0.525;\n\n    float rx = 0.0;\n    float ry = 1.0 * random();\n    float rz = 0.0;\n    spheres[i].center = rotate(float(f)*.5*random(), spheres[i].center, spheres[0].center, normalize(vec3(rx,ry,rz)));\n    spheres[i].center = rotate(45.0*random(), spheres[i].center, spheres[0].center, normalize(vec3(0.0, 0.0, 1.0)));\n  }\n\n  lights[0] = Light(vec3(-.8, 1.0, -.5), vec3(1, 1, 1), .2);\n  lights[0].location = rotate(float(f)*.2, lights[0].location, spheres[0].center, normalize(vec3(0.0, 1.0, 0.0)));\n}\n\n// The main entry point: This is called for every pixel on the screen \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // fragCoord ranges from \n  //   in x: 0.5 to iResolution.x-0.5\n  //   in y: 0.5 to iResolution.y-0.5\n  // pixel (0,0) is at the bottom left corner\n  \n  makeScene(iFrame);\n  \n  vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n  \n  float screenDepth = -2.0;\n  \n  float width = iResolution.x;\n  float height = iResolution.y; \n  float aspectRatio = width/height;\n   \n  vec3 samp = vec3(0, 0, 0);\n  seed = 0.0;\n\n  // position light by mouse coord \n  // lights[0].location.x = (iMouse.x / width * aspectRatio * 2.0 - 1.0);\n  // lights[0].location.y = (iMouse.y / height * 2.0 - 1.0);\n\n  for (int i=0; i<1*NUM_SAMPLES; i++) {\n    float x = fragCoord.x + random() - 0.5;\n    float y = fragCoord.y + random() - 0.5;\n    \n    // map (0.5, w-0.5) to (-1, 1)\n    // and (0.5, h-0.5) to (-1, 1)\n    x = (x/width)*2.0 - 1.0;\n    y = (y/height)*2.0 - 1.0;\n    \n    // account for the non-square window\n    y = y/aspectRatio;\n              \n    // normalized ray direction\n    vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n    Ray ray = Ray(rayOrigin, rayDirection);\n              \n    // traverse the scene (all spheres) and find the \n    // closest intersected object and intersection point\n    Intersection intersection = intersectAllObjects(ray);\n       \n    int iSphere = intersection.obj;\n    float minT = intersection.t;\n       \n    Sphere sphere;\n       \n    if (iSphere > -1) { // if there is an intersection\n      // to get around iSphere not being constant\n      // TODO: Not entirely sure why this is needed, need to look into this.\n      for (int i=0; i<NUM_SPHERES; i++) {\n        if (i==iSphere) {\n          sphere = spheres[i];\n          break;\n        }\n      }\n           \n      // hit coordinates\n      vec3 hit = ray.origin + minT*ray.direction;\n      // normal at the point of ray-sphere intersection\n      vec3 hitPointNormal = normalize(hit-sphere.center);         \n      // vector from intersection to light\n      vec3 hitPointToLight = normalize(lights[0].location-hit);\n      vec3 hitPointToView = ray.origin-hit;\n           \n      vec3 toViewTS;\n      vec3 toLightTS;\n      vec3 nTS;\n\n      convertToTangentSpace(hitPointToLight, hitPointToView, hit, toLightTS, toViewTS, nTS); \n\n      vec3 h_ts     = normalize(toLightTS + toViewTS);\n      float dot_nl  = clamp(toLightTS.z, 0.0, 1.0);\n      float dot_nv  = clamp(toViewTS.z, 0.0, 1.0);\n      float dot_nh  = clamp(h_ts.z, 0.0, 1.0);\n      float dot_lh  = clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n      float dot_ht  = h_ts.x;\n      float dot_hb  = h_ts.y;\n\n      Material m = materials[iSphere];\n\n      // lighting\n      // vec3 f0 = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n      // vec3 fresnel  = calc_fresnel_schlick(f0, dot_nv);\n      // float rough_s = dot_ht * dot_ht * m.roughness * m.roughness\n      //     + dot_hb * dot_hb * m.roughness * m.roughness; \n   \n      // vec3 diffuse_factor = (1.0 - fresnel) * (1.0 - m.metallic);\n            \n      // vec3 diffuse_term = diffuse_factor * calc_diffuse_term(dot_nl, dot_nv, dot_lh, m.baseColor, rough_s);\n      // vec3 specular_term = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n      // vec3 col = diffuse_term * dot_nl;\n\n      vec3 wi;\n      float lightPdf;\n      float lightVisible = checkLightVisibility(lights[0], hit, hitPointNormal);\n\n      vec3 brdf = BRDF(toLightTS, toViewTS, nTS, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), m);\n          \n      vec3 col = brdf * dot_nl * lightVisible;\n\n      if (iSphere == 0) {\n        col *= addMyPerlinTexture1(fragCoord, iFrame);\n      }\n\n      vec3 toneMappedColor = col * (1.0 / (col + 1.0));\n      float gamma = 1.0 / 2.2;\n\n      vec3 finalColor = vec3(pow(toneMappedColor.x, gamma),\n                             pow(toneMappedColor.y, gamma),\n                             pow(toneMappedColor.z, gamma));\n\n      samp = samp + finalColor; \n    } \n    else {\n      samp = samp + bgColor(ray.direction);\n    }\n  }\n\n  // average all the samples per pixel\n  fragColor = vec4(samp/float(NUM_SAMPLES), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1243, 1374, 1401, 1401, 1503], [1509, 1542, 1558, 1558, 1603], [1605, 1622, 1642, 1642, 1656], [1658, 1774, 1810, 1810, 1875], [1877, 1886, 1918, 1918, 2057], [2059, 2069, 2121, 2121, 2552], [2554, 2665, 2734, 2810, 3971], [3974, 4215, 4246, 4246, 4332], [4334, 4334, 4368, 4368, 4495], [4497, 4497, 4531, 4531, 4617], [4619, 4619, 4696, 4696, 4780], [4782, 4782, 4827, 4827, 4925], [4927, 4927, 5010, 5010, 5089], [5091, 5091, 5113, 5113, 5178], [5180, 5180, 5244, 5529, 7949], [10258, 10298, 10354, 10354, 10715], [10717, 10803, 10846, 10846, 11208], [11210, 11386, 11509, 11538, 11784], [11786, 11833, 11908, 11908, 12273], [12276, 12400, 12421, 12421, 12460], [12461, 12461, 12488, 12488, 12538], [12539, 12539, 12558, 12558, 12596], [12598, 12598, 12620, 12620, 14893], [14895, 14895, 14947, 14947, 15564], [15566, 15747, 15770, 15770, 17513], [17515, 17586, 17641, 17791, 21645]], "test": "untested"}
{"id": "NtS3RD", "name": "Voronoi graph", "author": "HanShaoqiu", "description": "noise", "tags": ["noise"], "likes": 1, "viewed": 125, "published": "Public API", "date": "1623406332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p){\n\tvec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n\ta+=dot(a,a+100.45);\n\treturn fract(vec2 (a.x*a.y ,a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec4 col = vec4(1.0);\n    //col = texture(iChannel0,uv);\n    float m = 0.0;\n\tfloat t = iTime;\n\tfloat minDist = 10.0;\n\tfloat cellIndex = 0.0 ;\n    vec2 uv1  = uv *10.0 ;\n\tvec2 gv = fract(uv1);\n\tvec2 id = floor(uv1);\n\n\tfor(int x =-1 ; x<=1 ; x++){\n\t\tfor(int y =-1 ; y<=1 ; y++){\n\t\t vec2 offs = vec2 (x,y);\n\t\t\tvec2 n = N22(id+offs);\n\t\t\tvec2 p = sin(n*t*5.0)*0.5+0.5+offs;\n\t\t\tfloat d = length (gv-p);\n\t\t\tif(d<minDist){\n\t\t\t\tminDist = d;\n\t\t\t}\n\n\t\t}\n\t}\n    col *= minDist;\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 131], [133, 133, 190, 240, 795]], "test": "untested"}
{"id": "NtS3Wd", "name": "Cactus fractal thing", "author": "jarble", "description": "I don't know what this thing is, but it looks very much like a cactus.", "tags": ["fractal", "cactus"], "likes": 7, "viewed": 164, "published": "Public API", "date": "1624926448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.6;\n        float scale1 = 1.2;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 795]], "test": "untested"}
{"id": "Nts3WX", "name": "Fire movement - shader (2)", "author": "sarabase", "description": "Basic fire shader implemented using a noise function", "tags": ["fire", "texture", "shader"], "likes": 6, "viewed": 47, "published": "Public", "date": "1623341576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 p ) {\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n    //The output must be between 0.0 and 1.0\n\treturn -1.0 + 2.0*fract(sin(p) * 43758.5453123);\n}\n\nfloat noise( in vec2 p ) { //Simplex noise\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y) * K1 );\n\n    vec2 a = p - i + (i.x+i.y) * K2;\n    vec2 o = step(a.yx,a.xy);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.; //lacunarity: steps in which we increment de frequencies\n        amplitude *= .5; //gain: decreases the amplitude\n    }\n    return value * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float color = 0.;\n    //Normalize fragment coordinates\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //These variables are used to modify the speed at which the texture moves\n    float strength = floor(uv.x+1.);\n    float t = max(3.,1.25*strength)*iTime*0.75;\n    \n    color += fbm(uv*strength-vec2(0,t));\n\n    float c1=clamp(color,0.,1.);\n\n    \n    float gradient = pow(1.0 - uv.y, 2.0) * 5.;\n    float finalNoise = c1 * gradient;\n    \n\n    vec3 col = vec3(c1, c1*c1*c1, c1*c1*c1*c1*c1*c1*c1*c1);\n\n    //define FLAMELIKE to implement a gradient\n    #define FLAMELIKE \n#ifdef FLAMELIKE\n    col = finalNoise * vec3(c1, c1*c1*c1, c1*c1*c1*c1*c1*c1*c1*c1);\n#endif\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nts3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 189], [191, 191, 217, 233, 685], [705, 705, 729, 729, 1057], [1059, 1059, 1116, 1116, 1828]], "test": "untested"}
{"id": "NtsGD7", "name": "noise_MrNissenDK", "author": "MrNissenDK", "description": "This noise algorithm is based on Perlin noise to output a random yeat smooth looking map, such as terrain for games.", "tags": ["noise", "game", "terrain", "perlin", "smooth"], "likes": 2, "viewed": 150, "published": "Public API", "date": "1622506875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float res = 10.; // how many sqrs along the x axes\nint seed = -5;\nint detail = 8;\nbool debug = false;\n\n\nfloat pixelSize = 0.;\n\nfloat[] digitsPi = float[](14.159265,35.897932,38.462643,38.327950,28.841971,69.399375,10.582097,49.445923,78.16406,28.620899,86.280348);\n\nfloat getDigit(float index){\n    return digitsPi[int(abs(mod(index, float(digitsPi.length()))))];\n}\nfloat getDigit(int index){\n    return getDigit(float(index));\n}\nfloat getRandom(vec2 index){\n    index = mod(index, 65535.);\n    float id = length(index) * float(seed) + length(index) + float(seed);\n    return fract(sin(dot(index, vec2(getDigit(id+265.), getDigit(id+159.))))* getDigit(id + 314.));\n}\nfloat getRandom(vec3 index){\n    index = mod(index, 65535.);\n    float id = length(index) * float(seed) + length(index) + float(seed);\n    return fract(sin(dot(index, vec3(getDigit(id+265.), getDigit(id+159.), getDigit(id+582.))))* getDigit(id + 314.));\n}\nfloat smoothMix(vec2 from, vec2 to, vec2 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(getRandom(from), getRandom(vec2(to.x, from.y)), t.x),\n        mix(getRandom(vec2(from.x, to.y)), getRandom(to), t.x),\n    t.y);\n}\nfloat smoothMix(vec3 from, vec3 to, vec3 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(\n            mix(getRandom(from), getRandom(vec3(to.x, from.yz)), t.x),\n            mix(getRandom(vec3(from.x, to.y, from.z)), getRandom(vec3(to.xy, from.z)), t.x),\n        t.y),\n\n        mix(\n            mix(getRandom(vec3(from.xy, to.z)), getRandom(vec3(to.x, from.y, to.z)), t.x),\n            mix(getRandom(vec3(from.x, to.yz)), getRandom(to), t.x),\n        t.y),\n\n    t.z);\n}\nfloat getNoise(vec2 index){\n    vec2 low = floor(index);\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec2 low = floor(index);\n        _output += smoothMix(low, low + vec2(1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += float(seed) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nfloat getNoise(vec3 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec3 low = floor(index);\n        _output += smoothMix(low, low + vec3(1,1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += float(seed) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n    \n    vec3 col = vec3(getNoise(vec3(uv, iTime/5.)));\n    \n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 266, 294, 294, 365], [366, 366, 392, 392, 429], [430, 430, 458, 458, 666], [667, 667, 695, 695, 922], [923, 923, 967, 967, 1154], [1155, 1155, 1199, 1199, 1636], [1637, 1637, 1664, 1664, 2027], [2028, 2028, 2055, 2055, 2391], [2392, 2392, 2449, 2449, 2852]], "test": "untested"}
{"id": "NtSGDD", "name": "Fractal Golfing [86 chars]", "author": "Xor", "description": "Not sure if the AA is worth the extra characters. 9x looks pretty good though", "tags": ["sierpinski", "tiny", "2tweet"], "likes": 1, "viewed": 73, "published": "Public", "date": "1623877158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//No AA (86 chars)\nvoid mainImage( out vec4 O,vec2 I)\n{\n    O = 1.-vec4( int( I/=exp2(fract(iTime/5.)) ) & int(I.y) );\n}\n\n\n\n///2x AA (141 chars)\n/*\nvoid mainImage( out vec4 O,vec2 I)\n{\n    I /= exp2(fract(iTime/5.));\n    O = vec4(0,.5,0,.5);\n    O *= dot(step(vec4((ivec4(I.x+O)&ivec4(I.y+O.rrgg))),O+=.5-O),O);\n}\n*/\n\n\n\n///9x AA (154 chars)\n/*\nvoid mainImage( out vec4 O,vec2 I)\n{\n    I /= exp2(fract(iTime/5.)); O-=O;\n    for(int i = 0;i++<81;)\n    O += step(vec4(ivec4(I.x+vec4(i%9)/9.)&ivec4(I.y+vec4(i/9)/9.)),O)/81.;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 55, 55, 120]], "test": "untested"}
{"id": "NtSGDR", "name": "Bunch o' random shapes", "author": "Ridicolas", "description": "My first shader, it isn't much, kind of glitchy, but its a start.\nIf you see anything glaringly wrong, tell me.\n\nThank you The Art of Code for your tutorials!", "tags": ["shapes"], "likes": 4, "viewed": 64, "published": "Public", "date": "1623734301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS (1<<7)\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define LIGHT_RADIUS 1000.\n\nconst float TorusMat = 1.;\nconst float CapsuleMat = 2.;\nconst float ShpereMat = 3.;\nconst float CubeMat = 4.;\nconst float PlaneMat = 5.;\n\nvec3 GetMatColor(float mat, vec3 currentPoint)\n{\n    vec3 col = vec3(0);\n    if(mat == TorusMat)\n    {\n        col = vec3(1,sin(iTime),cos(iTime));\n    }else if(mat == CapsuleMat)\n    {\n        col = vec3(0,0.5,cos(iTime));\n    }else if(mat == ShpereMat)\n    {\n        col = vec3(0.4,0.5,0.5);\n    }else if(mat == CubeMat)\n    {\n        col = vec3(.1);\n    } else {col = vec3(1);}\n    return col;\n}\n\nfloat GetMatSpec(float mat)\n{\n    if(mat == ShpereMat)\n    {\n        return 5.;\n    } else if(mat == CubeMat)\n    {\n        return 5.;\n    } else if(mat == PlaneMat)\n    {\n        return 0.05;\n    }\n    return 0.2;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab,ab);\n    t = clamp(t,0.,1.);\n    \n    vec3 c= a + t * ab * (sin(p.y / 1.) + 0.5);\n    return length(p-c)-r;\n}\n\nmat2 getRot(float rot)\n{\n    rot = radians(rot);\n    return mat2(cos(rot),sin(rot),-sin(rot),cos(rot));\n}\n\nfloat sdBox(vec3 p, vec3 s,vec3 r) {\n    p.zx *= getRot(r.y);\n    p.yx *= getRot(r.z);\n    p.zy *= getRot(r.x);\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTorus (vec3 p, vec2 r)\n{\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y)) -r.y;\n}\n\nfloat GetPlaneHeight (vec3 point, float lod)\n{\n    float f = 1.2;\n    vec3 texXZ = pow(textureLod(iChannel0, point.xz * .3+.5, lod).rgb, vec3(f));\n    return dot(texXZ, vec3(5.,1.,.2) * .003);\n}\n\nvec2 GetDist (vec3 p) {\n    vec4 s = vec4(sin(iTime), 1,cos(iTime) + 4., 1);\n    \n    float sphereDist = length(p-s.xyz ) - s.w;\n    float torusDist = sdTorus(p - vec3(0,sin(iTime)/5. + .5,-3), vec2(1,sin(iTime)/6. + 0.5));\n    float planeDist = p.y;\n    float boxDist = sdBox(p - vec3(-4,1.05,0), vec3(1),vec3(iTime*20.,0,iTime*20.)) - 0.1;\n    \n    float cd = sdCapsule(p - vec3(4,0,0), vec3(-cos(iTime),-sin(iTime) + 2.,0), vec3(cos(iTime),sin(iTime) + 2.,0),.6);\n    float d = min(cd, planeDist);\n    d = min(d, sphereDist);\n    d = min(d, torusDist);\n    d = min(d, boxDist);\n    \n    float mat = 0.;\n    if(d == torusDist) {mat = TorusMat;}\n    else if(d == cd) {mat = CapsuleMat;}\n    else if(d == sphereDist) {mat = ShpereMat;}\n    else if(d == planeDist) \n    {\n        \n        mat = PlaneMat;\n        d -= GetPlaneHeight (p, 2.);\n    }\n    else if(d == boxDist) {mat = CubeMat;}\n    return vec2(d,mat);\n}\n\nvec3 GetNormal (vec3 p) {\n    float d = GetDist (p).x;\n    vec2 e = vec2 (.0003, 0);\n    \n    vec3 left = vec3(GetDist(p - e.xyy).x,\n                     GetDist(p - e.yxy).x,\n                     GetDist(p - e.yyx).x),\n        right = vec3(GetDist(p + e.xyy).x,\n                     GetDist(p + e.yxy).x,\n                     GetDist(p + e.yyx).x);\n        \n    vec3 n = normalize(-left + right);\n    return normalize(n);\n}\n\nvec3 GetPlaneTexture (vec3 point)\n{\n    vec3 normal = abs(GetNormal(point));\n    vec3 texXZ = texture(iChannel0, point.xz * .3+.5).rgb;\n    vec3 texYZ = texture(iChannel0, point.yz * .5+.5).rgb;\n    vec3 texXY = texture(iChannel0, point.xy * .5+.5).rgb;\n    vec3 disp = vec3(0);\n    disp += texXY * normal.z;\n    disp += texYZ * normal.x;\n    disp += texXZ * normal.y;\n    return disp;\n}\n\nvec3 RayMarch (vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    float smallestDist = 1.;\n    float mat = 0.;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 currentPoint = ro + rd * dO;\n        vec2 Distance = GetDist(currentPoint);\n        mat = Distance.y;\n        float dS = Distance.x;\n        dO += dS;\n        smallestDist = min(smallestDist,dS/dO);\n        if(dS <= 0.01) \n        {\n            smallestDist = 0.;\n        }\n        if(dO>MAX_DIST || dS<SURF_DIST)\n        {\n         float fadeRatio =\n         1.0 - clamp(SURF_DIST / LIGHT_RADIUS, 0., 1.);\n         float distanceFactor = pow(fadeRatio, 2.);\n         smallestDist *= distanceFactor;\n         break;\n        }\n    }\n    smallestDist = clamp(smallestDist,0.,1.);\n    return vec3(dO,smallestDist,mat);\n}\n\nvec3 GetLight(float material,vec3 rayDir,vec3 p, vec3 pos,float power, vec3 color) \n{\n    vec3 lightPos = pos;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal (p);\n    \n    \n    float specAmount = GetMatSpec(material);\n    float spec = 0.;\n    if(specAmount != .0)\n    {\n        spec = pow(max( dot( reflect(-l, n), -rayDir ), 0.), 8.);\n    }\n    vec3 d = RayMarch(p+n*SURF_DIST*(material == CapsuleMat ? 400. : 12.),l);\n    float dif = d.y *clamp(dot(n, l), 0.,1.);\n    return clamp( dif + (vec3(1., .6, .2)*spec*specAmount),0.002,1.) * color * power;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 GetColor (float material, vec3 rayDirection, vec3 point)\n{\n    vec3 col = vec3(1);\n    if(material == PlaneMat)\n    {\n        col = GetPlaneTexture(point);\n    } else {col = GetMatColor(material,point);}\n\n\n    col *= \n       GetLight(material,rayDirection,point,vec3(0,5,-6),1.,vec3(1,1,1))\n    + GetLight(material,rayDirection,point,vec3(sin(iTime) * 3.,5,cos(iTime) * 3.),1.,vec3(1,0,1));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 pos = vec3(0, 6, -6);\n    vec3 ro = pos;\n    ro.yz *= Rot(-mouse.y*3.14+1.);\n    ro.xz *= Rot(-mouse.x*6.2831);\n    ro.y = clamp(ro.y,1.2,10.);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    \n    vec3 normal = GetNormal(p);\n    \n    float Distance = d.x;\n    \n    vec3 col = vec3(0);\n    if(d.x < MAX_DIST && d.x >= SURF_DIST)\n    {\n        col = GetColor (d.z, rd, p);\n        if(d.z == ShpereMat)\n        {\n            ro += rd*d.x;\n            rd = reflect(rd,normal);\n            d = RayMarch(ro+normal*0.0015, rd);\n            if(d.x < MAX_DIST)\n            {\n                p = ro + rd * d.x;\n                col += GetColor (d.z, rd, p) / (d.z == PlaneMat ? 1. : 8.);\n            }\n            normal = GetNormal(p);\n        }\n        \n    }\n    col = pow(col, vec3(.4545));\n    //Fade to black\n    col *= ((MAX_DIST-Distance)/MAX_DIST);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 284, 284, 634], [636, 636, 665, 665, 852], [854, 854, 904, 904, 1092], [1094, 1094, 1118, 1118, 1199], [1201, 1201, 1237, 1237, 1393], [1395, 1395, 1427, 1427, 1499], [1501, 1501, 1547, 1547, 1695], [1697, 1697, 1720, 1720, 2612], [2614, 2614, 2639, 2639, 3038], [3040, 3040, 3075, 3075, 3427], [3429, 3429, 3464, 3464, 4202], [4204, 4204, 4289, 4289, 4769], [4771, 4771, 4821, 4821, 5012], [5014, 5014, 5033, 5033, 5095], [5097, 5097, 5160, 5160, 5511], [5513, 5513, 5570, 5570, 6670]], "test": "untested"}
{"id": "NtsGWj", "name": "Distance to Truchet", "author": "oneshade", "description": "Distance to 2D truchet and a parametrization.", "tags": ["2d", "sdf", "truchet", "distance", "parametrization"], "likes": 12, "viewed": 90, "published": "Public", "date": "1622873154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy).x;\n}\n\nvec2 sdTruchet(in vec2 p) {\n    vec2 cId = floor(p);\n    vec2 cUv = fract(p) - 0.5;\n\n    cUv.x *= sign(Hash21(cId) - 0.5);\n    cUv -= cUv.x < -cUv.y ? -0.5 : 0.5;\n\n    float t = atan(cUv.y, cUv.x);\n    t *= sign(mod(cId.x + cId.y, 2.0) - 0.5);\n\n    return vec2(abs(length(cUv) - 0.5), t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0 + 0.25 * iTime;\n\n    vec2 truchet = sdTruchet(uv);\n    float d = truchet.x - 0.1;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d) * 0.6));\n\n    if (d < 0.02) {\n        truchet.y -= 0.5 * iTime;\n        float fade = 0.5 + 0.5 * sin(iTime);\n        float vertStripes = abs(mod(d + 0.0333, 0.0666) - 0.0333);\n        float horiStripes = abs(mod(truchet.y + 0.1, 0.2) - 0.1) * 0.5;\n        color += fade * smoothstep(0.03, 0.0, min(vertStripes, horiStripes));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 114, 114, 251], [253, 253, 280, 280, 543], [545, 545, 600, 600, 1371]], "test": "untested"}
{"id": "NtsGzl", "name": "circle demo111", "author": "zengqh", "description": "circle", "tags": ["circle"], "likes": 4, "viewed": 178, "published": "Public API", "date": "1623303934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float drawCircle(vec2 pos, float t)\n{\n    float dist = length(pos);\n    \n    float radius = mod(t * .1, .3);\n    float fadeDis = smoothstep(.3, .0, radius);\n    \n    float intensity = clamp(pow(2./abs(dist-radius), .2), .0, 3.5);\n    \n    intensity *= smoothstep(2.2, 3.1, intensity);\n    \n    intensity *= fadeDis;\n    \n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float intensity = drawCircle(pos, iTime);\n    intensity += drawCircle(pos, iTime + 1.);\n    intensity += drawCircle(pos, iTime + 2.);\n    \n    fragColor = vec4(.0,.3,.8, 1.) * intensity;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 344], [346, 346, 403, 403, 691]], "test": "untested"}
{"id": "NtsSRn", "name": "Evolving mandelbrot", "author": "Swiiz", "description": "An evolving mandelbrot", "tags": ["mandelbrot", "complex", "evolving"], "likes": 2, "viewed": 109, "published": "Public API", "date": "1625065148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float carg(vec2 Z)   {return   atan( (Z).y, (Z).x ) ;}\nvec2 CS(float a) {return vec2( cos(a), sin(a) ); }\nvec2 cmul(vec2 A,vec2 B) {return ( mat2( A, -(A).y, (A).x ) * (B) ) ;}  // by deMoivre formula\nvec2 pol2cart(vec2 U) { return (U).x * CS( (U).y ); }\nvec2 cpow(vec2 Z, float v) {return   pol2cart( vec2( pow(length(Z),v) , (v) * carg(Z) ) ) ;}\n\nconst vec4 colorPalette = -vec4(0,23,21,0);\nconst vec4 finalColor = vec4(.0);\nconst int hueModulus = 30;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.;\n    int recursion = 50, i = 0;\n    vec2 c = (fragCoord / iResolution.x - .5) * -zoom + -iMouse.xy/iResolution.xy, z = c;\n    for(; i <= recursion && length(z) <= 10. ; i++ ) z = cpow(z, iTime / 5. + 1.) + c;\n    fragColor =  i - 1 == recursion ? finalColor : .6 + .6 * cos( 6.3 *  (float((i - 1) % hueModulus) / float(hueModulus)) + colorPalette);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 54], [55, 55, 73, 73, 105], [106, 106, 132, 132, 176], [178, 201, 224, 224, 254], [255, 255, 283, 283, 347], [455, 455, 512, 512, 883]], "test": "untested"}
{"id": "NtX3DS", "name": "circle fun 2", "author": "zengqh", "description": "cicle fun", "tags": ["circle"], "likes": 5, "viewed": 82, "published": "Public", "date": "1622691133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 drawCircle(vec2 pos, float radius, float width, float power, vec4 color)\n{\n    vec2 mousePos = iMouse.xy - vec2(0.5);\n    float dist1 = length(pos);\n    dist1 = fract((dist1 * 5.0) - mod(iTime, 3.));\n    float dist2 = dist1 - radius;\n    float intensity = pow(radius / abs(dist2), width); \n    vec3 col = color.rgb * intensity * power;\n    return col;\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    vec4 t = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // // -1.0 ~ 1.0\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float h = mix(0.5, 0.65, length(pos));\n    vec4 color = vec4(hsv2rgb(h, 1.0, 1.0), 1.0);\n    float radius = 0.5;\n    float width = 0.4;\n    float power = 0.2;\n    vec3 finalColor = drawCircle(pos, radius, width, power, color);\n\n    pos = abs(pos);\n    // vec3 finalColor = vec3(pos.x, 0.0, pos.y);\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 79, 79, 358], [360, 360, 401, 401, 576], [578, 578, 635, 656, 1095]], "test": "untested"}
{"id": "NtX3zl", "name": "Line Fractal", "author": "scry", "description": "just a doodle", "tags": ["2d", "fractal", "zoom", "infinite"], "likes": 5, "viewed": 190, "published": "Public API", "date": "1622918396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime iTime*0.5\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat line(vec2 uvu, float l, float w) {\n    return smoothstep(w, 0.,abs(uvu.x-0.5)-0.005)*smoothstep(0.001,0.,abs(uvu.y-0.5)-l);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    uv += 0.5;\n    //\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    //col.r += smoothstep(0.01,0.,abs(uv.x-0.5));\n    //col.r *= smoothstep(0.01,0.,abs(uv.y-0.5)-0.4);\n    uv -= 0.5;\n    float c = length(uv);\n    float cc = c;\n    //uv.y -= 0.5;\n    //uv = abs(uv)-(sin(iTime*0.5)*0.5+0.5)*0.5;\n    //uv = abs(uv);\n    //uv = fract(uv);\n    //uv.x += 0.5;\n    //c = fract(c);\n    //uv.x += iTime;\n    uv = vec2(log(c),atan(uv.x,uv.y));\n    //uv.x *= 0.1;\n    //uv.x *= 0.5;\n    //uv.x /= c;\n    uv.x -= sin(c+iTime*0.25);\n    //uv.x -= sin(uv.y*4.+iTime);\n    uv.x *= 0.5;\n    //uv.x *= 2.;\n    uv.x -= iTime;\n    //uv.x *= 0.5;\n    uv.x += 1.;\n    //uv = abs(uv)-0.5;\n    //uv *= r2d(iTime*0.1);\n    //uv.x  = abs(uv.x);\n    //uv.y *= 4./3.14;\n    float vt = uv.x;\n    //vt = c*20.;\n    //float sy = float(int(fract(uv.x*0.05)*4.+0.9));\n    float sy = floor(fract(uv.x*0.05)*4.+0.9);\n    //uv.x -= sin(uv.y+iTime)*0.2;\n    //sy = floor(fract(uv.x)*4.);\n    //uv.x /= 8.-sy;\n    //uv.x *= .0000001;\n    //uv *= 0.25;\n    uv.y *= sy/3.14;\n    vt += iTime*0.025;\n    float ux = uv.x;\n    //vt += iTime+uv.y*0.1;\n    //uv.y *= 4./3.14;\n   // vt *= c*0.001;\n    //uv.x -= iTime;\n    //float vt = uv.x;\n    uv = fract(uv)-0.5;\n    c = length(uv);\n    //uv = vec2(log(c),atan(uv.x,uv.y))*0.1;\n    //uv.x += iTime;\n    //uv.y *= 2.;\n    //uv.x += 1.5;\n    //uv.x += 0.5;\n    int steps = 8;\n    //float c = length(uv);\n    //uv -= 0.5;\n    //uv = abs(uv+0.5)-0.5;\n    //uv += 0.5;\n    int s2 = 6;\n    s2 = int(mod(ux*1.,18.));\n    for (int i=0;i<s2;i++) {\n        uv = abs(uv)-(sin(vt*0.5)*0.5+0.5)*0.5;\n        uv *= r2d(float(i)+vt);\n    }\n    //uv -= 0.5;\n    //uv += 0.5;\n    //float c = length(uv);\n    uv *= r2d(sin(c*8.*sin(vt*0.5)+vt*0.5));\n    for (int i=0;i<steps;i++) {\n        uv *= r2d(-vt*0.1);\n        col.r += line(uv+0.5,0.4,(sin(uv.x*04.91)*0.5+0.5)*0.01)*21.;\n    }\n    \n    //col.r -= 4.5;\n    //col.r = fract(col.r*0.01+iTime*0.1);\n    //col.r *= 0.01;\n    //col.r = sin(col.r+iTime*0.1);\n    col.bg = col.rr;\n    col.r *= 0.05;\n    col.r += ux*0.2;\n    //col.r -= iTime*4.;\n    col = vec3(sin(col.r),cos(col.r+0.2),cos(-col.r))*0.8;\n    //col = sin(col+uv.x);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 93], [95, 95, 135, 135, 226], [229, 229, 286, 336, 2706]], "test": "untested"}
{"id": "sdBSWc", "name": "Smoothstep Integral", "author": "iq", "description": "The integral of smoothstep is a useful way to smoothly ramping up a stationary object into constant motion. More info: [url]https://iquilezles.org/www/articles/smoothstepintegral/smoothstepintegral.htm[/url]", "tags": ["2d", "smoothstep", "integral", "butterfly"], "likes": 70, "viewed": 1356, "published": "Public API", "date": "1624252804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// The left butterfly implements a naive and wrong way to\n// transition a stationary object into constant motion. The\n// butterfly to the right implements the integral of the\n// smoothstep() function in order to smoohtly transition\n// between the two states.\n//\n// More information here:\n//\n// https://iquilezles.org/www/articles/smoothstepintegral/smoothstepintegral.htm\n\n\n\n// Incorrect EaseInOut/Smoothstep velocity\nfloat position_bad( float t, in float T )\n{\n    return smoothstep(0.0,T,t)*t;\n    //return (t<T) ? (t*t*t)/(T*T*T)*(3.0*T-2.0*t) : t;\n}\n\n// Correct integral of EaseInOut/Smoothstep\nfloat position_good( float t, in float T )\n{\n    if( t>=T ) return t - 0.5*T;\n    float f = t/T;\n    return f*f*f*(T-t*0.5);\n}\n\n\n// =======================================\n\nvec3 trackMin( in vec3 v, in float d )\n{\n         if( d<v.x ) v=vec3(d,v.x,v.y); \n    else if( d<v.y ) v=vec3(v.x,d,v.y);\n    else if( d<v.z ) v=vec3(v.x,v.y,d);\n    return v;\n}\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    p.y *= 0.9;\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    if( p.y<0.0 )\n    {\n        float f = 0.6 + 0.01*sin( 24.0*a );\n        float w = 1.1*a-0.8;\n        f *= sin(w)*sin(w);\n\n        float th = f + 0.001;\n        float th2 = th;\n        \n        vec3 wcol = mix( vec3(210,119,40)/255.0, \n                         vec3(232,79,12)/255.0, smoothstep( 0.0, 0.7, r ) );\n        wcol *= 1.5;\n\n        wcol *= 1.0+0.1*sin(17.0*p.x+vec3(0,0,4))*sin(23.0*p.y+vec3(0,0,4));\n\n        vec2 q = p;\n        q.xy += 0.02*sin(q.yx*12.0);\n        q.y = min(q.y,0.0);\n        vec3 v = vec3(10);\n        v = trackMin(v,length(q-vec2(0.29,-0.20)));\n        v = trackMin(v,length(q-vec2(0.10,-0.30)));\n        v = trackMin(v,length(q-vec2(0.20,-0.26)));\n        v = trackMin(v,length(q-vec2(0.28,-0.29)));\n        v = trackMin(v,length(q-vec2(0.34,-0.27)));\n        v = trackMin(v,length(q-vec2(0.38,-0.24)));\n        v = trackMin(v,length(q-vec2(0.39,-0.20)));\n        v = trackMin(v,length(q-vec2(0.38,-0.15)));\n        v = trackMin(v,length(q-vec2(0.35,-0.08)));\n\n        v.yz -= v.x;\n        float g = 1.25*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.01,g);\n        th -= 0.05*(1.0-smoothstep(0.0,0.05,g))-0.02;\n\n        wcol *= smoothstep(0.02,0.03,(th-r)*th);\n\n        q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        wcol = mix( wcol, vec3(1,1,1), 1.0-smoothstep( 0.0, 0.005,d) );\n        \n        wcol *= smoothstep(0.01,0.03,length(p-vec2(0.235,-0.2)));\n        \n        d = r-(th+th2)*0.5;\n        col = vec4(wcol,smoothstep( 0.0,2.0*fwidth(d),-d) );\n    }\n    \n    if( a<2.2 )\n    {\n        float f = 0.65 + 0.015*sin( 24.0*a );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n        float th2 = th;\n        th += 0.25*exp2( -50.0*(w-1.4)*(w-1.4) );\n            \n        vec3 wcol = mix( vec3(0.7,0.5,0.2), \n                         vec3(0.8,0.2,0.0), smoothstep( 0.0, 1.0, r ) );\n        wcol *= 1.4;\n        wcol *= 1.0+0.1*sin(13.0*p.x+vec3(0,0,4))*sin(19.0*p.y+vec3(0,0,4));\n\n        vec3 v = vec3(10);\n        v = trackMin(v,length(p-vec2(0.25,0.2)));\n        v = trackMin(v,length(p-vec2(0.35,0.0)));\n        v = trackMin(v,length(p-vec2(0.4,0.1)));\n        v = trackMin(v,length(p-vec2(0.45,0.2)));\n        v = trackMin(v,length(p-vec2(0.45,0.3)));\n\n        v.yz -= v.x;\n        float g = 2.0*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.02,g);\n        th2 -= 0.05*(1.0-smoothstep(0.0,0.05,g));\n\n        float isblack = smoothstep(0.02,0.03,(th2-r)*th2);\n\n        vec2 q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        float ww = 1.0-smoothstep( 0.0, 0.01,d);\n        \n        if( r>th2 )\n        {\n        vec2 q = fract(p*18.0)-0.5;\n        vec2 iq = floor(p*18.0);\n        float id= iq.x*111.0+iq.y*13.0;\n        q += 0.25*sin(id*vec2(15,17)+vec2(0,2));\n        float r = 1.0+0.75*sin(id*431.0);\n        ww = max( ww, 1.0-smoothstep(0.0,0.01,length(q)-0.2*r));\n        }\n        \n        wcol = mix( wcol, vec3(ww), 1.0-isblack );\n        \n        d = r-th;\n        \n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n\n#if HW_PERFORMANCE==0\nconst int AA = 2;\n#else\nconst int AA = 4;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stime = mod( iTime, 6.0 );\n    \n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        \n        p *= 1.6;\n        //p.y += 0.5;\n\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = stime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/30.0) - 0.5*0.5/30.0;\n        \n        time += 0.07*sin( p.y );\n        \n        float wing = (p.x<0.0)?position_bad(time, 2.0):\n                               position_good(time, 2.0);\n        \n        if( p.x>0.0 ) p.x=p.x-1.4;\n        else          p.x=p.x+1.4;\n\n       \n        float an = 1.55*(0.5-0.5*cos(2.0*6.283185*wing));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        vec3 ro = vec3(0.0,0.085,2.1);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        vec4 tmp = butterfly( q );\n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n        \n        \n        col += mix( vec3(0.5), tmp.xyz, tmp.w );\n    }\n    col /= float(AA*AA);\n\n    vec2 q = fragCoord/iResolution.xy;\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSWc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1455, 1498, 1541, 1541, 1633], [1635, 1679, 1723, 1723, 1805], [1808, 1852, 1892, 1892, 2029], [2031, 2031, 2060, 2060, 5437], [5439, 5439, 5460, 5460, 5558], [5632, 5632, 5689, 5689, 7133]], "test": "untested"}
{"id": "sdS3zV", "name": "- change of basis -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sdf", "sphere"], "likes": 3, "viewed": 126, "published": "Public API", "date": "1624387057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define MAX_DIST 20.\n\nvec3 rotateY(vec3 pos, float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c) * pos;\n}\n\nvec3 changeOfBasis(vec3 pos, vec3 origin){\n    vec3 zAxis = -origin;\n    vec3 xAxis = normalize(rotateY(vec3(origin.x, 0, origin.z), 3.14 / 2.));\n    vec3 yAxis = cross(xAxis, zAxis);\n\t\n    return transpose(mat3(xAxis, yAxis, zAxis)) * pos;\n}\n\nfloat sdBox(vec3 pos) {\n    vec3 d = abs(pos) - 0.8;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdSphere(vec3 pos) {\n\treturn length(pos) - 1.;   \n}\n\nvec3 calcBoxPos() {\n    float y = 1. - 4. * abs(round(iTime / 12.) - iTime / 12.);\n    vec3 origin = vec3(sin(iTime / 0.3), y, cos(iTime / 0.3));\n    origin.xz *= cos(y * 3.14 / 2.);\n    return origin;\n}\n\nfloat calcDist(vec3 pos) {\n    vec3 origin = calcBoxPos();\n \t\n    float dBox = sdBox(changeOfBasis(1.5 * (pos + 3. * -origin), origin)) / 2. - 0.05;\n    float dSphere = sdSphere(0.35 * pos);\n\n    float morphK = 4.;\n    return -log(exp(-morphK * dSphere) + exp(-morphK * dBox)) / morphK;\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 100; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    \n    return distFromO;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos);\n\treturn normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(pos - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(pos - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    vec3 specular = vec3(0.15 * pow(max(dot(-camDir, reflect(-lightDir, normal)), 0.), 16.));\n    \n    return lightCol * (ambient + diffuse + specular);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col = vec3(0.7, 0.6, 0.6);\n    \n    if (dist < MAX_DIST) { \n        col = calcLight(camPos + dist * camDir, \n                        vec3(5, 0, -15), \n                        vec3(0.9, 0.6, 0.6), \n                        camDir);\n    } \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv.yx;\n    col *=  vec3(pow(uv.x * uv.y * 15., 0.1)); \n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 73, 73, 207], [209, 209, 251, 251, 451], [453, 453, 476, 476, 572], [574, 574, 600, 600, 631], [633, 633, 652, 652, 836], [838, 838, 864, 864, 1126], [1128, 1128, 1166, 1166, 1392], [1394, 1394, 1421, 1421, 1615], [1617, 1617, 1690, 1690, 2029], [2031, 2031, 2086, 2086, 2709]], "test": "untested"}
{"id": "sdSXRK", "name": "Perfect Border Voronoi", "author": "RiceFields", "description": "Voronoi", "tags": ["voronoi"], "likes": 4, "viewed": 128, "published": "Public", "date": "1625029507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ref: https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = 10.0f/iResolution.y; // pixel width for smoothstep edge \n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n\nfloat fill(float f, float size) {\n    return 1.-aastep(size, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 10.0f;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    // miniunm distance feature point\n    vec2 mNeighbour; // feature point cell\n    vec2 mDiff; // vector from current point to feature point\n    float mDist = 2.0f;\n    \n    // first find the least distant feature point\n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            // animate\n            point = 0.5f + 0.5f*sin(iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist) {\n                mDiff = diff;\n                mNeighbour = neighbour;\n                mDist = dist;\n            }\n        }\n    }\n    \n    mDist = 2.0f;\n    // second, neighbour search centered at cell contaiting least distant feature point\n    for(int j=-2; j<=2; ++j) { \n        for(int i=-2; i<=2; ++i) {\n            // 5x5\n            \n            vec2 neighbour = mNeighbour + vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            // animate\n            point = 0.5f + 0.5f*sin(iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n            \n            float dist = dot(0.5f*(mDiff+diff), normalize(diff-mDiff)); // distance with projection\n    \n            mDist = min(mDist, dist);\n        }\n    }\n    \n    \n   vec3 col = vec3(fill(mDist, 0.02f)); \n\n   fragColor = vec4(1.0f - col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 103, 103, 196], [198, 198, 242, 242, 389], [392, 392, 425, 425, 458], [460, 460, 517, 517, 2169]], "test": "untested"}
{"id": "sdsXWf", "name": "Ukiyo-e Japanese Woodblock Print", "author": "ircss", "description": "A ukiyo a inspired shader. Inspired by a Shin hanga Kawase Hasui piece known as Road to Arayu, Shiobara. You can find the original here https://artsandculture.google.com/asset/road-to-arayu-shiobara-artist-kawase-hasui-publisher-s-watanabe-color-print-co/", "tags": ["2d", "landscape", "painting", "japanese", "reproduction", "ukiyoe"], "likes": 42, "viewed": 524, "published": "Public API", "date": "1622628736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sky_upper        vec3(0.76,  0.74,  0.64)\n#define sky_lower        vec3(0.81,  0.68,  0.53)\n#define mountain_color   vec3(0.25,  0.35,  0.45)\n#define mountain_outline vec3(0.24,  0.28,  0.31)*0.9\n#define hill_upper       vec3(0.71,0.53,0.26)\n#define hill_lower       vec3(0.71,0.53,0.26)\n#define hill_natural     vec3(0.77,0.61,0.37)\n#define hill_outline     vec3(0.57,0.37,0.14)\n#define cloud_upper      vec3(0.85,  0.79,  0.69)\n#define cloud_lower      vec3(0.72,  0.7,   0.63)\n#define cloud_outline    vec3(0.64,  0.6,   0.48) * 0.9\n#define border_color     vec3(0.250, 0.250, 0.250)\n#define bush_color_far   vec3(0.63,0.35,0.16)\n#define bush_color_far2  vec3(0.51,0.25,0.14)\n#define d_tree_outline   vec3(0.42,0.17,0.05)\n#define tree_close_trunk vec3(0.39,0.3,0.15)\n#define tree_leaves      vec3(0.56,0.26,0.11)\n#define tree_leaves2     vec3(0.61,0.4,0.22)\n#define leaves_outline   vec3(0.35,0.22,0.09)\n#define paper_color      vec3(0.84,0.79,0.66)\n#define paper_outline    vec3(0.61,0.58,0.47)\n#define paper_col_dark   vec3(0.78,0.72,0.6)\n\n#define TAU  6.28318530718\n#define PI   3.14159265359\n\n// -----------------------------------------------\n// From https://www.shadertoy.com/view/XdXGW8\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)b\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat rand(float seed) \n{\n  return fract(sin(mod(seed,1000.) *52.02) * 7632.2);\n}\n\nfloat rand2D(vec2 seed) \n{\n  return fract(sin(dot(mod(seed, vec2(1000.)), vec2(18.612, 52.624)) *52.02) * 842.2);\n}\n\n// From https://github.com/glslify/glsl-aastep/blob/master/index.glsl\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\nfloat tWave(float x, float amplitude, float frequency){\n      return abs((fract(x*frequency) *2.)-1.) * amplitude;   \n}\n\n\nfloat distanceWithAspectRatio(vec2 v1, vec2 v2, float aspectRatio)\n{\n   vec2 t = v2 - v1; \n   return sqrt(t.x* t.x*(aspectRatio*aspectRatio)  + t.y *t.y);\n}\n\nvoid DrawWithOutline(inout vec3 col, vec3 paintCol, vec3 outlineCol, float threshold, float value, float thickness)\n{\n       vec3 maskCol = mix(outlineCol, paintCol, aaStep(thickness, threshold - value));\n       col = mix(maskCol, col, aaStep(threshold, value));\n}\n\n\nfloat distanceOnNormalizedAngle(float angle, float refPoin)\n{\n  \n  float d =abs( angle - refPoin);\n  if(d> 0.5) d = 1. - d;\n  return d;\n}\n\n\nvoid DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n    \n    vec2 vector = end - origin;\n          uv  -= origin;\n    float len  = length(vector);\n       vector /= len;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(aaStep(size, d), 0. ,1.)); \n}\n\n// -----------------------------------------------\n\nvoid PaintSky(inout vec3 col, in vec2 uv)\n{\n\n   \n    col = mix( sky_lower, sky_upper, smoothstep(0.5, 0.70, uv.y));\n    col = mix(col, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n}\n\n\nfloat cloudsHeightFunction(float coord_x, float baseamplitude, float baseFrequency, float height, vec2 coord_i, float distanceToEdge)\n{\n\n   float upperPart = rand2D(coord_i + vec2(51.2, 82.58))*0.15;\n   \n   float upOrDown = step(0.,height);\n   \n   for(float f = 1.; f <6.0; f++)\n     {\n       upperPart += abs(sin(coord_x * baseFrequency * f + rand2D(coord_i + \n       vec2(f*51.2 +72.124, f*82.58+ 93.125))\n       + iTime*0.2)) * baseamplitude/f;\n     };\n     \n     float lowerPart = 0.0f;\n     \n      for(float f = 1.; f <4.0; f++)\n     {\n       lowerPart += abs(sin(coord_x * baseFrequency * f*0.5 + \n       rand2D(coord_i+ vec2(f*12.8231+53.838, f*62.61+ 12.09)))) * baseamplitude * 0.5/f;\n     };\n     \n     return mix(upperPart, lowerPart, mix(upOrDown, 1.,  1.-distanceToEdge));\n}\nvoid PaintMountain(inout vec3 col, in vec2 uv)\n{\n\n\n    float fogHeight = sin(uv.x*2.) *0.1;\n\n\n\n     float f  = 0.40;\n     float baseAmplitude = 0.12;\n     float baseFrequency = 1.;\n     \n     f += fogHeight;\n     \n     \n     for(float i = 1.; i<10. ; i++)\n     {\n        f += tWave(uv.x + rand(i), baseAmplitude / i,  baseFrequency * i);\n     }\n     \n     fogHeight += tWave(uv.x + 21.521, 0.1,  0.4);\n     \n    vec3 mountainAndFog = mix(mountain_color, sky_lower, smoothstep(0.1, 0.3 , fogHeight *0.5 + 0.6  - uv.y) ); \n     \n     \n     \n     \n     \n     float fracUV_y = uv.y;\n     \n     fracUV_y-= f;\n  \n     float uv_i_y = floor(fracUV_y *12.);\n     fracUV_y = fract(fracUV_y *12.);\n  \n     \n     float outline = aaStep(0.02 , \n                            abs(fracUV_y - 0.5 + sin(uv.x*20.) * 0.5)) - \n                            abs(sin(uv.x*8. + rand(uv_i_y*10.)*6.4)) *0.008 \n                      + abs(sin(uv.x *10. + rand((uv_i_y +24.12)*10.)*6.4)) ;\n           outline = clamp(outline, 0. , 1.);\n    \n        mountainAndFog = mix(mountain_outline, mountainAndFog, outline);\n        mountainAndFog = mix(mountainAndFog, paper_color ,  pow(texture(iChannel0,uv*5.).x,6.));\n        \n        DrawWithOutline(col, mountainAndFog, mountain_outline, f, uv.y, 0.004 + abs(sin(uv.x*5.)) *0.004);\n     \n}\n\nvoid DetermineHillHeights(inout vec3 col, in vec2 uv, out float hillHeight)\n{\n    hillHeight =   (sin(uv.x*7. +2.5) *0.5 + 0.5) *0.05  + 0.4 +\n          + sin(uv.x*3. + 2.3) *0.06+ (sin(uv.x*88.+ 7.) ) * 0.0025  + sin(uv.x*30. + 3.3 ) *0.01;\n}\n\nvoid PaintHills(inout vec3 col, in vec2 uv, in float hillHeight)\n{\n    vec3 hillWithGradient = mix(hill_upper, hill_lower, smoothstep(0.1, 0.5, sin(uv.x*8.) *0.05 + 0.3 - uv.y) ); \n\n\n    float innerLinesWave = (abs(sin(uv.x*2.) + 0.05))*( 1.-min(1., (hillHeight - uv.y)))* 0.25;\n    \n    vec2 coord   = uv - vec2(0., hillHeight + innerLinesWave); \n    vec2 coord_f = fract(coord* vec2(2., 10.) );\n    vec2 coord_i = floor(coord* vec2(2., 10.) );\n    \n    float sinWaveOne =  sin(uv.x* 13. + rand(coord_i.y*252.125 + 521.2)*612.21);\n    float outline = aaStep(0.0, \n    abs(coord_f.y - 0.5 +sinWaveOne*0.2) - 0.0025\n    + sin(uv.x* 15. + rand(coord_i.y*252.125)*612.21)*0.015 );\n    \n           \n           \n           \n     mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n     vec2 noiseUV = (coord +vec2(0., sinWaveOne)*0.03 ) * vec2(69., 80.);\n    float noisef  = noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.5*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.25*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.125*noise(noiseUV);\n          noisef += noise(coord * 5.);\n    float texturefactor = clamp(abs(noisef),0., 1.);\n    \n    hillWithGradient = mix(hillWithGradient, hill_natural, texturefactor);\n    \n    hillWithGradient = mix(hill_outline ,hillWithGradient,outline);\n    \n    hillWithGradient = mix(hillWithGradient, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    \n    DrawWithOutline(col, hillWithGradient, hill_outline, 0.001,uv.y -hillHeight , 0.0025 + abs(sin(uv.x*5.)) *0.003);\n    \n}\n\nvoid PaintHClouds(inout vec3 col, in vec2 uv, float aspectRatio)\n{\n    vec2 uv_cloud_i = floor(uv * vec2(2., 8.)) ;\n    vec2 uv_cloud_f = fract(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n    vec2 uv_cloud_r = floor(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n     aspectRatio =  4./aspectRatio  ;\n    \n    vec2 center      = vec2(rand2D(uv_cloud_r + vec2(21.51,73.)), rand2D(uv_cloud_r + vec2(2., 51.51)));\n         center.x    = center.x *2. - 1.;\n         center      = vec2(0.5, 0.25) + center *vec2(0.3, 0.0); \n         \n         \n         // Determine cloud starting and ending point\n   float leftPoint   = 0.1       + (center.x - 0.1)  * rand2D(uv_cloud_r *vec2(572.21, 72.823) + vec2(94.1, 46.87));\n   float rightPoint  = center.x  + (0.9 - center.x ) * rand2D(uv_cloud_r *vec2(55.93, 287.23) + vec2(2.215,912.2));\n         \n   float endsAsdots  =  aaStep(0.02, min(distanceWithAspectRatio(vec2(leftPoint, center.y),uv_cloud_f, aspectRatio),\n                 distanceWithAspectRatio(vec2(rightPoint, center.y),uv_cloud_f, aspectRatio)));\n\n         // Determining the projection of the current pixel on the line between left and right points\n         \n    float projectionPos = min(max(leftPoint, uv_cloud_f.x), rightPoint);\n    float distanceToEdge =  min(uv_cloud_f.x - leftPoint , rightPoint - uv_cloud_f.x); \n\n\n    float distanceToLine  = distanceWithAspectRatio(vec2(projectionPos, center.y), uv_cloud_f,aspectRatio )*0.5;\n          distanceToLine -= cloudsHeightFunction(uv_cloud_f.x, 0.1, 10., \n          center.y - uv_cloud_f.y, uv_cloud_r* vec2(51.251, 72.21), smoothstep(0., 0.01, distanceToEdge)) \n          * smoothstep(-0.05, 0.05, distanceToEdge);\n\n    float maskCoord  = distanceToLine ;\n    float threshold  = 0.01;\n          threshold -= step(7., uv_cloud_i.y);\n          threshold -= step(0.5, rand2D(uv_cloud_r));\n          \n    vec3  cloudColGrad =mix(cloud_lower, cloud_upper, uv_cloud_f.y) ;\n        cloudColGrad = mix(cloudColGrad, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    DrawWithOutline(col, cloudColGrad, cloud_outline, threshold, maskCoord, 0.004 + abs(sin(uv.x*12.)) *0.01);\n    \n}\n\nfloat GetFarTreeDisplacement(float Domain, float baseFrequency, float baseAmplitude, float seed)\n{\n  float d = 0.0;\n  \n\n\n        d += (sin((Domain + rand(seed*25.521 + 0.0)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.2;\n        \n        d += (sin((Domain + rand(seed*25.521 + 61.21)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.5;\n        \n        d += (sin((Domain + rand(seed*25.521 + 21.6231)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.5;\n        baseFrequency *= 3.5;\n        \n        d += (sin((Domain + rand(seed*12.521 + 93.8236)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        d += (sin((Domain + rand(seed*12.521 + 62.8787)) *120. ) *0.5 + 0.5)* 0.05; \n        \n  return d;\n}\n\n\nvoid PaintDistanceTrees(inout vec3 col, in vec2 uv, in float terrainHeight, float seed, float aspectRatio)\n{\n   vec2 uv_bush_i = floor(uv * vec2(15., 1.));\n   vec2 uv_bush_f = fract(uv * vec2(15., 1.));\n        uv_bush_f.y = uv_bush_f.y - terrainHeight;\n        uv_bush_f.y *= 15. * aspectRatio;\n  \n   float threshold = 0.3;\n   float shoulDraw = step(0.4, rand(uv_bush_i.x +1. + seed));\n         threshold-=  shoulDraw;\n         \n         float treeCenterY = (rand((uv_bush_i.x+seed)*65.)*2.0-1.0) * 0.4;\n         \n         vec2 toTreeCenter = vec2(0.5, treeCenterY) - uv_bush_f;\n         \n         float randOne = rand(seed*251.221 + uv_bush_i.x*2.521);\n   float f         = length(toTreeCenter);\n   float angle     = fract(atan(toTreeCenter.y, toTreeCenter.x) / TAU + 0.5 + 0.25);\n   float dis       = GetFarTreeDisplacement(angle, \n                     6.+randOne*10.,\n                     0.2,  seed + uv_bush_i.x);\n         f        -= dis * distanceOnNormalizedAngle(angle, 0.);\n   \n   float sinOne = sin((uv_bush_f.x + seed *82.12+ uv_bush_i.x*10.67) *35.);\n   float colorFactor = abs(noise(uv_bush_f*2.\n   + vec2(0., sinOne*0.1 )));\n   \n   colorFactor +=  smoothstep(treeCenterY+0.1, treeCenterY-0.3, uv_bush_f.y  + sinOne*0.01);\n   \n  vec3 bushColor  = mix( bush_color_far, bush_color_far2, colorFactor);\n  \n    // Draw trunk\n    \n    float thickness = abs(sin(angle*12. + seed*6.21 + uv_bush_i.x*5.214 + uv.y*30.));\n    \n    DrawBetweenTwoPoints(vec2(0.5, treeCenterY), vec2(0.5, treeCenterY-0.5),\n    uv_bush_f + vec2(0., 0.), 0.005 - shoulDraw + thickness*0.03 , mix(d_tree_outline, bush_color_far, 0.25), col);\n    \n    // Draw inner leaves\n    \n    \n    float coord_leaves =  distance(uv_bush_f, vec2(0.5, treeCenterY-0.5))*5.;\n    float coord_l_i    = floor(coord_leaves);\n          coord_leaves = fract(coord_leaves);\n    float sinTwo   = sin(uv_bush_f.x *82. + randOne *65.61+ coord_l_i*82.21);\n    float sinThree = sin(uv_bush_f.x *10. + randOne *65.61+ coord_l_i*52.21);\n          coord_leaves = abs(coord_leaves - 0.5 + sinTwo*0.05+ sinThree*0.4);\n          coord_leaves = aaStep(-0.031, coord_leaves  + sinThree*0.1);\n    bushColor = mix(bush_color_far2,bushColor, coord_leaves);\n    \n      bushColor = mix(bushColor, paper_color ,  pow(texture(iChannel0,uv*3.).x,6.));\n    \n   DrawWithOutline(col, bushColor, d_tree_outline, threshold, f,\n   0.008 + thickness*0.01);\n   \n   \n   \n}\n\n\n\nvec4 LineSegCoord(vec2 p1, vec2 p2, vec2 uv, out float segmentLength){\n    \n\n    vec2 vector = p2 - p1;                         // Find the vector between the two lines\n          uv   -= p1;                              // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = max(length(vector), 0.01);                  // Find the ditance between the two points\n       vector  /= len;                             // normalize the vector \n    float vUv   = dot(vector, uv);                 // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ;    // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);                  // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    segmentLength = len;\n    \n                                                   // fourth component is used for drawing the branch thickness, is a noramlized value stating how far the pixel is between p1 nad p2\n    return vec4(vUv, d, signedD, clamp(vUv, 0.,len)/ len); \n}\n\nfloat determineBranchThickness(float size, vec4 branchCoord)\n{\n    size = mix(size, max(size, 0.8),  branchCoord.w);\n    return mix(0.05, 0., size);\n}\n\n\n\n\nfloat GetBranchDisplacement(vec2 uv, float seed)\n{\n  float d  =  (sin((uv.x + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d  =  (sin((uv.y + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d +=  (sin((uv.x + rand(seed*12.57 + 2.6123)) *15. ) *0.5 + 0.5)* 0.08;\n        d +=  (sin((uv.y + rand(seed*68.2146 + 5.84746)) *40. ) *0.5 + 0.5)* 0.025;\n        d +=  (sin((uv.y + rand(seed*90.572 + 73.232)) *60. ) *0.5 + 0.5)* 0.03;\n        return abs(d);\n}\n\nfloat GetLeaveShapes(vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, out float randLeaveSpace)\n{\n   \n  vec2 leaveCoord_f = fract(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  vec2 leaveCoord_i = floor(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  \n  float leaveIsOnBranch = step( segmentLength, (leaveCoord_i.x +0.5)/4.);\n        leaveIsOnBranch += step((leaveCoord_i.x +0.5)/4., 0.);\n  \n  randLeaveSpace =  rand(seed + rand2D(leaveCoord_i + vec2(51.61,87.21)));\n  \n  float laeveShape = abs(leaveCoord_f.x - 0.5);\n        laeveShape = leaveIsOnBranch+ treeShouldExist\n        + laeveShape - mix(0., mix(0.2,0.25 + abs(sin(2.35* branchCoord.x/TAU\n        + rand(randLeaveSpace+2.731 + sign(branchCoord.y)*20.0231)))*0.2, randLeaveSpace),  \n        abs(sin(PI*clamp(branchCoord.z/mix(0.2, 0.35, rand(randLeaveSpace+52.731)), -1.,1.))));\n\n\n     \n  return laeveShape;  \n}\n\nvoid DrawLeaves(inout vec3 col, vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, vec2 uv)\n{\n     float randLeaveSpace;\n\n   branchCoord.x += sin(branchCoord.z*5. + rand(seed) * 6.12)*0.05;\n\n   float leaveShape = GetLeaveShapes(branchCoord, segmentLength, treeShouldExist, seed , randLeaveSpace);\n   \n   float noiseMask = pow(texture(iChannel0,uv*3.).x,5.);\n   vec3 leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   float leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   branchCoord.x += /*sin(branchCoord.z*5. + rand(seed+62.721) * 6.12 )*0.05 + */\n                    sin(branchCoord.x*5. + rand(seed+62.721) * 6.12 )*0.05  ;\n   leaveShape = GetLeaveShapes(branchCoord + vec4(0.15,0.,0.,0.), segmentLength, treeShouldExist, seed +62.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n    leaveShape = GetLeaveShapes(branchCoord + vec4(-0.1521,0.,0.,0.), segmentLength, treeShouldExist, seed +9.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   \n   leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n     leaveShape = GetLeaveShapes(branchCoord + vec4(0.1,0.,0.,0.), segmentLength, treeShouldExist, seed -24.173, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n\n \n}\n\n#define trunkBorder 0.25\n#define branchStartRange 0.7\n#define treeEndPad 0.2\nvoid PaintCloseUpTrees(inout vec3 col, vec2 uv, float seed)\n{\n\n\n  uv.x += sin(uv.y*10. + uv.x + seed)*0.02 + sin(uv.y*20. + uv.x + seed)*0.01;\n\n  vec2 uv_trunk_i = floor(uv * vec2(10., 7.));\n  vec2 uv_trunk_f = fract(uv * vec2(10., 7.));\n  \n  float range_x_dis = 1. - trunkBorder*2.;\n  \n  vec2 p0 = vec2( rand2D(uv_trunk_i)                * range_x_dis + trunkBorder, 0.);\n  vec2 p1 = vec2( rand2D(uv_trunk_i + vec2(0., 1.)) * range_x_dis + trunkBorder, 1.);\n  \n  \n  vec2 p0To1  = normalize(p1 - p0);\n  vec2 p0Touv = uv_trunk_f - p0;\n  \n  float dot_x   = dot(p0Touv, p0To1);\n  float error_y = distance(uv_trunk_f- p0,  dot_x * p0To1);\n  \n\n  float treeShouldExist  = step(.15,rand(uv_trunk_i.x +52.12 + seed*5.213)) ;\n  float trunkHeight      = rand(uv_trunk_i.x)*4.0;\n        treeShouldExist  = max(treeShouldExist, step(trunkHeight, uv_trunk_i.y));\n  float thicknessControl = min(1., (uv_trunk_i.y + uv_trunk_f.y)/ trunkHeight); \n  \n  \n  // --- branches\n  // - left  \n  float cellRandOne = rand2D(uv_trunk_i + vec2(5.21 + seed, 1.2541 + seed));\n  float branchLeftStartf   =  cellRandOne\n                             * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchLeftStartv   = p0 + p0To1 * branchLeftStartf;\n  vec2  branchLeftEndv     = vec2(treeEndPad + rand2D(uv_trunk_i + vec2(2.712,  16.41)) * (branchLeftStartv.x - treeEndPad), \n                                  rand2D(uv_trunk_i + vec2(93.221 + seed, 22.83 + seed))\n                                  * (1. - branchLeftStartv.y - treeEndPad) +  branchLeftStartv.y );  \n \n  float branchThickStart   = min(1., (uv_trunk_i.y + branchLeftStartv.y)/ trunkHeight); \n  \n  \n  float segmentLength = 0.0;\n  vec4 branchCoord = LineSegCoord(branchLeftStartv, branchLeftEndv, uv_trunk_f, segmentLength);\n  \n\n float  branch = aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n \n  \n   float randLeaveSpace;\n   DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n \n  // - right \n  \n  float branchRightStartf   = rand2D(uv_trunk_i + vec2(251.24, 7.1281)) \n  * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchRightStartv   = p0 + p0To1 * branchRightStartf;\n  vec2  branchRightEndv     = vec2(rand2D(uv_trunk_i + vec2(71.22,  96.12)) * (1. - branchRightStartv.x - treeEndPad) +  branchRightStartv.x , \n                                   rand2D(uv_trunk_i + vec2(0.21, 83.16)) * (1. - branchRightStartv.y - treeEndPad) +  branchRightStartv.y);  \n  \n        branchThickStart    = min(1., (uv_trunk_i.y + branchRightStartv.y)/ trunkHeight); \n\n     \n     \n     branchCoord = LineSegCoord(branchRightStartv, branchRightEndv, uv_trunk_f, segmentLength);\n     \n        branch *= aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n       DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n      vec3 trunkCol = mix(tree_close_trunk, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n  col = mix(trunkCol, col, max(aaStep(0., error_y - mix(0.05, 0., thicknessControl))* branch,treeShouldExist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n         uv.y = 1.5 * uv.y  - 0.25;\n    vec3 col = vec3(0., 0., 0.);\n    uv.x += iTime*0.01;\n\n\n    float aspectRation = (iResolution.y / 1.5)/ iResolution.x;\n    PaintSky(col, uv);\n \n    PaintHClouds(col, uv, aspectRation);\n      uv.x += iTime*0.0065;\n      \n    PaintHClouds(col, uv * vec2(1., 0.8)+ vec2(7.213, 0.05 ), aspectRation);\n            uv.x += iTime*0.015;\n    PaintMountain(col, uv );\n    uv.x += iTime*0.1;\n    float hillHeights;\n    DetermineHillHeights(col, uv, hillHeights);\n    PaintDistanceTrees(col, uv*1.1, hillHeights+0.05, 0., aspectRation);\n    PaintHills(col, uv, hillHeights);\n    PaintDistanceTrees(col, (uv * 0.9) + vec2(5.2134, 0.), hillHeights-0.05, 51.613, aspectRation);\n    \n     uv.x += iTime*0.1;\n    \n    PaintCloseUpTrees(col, uv , -24.0);\n    \n     uv.x += iTime*0.1;\n    PaintCloseUpTrees(col, uv *0.95+ vec2(25.421, 0.05), 58.612);\n    \n    vec2 uvUnchanged = fragCoord/iResolution.xy;\n         uvUnchanged.x *= iResolution.x/iResolution.y;\n    \n     \n    vec2 shaderToyBorder      = vec2(0.0, 0.120 );\n    vec2 paperBorderThickness = vec2(0.045, 0.045);\n    float outlineThickness = 0.003 + abs(sin(uvUnchanged.x*5. +2.612) *0.1 + sin(uvUnchanged.y*5.)*0.1)*0.015;\n    \n    \n    vec3 outlineColor =  mix(paper_outline, paper_color ,  pow(texture(iChannel0,uvUnchanged*3.).x,3.));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.y + paperBorderThickness.y + outlineThickness, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y + outlineThickness), uvUnchanged.y)));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.x + paperBorderThickness.x + outlineThickness, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x + outlineThickness), uvUnchanged.x)));\n    \n    \n    vec3 pape = mix(paper_color, paper_col_dark ,  pow(texture(iChannel0,uvUnchanged*2.).x,2.)); \n    \n    \n    col = mix(pape , col,  step(shaderToyBorder.y + paperBorderThickness.y, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y), uvUnchanged.y)));\n    \n    col = mix(pape , col,  step(shaderToyBorder.x + paperBorderThickness.x, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x), uvUnchanged.x)));\n    \n    \n    \n    \n    \n    col = mix(border_color , col,  step(shaderToyBorder.x, uvUnchanged.x) \n    * (1.- step((iResolution.x/iResolution.y)- shaderToyBorder.x, uvUnchanged.x)));\n    \n    col = mix(border_color , col,  step(shaderToyBorder.y, uvUnchanged.y) \n    * (1.- step(1.-shaderToyBorder.y, uvUnchanged.y)));\n\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1108, 1206, 1283, 1338, 1818], [1820, 1820, 1846, 1846, 2287], [2290, 2290, 2315, 2315, 2371], [2373, 2373, 2399, 2399, 2488], [2490, 2560, 2600, 2600, 2757], [2759, 2759, 2814, 2814, 2878], [2881, 2881, 2949, 2949, 3037], [3039, 3039, 3156, 3156, 3303], [3306, 3306, 3367, 3367, 3443], [3446, 3446, 3555, 3555, 3914], [3916, 3968, 4011, 4011, 4156], [4159, 4159, 4294, 4294, 4946], [4947, 4947, 4995, 4995, 6252], [6254, 6254, 6331, 6331, 6497], [6499, 6499, 6565, 6565, 8038], [8040, 8040, 8106, 8106, 10207], [10209, 10209, 10307, 10307, 11059], [11062, 11062, 11170, 11170, 13464], [13468, 13468, 13538, 13538, 15559], [15561, 15561, 15623, 15623, 15711], [15716, 15716, 15766, 15766, 16192], [16194, 16194, 16316, 16316, 17131], [17133, 17133, 17249, 17249, 19303], [19382, 19382, 19443, 19443, 22518], [22521, 22521, 22578, 22628, 25395]], "test": "untested"}
{"id": "sl23DV", "name": "Random sunday fractal", "author": "mrange", "description": "License CC0: Random sunday fractal\nResult after a bit of random coding on sunday\n", "tags": ["2d", "fractal"], "likes": 10, "viewed": 179, "published": "Public API", "date": "1624790667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Random sunday fractal\n// Result after a bit of random coding on sunday\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define DOT2(x)         dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat g_cd = 0.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat boxf(vec3 p, vec3 b, float e) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat df(vec3 p) {\n  float d = 1E6;\n  vec3 op = p;\n\n  const float zf = 2.0-0.1;\n  const vec3 nz = normalize(vec3(1.0, .0, -1.0));\n  const vec3 ny = normalize(vec3(1.0, -1., 0.0));\n  float z = 1.0;\n  const float rsm = 0.125*0.25;\n  float a = 124.7+TIME*TAU/173.0; \n  mat2 rxy = ROT(a);\n  mat2 ryz = ROT(a*sqrt(0.5));\n  \n  float off = 0.8; \n  vec3 cp = vec3(0.55, 0.5, 0.45);\n  float cd = 1E6;\n\n  const int mid   = 0; \n  const int upper = 7; \n  for (int i = 0; i < mid; ++i) {\n    cd = min(cd, length(p-cp));\n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(off/zf, 0.0, 0.0);\n  }\n\n\n  for (int i = mid; i < upper; ++i) {\n    cd = min(cd, length(p-cp));\n    vec3 pp = p;\n    float dd4 = torus(pp.zxy, 0.5*vec2(1.0, 0.2));\n    float dd5 = boxf(pp, vec3(0.2), 0.00)-0.025;\n    float dd  = dd5;\n    dd = min(dd5, dd4);\n    dd  /= z;\n    \n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(off/zf, 0.0, 0.0);\n    d = pmax(d, -(dd-0.1/z), 0.05/z);\n    \n    d = min(d, dd);\n  }\n\n  g_cd = cd;\n  return d;\n}\n\nfloat df(vec2 p) {\n  vec3 p3 = vec3(p, mix(0.0, 1.0, PCOS(TAU*TIME/331.0)));\n  p3.xz *= ROT(TAU*TIME/127.0);\n  p3.yz *= ROT(TAU*TIME/231.0);\n  const float z = 0.25;\n  p3 *= z;\n  return df(p3)/z;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float aa = 0.0125;\n  return -0.025*smoothstep(-aa, aa, -d);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = hf(p + e.yx) - hf(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = hf(p);\n  float cd   = g_cd;\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, mix(-3.0, -10.0, PCOS(TIME+PI*p.x)), 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 lcol1 = sqrt(vec3(1.25, 1.35, 2.0).zxy*0.15);\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;\n  vec3 lpow1 = 0.15*lcol1/DOT2(ld1);\n  vec3 lpow2 = 0.25*lcol2/DOT2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*50.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 40.0)*lcol1;\n  col += rm*pow(ref2, 40.0)*lcol2;\n  \n  float hue  = fract(0.85-0.5*PI*cd);\n  float sat  = clamp(0.85*PCOS(10.0*cd), 0.0, 1.0);\n  float vue  = 1.0-1.0*PCOS(8.0*cd);\n  vec3 hsv   = vec3(hue, sat, vue);\n  vec3 color = (1.0*hsv2rgb(hsv));\n\n  return p.x > 0.0 ? color : col ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl23DV.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 422, 450, 470, 546], [548, 601, 623, 623, 792], [794, 794, 830, 830, 1063], [1065, 1065, 1092, 1092, 1179], [1181, 1181, 1212, 1212, 1277], [1280, 1280, 1317, 1317, 1599], [1601, 1601, 1640, 1640, 1729], [1731, 1731, 1770, 1770, 1799], [1801, 1801, 1837, 1837, 1925], [1927, 1927, 1955, 1955, 1983], [1985, 1985, 2003, 2003, 3253], [3255, 3255, 3273, 3273, 3451], [3453, 3453, 3471, 3471, 3554], [3556, 3556, 3577, 3577, 3767], [3769, 3769, 3797, 3797, 5197], [5199, 5199, 5254, 5254, 5441]], "test": "untested"}
{"id": "sl2GRc", "name": "Raytracer - Reflections", "author": "SpinningCube", "description": "Added reflections to the raytracer base. Removed fog because it was broken. Also added metals.", "tags": ["raytracing", "reflection", "bounce", "fresnel"], "likes": 12, "viewed": 216, "published": "Public API", "date": "1624499475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 850.;\nconst float pi = 3.141592653589793;\nconst int bounces = 5;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nint surfType; /* 0=dielectric 1=metallic */\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.3, 0.4, 0.7);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic */) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n            surfType = type;\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 18), 1.), vec3(0.4,.2, 0.01), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.05,0.1, 0.6), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-5, 5, 90), 6.), vec3(0.35,0.35, 1.), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.7,0.05, 0.05), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(15, 3, 80), 4.), vec3(.85,0.8, 0.05), .1, 1);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 3, 60), 4.), vec3(.02,0.3, 0.07), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 1, 55), 2.), vec3(.7,0.7, 0.1), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 2, 50), 3.), vec3(.03,0.05, 0.3), .1, 0);\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), .1, 0);\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 2.5, surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    /*\n    float fog = clamp(length(ray - rayOrigin)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    */\n    \n    vec3 finalCol = vec3(0.);\n    \n    if (surfType == 0) {\n        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);\n    }\n    else if (surfType == 1) {\n        finalCol = mix(surfCol * specular, vec3(specular), f);\n    }\n    \n    finalCol = finalCol;\n    \n    return finalCol;\n}\n\nvec3 renderFromRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 contribution = vec3(1.0);\n    vec3 combinedCol;\n    float totalDepth = 0.;\n    float foga;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);\n            if (surfType == 0) {\n                contribution *= f;\n            }\n            else if (surfType == 1) {\n                contribution *= mix(surfCol, vec3(1.), vec3(f));\n            }\n            \n            rayDir = reflect(rayDir, surfNormal);\n            rayOrigin = rayData.yzw + epsilon * surfNormal;\n        }\n        else {\n            combinedCol += contribution * ambient;\n            break;\n        }\n    }\n    return combinedCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/2.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec3 col = renderFromRay(rayDir, camera);\n    \n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 424, 467, 467, 510], [512, 522, 590, 590, 999], [1001, 1001, 1069, 1069, 1279], [1281, 1281, 1385, 1385, 1680], [1682, 1682, 1725, 1725, 2745], [2747, 2747, 2828, 2828, 3112], [3114, 3114, 3158, 3158, 3271], [3273, 3273, 3385, 3385, 3774], [3776, 3776, 3867, 3867, 4011], [4013, 4013, 4071, 4071, 4224], [4226, 4286, 4311, 4331, 4388], [4390, 4390, 4465, 4465, 4606], [4608, 4608, 4688, 4688, 5236], [5238, 5238, 5287, 5287, 6221], [6223, 6223, 6280, 6280, 6789]], "test": "untested"}
{"id": "sl2GzD", "name": "simplex noise crease", "author": "RiceFields", "description": "simplex noise", "tags": ["simplexnoise", "crease"], "likes": 4, "viewed": 55, "published": "Public", "date": "1623487034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate2d(vec2 uv, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n    return (mat*(uv));\n}\n\nvec2 hash(vec2 uv){\n    uv = vec2( dot(uv,vec2(127.1,311.7)), dot(uv,vec2(269.5,183.3)) );\n    vec2 v = -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);  \n    v = rotate2d(v, iTime); // rotated random direction\n    return v;\n}\n\n// noise range [-1, 1]\nfloat snoise2D(vec2 v) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n    \n    // skew each unit square gird into two equilateral triangle (simplex cell)\n    vec2 i = floor(v + (v.x+v.y)*K1); \n    \n    // unskew the cell origin i(x,y) back to original space\n    vec2 pa = i - (i.x+i.y)*K2;\n    // distance from cell origin to current point(v)\n    vec2 da = v - pa;\n    \n    // calculate point b of the simplex\n    vec2 o = vec2(0.0f);\n    if(da.x > da.y) {\n        o = vec2(1.0f, 0.0f); //  lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    } else {\n        o = vec2(0.0f, 1.0f); // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    }\n    \n    vec2 db = da - o + K2; // offset for point b of simplex\n    vec2 dc = da - 1.0 + 2.0 * K2; // offset for point c of simplex\n\n    \n    // calculate contribution of each point, with distance of simplex vertices from current point   \n    float ca = max(0.5f - dot(da, da), 0.0f); \n    float cb = max(0.5f - dot(db, db), 0.0f);\n    float cc = max(0.5f - dot(dc, dc), 0.0f); \n\n    // calculate gradient with the contribution\n    float n1 = ca*ca*ca*ca*dot(da, hash(i + vec2(0.0f)));\n    float n2 = cb*cb*cb*cb*dot(db, hash(i + o));\n    float n3 = cc*cc*cc*cc*dot(dc, hash(i + vec2(1.0f)));\n    \n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70.0f * (n1+n2+n3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // res\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 16.0f;\n    float x_max = (iResolution.x/iResolution.y)*16.0f; // max uv.x\n    \n    // tile\n    vec2 fuv = fract(uv);\n    vec2 iuv = floor(uv);\n    \n    // noise with creases \n    float len = length(snoise2D(uv+iTime*0.2f));\n    \n    // sliding window, between len and inverted len\n    float a = mod(iTime*2.5f, 2.0f*x_max); \n    if(a > x_max)\n      len = abs(step(uv.x, 2.0f*x_max-a)- len);\n    else\n      len = abs(step(uv.x, a)- len);\n    \n    fragColor = vec4(vec3(len), 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 133], [135, 135, 154, 154, 357], [359, 382, 406, 406, 1846], [1849, 1849, 1906, 1917, 2449]], "test": "untested"}
{"id": "sl2Gzw", "name": "Pride Sometimes", "author": "dmzmd", "description": "Applying a wave to a flag ", "tags": ["flag", "hsv", "pride"], "likes": 1, "viewed": 25, "published": "Public", "date": "1623621745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    vec3 hsv2rgb(vec3 c) //from  yiwenl/hsv2rgb \n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n   // uv.y+=sin(uv.x*13.+iTime)*.05;\n       uv.y*=sin(-iTime+distance(uv,vec2(.5)));\n    uv.y=floor(uv.y*6.)/6.;\n\n    // Time varying pixel color\n    float h=-uv.y-(1./6.);//put red on top\n    vec3 col = hsv2rgb(vec3(h,.99,.8));\n//col=vec3(uv.yy,0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2Gzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 50, 50, 219], [221, 221, 278, 328, 682]], "test": "untested"}
{"id": "slB3Rm", "name": "a cool effect", "author": "Vinicius_Jesus", "description": "in test", "tags": ["effect", "animation", "soft"], "likes": 3, "viewed": 66, "published": "Public", "date": "1623559386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TWO_PI (PI*2.0)\n#define N 68.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = (fragCoord.xy);\n    center.x=-10.12*sin(iTime/200.0);\n    center.y=-10.12*cos(iTime/200.0);\n    vec2 v = (fragCoord.xy - iResolution.x/20.0) / min(iResolution.y,iResolution.x) * 15.0;\n    v.x=v.x-10.0;\n    v.y=v.y-200.0;\n    float col = 0.0;\n\n    for(float i = 0.0; i < N; i++) {\n        float a = i * (TWO_PI/N) * 61.95;\n        col += cos(TWO_PI*(v.y * cos(a) + v.x * sin(a) + sin(iTime*0.004)*100.0 ));\n    }\n\n    col /= 5.;\n    \n    float red = 1.;\n    float green = sin(iTime) * 1.25;\n    float blue = cos(iTime) * 1.525;\n    vec3 rgb = vec3(red, green, blue);\n    vec3 color = vec3(rgb);\n    \n    fragColor = vec4(vec3(col*color),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slB3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 116, 783]], "test": "untested"}
{"id": "slB3z3", "name": "Fast Improved 3D Perlin Noise", "author": "TheTurk", "description": "Fast Perlin Noise implementation that replaces the orginal hashing mechanism with MurmurHash, which is faster, does not require a lookup table, has a greater range and produces a much better distribution of random numbers.", "tags": ["noise", "perlinnoise", "gradient", "random", "hash", "murmur"], "likes": 9, "viewed": 216, "published": "Public", "date": "1624364769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 3-dimensional unsigned integer input vector.\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process third vector element\n    k = x.z; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec3 gradientDirection(uint hash) {\n    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n    case 0:\n        return vec3(1, 1, 0);\n    case 1:\n        return vec3(-1, 1, 0);\n    case 2:\n        return vec3(1, -1, 0);\n    case 3:\n        return vec3(-1, -1, 0);\n    case 4:\n        return vec3(1, 0, 1);\n    case 5:\n        return vec3(-1, 0, 1);\n    case 6:\n        return vec3(1, 0, -1);\n    case 7:\n        return vec3(-1, 0, -1);\n    case 8:\n        return vec3(0, 1, 1);\n    case 9:\n        return vec3(0, -1, 1);\n    case 10:\n        return vec3(0, 1, -1);\n    case 11:\n        return vec3(0, -1, -1);\n    case 12:\n        return vec3(1, 1, 0);\n    case 13:\n        return vec3(-1, 1, 0);\n    case 14:\n        return vec3(0, -1, 1);\n    case 15:\n        return vec3(0, -1, -1);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(\n        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position.x *= iResolution.x / iResolution.y;\n    uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n    // float frequency = 16.0;\n    // float value = perlinNoise(vec3(position, iTime * 0.25) * frequency, seed); // single octave perlin noise\n    float value = perlinNoise(vec3(position, iTime * 0.25), 1, 6, 0.5, 2.0, seed); // multiple octaves\n    value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    fragColor = vec4(vec3(value), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slB3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 112, 142, 142, 412], [414, 547, 577, 577, 1107], [1110, 1110, 1145, 1145, 1936], [1938, 1938, 2077, 2077, 2254], [2256, 2256, 2275, 2303, 2356], [2358, 2358, 2403, 2403, 3598], [3600, 3600, 3714, 3714, 4152], [4154, 4154, 4209, 4209, 4779]], "test": "untested"}
{"id": "slf3zl", "name": "Raymarched SDF \"bearings\"", "author": "Danimtz", "description": "Update on my first shader. Used smoothmax to combine torus and sphere and made little spheres rotate in the groove. Currently slow due to nested loops for the little subbearings/burgers. Change AA from 2 to 1 for better performance", "tags": ["raymarching", "combiningsdfs"], "likes": 4, "viewed": 140, "published": "Public API", "date": "1622610108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.001\n#define AA 2\n\n#define PI 3.1415926538\n\n#define SPHERECOUNT 4\n#define SPHERE3 4.0\n#define SPHERE2 3.0\n#define SPHERE1 2.0\n#define PLANE 1.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y); //outer and inner radius 2d\n    return length(q)-t.y; //two symetric circles 2d\n}\n\nvec2 minSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 maxSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x>sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 smax(vec2 sdf1, vec2 sdf2, float k)//smooth\n{\n    float h = max(k - abs(sdf1.x - sdf2.x), 0.0)/k;\n    float bf = h*h*0.5;// blend factor \n    float res = bf*k*(1.0/2.0);\n    \n    return (sdf1.x>sdf2.x) ? vec2(sdf1.x+res, sdf1.y/*mix(sdf1.y, sdf2.y, bf)*/) : \n    vec2(sdf2.x+res, sdf2.y/*mix(sdf1.y, sdf2.y, 1.0-bf)*/);\n}\n\n//Returns origin of rotating sphere\nvec3 calcRotSphereXZ(float ofset, vec3 o, float th)\n{\n    vec2 o_2d = o.xz;//ignore height\n    vec2 p = o_2d+vec2(ofset);\n\n    //translate to origin\n    p -= o.xz;\n\n    //calculate rotation\n    vec2 rot_p;\n    rot_p.x = p.x*cos(th) - p.y*sin(th);\n    rot_p.y = p.x*sin(th) + p.y*cos(th);\n\n    //translate back\n    vec3 res = o;\n    res.xz = rot_p + o_2d;\n\n    return res;\n}\n\n\nvec2 sdBurger(vec3 p, vec3 o, float r, float k, float colourID) // Sphere with torus cut out\n{\n    //torus modifiers\n    float t1 = 0.7; \n    float t2 = 0.3;\n\n    vec3 po = p-o;\n\n    vec2 sdf = vec2(sdSphere(po, r), colourID);\n    sdf = smax(sdf, vec2(-sdTorus(po, vec2(r*t1, r*t2)), colourID), k);\n    return sdf;\n} \n\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    \n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    //Hollowed sphere\n    vec3 sph_o = vec3(0.0, 2.0, 10.0);\n    vec3 torus = vec3(0.0, 2.0, 10.0);\n    float rp = 2.0;\n    float k = 0.4;\n    float ratio = 0.287; //ratio\n    vec2 combined = vec2(1e10, 0.0);\n    \n    cur_sdf = sdBurger(p, sph_o, rp, k,SPHERE1);\n    \n    //Rotating spheres\n    float r = ratio*rp;\n    float rr = ratio*r;\n    float kk = ratio*k;\n    float kkk = ratio*kk;\n    float theta = 1.0*iTime;\n    int sph_count = SPHERECOUNT;\n    \n    //NOTE: these nested loops are very slow with increasing ammount of spheres. \n    //There are surely better ways to optimize this, but wanted to implement fractalike animation naively\n    for(int i = 0; i < sph_count; i++)\n    {\n        vec3 sph_or = calcRotSphereXZ(1.0, sph_o, theta+(2.0*PI*(float(i)/float(sph_count))));\n        cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_or, r, kk,SPHERE2));\n\n        //Rotating spheres\n        float theta2 = 4.0*theta;\n        for(int j = 0; j < sph_count; j++)\n        {\n            vec3 sph_orr = calcRotSphereXZ(ratio, sph_or, theta2+(2.0*PI*(float(j)/float(sph_count))));\n            cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_orr, rr, kkk,SPHERE3));\n        \n        }\n    \n    }\n    \n\n    //plane\n    cur_sdf = minSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < 0.001){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y); //d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    //float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            map(p+e.xyy).x-map(p-e.xyy).x,    \n            map(p+e.yxy).x-map(p-e.yxy).x,  \n            map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<=PLANE){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<=SPHERE1){ mat = vec3(0.15);}\n        else if(res.y<=SPHERE2){ mat = vec3(0.05);}\n        else if(res.y<=SPHERE3){ mat = vec3(0.11, 0.07, 0.15);}\n        \n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*0.05, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n         \n\n\n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(-cos(0.2*iTime), 2.7, -1.2*sin(0.2*iTime));\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slf3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 277, 277, 305], [307, 307, 340, 340, 463], [465, 465, 500, 500, 542], [544, 544, 579, 579, 621], [623, 623, 673, 673, 949], [951, 987, 1040, 1040, 1360], [1363, 1363, 1457, 1479, 1679], [1683, 1683, 1730, 1730, 3049], [3051, 3051, 3084, 3084, 3407], [3409, 3409, 3456, 3628, 4210], [4212, 4212, 4237, 4289, 4568], [4572, 4572, 4603, 4624, 6120], [6122, 6122, 6179, 6204, 6993]], "test": "untested"}
{"id": "slfGDs", "name": "Pioupiou", "author": "z0rg", "description": "piou", "tags": ["pioupiou"], "likes": 2, "viewed": 141, "published": "Public API", "date": "1623095225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n  vec2 l = abs(p)-s;\n  return max(l.x,l.y);\n}\n\n\nfloat line(vec2 p, vec2 s)\n{\n  vec2 rep = p;\n  rep.y= abs(p.y);\n  return min(_sqr(p, s),length(rep-vec2(0.,s.y))-s.x);\n}\nfloat pioupiou(vec2 p)\n{\n  return min(max(length(p)-.3,-(length(p-vec2(0.,.4))-.4)),\n    length(p-vec2(.15,.12))-.17);\n}\n\nvec3 foot(vec2 p, vec3 col, float off)\n{\n  float shp = 400.;\n  float h = .1;\n  p-= vec2(0.,-.2);\n  p*= r2d(sin(iTime*10.+off));\n  p+= vec2(0.,h);\n\n\n  float trunk = line(p,vec2(.02,h));\n  trunk = min(trunk, line(p-vec2(0.,-.1),vec2(.01,.05)));\n  vec2 mp = p;\n  mp.x = abs(mp.x);\n\ntrunk = min(trunk, line((mp-vec2(0.,-.1))*r2d(-1.57*.5),vec2(.01,.05)));\n\n  col = mix(col, vec3(.8,.6,.3),1.-sat(trunk*shp));\n  return col;\n}\n\nvec3 grass(vec2 uv, float t, vec3 col, vec3 rgb)\n{\n  float freq = 80.;\n  float shape  = uv.y-asin(sin(uv.x*freq+t))*.05;\n  col = mix(col, rgb,1.-sat(400.*shape));\n  return col;\n}\n\nfloat cloud(vec2 uv)\n{\n  uv.y+= -.5;\n  uv.x+=iTime*.3;\n  float rep = 0.1;\n  float id = floor((uv.x+rep*.5)/rep);\n  uv.x= mod(uv.x+rep*.5,rep)-rep*.5;\n  float acc = -uv.y;\n\n  acc = max(acc, length(uv)-abs(sin(id*.15))*.1);\n  return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec2 ouv = uv;\n  vec3 col = vec3(.2,.5,.7);\n  float shp = 400.;\n  mat2 rotb = r2d(sin(iTime*15.)*.05);\n  float piou = pioupiou(uv*rotb);\n  col = grass(ouv-vec2(0.,-.3), iTime*10.,col,vec3(.1,.5,.3));\n  col = foot(uv,col,3.1415);\n  col = mix(col, vec3(.8,.7,.4), 1.-sat(shp*piou));\n  col = mix(col, vec3(.1,.1,.2), 1.-sat(shp*(abs(piou)-.01)));\n  col = mix(col, vec3(.1,.1,.2), 1.-sat(shp*(length((uv*rotb-vec2(.22,0.17)))-.02)));\n  col = foot(uv,col,0.);\n  uv*= rotb;\n  uv -= vec2(.35,.13);\n  float mouth = max(_sqr(uv, vec2(.05,.025)),-(_sqr(uv*r2d(1.57*.5)-vec2(.05),vec2(.05))));\n  col = mix(col, vec3(.8,.6,.3), 1.-sat(shp*mouth));\n  col = grass(ouv-vec2(0.1,-.4), iTime*20.,col,vec3(.1,.5,.3)*1.5);\ncol = grass(ouv-vec2(0.,-.6), iTime*30.,col,vec3(.1,.5,.3));\ncol = mix(col, vec3(1.), 1.-sat(cloud(ouv)*400.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  vec3 col = rdr(uv*2.5);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGDs.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 428, 446, 446, 501], [503, 503, 531, 531, 577], [580, 580, 608, 608, 700], [701, 701, 725, 725, 821], [823, 823, 863, 863, 1243], [1245, 1245, 1295, 1295, 1423], [1425, 1425, 1447, 1447, 1662], [1664, 1664, 1683, 1683, 2517], [2519, 2519, 2576, 2576, 2703]], "test": "untested"}
{"id": "slj3Dd", "name": "Arrow - distance", "author": "iq", "description": "Distance to an arrow (exact interior and exterior Euclidean distances)", "tags": ["2d", "distancefield", "sdf", "arrow"], "likes": 10, "viewed": 330, "published": "Public API", "date": "1625029726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an arrow\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    // return min(length(p-a)-w1,length(p-b)); for debugging\n\n    // constant setup\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float time = iTime*0.25;\n    vec2 a = vec2(-1.0,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.1,1.3)+vec2(0.0,1.0));\n    vec2 b = vec2( 1.0,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.2,1.5)+vec2(0.3,2.0));\n    float w1 = 0.2;//0.05*(0.8+0.2*cos(time*0.31+2.0));\n    float w2 = w1 + 0.15;\n    \n    // distance\n    float d = sdArrow(p, a, b, w1, w2);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-5.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdArrow(m, a, b, w1, w2);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slj3Dd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1261, 1351, 1415, 1499, 2515], [2517, 2517, 2574, 2610, 3581]], "test": "untested"}
{"id": "slj3DR", "name": "Smoldering effect ", "author": "SimpleMurad", "description": "smoldering effect with noise ", "tags": ["noise", "fire", "smoldering"], "likes": 8, "viewed": 192, "published": "Public", "date": "1623749716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 2.0f;\nconst float intensivity = 0.05f;\nconst int iteration = 6;\nconst float speed = 85.0; // range 1 to 100\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; \n    const float K2 = 0.211324865; ;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime*0.02f;\n    float q = fbm(uv  * 0.5);\n\n\tuv *= scale;\n    uv -= q - time;\n    \n    float f = 0.0;\n    float weight = 0.7;\n    for (int i=0; i<iteration; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f = fract(f+iTime/(101.-speed));\n    \n    float coeff = intensivity/abs(.5 - f);\n    vec3 result = vec3(.9,.2,.1)*coeff;\n        \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slj3DR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 176, 197, 197, 310], [312, 312, 338, 338, 772], [774, 774, 793, 793, 947], [950, 950, 1007, 1007, 1538]], "test": "untested"}
{"id": "sljGzD", "name": "silly simple warping dot grid", "author": "benhardy", "description": "Just a simple one to demo how fast you can crank a shader out to a friend", "tags": ["simple", "mod", "kata"], "likes": 6, "viewed": 159, "published": "Public API", "date": "1623481866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float WINDOW_WIDTH = 15.0;\n\n#define ASPECT (iResolution.y/iResolution.x)\n\nvec2 cmod(vec2 pos, vec2 off) {\n    return mod(pos+0.5, off) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 win = WINDOW_WIDTH * (fragCoord/iResolution.xy - 0.5) * vec2(1, ASPECT);\n    float ang = 3.0 * sin(iTime*1.0 + 5.0* sin(iTime*0.23));\n    vec2 rot_pos = vec2(cos(ang)*win.x-sin(ang)*win.y,sin(ang)*win.x+cos(ang)*win.y);\n    vec2 warp_centre = 3.0 * vec2(sin(iTime*2.0), cos(5.0*iTime));\n    vec2 to_warp = rot_pos - warp_centre;\n    float d_warp = length(to_warp);\n    d_warp += (sin(iTime*3.5+ 2.3* sin(iTime*0.33))+1.2)*0.02*( pow(d_warp, 3.0) + 0.1 );\n    vec2 warped = warp_centre +d_warp * normalize(to_warp);\n    \n    vec2 pos = cmod(warped, vec2(1));\n    float dist = length(pos) - 0.25;\n    float level = clamp(ceil(dist), 0.0, 1.0);\n    vec3 col = vec3(level);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 111, 111, 149], [151, 151, 208, 258, 995]], "test": "untested"}
{"id": "sll3Rj", "name": "flag 1", "author": "sean1998", "description": "show a simple flag", "tags": ["2d", "flag"], "likes": 1, "viewed": 126, "published": "Public API", "date": "1622609728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926;\n\nfloat plot(vec2 uv, float f, float offset, bool flag){\n   f *= 2.0;\n   float y = mix(0.0, 1.0, uv.y);\n   return smoothstep(flag ? 0.02 : -0.02, 0.0, y - 0.1*sin(iTime+f) - offset);\n}\n\n\nvec3 getcolor(vec2 uv, float y, float offset, vec3 c1, vec3 c2, bool flag){\n    y *= PI;\n    float f = plot(uv, y, offset, flag);\n    \n    return mix(c1, c2, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color1 = getcolor(uv, uv.x, 0.8, vec3(1,0,0),  vec3(0,0,0), false);\n    vec3 color2 = getcolor(uv, uv.x, 0.6, vec3(-1,1,0), vec3(0,0,0), false);\n    vec3 color3 = getcolor(uv, uv.x, 0.4, vec3(0,-1,1), vec3(0,0,0), false);\n    vec3 color4 = getcolor(uv, uv.x, 0.2, vec3(0,0,-1), vec3(0,0,0), false);\n\n    // Output to screen\n    fragColor = vec4(color1 + color2 + color3 + color4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 77, 77, 205], [208, 208, 283, 283, 371], [373, 373, 430, 480, 918]], "test": "untested"}
{"id": "sll3Rl", "name": "- Modified Julia Set -", "author": "Mihaha", "description": "Classic julia set with a slightly modified distance formula.", "tags": ["julia", "mandelbrot", "set"], "likes": 2, "viewed": 171, "published": "Public API", "date": "1622658051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n> by MihasGames, 02.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nconst int MAX_ITERATIONS = 200;\n\nint julia(vec2 zz, vec2 c) \n{\n  vec2 z = zz;\n  float a = z.x;\n  float b = z.y;\n  int n = 0;\n  while (n < MAX_ITERATIONS) {\n    float aa = a*a;\n    float bb = b*b;\n    float twoab = 2.0 * a * b;\n\n    a = aa - bb + c.x;\n    b = twoab + c.y;\n\n    if (a*a*a*b + b*b*b*a > 3.0) break;\n    n++;\n  }\n  return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  int juliaValue = julia((fragCoord.xy/iResolution.xy*4.0 - vec2(2, 2)) * vec2(iResolution.x / iResolution.y, 1), \n                          vec2(cos(iTime), sin(iTime/1.2)));\n  \n  float color = float(juliaValue) / float(MAX_ITERATIONS) * 7.0 + 0.1;\n  fragColor = vec4(color*0.2, color-0.3, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 103, 132, 132, 409], [411, 411, 469, 469, 775]], "test": "untested"}
{"id": "sll3Rs", "name": "Perlin Noise 1D __", "author": "Envy24", "description": "perlin, noise, random", "tags": ["noise", "perlin", "random"], "likes": 1, "viewed": 35, "published": "Public", "date": "1622668963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 12345u;\n    const uint enthropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\nfloat PerlinNoise1D(float u)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n\n    // Integer part.\n    u = floor(u);\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0f - 2.0f * fractU);\n\n    // Random gradient vectors.\n    float gradient0 = signedSample1DHashUI32(uint(u));\n    float gradient1 = signedSample1DHashUI32(uint(u + 1.0f));     \n\n    // Distance vectors.\n    float distance0 = fractU;\n    float distance1 = fractU - 1.0f;\n\n    // Dot products.\n    float dotProduct0 = gradient0 * distance0;\n    float dotProduct1 = gradient1 * distance1;\n\n    // llinear filter.\n    return\n        dotProduct0 * (1.0f - tU) +\n        dotProduct1 * tU;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0f;\n    \n    float _u;\n    \n    if (uv.x < 1.0f) { _u = uv.x + iMouse.x * 0.1f + iTime * 0.1f; }\n    else { _u = uv.x + iMouse.x * 0.1f + iTime * 0.9f; }\n\n    float gray = PerlinNoise1D(_u)      * 6.6f;\n    gray += PerlinNoise1D(_u * 2.3f)    * 2.62f;\n    gray += PerlinNoise1D(_u * 4.32f)   * 0.47f;\n    gray += PerlinNoise1D(_u * 8.672f)  * 0.17f;\n    gray += PerlinNoise1D(_u * 16.62f)  * 0.18f;\n    gray += PerlinNoise1D(_u * 37.72f)  * 0.17f;\n    gray += PerlinNoise1D(_u * 64.72f)  * 0.17f;\n    gray += PerlinNoise1D(_u * 128.72f) * 0.07f;\n    gray += PerlinNoise1D(_u * 256.72f) * 0.03f;\n    gray += 4.6f;\n    gray *= 0.20f;\n    \n    // Anti-aliasing.\n    float lineWidth = 4.0/iResolution.y;\n    gray = smoothstep(0.0f, lineWidth, abs(uv.y - gray));\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 87, 157, 449], [451, 451, 481, 503, 1116], [1118, 1118, 1175, 1225, 2091]], "test": "untested"}
{"id": "sll3Wl", "name": "Fork Fast 2D Ha badjano 213", "author": "badjano", "description": "Made something weird, testing precision", "tags": ["procedural", "2d", "noise", "random", "hash"], "likes": 2, "viewed": 43, "published": "Public", "date": "1623140300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fast vec2 -> vec4 hash function for webgl\n//github.com/victor-shepardson\n\n//hash based on Blum, Blum & Shub 1986\n//and Sharpe http://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/\nfloat pi = 3.14159265359;\nfloat bbsm = 1739.;\nvec2 bbsopt(in vec2 a){\n\treturn fract(a*a*(1./bbsm))*bbsm;\n}\nvec2 mod1024(in vec2 a){\n\treturn fract(a*(1./1024.))*1024.;\t\n}\nvec4 hash(in vec2 pos){\n\tvec2 a0 = mod1024(pos*pi);\n\tvec2 a1 = bbsopt(a0);\n\tvec2 a2 = a1.yx + bbsopt(a1);\n\tvec2 a3 = a2.yx + bbsopt(a2);\n\treturn fract((a2.xyxy + a3.xxyy + a1.xyyx)*(1./bbsm));\n}\n\nvec4 fbm(in vec2 pos){\n    float m = 1.;\n    float n = 0.125;\n    vec4 r = vec4(0.);\n    for (int i=0; i<32; i++){\n        r += hash(pos) * n;\n        m *= r.x;\n        n *= 0.9;\n        pos *= 1.5;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec2 vel = vec2(60., 60.); //animation speed\n    const vec2 scale = vec2(1., 1.);\n\tconst int num = 1; //average multiple instances\n\t\n\tvec2 p = scale*floor(fragCoord.xy-vel*iTime);\n\t\n\tvec4 c = vec4(0.);\n\tfor(int i=0; i<num; i++)\n\t\tc+= fbm(p*pow(sin(iTime)*.5+2.,5.)*0.0000001+float(i*1024));\n\tc*=1./float(num);\n\t\n\tfragColor = vec4(c.x,c.y,c.z,c.w);\n\t\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 242, 265, 265, 302], [303, 303, 327, 327, 365], [366, 366, 389, 389, 560], [562, 562, 584, 584, 782], [784, 784, 841, 841, 1201]], "test": "untested"}
{"id": "sllXzr", "name": "Segmented Graph", "author": "wildniklin", "description": "The graph is split into several lines for avoiding the weird glitch at abrupt value differences. Relatively fast, 4 value calls, can be reduced down to 2, but 4 is the best for avoiding column edge glitches.\n\nOh and the best part is it's antialiased. ;)", "tags": ["graph"], "likes": 3, "viewed": 151, "published": "Public API", "date": "1625083623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float segments = 50.0; // Segments per unit, must be less than (1.0 / thickness), or else will glitch visually, because lines are wider than segments.\nconst float thickness = 0.01; // Line thickness\nconst float gridThickness = 0.001; // Grid line thickness\nconst float scale = 3.0;\n\nfloat value(float x) {\n    return fract(x) * fract(-x) * (fract(x * 0.5) > 0.5 ? -4.0 : 4.0); // I discovered a sine wave polynomial. I doubt it's any faster than sin() though, it's off by a few decimals.\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b - a;\n    float dist = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n    if(dist <= 0.0) return a;\n    if(dist >= 1.0) return b;\n    return mix(a, b, dist);\n}\n\nfloat distToLine(vec2 a, vec2 b, vec2 p) {\n    return length(p - closestPointLine(a, b, p));\n}\n\nvec2 point(int i, float unit) {\n    float x = (float(i) + 0.5) * unit;\n    return vec2(x, value(x));\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    \n    un *= scale;\n    \n    vec2 uv = (i - (0.5 * iResolution.xy)) * un;\n    \n    uv *= rot(radians(sin(radians(iTime * 22.5)) * 4.0));\n\n    int ip = int(floor(uv.x * segments));\n    float unit = 1.0 / segments;\n\n    vec2 p0 = point(ip - 2, unit),\n         p1 = point(ip - 1, unit),\n         p2 = point(ip    , unit),\n         p3 = point(ip + 1, unit),\n         p4 = point(ip + 2, unit);\n\n    float dist = min(min(distToLine(p0, p1, uv), distToLine(p1, p2, uv)),\n                     min(distToLine(p2, p3, uv), distToLine(p3, p4, uv))) - thickness;\n\n    float d = 1.0;\n\n    vec2 f = fract(uv);\n    d = mix(d, 0.75, min(1.0, smoothstep(un, -un, (1.0 - f.x) - gridThickness) + smoothstep(un, -un, f.x - gridThickness) + smoothstep(un, -un, (1.0 - f.y) - gridThickness) + smoothstep(un, -un, f.y - gridThickness)));\n\n    d = mix(d, 0.0, smoothstep(un, -un, dist));\n\n    d = mix(d, 0.0, smoothstep(0.0, 3.0 * scale, length(uv)));\n    \n    o = vec4(d, d, d, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 289, 311, 311, 495], [497, 497, 516, 516, 582], [584, 584, 631, 631, 806], [808, 808, 850, 850, 902], [904, 904, 935, 935, 1006], [1008, 1008, 1044, 1044, 2065]], "test": "untested"}
{"id": "sls3Df", "name": "dissolve_210607", "author": "intrometa", "description": "dissolve sample", "tags": ["dissolve"], "likes": 4, "viewed": 54, "published": "Public", "date": "1623228694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float unity_noise_randomValue (vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nfloat unity_noise_interpolate (float a, float b, float t)\n{\n    return (1.0-t)*a + (t*b);\n}\n\nfloat unity_valueNoise (vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n\n    uv = abs(fract(uv) - 0.5);\n    vec2 c0 = i + vec2(0.0, 0.0);\n    vec2 c1 = i + vec2(1.0, 0.0);\n    vec2 c2 = i + vec2(0.0, 1.0);\n    vec2 c3 = i + vec2(1.0, 1.0);\n    float r0 = unity_noise_randomValue(c0);\n    float r1 = unity_noise_randomValue(c1);\n    float r2 = unity_noise_randomValue(c2);\n    float r3 = unity_noise_randomValue(c3);\n\n    float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);\n    float topOfGrid = unity_noise_interpolate(r2, r3, f.x);\n    float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\n// https://docs.unity3d.com/Packages/com.unity.shadergraph@10.4/manual/Simple-Noise-Node.html\nvoid Unity_SimpleNoise_float(vec2 UV, float Scale, out float Out)\n{\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\n    float amp = pow(0.5, float(3-0));\n    t += unity_valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\n    amp = pow(0.5, float(3-1));\n    t += unity_valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\n    amp = pow(0.5, float(3-2));\n    t += unity_valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    Out = t;\n}\n\nvoid Unity_Remap_float(float In, vec2 InMinMax, vec2 OutMinMax, out float Out)\n{\n    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);\n}\n\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // designed effect: start with a circle on grey background, and dissovle to whole black\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // params\n    float threshold = sin(iTime - 3.14 * 1.5); // offset by 3/2 PI\n    vec4 borderColor = vec4(1.0, 1.0, 0.0, 1.0);\n    \n    vec3 bgColor = vec3(0.0, 0.0, 0.0);\n    vec4 fgColor = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n    // params - simple shape\n    vec2 uv_n = uv;\n    float ratio = iResolution.x / iResolution.y;\n    uv_n.x *= ratio;\n    fgColor = length(vec2(0.5 * ratio, 0.5) - uv_n) < 0.3 ? vec4(rgb(225.0, 95.0, 60.0), 1.0) : fgColor;\n    // params - simple shape end\n    \n    float noiseScale = 43.44;\n    // params end\n\n    float noise;\n    vec3 col = fgColor.rgb;\n    Unity_SimpleNoise_float(uv, noiseScale, noise); // generate noise\n    Unity_Remap_float(threshold, vec2(-1.0, 1.0), vec2(0.0, 1), threshold);\n    float alpha = step(noise, threshold); // alpha clip threshold\n    col += borderColor.rgb * step(threshold - noise, 0.05); // add border\n    fragColor = mix(vec4(bgColor, 1.0), vec4(col, 1.0), alpha); // blend\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 109], [111, 111, 170, 170, 202], [204, 204, 238, 238, 872], [874, 968, 1035, 1035, 1487], [1489, 1489, 1569, 1569, 1672], [1674, 1674, 1711, 1711, 1760], [1762, 1762, 1819, 1961, 2954]], "test": "untested"}
{"id": "slS3DK", "name": "On their way to Sirius", "author": "elefAntti", "description": "An old shader that I did, now moved to Shadertoy. I left it a bit glitchy on purpose, but I'm not sure how consistent the glitches behave on different platforms.", "tags": ["quaterinion"], "likes": 8, "viewed": 112, "published": "Public", "date": "1624705924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.1415926535897932384626433832795\n\nvec3 to_polar(vec3 pos)\n{\n    float x = atan( pos.x, pos.z );\n    float y = atan( pos.y, length(pos.xz));\n    return vec3(x, y, length(pos));\n}\n\nvec4 quaternion_multiply(vec4 a, vec4 b)\n{\n    float real_p = a.x*b.x - dot(a.yzw, b.yzw);\n    vec3 imag_p = a.x * b.yzw + b.x * a.yzw + cross(a.yzw, b.yzw);\n    return vec4(real_p, imag_p);\n}\n\nvec4 quaternion_inverse(vec4 a)\n{\n    float len = length(a);\n    return a * vec4(1.0, vec3(-1.0)) / (len * len);\n}\n\nvec4 rotation_quaternion(vec3 axis, float angle)\n{\n    return vec4(cos(angle/2.0), sin(angle/2.0) * axis);\n}\n\nvec3 rotate_around_axis(vec3 v, vec3 axis, float angle)\n{\n    vec4 Q = rotation_quaternion(axis, angle);\n    vec4 Q_inv = quaternion_inverse(Q);\n    return quaternion_multiply(quaternion_multiply(Q, vec4(0.0, v)), Q_inv).yzw;\n}\n\nfloat noise(float pos)\n{\n    //Picking the low bits, which are more random\n    return mod(sin(pos) * 10000.0, 1.0);\n}\n\nfloat noise(vec3 pos)\n{\n    float key = pos.x * 111.0 + pos.y * 788.0 + pos.z * 827.0;\n    return noise(key);\n}\n\n\nmat3 camera_rotation( vec3 look_at )\n{\n    //look_at = normalize(look_at);\n    vec3 x = vec3( look_at.z, 0, -look_at.x ); \n    vec3 y = cross( look_at, x );\n    return mat3( x, y, look_at );\n}\n\n#define AccuracyDropoff 10.0\n#define MaxCastLen 27.0\n#define HitDistance 0.05\n#define FocalLength 2.0\n#define DistanceMultiplier 1.0\n#define DistanceNoise 0.2\n#define GlowRadius 0.05\n#define InnerRadius 7.95\n#define OuterRadius 8.0\n\n#define TimeStep 2.0\n#define SpokeCount 5.0\n\nfloat model_radius_fcn(float time)\n{\n   return mix(InnerRadius, 0.0, clamp(time  / TimeStep - 5.0, 0.0, 1.0));\n} \n\nfloat spoke_model(vec3 pos, float my_time)\n{\n    vec3 polar = to_polar(pos);\n    vec2 xy = polar.xy / (M_PI * 2.0);\n    //Adjust spoke position away from the poles\n    xy.y /= 0.75;\n    xy += 0.5;\n    \n    vec2 xy2 = fract(xy * SpokeCount) - 0.5;\n\n    float dist_polar = length(xy2) * polar.z;\n    float inner_radius = model_radius_fcn(iTime);\n    return max(max(dist_polar - 0.25, polar.z - 8.0), inner_radius - polar.z ) * 0.4;  \n}\n\nfloat rotated_model(vec3 pos, float my_time)\n{\n    float t = floor(my_time / TimeStep);\n    float angle = fract(my_time / TimeStep) * 2.0 * M_PI;\n    vec3 axis =  t < 1.0  ?\n         vec3( 0.0, 1.0, 0.0) :\n         vec3(noise(t + 0.2) - 0.5,\n              noise(t + 0.7) - 0.5,\n              noise(t + 1.1) - 0.5);\n    axis = normalize(axis);\n    return spoke_model(rotate_around_axis(pos, axis, angle), my_time);\n}\n\nfloat dist_model(vec3 pos, float my_time)\n{\n    float len = length(pos);\n    //Early out\n    if( len > (OuterRadius + 0.5))\n    {\n        return len - OuterRadius;\n    }\n    return rotated_model(pos, (my_time - 0.3 * len) * 0.25);\n}\n\nfloat castRay( vec3 vStart, vec3 vDir, float my_time )\n{\n    float fCastLen = 0.0;\n    float fMinDist = 100.0;\n    vec3 vHit = vStart + vDir * 0.03;\n    while( fCastLen < MaxCastLen )\n    {\n        float fDistance = dist_model( vHit, my_time );\n        fMinDist = min(fMinDist, fDistance);\n\n        if( fDistance < HitDistance)\n        {\n            return fMinDist;\n        }\n\n        fDistance *= max(1.0, fCastLen / AccuracyDropoff);\n#ifdef DistanceNoise\n        fDistance *= ( 1.0 - noise(vHit) * DistanceNoise);\n#endif\n        fCastLen += fDistance;\n        vHit = vDir * fCastLen + vStart;\n    }\n\n    return fMinDist;\n}\n\nvec3 glow( vec3 dist )\n{\n    return pow(abs(dist - 0.1) / GlowRadius, vec3(-2.0));\n}\n\nvec4 rayTraceMain( vec2 fragCoord )\n{\n    float dt = 0.1;\n    vec2 position = fragCoord * -2.0 + 1.0;\n    vec3 cameraPos = vec3( 6.0, 1.0, -21.0 );\n    vec3 rayDir = normalize( vec3( position, 2.0 ) );\n    float dist_r = castRay( cameraPos, rayDir, iTime );\n    float dist_g = castRay( cameraPos, rayDir, iTime + dt);\n    float dist_b = castRay( cameraPos, rayDir, iTime + dt * 2.0);\n\n    return vec4(glow(vec3(dist_r, dist_g, dist_b)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n    fragColor = rayTraceMain( uv );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 74, 74, 192], [194, 194, 236, 236, 386], [388, 388, 421, 421, 502], [504, 504, 554, 554, 612], [614, 614, 671, 671, 841], [843, 843, 867, 917, 960], [962, 962, 985, 985, 1073], [1076, 1076, 1114, 1150, 1268], [1548, 1548, 1584, 1584, 1660], [1663, 1663, 1707, 1707, 2096], [2098, 2098, 2144, 2144, 2513], [2515, 2515, 2558, 2558, 2747], [2749, 2749, 2805, 2805, 3374], [3376, 3376, 3400, 3400, 3460], [3462, 3462, 3499, 3499, 3906], [3908, 3908, 3965, 4015, 4238]], "test": "untested"}
{"id": "sls3Rl", "name": "Hypno circle", "author": "avin", "description": "visual experiment", "tags": ["circle"], "likes": 1, "viewed": 153, "published": "Public API", "date": "1622661983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n\n#define SF 1./min(iResolution.x,iResolution.y)*.5\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define tx(b) texture(iChannel0, b)\n#define snd(x) texture(iChannel0, vec2(x,.1)).r\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n    \n    float l = length(uv);\n    \n    float size = .15;\n    float width = .005;\n    \n    float v = SS(l,  size) * SS(size -width, l);\n    \n    // float v = (.1 / smoothstep(l, l-.1, size));\n    \n    float a = sin(atan(uv.y, uv.x)*3.);\n    \n    float sv = tx(vec2(0.5,0.75)).r;\n    float mf = abs(snoise(vec3(a*.01,a, iTime)))*.1;\n    float v2 = SS(l - mf - width,  size) * SS(size-width*2. - mf, l);\n    float v22 = SS(l - mf - width,  size); // + SS(size-width*10. - mf, l);\n    float vs = 1.025;\n    float v3 = SS(l*vs - mf - width,  size) * SS(size-width*2. - mf, l*vs);\n    \n    vec3 col = vec3(0.0 + SS(abs(fract((uv.x + uv.y)*iResolution.x*.1)-.5), .15)*.1);\n    \n    col = mix(col, vec3(.25).rgb, v2);\n    col = mix(col, vec3(.0).rgb, v3);\n    col = mix(col, vec3(.7).rgb, v22-v2);\n    col = mix(col, vec3(1.), v);            \n        \n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*ouv.x*ouv.y*(1.0-ouv.x)*(1.0-ouv.y), 0.1 );\n    col = clamp(col,0.0,1.0);\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col) + vec3(0.0,0.0,0.04);\n    \n        \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 332, 332, 499], [501, 501, 523, 523, 1169], [1171, 1171, 1228, 1228, 2424]], "test": "untested"}
{"id": "slS3WG", "name": "Morphing discs", "author": "jarble", "description": "These discs morph in a shutter-like pattern.", "tags": ["fractal", "metal", "shiny", "iridescent"], "likes": 3, "viewed": 117, "published": "Public API", "date": "1624583825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = -1.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/9.0;\n    float s1 = (uv.y+iTime/2.)/8.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv.y /= scale;\n            uv = (uv+vec2(s1+uv.x-uv.y)/scale);\n            //uv.y -= col.x/16.;\n            uv.x *= -scale;\n            \n            uv = fract(uv.yx);\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 692]], "test": "untested"}
{"id": "slS3WV", "name": "Polyhedron series ", "author": "gaz", "description": "3d", "tags": ["sdf", "polyhedron"], "likes": 9, "viewed": 184, "published": "Public API", "date": "1624718226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI (atan(1.)*4.)\n\nvoid rot(inout vec3 p,vec3 a,float t)\n{\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a);\n}\n\n// https://www.shadertoy.com/view/MsKGzw\nvec3 fold(vec3 p, float t)\n{\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         // normalize\n    for(float i=0.; i<t; i++){\n        p.xy=abs(p.xy);\n        p-=2.*min(0.,dot(p,n))*n;\n    }\n    return p;\n}\n\nfloat map(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.5),.5*sin(iTime*.2)),iTime*.7);\n    float t = float[](3.,4.,5.)[int(fract(iTime/8.)*3.)];\n    p = fold(p,t);\n    p.z-=1.;\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         // normalize\n    return float[](\n            dot(p, normalize(vec3(n.z,0,-n.x))),\n            dot(p, normalize(vec3(0,n.z,-n.y))),\n            length(p.xz)-.1,\n            length(p.yz)-.1\n        )[int(fract(iTime/2.5)*4.)];\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.7,.5,.3)+cos(p*2.)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(uv,3));\n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.1,1.);\n        col*=max(dif,0.);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.8;\n        col*=max(.5+.5*n.y,.1);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    col=pow(col,vec3(1./2.2));\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 65, 65, 131], [133, 174, 202, 202, 396], [398, 398, 417, 417, 873], [875, 875, 900, 900, 1043], [1045, 1045, 1099, 1099, 1264], [1266, 1266, 1288, 1288, 1333], [1335, 1335, 1392, 1392, 2204]], "test": "untested"}
{"id": "slSGD1", "name": "starry Night", "author": "Vinicius_Jesus", "description": "in progress", "tags": ["star", "night", "comet", "moom"], "likes": 4, "viewed": 61, "published": "Public", "date": "1623881671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Rotate(vec2 uv,float t){\n\treturn vec2(uv.x*cos(t)-uv.y*sin(t),uv.y*cos(t)+uv.x*sin(t));\n}\n\nfloat R21(vec2 p) \n{\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nfloat Line(vec2 p, vec2 o, vec2 b, float sw, float ew){\n\tfloat d = distance(o, b);\n\tvec2  n = normalize(b - o);\n\tvec2 l = vec2( max(abs(dot(p - o, n.yx * vec2(-1.0, 1.0))), 0.0),\n\t               max(abs(dot(p - o, n) - d * 0.5) - d * 0.5, 0.0));\n\treturn smoothstep( mix(sw, ew, 1.-distance(b,p)/d) , 0., l.x+l.y);\n}\n\nvec3 Comet(vec2 p)\n{\n    float modu = 4.;        \n    float endPointY = -.1; \n    vec2 cmtVel = mod(iTime/modu+modu*.5, 2.) > 1. ? vec2(2., 1.4)*.5 : vec2(-2., 1.4)*.5;\n    vec2 cmtLen = vec2(.25)*cmtVel;\n    \n    vec2 cmtPt = 1. - mod(iTime*cmtVel, modu);\n    cmtPt.x +=1.;\n\n    vec2 cmtStartPt, cmtEndPt;\n\n    if(cmtPt.y < endPointY) {\n        cmtEndPt   = cmtPt + cmtLen;\n        if(cmtEndPt.y > endPointY) \n            cmtStartPt = vec2(cmtPt.x + cmtLen.x*((endPointY - cmtPt.y)/cmtLen.y), endPointY);\n        else\n            return vec3(.0);\n    }\n    else {\n        cmtStartPt = cmtPt;\n        cmtEndPt = cmtStartPt+cmtLen; \n    }\n\n    float bright = clamp(smoothstep(-.2,.65,distance(cmtStartPt, cmtEndPt)),0.,1.);\n\n    vec2 dlt = vec2(.003) * cmtVel;\n\n    float q = clamp( (p.y+.2)*2., 0., 1.);\n\n    return  vec3(bright * .75 * (smoothstep(0.993, 0.999, 1. - length(p - cmtStartPt)) + \n             Line(p, cmtStartPt, cmtStartPt+vec2(.06)*cmtVel,  0.009, 0.003)) +\n             vec3(1., .7, .2) * .33 * Line(p, cmtStartPt,         cmtEndPt,        0.003, .0003) +          \n             vec3(1., .5, .1) * .33 * Line(p, cmtStartPt+dlt,     cmtEndPt+dlt*2., 0.002 ,.0002) +         \n             vec3(1., .3, .0) * .33 * Line(p, cmtStartPt+dlt+dlt, cmtEndPt+dlt*4., 0.001, .0001)) \n             * (bright) * q;\n}\n\n\nfloat Circle(vec2 uv, vec2 p) {\n    float dist = length(uv-p);\n    float mask = smoothstep(.3, .29, dist);\n    return mask;\n}\n\nvec3 Moon(vec2 uv) {\n    uv *= 2.;\n    vec3 col = vec3(0.);\n    \n    vec2 p = vec2(1.2, -.5);\n    \n    col += Circle(uv, vec2(0.)-p);\n    col -= Circle(uv, vec2(.08)-p);\n    return col;\n}\n\nfloat Star(vec2 gv, float dist){\n    gv *= 1.9;\n    \n    float brigthness = .005;\n    brigthness *= sin(fract(iTime)*10.)*.5+.5;\n    \n    float star = brigthness/dist;\n    \n    float rays = max(0., 1.-abs(gv.x*gv.y*1000.));\n    star += rays;\n    \n    gv *= Rotate(gv, .8);\n    \n    rays = max(0., 1.-abs(gv.x*gv.y*1000000.));\n    star += rays;\n    \n    star *= smoothstep(.2, .1, dist);\n    \n    return star * .3;\n}\n\nvec3 Stars(vec2 uv) {\n    uv *= 6.;\n    \n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    vec3 col = vec3(0.);\n\n    for (float y = -1.; y <= 1.; y ++)\n    {\n        for(float x = -1.; x <= 1.; x++)\n        {\n            vec2 offset = vec2(x,y);\n            float n = R21(id + offset);\n            \n            float dist = length(gv-offset-n);\n            \n            //float blink = sin(fract(iTime)*10.+ n)*.5+.5;\n            col += Star(gv-offset-n, dist);// * blink;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    col += Stars(uv);\n    col += Moon(uv);\n    col += Comet(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 94], [96, 96, 116, 116, 216], [218, 218, 273, 273, 533], [535, 535, 555, 555, 1856], [1859, 1859, 1890, 1890, 1984], [1986, 1986, 2006, 2006, 2173], [2175, 2175, 2207, 2207, 2590], [2592, 2592, 2613, 2613, 3117], [3119, 3119, 3176, 3176, 3404]], "test": "untested"}
{"id": "slSGDV", "name": "twisting log spiral", "author": "morisil", "description": "I generalized some previous sketches", "tags": ["spiral", "polar"], "likes": 4, "viewed": 169, "published": "Public API", "date": "1624720586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float LOG_SCALE_MAX = 50.;\nconst float LOG_SCALE_PERIOD = .4;\nconst float ANGLE_SCALE = 20.;\nconst float ROTATION_SPEED = 30.;\n\n#define wave(x) (sin(x) + 1.) / 2.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    float angle = atan(st.x, st.y);\n    float logDist = log(dist);\n    float logScale = sin(iTime * LOG_SCALE_PERIOD) * LOG_SCALE_MAX;\n    float luma = wave(\n        logDist * logScale + angle * ANGLE_SCALE - iTime * ROTATION_SPEED\n    );\n    fragColor = vec4(vec3(luma), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 225, 225, 633]], "test": "untested"}
{"id": "slSGWd", "name": "1D cubic bezier demo", "author": "yunhai", "description": "~", "tags": ["try"], "likes": 2, "viewed": 52, "published": "Public", "date": "1624966017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS(a,b,t) smoothstep(a,b,t)\n#define SL(d) smoothstep(HLW*.4+.01,HLW*.4-.01,d)\n#define iR iResolution.xy\n#define PIXW (10./iR.x)\n#define LWF(y) (normalize(vec2(PIXW,dFdx(y))).x)\nconst float PI=3.14159265;\nconst int MAX_FUNCTION_NUM=10;\n//---------------------Lines-------------------\nconst float HLW=.05;//half line width\nconst float MSI=1.;//mesh space interval\nfloat lineSeg(vec2 uv,vec2 start,vec2 end)\n{\n    vec2 sp=uv-start;\n    vec2 se=end-start;\n    vec2 closp=clamp(dot(sp,se)/dot(se,se),0.,1.)*se+start;\n    return SL(length(uv-closp));\n}\nfloat line(vec2 uv,vec2 ori,vec2 dir)\n{\n    vec2 sp=uv-ori;\n    vec2 closp=dot(sp,dir)*dir+ori;\n    return SL(length(uv-closp));\n}\n//----------------------------------------------\nvec3 cartesian(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float msp=MSI;\n    float lhlw=HLW/2.;//local HLW\n    vec3 mesh=vec3(SS(lhlw,lhlw-.005,abs(uv.x-round(uv.x/msp)*msp)));\n    mesh+=vec3(SS(lhlw,lhlw-.005,abs(uv.y-round(uv.y/msp)*msp)));\n    col+=mesh*.5;\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(0.,1.)));\n    return col;\n}\nvec3 palette(float t)//Color Palette\n{\n    t*=1.732;\n    return vec3(.7)+vec3(.3)*cos(2.*PI*(vec3(.71,.31,.21)*t+vec3(.2,.4,.6)));\n}\n//-------------------experiment-----------------\nfloat cubicBezier(float a,float b,float c,float d,float t)\n{\n    float abt=mix(a,b,t),bct=mix(b,c,t),cdt=mix(c,d,t);\n    return mix(mix(abt,bct,t),mix(bct,cdt,t),t);\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv= (C-.5*iResolution.xy)/iResolution.y;\n    uv*=10.;uv.x+=8.;\n    float x=uv.x,y=uv.y,t=iTime*.5;\n    O.rgb+=cartesian(uv)*palette(uv.x*.1);    \n    \n    //--------------func output------------\n    float p1=0.,p2=sin(t)*10.,p3=sin(t*2.+PI),p4=1.;\n    float y1=cubicBezier(p1,p2,p3,p4,x*.1);\n    O.rgb=mix(O.rgb,palette(0.3)*.8+.2,SL(abs(y-y1)*LWF(y1)));\n    \n    #define DP(c,y,i) O.rgb=mix(O.rgb,pow(palette(c),vec3(.5)),SS(.14,.1,length(uv-vec2(i,y))))\n    DP(23.,p1,0);\n    DP(4.9,p2,1);\n    DP(2.6,p3,2);\n    DP(.85,p4,3);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 370, 414, 414, 554], [555, 555, 594, 594, 685], [686, 735, 760, 760, 1134], [1135, 1135, 1173, 1173, 1267], [1268, 1317, 1377, 1377, 1484], [1485, 1485, 1526, 1526, 2075]], "test": "untested"}
{"id": "slX3W2", "name": "Graph Plot", "author": "carlosbaraza", "description": "Plotting a graph with AA", "tags": ["plot"], "likes": 4, "viewed": 133, "published": "Public", "date": "1622850772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nfloat lineWidth = 0.01;\nfloat DELTA = 0.005;\n\nfloat plot(vec2 uv, vec2 p, vec2 pDelta){\n  vec2 delta = pDelta - p;\n  float cosPhi = delta.x / length(delta); //cos(atan(delta.y, delta.x));\n  float height = lineWidth / 2.0 / cosPhi;\n  return abs(uv.y - p.y) - height;\n}\n\n\nfloat f(float x) {\n   float a = sin(x * 20.0 + iTime) * .5;\n   a += sin(x * 24.0 + iTime * 3.5) * .5;\n   a *= .3;\n   return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1.0 to 1.0)\n    vec2 uv = (fragCoord/iResolution.xy - .5) * 2.0;\n\n    vec2 p = vec2(uv.x, f(uv.x));\n    vec2 pDelta = vec2(uv.x + DELTA, f(uv.x + DELTA));\n\n    float d = plot(uv, p, pDelta);\n    vec3 col = smoothstep(0.0, 0.01, d) * vec3(1.0, 1.0, 1.0); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 111, 111, 291], [294, 294, 312, 312, 422], [424, 424, 481, 536, 837]], "test": "untested"}
{"id": "slX3WX", "name": "Raytraced 3D Truchet Pattern", "author": "oneshade", "description": "More voxel traversing. Maybe now I'll be motivated to improve my torus intersector? :P", "tags": ["3d", "raytracing", "torus", "truchet", "pattern", "voxeltraversal"], "likes": 10, "viewed": 133, "published": "Public", "date": "1622970197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Intersect {\n    vec3 nor;\n    vec2 uv;\n    float t;\n};\n\n// The heart of the truchet pattern...\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nvoid updateRoot(inout vec2 old, in vec2 new) { if (abs(new.y) < abs(old.y)) old = new; }\nint iTorus(in vec3 ro, in vec3 rd, in float radius, in float thickness, inout vec4 roots) {\n    float rr = radius * radius, rr4 = 4.0 * rr;\n    float qa = dot(rd, rd), qb = 2.0 * dot(ro, rd), qc = dot(ro, ro) + rr - thickness * thickness;\n\n    float a = qa * qa;\n    float b = 2.0 * qa * qb / a;\n    float c = (2.0 * qa * qc + qb * qb - rr4 * dot(rd.xz, rd.xz)) / a;\n    float d = (2.0 * qb * qc - 2.0 * rr4 * dot(ro.xz, rd.xz)) / a;\n    float e = (qc * qc - rr4 * dot(ro.xz, ro.xz)) / a;\n\n    // Quartic solver based on https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/auckly29.pdf\n    float bb = b * b;\n    float p = c - 3.0 * bb / 8.0;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + 0.0625 * bb * c - 3.0 * bb * bb / 256.0;\n\n    // Factoring the quartic into two quadratics using the solution to a cubic\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n\n    float d0 = ra * ra - 3.0 * rb;\n    float d1 = (2.0 * ra * ra - 9.0 * rb) * ra - 27.0 * q * q;\n    float h = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(h));\n\n    vec2 C = h < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) < 1e-3 && abs(C.y) < 1e-3) C = h < 0.0 ? vec2(d1, -j) : vec2(d1 - j, 0.0); // Switch sign if C=0\n    vec2 polar = vec2(atan(C.y, C.x) / 3.0, pow(0.25 * dot(C, C), 1.0 / 6.0)); // ---v\n    C = vec2(cos(polar.x), sin(polar.x)) * polar.y; // De Moivre's formula <---------<\n\n    vec2 root = vec2(1e20);\n    vec2 m1 = mat2(C, -C.y, C.x) * eta, m2 = mat2(C, C.y, -C.x) * eta; // Complex multiplication using matrices\n    updateRoot(root, (vec2(-d0, d0) *  C / dot( C,  C) - vec2( C.x + ra,  C.y)) / 3.0);\n    updateRoot(root, (vec2(-d0, d0) * m1 / dot(m1, m1) - vec2(m1.x + ra, m1.y)) / 3.0);\n    updateRoot(root, (vec2(-d0, d0) * m2 / dot(m2, m2) - vec2(m2.x + ra, m2.y)) / 3.0);\n\n    // Solve for the roots of the factors\n    int n = 0; // Root counter\n    float lambda = root.x;\n    if (lambda < 0.0) return 0;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// align 0: x aligned, align 1: y aligned, align 2: z aligned\nvoid addTorus(inout Intersect isect, in vec3 ro, in vec3 rd, in float radius, in float thickness, in vec3 pos, in int align) {\n    if (align == 0) ro = ro.yxz, rd = rd.yxz, pos = pos.yxz;\n    if (align == 2) ro = ro.xzy, rd = rd.xzy, pos = pos.xzy;\n\n    vec4 roots;\n    int nroots = iTorus(ro - pos, rd, radius, thickness, roots);\n\n    // Optimizing things to be out of the loop hasn't worked yet...\n    for (int idx=0; idx < nroots; idx++) { // All intersections need to be checked against the cell boundaries\n        vec3 hitPos = ro + rd * roots[idx];\n        if (roots[idx] > 0.0 && (isect.t > 0.0 ? roots[idx] < isect.t : true) &&\n            all(lessThan(abs(hitPos), vec3(0.5)))) {\n            hitPos -= pos;\n            float r = length(hitPos.xz);\n            isect.nor = normalize(vec3(hitPos.xz - normalize(hitPos.xz) * radius, hitPos.y)).xzy;\n            isect.nor = align == 0 ? isect.nor.yxz : align == 1 ? isect.nor : isect.nor.xzy;\n            isect.uv = vec2(atan(hitPos.z, hitPos.x), atan(hitPos.y, r - radius));\n            isect.t = roots[idx];\n        }\n    }\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash33(in vec3 p) {\n\tp = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p += dot(p, p.yxz + 33.33);\n    return fract((p.xxy + p.yxx) * p.zyx);\n}\n\nfloat sign2(in float x) { return x < 0.0 ? -1.0 : 1.0; } // Nonzero sign\nIntersect gridCell(in vec3 ro, in vec3 rd, in vec3 pos) {\n    ro -= pos;\n\n    vec3 rand = Hash33(pos) - 0.5;\n    vec3 flip = vec3(sign2(rand.x), sign2(rand.y), sign2(rand.z));\n\n    // Scramble the cell\n    ro *= flip;\n    rd *= flip;\n\n    // Arrange three tori connecting the three pairs of faces\n    Intersect isect = Intersect(vec3(0.0), vec2(0.0), -1.0);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3( 0.0, -0.5,  0.5), 0);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3( 0.5,  0.0, -0.5), 1);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3(-0.5,  0.5,  0.0), 2);\n\n    // Flip normal back into world space\n    isect.nor *= flip;\n\n    return isect;\n}\n\n// Learning from https://github.com/cgyurgyik/fast-voxel-traversal-algorithm/blob/master/overview/FastVoxelTraversalOverview.md\nIntersect traverse(vec3 ro, vec3 rd) {\n    vec3 invRd = 1.0 / rd, octant = sign(rd);\n    vec3 voxel = floor(ro) + 0.5;\n    vec3 corner = 0.5 * octant - ro;\n    for (int iter=0; iter < 15; iter++) {\n        Intersect cell = gridCell(ro, rd, voxel);\n        if (cell.t > 0.0) return cell;\n        vec3 tMax = (voxel + corner) * invRd; // Intersection with the cell boundaries\n        voxel += step(0.0, min(tMax.x, min(tMax.y, tMax.z)) - tMax) * octant; // Step in the direction of the nearest one\n    }\n\n    return Intersect(vec3(0.0), vec2(0.0), -1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, -iTime);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    Intersect hit = traverse(ro, rd);\n    //Intersect hit = gridCell(ro, rd, vec3(0.0)); // Grid cell debugging\n\n    // Render\n    if (hit.t > 0.0) {\n        float diff = abs(dot(hit.nor, normalize(mix(normalize(vec3(-1.0, 1.0, 1.0)), hit.nor, 0.5))));\n        float checker = 0.5 + 0.5 * mod(floor(hit.uv.x / 6.28 * 32.0) + floor(hit.uv.y / 3.14 * 3.0), 2.0);\n        fragColor.rgb = mix(vec3(checker, 0.0, 0.0), vec3(0.0), 1.0 - exp(-hit.t * 0.15)) / max(1.0, 0.125 * hit.t); // Fog\n        fragColor.rgb *= diff;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 143, 189, 189, 231], [232, 232, 323, 323, 2750], [2752, 2814, 2940, 2940, 3896], [3898, 3987, 4011, 4011, 4133], [4135, 4135, 4160, 4160, 4191], [4192, 4208, 4265, 4265, 4852], [4854, 4982, 5020, 5020, 5536], [5538, 5538, 5593, 5593, 6654]], "test": "untested"}
{"id": "slXGDB", "name": "2d landscape-v-2", "author": "jorge2017a1", "description": "2d landscape-v-2", "tags": ["2dlandscapev2"], "likes": 5, "viewed": 182, "published": "Public API", "date": "1622729866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1...jorge flores p.\n//referencia\n//https://www.shadertoy.com/view/XsG3WR......//Created by Hamneggs in 2016-01-27\n//https://www.shadertoy.com/view/wldcWr  ....//Created by TheNosiriN in 2020-12-25\n//https://www.shadertoy.com/view/ttVfWG .....//Created by Plento in 2021-03-06\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define PI 3.14\n#define roundnes 0.025\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n// Channel definitions.\n#define DATA_BUFFER iChannel0\n#define NOISE_TEX iChannel1\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\n\n// Noise stuff\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm2(vec2 n, float t){\n\tfloat sum = 0.0, amp = 1.0;\n\tfor (int i = 0; i < 10; i++){\n        n.x += t;\n\t\tsum += noise(n) * amp;\n\t\tn += n;\n\t\tamp *= 0.5;\n\t}\n\treturn sum;\n}\n\n//https://www.shadertoy.com/view/XsG3WR\n//Lunar Lander\n//Created by Hamneggs in 2016-01-27\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n\nvec3 Lunar(vec2 p, vec3 col, vec3 colTierraA,vec3 colTierraB)\n{\n     float dl1=distLunarSurface(p);\n     float dl2=distLunarSurface(p-vec2(0.001,0.0125));\n     \n     col= ponerBorde2(colTierraA, col, dl2 );\n     col= ponerBorde2(colTierraB, col, dl1 );\n     \n     \n     return col;\n}\n\n\n\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat star(vec2 uv, float time, float flare)\n{\n\tfloat d = length(uv);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= rotate(45.0);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*0.5*flare;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 hash23( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n\nfloat starFieldMin(vec2 p)\n{\n    vec3 rnd = hash23(p * iResolution.x);\n    float intensity = pow((1.+sin((iTime+27.0)*rnd.x))*.5, 7.) ;\n    return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n\n\n//Shader try of StarofBethlehem\nfloat starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    float colf=0.0;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float size = min(0.25, fract(n*1234.567) + 0.1);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246), smoothstep(.9, 1., size)*.6);\n            \n            colf += star * size;\n        }\n    }\n    \n    return colf;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 nv=uv;\n    vec2 p=uv*0.5+vec2(0.0+iTime*0.05,0.125);\n    \n    \n    // Noise for clouds and fuselage\n    float nse = fbm2(5.*vec2(uv.x, uv.y*14.5), 0.)-.5;\n    float nse2 = fbm2(nv*4., iTime*.14)-.5;\n    float nse3= fbm2(p*4., 0.14)-.5;\n    \n    vec3 cloud = vec3(nse2)*0.7;\n    \n    \n    // Bg color\n    vec3 col = mix(vec3(.7, .8, .99), vec3(.8, .8, .8), nv.y) + cloud*cloud*.5;\n     col= mix(vec3(0.125), vec3(.2, .2, .8), nv.y) + col*cloud*.5;\n     col += (starField(uv*50.0)) + starFieldMin(uv)*2.0;\n     \n     col=Lunar(p-vec2(0.0,-0.05),col,vec3(1.0),vec3(0.8,0.5,0.35) *nse3);\n     \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[710, 794, 854, 854, 980], [982, 982, 1043, 1043, 1167], [1171, 1186, 1205, 1205, 1274], [1275, 1275, 1295, 1295, 1493], [1494, 1494, 1522, 1522, 1667], [1669, 1824, 1849, 1849, 2154], [2157, 2157, 2195, 2195, 2290], [2293, 2293, 2356, 2356, 2576], [2581, 2581, 2607, 2607, 2705], [2707, 2707, 2753, 2753, 3060], [3065, 3065, 3087, 3087, 3181], [3183, 3183, 3207, 3207, 3398], [3401, 3401, 3429, 3429, 3594], [3597, 3629, 3655, 3655, 4212], [4215, 4215, 4272, 4322, 5003]], "test": "untested"}
{"id": "slXGWs", "name": "Variable Checkerboard Farini2", "author": "Farini", "description": "Variable Checkerboard", "tags": ["checkerboard"], "likes": 3, "viewed": 40, "published": "Public", "date": "1623089650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 0.8\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;    \n    vec2 u = fragCoord/iResolution.y;    \n    float t = iTime * SPEED;\n    uv*=8.0;\n    \n    // uv.x+=t*0.1; // uncomment to move tiles in x axis\n    vec2 c = vec2(0.5);\n    vec2 fu = mod(uv,2.0)*0.5;\n    uv = fract(uv)+step(fu.yx,vec2(.5))-0.5;\n    \n    // uv.x-=fu.x-0.5;\n    //uv.y-=fu.y-0.5;\n    float d = length(1.0*uv-.5);\n    \n    float smooth1 = 0.05;\n    float smooth2 = 20.25;\n    float smoothd = d * 20.;\n    float m = smoothstep(smooth1,smooth2,smoothd);\n    \n    uv -= c;\n    vec2 e = vec2(1., 1.);//sin(u+.5)*1.1415;\n    float f = e.x;\n    \n    float angle = cos(atan(uv.x,uv.y))*1.0;\n    float k = 0.5+sin((t+m)+u.x+angle*.15)*.5;\n    O = vec4(k);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 68, 68, 776]], "test": "untested"}
{"id": "st23DW", "name": "- Tower of Squares -", "author": "Mihaha", "description": "Just a bunch of Spinning Squares", "tags": ["lines", "vignette", "rotation", "figures", "recs"], "likes": 5, "viewed": 66, "published": "Public", "date": "1623956279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n> by MihasGames, 17.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nfloat sum(vec2 v) { return v.x + v.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    float map = 3., \n          t = iTime;\n    \n    // Pixel Normalizations //\n    vec2 uv101 = fragCoord.xy/iResolution.xy - 0.5,\n         uv = uv101*map * vec2(iResolution.x / iResolution.y, 1);\n    \n    if (cos(sum(uv*20. + vec2(-t*4., 0))) > 0.98) col = vec3(0.85); // Lines //\n    \n    // Tower //\n    int rCount = 30;\n    for (int i = -rCount/2; i < rCount; i++) {\n        float r = t*3. + float(i)/float(rCount) * pow(sin(t), 2.)*5.; // Angle of Rotation\n        vec2 rectUv = ((uv+vec2(0, float(i)/float(rCount)*2.5-0.45))/vec2(1, cos(45.))) * mat2( cos(r), -sin(r), sin(r), cos(r) );\n\n        if (sum(abs(rectUv)) < 1. && sum(abs(rectUv)) > 0.9) col = vec3(uv101*vec2(5., 2.), 1.); // Filling the Contours of Squares\n        if (sum(abs(rectUv)) < 0.9) col = vec3(1.); // Filling inside\n    }\n    \n    col *= (1. - length(uv101/2.))*1.15; // Vignette //\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 89, 89, 109], [111, 111, 168, 168, 1092]], "test": "untested"}
{"id": "st23z1", "name": "Warping Grid", "author": "oneshade", "description": "Warped.", "tags": ["texture", "warp", "bilinear", "piecewise"], "likes": 13, "viewed": 165, "published": "Public", "date": "1623388309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 4.0\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 10.0 - 5.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Get UV coordinates in a bilinear patch (requires solving a quadratic)\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nbool iBilinear(in vec2 xy, in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec4 uv) {\n    vec2 p = a - b + c - d;\n    vec2 q = b - a, r = d - a;\n\n    float c1 = cross2D(r, p);\n    float c2 = cross2D(r, q) + cross2D(a, p) + cross2D(p, xy);\n    float c3 = cross2D(a, q) + cross2D(q, xy);\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        uv.yw = (vec2(-1.0, 1.0) * sqrt(discr) - c2) / c1 * 0.5;\n        uv.xz = (xy.x - a.x - r.x * uv.yw) / (p.x * uv.yw + q.x);\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * SCALE;\n    float unit = 2.0 * SCALE / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 cell = floor(uv);\n    vec2 centerPoint = getPoint(cell);\n    for (int i=-1; i <= 1; i++) {\n        for (int j=-1; j <= 1; j++) {\n            if (abs(i) != abs(j)) {\n                // Draw lines to the right, left, top, and bottom cell points\n                vec2 edgePoint = getPoint(cell + vec2(i, j));\n                color += smoothstep(unit, 0.0, sdLine(uv, centerPoint, edgePoint));\n            }\n\n            if (i <= 0 && j >= 0) {\n                vec4 patchUv;\n\n                // Cells and their vertices\n                vec2 c1 = cell + vec2(i    , j - 1), v1 = getPoint(c1);\n                vec2 c2 = cell + vec2(i + 1, j - 1), v2 = getPoint(c2);\n                vec2 c3 = cell + vec2(i + 1, j    ), v3 = getPoint(c3);\n                vec2 c4 = cell + vec2(i    , j    ), v4 = getPoint(c4);\n\n                // Draw the current warped cell\n                if (iBilinear(uv, v1, v2, v3, v4, patchUv)) {\n                    if (all(lessThan(abs(patchUv.zw - 0.5), vec2(0.5)))) {\n                        vec2 texUv = (iResolution.y / SCALE * (c1 + patchUv.zw) + center) / iResolution.xy;\n                        color += texture(iChannel0, texUv).rgb;\n                    }\n                }\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 60, 86, 86, 172], [174, 199, 228, 228, 511], [513, 513, 560, 560, 668], [670, 743, 780, 780, 812], [813, 813, 898, 898, 1344], [1346, 1346, 1401, 1401, 2853]], "test": "untested"}
{"id": "st23zw", "name": "Shine On", "author": "emodeman", "description": "A morphing crystaline thingy.", "tags": ["noise", "fbm", "perlin"], "likes": 1, "viewed": 87, "published": "Public", "date": "1623620334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A tweaked version of https://www.shadertoy.com/view/ll2GRt\n// with https://www.shadertoy.com/view/XtGyDR in the background\n\nvec3 MIX(vec3 x, vec3 y)\n{\n    return abs(x - y);\n}    \n\nfloat CV(vec3 c, vec2 uv)\n{\n    float size = 640.0 / iResolution.x * 0.003;\n    return 1.0 - clamp(size * (length(c.xy - uv) - c.z), 0.0, 1.0);\n}\n\nvec3 crystal(vec2 fc)\n{\n    vec3 O = vec3(0.0);\n    vec3 c;\n    for (float i = 0.0; i < 60.0; i += 4.5)\n    {\n        c = vec3(sin(i * 0.57 +  7.0 + iTime * 0.7),\n\t\t         sin(i * 0.59 - 15.0 - iTime * 0.65),\n\t\t         sin(i * 0.60        + iTime * 0.9)\n\t\t         ) * 0.75 + 0.75;\n        O = MIX(O, c * CV(vec3(sin(iTime * 0.50 + i / 4.5) * (iResolution.x / 2.0 - 60.0) + iResolution.x / 2.0,\n\t\t\t                   sin(iTime * 0.73 + i / 3.0) * (iResolution.y / 2.0 - 60.0) + iResolution.y / 2.0,\n\t\t\t                   0.0),\n \t\t                  fc));\n    }\n    return O;\n}\n\nmat2 rot2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat r(float a, float b)\n{\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat h(float a)\n{\n    return fract(sin(dot(a, dot(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p  = floor(x);\n    vec3 f  = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    return mix(mix(mix(h(n), h(n + 1.0), f.x),\n                   mix(h(n + 57.0), h(n + 58.0), f.x), f.y),\n               mix(mix(h(n + 113.0), h(n + 114.0), f.x),\n                   mix(h(n + 170.0), h(n + 171.0), f.x), f.y), f.z);\n}\n\n// http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n// http://www.pouet.net/topic.php?post=401468\nvec3 dnoise2f(vec2 p)\n{\n    float i = floor(p.x), j = floor(p.y);\n    float u = p.x - i, v = p.y - j;\n    float du = 30.0 * u * u * (u * (u - 2.0) + 1.0);\n    float dv = 10.0 * v * v * (v * (v - 2.0) + 1.0);\n    u = u * u * u * (u * (u * 6.0 - 25.0) + 10.0);\n    v = v * v * v * (v * (v * 6.0 - 15.0) + 10.0);\n    float a = r(i, j);\n    float b = r(i + 1.0, j);\n    float c = r(i, j + 1.0);\n    float d = r(i + 1.0, j + 1.0);\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n    return vec3(k0 + k1 * u + k2 * v + k3 * u * v,\n                du * (k1 + k3 * v),\n                dv * (k2 + k3 * u));\n}\n\nfloat fbm(vec2 uv)\n{               \n    vec2 p = uv;\n    float f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for (int i = 0; i < 28; ++i)\n    {        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx * dx + dz * dz);\n        w *= 0.86;\n        uv *= vec2(1.16);\n        uv *= rot2d(1.25 * noise(vec3(p * 0.1, 0.12 * iTime)) +\n                    0.75 * noise(vec3(p * 0.1, 0.20 * iTime)));\n    }\n    return f;\n}\n\nfloat fbmLow(vec2 uv)\n{\n    float f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx * dx + dz * dz);\n        w *= 0.75;\n        uv *= vec2(1.5);\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 1.0 - 2.0 * (fragCoord / iResolution.xy);\n    uv.y /= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    \n    vec2 rv = uv / (length(uv * 2.5) * (uv * 30.0));\n    uv *= rot2d(0.3 * t);\n    float val = 0.5 * fbm(uv * 2.0 * fbmLow(length(uv) + rv - t));\n    uv *= rot2d(-0.6 * t);\n\n    float fc = 0.5 * fbm(uv * val * 8.0) + 0.02 * r(uv.x, uv.y);\n    vec3 fragC = 1.6 * vec3(fc);   \n    fragC *= 3.8;\n    fragC = fragC / (1.0 + fragC);\n    fragC = smoothstep(0.18, 0.88, fragC);\n    fragC = pow(fragC, crystal(fragCoord));\n    fragColor = vec4(fragC, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 153, 153, 178], [184, 184, 211, 211, 329], [331, 331, 354, 354, 909], [911, 911, 936, 936, 1004], [1006, 1006, 1033, 1033, 1111], [1113, 1113, 1131, 1131, 1199], [1201, 1201, 1222, 1222, 1585], [1587, 1699, 1722, 1722, 2342], [2344, 2344, 2364, 2364, 2810], [2812, 2812, 2835, 2835, 3119], [3121, 3121, 3176, 3176, 3758]], "test": "untested"}
{"id": "st2GR1", "name": "Vorochet I", "author": "oneshade", "description": "WIP", "tags": ["voronoi", "truchet", "tiling", "connections"], "likes": 9, "viewed": 66, "published": "Public", "date": "1623379230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat Hash31(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float time = 2.0;//iTime\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = time * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\n// https://www.shadertoy.com/view/7dSSW1\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x * n1.y - n0.y * n1.x; // 0 if paralelle but does not append here\n    vec2 p = (p0 - p1) / d;\n    return vec2(p.y * n1.x - p.x * n1.y, p.y * n0.x - p.x * n0.y);\n}\n\nvec2[8] getVoronoiPolygon(in vec2 cellId, out int out_sz) {\n\tvec2 rm = getPoint(cellId); // center of cell\n    vec2 c[8], n[8];\n    // Get liste of lines\n    for(int i=0; i < 8; i++) {\n        vec2 g0 = ID_POS(i),\n             r0 = getPoint(cellId + g0),  // centre de l'autre cellule\n             n0 = r0 - rm;\n         c[i] = rm + n0*.5;  // Pt entre les 2 cellules             \n         n[i] = normalize(vec2(-n0.y,n0.x));\n    }\n\n    // Find intersection between lines\n    vec4 seg[8]; // x:-2 y:-1 z:+1 w:+2  \n    for(int i=2; i < 10; i++) { // Intersection point with two previous lines\n        vec2 t1 = intersect(c[i % 8], n[i % 8], c[(i - 1) % 8], n[(i - 1) % 8]),\n             t2 = intersect(c[i % 8], n[i % 8], c[(i - 2) % 8], n[(i - 2) % 8]);\n        seg[i % 8].x = t2.x;     // -2 of seg  0\n        seg[i % 8].y = t1.x;     // -1 of seg  0\n        seg[(i - 1) % 8].z = t1.y; // +1 of seg -1\n        seg[(i - 2) % 8].w = t2.y; // +2 of seg -2      \n    }\n\n    // Reconstruct the polygon\n    out_sz = 0;\n    for(int i=0; i<8; i++) {\n        float dmin = max(seg[i].z, seg[i].w);\n        if (dmin < min(seg[i].x, seg[i].y)) { // skip useless segments\n            n[out_sz] = c[i] + dmin * n[i];\n            out_sz++;\n        }\n    }\n\n    return n;\n}\n\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = mix(2.0, 10.0, 0.5 + 0.5 * cos(0.25 * iTime));\n    float fade = 0.5 + 0.5 * sin(iTime);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * zoom + 0.5 * iTime;\n    float unit = 2.0 * zoom / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 cell = floor(uv), closest;\n    float minDist = 1e20;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            vec2 toCurPoint = uv - curPoint;\n            float curDist = dot(toCurPoint, toCurPoint);\n            if (curDist < minDist) { closest = curPoint; minDist = curDist; }\n        }\n    }\n\n    int numVerts;\n    vec2 closestCell = floor(closest);\n    vec2[8] voroPoly = getVoronoiPolygon(closestCell, numVerts);\n    for (int n=0; n < numVerts; n++) {\n        int randEdge = int(Hash31(vec3(closestCell, n)) * float(numVerts));\n        if (randEdge == n) randEdge = (randEdge + 1) % numVerts;\n\n        vec2 rand1 = voroPoly[randEdge], rand2 = voroPoly[(randEdge + 1) % numVerts];\n        vec2 v1 = voroPoly[n], v2 = voroPoly[(n + 1) % numVerts];\n\n        vec2 nor1 = normalize(v2 - v1).yx * vec2(-1.0, 1.0);\n        vec2 nor2 = normalize(rand2 - rand1).yx * vec2(-1.0, 1.0);\n\n        vec2 a = 0.5 * (v1 + v2), c = 0.5 * (rand1 + rand2);\n        vec2 b = a + nor1 * (c.y * nor2.x - c.x * nor2.y + nor2.y * a.x - nor2.x * a.y) / (nor1.y * nor2.x - nor1.x * nor2.y);\n        //vec2 b = 0.5 * (a + c) + normalize(c - a).yx * vec2(1.0, -1.0);\n        //vec2 b = closest;\n\n        color = max(color, vec3(smoothstep(unit, 0.0, sdBezier(uv, a, b, c))));\n        color.b = max(color.b, smoothstep(unit, 0.0, sdLine(uv, v1, v2) - 0.01) * fade);\n    }\n\n    color.rg = max(color.rg, 0.6 * Hash22(closestCell) * fade);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 67, 67, 153], [155, 155, 180, 180, 275], [277, 277, 301, 301, 436], [438, 463, 492, 492, 802], [804, 915, 967, 967, 1148], [2410, 2410, 2473, 2473, 3686], [3688, 3688, 3735, 3735, 3843], [3845, 3845, 3900, 3900, 5705]], "test": "untested"}
{"id": "st2GRc", "name": "Bismuth crystals 3", "author": "jarble", "description": "These patterns remind me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 4, "viewed": 163, "published": "Public API", "date": "1624424020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.15;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/2.)/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (-uv-vec2(uv.x/scale+uv.y/scale1,uv.y/scale+uv.x/scale1)/scale)/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx-s1);\n            uv.y /= scale1;\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.8;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 704]], "test": "untested"}
{"id": "st2GRy", "name": "大龙猫 - Quicky#056", "author": "totetmatt", "description": "Quciky", "tags": ["quicky"], "likes": 11, "viewed": 209, "published": "Public API", "date": "1624191541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fGlobalTime iTime\nfloat box(vec2 p,vec2 b){\n    vec2 q = abs(p) -b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat sdCross( in vec3 p ) // From IQ \n{\n  float da = box(p.xy,vec2(.1));\n  float db = box(p.yz,vec2(0.1));\n  float dc = box(p.zx,vec2(0.1));\n  return min(da,min(db,dc));\n}\nfloat diam(vec3 p,float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*sqrt(1./3.);\n  }\nvec2 sdf(vec3 p){\n  //p.xy*=rot(fGlobalTime);\n  vec3 pp=p;\n    vec2 h;\n    \n  // p.x +=.2;\n    for(float i=0.;i<=3.;i++){\n        p = abs(p)-2.8655;\n      //p*=1.05;\n        p.xz*=rot(-.785);\n         p.xy = p.x < p.y ? p.yx:p.xy;\n    }      \n    h.x = min(diam(p,3.),sdCross(p));\n    p= abs(p)-.8;\n    p = asin(sin(p));\n    h.x = max(-(length(p)-1.1),h.x);\n    h.y= fract(p.z) >.25 ? 1.:3.;\n    \n    vec2 t;\n    t.x = diam(pp,1.4);\n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n    return h;\n}\n#define q(s) s*sdf(p+s).x\nvec2 nv=vec2(-.001,.001);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec3 col = vec3(.1);\n  \n  vec3 ro=vec3(sin(fGlobalTime*.1)*3.5,0.75,cos(fGlobalTime*.1)*3.5);\n\t\n  vec3 rt = vec3(0.+sin(fGlobalTime)*.1,0.+cos(fGlobalTime)*.1,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = cross(z,vec3(0.,-1.,0.));\n  vec3 y = cross(z,x);\n  \n  \n  vec3 rd=normalize(mat3(x,y,z)*vec3(uv,1.+sin(fGlobalTime*.1)*.4));\n  vec3 rp = ro;\n  vec3 light = vec3(1.,2.,-3.);\n  \n  float i;\n  const float c=69.;\n  vec3 acc = vec3(0.);\n  float rdp=0.;\n  for(i=0.;i<=c;i++){\n      vec2 d = sdf(rp);\n    \n      if(d.y ==1.) {\n        vec2 vv= vec2(atan(rp.x,rp.z),rp.y);\n        acc += vec3(1.1,.5,.3)*(exp(2.*-abs(d.x))/(10.1+19.*fract(fGlobalTime+texture(iChannel0,vv*.001).r\n)));\n        \n         \n      }\n       if(d.y ==3.) {\n        vec2 vv= vec2(atan(rp.x,rp.z),rp.y);\n        acc += vec3(.1,1.5,1.3)*(exp(2.*-abs(d.x))/(40.1+19.*fract(fGlobalTime+texture(iChannel0,vv*.001).r\n)));\n        \n         d.x = max(.002,abs(d.x));\n      }\n     rp+=rd*d.x;\n      rdp+=d.x;\n      if(d.x <=.001 || rdp>=15.){\n        if(d.y==2.){\n            vec3 n = norm(rp);\n          float fre = pow((1.+dot(rd, n)), 2.);\n            rd = reflect(rd,n+texture(iChannel0,rp.xy*.1+vec2(fGlobalTime*.001)).r);\n            rp+=n*0.002;\n           col +=vec3(.0,.1,.50)*.5+fre*vec3(.3,.5,0.1);\n         \n          }\n        else break;\n        }\n    \n  }\n\n  col +=acc;\n\n    fragColor = vec4(sqrt(col)*col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 134], [136, 136, 154, 154, 201], [202, 202, 242, 242, 374], [375, 375, 402, 402, 458], [459, 459, 476, 504, 946], [999, 999, 1017, 1017, 1076], [1077, 1077, 1134, 1184, 2634]], "test": "untested"}
{"id": "st2GWD", "name": "Lattice [82 chars]", "author": "Xor", "description": "Experiement with fwidth", "tags": ["tiny"], "likes": 11, "viewed": 93, "published": "Public", "date": "1623940825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 I)\n{\n    O = fwidth(vec4(int(++I)&int(I.y)+iFrame*2))/32.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 92]], "test": "untested"}
{"id": "stB3D1", "name": "sdfCrossCircle", "author": "a745806106", "description": "sdf painting test", "tags": ["sdf2dpattern"], "likes": 1, "viewed": 114, "published": "Public API", "date": "1623817867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q=uv-vec2(0.5,0.5);\n    q.x*=iResolution.x/iResolution.y;\n    \n    float inputVal=fract(iTime);\n    //inputVal=inputVal*2.0-1.0;\n    inputVal=2.0*sin(iTime);\n    float insertVal=(inputVal+2.0)*0.625-0.5;\n    \n    float curveVal=1.0-abs(2.0*sin(2.0*atan(q.y,q.x)+inputVal));\n    float r=0.3+0.1*insertVal*smoothstep(0.3,1.3,curveVal);\n    r*=abs(inputVal);\n    float Result =smoothstep(r+0.01,r,length(q));\n    \n    // Output to screen\n    fragColor = vec4(0,0.7391,1.0,1.0)*Result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 640]], "test": "untested"}
{"id": "stB3zW", "name": "Volumetric God Rays - Andrew", "author": "andrew741", "description": "A basic scene rendered using ray marching with volumetric shadows also known as god rays. Theres also specular reflection. This is an improvement/revision of my last attempt at god rays and is much better in performance and looks.", "tags": ["raymarching", "godrays", "volumetrics", "volumetricclouds", "specularreflection"], "likes": 6, "viewed": 182, "published": "Public", "date": "1623429624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nA revision of my last attempt, the main difference is that instead of\ngathering the volume info during the ray march, i gather it after by\nfinding the start and end position and create 180 sample points inbetween where\ni gather the volume info. (For the sky i step into the scene by 0.2 160\ntimes to gather the volume info).\n*/\n\n\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat Dimple(vec3 p)\n{\n    return min(p.y + 10., 1. - (abs(length(p.xz) / max((p.y + 5.) / 10., 1.)) - 15.));\n}\n\n\nfloat Boxes(vec3 p)\n{\n    return sdBox(abs(p) - vec3(10., 0., 10.), vec3(1., 15., 1.));\n}\n\n\nfloat GetDst(vec3 p)\n{\n    float dst1 = length(p) - 2.5;\n    float dst2 = Dimple(p);\n    float dst3 = Boxes(p);\n    \n    return min(min(dst1, dst2), dst3);\n}\n\n\nvec4 GetCol(vec3 p)\n{\n    float dst1 = length(p) - 2.;\n    float dst2 = Dimple(p);\n    float dst3 = Boxes(p);\n    \n    float dst = min(min(dst1, dst2), dst3);\n    \n    if (dst == dst1) return vec4(0.2, 0.2, 0.8, 0.);\n    if (dst == dst2) return vec4(0.8, 0.2, 0.8, 1.);\n    if (dst == dst3) return vec4(0.2, 0.8, 0.8, 2.);\n    return vec4(0., 0., 0., -1.);\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;  // * vec2(1., 0.62);\n    vec3 col = vec3(0.);\n\n    vec3 sun_dir = normalize(vec3(sin(iTime), 1.5, cos(iTime)));\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n\n    // from https://www.shadertoy.com/view/WtGXDD (getting ro and rd)\n    vec3 ro = vec3(0, 8, -8);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., 0.), 1.);\n\n    vec3 p = ro;\n    float depth = 0.;\n    bool collided = false;\n    for (int s = 0; s < 125; s++)\n    {\n        float dst = GetDst(p);\n        p += rd * dst;\n        depth += dst;\n        \n        if (dst < 0.01)\n        {\n            collided = true;\n            break;\n        }\n        else if (dst > 35.) break;\n    }\n    if (collided)\n    {\n        vec4 object_col_and_mat = GetCol(p);\n        vec3 object_col = object_col_and_mat.rgb;\n        vec3 normal = GetNormal(p);\n        object_col *= dot(sun_dir, normal) * 0.5 + 0.5;\n        SpecularLight spec = Specular(0.8, normal, rd, sun_dir);\n        object_col += sun_col * spec.highlight;\n\n        float sun_depth = 0.;\n        bool shadow_collided = false;\n        vec3 sp = p + normal * 0.01 * 2.;\n        for (int s = 0; s < 50; s++)\n        {\n            float dst = GetDst(sp);\n            sp += sun_dir * dst;\n            sun_depth += dst;\n            \n            if (dst < 0.01)\n            {\n                shadow_collided = true;\n                break;\n            }\n            else if (sun_depth > 35.) break;\n        }\n        float total_density = 0.;\n        float step_size_f = depth / 180.;\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        for (int s = 0; s < 180; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 75; sr++)\n            {\n                float dst = GetDst(srp);\n                srp += sun_dir * dst;\n                slrd += dst;\n                \n                if (dst < 0.075)\n                {\n                    total_density += 0.15 * step_size_f;\n                    break;\n                }\n                else if (slrd > 25.) break;\n            }\n            dp += step_size;\n        }\n        \n        object_col *= exp(-total_density);\n        object_col *= shadow_collided ? 0.5 : 1.;\n        \n        col = object_col;\n    }\n    else\n    {\n        float total_density = 0.;\n        float step_size_f = 0.175;\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        for (int s = 0; s < 180; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 75; sr++)\n            {\n                float dst = GetDst(srp);\n                srp += sun_dir * dst;\n                slrd += dst;\n                \n                if (dst < 0.075)\n                {\n                    total_density += 0.15 * step_size_f;\n                    break;\n                }\n                else if (slrd > 25.) break;\n            }\n            dp += step_size;\n        }\n        \n        col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n        if (rd.y > 0.) col = mix(col, sun_col * 1.3, min(max(pow(dot(sun_dir, rd), 20.) * 0.7, 0.), 1.));\n        col *= exp(-total_density);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 401, 479, 479, 813], [816, 862, 881, 881, 943], [945, 991, 1041, 1041, 1232], [1235, 1281, 1310, 1310, 1391], [1394, 1394, 1416, 1416, 1505], [1508, 1508, 1529, 1529, 1597], [1600, 1600, 1622, 1622, 1757], [1760, 1760, 1781, 1781, 2118], [2121, 2121, 2145, 2145, 2347], [2350, 2350, 2407, 2407, 5897]], "test": "untested"}
{"id": "stB3zy", "name": "loading animation", "author": "dstratonov", "description": "loading animation", "tags": ["circles", "simple", "animation", "loading"], "likes": 1, "viewed": 76, "published": "Public", "date": "1624123896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float innerRadius = 0.45;\nfloat outterRadius = 0.5;\nfloat segmentAngle = 0.7;\nfloat PI = 3.14;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resultColor = vec3(1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    float pix = 1./iResolution.y;\n    float x = sin(iTime);\n    float y = cos(iTime) * abs(cos(iTime));\n    \n    vec2 movingPoint = vec2(x, y);\n    float distToCenter = distance(uv, vec2(0.5, 0.5));\n    \n    vec2 newUv = uv - vec2(0.5, 0.5);\n    float cosA = dot(newUv, movingPoint) / (length(newUv) * length(movingPoint));\n    segmentAngle *= abs(y);\n    \n    float coefForDist = smoothstep(innerRadius - pix, innerRadius + pix, distToCenter) * smoothstep(distToCenter - pix, distToCenter + pix, outterRadius);\n    float coefForAngle = smoothstep(cosA - pix, cosA + pix, segmentAngle) * smoothstep(-segmentAngle - pix, -segmentAngle + pix, cosA);\n    \n    resultColor = vec3(1.0) * (1.0 - coefForDist * coefForAngle);\n \n    fragColor = vec4(resultColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 991]], "test": "untested"}
{"id": "stBGRV", "name": "Bismuth crystals 2", "author": "jarble", "description": "These patterns reminds me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 9, "viewed": 173, "published": "Public API", "date": "1624249406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.15;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = scale1*scale+uv.y+iTime/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= -fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx/s1)*s1;\n            uv.y /= scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 775]], "test": "untested"}
{"id": "stBGW3", "name": "Types of Voronoi", "author": "DrDesten", "description": "Different Types of Voronoi / Worley Noise\n\n1: Normal Voronoi Noise\n2: Difference between Worley and Voronoi\n3: Worley Noise, 2nd closest\n4: Worley Noise, 4th closest", "tags": ["voronoi", "noise", "random", "worley"], "likes": 4, "viewed": 78, "published": "Public", "date": "1624906559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Controls (Play with these)\n//////////////////////////////////////////////////////////////////\n\n// Increase PROXIMITY_CHECK if you see grid lines\n#define PROXIMITY_CHECK 2\n#define GRID_SIZE 25.\n\n#define ANIMATE\n#define ANIMATION_SPEED 2.\n\n#define RANDOMNESS 1. \n\n//#define COLORIZE\n\nfloat N21(vec2 c) {\n    return fract(sin(c.x*38.+c.y*367.) * 43891.1791);\n}\nvec2 N22(vec2 c) {\n    return vec2(N21(c-5.), N21(c+5.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make UVs Aspect Ratio independant and center at (0,0)\n    vec2 uv  = (fragCoord - iResolution.xy * .5)/iResolution.x;\n    \n    // Calculate Grid UVs (Also center at (0,0))\n    vec2 guv = fract(uv * GRID_SIZE) - .5;\n    vec2 gid = floor(uv * GRID_SIZE);\n \n    vec3 col = vec3(0);\n    \n    float md1 = 1e3;\n    float md2 = 2e3;\n    float md3 = 3e3;\n    float md4 = 4e3;\n    \n    // Check neighboring Grid cells\n    for (int x = -PROXIMITY_CHECK; x <= PROXIMITY_CHECK; x++) {\n        for (int y = -PROXIMITY_CHECK; y <= PROXIMITY_CHECK; y++) {\n        \n            vec2 offset = vec2(x, y);\n            \n            // Get the id of current cell (pixel cell + offset by for loop)\n            vec2 id         = gid + offset;\n            // Get the uv difference to that cell (offset has to be subtracted)\n            vec2 relativeUV = guv - offset;\n            \n            // Get Random Point (adjust to range (-.5, .5))\n            vec2 p          = N22(id) - .5;\n            \n            #ifdef ANIMATE\n                p = vec2(sin(iTime * p.x * ANIMATION_SPEED), cos(iTime * p.y * ANIMATION_SPEED)) * .5;\n            #endif\n            \n            p *= RANDOMNESS;\n            \n            // Calculate Distance bewtween point and relative UVs)\n            float d         = distance(p, relativeUV);\n            \n            \n            if (md1 > d) {\n                md4 = md3;\n                md3 = md2;\n                md2 = md1;\n                md1 = d;\n            } else if (md2 > d) {\n                md4 = md3;\n                md3 = md2;\n                md2 = d;\n            } else if (md3 > d) {\n                md4 = md3;\n                md3 = d;\n            } else if (md4 > d) {\n                md4 = d;\n            }\n            \n        \n        }\n    }\n    \n    vec2 screenUV = (fragCoord / iResolution.xy) - .5;\n    if (uv.x < 0. && uv.y > 0.) {\n    \n        // Normal Voronoi Noise\n        col = vec3(md1 / 1.225);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x - .5), sin(col.x), sin(col.x + 1.1));\n        #endif\n        \n    } else if (screenUV.x > 0. && screenUV.y > 0.) {\n    \n        // Difference between closest and second-closest point\n        col = vec3(md2 - md1);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x + .3), sin(col.x + .05), sin(col.x - .3));\n        #endif\n        \n    } else if (screenUV.x < 0. && screenUV.y < 0.) {\n        \n        // Worley Noise (2nd)\n        col = vec3(md2 / 1.414);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x + .24), sin(col.x + .2), sin(col.x + .1));\n        #endif\n    \n    } else if (screenUV.x > 0. && screenUV.y < 0.) {\n        \n        // Worley Noise (4th)\n        col = vec3(md4 / 1.732);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x - .3), sin(col.x + .2), sin(col.x + .6));\n        #endif\n    \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 285, 304, 304, 360], [361, 361, 379, 379, 420], [423, 423, 480, 541, 3385]], "test": "untested"}
{"id": "stBGWh", "name": "LookingGlass: Plasma Globe", "author": "xjorma", "description": "Original Shader from Nimitz\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["3d", "raymarching", "tutorial", "rays", "plasma", "volumetric", "glass", "looking", "lookingglass"], "likes": 0, "viewed": 71, "published": "Public API", "date": "1623795541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= time*.65*z;\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;\n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, vec3 _ro, vec3 _rd )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = _ro;\n    vec3 brd = _rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.3, 1.0);\n}\n\n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 2.2;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 5.0;  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGWh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[225, 370, 391, 391, 443], [444, 444, 470, 470, 522], [524, 524, 546, 546, 579], [581, 581, 605, 605, 824], [936, 981, 1016, 1016, 1232], [1234, 1254, 1278, 1278, 1474], [1476, 1476, 1513, 1513, 1639], [1641, 1641, 1676, 1676, 1889], [1891, 1891, 1918, 1918, 2205], [2207, 2207, 2288, 2288, 2527], [2529, 2551, 2614, 2614, 3149], [3151, 3197, 3236, 3236, 3424], [3426, 3426, 3503, 3503, 4779], [5037, 5037, 5093, 5093, 5791]], "test": "untested"}
{"id": "stBGzm", "name": "Smooth Voronoi Experiment", "author": "oneshade", "description": "I tried adding a smooth minimum to the voronoi distance and got a neat result to play around with.\nThis is reminding me very much of Shane's shaders...", "tags": ["voronoi", "experiment", "smooth"], "likes": 19, "viewed": 209, "published": "Public", "date": "1623567923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Alternative by iq suggested by Shane\n// Its associative and commutative\n// Associative: sminExp(a, sminExp(b, c, k), k) = sminExp(sminExp(a, b, k), c, k)\n// Commutative: sminExp(a, b, k) = sminExp(b, a, k)\nfloat sminExp(in float a, in float b, in float k) {\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat smoothVoronoi(in vec2 p, in float k) {\n    // Get closest point\n    vec2 cell = floor(p), closest = getPoint(cell);\n    float minDist = length(p - closest);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec2 curCell = cell + vec2(i, j), curPoint = getPoint(curCell);\n            float dist = length(p - curPoint);\n            if (dist < minDist) {\n                closest = curPoint;\n                minDist = dist;\n            }\n        }\n    }\n\n    // Get closest border (should be doing 5x5 search but it doesn't affect this look)\n    cell = floor(closest);\n    vec2 p1 = getPoint(cell + 1.0);\n    float dist = dot(p - 0.5 * (closest + p1), normalize(closest - p1));\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if ((i == 0 && j == 0) || (i == 1 && j == 1)) continue;\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            dist = sminExp(dist, dot(p - 0.5 * (closest + curPoint), normalize(closest - curPoint)), k);\n        }\n    }\n\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 3.0 + 0.5 * iTime;\n    float unit = 6.0 / iResolution.y;\n\n    float k = 13.0; // How much the tiles are packed\n    float voro = smoothVoronoi(uv, k);\n\n    float dx = (smoothVoronoi(uv + vec2(0.001, 0.0), k) - voro) / 0.001;\n    float dy = (smoothVoronoi(uv + vec2(0.0, 0.001), k) - voro) / 0.001;\n    vec3 grad = normalize(vec3(dx, dy, 1.0));\n\n    fragColor = vec4(0.0);\n\n    fragColor.gb += 0.5 + 0.5 * grad.xy;\n    fragColor.r += grad.z;\n\n    fragColor.rgb -= smoothstep(unit, 0.0, voro);\n    fragColor.rgb += pow(grad.z, 10.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 260, 260, 331], [333, 422, 448, 448, 534], [536, 561, 590, 590, 873], [875, 875, 919, 944, 1966], [1968, 1968, 2023, 2023, 2623]], "test": "untested"}
{"id": "stf3Dl", "name": "Smoky Farini 600", "author": "Farini", "description": "Slight changes from this shader:  https://www.shadertoy.com/view/wlVGWd, created by latyr.", "tags": ["noise", "fbm", "smoke"], "likes": 0, "viewed": 87, "published": "Public", "date": "1623087155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by CineShader: https://www.shadertoy.com/view/wlVGWd\n\n// Scale\n#define ZOOM 8.\n\n// FBM Scale\n#define FBMZ 2.5\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.2,0.6,0.8);\n\nfloat fbm( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.769;\n}\n\nfloat pattern( in vec2 p ) {\n  vec2 q = vec2(fbm(p + vec2(0.0,0.0)));\n  vec2 zm = q * FBMZ;\n  \n  vec2 r = vec2( fbm( p + zm + vec2(1.1,8.2)));\n  r+= iTime * 0.1;\n  return fbm( p + 1.760*r );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  \tvec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= ZOOM;\n  \tfloat displacement = pattern(uv);\n  \tvec4 color = vec4(displacement * 0.8, displacement * 0.8, displacement * 1.2, 1.);\n    \n    color.a = min(color.r * 0.75, 1.); // Depth for CineShader\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 123, 143, 143, 212], [214, 214, 235, 235, 470], [513, 513, 536, 536, 735], [737, 737, 765, 765, 929], [931, 931, 988, 988, 1264]], "test": "untested"}
{"id": "stf3WS", "name": "Ray_baichuan", "author": "baichuan", "description": "a simple effect for Ph.D. application in Lund University", "tags": ["test"], "likes": 0, "viewed": 137, "published": "Public API", "date": "1622713966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat Calculate_distance(vec3 point){\n\n    vec4 ball=vec4(1.,1.,5.,1.);\n    float distance_to_ball = length(point-ball.xyz)-ball.w;\n    float distance_to_plane = point.y;\n    float min_distance = min(distance_to_ball,distance_to_plane);\n    return min_distance;\n}\n\nvec3 Calculate_Normal(vec3 point){\nfloat distance_ = Calculate_distance(point);\n    vec2 disturb = vec2(.01,0.);\n    vec3 normal_point = vec3(distance_)-vec3(Calculate_distance(point-disturb.xyy),\n                                            Calculate_distance(point-disturb.yxy),\n                                            Calculate_distance(point-disturb.yyx)); \n    return normalize(normal_point);\n}\n\nfloat Raytrack(vec3 camera_center, vec3 ray_direction){\n    float distance_from_camera = 0.;\n    for(int i=0;i<100;i++){\n        vec3 point = camera_center+ray_direction*distance_from_camera;\n        float distance_to_ball = Calculate_distance(point);\n        distance_from_camera = distance_from_camera + distance_to_ball;\n        if(distance_from_camera>100.) break;\n    }\n    return distance_from_camera;\n}\n\n\nfloat Calculate_Light(vec3 point){\n    vec3 light_position = vec3(2.+4.0*sin(iTime),2.+1.0*sin(iTime),3.+3.0*cos(iTime));\n    vec3 light_to_point = normalize(light_position-point);\n    vec3 normal_point = Calculate_Normal(point);\n    float light_strength = clamp (dot(normal_point,light_to_point),0.,1.);\n    float point_to_light = Raytrack(point+normal_point*0.01*2.,light_to_point);\n    if(point_to_light<length(light_position-point)) light_strength=0.;\n    return light_strength;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    vec3 ball_center = vec3(0.,1.,0.);\n    vec3 ray_direction = normalize(vec3(uv.x,uv.y,1.));\n    float distance_from_camera = Raytrack(ball_center,ray_direction);\n    \n    vec3 point =  ball_center + distance_from_camera*ray_direction;\n    float light = Calculate_Light(point);\n\tvec3 col = vec3(light);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 40, 40, 266], [268, 268, 302, 302, 670], [672, 672, 727, 727, 1081], [1084, 1084, 1118, 1118, 1568], [1572, 1572, 1629, 1629, 2057]], "test": "untested"}
{"id": "stf3zs", "name": "ripple demo of radar", "author": "zengqh", "description": "ripple demo", "tags": ["ripple"], "likes": 6, "viewed": 84, "published": "Public", "date": "1622628900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define green vec3(0.0,.3,0.6)\n\n// returns a vec3 color from every pixel requested.\n// Generates a BnW Ping on normalized 2d coordinate system\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n               in float frontierBorder, in float timeResetSeconds, \n               in float radarPingSpeed, in float fadeDistance, float t)\n{\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(t, timeResetSeconds) * radarPingSpeed;\n   \n    float circle;\n    // r is the distance to the center.\n    // circle = BipCenter---//---innerTail---time---frontierBorder\n    //illustration\n    //https://sketch.io/render/sk-14b54f90080084bad1602f81cadd4d07.jpeg\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n\tcircle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance\n        \n    return vec3(circle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //normalize coordinates \n    vec2 uv = fragCoord.xy / iResolution.xy; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    uv.x *= iResolution.x/iResolution.y; //correct the aspect ratio\n    \n\tvec3 color;\n    // generate some radar pings\n    float fadeDistance = 0.8;\n    float resetTimeSec = 3.0;\n    float radarPingSpeed = 0.2;\n    vec2 greenPing = vec2(0.0, 0.0);\n    color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime) * green;\n    color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 1.) * green;\n    color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 2.) * green;\n    //return the new color\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 144, 349, 349, 894], [896, 896, 953, 983, 1785]], "test": "untested"}
{"id": "stfGWB", "name": "Lattice Voronoi with F1,F2,F3,..", "author": "weasel", "description": "A simple shader to visualise the Voronoi zones in a lattice.\nIt is using a gram-schmidt like orthogonalization to make the lattice mostly orthogonal for smaller nearest neighbor check radius.", "tags": ["voronoi"], "likes": 6, "viewed": 74, "published": "Public", "date": "1622723918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(mat2 mat, vec2 pos) {\n    vec2 tpos = inverse(mat)*pos;\n    vec2 closest = tpos+mod(tpos+0.5, vec2(1))-0.5;\n    if (abs(tpos.x-closest.x) < 0.003/length(mat[0])\n     || abs(tpos.y-closest.y) < 0.003/length(mat[1]))\n        return 1.0;\n    return max(0.0, 20.0-1000.0*length(mat*(tpos - closest)));\n}\n\n#define REGIONS 4 // min 4\n#define CELLS 2\n\nfloat voronoi(inout mat2 mat, vec2 pos, vec2 show_cell, out int region) {\n    // optimization: find most orthogonal primitive cell\n    vec2 real1 = mat[1]-round(dot(mat[1], mat[0])/dot(mat[0], mat[0]))*mat[0];\n    vec2 real0 = mat[0]-round(dot(mat[0], real1)/dot(real1, real1))*real1;\n    real1 = real1-round(dot(real1, real0)/dot(real0, real0))*real0;\n    real0 = real0-round(dot(real0, real1)/dot(real1, real1))*real1;\n    mat = mat2(real0, real1);\n    \n    // find k-nearest neighbors\n    vec2 tpos = inverse(mat)*pos;\n    float d[REGIONS];\n    for (int i = 0; i < REGIONS; i++) d[i] = 1e6;\n    vec2 k[REGIONS];\n    for (int x = -CELLS; x <= CELLS; x++) {\n        for (int y = -CELLS; y <= CELLS; y++) {\n            vec2 kn = mod(tpos+0.5, vec2(1))+vec2(x, y)-0.5;\n            float dn = length(mat*kn);\n            for (int j = 0; j < REGIONS; j++) {\n                if (dn < d[j]) {\n                    for (int i = REGIONS - 1; i > j; i--) {\n                        k[i]=k[i-1];\n                        d[i]=d[i-1];\n                    }\n                    d[j] = dn;\n                    k[j] = kn;\n                    break;\n                }\n            }\n        }\n    }\n    // find the region which corresponds to show_cell\n    region = -1;\n    for (int i = 0; i < REGIONS - 1; i++)\n        if (length(k[i] - tpos - show_cell) < 1e-3)\n            region = i;\n    \n    // make some grid visuals with points and F1 voronoi edges\n    vec2 h = mat*(k[3]);\n    vec2 w = mat*(k[2]);\n    vec2 v = mat*(k[1]);\n    vec2 u = mat*(k[0]);\n    float edge = min(dot(0.5*(u+v), normalize(v-u)),\n                 min(dot(0.5*(u+w), normalize(w-u)),\n                     dot(0.5*(u+h), normalize(h-u))));\n    return max(0.0, (0.002-min(0.1*d[0], edge)) * 2000.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 mouse = iMouse.xy;\n    \n    // animate if mouse has never moved\n    if (length(mouse.xy) == 0.0)\n        mouse.x += iTime*50.0;\n\n    // make grid matrix\n    mat2 real = mat2(vec2(0.25, 0.0), mouse/iResolution.xy-0.5);\n    real[0] *= iResolution.xy/iResolution.y;\n    real[1] *= iResolution.xy/iResolution.y;\n    \n    // \"do voronoi\"\n    int vregion = -1;\n    vec2 pos = (uv-mouse)/iResolution.y + real[1];\n    float decoration = voronoi(real, pos, vec2(0), vregion);\n    \n    // draw most orthogonal grid instead of voronoi cells\n    //decoration = grid(real, pos);\n    \n    // define the colors used for the regions\n#define COLORS 6\n    vec3 colors[COLORS];\n    colors[0] = vec3(1,0,0);\n    colors[1] = vec3(0,1,0);\n    colors[2] = vec3(0,0,1);\n    colors[3] = vec3(1,1,0);\n    colors[4] = vec3(0,1,1);\n    colors[5] = vec3(1,0,1);\n    \n    // Output to screen\n    vec3 col = colors[vregion % COLORS] * 2.0 / float(2 + vregion / COLORS);\n    if (vregion < 0)\n        col = vec3(0);\n    fragColor = vec4(col + decoration, 1);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 310], [356, 356, 429, 486, 2115], [2118, 2118, 2175, 2225, 3287]], "test": "untested"}
{"id": "stfXzn", "name": "Портрэт", "author": "Natan_Chachko", "description": "да", "tags": ["dd"], "likes": 0, "viewed": 31, "published": "Public", "date": "1625059340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float _(float a, float b, float c)   \n          {\n             return max(a,max(b,c));\n          }\n        \n        float L(vec2 p, vec2 p0, vec2 p1){\n            float a = -(p1.y-p0.y);\n            float b =  (p1.x-p0.x);\n            float d =  p0.x*p1.y- p0.y*p1.x; \n            float x = p.x;\n            float y = p.y;\n            \n            return a*x+b*y+d;\n        }\n    \n    float T(vec2 p, vec2 p0, vec2 p1, vec2 p2){\n      return  _(\n                 L(p, p0, p1),\n                 L(p, p1, p2), \n                 L(p, p2, p0)\n                ) ;   \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n vec2 P[255];\nP[0] = vec2(0.74375, 0.14063);\nP[1] = vec2(0.72188, 0.2);\nP[2] = vec2(0.6125, 0.16562);\nP[3] = vec2(0.55938, 0.14687);\nP[4] = vec2(0.54063, 0.16562);\nP[5] = vec2(0.49688, 0.14375);\nP[6] = vec2(0.44375, 0.19375);\nP[7] = vec2(0.45313, 0.24062);\nP[8] = vec2(0.4625, 0.2);\nP[9] = vec2(0.47188, 0.2625);\nP[10] = vec2(0.44688, 0.2625);\nP[11] = vec2(0.45938, 0.30937);\nP[12] = vec2(0.425, 0.34375);\nP[13] = vec2(0.425, 0.30937);\nP[14] = vec2(0.39688, 0.35);\nP[15] = vec2(0.38438, 0.4);\nP[16] = vec2(0.37188, 0.375);\nP[17] = vec2(0.35938, 0.4125);\nP[18] = vec2(0.31563, 0.47187);\nP[19] = vec2(0.32188, 0.44062);\nP[20] = vec2(0.2875, 0.49375);\nP[21] = vec2(0.2375, 0.53438);\nP[22] = vec2(0.2625, 0.49062);\nP[23] = vec2(0.2125, 0.54062);\nP[24] = vec2(0.16563, 0.55312);\nP[25] = vec2(0.16563, 0.52187);\nP[26] = vec2(0.12187, 0.57813);\nP[27] = vec2(0.1125, 0.5375);\nP[28] = vec2(0.06875, 0.59062);\nP[29] = vec2(0.05625, 0.55937);\nP[30] = vec2(0.021875, 0.60312);\nP[31] = vec2(0.0375, 0.56563);\nP[32] = vec2(-0.028125, 0.6125);\nP[33] = vec2(-0.046875, 0.59062);\nP[34] = vec2(-0.10625, 0.59375);\nP[35] = vec2(-0.05625, 0.62813);\nP[36] = vec2(-0.1375, 0.575);\nP[37] = vec2(-0.14063, 0.54062);\nP[38] = vec2(-0.090625, 0.575);\nP[39] = vec2(-0.17812, 0.55312);\nP[40] = vec2(-0.19062, 0.50937);\nP[41] = vec2(-0.15937, 0.52812);\nP[42] = vec2(-0.20625, 0.48125);\nP[43] = vec2(-0.19062, 0.46562);\nP[44] = vec2(-0.17812, 0.50313);\nP[45] = vec2(-0.23438, 0.45625);\nP[46] = vec2(-0.2125, 0.44062);\nP[47] = vec2(-0.20937, 0.49062);\nP[48] = vec2(-0.2625, 0.425);\nP[49] = vec2(-0.2375, 0.43125);\nP[50] = vec2(-0.25937, 0.44688);\nP[51] = vec2(-0.29062, 0.4);\nP[52] = vec2(-0.24687, 0.4125);\nP[53] = vec2(-0.29062, 0.39687);\nP[54] = vec2(-0.29688, 0.35312);\nP[55] = vec2(-0.26563, 0.3875);\nP[56] = vec2(-0.3125, 0.37187);\nP[57] = vec2(-0.30312, 0.32813);\nP[58] = vec2(-0.27187, 0.35938);\nP[59] = vec2(-0.31875, 0.3375);\nP[60] = vec2(-0.3625, 0.32187);\nP[61] = vec2(-0.33125, 0.3125);\nP[62] = vec2(-0.35312, 0.35625);\nP[63] = vec2(-0.37187, 0.31562);\nP[64] = vec2(-0.32187, 0.3125);\nP[65] = vec2(-0.38437, 0.3125);\nP[66] = vec2(-0.38437, 0.28437);\nP[67] = vec2(-0.36562, 0.29688);\nP[68] = vec2(-0.4, 0.28125);\nP[69] = vec2(-0.37187, 0.27812);\nP[70] = vec2(-0.4125, 0.25312);\nP[71] = vec2(-0.39687, 0.24687);\nP[72] = vec2(-0.4, 0.28437);\nP[73] = vec2(-0.4125, 0.25);\nP[74] = vec2(-0.39687, 0.225);\nP[75] = vec2(-0.38125, 0.24375);\nP[76] = vec2(-0.38437, 0.22187);\nP[77] = vec2(-0.40937, 0.21562);\nP[78] = vec2(-0.36562, 0.21562);\nP[79] = vec2(-0.38125, 0.24375);\nP[80] = vec2(-0.38437, 0.20313);\nP[81] = vec2(-0.4, 0.18125);\nP[82] = vec2(-0.425, 0.15312);\nP[83] = vec2(-0.41563, 0.14375);\nP[84] = vec2(-0.4375, 0.14063);\nP[85] = vec2(-0.43437, 0.1125);\nP[86] = vec2(-0.45625, 0.1);\nP[87] = vec2(-0.475, 0.071875);\nP[88] = vec2(-0.475, 0.05);\nP[89] = vec2(-0.49375, 0.03125);\nP[90] = vec2(-0.48438, 0.003125);\nP[91] = vec2(-0.48438, -0.01875);\nP[92] = vec2(-0.48125, 0.021875);\nP[93] = vec2(-0.49062, -0.025);\nP[94] = vec2(-0.47187, -0.04375);\nP[95] = vec2(-0.46562, 0.025);\nP[96] = vec2(-0.4875, -0.0625);\nP[97] = vec2(-0.45937, -0.04375);\nP[98] = vec2(-0.49062, -0.065625);\nP[99] = vec2(-0.4625, -0.03125);\nP[100] = vec2(-0.46875, -0.075);\nP[101] = vec2(-0.45625, -0.090625);\nP[102] = vec2(-0.46875, -0.1125);\nP[103] = vec2(-0.425, -0.11563);\nP[104] = vec2(-0.4375, -0.14688);\nP[105] = vec2(-0.45937, -0.12187);\nP[106] = vec2(-0.38437, -0.1375);\nP[107] = vec2(-0.43437, -0.16563);\nP[108] = vec2(-0.4125, -0.16563);\nP[109] = vec2(-0.40312, -0.18125);\nP[110] = vec2(-0.40937, -0.23438);\nP[111] = vec2(-0.39687, -0.25625);\nP[112] = vec2(-0.3875, -0.29688);\nP[113] = vec2(-0.39687, -0.29688);\nP[114] = vec2(-0.38125, -0.26875);\nP[115] = vec2(-0.40937, -0.27813);\nP[116] = vec2(-0.3875, -0.30625);\nP[117] = vec2(-0.38125, -0.34688);\nP[118] = vec2(-0.40625, -0.35);\nP[119] = vec2(-0.39063, -0.3625);\nP[120] = vec2(0.059375, -0.059375);\nP[121] = vec2(0.090625, -0.0625);\nP[122] = vec2(0.11875, -0.034375);\nP[123] = vec2(0.046875, -0.053125);\nP[124] = vec2(0.075, -0.025);\nP[125] = vec2(0.125, -0.040625);\nP[126] = vec2(0.12187, -0.059375);\nP[127] = vec2(0.14688, -0.05);\nP[128] = vec2(0.18125, -0.025);\nP[129] = vec2(0.1375, -0.034375);\nP[130] = vec2(0.18437, -0.034375);\nP[131] = vec2(0.20938, -0.015625);\nP[132] = vec2(0.1875, -0.034375);\nP[133] = vec2(0.20313, 0.003125);\nP[134] = vec2(0.2375, 0.009375);\nP[135] = vec2(0.225, 0.053125);\nP[136] = vec2(0.25313, 0.05);\nP[137] = vec2(0.25, 0.03125);\nP[138] = vec2(0.27813, 0.084375);\nP[139] = vec2(0.2625, 0.1125);\nP[140] = vec2(0.26875, 0.0875);\nP[141] = vec2(0.24375, 0.125);\nP[142] = vec2(0.23438, 0.10625);\nP[143] = vec2(0.20938, 0.125);\nP[144] = vec2(0.20625, 0.10312);\nP[145] = vec2(0.16563, 0.11562);\nP[146] = vec2(0.1875, 0.13437);\nP[147] = vec2(0.13438, 0.090625);\nP[148] = vec2(0.17188, 0.1);\nP[149] = vec2(0.15312, 0.13437);\nP[150] = vec2(0.12813, 0.0875);\nP[151] = vec2(0.10313, 0.06875);\nP[152] = vec2(0.1375, 0.078125);\nP[153] = vec2(0.10938, 0.10312);\nP[154] = vec2(0.096875, 0.059375);\nP[155] = vec2(0.10938, 0.05);\nP[156] = vec2(0.075, 0.0375);\nP[157] = vec2(0.071875, 0.028125);\nP[158] = vec2(0.084375, 0.025);\nP[159] = vec2(0.05625, -0.015625);\nP[160] = vec2(0.065625, -0.03125);\nP[161] = vec2(0.05, -0.0625);\nP[162] = vec2(0.084375, -0.00625);\nP[163] = vec2(0.06875, 0.021875);\nP[164] = vec2(0.09375, 0.05);\nP[165] = vec2(0.13438, 0.14687);\nP[166] = vec2(0.11563, 0.11562);\nP[167] = vec2(0.1, 0.14063);\nP[168] = vec2(0.0625, 0.125);\nP[169] = vec2(0.071875, 0.15);\nP[170] = vec2(0.046875, 0.175);\nP[171] = vec2(0.071875, 0.18125);\nP[172] = vec2(0.071875, 0.15625);\nP[173] = vec2(0.04375, 0.22812);\nP[174] = vec2(0.06875, 0.22187);\nP[175] = vec2(0.05, 0.18437);\nP[176] = vec2(0.071875, 0.2625);\nP[177] = vec2(0.06875, 0.225);\nP[178] = vec2(0.0625, 0.24062);\nP[179] = vec2(0.08125, 0.25937);\nP[180] = vec2(0.05, 0.23125);\nP[181] = vec2(0.078125, 0.27812);\nP[182] = vec2(0.09375, 0.28437);\nP[183] = vec2(0.084375, 0.25625);\nP[184] = vec2(0.10313, 0.31562);\nP[185] = vec2(0.10938, 0.33437);\nP[186] = vec2(0.078125, 0.3);\nP[187] = vec2(0.10313, 0.2875);\nP[188] = vec2(0.090625, 0.33437);\nP[189] = vec2(0.10625, 0.29688);\nP[190] = vec2(0.090625, 0.30937);\nP[191] = vec2(0.09375, 0.34687);\nP[192] = vec2(0.10938, 0.3875);\nP[193] = vec2(0.09375, 0.3875);\nP[194] = vec2(0.1125, 0.38125);\nP[195] = vec2(0.11563, 0.43125);\nP[196] = vec2(0.12813, 0.3875);\nP[197] = vec2(0.1, 0.38437);\nP[198] = vec2(0.096875, 0.45625);\nP[199] = vec2(0.11563, 0.41563);\nP[200] = vec2(0.0875, 0.45937);\nP[201] = vec2(0.053125, 0.45);\nP[202] = vec2(0.10938, 0.45937);\nP[203] = vec2(0.059375, 0.49062);\nP[204] = vec2(0.0375, 0.45937);\nP[205] = vec2(0.003125, 0.5);\nP[206] = vec2(0.05625, 0.47187);\nP[207] = vec2(-0.01875, 0.52187);\nP[208] = vec2(-0.009375, 0.51563);\nP[209] = vec2(-0.0375, 0.50937);\nP[210] = vec2(-0.065625, 0.53438);\nP[211] = vec2(-0.065625, 0.50625);\nP[212] = vec2(-0.11875, 0.53438);\nP[213] = vec2(-0.071875, 0.54688);\nP[214] = vec2(-0.14063, 0.53438);\nP[215] = vec2(-0.11875, 0.50625);\nP[216] = vec2(-0.08125, 0.5375);\nP[217] = vec2(-0.12812, 0.52187);\nP[218] = vec2(-0.17812, 0.52187);\nP[219] = vec2(-0.19687, 0.49062);\nP[220] = vec2(-0.15, 0.4875);\nP[221] = vec2(-0.16562, 0.51875);\nP[222] = vec2(-0.13437, 0.35625);\nP[223] = vec2(-0.14687, 0.34062);\nP[224] = vec2(-0.13437, 0.325);\nP[225] = vec2(-0.125, 0.34687);\nP[226] = vec2(-0.125, 0.31875);\nP[227] = vec2(-0.14687, 0.32187);\nP[228] = vec2(-0.17188, 0.31562);\nP[229] = vec2(-0.14375, 0.3);\nP[230] = vec2(-0.11875, 0.30625);\nP[231] = vec2(-0.10312, 0.28437);\nP[232] = vec2(-0.0875, 0.32813);\nP[233] = vec2(-0.10625, 0.35312);\nP[234] = vec2(-0.090625, 0.3625);\nP[235] = vec2(-0.10625, 0.39063);\nP[236] = vec2(-0.090625, 0.37812);\nP[237] = vec2(-0.12812, 0.3375);\nP[238] = vec2(-0.1875, 0.34062);\nP[239] = vec2(-0.15625, 0.3625);\nP[240] = vec2(-0.16562, 0.325);\nP[241] = vec2(-0.15, 0.33125);\nP[242] = vec2(-0.12812, 0.375);\nP[243] = vec2(-0.175, 0.35625);\nP[244] = vec2(-0.13125, 0.375);\nP[245] = vec2(-0.10312, 0.3875);\nP[246] = vec2(-0.13125, 0.41563);\nP[247] = vec2(-0.175, 0.37812);\nP[248] = vec2(-0.14375, 0.3875);\nP[249] = vec2(-0.1125, 0.33437);\nP[250] = vec2(-0.1875, 0.32187);\nP[251] = vec2(-0.16562, 0.34062);\n\n\nP[252] = vec2(0.2,     \t0.14687);\nP[253] = vec2(0.19375, 0.2);\nP[254] = vec2(0.24063, 0.1875);\n\n\n\n\n   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.x/iResolution.y;\n     float y = p.y ;\n     \n     float mx = m.x * iResolution.x/iResolution.y;\n     float my = m.y ;\n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   \n\n      float  z = 1.0e25; //infinity?\n              for(int i=0;i<255-4;i++)\n                z = min(z, T(p,P[i],P[i+1], P[i+3]) );   \n       float     f = 1.25/z; \n\n    // Time varying pixel color\n               vec3 col = vec3(1.0, 1.0, 1.0);\n                if(f >= 0.0)col.g = sin(iTime/10.0);\n                   else     col.r = f;\n                \n\n    // Output to screen\n                 fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfXzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 98], [116, 116, 150, 150, 375], [385, 385, 428, 428, 567], [569, 569, 626, 626, 9772]], "test": "untested"}
{"id": "stl3DX", "name": "CircleSDF __", "author": "Envy24", "description": "CircleSDF\n\nsource: https://www.shadertoy.com/view/3ltSW2", "tags": ["sdf", "circle"], "likes": 1, "viewed": 30, "published": "Public", "date": "1623027583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 12345u;\n    const uint enthropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\nfloat circleSDF(\n    float x,\n    float y,\n    float cx,\n    float cy, \n    float r)\n{\n    // Sample coordinates relative to circle center.\n    float _x = x - cx;\n    float _y = y - cy;\n    \n    // Signed distance.\n    return sqrt(_x * _x + _y *_y) - r;\n}\n\nfloat smoothCircleSDF(\n    float x,\n    float y,\n    float cx,\n    float cy, \n    float r,\n    float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = x - cx;\n    float _y = y - cy;\n    \n    // Signed distance.\n    float d =  sqrt(_x * _x + _y *_y) - r;\n     \n    // Smoothstep interpolation.\n    return smoothstep(-smoothness, smoothness, d);\n}\n\nfloat left(in vec2 fragCoord, float radius)\n{     \n    float gray = circleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.16, iResolution.y * 0.5,\n            radius);\n            \n    return (1.0 + cos(gray * 0.9) * 0.4);\n}\n\nfloat middle(in vec2 fragCoord, float radius)\n{     \n    return smoothCircleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.495, iResolution.y * 0.5,\n            radius,\n            4.0);\n}\n\n\nfloat right(in vec2 fragCoord, float radius)\n{     \n    float gray = circleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.83, iResolution.y * 0.5,\n            radius);\n            \n    gray = (1.0 + cos(gray * 0.9) * 0.4);\n\n    gray = min(\n        gray, \n        smoothCircleSDF(\n            fragCoord.x, fragCoord.y,\n            iResolution.x * 0.83, iResolution.y * 0.5,\n            radius,\n            4.0));\n            \n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 c = iResolution.xy * 0.5;\n\n    float radius = 15.0 + (1.0 + sin(iTime * 0.1)) * 60.0;\n\n    float gray = 0.0;\n    \n    float xTreshold0 = 0.33 + signedSample1DHashUI32(uint(fragCoord.y * 7.1)) * 0.00159;\n    float xTreshold1 = 0.66 + signedSample1DHashUI32(uint(fragCoord.y * 7.1)) * 0.00159;\n    \n    if (uv.x < xTreshold0) { gray = left(fragCoord, radius); }\n    else if (uv.x >= xTreshold0 && uv.x < xTreshold1) { gray = middle(fragCoord, radius); }\n    else { gray = right(fragCoord, radius); }\n\n    float yTreshold = 0.5 + signedSample1DHashUI32(uint(fragCoord.x * 7.1)) * 0.00159;\n\n    // Output to screen\n    if (uv.y > yTreshold) { fragColor = vec4(vec3(1.0 - (gray - 0.5) * (gray - 0.5)),1.0); }\n    else { fragColor = vec4(vec3(gray),1.0); }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 87, 157, 449], [451, 451, 537, 590, 706], [708, 708, 822, 875, 1085], [1087, 1087, 1132, 1132, 1336], [1338, 1338, 1385, 1385, 1552], [1555, 1555, 1601, 1601, 2024], [2026, 2026, 2083, 2133, 2940]], "test": "untested"}
{"id": "stlGzj", "name": "2D Lightened Glass Ball", "author": "Densevoid", "description": "For my education", "tags": ["refraction", "glass", "ball", "education", "caustic"], "likes": 7, "viewed": 118, "published": "Public", "date": "1622910506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float eta = 1.0 / 1.501;\nfloat FP = 1.24;\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d * 2.0 - 1.0;\n}\n\nvec2 uvToCuv( vec2 uv, vec2 maxuv )\n{\n    return 2.0 * uv - maxuv;\n}\n\nvec2 cuvToUv( vec2 cuv, vec2 maxuv )\n{\n    return (cuv + maxuv) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fract_time = fract(iTime);\n    float cos_time = (cos(iTime));\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 maxuv = vec2(iResolution.x / iResolution.y, 1.0);  \n    \n    //centrilize uv coordinates   \n    vec2 cuv = uvToCuv(uv, maxuv);\n    \n    fragColor = texture(iChannel0, uv);\n    \n    vec2 ballCoord = vec2(cos_time, 0.0);\n    float ballRadius = 0.5;\n    \n    float dist = distance(ballCoord, cuv);\n    \n    if (dist < ballRadius * 0.995)\n    {\t\n        vec2 balluv = (cuv - ballCoord) / ballRadius;\n        vec3 norm = vec3(balluv.x, balluv.y, -sqrt(1.0 - dist / ballRadius));\n        \n\t\tvec3 spec = reflect(vec3(0, 0, 1), norm);\n        vec3 refr = refract(vec3(0, 0, 1), norm, eta);\n        \n\t\tvec4 ambient = vec4(0.09, 0.08, 0.07, 0.0);\n\t\tvec4 spec_light = texture(iChannel0, cuvToUv(spec.xy + ballCoord, maxuv));\n        vec4 refr_light = texture(iChannel0, cuvToUv(refr.xy + ballCoord, maxuv));\n\n        float F = (1.0 - eta) * (1.0 - eta) / ((1.0 + eta) * (1.0 + eta));\n        float ratio = F + (1.0 - F) * pow(dist / ballRadius, FP);\n        \n        fragColor = mix(refr_light, spec_light, ratio) + ambient;\n\n        //glare drawing\n        vec2 lightPos = vec2(cos_time, 0.5);\n        float distanceToLight = abs(cos_time) * 0.5 + 0.5;\n        vec4 lightColor = vec4(0.8, 1.0, .85 ,1);\n        \n        float glareSize = 0.5;\n        glareSize *= distanceToLight;\n        \n        float glareHardness = 0.0;\n        float glareMax = 1.0;\n        \n        vec2 glareOffset = -lightPos * 0.5;   \n        \n        float refrGlareDistance = distance(glareOffset, refr.xy);\n        float specGlareDistance = distance(glareOffset, spec.xy);\n        \n        if (refrGlareDistance < glareSize)\n        {\n            float glarePower = 1.0 - smoothstep(glareSize * glareHardness, glareSize, refrGlareDistance);\n            fragColor = mix(fragColor, vec4(linearLight(fragColor.rgb, lightColor.rgb), 1.0 ), glarePower * glareMax);\n        }\n        \n        if (specGlareDistance < glareSize)\n        {\n            float glarePower = 1.0 - smoothstep(glareSize * glareHardness, glareSize, specGlareDistance);\n            fragColor = mix(fragColor, vec4(linearLight(fragColor.rgb, lightColor.rgb), 1.0), glarePower * glareMax);\n        }\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 79, 79, 114], [116, 116, 153, 153, 184], [186, 186, 224, 224, 258], [260, 260, 317, 317, 2581]], "test": "untested"}
{"id": "stlGzs", "name": "Cubic Bézier curve", "author": "HalbFettKaese", "description": "A direct implementation of a cubic Bézier curve that is defined through a quadratic curve.", "tags": ["animation", "curve", "cubic", "quadratic", "bzier"], "likes": 1, "viewed": 52, "published": "Public", "date": "1622674749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 quadratic(vec2 p1, vec2 p2, vec2 p3, float t) {\n    // mix(a, b, t) == (1 - t) * a + t * b\n    return mix(\n        mix(p1, p2, t),\n        mix(p2, p3, t),\n        t);\n}\nvec2 cubic(vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t) {\n    return mix(\n        quadratic(p1, p2, p3, t),\n        quadratic(p2, p3, p4, t),\n        t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time variable from 0 to 1\n    float t = mod(iTime, 1.);\n    \n    // The four points defining the curve\n    vec2 p1 = vec2(0, 0); // The starting position\n    vec2 p2 = vec2(0, 1); // The position that the point moves to initially\n    vec2 p3 = vec2(1, 1); // The position that the point moves away from at the end\n    vec2 p4 = vec2(1, 0); // The ending position\n    \n    // The resulting point for the current time\n    vec2 p = cubic(p1, p2, p3, p4, t);\n    \n    // The point rendered to the screen\n    vec2 uv = fragCoord;\n    vec3 col = vec3(smoothstep(2., 3., length(p*iResolution.xy-uv)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 95, 173], [174, 174, 231, 231, 334], [336, 336, 393, 426, 1028]], "test": "untested"}
{"id": "sts3DB", "name": "Cat Android Factory", "author": "shyuriken", "description": "modeled by SDF Editor", "tags": ["raymarchingsdfglsl"], "likes": 6, "viewed": 95, "published": "Public", "date": "1622799185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from original shader: https://www.shadertoy.com/view/ldcyW4\n// modeled by https://joetech.itch.io/sdf-editor\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 2,150 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat3 rotateMat(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle),\n\t      c = cos(angle),\n\t      r = 1. - c;\n\treturn mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s, a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s, a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n}\n\n#define LIGHT\tnormalize(vec3(1, 1, 0))\n\nfloat pSphere(float r, vec3 p) { return length(p) - r; }\n\nfloat pTriPrism(float h, float r, vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h, max(q.x * .866025 + p.y * .5, -p.y) - r * .5);\n}\n\nfloat pCapsule(float r, float h, vec3 p) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pRoundCone(float r1, float r2, float h, vec3 p) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat b = (r1 - r2) / h,\n\t      a = sqrt(1. - b * b),\n\t      k = dot(q, vec2(-b, a));\n\tif (k < 0.) return length(q) - r1;\n\tif (k > a * h) return length(q - vec2(0, h)) - r2;\n\treturn dot(q, vec2(a, b)) - r1;\n}\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mMirror(vec3 normal, float dist, vec3 p) { return p - 2. * max(0., dot(normal, p) - dist) * normal; }\n\nvec3 mRepInf(vec3 cell_size, vec3 p) { return p - cell_size * round(p * vec3(greaterThan(cell_size, vec3(0))) / cell_size); }\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat oSubtraction(float d1, float d2) { return max(d1, -d2); }\n\nfloat sdf(vec3 p0) {\n\tfloat d1, d2, d3, d4, d5, d6, d7;\n\t{ }\n\t{\n\t\tvec3 p1 = mRepInf(vec3(3, -1, 3), p0);\n\t\t{\n\t\t\tmat3 mt = rotateMat(p1, iTime, vec3(0, 1, 0));\n\t\t\tvec3 p2 = mRotation(mt, p1);\n\t\t\t{ d1 = pEllipsoid(vec3(1.2, .05, .1), mTranslation(vec3(0, -.74, 0), p2)); }\n\t\t}\n\t\t{ d2 = pCapsule(.07, 1., mTranslation(vec3(0, .2, 0), p1)); }\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), .06, p1);\n\t\t\t{ d3 = pSphere(.15, mTranslation(vec3(.17, .1, -.52), p2)); }\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), .06, p1);\n\t\t\t{ d4 = pSphere(.2, mTranslation(vec3(.17, .1, -.52), p2)); }\n\t\t}\n\t\t{ d5 = pRoundCone(1.2, .5, 1., mTranslation(vec3(0, 3, 0), p1)); }\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), 0., p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(.5, .09, 0), p2);\n\t\t\t\t{ d6 = pTriPrism(.02, .41, mRotation(mat3(.925417, -.163176, .34202, .044233, .942887, .330162, -.376361, -.290409, .879781), p3)); }\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(0, .84, 0), p1);\n\t\t\t{ d7 = pRoundCone(1., .5, 1., mRotation(mat3(1, -0, 0, 0, -1, -0, 0, 0, -1), p2)); }\n\t\t}\n\t}\n\treturn oUnion(d6, oUnion(d5, oUnion(oSubtraction(d7, d4), oUnion(d3, oUnion(d2, d1)))));\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin) {\n\tfloat dist = .01,\n\t      totalDist = 0.,\n\t      itter = 0.;\n\tvec3 pos = cameraOrigin;\n\tfor (int i = 0; i < 128; i++) {\n\t\tdist = sdf(pos);\n\t\titter++;\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir;\n\t\tif (dist < .01 || totalDist > 130.) break;\n\t}\n\n\treturn vec3(dist, totalDist, itter / 128.);\n}\n\nfloat AO(vec3 pos, vec3 n) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 3; i++) {\n\t\taopos = pos + n * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro),\n\t     cu = normalize(cross(cw, vec3(sin(cr), cos(cr), 0)));\n\treturn mat3(cu, normalize(cross(cu, cw)), cw);\n}\n\nvec4 NorCurv(vec3 p) {\n\tconst vec2 e = vec2(-.01, .01);\n\tfloat t1 = sdf(p + e.yxx),\n\t      t2 = sdf(p + e.xxy),\n\t      t3 = sdf(p + e.xyx),\n\t      t4 = sdf(p + e.yyy);\n\treturn vec4(normalize(e.yxx * t1 + e.xxy * t2 + e.xyx * t3 + e.yyy * t4), .25 / e.y * (t1 + t2 + t3 + t4 - 4. * sdf(p)));\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos) { return vec3(max(0., dot(LIGHT, n)), pow(max(0., dot(reflectDir, LIGHT)), 10.), 1. - max(0., dot(-n, rayDir))) * .5; }\n\nfloat TriplanarTexture(vec3 pos, vec3 n) { return 0.; }\n\nfloat BackGround(vec3 rayDir) { return smoothstep(1., 0., clamp(length(rayDir - LIGHT), 0., 1.)) * .5; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 cameraOrigin = vec3(0);\n\tif (iMouse.z > 0.) {\n\t\tcameraOrigin.x = sin(iMouse.x * .01) * 5.;\n\t\tcameraOrigin.y = iMouse.y * .05 - 10.;\n\t\tcameraOrigin.z = cos(iMouse.x * .01) * 5. + 15.;\n\t}\n\telse {\n\t\tcameraOrigin.x = sin(iTime * .25 + 2.) * (6. + sin(iTime * .1));\n\t\tcameraOrigin.y = sin(iTime * .3) + 3.;\n\t\tcameraOrigin.z = cos(iTime * .25 + 2.) * (6. + sin(iTime * .15));\n\t}\n\n\tvec2 screenPos = uv * 2. - 1.;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tmat3 cam = SetCamera(cameraOrigin, vec3(0, .25, -1), sin(iTime * .15) * .5);\n\tvec3 rayDir = cam * normalize(vec3(screenPos, 2)),\n\t     dist = RayMarch(rayDir, cameraOrigin);\n\tfloat res,\n\t      backGround = BackGround(rayDir);\n\tif (dist.x < .01) {\n\t\tvec3 l,\n\t\t     pos = cameraOrigin + dist.y * rayDir;\n\t\tvec4 n = NorCurv(pos);\n\t\tfloat col,\n\t\t      ao = AO(pos, n.xyz);\n\t\tl = Lighting(n.xyz, rayDir, reflect(rayDir, n.xyz), pos);\n\t\tcol = TriplanarTexture(pos, n.xyz);\n\t\tcol *= n.w * .5 + .5;\n\t\tcol *= ao;\n\t\tcol += ao * (l.x + l.y);\n\t\tcol += l.z * .75;\n\t\tcol += BackGround(n.xyz) * .25;\n\t\tres = col;\n\t}\n\telse res = backGround;\n\n\tfragColor = vec4(vec3(res), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 245, 293, 293, 608], [650, 650, 682, 682, 706], [708, 708, 751, 751, 839], [841, 841, 883, 883, 935], [937, 937, 992, 992, 1237], [1239, 1239, 1273, 1273, 1348], [1350, 1350, 1399, 1399, 1429], [1431, 1431, 1474, 1474, 1501], [1503, 1503, 1550, 1550, 1609], [1611, 1611, 1649, 1649, 1736], [1738, 1738, 1772, 1772, 1794], [1796, 1796, 1836, 1836, 1859], [1861, 1861, 1881, 1881, 2995], [2997, 2997, 3044, 3044, 3335], [3337, 3337, 3365, 3365, 3537], [3539, 3539, 3583, 3583, 3724], [3726, 3726, 3748, 3748, 4018], [4020, 4020, 4083, 4083, 4201], [4203, 4203, 4245, 4245, 4258], [4260, 4260, 4291, 4291, 4364], [4366, 4366, 4418, 4418, 5581]], "test": "untested"}
{"id": "sts3RB", "name": "Bplus' Swizzle", "author": "ashishkingdom", "description": "Inspired from https://www.qb64.org/forum/index.php?topic=3952", "tags": ["spiral", "swizzle"], "likes": 4, "viewed": 60, "published": "Public", "date": "1623132244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rf 0.05\n#define Gf 0.03\n#define Bf 0.02\n#define K (3.14159265358979323/180.0)\n#define SWZ 0.985 \n\nvec3 vScreenRGB(in vec2 pos)\n{\n    return vec3(0.5+0.5*sin(Rf*pos.x+iTime*10.0), 0.5+0.5*sin(Gf*pos.x+iTime*6.0), 0.5+0.5*sin(Bf*(pos.x)+iTime*4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 clr = vec3(0.0);\n    float max_r = min(iResolution.x, iResolution.y)/2.0;\n    vec2 c = iResolution.xy/2.0; //center\n    float r = length(c-fragCoord);\n    if(r<max_r){\n        float a = acos((fragCoord.x-c.x)/r)-pow(r, SWZ)*K;\n        vec2 p = vec2(c.x+r*cos(a),c.y+r*sin(a));\n        clr = vScreenRGB(p);\n    } else {\n        clr = vScreenRGB(fragCoord);\n        //clr+= vec3(vScreenRGB(fragCoord).x*0.5);\n        //clr+= vec3(vScreenRGB(fragCoord).y*0.3);\n        //clr+= vec3(vScreenRGB(fragCoord).z*0.2);\n    }\n    \n    fragColor = vec4(clr,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 136, 136, 257], [259, 259, 316, 316, 878]], "test": "untested"}
{"id": "sts3WB", "name": "Newton Marcher V1.0", "author": "Raxmo", "description": "Here is a Newtonian approximation distance marching algorithm. See comment section in shader for more detail and information.", "tags": ["raymarch", "isosurface"], "likes": 0, "viewed": 57, "published": "Public", "date": "1623219403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Description:\n        I'm toying with the idea of using newtonian approximation\n        rather than distance stepping to find the points of ray\n        intersection to a 0 isosurface.\n    Discoveries:\n        From other experiments, compound distance fields do not work.\n        however, for indavidual objects, Newton-marching requires\n        orders of magnitude fewer itterations to find an intersection\n        with the same level of detail as sphere-tracing. I've come\n        to realize that Newton-marching is FAR more complicated than\n        sphere-tracing, as for each object requires 3 functions.\n        Sphere-tracing is also one of if not the simplest method of\n        rendering a scene.\n    Notes:\n        - the unit sphere case is the most detailed in the comments\n          when it comes to explaining the algorithm.\n        - I'm unsure of the relative efficiency with many objects.\n        - Will need to experiment with space deformation like with\n          sphere-tracing.\n        - Likely possible to elimate much of the branching in the\n          algorithm to make it even more efficient.\n        - I suspect that boolien opperations are possible, however,\n          they are likely rather complicated to impliment.\n        - Given smarter people, or more time, one could define exact\n          derivatives for the gradient calculations rather than use\n          the hackey approximations.\n        - Thanks to some smarter people (oneshade), some analytic\n          gradients/derivatives have been added.\n    Purpose:\n        The entire purpose for trying out these experiments is to find\n        a method of rendering volumetric data directly. As in, given\n        3D samples at known locations, rendering the 0 iso-surface\n        directly. This more of an overview of the algorithm than a full\n        demonstration of the end-use.\n*/\n\n//-[ Defines for use later ]-//\n#define MAXDIST 100.\n#define SURF 0.01\n#define eps 1e-5\n#define STEPS 16\n//< NOTE: Notice that the number of steps is FAR less than sphere-trace rendering. >//\n\n//-[ Unit Sphere Functions ]-//\nfloat UnitSphereVal(vec3 p) //<- SDF of a unit sphere at origin\n{\n    return length(p) - 1.;\n}\n\nfloat GradUSV(vec3 p, vec3 rd) //<- Find the gradient at the point in the direction of the ray.\n{\n    float v0 = UnitSphereVal(p);\n    float v1 = UnitSphereVal(p + rd * eps);\n    \n    return (v1 - v0) / eps;\n}\n\nvoid NUSV(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D) //<- Newtonian distance calculation for unit sphere at origin\n{\n    float t = UnitSphereVal(ro);          //<- Step forward once just to get close\n    float v = UnitSphereVal(ro + rd * t); //<- this is the value of the function in first step\n    float g = GradUSV(ro + rd * t, rd);   //<- Find the gradient at the point, in the ray's direction\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++) //<- The Newtonian approximation loop\n    {\n        t -= v / g;    //<- find the x intercept of the gradient\n        \n        v = UnitSphereVal(ro + rd * t);  //<- Update the new value\n        g = GradUSV(ro + rd * t, rd);    //<- Update the new gradient\n    }\n    \n    if(abs(v) <= SURF && t > 0.)   //<- if the t value is positive, and the function value is within the perameters, then you've hit the surface within the view\n    {\n        inorm = ro + rd * t;  //<- set the internal normal to the normal of the point on the sphere, which is that point in the case of a unit sphere at the origin.\n    }\n    else\n    {\n        t = MAXDIST;  //<- otherwise, the point is either out of view, or not on the surface, set it to the max view distance to effectively exclude.\n    }\n    \n    if(t < D)   //<- if the calculated point is closer than the passed in point...\n    {\n        norm = inorm;   //<- set the passed in point to the internal calculated normal\n        D = t;          //<- set the passed in distance to the calculated distance\n    }\n}\n\n//-[ Plane Functions ]-//\nfloat SDPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat GradSDP(vec3 p, vec3 rd, vec4 n)\n{//-> Oneshade's Analytic gradient\n    return dot(rd, n.xyz); \n}\n\nvoid SSDP(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 n)\n{\n    float t = MAXDIST;\n    \n    float sol = (dot(ro, n.xyz) + n.w) / dot(rd, -n.xyz);\n    \n    if(sol >= 0.) t = sol;\n    \n    if(t < D)\n    {\n        D = t;\n        norm = n.xyz;\n    }\n}\n\nvoid NSDP(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 n)\n{\n    float t = SDPlane(ro, n);\n    float v = SDPlane(ro + rd * t, n);\n    float g = GradSDP(ro + rd * t, rd, n);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g !=0.; i++)\n    {\n        t -= v / g;\n        \n        v = SDPlane(ro + rd * t, n);\n        g = GradSDP(ro + rd * t, rd, n);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = n.xyz; //<- Since the plane is partially defined by its normal, just return the normal of the plane.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\n//-[ Sphere Functions ]-//\nfloat SphereVal(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat GradSV(vec3 p, vec3 rd, vec4 s)\n{ //-> Oneshade's Analytic Gradient\n    p -= s.xyz;\n    return dot(p, rd) / length(p);\n}\n\nvoid NSV(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{\n    float t = SphereVal(ro, s);\n    float v = SphereVal(ro + rd * t, s);\n    float g = GradSV(ro + rd * t, rd, s);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++)\n    {\n        t -= v / g;\n        \n        v = SphereVal(ro + rd * t, s);\n        g = GradSV(ro + rd * t, rd, s);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = ((ro + rd * t) - s.xyz) / s.w;  //<- the normal of a sphere at a given point on that shpere is simply just that point relative to the sphere's center devided by the radius of that sphere.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\n//-[ Scalar Field for Sphere ]-//\nfloat SFSphere(vec3 p, vec4 s)\n{//-> Here is a raw scalar field of a sphere.\n    vec3 q = p - s.xyz;\n    return dot(q, q) - (s.w * s.w);\n}\n\nfloat SFSGrad(vec3 p, vec3 rd, vec4 s)\n{\n    vec3 q = p - s.xyz;\n    vec3 g = 2. * q;     //<- true gradient of the scalar field\n    return dot(rd, g);\n}\n\nvoid NSFS(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{//-> Newton-Raphson approximation for the given sphere scalar field\n    float t = 0.;\n    float v = SFSphere(ro + rd * t, s);\n    float g = SFSGrad(ro + rd * t, rd, s);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++)\n    {\n        t -= v / g;\n        \n        v = SFSphere(ro + rd * t, s);\n        g = SFSGrad(ro + rd * t, rd, s);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = ((ro + rd * t) - s.xyz) / s.w;  //<- the normal of a sphere at a given point on that shpere is simply just that point relative to the sphere's center devided by the radius of that sphere.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\nvoid SSFS(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{//-> Direct solution of the scalar field for the sphere\n    vec3 o = ro - s.xyz;\n    vec3 d = rd;\n    float r = s.w;\n    \n    float a = dot(d, d);\n    float b = dot(o, d);\n    float c = dot(o, o) - (r * r);\n    \n    float dis = b*b - a * c;\n    \n    float t = MAXDIST;\n    \n    if(dis >= 0.0)\n    {\n        float z0 = (-b - sqrt(dis)) / a;\n        float z1 = (-b + sqrt(dis)) / a;\n\n        t = min(z0, z1);\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = ((ro + rd * t) - s.xyz) / s.w;\n    }\n}\n\n//-[ Rendering things ]-//\nfloat Sun(vec3 norm)\n{\n    float val = 0.;\n    \n    vec3 sun = normalize(-vec3(sin(iTime), -2., cos(iTime)));\n    val = dot(sun, norm);\n    \n    return val;\n}\n\n//-[ ENTRY POINT ]-//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UV to -1, 1 relative to the X of the resolution\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x * 2.0;\n    \n    //[ Camera set-up ]//\n    vec3 co = vec3(0., 0., -5.);         //<- This is the camera's origin\n    vec3 cd = normalize(vec3(uv, 1.));   //<- This is the ray's direction\n    \n    \n    vec3 norm = vec3(0., 0., 0.);\n    float d = MAXDIST;\n    \n    //-[ Object calculations ]-//\n    SSFS(co, cd, norm, d, vec4(0., 0., 0., 1.));\n    SSDP(co, cd, norm, d, vec4(0., 1., 0., 1.));\n    \n    \n    vec3 col = vec3(Sun(norm));\n    //vec3 col = vec3(d / iTime);\n    \n    \n    // Output\n    fragColor = vec4(col, 1.);\n}\n/*\n    Remarks:\n        I've come to realize that faster algorithms tend to be more\n        complex, yet, ones that tend to look better are much simpler.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2062, 2094, 2159, 2159, 2188], [2190, 2190, 2287, 2287, 2399], [2401, 2401, 2530, 2530, 3952], [3954, 3980, 4011, 4011, 4045], [4047, 4047, 4087, 4120, 4150], [4152, 4152, 4230, 4230, 4418], [4420, 4420, 4498, 4498, 5102], [5104, 5131, 5164, 5164, 5202], [5204, 5204, 5243, 5277, 5330], [5332, 5332, 5409, 5409, 6105], [6107, 6141, 6173, 6217, 6279], [6281, 6281, 6321, 6321, 6434], [6436, 6436, 6514, 6581, 7263], [7265, 7265, 7343, 7398, 7849], [7851, 7878, 7900, 7900, 8036], [8038, 8060, 8117, 8182, 8770]], "test": "untested"}
{"id": "stS3Ww", "name": "Ellipse Extraction", "author": "oneshade", "description": "Extracting the major and minor axes from an ellipse in the general quadric form. There are two versions, one that uses trig and one that doesn't. The one with trig is simpler but I'm unsure in terms of performance.", "tags": ["2d", "quadric", "ellipse", "conversion", "extraction"], "likes": 3, "viewed": 75, "published": "Public", "date": "1623991446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// See the desmos graphs where I worked most of this out:\n// Computing major and minor axes: https://www.desmos.com/calculator/12t322u7xa\n// Converting ellipse with center and axes to a general quadric: https://www.desmos.com/calculator/tialwuz5wh\n// I was thinking of using this to parametrize the intersection\n// between a plane and an ellipsoid\n\n// Drawing utility\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Main stuff\nstruct Quadric { float a; float b; float c; float d; float e; float f; };\nstruct Ellipse { vec2 center; mat2 axes; };\n\nfloat evalQuadric(in vec2 p, in Quadric q) {\n    return q.a * p.x * p.x + q.b * p.y * p.y + q.c * p.x * p.y +\n           q.d * p.x + q.e * p.y + q.f;\n}\n\nvec2 evalQuadricPrime(in vec2 p, in Quadric q) {\n    return vec2(2.0 * q.a * p.x + q.c * p.y + q.d,\n                2.0 * q.b * p.y + q.c * p.x + q.e);\n}\n\n#if 0 // Trig version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float a = 0.5 * atan(q.b - q.a, q.c);\n    vec2 k = vec2(cos(a), sin(a));\n    float i = k.x - k.y, j = k.x + k.y;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n\n#else // Trigless version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float ba = q.b - q.a, r = ba / q.c;\n    float ca = 0.5 * sign(q.c) / sqrt(1.0 + r * r);\n    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);\n    float i = ch - sh, j = ch + sh;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n#endif\n\nQuadric implicitizeEllipse(in Ellipse e) {\n    mat2 inv = inverse(e.axes);\n    vec2 ce = inv * e.center;\n    return Quadric(dot(inv[0], inv[0]),\n                   dot(inv[1], inv[1]),\n                   2.0 * dot(inv[0], inv[1]),\n                   -2.0 * dot(inv[0], ce),\n                   -2.0 * dot(inv[1], ce),\n                   dot(ce, ce) - 1.0);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.05, sdIsosceles(p - vec2(0.0, m), 0.2, 0.35));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec3 color = vec3(0.15);\n    float unit = 16.0 / iResolution.y;\n\n    // Ellipse position and axes for testing\n    vec2 pos = vec2(3.0 * cos(iTime), sin(2.0 * iTime));\n    vec2 ab = vec2(2.0 + cos(iTime), 2.0 + sin(iTime));\n    float rot = iTime - 2.0 * sin(0.5 * iTime);\n\n    // Rotate and scale\n    vec2 u = vec2(cos(rot), sin(rot));\n    vec2 v = vec2(-u.y, u.x) * ab.y;\n    u *= ab.x;\n\n    // Add some shear\n    u.y += 0.5 + cos(iTime);\n    v.x += 0.5 - sin(iTime);\n\n    // Implicitize the ellipse and then extract the center and axes\n    // This makes it possible to make an identity check\n    Quadric q = implicitizeEllipse(Ellipse(pos, mat2(u, v)));\n    Ellipse e = parametrizeEllipse(q);\n\n    // Grid\n    float spacing = 0.5, hSpacing = 0.5 * spacing;\n    drawSDF(abs(mod(uv.x + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n    drawSDF(abs(mod(uv.y + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n\n    drawSDF(abs(uv.x) - 0.01, vec3(0.6, 0.0, 0.0));\n    drawSDF(abs(uv.y) - 0.01, vec3(0.0, 0.0, 0.6));\n\n    // Quadric\n    drawSDF(evalQuadric(uv, q) / length(evalQuadricPrime(uv, q)), vec3(0.0, 0.0, 1.0));\n\n    // Draw an outline using the extracted ellipse parameters\n    uv -= e.center;\n    float tStep = 0.2;\n    float coStep = cos(tStep), siStep = sin(tStep);\n    mat2 stepMat = mat2(coStep, siStep, -siStep, coStep);\n    vec2 prev = vec2(1.0, 0.0);\n    for (float t=0.0; t < 6.28; t += tStep) {\n        vec2 cur = stepMat * prev;\n        drawSDF(sdLine(uv, e.axes * prev, e.axes * cur) - 0.01, vec3(1.0));\n        prev = cur;\n    }\n\n    // Original axes\n    drawSDF(abs(dot(uv, normalize(vec2(-u.y, u.x)))) - 0.02, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(dot(uv, normalize(vec2(-v.y, v.x)))) - 0.02, vec3(0.0, 1.0, 0.0));\n\n    // Computed axes and center\n    drawSDF(sdVectorArrow(uv, e.axes[0]), vec3(1.0, 0.5, 0.0));\n    drawSDF(sdVectorArrow(uv, e.axes[1]), vec3(0.8, 1.0, 0.0));\n    drawSDF(length(uv) - 0.1, vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stS3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 582, 626, 626, 733], [735, 735, 783, 783, 888], [2297, 2297, 2339, 2339, 2654], [2656, 2664, 2711, 2711, 2819], [2821, 2821, 2866, 2866, 2934], [2936, 2936, 2990, 2990, 3266], [3268, 3268, 3311, 3311, 3498], [3500, 3500, 3555, 3555, 5739]], "test": "untested"}
{"id": "stS3zW", "name": "Rainbow Melting", "author": "playmobil", "description": "A simple but yet nice and colorful effect.", "tags": ["colorful", "fluid", "loop", "rainbow", "melting"], "likes": 4, "viewed": 59, "published": "Public", "date": "1623424295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Rainbow Melting - By Sandro Benigno - Jun, 2021\n\n#define PI radians(180.)\n\n//2D Rotation Matrix\nmat2 rotate2D(float a){\n    return mat2(-sin(a), cos(a),\n                 cos(a), sin(a));\n}\n\n//Using polar coords calc in a creative way\nvec2 wave(vec2 v, float r){\n    return vec2(r*cos(v.x),r*sin(v.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    //Time tunning\n    float tmp = iTime / 2.0;\n\n    //Normalizing ST coords (centered origin)\n    st = st * 2.0 - 1.0;\n    //Correcting the aspect ratio\n    st.x *= ratio;\n\n    //Rotating by matrix multiplying\n    st *= rotate2D(0.75 * PI * tmp/4.);\n\n    //Zooming in/out\n    st *= sin(iTime/4.0 * PI) + 2.0;\n\n    //Applying the distortion\n    st = wave(st*6.0,0.3);\n\n    //Base Color\n    vec3 c = vec3(0.0);\n\n    //Shapping block\n    float dist = distance(st,vec2(cos(tmp*2.0)/2.0,sin(tmp*2.0)/2.0));\n    float r = 0.6;\n    float mask = smoothstep(r+0.5,r-0.5,dist);\n    float distfrac = fract(pow(dist,-1.5)+tmp*4.0);\n\n    //Coloring with some fractional offsets\n    c.r = fract((1.0 - distfrac)*5.2) * ( 1.0 - mask);\n    c.g = fract((1.0 - distfrac)*2.0) * ( 1.0 - mask);\n    c.b = fract((1.0 - distfrac)*1.5) * ( 1.0 - mask);\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stS3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 98, 121, 121, 190], [192, 236, 263, 263, 305], [307, 307, 364, 414, 1391]], "test": "untested"}
{"id": "stsGDs", "name": "20210608 eclipse", "author": "kamonumber", "description": "I drew a semicircle, like a solar eclipse.", "tags": ["glow"], "likes": 3, "viewed": 66, "published": "Public", "date": "1623161382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    uv.x-=iResolution.x/iResolution.y/2.0;//画面の中心を0,0にして範囲を-1.0~1.0くらいにする\n    uv.y-=0.1;//中心をずらす\n    uv.y*=1.05;//縦につぶす\n\n   float r = 0.6;//円の半径\n   float y=sqrt(pow(r,2.0)-pow(uv.x,2.0));//円の式\n   float col =((((sin(iTime)+(sin(iTime*0.7))/2.0+2.01)/100.0)/length(y-uv.y)));//関数\n\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 535]], "test": "untested"}
{"id": "stSGDW", "name": "Distortions_", "author": "Vinicius_Jesus", "description": "playing with scales and distortions", "tags": ["circles", "distortion", "colors"], "likes": 3, "viewed": 57, "published": "Public", "date": "1623890524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.5;\n    \n    float r = sqrt(uv.x*uv.x+uv.y*uv.y)/15.0;\n    float size1 = 2.0 * sin(iTime/5.);\n    \n    float distor = 20.;\n    \n    float a = 60.0 * sin(distor*atan(uv.x+size1*uv.y/r,uv.y-size1*uv.x/r)+iTime);\n    a += 500.0 - cos(iTime)*50.;\n    a = a*(r/50.0);\n    a = 200000.0*sin(a*6.0)*(r/30.0);\n    \n    vec3 col = vec3(cos(a/20.0),a/cos(a/200.0),sin(a/200.0));\n    \n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 571]], "test": "untested"}
{"id": "stSGR3", "name": "Lorenz attractor Weirdness", "author": "Bupeldox", "description": "Uses a lorenz attractor, a chaotic equation, to do weird stuff.\nThis compares start point of the strange attractor (screen xy + z kinda time), to the output (as the rotation from 0,1).", "tags": ["math", "trippy", "lorenz"], "likes": 3, "viewed": 67, "published": "Public", "date": "1624354547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat speed = 1.;\nfloat scale = 4000.0;\nvec2 offset = vec2(0.0,0.0);\nfloat yitterations = 10.;\n\nfloat infinity = 1.0/0.0;\n\nfloat zinp = 0.0;\n\n\n\nfloat tSin(float inp){\nreturn (sin(inp)+1.)/2.;\n}\n\nvec3 LorenzDifferential(vec3 tinput,float delta){\n    float sigma = 20.0;\n    float beta= pow(tSin(speed*iTime/1.242)*10.0,2.);\n    float ohmega= pow(tSin(speed*iTime/4.35)*10.0,2.);\n\n    float x = tinput.x;\n    float y = tinput.y;\n    float z = tinput.z;\n    \n    vec3 newPoint = vec3(\n        (sigma*(y-(x))),\n        (x*(ohmega-abs(z)))-y,\n        ((x*y)-(beta*z))\n    );\n    newPoint = newPoint * delta;\n    return newPoint;\n}\n\n\nvec3 lorenzAttractor(vec3 start,float delta,float itterations){\n\t\n\t\n    \n\tvec3 currentPoint = start;\n    \n\t\n\tfor(float i = 0.;i<itterations;i+=1.0){\n\t\tvec3 tdelta = LorenzDifferential(currentPoint,delta);\n        vec3 newPoint = currentPoint + tdelta;\n        \n        if(abs(newPoint.x)==infinity||abs(newPoint.y)==infinity||abs(newPoint.z)==infinity){\n            //return vec3(max(-i,newPoint.x),max(-i,newPoint.y),max(-i,newPoint.z));\n            return vec3(-i);\n        }\n        \n\t\tcurrentPoint = newPoint;\n\t}\n    \n    vec3 finalTDelta = LorenzDifferential(currentPoint,delta*mod(itterations,1.));\n    \n\treturn currentPoint+finalTDelta;\n}\n\n\nvec3 canvasPToCoord(vec2 inp){\n\n\n    inp = inp - (iResolution.xy*0.5);\n    inp = inp/iResolution.xx;\n    inp.x *= 0.2;\n    inp = inp * scale;\n    inp = inp + offset;\n\treturn vec3(inp,zinp);\n}\n\nfloat transformFunc (float x){\n    //The largest sig fig.\n    float a = floor(log(x))/log(10.)-1.0;\n    float b = x/pow(10.,a);\n    float c = (b-10.)/90.;\n    return min(max(c,0.),1.);\n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 colourTransform(vec3 col){\n        ///*\n        //Winding\n\n        float angle = acos(dot(normalize(col.xy), vec2(0.,1.)));\n          float dist = length(col);\n        vec3 hsv = vec3(angle/(3.1415*2.),0.5,min(max(sqrt(dist)/20.,0.),1.));\n        col = hsv2rgb(hsv);\n        return col;\n        /**/\n        \n        /*\n        //Exponent\n        /**/\n        \n        /*\n        //Exponential Grid\n        col.x =transformFunc(col.x);\n        col.y =transformFunc(col.y);\n        col.z =transformFunc(col.z);\n        col = col*9.;\n        return col;\n        /**/\n\n}\n\n\n\nvec3 colorTransform2(vec3 col){\n   \n    vec3 hsl = rgb2hsv(col);\n\n    hsl.x = hsl.x/2.;\n    hsl.x+=mod(speed*iTime/12.3,1.0);\n    hsl.z = pow(hsl.z,0.2);\n    hsl.x += 0.5;\n\n    return hsv2rgb(hsl);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float tTime = speed*iTime/2.0;\n   \n    \n    float szoom = (sin(tTime/2.)+1.0);\n    \n    yitterations = 5. + ((sin(tTime)+1.0)*80.0);\n     \n     \n     \n     \n    scale = ((szoom+3.0)-pow((sin(tTime))+1.,1.1)) *3000.0;\n    zinp = cos(tTime/3.14)*1000.0;\n     \n    vec3 col = vec3(0);\n    \n    vec3 p = canvasPToCoord(fragCoord);\n    \n    \n    vec3 endPoint = lorenzAttractor(p,0.001,yitterations);\n    endPoint = abs(endPoint);\n    col = colourTransform(endPoint); \n    \n    \n    col=colorTransform2(col);\n    \n    \n    /*\n    if(col.x<=0. && col.y<=0. && col.z<=0.&&false){\n       //20 15000\n       //90 2500\n        scale = 2000. + ((sin(tTime)+1.0)*((15000.-2500.)/2.));\n        yitterations = 20. + ((sin(tTime+(3.14))+1.0)*45.0);\n        zinp = 1000.;\n        p = canvasPToCoord(fragCoord);\n        zinp = cos(tTime/-3.14)*1000.0;\n        endPoint = lorenzAttractor(p,-0.001,yitterations); //Reverse the differetial\n\n        endPoint = colourTransform(endPoint); \n\n        col=colorTransform2(endPoint);\n        //col=vec3(1.0,1.0,1.0);\n    }*/\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 167, 167, 194], [196, 196, 245, 245, 626], [629, 629, 692, 692, 1274], [1277, 1277, 1307, 1307, 1468], [1470, 1470, 1500, 1527, 1656], [1657, 1657, 1679, 1679, 2010], [2013, 2013, 2035, 2035, 2204], [2207, 2207, 2238, 2269, 2779], [2783, 2783, 2814, 2814, 2983], [2986, 2986, 3043, 3043, 4143]], "test": "untested"}
{"id": "stSGRV", "name": "20210620_SPACE_GARDEN", "author": "FMS_Cat", "description": "live coded in Bonzomatic, 45 minutes\n\nhttps://twitter.com/urrativ/status/1403290917898010625", "tags": ["3d", "fractal", "raymarcher", "livecoding"], "likes": 14, "viewed": 109, "published": "Public", "date": "1624246958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fs(i) (fract(sin(i*114.514)*1919.810))\n#define lofi(i,j) (floor((i)/(j))*(j))\n\nfloat time;\nfloat seed;\n\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\n// Pinieon !!!!!!!!\n\nfloat random(){\n  seed=fs(seed+1.);\n  return seed;\n}\n\nvec3 randomSphere(){\n  float phi=TAU*random();\n  float theta=acos(random()*2.-1.);\n  return vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));\n}\n\nvec3 randomHemisphere(vec3 n){\n  vec3 d=randomSphere();\n  return dot(d,n)<0.0?-d:d;\n}\n\nmat2 r2d(float t){\n  return mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nfloat sdbox(vec3 p,vec3 s){\n  vec3 d=abs(p)-s;\n  return min(0.,max(d.x,max(d.y,d.z)))+length(max(d,vec3(0.0)));\n}\n\nfloat ease(float t){\n  return 0.5+0.5*cos(PI*exp(-t*5.));\n}\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y)>.99?vec3(0,0,1):vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 s){\n  mat3 b=orthBas(rot);\n  for(int i=0;i<6;i++){\n    s*=b;\n    s*=0.56;\n    p=abs(p)-abs(s);\n    p.xy=p.x<p.y?p.yx:p.xy;\n    p.yz=p.y<p.z?p.zy:p.yz;\n  }\n  return p;\n}\n\nvec3 noise(vec3 p,vec3 bas,float pump){\n  mat3 b=orthBas(bas);\n  vec4 sum=vec4(0);\n  float warp=1.1;\n  for(int i=0;i<5;i++){\n    p*=b;\n    p*=2.0;\n    p+=sin(p.yzx);\n    sum+=vec4(cross(sin(p.zxy),cos(p)),1);\n    sum*=pump;\n    warp*=1.3;\n  }\n  return sum.xyz/sum.w;\n}\n\nvec4 map(vec3 p){\n  vec3 pt=p;\n  pt.zx=r2d(time*.1)*pt.zx;\n  pt.z-=.1*time;\n  vec3 cell=lofi(pt,2.0)+1.0;\n  pt-=cell;\n  float heck=abs(pt.x)+abs(pt.y)+abs(pt.z);\n  float clampbox=sdbox(pt,vec3(0.8));\n  float ph=0.5*time+0.2*(cell.x+cell.y+cell.z);\n  vec3 rot=mix(\n    fs(vec3(1.4,2.1,3.5)+floor(ph)),\n    fs(vec3(1.4,2.1,3.5)+floor(ph+1.)),\n    ease(fract(ph))\n  );\n  vec3 sh=1.0+0.2*mix(\n    fs(vec3(2.4,3.1,1.5)+floor(ph)),\n    fs(vec3(2.4,3.1,1.5)+floor(ph+1.)),\n    ease(fract(ph))\n  );\n  pt=ifs(pt,rot,sh);\n  float d=sdbox(pt,vec3(.04));\n  d=max(d,clampbox);\n  //d+=0.002*noise(2.0*p,vec3(1),2.0).x;\n\n  return vec4(d,1,min(abs(pt.x),abs(pt.z)),0);\n}\n\nvec3 nmap(vec3 p,vec2 d){\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aomap(vec3 p,vec3 n){\n  float accum=0.0;\n  for(int i=0;i<30;i++){\n    vec3 pt=p+n*random()*randomHemisphere(n);\n    float d=map(pt).x;\n    accum+=smoothstep(0.0,-0.02,d)/30.0;\n  }\n  return 1.0-sqrt(accum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 p=uv*2.-1.;\n  p.x*=iResolution.x/iResolution.y;\n  \n  time=iTime;\n  seed+=texture(iChannel0,8.0*uv).x;\n  seed+=fract(time);\n  \n  time+=0.02*random();\n\n  vec3 ro=vec3(0,0,2);\n  vec3 rd=normalize(vec3(p,-1.+.4*length(p)));\n  rd.xy=r2d(time*.1)*rd.xy;\n  \n  vec3 col=vec3(0);\n  vec3 colRem=vec3(1);\n\n  for(int iR=0;iR<2;iR++){\n    float rl=1E-2;\n    vec3 rp=ro+rd*rl;\n    vec4 isect;\n    \n    for(int i=0;i<128;i++){\n      isect=map(rp);\n      rl+=isect.x*.6;\n      rp=ro+rd*rl;\n      \n      if(abs(isect.x)<1E-3){break;}\n    }\n    \n    float fog=exp(-0.04*rl);\n    vec3 haha=0.5+0.5*sin(-2.0+3.0*exp(-rl)+vec3(0,2,4));\n    haha+=vec3(0.2,0.5,1.1);\n    col+=colRem*(1.0-fog)*4.0*haha;\n    vec3 n=nmap(rp,vec2(0,1E-3));\n    float f=1.0-clamp(dot(-rd,n),0.,1.);\n    f=f*f*f*f*f;\n    col+=colRem*f*4.0*haha;\n    \n    if(abs(isect.x)<1E-3){\n      float ao=aomap(rp,n);\n      col+=0.2*colRem*fog*vec3(ao);\n      col+=vec3(0.1,1.0,0.2)*colRem*fog*smoothstep(0.001,0.0005,isect.z);\n      colRem*=0.1+0.9*f;\n      \n      ro=rp+n*1E-2;\n      rd=reflect(rd,n);\n    }else{\n      break;\n    }\n  }\n  \n  col=pow(col,vec3(.4545));\n  col*=1.-length(p)*.3;\n  col=vec3(\n    smoothstep(0.04,0.92,col.x),\n    smoothstep(-0.08,0.97,col.y),\n    smoothstep(-0.2,1.03,col.z)\n  );\n\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 183, 198, 198, 235], [237, 237, 257, 257, 388], [390, 390, 420, 420, 475], [477, 477, 495, 495, 542], [544, 544, 571, 571, 657], [659, 659, 679, 679, 718], [720, 720, 741, 741, 873], [875, 875, 908, 908, 1073], [1075, 1075, 1114, 1114, 1343], [1345, 1345, 1362, 1362, 1999], [2001, 2001, 2026, 2026, 2163], [2165, 2165, 2192, 2192, 2378], [2380, 2380, 2436, 2436, 3800]], "test": "untested"}
{"id": "stSGWD", "name": "Sin Lines ", "author": "Vinicius_Jesus", "description": "play", "tags": ["lines", "sin", "laser"], "likes": 10, "viewed": 127, "published": "Public", "date": "1624073061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv.x -= 1.;\n    //uv.x += 355.;\n    \n    vec3 color = vec3(0.);\n    \n    for( float i = 1.; i < 15.; ++i )\n    {\n        float t = iTime;\n        uv.y += sin(uv.x*i + t+i/2.) * .2;\n        float fTemp = abs(1. / uv.y / 100.);\n        color += vec3(fTemp*(10.-i)/10., fTemp/10., vec2(fTemp)*1.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 463]], "test": "untested"}
{"id": "stsGzX", "name": "Infinite Stars", "author": "IamWiki", "description": "This is the first time I used fractional parts of the rays in order to create an infinite number of shapes. I used it on one of my experimental shaders and this is the result. * - *", "tags": ["star", "stars", "infinite", "infinity", "dimension"], "likes": 6, "viewed": 129, "published": "Public", "date": "1622561534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100.\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat smin(float a, float b, float h)\n{\n    float k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h)\n{\n    vec3 k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 tunnel(vec3 p)\n{\n    vec3 off = vec3(0);\n    float dd = p.z * 0.02;\n    dd = floor(dd) + smoothstep(0., 1., smoothstep(0., 1., fract(dd)));\n    dd *= 1.7;\n    off.x += sin(dd) * 10.;\n    off.y += sin(dd * 0.7) * 10.;\n\n    return off;\n}\n\nvec3 kif(vec3 p, float t)\n{\n  float d;\n  float s = 10.;\n  for(int i = 0; i < 5; ++i)\n  {\n    p.xy *= rot(t);\n    p.xz *= rot(t*.7);\n    p = smin(p, -p, -1.);\n    p -= s;\n    \n    //p -= s + sin(t - length(p));\n    s *= 0.4;\n  }\n  \n  return p;\n}\n\nfloat at = 0.;\nfloat atsph = 0.;\nfloat atbsph = 0.;\nfloat map(vec3 p)\n{\n    \n    vec3 p1 = p;\n    vec3 p2 = rep(p, 100.);\n    \n    p1 = kif(p2, iTime * 0.1);\n    p1.xy *= rot(iTime * 0.3);\n    p1.xz *= rot(iTime * 0.7);\n    float d1 = box(p1, vec3(0.01));\n    float d2 = sphere(p2, 10.5);\n    float d3 = sphere(p2, .8);\n    float d4 = sphere(p2, 3.);\n    \n    float d = max(d1, d2);\n\n    at += 0.1 / (0.01 + abs(d2));\n    atsph += 0.1 / (0.0 + abs(d3));\n    d3 = min(d3, d4);\n    atbsph += 0.3 / (0.01 + abs(d4));\n    d = min(d, d3);\n\n    return d;\n}\n\nvoid cam(inout vec3 p)\n{\n    float t = iTime * 0.05;\n    p.xy *= rot(t);\n    p.xz *= rot(t * 0.7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n    vec3 s = vec3(0, 0, -50);\n    vec3 r = vec3(uv, 1);\n    //s -= tunnel(s);\n\n    cam(s);\n    cam(r);\n\n    s.z += iTime * 10.;\n    s.x += sin(iTime / 16.) * 25.;\n\n    vec3 p = s;\n    float d = 0.;\n\n    float i = 0.;\n    float dd = 0.;\n    vec3 off = vec3(0.1, 0, 0);\n    for(i = 0.; i < MAX_STEPS; i++)\n    {\n        d = map(p);\n        dd += d;\n        d *= 0.4;\n        //vec3 n = normalize(map(p) - vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        if(d < 0.001)\n        {\n            d = 0.1;\n        }\n        p += r*d;\n    }\n    \n    atsph *= 50.;\n    \n    vec3 col = vec3(0);\n    //col += vec3(pow(1.-i/(MAX_STEPS + 1.), 3.)) * 1.;\n    col += pow(at * 0.016, 6.) * vec3(0.5,0,0.5);\n    col += pow(atsph * 0.016, 3.) * vec3(1,0,0);\n    col += pow(atbsph * 0.2, sin(iTime * 2.)*.1+1.1) * vec3(0,1.,0.);\n\n    //float dist = length(p-s);\n    //col -= 1. / dist;\n    \n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 95], [138, 138, 169, 169, 197], [199, 199, 226, 226, 284], [286, 286, 325, 325, 416], [418, 418, 454, 454, 544], [546, 546, 567, 567, 786], [788, 788, 815, 815, 1032], [1086, 1086, 1105, 1105, 1584], [1586, 1586, 1610, 1610, 1686], [1688, 1688, 1743, 1743, 2806]], "test": "untested"}
{"id": "stsXzr", "name": "Ann The Bee", "author": "Pebaz", "description": "First non-hello world SDF painting.", "tags": ["sdf"], "likes": 8, "viewed": 74, "published": "Public", "date": "1625083923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nHello World Shader\n\nWorks on Shadertoy and in the Visual Studio Code extension:\nhttps://github.com/actarian/vscode-glsl-canvas\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n// Cross-Platform SDF Header\n////////////////////////////////////////////////////////////////////////////////\n\n// Uncomment to deploy to Shadertoy\n#define SHADERTOY\n\n// Uncomment to deploy to Win32\n// #version 430 core\n// #define WIN32\n\n// -----------------------------------------------------------------------------\nvoid fragment(vec2 uv, out vec3 color);\n\n#ifdef SHADERTOY\n    #define resolution iResolution\n    #define time iTime\n    #define mouse\n\n    void mainImage(out vec4 out_color, in vec2 frag_coord)\n    {\n        vec2 uv = (2.0 * frag_coord.xy - resolution.xy) / resolution.y;\n        vec3 color = vec3(0);\n        fragment(uv, color);\n        out_color = vec4(color, 1);\n    }\n\n#elif defined(WIN32)\n    out vec4 color;\n\n    uniform vec2 resolution;\n    uniform float time;\n\n    void main()\n    {\n        vec2 uv = (2.0 * gl_FragCoord.xy - resolution.xy) / resolution.y;\n        vec3 final_color = vec3(0);\n        fragment(uv, final_color);\n        color = vec4(final_color, 1);\n    }\n\n#else  // VS Code\n    precision mediump float;\n\n    uniform vec2 u_resolution;\n    uniform float u_time;\n    uniform sampler2D u_texture_0;\n    uniform sampler2D u_texture_1;\n\n    #define resolution u_resolution\n    #define time u_time\n    #define mouse\n\n    void main()\n    {\n        vec2 uv = (2.0 * gl_FragCoord.xy - resolution.xy) / resolution.y;\n        vec3 color = vec3(0);\n        fragment(uv, color);\n        gl_FragColor = vec4(color, 1);\n    }\n#endif\n\nconst int max_steps = 100;\nconst float max_distance = 5.0;\nconst float surface_hit = 0.001;\nconst float epsilon = 0.001;\n\n#define WHITE 1\n#define BLACK 2\n#define LIGHT_BROWN 3\n#define BROWN 4\n#define YELLOW 5\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float length;\n};\n\nstruct Hit\n{\n    vec3 position;\n    float distance;\n    int object_type;\n    vec2 uv;\n    vec3 normal;\n};\n\nfloat sdf_sphere(const in vec3 point, const in vec3 origin, const in float radius)\n{\n    return length(point - origin) - radius;\n}\n\nfloat sdf_box(vec3 point, vec3 origin, vec3 bounds)\n{\n    vec3 dist = abs(point - origin) - bounds;\n    return length(\n        max(dist, 0.0)\n    ) + min(\n        max(dist.x, max(dist.y, dist.z)),\n        0.0\n    );\n}\n\nfloat sdf_line(vec3 point, vec3 point_a, vec3 point_b, float radius)\n{\n    vec3 a = point - point_a;\n    vec3 b = point_b - point_a;\n    float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);\n    return length(a - b * h) - radius;\n}\n\nvec3 rotate_x(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        point.x,\n        c * point.y + s * point.z,\n        -s * point.y + c * point.z\n    );\n\n    return result;\n}\n\nvec3 rotate_y(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        c * point.x + s * point.z,\n        point.y,\n        -s * point.x + c * point.z\n    );\n\n    return result;\n}\n\nvec3 rotate_z(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        c * point.x + s * point.y,\n        -s * point.x + c * point.y,\n        point.z\n    );\n\n    return result;\n}\n\nHit get_closer_hit(Hit a, Hit b)\n{\n    if (a.distance <= b.distance)\n        return a;\n    else\n        return b;\n}\n\nmat3 skew(float skew_angle, const in vec3 a, const in vec3 b)\n{\n    skew_angle = tan(skew_angle);\n    float x = a.x * skew_angle;\n    float y = a.y * skew_angle;\n    float z = a.z * skew_angle;\n\n    return mat3(\n        x * b.x + 1.0, x * b.y, x * b.z,\n        y * b.x, y * b.y + 1.0, y * b.z,\n        z * b.x, z * b.y, z * b.z + 1.0\n    );\n}\n\n// float round_merge(float shape1, float shape2, float radius) {\n//     float2 intersectionSpace = float2(shape1 - radius, shape2 - radius);\n//     intersectionSpace = min(intersectionSpace, 0);\n//     return length(intersectionSpace) - radius;\n// }\n\nHit body(vec3 point)\n{\n    Hit result;\n\n    result.position = point;\n\n    vec3 sample_point = point;\n    vec3 a = vec3(0, 1.0, 0);\n    vec3 b = vec3(0, 0, -1.0);\n    float skew_angle = 0.2;\n\n    sample_point = skew(skew_angle, a, b) * sample_point;\n\n    vec3 head_point = vec3(0, 0.05, 0.3);\n    vec3 tail_point = vec3(0, 0, -0.3);\n    float roundness = 1.0;\n    float body = sdf_line(sample_point, head_point, tail_point, roundness);\n\n    result.distance = body;\n    result.object_type = YELLOW;\n\n    // Determine material based on point on body\n    if (distance(sample_point, head_point * 5.5) < 1.0001)\n    {\n        result.object_type = LIGHT_BROWN;\n    }\n\n    else if (distance(sample_point, head_point * 2.5) < 1.005)\n    {\n        result.object_type = BROWN;\n    }\n\n    // else if (distance(sample_point, tail_point) < 1.0005)\n    // {\n    //     result.object_type = WHITE;\n    // }\n\n    else if (distance(point, tail_point * 4.0) < 1.25)\n    {\n        result.object_type = BROWN;\n    }\n\n    // Face\n\n    float eye1 = sdf_sphere(point, vec3(-0.35, 0.1, 1.18), 0.1);\n    float highlight1 = sdf_sphere(point, vec3(-0.36, 0.12, 1.27), 0.01);\n\n    if (eye1 < result.distance)\n    {\n        result.distance = min(result.distance, eye1);\n        result.object_type = BLACK;\n\n        if (highlight1 < result.distance)\n        {\n            result.distance = highlight1;\n            result.object_type = WHITE;\n        }\n    }\n\n    float eye2 = sdf_sphere(point, vec3(0.35, 0.1, 1.18), 0.1);\n    float highlight2 = sdf_sphere(point, vec3(0.36, 0.12, 1.27), 0.01);\n\n    if (eye2 < result.distance)\n    {\n        result.distance = min(result.distance, eye2);\n        result.object_type = BLACK;\n\n        if (highlight2 < result.distance)\n        {\n            result.distance = highlight2;\n            result.object_type = WHITE;\n        }\n    }\n\n    float smile_base = sdf_sphere(point, vec3(0, 0, 1.16), 0.2);\n    float smile_cutout = sdf_sphere(point, vec3(0, -0.15, 1.16), 0.1);\n    float smile = max(-smile_base, smile_cutout);\n    // float smile = min(smile_base, smile_cutout);\n\n    if (smile < result.distance)\n    {\n        result.distance = min(result.distance, smile);\n        result.object_type = BLACK;\n    }\n\n    return result;\n}\n\nHit foot(vec3 point, vec3 point_a, vec3 point_b, float radius)\n{\n    Hit result;\n\n    result.position = point;\n\n    float line = sdf_line(point, point_a, point_b, radius);\n\n    result.distance = line;\n    result.object_type = BLACK;\n\n    return result;\n}\n\nfloat rounded_cylinder(vec3 point, vec3 origin, float ra, float rb, float h)\n{\n    point -= origin;\n    vec2 d = vec2(length(point.xz) - 2.0 * ra + rb, abs(point.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nHit wings(vec3 point)\n{\n    Hit result;\n\n    result.position = point;\n\n    // float sphere = sdf_sphere(point, vec3(0, 2, 0), 1.0);\n\n    // float sphere = length(point - vec3(0, 2, 0)) - 1.0;\n\n    // float wing = rounded_cylinder(rotate_x(point, 1.5), vec3(0, 1, 0), 0.5, 0.1, 0.5);\n\n    vec3 origin = rotate_x(vec3(0.8, 0.8, 0.55) - point, 1.5) + point;\n    float wing = rounded_cylinder(point, origin, 0.17, 0.01, 0.03);\n    float wing_cutout = rounded_cylinder(point, origin + vec3(0, 0.05, 0), 0.1, 0.01, 0.03);\n    wing = max(wing, -wing_cutout);\n\n    vec3 origin2 = rotate_x(vec3(-0.8, 0.8, 0.55) - point, 1.5) + point;\n    float wing2 = rounded_cylinder(point, origin2, 0.17, 0.01, 0.03);\n    float wing_cutout2 = rounded_cylinder(point, origin2 + vec3(0, 0.05, 0), 0.1, 0.01, 0.03);\n    wing2 = max(wing2, -wing_cutout2);\n\n    result.distance = min(wing, wing2);\n    result.object_type = WHITE;\n\n    return result;\n}\n\nHit scene(vec3 point)\n{\n    Hit result = foot(point, vec3(0), vec3(0, 0, -1.35), 0.05);\n\n    Hit foot1 = foot(point, vec3(0, 0, 0.15), vec3(-0.65, -0.65, 0.75), 0.1);\n    Hit foot2 = foot(point, vec3(0, 0, -0.1), vec3(-0.75, -0.75, 0.0), 0.1);\n    Hit foot3 = foot(point, vec3(0, 0, -0.55), vec3(-0.75, -0.75, -0.65), 0.1);\n\n    Hit foot4 = foot(point, vec3(0, 0, 0.15), vec3(0.65, -0.65, 0.75), 0.1);\n    Hit foot5 = foot(point, vec3(0, 0, -0.1), vec3(0.75, -0.75, 0.0), 0.1);\n    Hit foot6 = foot(point, vec3(0, 0, -0.55), vec3(0.75, -0.75, -0.65), 0.1);\n\n    Hit wings = wings(point);\n\n    result = get_closer_hit(result, body(point));\n    result = get_closer_hit(result, foot1);\n    result = get_closer_hit(result, foot2);\n    result = get_closer_hit(result, foot3);\n    result = get_closer_hit(result, foot4);\n    result = get_closer_hit(result, foot5);\n    result = get_closer_hit(result, foot6);\n\n    result = get_closer_hit(result, wings);\n\n    return result;\n}\n\nvec3 get_scene_normal(const in vec3 point)\n{\n    vec3 offset1 = vec3(epsilon, -epsilon, -epsilon);\n    float f1 = scene(point + offset1).distance;\n    vec3 normal = offset1 * f1;\n\n    vec3 offset2 = vec3(-epsilon, -epsilon, epsilon);\n    float f2 = scene(point + offset2).distance;\n    normal += offset2 * f2;\n\n    vec3 offset3 = vec3(-epsilon, epsilon, -epsilon);\n    float f3 = scene(point + offset3).distance;\n    normal += offset3 * f3;\n\n    vec3 offset4 = vec3(epsilon, epsilon, epsilon);\n    float f4 = scene(point + offset4).distance;\n    normal += offset4 * f4;\n\n    return normalize(normal);\n}\n\nHit raymarch(Ray ray)\n{\n    Hit closest;\n\n    for (int step = 0; step < max_steps; step++)\n    {\n        vec3 point = ray.origin + ray.direction * ray.length;\n        closest = scene(point);\n        closest.position = point;\n\n        if (closest.distance < surface_hit)\n            break;\n\n        ray.length += closest.distance;\n\n        if (ray.length >= max_distance)\n            break;\n    }\n\n    closest.distance = ray.length;\n    return closest;\n}\n\nvec3 render(Ray ray)\n{\n    vec3 color = vec3(0);\n\n    Hit hit = raymarch(ray);\n\n    if (hit.distance <= max_distance)\n    {\n        vec3 normal = get_scene_normal(hit.position);\n\n        if (hit.object_type == WHITE)\n        {\n            color = vec3(1.0) - normal.x;\n        }\n\n        else if (hit.object_type == BLACK)\n        {\n            // color = abs(get_scene_normal(hit.position));\n            color = vec3(0.15);\n        }\n\n        else if (hit.object_type == LIGHT_BROWN)\n        {\n            color = vec3(189, 153, 91) / 255.0;\n        }\n\n        else if (hit.object_type == BROWN)\n        {\n            color = vec3(0.27, 0.17, 0.09);\n        }\n\n        else if (hit.object_type == YELLOW)\n        {\n            color = vec3(1, 0.78, 0);\n        }\n\n        vec3 light_color = vec3(0.2, 0.5, 0.7);\n        vec3 light_dir = normalize(rotate_y(vec3(0, -0.25, 1), -1.25));\n        float diff = max(dot(normal, light_dir), 0.0);\n        float sky_energy = 1.7;\n        vec3 sky = diff * light_color * sky_energy;\n        // sky = vec3(0);\n\n        vec3 light_color2 = vec3(0.7, 0.5, 0.2);\n        vec3 light_dir2 = normalize(rotate_y(vec3(0, 0.25, 1), 1.0));\n        float diff2 = max(dot(normal, light_dir2), 0.0);\n        float sun_energy = 1.2;\n        vec3 sun = diff2 * light_color2 * sun_energy;\n        // sun = vec3(0);\n\n        vec3 light_color3 = vec3(1);\n        vec3 light_dir3 = normalize(rotate_y(vec3(0, 1, 4), 2.75));\n        float diff3 = max(dot(normal, light_dir3), 0.0);\n        float wormhole_energy = 0.5;\n        vec3 wormhole = diff3 * light_color3 * wormhole_energy;\n        // wormhole = vec3(0);\n\n        // float diff2 = max(dot(normal, light_dir2), 0.0);\n        // lighting += vec3(diff2) * 0.5 * vec3(0.7, 0.5, 0.2);\n\n        // color = albedo * lighting;\n\n        vec3 ambient = vec3(0.3);\n\n        color = color * (ambient + sun + sky + wormhole);\n    }\n\n    else\n    {\n        color = normalize(normalize(hit.position) + vec3(2));\n    }\n\n    return color;\n}\n\nRay get_camera_ray(\n    const in vec3 vPos,\n    const in vec3 vForwards,\n    const in vec3 vWorldUp,\n    const in vec2 uv\n) {\n    vec2 vUV = uv;\n    vec2 vViewCoord = vUV;// * 2.0 - 1.0;\n\n    // float fRatio = resolution.x / resolution.y;\n    // vViewCoord.y /= fRatio;\n\n    Ray ray;\n\n    ray.origin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n\n    ray.direction = normalize(\n        vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards\n    );\n\n    return ray;\n}\n\nRay look_at(\n    const in vec3 vPos,\n    const in vec3 vInterest,\n    const in vec2 uv\n) {\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    return get_camera_ray(vPos, vForwards, vUp, uv);\n}\n\nvoid fragment(vec2 uv, out vec3 color)\n{\n    // vec3 ray_origin = rotate_y(vec3(0, sin(time * 0.25) * 1.5, 2.5), cos(time));\n    vec3 ray_origin = rotate_y(vec3(0, sin(time * 0.2), 2.5), time * 0.4);\n\n    Ray ray = look_at(\n        ray_origin,\n        vec3(0),\n        uv\n    );\n\n    color = render(ray);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 2067, 2151, 2151, 2197], [2199, 2199, 2252, 2252, 2416], [2418, 2418, 2488, 2488, 2645], [2647, 2647, 2705, 2705, 2898], [2900, 2900, 2958, 2958, 3151], [3153, 3153, 3211, 3211, 3404], [3406, 3406, 3440, 3440, 3521], [3523, 3523, 3586, 3586, 3865], [3867, 4118, 4140, 4140, 6359], [6361, 6361, 6425, 6425, 6615], [6617, 6617, 6695, 6695, 6852], [6854, 6854, 6877, 6877, 7778], [7780, 7780, 7803, 7803, 8749], [8751, 8751, 8795, 8795, 9353], [9355, 9355, 9378, 9378, 9808], [9810, 9810, 9832, 9832, 11812], [11814, 11814, 11939, 11939, 12341], [12343, 12343, 12433, 12433, 12575], [12577, 12577, 12617, 12701, 12883]], "test": "untested"}
{"id": "stX3Dl", "name": "Classic Normal Noise", "author": "Farini", "description": "Simplex Normal noise inspired by: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83", "tags": ["noise", "simplex", "normal"], "likes": 2, "viewed": 45, "published": "Public", "date": "1623085152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat simplexNoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 normalNoise(in vec2 _st, in float _zoom, in float _speed){\n\tvec2 v1 = _st;\n\tvec2 v2 = _st;\n\tvec2 v3 = _st;\n\tfloat expon = pow(10.0, _zoom*2.0);\n\tv1 /= 1.0*expon;\n\tv2 /= 0.62*expon;\n\tv3 /= 0.83*expon;\n\tfloat n = iTime*_speed;\n\tfloat nr = (simplexNoise(vec3(v1, n)) + simplexNoise(vec3(v2, n)) + simplexNoise(vec3(v3, n))) / 6.0 + 0.5;\n\tn = iTime * _speed + 1000.0;\n\tfloat ng = (simplexNoise(vec3(v1, n)) + simplexNoise(vec3(v2, n)) + simplexNoise(vec3(v3, n))) / 6.0 + 0.5;\n\treturn vec3(nr,ng,0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(normalNoise(fragCoord, 1., .2), 1.); //cnoise; //vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 58], [59, 59, 86, 86, 134], [136, 136, 163, 163, 1999], [2001, 2001, 2064, 2064, 2505], [2507, 2507, 2564, 2614, 2855]], "test": "untested"}
{"id": "stXGDB", "name": "Value noise 3D __", "author": "Envy24", "description": "value, noise, random", "tags": ["noise", "random", "value"], "likes": 1, "viewed": 48, "published": "Public", "date": "1622728578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * enthropy3 * enthropy2 +\n        y * enthropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat valuetNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n    \n    // Pseudorandom samples.\n    float sample0 = sample3DHashUI32(uint(u),       uint(v),       uint(w));\n    float sample1 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w));\n    float sample2 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w));\n    float sample3 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w));\n    float sample4 = sample3DHashUI32(uint(u),       uint(v),       uint(w + 1.0));\n    float sample5 = sample3DHashUI32(uint(u + 1.0), uint(v),       uint(w + 1.0));\n    float sample6 = sample3DHashUI32(uint(u),       uint(v + 1.0), uint(w + 1.0));\n    float sample7 = sample3DHashUI32(uint(u + 1.0), uint(v + 1.0), uint(w + 1.0));\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0 - 2.0 * fractU);\n    float tV = fractV * fractV * (3.0 - 2.0 * fractV);\n    float tW = fractW * fractW * (3.0 - 2.0 * fractW);\n\n    // Trilinear interpolation.\n    return \n        sample0 * (1.0 - tU) * (1.0 - tV) * (1.0 - tW) + \n        sample1 * tU         * (1.0 - tV) * (1.0 - tW) +\n        sample2 * (1.0 - tU) * tV         * (1.0 - tW) +\n        sample3 * tU         * tV         * (1.0 - tW) +\n        sample4 * (1.0 - tU) * (1.0 - tV) * tW + \n        sample5 * tU         * (1.0 - tV) * tW +\n        sample6 * (1.0 - tU) * tV         * tW +\n        sample7 * tU         * tV         * tW;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 6.0f;\n    \n    float _u = uv.x + iMouse.x * 0.1f;\n    float _v = uv.y + iMouse.x * 0.1f;\n    float _w = uv.x + iTime * 0.4f;\n\n    float gray = valuetNoise3D(_u, _v, _w) * 0.35f;\n    gray += valuetNoise3D(_u * 2.054f, _v * 2.354f, _w * 2.754f) * 0.125f;\n    gray += valuetNoise3D(_u * 4.554f, _v * 4.254f, _w * 4.154f) * 0.025f;\n    gray += valuetNoise3D(_u * 32.554f, _v * 32.354f, _w * 32.430f) * 0.025f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 92, 162, 635], [637, 637, 685, 707, 2213], [2216, 2216, 2273, 2323, 2835]], "test": "untested"}
{"id": "stXGWX", "name": "20210606 magnetic field", "author": "kamonumber", "description": "magnetic field", "tags": ["sinatan"], "likes": 1, "viewed": 32, "published": "Public", "date": "1622963473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-=vec2(0.5);\n    float angle = atan(uv.x/uv.y);//uv0,0との角度を割り出す\n    float l = length(sqrt(pow(uv.x,2.)+pow(uv.y,2.)));//0.0からの距離\n    l+=sin(iTime);\n    \n    vec3 col = vec3(angle);\n    col =(col/vec3(l));//回転部分とと0,0からの距離との値同士を計算する★/がポイント\n    col*=vec3(3.);//波の数\n    col = fract(col);//値を0.0~1.0にする\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 541]], "test": "untested"}
{"id": "tdcBRN", "name": "mandelbrot set itishappy", "author": "itishappy", "description": "fractal", "tags": ["fractal"], "likes": 0, "viewed": 47, "published": "Public", "date": "1623388103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define i_max 512.\n#define escape 4.\n#define gamma .6\n\nvec2 isq(vec2 z) { // square of a complex number: s=z^2\n    vec2 s;\n    s.x = z.x*z.x - z.y*z.y; // real part: x^2-y^2\n    s.y = 2. * z.x * z.y;    // imag part: 2xy\n    return s;\n}\n\nfloat mandel(vec2 c) { // mandelbrot set: does f(z)=z^2+c diverge? iterations until |z|>escape\n    vec2 z = vec2(0.);          // z_0 = 0\n    float i;\n    for (i=0.; i<i_max; i++) {\n\t\tz = isq(z) + c;         // f(z)=z^2+c\n        if (length(z) > escape) // |z|>escape\n            return i + 1. - log(log(length(z)))/log(2.);\n    }\n    return 0.;\n}\n\nmat2 rot(float a) { // rotation by angle a: used by the camera\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // aspect ratio\n    vec2 z = 2.*(2.*fragCoord-iResolution.xy)/length(iResolution.xy);\n    \n    // magic camera stuff\n    z += vec2(-.25, 0.);\n    z *= rot(.2*sin(.17*iTime));\n    z += vec2(-.25, 0.);\n    z *= 0.8+0.2*sin(0.03*iTime);\n    \n    // the magic\n    float m = mandel(z)/i_max;\n    \n    // attept at exposure\n    fragColor = vec4(vec3(pow(m,gamma)),10.);\n}\n\n// hmmmm...\n// how do complex numbers exponentiate???\n// I think I can eek more contrast out if I use s=z^x where x is slightly < 2\n// NOPE, that doesn't do what I expected, changing the exponent \"unwraps\" the fractal", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 73, 110, 236], [238, 238, 260, 332, 585], [587, 587, 606, 649, 701], [703, 703, 760, 780, 1130]], "test": "untested"}
{"id": "Wl2cRc", "name": "noise——", "author": "gggab", "description": "noise", "tags": ["noise"], "likes": 0, "viewed": 31, "published": "Public", "date": "1622535954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p){\n    //p = fract(p*vec2(234.34,435.345));\n    //p+=dot(p,p+34.32);\n    //return fract(p.x*p.y);\n    \n    return fract(sin(p.x *100.+p.y*6574.)*5678.);\n}\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3. - 2. * lv);\n    vec2 id = floor(uv);\n    \n    float bl = Hash21(id);\n    float br = Hash21(id + vec2(1.,0.));\n    float b = mix(bl,br,lv.x);\n    \n    float tl = Hash21(id + vec2(0.,1.));\n    float tr = Hash21(id + vec2(1.,1.));\n    float t = mix(tl,tr,lv.x);\n    \n    return mix(b,t,lv.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv+=iTime*.1;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n\tcol+=SmoothNoise(uv*4.);\n    col+=SmoothNoise(uv*8.)*.5;\n    col+=SmoothNoise(uv*16.)*.25;\n    col+=SmoothNoise(uv*32.)*.125;\n    col+=SmoothNoise(uv*64.)*.0625;\n    \n    col/=1.9375;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 116, 173], [174, 174, 201, 201, 541], [542, 542, 599, 649, 1011]], "test": "untested"}
{"id": "WsyXz3", "name": "Devil Square", "author": "104", "description": "Modulating a sine wave field with a signed distance field", "tags": ["2d"], "likes": 4, "viewed": 66, "published": "Public", "date": "1623252907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// as usual, signed distance funcs credit iq\n\nconst float waveHeight = .2;\nconst float waveAmp = .1;\nconst float waveAmpOffset = .01;\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\nfloat sdShape(vec2 uv) {\n    uv *= rot2D(-iTime*.4);\n    return sdStar(uv, 1.6, 4, 2.4);\n}\n\n// https://www.shadertoy.com/view/3t23WG\n// Distance to y(x) = a + b*cos(cx+d)\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n    \n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<7; i++ ) // bisection, 7 bits more or less\n    {\n        float x = 0.5*(xa+xb);\n        float si = sin(x);\n        float co = cos(x);\n        float y = x-p.x+b*c*si*(p.y-b*c*co);\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    for( int i=0; i<4; i++ ) // newtown-raphson, 28 bits more or less\n    {\n        float si = sin(x);\n        float co = cos(x);\n        float  f = x - p.x + b*c*(p.y*si - b*c*si*co);\n        float df = 1.0     + b*c*(p.y*co - b*c*(2.0*co*co-1.0));\n        x = x - f/df;\n    }\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nvec3 dtoa(float d, in vec3 amount){\n    return 1. / clamp(d*amount, amount/amount, amount);\n}\n\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N2 = C/R;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime  *.1;\n    \n    uv *= 2.;\n\n    float a2 = 1e5;\n    vec2 uvsq = uv;\n    float a = sdShape(uvsq);\n    vec2 uv2 = uv;\n\n    uv.y = mod(uv.y, waveHeight) - waveHeight*.5;\n    \n    for (float i = -3.; i <= 3.; ++ i) {\n    \tvec2 uvwave = vec2(uv2.x, uv.y + i * waveHeight);\n        float b = (smoothstep(1., -1.,a)*waveAmp)+ waveAmpOffset;\n        float c = 15.;\n    \ta2 = min(a2, udCos(uvwave, 0., b, c, t));// a + b*cos(cx+d)\n    }\n    \n\tvec3 tint = vec3(1.5,.6,.45);\n    o.rgb = dtoa(pow(mix(a2, a, .2), 2.), 200.*tint);\n    o = 1.-o;\n    o *= 1.-dot(N,N);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 155, 155, 207], [209, 271, 341, 399, 835], [836, 836, 860, 860, 926], [928, 1007, 1081, 1132, 2027], [2029, 2029, 2064, 2064, 2122], [2124, 2142, 2164, 2164, 2307], [2308, 2308, 2345, 2345, 3026]], "test": "untested"}
{"id": "WtKyWd", "name": "ProcEye", "author": "Ellementul", "description": "Eye", "tags": ["eye"], "likes": 1, "viewed": 40, "published": "Public", "date": "1622890442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nvec2 GetCUV(vec2 coords, vec2 limitCoords){\n    return (coords-.5*limitCoords.xy)/limitCoords.y;\n}\n\nvec2 GetPolarCoord(vec2 uv) {\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    st.x /= PI;\n    st.x += .5;\n    return st;\n}\n\nfloat GetSeepdTime(float time, float speed) {\n    return abs(fract(time*speed)-.5)*2.;\n}\n\nfloat N21(vec2 coords) {\n    return fract( sin(coords.x*100. + coords.y*6574.)*5647. );\n}\n\nfloat SmoothNoise(vec2 uv){\n    \n    vec2 lv  = fract(uv);\n    vec2 id  = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id+vec2(0,0));\n    float br = N21(id+vec2(1,0));\n    float b  = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t  = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv){\n    \n    float c = SmoothNoise(uv*4.);\n    c+= SmoothNoise(uv*8.) *.5;\n    c+= SmoothNoise(uv*16.)*.25;\n    c+= SmoothNoise(uv*32.)*.125;\n    c+= SmoothNoise(uv*64.)*.0625;\n    \n    return c/2.;\n}\n\nfloat Pupil(vec2 uv, float t, float br, float er, float bb, float eb) {\n\n    float r  = t*br + (1.-t)*er;\n    float b  = t*bb + (1.-t)*eb;\n    \n    return smoothstep(r - b, r, uv.y);\n}\n\nfloat Iris(vec2 uv, float r1, float r2, float p) {\n    uv.x = abs(uv.x - .5);\n\n    uv.x *= 4.*p+.4;\n    //uv.x += p;\n    \n    float iris = SmoothNoise2(uv*6.);\n    float c = smoothstep(r1, r1-0.015, uv.y);\n    \n    return iris * c * smoothstep(r2-0.1*(1.-p), r2, uv.y);\n}\n\nvec3 Eye(vec2 uv, float width) {\n    vec3 col = vec3(0.,0.,0.);\n    \n    uv = GetPolarCoord(uv);\n    uv.y *= 0.33;\n    \n    uv.x = fract(uv.x + 0.33);\n    float iris = Iris(uv, 0.17, 0.07, .04);\n    col = mix(col, vec3(0.2,0.5,1.0), iris);\n    \n    uv.x = fract(uv.x + 0.1);\n    iris = Iris(uv, 0.165, 0.16, .1);\n    col  = mix(col, vec3(0.2, 1.0,0.5), iris*.8);\n    \n    uv.x = fract(uv.x + 0.33);\n    iris = Iris(uv, 0.17, 0.01, .6);\n    col  = mix(col, vec3(0.7,0.7,0.7), iris*(1. - uv.y)*.3);\n    \n    float pupil = Pupil(uv, width, 0.01, 0.12, 0.005, 0.03);\n    col = mix(vec3(0.0,0.0,0.0), col, pupil);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = GetCUV(fragCoord, iResolution.xy);\n    \n    \n    float t = GetSeepdTime(iTime,  0.1);\n    \n    vec3 col = Eye(uv, .5);\n    \n    uv = GetPolarCoord(uv);\n    //uv.y *= 1.5;\n    //uv.x += (abs(t)-abs(uv.y*t))*0.5;\n    uv.x += iTime*.4;\n    \n    float count = 2.5;\n    float longS = .7;\n    float r     = .2;\n    float blur  = .2;\n    float m = abs(fract(uv.x*count) - .5);\n    float s = m * longS + .2 - uv.y;\n    float c = smoothstep(r-blur, r, s);\n    \n    col  *= mix(col, vec3(0.0, 1.0, 0.0), c*.5);\n    \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 75, 75, 130], [132, 132, 161, 161, 260], [262, 262, 307, 307, 350], [352, 352, 376, 376, 441], [443, 443, 470, 470, 808], [810, 810, 838, 838, 1035], [1037, 1037, 1108, 1108, 1221], [1223, 1223, 1273, 1273, 1494], [1496, 1496, 1528, 1528, 2127], [2131, 2131, 2188, 2238, 2803]], "test": "untested"}
{"id": "WtVyDw", "name": "Wachspress Coordinates", "author": "Reynolds", "description": "Wachspress are generalised barycentric coordinates which are valid for convex polygons. The functions allow you to interpolate over multisided faces. Shows isolines of the coordinate of one vertex.", "tags": ["gbc", "generalisedbarycentriccoordinates", "parametrisation"], "likes": 1, "viewed": 32, "published": "Public", "date": "1624904939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 6\n\nfloat signedTriangleArea(vec2 v1, vec2 v2, vec2 v3) {\n    float det = v2.x*v3.y + v3.x*v1.y + v1.x*v2.y - v2.x*v1.y - v1.x*v3.y - v3.x*v2.y;\n    return det;\n}\n\n\nfloat[N] wachspress(vec2 p, vec2[N] poly) {\n    float[N] weights;\n    float sumweights = 0.0;\n    float A_i, A_iplus1, B;\n    \n    \n    A_iplus1 = signedTriangleArea(poly[N - 1], poly[0], p);\n    for(int i = 0; i < N; i++) {\n        A_i = A_iplus1;\n        A_iplus1 = signedTriangleArea(poly[i], poly[(i+1) % N], p);     \n        \n        //if the polygon is regular this could be kept constant\n        B = signedTriangleArea(poly[(i - 1 + N) % N], poly[i], poly[(i+1) % N]);\n        \n        \n        weights[i] = B / (A_i*A_iplus1);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n    return weights;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n\n    return length( pa - ba*h);\n}\n\nfloat sdScene(vec2 p,     vec2[N] poly) {\n    float d = sdSegment(p, poly[0], poly[1]);\n    \n    for(int i = 0; i < N; ++i) {\n       d = min(d, sdSegment(p, poly[i], poly[(i+1) % N])); \n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.25, 0.0);\n\n    vec3 col = vec3(1.0);\n\n\n    //create a polygon\n    vec2[N] poly;\n    float R = 0.5;\n    float tpi = 2.0*3.14159;\n    \n    float incr = 1.0/float(N);\n    float phi = 0.0;\n    for(int i = 0; i < N; ++i) {\n        poly[i] = vec2(0.5, 0.5) + R * vec2(cos(tpi * phi), sin(tpi * phi));\n        \n        phi += incr;\n    }\n\n    //perturb right most vertex\n    poly[0] += 0.25*vec2(sin(iTime), 0.0);\n    \n   \n    float[N] weights = wachspress(uv, poly);\n    float d = sdScene(uv, poly);\n    \n    \n    \n    //change v to [0,..,N-1] to show the other coordinate functions    \n    int v = 0;\n    \n    //render isolines\n    float linewidth = 0.005;\n    float z = 0.001;\n    if(weights[0] > 0.0 && weights[1] > 0.0 && weights[2] > 0.0 && weights[3] > 0.0) {\n        //to change number of isolines    \n        float w = 0.1;\n        for(int i = 0; i < 9; ++i) {\n            if(weights[v] > (w - linewidth) && weights[v] < (w + linewidth) ) {\n                float f = weights[v] - (w - linewidth);\n                f /= 2.0 * linewidth;\n                \n                if(f < 0.5) {\n                    col = vec3(smoothstep(1.0, 0.0, f/0.5));\n                }  else {\n                    col = vec3(smoothstep(0.0, 1.0, (f - 0.5)/0.5));\n                }\n            }\n            w += 0.1;\n            linewidth += z;\n        }\n    }\n\n    //draw polygon through segments\n    linewidth = 0.005;\n    float e = smoothstep(0.0, 1.0, d / linewidth);\n    if(e < 1.) {\n        fragColor = vec4(vec3(e), 1.0);\n    } else {\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 66, 66, 171], [174, 174, 217, 217, 891], [893, 893, 934, 934, 1070], [1072, 1072, 1113, 1113, 1284], [1286, 1286, 1343, 1393, 3003]], "test": "untested"}
