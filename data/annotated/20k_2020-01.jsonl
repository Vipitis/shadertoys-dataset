{"id": "3l3GWl", "name": "球形的光线步进（sphere ray marching）", "author": "ywqy", "description": "用光线步进做个球。\nuse ray marching make a sphere.\nlearn by the art of code\nhttps://www.youtube.com/watch?v=Ff0jJyyiVyw", "tags": ["raymarching", "artofcodetutorial"], "likes": 2, "viewed": 288, "published": "Public API", "date": "1577857209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n//球形\nfloat sdSphere(vec3 point, vec3 offset, float radius) {\n\treturn length(point - offset) - radius;\n}\n\n//平面\nfloat sdPlane(vec3 point, vec3 offset, vec3 normal) {\n\treturn dot(point - offset, normal.xyz);\n}\n\n//计算射线上的点到物体的最小距离\nfloat GetDist(vec3 point) {\n    \n    float sphereDistance = sdSphere(point, vec3(0, 1, 6), 1.0);\n    float planeDistance = sdPlane(point, vec3(0, 0, 6), normalize(vec3(0, 1, -0.4)));\n    \n    float minDistance = min(sphereDistance, planeDistance);\n    \n    return minDistance;\n}\n\n//使用光线步进\nfloat RayMarch(vec3 rayOrigin, vec3 rayDrection) {\n\tfloat distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 point = rayOrigin + rayDrection * distanceFromOrigin;\n        float minDistance = GetDist(point);\n        distanceFromOrigin += minDistance;\n\n        if(distanceFromOrigin > MAX_DIST || minDistance < SURF_DIST) \n            break;\n    }\n    \n    return distanceFromOrigin;\n}\n\n//运用偏移得到法向量\nvec3 GetNormal(vec3 hitPoint) {\n\tfloat hitDistance = GetDist(hitPoint);\n    vec2 epsilon = vec2(.01, 0);\n    \n    vec3 hitNormal = hitDistance - vec3(\n        \tGetDist(hitPoint - epsilon.xyy),\n        \tGetDist(hitPoint - epsilon.yxy),\n        \tGetDist(hitPoint - epsilon.yyx)\n    \t);\n    \n    return normalize(hitNormal);\n}\n\n//漫反射和其阴影\nfloat GetDiffuseLight(vec3 hitPoint) {\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 10.0;\n    \n    vec3 lightDirection = normalize(lightPos - hitPoint);\n    vec3 hitNormal = GetNormal(hitPoint);\n    \n    float diffuseLight = dot(hitNormal, lightDirection);\n    diffuseLight = clamp(diffuseLight, 0.0, 1.0);\n    \n    float shadowTolightDist = RayMarch(hitPoint + hitNormal * SURF_DIST * 2.0, lightDirection);\n    if(shadowTolightDist < length(lightPos - hitPoint)) \n        diffuseLight *= .1;\n    \n    return diffuseLight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0, 3, -3);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    float diffuseLight = GetDiffuseLight(hitPoint);\n    \n    vec3 col = vec3(diffuseLight);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3GWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 78, 133, 133, 176], [178, 187, 240, 240, 283], [285, 333, 360, 360, 611], [613, 634, 684, 684, 1048], [1050, 1080, 1111, 1111, 1403], [1405, 1429, 1467, 1467, 1990], [1993, 1993, 2049, 2049, 2440]]}
{"id": "3lcSR8", "name": "TEST 2", "author": "andypicci", "description": "tes ", "tags": ["cineshader"], "likes": 4, "viewed": 5432, "published": "Public API", "date": "1580326484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 2\",\n\t\"description\": \"OMG\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 189, 189, 213], [216, 216, 235, 235, 571], [573, 573, 603, 603, 885], [887, 887, 944, 944, 1662]]}
{"id": "3lcSRn", "name": "moving bars", "author": "bandaloo", "description": "shader i made for class", "tags": ["cineshader"], "likes": 3, "viewed": 4641, "published": "Public API", "date": "1580237856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159265;\n\nvec3 blurry_rectangle(vec2 p, float xEdgeWidth, float yEdgeWidth, float xBlurriness, float yBlurriness, float xOffset, float yOffset) {\n  // the blurry rectangle mask\n  p -= vec2(xOffset, yOffset);\n  float smoothFrequency = 1.0;\n  vec2 innerEdge = vec2(xEdgeWidth, yEdgeWidth) - vec2(xBlurriness, yBlurriness);\n  vec2 outerEdge = vec2(xEdgeWidth, yEdgeWidth) + vec2(xBlurriness, yBlurriness);\n  vec2 bl = smoothstep(innerEdge, outerEdge, p); // bottom-left\n  vec2 tr = smoothstep(innerEdge, outerEdge, 1.0 - p); // top-right\n  return vec3(bl.x * bl.y * tr.x * tr.y);\n}\n\nvec3 waves(vec2 p, float xWiggleRate, float yWiggleRate, float xFrequency, float yFrequency, float xWiggle, float yWiggle) {\n  xFrequency += sin(iTime * xWiggleRate);\n  yFrequency += sin(iTime * yWiggleRate);\n  return vec3(cos(xFrequency * (p.x + xWiggle * sin(p.y))) * cos(yFrequency * (p.y + yWiggle * cos(p.y))));\n}\n\nfloat glow(vec2 p) {\n  vec2 pn = p * 2.0 - 1.0;\n  \n  float glowScalar = 2.0;\n  float glowAdder = 0.0;\n  \n  float fadeFrequency = 1.0;\n  float glowColor = glowAdder + (1.0 - length(pn)) * glowScalar - (0.5 * sin(fadeFrequency * iTime) + 0.5);\n  return clamp(glowColor, 0.0, 1.0);\n}\n\nfloat sinSpeeding(float position, float offset) {\n  float speed = 100.0 * smoothstep(3.0, 100.0, position);\n  return sin(0.01 * position * speed + offset);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // position on screen\n  vec2 p = fragCoord.xy / iResolution.xy;\n  \n  // rectangle masks\n  vec3 mask1 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 0.0), 0.0);\n  vec3 mask2 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 2.0 * pi / 3.0), 0.0);\n  vec3 mask3 = blurry_rectangle(p, 0.4, 0.125, 0.02, 0.02, 0.3 * sinSpeeding(iTime, 4.0 * pi / 3.0), 0.0);\n  \n  // inside the blurry rectangle\n  vec3 color1 = waves(p, 0.2, 0.2, 10.0, 10.0, 5.0, 5.0);\n  vec3 color2 = waves(p, 0.1, 0.1, 2.0, 1.0, 100.0, 5.0);\n  vec3 color3 = waves(p, 0.1, 0.1, 2.0, 5.0, 1.0, 5.0);\n  \n  float glowVal = glow(p);\n  fragColor = vec4(mask1 * color1 + mask2 * color2 + mask3 * color3, 1.0) * vec4(0.8 * glowVal, 0.2 * glowVal, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 165, 196, 598], [600, 600, 724, 724, 918], [920, 920, 940, 940, 1200], [1202, 1202, 1251, 1251, 1359], [1361, 1361, 1418, 1442, 2180]]}
{"id": "3lcXR4", "name": "Magnetic Field Lines", "author": "adasba", "description": "These are magnetic fields with random charges, both positive and negative. Lines and colors are determined by the direction of the force acting on a particle at that point.", "tags": ["2d", "physics", "magnet"], "likes": 2, "viewed": 302, "published": "Public API", "date": "1580443692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I didn't make this. Credit to:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//I didn't make this either. Credit to:\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst int pointCount = 32;\n    \n#define PI 3.1415926535897932384626433832795\n    \nvec2 magneticField(vec3[pointCount] pts, vec2 position) {\n    vec2 netForce = vec2(0, 0);\n    for (int i = 0; pointCount > i; i++) {\n    \tnetForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;\n    }\n    return netForce;\n}\n\nfloat modsign(float a, float b) {\n\treturn mod(a, b) * sign(a);\n}\n\nvec3 points[pointCount];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    for (int i = 0; pointCount > i; i++) {\n        int pc = pointCount;\n    \tpoints[i] = vec3(0.0);\n        points[i].x = rand(vec2(i, i + pc)) + sin(iTime * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;\n        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(iTime * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;\n        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;\n    }\n    \n    points[1].x = m.x;\n    points[1].y = m.y;\n    points[1].z = -1.0;\n    \n    //points[0] = vec3(0.25, 0.25, 1.0);\n    \n    //points[2] = vec3(0.75, 0.75, 1.0);\n\t//points[1] = vec3(m.x, m.y, -1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 mField = magneticField(points, uv);\n    float fieldMag = distance(vec2(0, 0), mField);\n    float fieldDir = atan(mField.y, mField.x);\n    //fragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);\n    vec2 mDeriv = mField - magneticField(points, uv + vec2(0.0001));\n    \n    //fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);\n    float logmag = log(fieldMag);\n    //float threshold = (1.0 / (1.0 + pow(3.0, -logmag)));\n    float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);//pow((pow(2.0, 0.333) / (1.0 + pow(2.0, -distance(vec2(0.0), mDeriv)))), 3.0);\n    //vec3 col = vec3((mod(logmag * 4.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0);\n    float col = (mod(fieldDir / PI * 24.0, 2.0) > threshold * 0.5) ? 0.0 : 1.0;\n    fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 109, 109, 278], [280, 398, 418, 418, 490], [575, 575, 632, 632, 830], [832, 832, 865, 865, 896], [925, 925, 982, 982, 2781]]}
{"id": "3lcXzN", "name": "The Art of Code - Crewce", "author": "crewce", "description": "The Art of Code First Challenge", "tags": ["theartofcode"], "likes": 1, "viewed": 69, "published": "Public", "date": "1580473357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R_BIG 0.44\n#define R_MIDDLE 0.2\n#define R_SMALL 0.05\n#define MID_CENTER vec2(0.0, R_MIDDLE)\n#define EPS 0.001\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime)); // rotate\n    uv.y *= 1. + sin(iTime*2.0)*0.2; // morph - comment out for normal looking yy\n\n    vec2 uuv = vec2(uv.x, abs(uv.y));\n    float left = step(0.0, -uv.x);\n    float up = step(0.0, uv.y);\n    float bigDist = length(uv);\n    float smallDist = length(uuv - MID_CENTER);\n    \n    float big = smoothstep(R_BIG, R_BIG - EPS, bigDist);\n    float small = smoothstep(R_SMALL, R_SMALL - EPS, smallDist);\n    float middle = smoothstep(R_MIDDLE, R_MIDDLE - EPS, smallDist);\n    \n    float light = smoothstep(R_MIDDLE * 2. + EPS, R_MIDDLE * 2., bigDist);\n    light *= left;\n    light -= (middle - 2. * small) * up;\n    light += middle * (1.0 - up) * (1.0 - left); // (1.0 - left) because left part is already white\n    light -= small * (1.0 - up);\n    \n    // generate final color\n    vec3 col = vec3(1.0 - big + light);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\n\n    float big = 1. - step(R_BIG, length(uv));\n    float smallUp = 1. - step(R_SMALL, length(uv - MID_CENTER));\n    float smallDown = 1. - step(R_SMALL, length(uv + MID_CENTER));\n    float middleUp = 1. - step(R_MIDDLE, length(uv - MID_CENTER));\n    float middleDown = 1. - step(R_MIDDLE, length(uv + MID_CENTER));\n    \n    float light = 1. - step(R_MIDDLE * 2., length(uv));\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 175, 175, 1187]]}
{"id": "3ldGDl", "name": "V4", "author": "nabr", "description": "let me think what a proper description would be...\n\nmouse = scale", "tags": ["sphere"], "likes": 9, "viewed": 162, "published": "Public", "date": "1577973452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----------------------------------------------------\n// V4 by nabr\n// https://www.shadertoy.com/view/3ldGDl\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R = iResolution.xy;\n    U = (1. - 2. * iMouse.x / R.x) * (U - .5 * R) / min(R.x, R.y);\n    float m = 6.*texture(iChannel0, vec2(0.05)).x;\n    vec3 ht = smoothstep(0., 2., .25 - dot(U, U)) * vec3(U, m-4.),\n         n = 100. * normalize(ht - vec3(0, -.15 * fract(.00085 * iTime), .65)), \n         p = n;\n    for (float i = 0.; i <= 25.; i++)\n    {\n        p = 20. * n + vec3(cos(.325 * iTime - i - p.x) + cos(.325 * iTime + i - p.y), \n                           sin(i - p.y) + cos(i + p.x), 3);\n        p.xy = n.xy + (.5 - cos(i) * p.xy + sin(i) * vec2(p.y, -p.x));\n    }\n    float tx = 6. * sqrt(dot(vec3(0, 6, 4), -p));\n    O = vec4(pow(sin(vec3(0, 1, 1.57) - tx) * .35 + .5, vec3(1.5)), 1);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldGDl.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 309, 348, 348, 1051]]}
{"id": "3lG3Dc", "name": "Isosurface Teapot", "author": "klk", "description": "Teapot SDF model (was made as a test task for job application)", "tags": ["sdf", "isosurface", "teapot", "tea"], "likes": 20, "viewed": 443, "published": "Public API", "date": "1580019416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Isosurface Heart\" by klk. https://shadertoy.com/view/XtVSRh\n\n// Many Thanks to IQ for wonderful idea of signed distance field!\n\n#define PI 3.1415926535897932384626433832795\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n#define float3x3 mat3\n\nconst float MAX_RAY_LENGTH=10000.0;\n\nvoid RayPlane(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n\tif(t<0.0)\n\t{\n\t\tt=MAX_RAY_LENGTH;\n\t\treturn;\n\t}\n\t\n\tuv=float3(u,v,0.0);\n\tn=normalize(dett);\n}\n\nfloat Arrows(float2 p, float t)\n{\n\tfloat2 p1=float2(p.x+p.y,p.x-p.y);\n\tfloat2 f1xy=abs(fract(p1/sqrt(8.0))-0.5)-0.25;\n\tf1xy=clamp(f1xy*t+0.5,0.0,1.0);\n\tfloat f1=mix(f1xy.x,1.0-f1xy.x,f1xy.y);\n\n\tfloat2 fxy=float2(p.x-sqrt(0.125),p.y);\n\tfxy=abs(fract((fxy*sqrt(2.0)+0.5)/2.0)-0.5)-0.25;\n\tfxy=clamp(fxy*t/sqrt(2.0)+0.5,0.0,1.0);\n\tfloat f=mix(fxy.x,1.0-f1,fxy.y);\n\n\treturn f;\n}\n\nfloat Checker(float2 p, float t)\n{\n\tfloat2 fxy=float2(p.x,p.y);\n\tfxy=abs(fract((fxy+0.5)/2.0)-0.5)-0.25;\n\tfxy=clamp(fxy*t+0.5,0.0,1.0);\n\tfloat f=mix(fxy.x,1.0-fxy.x,fxy.y);\n\n\treturn f;\n}\n\nfloat PlaneTexture(float2 p, float t)\n{\n\treturn Arrows(p,t);\n}\n\n// Trace non-SDF objects\nvoid Trace(float3 rp0, float3 rd, out float t, out float3 pos, out float3 n)\n{\n\tfloat t1=MAX_RAY_LENGTH;\n\tfloat3 col1;\n\tfloat3 n1;\n\tRayPlane(float3(0.0,-10.0,0.0),float3(-1.0,0.0,0.0),float3(0.0,0,1.0),rp0, rd, t1, col1, n1);\n\tpos=rp0+rd*t1;\n\tt=t1;\n}\n\n// Smooth combine functions from IQ\nfloat smin(float a, float b, float k)\n{\n\tfloat h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n\treturn -smin(-a,-b,k);\n}\n\nfloat smin( float a, float b)\n{\n\treturn smin(a,b,0.1);\n}\n\nfloat smax( float a, float b)\n{\n\treturn smax(a,b,0.1);\n}\n\nfloat sq(float x){return x*x;}\n\nfloat Torus(float x, float y, float z, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(x)+sq(z))-R)+sq(y))-r;\n}\n\nfloat Torus(vec3 p, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(p.x)+sq(p.z))-R)+sq(p.y))-r;\n}\n\n\nfloat Lid(float x, float y, float z)\n{\n\tfloat v=sqrt(sq(x)+sq(y-0.55)+sq(z))-1.4;\n\tv=smin(v,Torus(y-2.,x,z,.2,.08),.1);\n\tv=smax(v,-sqrt(sq(x)+sq(y-0.55)+sq(z))+1.3);\n\tv=smax(v,sqrt(sq(x)+sq(y-2.5)+sq(z))-1.3);\n\n\tv=smax(v,-sqrt(sq(x-.25)+sq(z-.35))+0.05,.05);\n\tv=smin(v,Torus(x,(y-1.45)*.75,z,.72,.065),.2);\n\treturn v;\n}\n\nfloat Nose(float x, float y, float z)\n{\n\tz-=sin((y+0.8)*3.6)*.15;\n\t\n\tfloat v=sqrt(sq(x)+sq(z));\n\t\n\tv=abs(v-.3+sin(y*1.6+.5)*0.18)-.05;\n\tv=smax(v,-y-1.);\n\tv=smax(v,y-0.85,.075);\n\t\n\treturn v;\n}\n\nfloat Teapot(float3 p)\n{\n\tfloat x=p.x;\n\tfloat y=p.y;\n\tfloat z=p.z;\n\n\tfloat v=0.0;\n\tv=sqrt(x*x+z*z)-1.2-sin(y*1.5+2.0)*.4;\n\tv=smax(v,abs(y)-1.,0.3);\n\n\n\t\n\tfloat v1=sqrt(x*x*4.+sq(y+z*.1)*1.6+sq(z+1.2))-1.0;\n\tv1=smax(v1,-sqrt(sq(z+1.2)+sq(y+z*.12+.015)*1.8)+.8,.3);\n\t\n\tv=smin(v,Torus(y*1.2+.2+z*.3,x*.75,z+1.25+y*.2,.8,.1),.25);\n\tv=smin(v,sqrt(sq(x)+sq(y-1.1)+sq(z+1.8))-.05,.32);\n\n\tfloat v3=Nose(x,(y+z)*sqrt(.5)-1.6,(z-y)*sqrt(.5)-1.1);\n\n\tv=smin(v,v3,0.2);\n\t\n\tv=smax(v,smin(sin(y*1.4+2.0)*0.5+.95-sqrt(x*x+z*z),y+.8, .2));\n\tv=smax(v,-sqrt(sq(x)+sq(y+.15)+sq(z-1.5))+.12);\n\n\tv=smin(v,Torus(x,y-0.95,z,0.9,.075));\n\tv=smin(v,Torus(x,y+1.05,z,1.15,.05),0.15);\n\t\n\t\n\tfloat v2=Lid(x,y+.5,z);\n\tv=min(v,v2);\n\n\treturn v;\n}\n\nfloat plate0(float3 p)\n{\n\tfloat v=(length(p.xz)*.8-p.y)/sqrt(1.64);\n\tv=smin(v,(length(p.xz)*.3-p.y+.7)/sqrt(1.09));\n\tv=smax(v,-p.y+.8,.1);\n\treturn v;\n}\n\nfloat Plate(float3 p)\n{\n\tfloat v;\n\tfloat vi=plate0(p);\n\tfloat vo=plate0(p+float3(0,-.1,0));\n\tv=smax(vi,-vo);\n\tv=smax(v,(length(p.xz)*2.+p.y)/sqrt(3.)-3.);\n\tv=smin(v,Torus(p.x,p.y-.7,p.z,0.8,.025),0.2);\n\treturn v;\n}\n\nfloat Value(float3 p)\n{\n\tfloat v;\n\tv=Teapot(p);\n\t//v=Plate(p);\n\treturn v;\n}\n\nstruct Ray\n{\n\tvec3 p;\n\tvec3 d;\n};\n\nbool RayMarch(\n\tconst in Ray r, \n\tconst float startT, const float endT, \n\tconst float stp, \n\tconst int N,\n\tout float t, out float v, out int i)\n{\n\tfloat t0=startT;\n\tt=t0;\n\tv=Value(r.p+r.d*t);\n\n\tif(v<0.)\n\t\treturn true;\n\n\ti=0;\n\tfor(int j=0;j<1;j+=0)\n\t{\n\t\tt+=max(v*.85, stp);\n\t\tfloat v1=Value(r.p+r.d*t);\n\t\tif(v1<0.)\n\t\t{\n\t\t\t// Linear interpolation between two last steps\n\t\t\tt=t0+(t-t0)*v/(v-v1);\n\t\t\tv=Value(r.p+r.d*t);\n\t\t\treturn true;\n\t\t}\n\t\tif(t>endT)\n\t\t\treturn false;\n\t\ti++;\n\t\tif(i>N)\n\t\t\treturn false;\n\t\tv=v1;\n\t\tt0=t;\n\t}\n\treturn false;\n}\n\nfloat3 CalcNormal(float3 p, float n0)\n{\n\tfloat3 n;\n\tfloat d=0.001;\n\tn.x=Value(p+float3(d,0.0,0.0))-n0;\n\tn.y=Value(p+float3(0.0,d,0.0))-n0;\n\tn.z=Value(p+float3(0.0,0.0,d))-n0;\n\n\tn=normalize(n);\n\treturn n;\n}\n\nstruct Sphere\n{\n\tvec3 p;\n\tfloat r;\n};\n\nbool RaySphere(in Ray r, in Sphere s, out float t0, out float t1)\n{\n\tfloat3 l=s.p-r.p;\n\tfloat tc=dot(l,r.d);\n\tif(tc<0.0)\n\t{\n\t\treturn false;\n\t};\n\n\tfloat d2=s.r*s.r+tc*tc-dot(l,l);\n\n\tif(d2<0.0)\n\t{\n\t\treturn false;\n\t};\n\n\tfloat thc=sqrt(d2);\n\tt0=tc-thc;\n\tt1=tc+thc;\n\treturn true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat3 campos=float3(-12.0,3.0,0.0);\n\tfloat3 look_at=float3(0.0,0.5,0.0);\n\tfloat3 up=float3(0,1,0);\n\tfloat3 forward;\n\tfloat3 right;\n\n\tfloat3 light=float3(0,10,10);\n\n\tfloat T=iTime*0.45;\n\t\n\tlight.x=cos(T)*10.0;\n\tlight.z=sin(T)*10.0;\n\tlight.y=5.0;\n\t\n\tfloat mposx=iMouse.x;\n\tfloat mposy=iMouse.y;\n\tif(iMouse.z<0.0)mposx=-iMouse.z;\n\tif(iMouse.w<0.0)mposy=-iMouse.w;\n\t\n\tfloat a1=(0.6+(mposy/iResolution.y-0.5)*0.7)*PI;\n\tfloat a2=mposx/iResolution.x*PI*2.0-PI/3.0;\n\n\tif(iMouse.y<10.0)\n\t{\n\t\ta1=PI*0.55;\n\t\ta2=PI+0.3;\n\t}\n\n\tcampos.y=cos(a1)*campos.x;\n\tfloat camx=sin(a1)*campos.x;\n\tcampos.x=cos(a2)*camx;\n\tcampos.z=sin(a2)*camx;\n\t\n\tforward=normalize(look_at-campos);\n\tright=normalize(cross(up,forward));\n\tup=normalize(cross(forward,right));\n\n\tfloat2 scr = fragCoord.xy /iResolution.xy;\n\tscr=2.0*scr-1.0;\n\n\tfloat2 scr2ray=scr;\n\tscr2ray.x*=(iResolution.x/iResolution.y);\n\tfloat2 uv=scr2ray;\n\tfloat3 ray=normalize(forward+(up*uv.y+right*uv.x)*0.2);\n\n\tfloat3 col=float3(0.0,0.5,0.0);\n\tfloat3 n;\n\tfloat t;\n\n\tfloat3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),clamp(1.0-(1.0-ray.y)*(1.0-ray.y),0.,1.));\n\tfragColor.rgb=fogcol;\n\tfloat3 tpos;\n\tTrace(campos, ray, t, tpos, n);\n\tcol=mix(float3(0.97,0.95,0.83),float3(0.1,0.15,0.4), smoothstep(0.0,1.0,PlaneTexture(tpos.xz*0.2,36000.0/t/t)));\n\tfloat3 tolight=normalize(light);\n\n\t// Debug visualization of SDF values \n\tif(false)\n\t{\n\t\tfloat t1=MAX_RAY_LENGTH;\n\t\tfloat3 col1;\n\t\tfloat3 colp=vec3(0);\n\t\tfloat3 n1;\n\t\tRayPlane(float3(0.,0.,0.),float3(0.0,1.0,0.0),float3(1.0,0,0.0),campos, ray, t1, col1, n1);\n\t\tfloat3 pos=campos+ray*t1;\n\t\tif(t1<t)\n\t\t{\n\t\t\tt=t1;\n\t\t\tfloat v=Value(pos);\n\t\t\tcolp.r=v>0.?fract(v):0.5;\n\t\t\tcolp.b=v<0.?fract(v):0.5;\n\t\t\tcolp.g=.5-abs(clamp(fract(v*10.),0.,1.)-0.5);\n\t\t}\n\t\tcol.rgb+=colp.rgb*0.5;\n\t\tfragColor.rgb=col;\n\t}\n\n\tif(t<MAX_RAY_LENGTH)\n\t{\n\t\tcol=mix(fogcol,col,exp(-t*0.005));\n\t\tfragColor.rgb=col;\n\t}\n\n\t{\n\t\tfloat ts0, ts1;\n\t\tfloat3 start=campos;\n\t\tfloat n0;\n\t\tSphere bound=Sphere(vec3(.0,.3,.2),2.5);\n\n\t\t// Try bounding sphere first\n\t\tbool hit=RaySphere(Ray(start,ray), bound, ts0, ts1);\n\t\t//if(hit)fragColor.rgb*=0.95;\n\t\tint nt=-1;\n\n\t\tfloat tp;\n\n\t\tif(hit)\n\t\t{\n\t\t\thit=RayMarch(Ray(start,ray),ts0,ts1,.025,180,tp,n0,nt);\n\t\t}\n\n\t\tif(hit)\n\t\t{\n\t\t\tif(tp<t)\n\t\t\t{\n\t\t\t\tt=tp;\n\t\t\t\tfloat3 p=start+ray*tp;\n\t\t\t\tfloat3 n=CalcNormal(p,n0);\n\t\t\t\tif(nt<0)\n\t\t\t\t{\n\t\t\t\t\tn=normalize(p-bound.p);\n\t\t\t\t}\n\n\t\t\t\tfloat3 halfn=normalize(tolight-ray);\n\n\t\t\t\tfloat lamb=pow(clamp(dot(n,tolight),0.0,1.0),1.0)*0.9+0.1;\n\t\t\t\tfloat3 refray=reflect(ray,n);\n\n\t\t\t\tfloat spec1=clamp(dot(halfn,n),0.0,1.0);\n\t\t\t\tfloat spec2=clamp(dot(tolight,refray),0.0,1.0);\n\n\t\t\t\tfloat3 reffog=mix(\n\t\t\t\t\tfloat3(0.87,0.8,0.83),\n\t\t\t\t\tfloat3(0.3,0.6,1.0),\n\t\t\t\t\tclamp(1.0-(1.0-refray.y)*(1.0-refray.y),0.,1.));\n\n\t\t\t\tfloat3 n1;\n\n\t\t\t\tcol=lamb*float3(0.78,0.79,0.8);\n\t\t\t\tfloat3 rpos;\n\t\t\t\tfloat3 rcol;\n\t\t\t\tfloat tr;\n\t\t\t\tTrace(p, reflect(ray,n), tr, rpos, n1);\n\t\t\t\tfloat fresn=clamp(1.0-dot(ray,-n),0.0,1.0);\n\t\t\t\tif(tp<MAX_RAY_LENGTH)\n\t\t\t\t{\n\t\t\t\t\trcol=mix(float3(0.87,0.85,0.83),float3(0.1,0.12,0.4),\n\t\t\t\t\t\tsmoothstep(0.0,1.0,PlaneTexture(rpos.xz*0.2,600.0/tr/tr)));\n\t\t\t\t\trcol=mix(reffog,rcol,exp(-tr*0.02));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trcol=reffog;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tcol=mix(col,rcol,pow(fresn,1.2)*0.50);\n\t\t\t\t\tcol+=rcol*(pow(fresn,2.6)*0.2+0.1);\n\t\t\t\t\tcol=mix(col,float3(1,1,1),pow(spec2,40.0)*.4);\n\t\t\t\t\tcol=mix(col,float3(1,1,1),.8*pow(spec2,180.0));\n\t\t\t\t}\n\t\t\t\tfragColor.rgb=col;\n\t\t\t}\n\t\t}\n\n\t\t// Color coded steps count\n\t\tif(false)\n\t\t{\n\t\t\tif(nt>8)\n\t\t\t\tfragColor.g+=.2;\n\t\t\tif(nt>16)\n\t\t\t\tfragColor.r+=.4;\n\t\t\tif(nt>32)\n\t\t\t\tfragColor.g-=.2;\n\t\t\tif(nt>48)\n\t\t\t\tfragColor.rb+=vec2(-.4,.4);\n\t\t}\n\t}\n\tfragColor.a=1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 306, 422, 422, 716], [718, 718, 751, 751, 1091], [1093, 1093, 1127, 1127, 1279], [1281, 1281, 1320, 1320, 1343], [1345, 1370, 1448, 1448, 1620], [1622, 1658, 1697, 1697, 1776], [1778, 1778, 1818, 1818, 1844], [1846, 1846, 1877, 1877, 1902], [1904, 1904, 1935, 1935, 1960], [1962, 1962, 1980, 1980, 1992], [1994, 1994, 2052, 2052, 2101], [2103, 2103, 2142, 2142, 2197], [2200, 2200, 2238, 2238, 2519], [2521, 2521, 2560, 2560, 2712], [2714, 2714, 2738, 2738, 3425], [3427, 3427, 3451, 3451, 3578], [3580, 3580, 3603, 3603, 3794], [3796, 3796, 3819, 3819, 3871], [3908, 3908, 4053, 4053, 4443], [4445, 4445, 4484, 4484, 4650], [4691, 4691, 4758, 4758, 4967], [4969, 4969, 5026, 5026, 8625]]}
{"id": "3lG3WR", "name": "Gears using involute SDF", "author": "Pidhorskyi", "description": "More or less accurate gear geometry. The shape of the cogs is made using an SDF for an involute.", "tags": ["gears", "involute"], "likes": 9, "viewed": 264, "published": "Public API", "date": "1578592688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \"Gears using involute SDF\" by Stanislav Pidhorskyi - 2020\n * License Creative Commons Attribution 4.0 International License.\n * Contact: stpidhorskyi@mix.wvu.edu\n */\n\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat SmoothUnion(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Substraction(float a, float b)\n{\n    return max(a,-b);\n}\n\nfloat Intersection(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat SmoothIntersection(float a, float b, float k)\n{\n    return Substraction(Intersection(a, b), SmoothUnion(Substraction(a, b), Substraction(b, a), k));\n}\n\nfloat Circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat Circle(float rho, float r)\n{\n\treturn rho - r;\n}\n\nfloat Gear(vec2 p, float D, float N, float psi, float alpha, float dir)\n{\n    float R = D / 2.0;\n    /* The Pitch Circle Diameter is the diameter of a circle which by a pure rolling action would transmit \n     * the same motion as the actual gear wheel. It should be noted that in the case of wheels which connect\n     * non-parallel shafts, the pitch circle diameter is different for each cross section of the wheel\n     * normal to the axis of rotation.\n     */\n\n    float rho = length(p);\n    \n    float Pd = N / D; // The Diametral Pitch, p_d is the number of teeth per unit length of diameter\n\n    float P = 3.1416 / Pd; // Circular Pitch\n    /* The Circular Pitch, p is the length of arc round the pitch circle between corresponding points \n     * on adjacent teeth.\n     */\n\n    float a = 1.0 / Pd; // Addendum\n    /* The Addendum is the radial length of a tooth from the pitch circle to the tip of the tooth.\n     */\n\n    float Do = D + 2.0 * a; // Outside Diameter\n    float Ro = Do / 2.0; \n\n    float h = 2.2 / Pd;\n\n    float innerR = Ro - h - 0.4;\n    \n    // Early exit\n    if (innerR - rho > 0.0)\n        return innerR - rho;\n    \n    // Early exit\n    if (Ro - rho < -0.2)\n        return rho - Ro;\n    \n    float Db = D * cos(psi); // Base Diameter \n    float Rb = Db / 2.0; \n\n    float fi = atan(p.y, p.x) * dir + alpha;\n    \n    float alphaStride = P / R;\n    \n    float invAlpha = acos(Rb / R);\n    float invPhi = tan(invAlpha) - invAlpha;\n    \n    float shift = alphaStride / 2.0 - 2.0 * invPhi;\n    \n    float fia = mod(fi + shift / 2.0, alphaStride) - shift / 2.0;\n    float fib = mod(-fi - shift + shift / 2.0, alphaStride) - shift / 2.0;\n    \n    float dista = -1.0e6;\n    float distb = -1.0e6;\n    \n    if (Rb < rho)\n    {\n        float acos_rbRho = acos(Rb/rho);\n        \n        float thetaa = fia + acos_rbRho;\n        float thetab = fib + acos_rbRho;\n\n        float ta = sqrt(rho * rho - Rb * Rb);\n\n        // https://math.stackexchange.com/questions/1266689/distance-from-a-point-to-the-involute-of-a-circle\n        dista = ta - Rb * thetaa;\n        distb = ta - Rb * thetab;\n    }\n    \n    float gearOuter = Circle(rho, Ro);\n    float gearBase = Circle(rho, Rb);\n    float gearLowBase = Circle(rho, Ro - h);\n    float crownBase = Circle(rho, innerR);\n    \n    float cogs = Intersection(dista, distb);\n    \n    float baseWalls = Intersection(fia - (alphaStride - shift), fib - (alphaStride - shift));\n    \n    cogs = Intersection(baseWalls, cogs);\n    cogs = SmoothIntersection(gearOuter, cogs, 0.01);\n    cogs = SmoothUnion(gearLowBase, cogs, Rb - Ro + h);\n    \n    cogs = Substraction(cogs, crownBase);\n    return cogs;\n}\n\nfloat Alpha(float d)\n{\n    d *= iResolution.y / 2.0;\n\treturn clamp(-d + 0.7, 0.0, 1.0);\n}\n\n\nfloat AO(float d, float height)\n{\n    return 1.0 - atan(height, d) / 3.14159;\n}\n\nfloat SDF(vec2 p)\n{\n    float N = pow(2.0, mod(floor(iTime / 15.0), 4.0)) * 4.0 + 9.0; // Number of Teeth\n    float psi = 3.096e-5 * N * N -6.557e-3 * N + 0.551;// Pressure Angle\n\t/* The Pressure Angleor Angle of Obliquity  Psi is the angle \n \t * between the common normal LM and the tangent at the pitch point\n \t */\n    float D = 2.8;\n        \n    float gearA = Gear(p + vec2(1.5, 0.0), D, N, psi, iTime / 4.0, 1.0);\n    float gearB = Gear(p + vec2(1.5 - D, 0.0), D, N, psi, iTime / 4.0, -1.0);\n    float dist = Union(gearA, gearB);\n    return dist;\n}\n\nvec2 normal(vec2 p, float dist)\n{\n\tfloat dx = SDF(p + vec2(0.0, 1.0) / iResolution.yy) - dist;\n\tfloat dy = SDF(p + vec2(1.0, 0.0) / iResolution.yy) - dist;\n    return normalize(vec2(dx, dy));\n}\n\nvec3 Render(vec2 p)\n{\n\t// gradient\n\tvec3 color = vec3(0.55, 0.5, 0.45) * (1.3 - length(p / 2.0 / iResolution.xy * iResolution.yy));\n  \n\tcolor = mix(color, vec3(0.1, 0.1, 0.2), 0.2 * Alpha(0.5 * SDF((p - vec2(1.0, 0.0)) / 2.0)));\n    \n    float dist = SDF(p);\n    \n\tcolor *= AO(dist, 0.2);\n    \n\tcolor = mix(color, vec3(0.1, 0.1, 0.1), Alpha(dist));\n    \n    #ifdef ADD_SPECULAR\n    if (dist < 0.0)\n    {\n    \tvec2 n = normal(p, dist);\n        vec3 nn = normalize(vec3(n, -dist * 200.1));\n        \n        float s = dot(nn, normalize(vec3(1.0, 1.0, 1.0)));\n        \n        s = pow(max(s, 0.0), 20.0);\n        \n    \tcolor += vec3(s) * clamp(-dist * iResolution.y / 4.0, 0.0, 1.0);\n    }\n    #endif\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy  + vec2(0.5)) / iResolution.yy;\n    vec2 p = uv.xy * vec2(2.0) - vec2(1.0);\n\tfragColor = vec4(pow(Render(p), vec3(1.0 / 2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3WR.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 171, 202, 202, 223], [225, 225, 271, 271, 372], [374, 374, 412, 412, 436], [438, 438, 476, 476, 499], [501, 501, 554, 554, 657], [659, 659, 690, 690, 715], [717, 717, 751, 751, 770], [772, 772, 845, 845, 3423], [3425, 3425, 3447, 3447, 3514], [3517, 3517, 3550, 3550, 3596], [3598, 3598, 3617, 3617, 4150], [4152, 4152, 4185, 4185, 4345], [4347, 4347, 4368, 4381, 5072], [5074, 5074, 5131, 5131, 5295]]}
{"id": "3lG3Wz", "name": "Simplex noise color trip", "author": "Bleuje", "description": "Experimenting with color and 3d simplex noise.", "tags": ["simplexnoise"], "likes": 7, "viewed": 357, "published": "Public API", "date": "1578601879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by @etiennejcb\n//3d simplex noise from https://www.shadertoy.com/view/XsX3zB\n\nconst float PI = 3.1415926535897932384626433832795;\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\nfloat transformValue(float v){\n    v = 0.5 + 0.5*v;\n    v = pow(v+0.35,7.0);\n    return v;\n}\n\n//from bookofshaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/iResolution.x;\n\tfloat offset = 0.9*simplex3d(vec3(9.*p+vec2(0.,-0.3*iTime),0.2*iTime))*clamp((2.0-5.*length(p-vec2(0.5,0.25))),0.,2.) + 10.*length(p-vec2(0.5,0.25));\n    //float offset2 = simplex3d(vec3(123)+vec3(10.*p+vec2(-1.*iTime,0),0.5*iTime));\n    \n    float change = 9.0;\n    \n    float scl = 5.;\n    \n    float value = simplex3d(vec3(change*(iTime-offset),scl*p.x,scl*p.y));\n\tfloat value2 = simplex3d(vec3(1.1*change*(iTime-offset),123.+scl*p.x,scl*p.y));\n    float value3 = simplex3d(vec3(1.5*change*(iTime-offset),1234.+scl*p.x,scl*p.y));\n    //float value4 = simplex3d(vec3(1.5*change*(iTime-offset),3234.+scl*p.x,scl*p.y));\n    \n\tvalue = transformValue(value);\n    value2 = transformValue(value2);\n    value3 = transformValue(value3);\n\t\n    vec3 color0 = vec3(value+value2,value2+0.*value3,value3+value);\n    \n    vec3 rgb = clamp(color0,0.,1.);\n    \n    vec3 hsb = rgb2hsb(rgb);\n    \n    hsb.x += 0.3*sin(13.*length(p-vec2(0.5,0.25))-1.*iTime)+0.15*iTime;\n    \n    hsb.x = mix(hsb.x,0.5,0.7);\n    \n    hsb.y += 0.2*sin(14.*length(p-vec2(0.5,0.25))-1.1*iTime+0.5)-0.4;\n                \n    rgb = hsb2rgb(hsb);\n    \n\tfragColor = vec4(rgb,1.0);\n\treturn;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lG3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 206, 228, 228, 401], [508, 531, 556, 809, 1726], [1729, 1729, 1759, 1759, 1821], [1823, 1844, 1870, 1870, 2300], [2302, 2376, 2402, 2402, 2634], [2636, 2636, 2693, 2693, 3882]]}
{"id": "3lGGDK", "name": "RayTraceReflection", "author": "JackSolace", "description": "Simple Reflections on a sphere moving in 3D space.\n\nFuture ideas: fix colors, fix aliasing, do something that was invented after 1985 ect ect.", "tags": ["reflection", "ray", "sphere", "animated", "trace", "learn"], "likes": 3, "viewed": 72, "published": "Public", "date": "1579820483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Jan 2020\n//Basic Raytrace of a Moving Sphere with Reflections (Basic Shadows).\n//normally these checks would be done recursively but for educational purpses it is often\n//easier to see it done iteratively\n//We are starting to get to the point where more elegant ways of checking intersections are needed\n//not just for performance but for ease of extending the code (Thank goodness this is just for learning)\n\n#define PI 3.14159265359\n\nstruct Ray {\n\tvec3 origin; // Origin of ray (not to be confused with world origin)\n\tvec3 direction; // Direction Normalized vector\n};\n\nstruct Sphere {\n\tvec3 center;  // Center of the Sphere\n\tfloat radius; // Radius of the Sphere\n};\n    \nstruct Plane {\n\tvec3 normal; //Normal vector\n    vec3 point; //Some point such that for all points p in the plane dot((p-point),normal) == 0\n};\n\n//Simplest light source\nstruct PointLight {\n    vec3 position; //3d point in space\n    vec4 color; //RGBA color\n};\n\n    \n//Move the Sphere over time\nvoid AnimateSphere(inout Sphere sphere) {\n    //Size of the animation loop\n\tfloat loopRadius = 4.0;\n    //initial sphere position\n    float loopOffset = sphere.center.z;\n    //time it takes to complete a loop\n    float loopTime = 8.0;\n    \n    //Based on parametric equations of a circle\n    sphere.center.x = sin((mod(iTime, loopTime))/loopTime*2.0*PI)*loopRadius;\n    sphere.center.z = loopOffset + cos((mod(iTime,loopTime))/loopTime*2.0*PI)*loopRadius;\n    \n}\n    \n//Get the Specular color (shiny light)\nvec4 calculateSpecular(in vec3 rayd, in vec3 normal, in vec3 toLight, in PointLight light) {\n    //specular exponent\n    float shinnyness = 5.0;\n    //get the reflected light vector\n    vec3 reflected = 2.0*dot(toLight, normal)*normal - toLight;\n    //calculate specular color\n    return light.color * max(0.0,pow(dot(rayd,reflected),shinnyness));\n}\n    \n//Get the Diffuse color (Basic light effect)\nvec4 calculateDiffuse(in vec3 normal, in vec3 toLight, in PointLight light) {\n    return light.color * max(0.0,dot(normal,toLight));\n}\n    \n//Get the direction to the light source (no shadows simplifies check)\nvec3 checkLight(in vec3 intersect, in PointLight light) {\n    return normalize(light.position - intersect);\n}\n\n//Get the sphere surface normal from the intersection point\nvec3 getSphereIntersectionNormal(in vec3 intersect, in Sphere sphere) {\n\treturn normalize(intersect - sphere.center);\n} \n\n//Get the 3d point that is depth along the ray\nvec3 calculateIntersectionPoint(in Ray ray, in float depth) {\n\treturn ray.origin + ray.direction*depth;\n}\n    \n// From the Wikipedia page on Line-Plane intersection\nfloat intersectPlane(in Ray ray, in Plane plane) {\n\tfloat denominator = dot(ray.direction,plane.normal);\n    if(abs(denominator) >= 0.01) {//make sure Ray is not parallel to plane (or nearly parallel)\n        return dot((plane.point - ray.origin),plane.normal)/denominator;\n    }\n\treturn -1.0; // Any negative number to indicate no intersect (or intersection from behind)\n}\n\n// From the Wikipedia page on Line-sphere intersection\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance from the ray origin to point of intersection\n    //bear in mind that there may be more than one solution\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, get ray intersection depth\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant);\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nbool performPlaneCheck(in Ray ray, in Plane plane, in Sphere sphere, out vec4 color){\n//code for plane Check\n// Check if the ray from the camera through the pixel intersects the Plane\n\tfloat intersectionDepth = intersectPlane(ray,plane);\n    if (intersectionDepth >= 0.01 && intersectionDepth <= 1000.0) {//Front and Back Culling\n    \t//Point light is purple and a little to the left and aboveof the camera start\n    \tPointLight light = PointLight(vec3(-5.0,5.0,0.0), vec4(1.0,0.0,1.0,1.0));\n    \t//Get the ray intersection Point\n    \tvec3 intersect = calculateIntersectionPoint(ray,intersectionDepth);\n    \t//ambient color of the Plane is dark Grey default Light Grey Checkered\n    \tvec4 ambientPlaneColor = vec4(0.2,0.2,0.2,1.0);\n    \t//simple way to make a checkerboard pattern\n    \tfloat xmod = mod(intersect.x,1.0);\n    \tfloat ymod = mod(intersect.z,1.0);\n    \tif ((xmod <= 0.5 && ymod <= 0.5)||(xmod >= 0.5 && ymod >= 0.5)){\n        \t//this intersect is in the light part of the pattern\n        \tambientPlaneColor = vec4(0.5,0.5,0.5,1.0);\n    \t}\n    \t//Get the direction to the lightsource from the intersection point\n    \tvec3 toLight = checkLight(intersect, light);\n    \t//contruct Ray for shadow check\n    \tRay shadowRay = Ray(intersect, toLight);\n    \t//Do a shadow check\n    \tintersectionDepth = intersectSphere(shadowRay,sphere);\n    \tif (intersectionDepth >= 0.05) { //Sphere is blocking the Light\n        \tcolor = ambientPlaneColor;\n    \t}else{ //Light is visable from this point\n        \tcolor = ambientPlaneColor + 0.5*calculateDiffuse(plane.normal, toLight, light);\n    \t}\n        return true;\n    }else{\n        // else draw background color (black)\n\t\tcolor = vec4(0, 0, 0, 1);\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // output a 4d fragment color vector [R,G,B,A]\n    // input is a 2d fragment Co-ordinate vector [X,Y]\n    // can interpret input vector as a pixel (function is called 640x360 times by default per frame)\n    \n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat u = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat v = fragCoord.y / iResolution.y; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the image\n\tu = u * 2.0 - 1.0;\n\tv = v * 2.0 - 1.0;\n\n    //the following line is necessary since the image may not be a square\n    //removing this line results in the x dimension being stretched\n    u *= (iResolution.x/iResolution.y);\n    \n\t// The position of this pixel in 3D space \n    //(imagine a plane centered at the origin perpendicular to the camera, what would be the 3d coordinates of this pixel?)\n\tvec3 pixelPos = vec3(u, v, 0);\n\n    // The camera position in this example is on a fixed loop.\n    // Initialize at 0.0\n    vec3 cameraPos = vec3(0.0, 0.0, -4.0); \n    \n\t// The ray direction is ray from the camera through the pixel\n\tvec3 rayDir = normalize(pixelPos - cameraPos);\n    \n    // The Sphere is at the origin\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    \n    //Animate the Sphere\n    AnimateSphere(sphere);\n    \n    // The plane is the xz plane at y = -2.0\n    Plane plane = Plane(vec3(0.0,1.0,0.0),vec3(0.0,-2.0,0.0));\n\n    //Create Ray struct from origin through current pixel\n    Ray ray = Ray(cameraPos, rayDir);\n    \n\t// Check if the ray from the camera through the pixel intersects the sphere\n\tfloat intersectionDepth = intersectSphere(ray, sphere);\n\n\t// If the depth at which the ray intersects the sphere is positive (in front of camera)\n\tif (intersectionDepth >= 0.05)//Sphere Check\n\t{//draw the sphere color (basic ambient + diffuse)\n        //ambient color of the sphere is greenish\n        vec4 ambientSphereColor = vec4(0.0,0.2,0.0,1.0);\n        \n        //Point light is purple and a little to the left of the camera start\n        PointLight light = PointLight(vec3(-3.0,0.0,0.0), vec4(1.0,0.0,1.0,1.0));\n        \n        //Get the ray intersection Point\n        vec3 intersect = calculateIntersectionPoint(ray, intersectionDepth);\n        \n        //Get the surface normal at that point\n\t\tvec3 normal = getSphereIntersectionNormal(intersect,sphere);\n        \n        //Get the direction to the lightsource from the intersection point\n        vec3 toLight = checkLight(intersect, light);\n        \n        //we are going to skip the checks for shadows for the sphere\n        //but in other scenes we will not have this luxury\n        \n        //calculate reflected Ray (normalize here is because im paranoid)\n        vec3 reflected = normalize(ray.direction - 2.0*dot(ray.direction, normal)*normal);\n        Ray rayreflect = Ray(intersect,reflected);\n          \n        //initialize reflected color\n        vec4 reflectColor = vec4(1.0,1.0,1.0,1.0);\n        //Plane Check\n        bool intersected = performPlaneCheck(rayreflect,plane,sphere,reflectColor);\n        if (intersected){\n        \t//Combine it all to get the correct color (with reflected color)\n        \tfragColor = ambientSphereColor + calculateDiffuse(normal,toLight,light) + calculateSpecular(-ray.direction, normal, toLight, light) + 0.5*reflectColor;\n        }else{\n        \t//Combine it all to get the correct color\n        \tfragColor = ambientSphereColor + calculateDiffuse(normal,toLight,light) + calculateSpecular(-ray.direction, normal, toLight, light);\n        }\n    } else {//Plane Check\n        bool intersected = performPlaneCheck(ray,plane,sphere, fragColor);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[951, 979, 1020, 1053, 1441], [1447, 1486, 1578, 1602, 1835], [1841, 1886, 1963, 1963, 2020], [2026, 2096, 2153, 2153, 2205], [2207, 2267, 2338, 2338, 2386], [2389, 2436, 2497, 2497, 2541], [2547, 2601, 2651, 2651, 2974], [2976, 3031, 3084, 3116, 3692], [3694, 3694, 3779, 3877, 5419], [5421, 5421, 5478, 5753, 9193]]}
{"id": "3lGGWc", "name": "the cycle of the universe", "author": "khadari", "description": "quantum fluctuation of the vacuum-->The  Big Bang --> super inflation --> The Big Rip -->quantum fluctuation of the vacuum.", "tags": ["theuniverse"], "likes": 1, "viewed": 53, "published": "Public", "date": "1580040401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float d = length(st);\n    float c;\n     c=smoothstep(0.1*sin(iTime),0.1*cos(iTime)+tan(iTime)*sin(iTime) ,d );\n   \n    vec3 color =vec3(c*sin(iTime),c*cos(iTime),c*tan(iTime))-fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453)/tan(iTime);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 520]]}
{"id": "3lGGzR", "name": "Day 15", "author": "jeyko", "description": "asdf", "tags": ["asdf"], "likes": 8, "viewed": 414, "published": "Public API", "date": "1578055429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define iTime (iTime + 9.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI acos(-1.)\n#define pi acos(-1.)\n#define dmin(a, b) a.x < b.x ? a : b\n#define fov (0.8 + sin(iTime)*0.05)\n\n// thx nusan for refractions\n// and knighty/lsdlive/tdhooper and others for folding\n\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017 + sin(iTime)*0.002);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.*min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return dir + right*uv.x*fov + up*uv.y*fov;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e5);\n    \n    \n    vec3 q = p;\n    p = fold(p);\n    vec3 z = p;\n    float b = pow((1. + sin(p.x*3.)), 0.7) - 1.;\n    vec3 l = p;\n    l.xz *= rot(sin(iTime*0.7)*0.4 - 0.2);\n    b = min(b, sin(l.x*3.)*3.);\n    z.z += 0.2;\n    z.x += 0.82;\n    d = dmin(d, vec2(mix(dot(z - 0.6, vec3(0.1,0.1,0.2)), b, 0.1),1.));\n    q = fold(q) - vec3(0.5,0.6,-0.2);\n    q = abs(q);\n    q.z -= 0.2;\n    d = dmin(d, vec2( dot(q, normalize(vec3(1))),2.));\n    p.x -= 0.2;\n    p.y += 0.7;\n    \n    p = fold(p) - vec3(0.4,0.4,20.);\n    p = fold(p) - vec3(0.,0.4,20.);\n    p = fold(p) - vec3(0.,0.,1.);\n    \n    for (int i = 0;i < 2; i++){\n    \tp = abs(p);\n        p.x -= 0.2;\n    }\n    \n    p -= 7.;\n    \n    p = fold(p);\n    \n    p -= 0.6;\n    d = dmin(d, vec2( max(p.x, p.y), 1. ));\n    p.xy *= rot(2.5);\n    \n    d.x *= 1.;\n    d.x += sin(p.x*10.)*0.06;\n    return d;\n}\n    \n   \nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\n\n#define zoom (7. + sin(iTime)*0.4)\n#define rotSpeed (iTime*0.2 + cos(iTime*0.7)*0.5 - sin(iTime*0.5)*0.9)\n\n#define pal(x,t) (0.5 + sin(x*vec3(2.9,5.,1.2) + t + sin(iTime)))\n\nvec3 glow = vec3(0);\n#define mx (20.*iMouse.x/iResolution.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(sin(rotSpeed + mx)*zoom,0. + sin(iTime),cos(rotSpeed + mx)*zoom);\n    vec3 lookAt = vec3(0);\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 p = ro; float t, tBeforeRefraction = 0.;\n    \n    float bounce = 0.;\n    vec3 attenuation = vec3(1);\n    float side = 1.;\n    #define ITERS 200.\n    for(float i = 0.; i <= ITERS ; i ++){\n    \tvec2 d = map(p);\n        d.x *= side;\n\t\tglow += pal(t*0.2 + exp(-d.x*10.) + 2., 2.6)* .095 / (.01 + d.x*d.x);\n        \n        if (d.x < 0.002){\n            vec3 lDir = normalize(vec3(1));\n            vec3 n = getNormal(p)*side;\n            vec3 h = normalize(lDir - rd);\n            \n            float diff = max(dot(lDir,n),0.);\n            float fres = pow(1. - max(dot(-rd,n),0.), 20.);\n            float spec = pow(max(dot(h,n),0.), 10.);\n            if (d.y == 2.) {\n            \tcol += mix( (sin(vec3(2.9,2.9,2.6)*glow*0.005) + 7.)*0.1 *diff ,vec3(0.005*glow*min(fres*spec*diff, 1.)), 0.2)*attenuation;\n                break;\n            } else {\n                col += mix( 0.001*glow *diff ,vec3(0.005*glow*min(fres*spec, 1.)), 0.5)*attenuation;\n                attenuation *= vec3(0.2,0.4,0.9)*0.6;\n                ro = p;\n                rd = refract(rd, n, 1. + n.y*0.07 + n.x*0.2);\n                side = -side;\n                bounce++;\n                if(bounce == 1.) {\n                    tBeforeRefraction = t;\n                }\n\n                t = 0.;\n                d.x = 0.2;\n            }\n            \n\n            \n            //break;\n        }\n        if (t > 50. || i == ITERS) {\n            if (bounce == 0.) {\n\t\t\t\ttBeforeRefraction = t;\n            }\n        \tbreak;\n        }\n        t += d.x;\n        p = ro + rd*t;\n    }\n    \n    col -= exp(-7. +tBeforeRefraction*0.14);\n    \n    col *= 1.9;\n    col = clamp(col, 0., 1.);\n    \n    col = mix(col, vec3(0.02,0.03,0.05),smoothstep(0.,1.,0.2 + tBeforeRefraction*0.01));\n    col = pow(col, vec3(0.45));\n    \n    col *= 1.5;\n    col *= 1. - pow(length(uv)*0.5 + 0.37, 4.);\n    fragColor = vec4(col,tBeforeRefraction);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}, {"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 282, 301, 301, 482], [485, 485, 527, 527, 709], [711, 711, 728, 728, 1594], [1604, 1604, 1627, 1627, 1781], [2020, 2020, 2077, 2077, 4215]]}
{"id": "3lK3D1", "name": "sdCylinder Sponge", "author": "jorge2017a1", "description": "sdCylinder Sponge", "tags": ["sdcylindersponge"], "likes": 1, "viewed": 41, "published": "Public", "date": "1578845786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia 60442.0\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n    float  distToCapsule =sdCylinder( p, vec2(1.0,1.0) );\n    \n    d=distToCapsule;\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 45, 45, 71], [73, 73, 102, 102, 188], [190, 190, 219, 219, 295], [298, 298, 380, 380, 611], [614, 614, 650, 650, 753], [756, 931, 954, 954, 1092], [1095, 1095, 1117, 1117, 1187], [1189, 1189, 1208, 1208, 1676], [1678, 1678, 1699, 1699, 1932], [1934, 1934, 1967, 1967, 2250], [2252, 2252, 2309, 2309, 2689]]}
{"id": "3lK3zz", "name": "Seigaiha", "author": "coposuke", "description": "training. 青海波(seigaiha)", "tags": ["pattern", "training", "japanese"], "likes": 4, "viewed": 121, "published": "Public", "date": "1578197433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI      3.14159265358979\n#define PI_HALF (PI / 2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\n    float scale = 5.0 + sin(iTime) * 0.25;\n    uv.y -= fract(iTime * 0.2) / scale;\n    \n    vec2  uvGrid = floor(uv * scale);\n    float uvYOffset = mod(uvGrid.x, 2.0) <= 0.0 ? 0.0 : 0.5;\n    vec2  uvLocal = fract(uv * scale + vec2(0.0, uvYOffset)) - vec2(0.0, 0.5);\n    float dist = 1e+5;\n    \n    // below grids (both sides only)\n    for(float x=-1.0; x<2.0; x+=2.0)\n        dist = min(dist, distance(vec2(x, -1), uvLocal));\n    \n    // self grid\n    const float WAVE_DISTANCE = 1.0;\n\tif(WAVE_DISTANCE < dist)\n    \tdist = min(dist, distance(vec2(0, -0.5), uvLocal));\n\n    // center grids (both sides only)\n\tif(WAVE_DISTANCE < dist)\n  \t\tfor(float x=-1.0; x<2.0; x+=2.0)\n        \tdist = min(dist, distance(vec2(x, 0), uvLocal));\n\n    const float STRIPES = 8.0;\n    float stripeOffset = (-cos(fract(iTime * 0.5) * PI) * 0.5 + 0.5) * (4.0 * PI);\n    fragColor.rgb =\n        (0.0 < sin(dist * STRIPES * PI - stripeOffset)) ?\n    \tvec3(1.0, 0.8, 0.4) :\n    \tvec3(1.0, 0.7, 0.2);\n\n    float uvYGradient = fragCoord.y / iResolution.y;\n    fragColor.rgb *= uvYGradient * 0.4 + 0.6;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lK3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 1281]]}
{"id": "3lKGD3", "name": "Interesting Flower", "author": "zovox", "description": "Interesting Flower", "tags": ["flower", "interesting"], "likes": 2, "viewed": 180, "published": "Public API", "date": "1580063705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\n\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), -sin(x), cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    if( w<0.0 ) return vec2(-1.0);\n    w = sqrt( w );\n\n    // will fail for k0=0, which is only on the ba edge \n    float v = 2.0*k0/(-k1 - w); \n    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);\n\n    float u = (h.x - f.x*v)/(e.x + g.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n    return vec2( u, v );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy*2.-1.;\n    \n    p.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = vec3(0.);\n\n    vec2 c = vec2(0., 0.);\n    vec2 d = vec2(0., 0.);\n\n    const float max_iterations = 4.;\n    \n    float map = 0.;\n    \n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float rots = 6.+3.*sin(time);\n        float angle = atan(-p.y, -p.x);\n        angle = floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 0.);\n        vec2 b = vec2(1., 0.);\n        \n        a *= rotate(-angle/rots*2.*PI);\n        angle += 1.;\n        b *= rotate(-angle/rots*2.*PI);\n\n        p = (invBilinear( p, a, b, c, d ))*2.-1.;\n\n        \n        map += 1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.x+p.y)));\n    }\n\n    fragColor = vec4(flux(map)*clamp(map, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 362, 382, 382, 487], [488, 488, 506, 506, 545], [547, 547, 565, 565, 614], [616, 616, 634, 634, 693], [696, 696, 718, 718, 766], [768, 768, 807, 807, 835], [837, 837, 912, 912, 1474], [1476, 1476, 1528, 1528, 1648], [1650, 1650, 1674, 1674, 1730], [1732, 1732, 1789, 1789, 2654]]}
{"id": "3lKGDz", "name": "infinate sphere", "author": "BrianDeLange", "description": "here I created an infinate universe of spheres", "tags": ["raymarcher"], "likes": 3, "viewed": 87, "published": "Public", "date": "1578688584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distToSphere(vec3 pos){\n    float r = .25;\n    vec3 c = vec3(0., 0.0, 0.0);\n    float sub = 1.;\n    \n    float s = 4.;\n    \n    vec3 a = (pos-c);\n    return pow(pow(a.x, s)+pow(a.y, s)+pow(a.z,s),1./s)-r;\n    \n    //d.dist = length(mod(pos,sub)-c)-r;\n    //d.normal = normalize(mod(pos, sub)-c);\n    //return d;\n}\n\nvec3 CalcNormal(vec3 p)\n{\n    float epsilon = 0.001; // arbitrary — should be smaller than any surface detail in your distance function, but not so small as to get lost in float precision\n    float centerDistance = distToSphere(p);\n    float xDistance = distToSphere(p + vec3(epsilon, 0, 0));\n    float yDistance = distToSphere(p + vec3(0, epsilon, 0));\n    float zDistance = distToSphere(p + vec3(0, 0, epsilon));\n    vec3 normal = (vec3(xDistance, yDistance, zDistance) - centerDistance) / epsilon;\n    return normal;\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.y)*.5;\n    \n    const int numLights = 2;\n    vec3 lightDir[numLights];\n    lightDir[0] = normalize(vec3(1., 1., -1.));\n    lightDir[1] = normalize(vec3(1., 1., 1.));\n\n    float speed = 1.f;\n    vec3 camPosition = vec3(0., .5, -1.);\n    camPosition.xz *= rot(iTime*speed);\n    vec3 rayPos = camPosition;\n    vec3 direction = vec3(uv, .5);\n    direction.y -= 0.2f;\n    direction.xz *= rot(iTime*speed);\n    \n    float d;\n    bool hit = false;\n    while(length(rayPos-camPosition) < 200.){\n        d = distToSphere(rayPos);\n        if(d < 0.001){\n            hit = true;\n            break;\n    \t}\n        else\n            rayPos += direction * d;\n    }\n    \n    vec3 col = vec3(0.);\n\t\n    vec3 lightColor = vec3(.8, .8, .6);\n    vec3 myColor = vec3(.55, .3, .64);\n    float shininess = 73.;\n    \n    \n    for(int i = 0; i < numLights; i++){\n        if(hit){ \n            vec3 normal = CalcNormal(rayPos);\n            vec3 emissive = vec3(0.);\n            vec3 ambient = vec3(0.05, 0.05, 0.1);\n            vec3 diffuse = myColor*lightColor * max(dot(normal, lightDir[i]), 0.);\n            vec3 H = normalize((-1.0f * direction) + lightDir[i]);\n            float facing = max(dot(normal, lightDir[i]), 0.);\n            vec3 specular = myColor * lightColor * facing * pow((max(dot(normal, H), 0.)), shininess);\n            col += emissive + ambient + diffuse + specular;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 319], [321, 321, 346, 346, 844], [846, 846, 865, 865, 941], [943, 943, 1000, 1000, 2472]]}
{"id": "3lKGR1", "name": "Pulsing Stars", "author": "atsn", "description": "pulsing stars in outer space", "tags": ["space", "stars"], "likes": 2, "viewed": 235, "published": "Public API", "date": "1578287065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand21(vec2 uv){\n    vec2 t = fract(vec2(uv.x*236.73,uv.y*678.47));\n    float u = dot(uv*(t+143.66),t);\n    return fract(t.x*u*345.87 + 365.22+t.y*u*475.57);\n}\nfloat rand21p(vec2 uv){\n    vec2 p = floor(uv);\n    vec2 fr = fract(uv);\n    \n    float grad = (\n        rand21(p+vec2(0.,0.)) * (1.-fr.x) * (1.-fr.y) + \n        rand21(p+vec2(1.,0.)) * (fr.x) * (1.-fr.y) +\n        rand21(p+vec2(0.,1.)) * (1.-fr.x) * (fr.y) +\n        rand21(p+vec2(1.,1.)) * (fr.x) * (fr.y)\n    );\n    return grad;\n}\nfloat perlin(vec2 uv, float layers){\n    float ret = 0.;\n    for(float i=0.;i<layers;i++){\n        ret += rand21p(uv*pow(2.,i)) / layers;\n    }\n    return ret;\n}\nfloat splatter(float time, vec2 uv){\n    float n0 = perlin(uv+rand21(uv*dot(uv,vec2(time))),9.);\n    return smoothstep(0.5,0.55,n0);\n}\nfloat ease(float time, vec2 uv){\n    float cur = splatter(floor(time),uv);\n    float next = splatter(floor(time)+1.,uv);\n    float f = fract(time);\n    return (1.-f)*cur + f*next;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5/iResolution.xy)/iResolution.y;\n    \n   \tfloat stars = pow(rand21(uv),200.) * (ease(iTime*2.,uv)*.7+.3);\n    \n    float atmo = pow(smoothstep(4.,3.5,length(uv-vec2(.9,-3.6))),2.);\n    vec3 atmo_col = vec3(.5,.5,1.);\n    \n    vec3 col = vec3(stars);\n    col = max(atmo_col*atmo,stars);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 165], [166, 166, 189, 189, 499], [500, 500, 536, 536, 661], [662, 662, 698, 698, 796], [797, 797, 829, 829, 978], [979, 979, 1036, 1036, 1387]]}
{"id": "3lKGRW", "name": "Translucency Rendering II", "author": "ikuto", "description": "Move mouse horizontally to control the camera position and vertically to control the light position.", "tags": ["translucency", "translucent"], "likes": 30, "viewed": 568, "published": "Public API", "date": "1578482616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n#define PI 3.14159\n\nstruct Material\n{\n    vec3 \tdiffuseAlbedo;\n    vec3 \tspecularAlbedo;\n    float \tspecularPower;\n    float   bumpiness;\n};\n    \nMaterial materials[] = Material[] \n(\n    Material(vec3(0.0, 0.2, 0.2), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.0, 0.1, 0.2), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.0, 0.2, 0.1), vec3(0.3), 4.0, 0.2),\n    Material(vec3(0.1, 0.2, 0.0), vec3(0.3), 8.0, 0.1),\n    Material(vec3(0.2, 0.0, 0.2), vec3(0.3), 4.0, 0.15),\n    Material(vec3(0.4, 0.3, 0.02), vec3(0.2), 1.0, 0.1),\n    Material(vec3(0.2, 0.0, 0.2), vec3(0.2), 1.0, 0.1),\n    Material(vec3(0.0, 0.1, 0.1), vec3(0.2), 1.0, 0.05)\n);\n\nvec2 rotate(vec2 v, float a) { return cos(a)*v + sin(a)*vec2(v.y,-v.x); }\n\n//noise function from https://www.shadertoy.com/view/MsXGWr\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec2 opUnion(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\n//distance function from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 map(vec3 p)\n{\n    float objID = 0.0;\n    vec2 res = vec2(sdRoundBox(p-vec3(0.0, 0.0, 0.0), vec3(0.7, 0.7, 0.7), 0.2), objID++);\n    vec3 p2 = p - vec3(0.0, 1.3, 0.0); p2.xz = rotate(p2.xz, PI/6.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.3, 0.3, 0.3), 0.1), objID++));\n    p2 = p - vec3(0.0, 2.2, 0.0); p2.xz = rotate(p2.xz, PI/9.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.5, 0.3, 0.5), 0.2), objID++));\n    p2 = p - vec3(3.0, 0.3, 0.0); p2.xz = rotate(p2.xz, PI/9.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.7, 1.0, 0.7), 0.2), objID++));\n    p2 = p - vec3(-3.0, -0.2, 0.5); p2.xz = rotate(p2.xz, PI/4.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.5, 0.5, 0.5), 0.2), objID++));\n    p2 = p - vec3(-2.8, 1.3, 0.5); p2.xz = rotate(p2.xz, 0.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.6, 0.6, 0.6), 0.2), objID++));\n    p2 = p - vec3(1.0, -0.4, 2.5); p2.xz = rotate(p2.xz, PI/6.0);\n    res = opUnion(res, vec2(sdRoundBox(p2, vec3(0.4, 0.4, 0.4), 0.1), objID++));\n    res = opUnion(res, vec2(p.y + 0.9, objID++));\n    return res;\n}\n\nvec3 calculateTransmittance(vec3 ro, vec3 rd, float tmin, float tmax, vec3 atten)\n{\n    float thickness = 0.0;\n    for (float t = tmin; t < tmax;)\n    {\n        float h = map(ro + t * rd).x;\n        float dt = (abs(h) < 1e-5) ? 0.01 : min(tmax-t, abs(h));\n        if (h < 0.0) thickness += dt; \n        t += dt;\n    }\n    \n    return exp(-atten * thickness);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfor (float t = tmin; t < tmax;)\n    {\n        vec3 pos = ro + t * rd;\n        vec2 res = map(pos);\n        \n        float dist = res.x;\n        if (dist < 0.001) return vec2(t, res.y);\n        \n        t += dist;\n    }\n    return vec2(1e6, -1.0);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    vec3 dt = vec3(0.001, 0.0, 0.0);\n    return normalize( vec3 ( map(p+dt.xyy).x - map(p-dt.xyy).x,\n    \t\t\t\t\t\t map(p+dt.yxy).x - map(p-dt.yxy).x,\n                             map(p+dt.yyx).x - map(p-dt.yyx).x ) );\n}\n\nfloat calculateAO(vec3 pos, vec3 nor) //ambient occlusion\n{\n    float ao = 0.0, sca = 1.0;\n    \n    for (int i = 0; i < 5; ++i)\n    {\n    \tfloat h = 0.01 + 0.11*float(i)/4.0;\n        float d = map(pos+h*nor).x;\n        ao += (h-d)*sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0-2.0*ao, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n    \n    float an = iMouse.z>0.0 ? 10.0*(iMouse.y/iResolution.y-0.5) : (1.0-0.2*iTime);\n    vec3 lightPos = vec3(3.0*cos(an), 1.3, 3.0*sin(an));\n    vec3 lightColor = vec3(10.0, 8.0+sin(iTime)*6.0, 7.0+cos(iTime)*5.0);\n    \n    vec2 res = rayMarch(ro, rd, 0.01, 15.0);\n    float t = res.x;\n    float objID = res.y;\n    \n    //draw entities\n    if (objID > -0.5)\n    {\n        Material mat = materials[int(objID)];\n        vec3 pos = ro + t * rd;\n        vec3 nor = calculateNormal(pos);\n        vec3 bnor = -1.0 + 2.0 * texturize(iChannel0, 0.5*pos, nor);\n\t\tnor = normalize(nor + mat.bumpiness*bnor);\n       \n        vec3 lightDir = normalize(lightPos - pos);\n        float lightDist = length(lightPos - pos);\t\t\n        float atten = 1.0 / (1.0 + 0.5 * lightDist * lightDist);\n        vec3 light = atten * lightColor;\n        light *= calculateTransmittance(pos+0.01*nor, lightDir, 0.01, min(lightDist, 20.0), vec3(1.0, 0.6, 0.5));\n        \n        float ao = calculateAO(pos, nor);\n        color +=  light * mat.diffuseAlbedo;\n        color += light * mat.specularAlbedo * pow(max(0.0, dot(reflect(lightDir,nor),rd)), mat.specularPower);\n        color *= ao;\n    }\n    \n    //draw lights\n    {\n        vec3 lv = lightPos - ro;\n        float ll = length(lv);\n        if (ll < t)\n        {\n            float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n            color += 1e2*lightColor*pow((1.0-smoothstep(0.0, 0.8, angle*ll)), 32.0);    \n        }\n    }\n    \n    return color;\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float an = iMouse.z>0.0 ? 10.0*(iMouse.x/iResolution.x-0.5) : 0.0;\n    \n\tvec3 ro = 5.0*vec3(1.2*sin(an), 0.3, cos(an)+0.2);\n    mat3 viewMat = lookAt(ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < AA; ++i) //super sampling\n    {\n        for (int k = 0; k < AA; ++k)\n        {\n            vec2 offset = vec2(float(i)+0.5,float(k)+0.5) / float(AA) - 0.5;\n            vec2 uv = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;    \n    \t    vec3 rd = viewMat * normalize(vec3(uv, -2.0));\n    \t\t\n            color += render(ro, rd);\n        }\n    }\n    \n\tcolor /= float(AA*AA);\n\tcolor = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[650, 650, 680, 680, 723], [725, 785, 833, 833, 986], [988, 988, 1018, 1018, 1046], [1048, 1144, 1189, 1189, 1280], [1282, 1282, 1300, 1300, 2364], [2366, 2366, 2449, 2449, 2726], [2728, 2728, 2785, 2785, 3035], [3037, 3037, 3067, 3067, 3284], [3286, 3286, 3345, 3345, 3595], [3597, 3597, 3628, 3628, 5137], [5139, 5139, 5184, 5184, 5315], [5317, 5317, 5372, 5372, 6084]]}
{"id": "3lKGzt", "name": "SineMadness", "author": "kvick", "description": "sine waves", "tags": ["sine"], "likes": 3, "viewed": 90, "published": "Public", "date": "1579626275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circ(in vec2 st, in vec2 pos, float r)\n{\n    vec2 d = st - pos;\n \treturn (sqrt(d.x * d.x + d.y * d.y) < r) ? 0.0 : 1.0;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 st = vec2(uv.x * aspect, uv.y);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    col = vec3(uv.y * 0.25 + 0.5);\n    \n    float rotRad = 0.4;\n    float degs = iTime * 0.1;\n    vec2 pOrigin = vec2(0.5 * aspect, 0.5);\n    col *= circ(st, pOrigin, 0.025);\n    \n    //Orbit\n    //float numRows = mod(iTime * 8.0, 64.0);\n    float numRows = sin(iTime * 0.5) * 32.0 + 32.0;//, 64.0);\n    for(float j = 0.0; j < numRows; j += 1.0)\n    {\n        for(float i = 0.0; i < 44.0; i += 1.0)\n        {\n            //offset j\n            float oj = j - (numRows * 0.5);\n            degs = iTime * 0.1 + i + j * 0.01;\n            \n            //normalized j\n            float nj = (oj / numRows);\n            vec2 circPos = vec2(cos(degs) * rotRad * nj+ oj * 0.01, sin(degs) * rotRad * nj + oj * 0.01);\n            col *= circ(st, pOrigin + circPos, 0.0025 + j * 0.0001);\n        }\n    }\n    \n    degs = iTime * 0.1;\n    for(float i = 1.0; i < 36.0; i += 1.0)\n    {\n\t\tvec2 circPos = vec2(cos(degs * 2.0 * i) * rotRad, sin(degs * i * 1.1) * rotRad);\n    \tcol *= circ(st, pOrigin + circPos, 0.01 * abs((pOrigin - st).y) * 4.1);\n    }\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 130], [132, 132, 189, 239, 1530]]}
{"id": "3lt3WS", "name": "Recursive Platonic solids", "author": "tomoe", "description": "generalization of Sierpinski's method", "tags": ["imi202001"], "likes": 10, "viewed": 301, "published": "Public API", "date": "1578290810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n#define v1 vec3(1.0, 0.0, 0.0)\n#define v3 vec3(0.0, 0.0, 1.0)\nvec3 v2, w1, w2, w3;\nvec3 vtxP, edgN, faceN;\nfloat rad = 1.0;\nvoid init(float m) {\n    v2 = vec3(-0.5, sqrt(0.75 - pow(cos(PI / m), 2.0)), - cos(PI / m));\n    float triProd = dot(cross(v1, v2), v3);\n    w1 = normalize(cross(v3, v2) / triProd);\n    w2 = normalize(cross(v1, v3) / triProd);\n    w3 = normalize(cross(v2, v1) / triProd);\n}\nfloat edgSDF(vec3 p, float t) {// t:thickness\n    return max(abs(dot(p - vtxP, faceN)), abs(dot(p - vtxP, edgN))) - t;\n}\nfloat vtxSDF(vec3 p, float t) {\n    return length(p - vtxP) - t;\n}\nfloat faceSDF(vec3 p, float t) {\n    return dot(p - vtxP, faceN) - t;\n}\n#define fold(w)p = p - 2.0 * max(dot(w, p), 0.0) * w;\nfloat tetraSDF(vec3 p) {\n    init(3.0);\n    float scale = 2.0;\n    float scalePow = 1.0;\n    vtxP = rad * w1;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v3)fold(v2)fold(v3)fold(v1)fold(v2)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }  \n    edgN = w2;\n    faceN = w3;\n    return edgSDF(p, 0.1) / scalePow;\n}\nfloat cubeSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w3;\n    float scale = 2.5;\n    float scalePow = 1.0;\n    for(int i = 0; i < 4; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return faceSDF(p, 0.5) / scalePow;\n}\nfloat octaSDF(vec3 p) {\n    init(4.0);\n    vtxP = rad * w1;\n    float scale = 2.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return min(edgSDF(p, 0.02), vtxSDF(p, 0.3)) / scalePow;\n}\nfloat dodecaSDF(vec3 p) {\n    init(5.0); \n    vtxP = rad * w1;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w3;\n    return faceSDF(p, 0.0) / scalePow;\n}\nfloat icosaSDF(vec3 p) {\n    init(5.0);\n    vtxP = rad * w3;\n    float scale = PHI + 1.0;\n    float scalePow = 1.0;\n    for(int i = 0; i < 3; i ++ ) {\n        fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n        p *= scale;\n        scalePow *= scale;\n        p -= (scale - 1.0) * vtxP;\n    }\n    edgN = w2;\n    faceN = w1;\n    return edgSDF(p, 0.08) / scalePow;\n}\nmat3 euler(float h, float p, float r) {\n    return mat3(\n        cos(r) * cos(h) - sin(r) * sin(p) * sin(h), - sin(r) * cos(p), cos(r) * sin(h) + sin(r) * sin(p) * cos(h),\n        sin(r) * cos(h) + cos(r) * sin(p) * sin(h), cos(r) * cos(p), sin(r) * sin(h) - cos(r) * sin(p) * cos(h),\n        - cos(p) * sin(h), sin(p), cos(p) * cos(h)\n    );\n}\n#define seq(v, s)d = mix(d, v, smoothstep(s - 0.3, s, t));\nfloat sceneSDF(vec3 p) {\n    float seqStep = 5.0;\n    float t = abs(mod(iTime * 0.5, seqStep * 2.0) - seqStep);\n    float d = tetraSDF(p);\n    seq(cubeSDF(p), 1.0)\n    seq(octaSDF(p), 2.0)\n    seq(dodecaSDF(p), 3.0)\n    seq(icosaSDF(p), 4.0)\n    return d;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n            sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n            sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n            sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n        ));\n    }\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    vec3 cSide = cross(cDir, cUp);\n\n    // light\n    vec3 lightPos = g * vec3(0.0, 1.0, 1.0);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    vec3 rPos = cPos ;\n\n    // marching loop\n    for(int i = 0; i < 60; i ++ ) {\n        rPos += sceneSDF(rPos) * ray;\n    }\n\n    // collision detection\n    if (sceneSDF(rPos) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), normal), 0.01, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lt3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 199, 199, 452], [453, 453, 484, 498, 573], [574, 574, 605, 605, 640], [641, 641, 673, 673, 712], [767, 767, 791, 791, 1129], [1130, 1130, 1153, 1153, 1514], [1515, 1515, 1538, 1538, 1920], [1921, 1921, 1946, 1946, 2362], [2363, 2363, 2387, 2387, 2802], [2803, 2803, 2842, 2842, 3147], [3207, 3207, 3231, 3231, 3464], [3465, 3465, 3487, 3487, 3795], [3796, 3796, 3851, 3876, 4831]]}
{"id": "3ltSzn", "name": "Sin and Cos", "author": "tonywu", "description": "just for test", "tags": ["sound"], "likes": 2, "viewed": 185, "published": "Public API", "date": "1580291616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n        // the sound texture is 512x2\n    //int tx = int(uv.x*512.0);\n    int tx = 1;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    \n    col += sin(uv.x * cos(iTime/30.*fft/20.) * 60.) + sin(uv.y * cos(iTime / 20.) * 18.);\n\n    col += cos(uv.x* sin(iTime/60.) * 60.) + cos(uv.y * sin(iTime / 10.*wave) * 18. * fft);\n    \n    //col *= sin(iTime / 30.);\n    \n    col += mix(col,(cos(iMouse.yxy+vec3(0,2,4))),uv.y);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 951]]}
{"id": "3ltXzr", "name": "ShoninVRC/Random noise", "author": "ShoninVRC", "description": "noise", "tags": ["noise"], "likes": 2, "viewed": 259, "published": "Public API", "date": "1580308155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define _num 200.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int uvx = int(uv.x * _num);\n    int uvy = int(uv.y * _num);\n    uv.x = float(uvx) / _num;\n    uv.y = float(uvy) / _num;\n    float _rnd = rand(uv * iTime);\n    _rnd = rand(vec2(_rnd, iTime));\n    \n    if(fract(iTime * 2.0) > 0.1)\n        _rnd /= fract(iTime * 2.0);\n\n    // Time varying pixel color\n    vec4 col = vec4(_rnd, _rnd, _rnd, _rnd);\n\n    // Output to screen\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Random noise\",\n\t\"description\": \"first of glsl\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [114, 114, 171, 221, 661]]}
{"id": "3lV3W3", "name": "3D Tree", "author": "zovox", "description": "3D Tree", "tags": ["3d", "tree"], "likes": 5, "viewed": 257, "published": "Public API", "date": "1580063451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*GR*E*5.)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI/GR/E)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvec3 mcol;\nfloat dB;\nfloat dfScene(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n\tfloat d=max(abs(z.y+1.0)-1.0,length(z.xz)-0.13);\n\tfor(int i=0;i<5;i++){\n\t\tz.xz=Kaleido(z.xz,float(i+2)*2.);\n\t\tz.yz=Rotate(z.yz,(saw(time*PI)-1.));\n\t\t\n        float dcap = sdCapsule(z.xyz+vec3(0., 0., 1.), vec3(0.,0.,1.), vec3(0.,2.0,0.),0.1);\n        dB += dcap/z.w/10.;\n\t\td=min(d,dcap/z.w);\n\t\tz.z+=1.0;\n        z.y -= 2.;\n\t\tz*=vec4(2.0,2.0,2.0,2.0);\n\t}\n\t//dB=(length(z.xyz)-1.0)/z.w;\n\treturn d;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 64; i++) {\n        rp = ro + rd * d;\n        float ns = dfScene(rp);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = flux(dB+time); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = sc;//pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, 1./GR, -PI)*2.;\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 1023, 1060, 1060, 1121], [1122, 1122, 1158, 1158, 1221], [1222, 1222, 1276, 1276, 1357], [1359, 1359, 1378, 1378, 1430], [1432, 1432, 1484, 1484, 1611], [1633, 1633, 1659, 1659, 2080], [2082, 2082, 2119, 2119, 2421], [2423, 2428, 2471, 2471, 2764], [2766, 2779, 2814, 2814, 3574], [3577, 3577, 3632, 3666, 4110]]}
{"id": "3lV3WK", "name": "Wavy SDFs and Norms", "author": "rarora7777", "description": "A bunch of wavy \"circles\".", "tags": ["waves", "sdf", "norm"], "likes": 3, "viewed": 74, "published": "Public", "date": "1579899160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846264338327950288\n\nfloat sdf(vec2 xy, float t, vec2 center)\n{\n    float x = xy.x - center.x;\n    float y = xy.y - center.y;\n    float theta = atan(y, x);\n    float angleDist = min(abs(theta-mod(t, 2.*M_PI)), abs(mod(t, 2.*M_PI)-theta));\n    \n    float p = (sin(t*2.) + 1.0) / 2.0;\n    float power = p * .5 + (1.-p) * 8.;\n    float r = pow((abs(pow(abs(x), power)) + abs(pow(abs(y), power))), 1./power);\n    \n    float param = (sin(10.*angleDist) + 1.)/2.;\n    param = smoothstep(0., 1., param);\n    \n    return r * (1.0 * param + .75 * (1.-param));\n}\n\nvec3 thingy(vec2 xy, float t, vec2 center, float size, vec3 color)\n{\n    float sizeIn = size * 24./25.;\n    vec3 colorIn = color / 3.;\n    \n    float dist = sdf(xy, t, center);\n    \n    vec3 col;\n    \n    if (dist < sizeIn)\n        col = color;\n    else if (dist < size)\n        col = colorIn;\n    else\n        col = vec3(0.);\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    //float dist = sdf(uv, iTime);\n    \n    vec3 col = vec3(0.);\n    col += thingy(uv, iTime, vec2(1.5, .5), .25, vec3(153.,216.,201.)/255.);\n    col += thingy(uv, iTime+.5, vec2(0., 1.), .45, vec3(254.,178.,76.)/255.);\n    col += thingy(uv, (iTime+.25)/5., vec2(0.7, 0.35), .15, vec3(103.,138.,76.)/255.);\n    col += thingy(uv, 2.*iTime, vec2(0.35, 0.32), .2, vec3(200.,100.,6.)/255.);\n    col += thingy(uv, 4.*(iTime+.75), vec2(1., .8), .35, vec3(176.,116.,197.)/255.);\n    col += thingy(uv, 1.5*(iTime+.5), vec2(1.6, 0.), .45, vec3(250.,159.,181.)/255.);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 94, 94, 583], [585, 585, 653, 653, 926], [929, 929, 986, 1036, 1729]]}
{"id": "3lV3zK", "name": "krap", "author": "monsterkodi", "description": "MOUSE rotate \nRIGHT  rotation \nDOWN  antialias \nUP       animation\n", "tags": ["sdf"], "likes": 22, "viewed": 172, "published": "Public", "date": "1579813410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TOY  1\n\n#define MAX_STEPS 128\n#define MIN_DIST   0.005\n#define MAX_DIST  20.0\n#define SHADOW     0.4\n#define FLOOR      0.0\n\n#define PI 3.1415926535897\n#define ZERO min(iFrame,0)\n\n#define NONE  0\n#define PLANE 1\n#define HEAD  2\n#define BULB  3\n#define PUPL  4\n#define BBOX  6\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nsdf s;\nint mat;\nint AA = 2;\nvec2 frag;\nbool soft;\nfloat brth;\nbool animat;\nvec3 camPos;\nvec3 camTgt;\nvec3 camDir;\n\nvec3 pHead, nyHead, nzHead;\nvec3 pEyeT, pEyeL, pEyeR, nEyeL, nEyeR, pEarL, nEarL, pEarR, nEarR, pPupL, pPupR, pLnsL, pLnsR,\n     pLegL, nLegL, pLegR, nLegR, pLegF, nLegF; \n\nvec3 v0 = vec3(0,0,0);\nvec3 vx = vec3(1,0,0);\nvec3 vy = vec3(0,1,0);\nvec3 vz = vec3(0,0,1);\n    \nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\nfloat gradientNoise(vec2 uv)\n{\n    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n}\n\n// 0000000    000   0000000   000  000000000  \n// 000   000  000  000        000     000     \n// 000   000  000  000  0000  000     000     \n// 000   000  000  000   000  000     000     \n// 0000000    000   0000000   000     000     \n\nfloat digitBin(const int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat digit(vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces)\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = fValue < 0.0;\n    fValue = abs(fValue);\n    \n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if (fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n        if (fDigitIndex > fBiggestIndex) \n        {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } \n        else \n        {\n            if (fDigitIndex == -1.0) \n            {\n                if (fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } \n            else \n            {\n                float fReducedRangeValue = fValue;\n                if (fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = digitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod(fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0)), 2.0));\n}\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    vec4 qr;\n    float half_angle = deg2rad(angle * 0.5);\n    qr.x = axis.x * sin(half_angle);\n    qr.y = axis.y * sin(half_angle);\n    qr.z = axis.z * sin(half_angle);\n    qr.w = cos(half_angle);\n    return qr;\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 quat, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotate(vec4 quat, vec3 o, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p-o, 0));\n    return o + quatMul(q_tmp, conj).xyz;\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    vec4 qr_conj = quatConj(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n    \n    vec4 q_tmp = quatMul(qr, q_pos);\n    qr = quatMul(q_tmp, qr_conj);\n    \n    return vec3(qr.x, qr.y, qr.z);\n}\n\nvec3 rotRayAngle(vec3 position, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(position-ro, rd-ro, angle)+ro;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opUnion(float d1, float k, float d2) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opDiff(float d1, float k, float d2) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{   \n    return dot(n, p);\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, float rl, float rs)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-rl,abs(dot(n, q))))-rs;\n}\n\nfloat sdConeBend(vec3 p, vec3 a, vec3 b, float fa, float fb)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    vec3 n  = normalize(ab);\n    float l = length(ab);\n    float dp = dot(ab,ap);\n    float dn = dot(ab,ab);\n    float t = dp / dn;\n    float ct = clamp(t, -0.5, 10.0);\n    float ra = l*fa;\n    float rb = l*fb;\n    \n    vec3 lp = a+ab*clamp01(t);\n    return length(p-lp) - (ct*rb+(1.0-ct)*ra);\n}\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(vec3 pos, vec3 pupil, vec3 lens)\n{\n    float d = sdSphere(s.pos, pos, 0.35);\n    if (d > s.dist) return;\n    \n    d = opDiff(d, 0.05, sdSphere(s.pos, pupil, 0.15));\n\n    if (d < s.dist) { s.mat = BULB; s.dist = d; }\n    \n    d = min(d, sdSphere(s.pos, lens, 0.2));\n    \n    if (d < s.dist) { s.mat = PUPL; s.dist = d; }\n}\n\n// 000      00000000   0000000   \n// 000      000       000        \n// 000      0000000   000  0000  \n// 000      000       000   000  \n// 0000000  00000000   0000000   \n\nfloat leg(vec3 pos, vec3 n)\n{\n    float d = sdConeBend(s.pos, pos, pos+n*0.2, 2.1, 2.5);\n    \n    d = opDiff(d, 0.2, sdPlane(s.pos, pos+n*0.5, -n));\n    d = opDiff(d, 0.1, sdSphere(s.pos, pos+n*0.7, 0.4));\n    \n    return d;\n}\n\n// 00000000   0000000   00000000   \n// 000       000   000  000   000  \n// 0000000   000000000  0000000    \n// 000       000   000  000   000  \n// 00000000  000   000  000   000  \n\nfloat ear(vec3 pos, vec3 n)\n{\n    float d = sdConeBend(s.pos, pos, pos+n*0.23, 0.7, 1.1);\n    \n    d = opDiff(d, 0.25, sdSphere(s.pos, pos+n*(0.5 + 0.15*brth/2.0), 0.1));\n    \n    return d;\n}\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nvoid anim()\n{\n    float tt = 1.0-fract(iTime*0.5);\n    float aa = cos(tt*tt*PI*2.0); \n    float ab = cos(tt*PI*2.0); \n    \n    brth = 1.0*mix(smoothstep(-0.8, 0.95, aa), ab, 0.3);\n    \n    vec3 hsh1 = hash31(floor(iTime*0.3));\n    vec3 hsh2 = hash31(floor(iTime));\n    \n    pEyeT = camPos + hsh1*2.0 + hsh2*0.5;\n}\n    \nvoid pose()\n{\n    pHead = vec3(0,1.35,-brth*0.015);\n    \n    nyHead = rotAxisAngle(vy, vx, -2.0*brth);\n    nzHead = rotAxisAngle(vz, vx, -2.0*brth);\n    \n    nEarL = rotAxisAngle(rotAxisAngle(nzHead, vx, -48.0), nyHead,  130.0);\n    nEarR = rotAxisAngle(rotAxisAngle(nzHead, vx, -48.0), nyHead, -130.0);\n  \n    pEarL = pHead + nEarL*1.1;\n    pEarR = pHead + nEarR*1.1;\n  \n    nEarL = normalize(nEarL+vec3( brth*0.2,0,0));\n    nEarR = normalize(nEarR+vec3(-brth*0.2,0,0));\n    \n    nEyeL = rotAxisAngle(rotAxisAngle(nzHead, vx, -42.0), nyHead,  48.0);\n    nEyeR = rotAxisAngle(rotAxisAngle(nzHead, vx, -42.0), nyHead, -48.0);\n    \n    pEyeL  = pHead + nEyeL*0.9;\n    pEyeR  = pHead + nEyeR*0.9;\n    \n    nLegL = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 - 3.0*brth), nyHead,  120.0);\n    nLegR = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 - 3.0*brth), nyHead, -120.0);\n    nLegF = rotAxisAngle(rotAxisAngle(vz, vx, 42.0 + 0.5*brth), nyHead,    0.0);\n    \n    vec3 nl = normalize(pEyeT - pEyeL);\n    vec3 nr = normalize(pEyeT - pEyeR);\n        \n    float pd = 0.3;\n    float ld = 0.16;\n\n    pPupL = pEyeL + pd*nl;\n    pPupR = pEyeR + pd*nr;\n    \n    pLnsL = pEyeL + ld*nl;\n    pLnsR = pEyeR + ld*nr;\n}\n\n// 000   000  00000000   0000000   0000000    \n// 000   000  000       000   000  000   000  \n// 000000000  0000000   000000000  000   000  \n// 000   000  000       000   000  000   000  \n// 000   000  00000000  000   000  0000000    \n\nvoid head()\n{        \n    float bd = sdSphere(s.pos, pHead, 2.3);    \n\n    if (bd > MIN_DIST*1.1) \n    {\n        if (bd < s.dist) { s.mat = BBOX; s.dist = bd; }\n        return;\n    }\n\n    float d = sdSphere(s.pos, pHead, 1.0+brth*0.01);\n\n    d = opUnion(d, 0.2, ear(pEarL, nEarL));\n    d = opUnion(d, 0.2, ear(pEarR, nEarR));\n            \n    d = opUnion(d, 0.15, sdTorus(s.pos, pEyeL, nEyeL, 0.4, 0.05));\n    d = opUnion(d, 0.15, sdTorus(s.pos, pEyeR, nEyeR, 0.4, 0.05));\n    \n    d = opUnion(d, 0.2, leg(pHead + nLegL, nLegL));\n    d = opUnion(d, 0.2, leg(pHead + nLegR, nLegR));\n    d = opUnion(d, 0.2, leg(pHead + nLegF, nLegF));\n    \n    if (d < s.dist) { s.mat = HEAD; s.dist = d; }\n        \n    eye(pEyeL, pPupL, pLnsL);\n    eye(pEyeR, pPupR, pLnsR);\n}\n\nvoid plane(vec3 pos)\n{        \n    if (camPos.y < FLOOR) return;\n    float d = sdPlane(s.pos, pos, vy);\n    if (d < s.dist) { s.mat = PLANE; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n         \n    plane(v0);\n    head();\n\n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i=0; i<25; i++)\n    {\n        float h = map(ro+rd*dist);\n        if (s.mat != BBOX)\n            shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k / PI;\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col)\n{\n    if (mat == NONE) return col;\n    \n    vec3 cr = cross(camDir, vec3(0,1,0));\n    vec3 up = normalize(cross(cr,camDir));\n    vec3 lp = 2.0 * (camPos + vec3(-0.5,1.0,0) + up*2.0); \n    vec3 l = normalize(lp-p);\n \n    float ambient = 0.005;\n    float dif = clamp(dot(n,l), 0.0, 1.0);\n    \n    if (mat == PUPL)\n    {\n        dif = clamp(dot(n,normalize(mix(camPos,lp,0.1)-p)), 0.0, 1.0);\n        dif = mix(pow(dif, 16.0), 1.0*dif, 0.2);\n        dif += 1.0 - smoothstep(0.0, 0.2, dif);\n        if (mat == PUPL) ambient = 0.1;\n    }\n    else if (mat == BULB)\n    {\n        dif = mix(pow(dif, 32.0), 3.0*dif+1.0, 0.2);\n        ambient = 0.2;\n    }\n    else if (mat == HEAD)\n    {\n        float exp = 1.5;\n        float smx = 0.27;\n        \n        vec3  n2c = normalize(camPos-p);\n        vec3  bcl = normalize(n2c + l);\n        float dnh = dot(n, bcl);\n        float shi = shiny(2.5, dnh, bcl);\n        \n        dif = pow(dif, exp);\n        dif = mix(dif, shi, smx);\n        ambient = 0.1;\n    }\n    \n    if (mat == HEAD || mat == PLANE || mat == BULB)\n    {\n        dif *= softShadow(p, lp, 6.0);        \n    }\n    \n    vec3 hl = v0;\n    if (mat == PUPL || mat == BULB)\n    {\n        hl = vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 20.0));\n    }\n    else if (mat == HEAD)\n    {\n        float hv = pow(clamp01(smoothstep(0.7,1.0,dot(n, l))), 1.2);\n        hl = col*hv*0.3;\n    }\n    \n    return col * clamp(dif, ambient, 1.0) + hl;\n}\n\n// 00000000   0000000    0000000   \n// 000       000   000  000        \n// 000000    000   000  000  0000  \n// 000       000   000  000   000  \n// 000        0000000    0000000   \n\nvec3 fog(vec3 col, vec3 bg, float dist)\n{\n    float f = smoothstep(5.0, MAX_DIST, dist);\n    return mix(col, bg, f);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    frag = fragCoord;\n    bool dither = true;\n    bool camrot = texelFetch(iChannel0, ivec2(KEY_RIGHT, 2), 0).x < 0.5;\n    bool space  = texelFetch(iChannel0, ivec2(KEY_SPACE, 2), 0).x > 0.5;\n         soft   = texelFetch(iChannel0, ivec2(KEY_DOWN,  2), 0).x < 0.5;\n         animat = texelFetch(iChannel0, ivec2(KEY_UP,    2), 0).x < 0.5;\n          \n    if (!soft) \n    {\n        AA = 1;   \n    }\n    else\n    { \n        if (iTimeDelta < 0.02) AA = 3;\n    }\n         \n    float d;\n    vec3 cols = v0;\n    vec3 col, foc;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    float md = 5.5;\n    float mx = 2.0*(iMouse.x/iResolution.x-0.5);\n    float my = 2.0*(iMouse.y/iResolution.y-0.5);\n    \n    if (iMouse.z <= 0.0 && camrot)\n    {\n        float ts = 276.2;\n        mx = 0.3*sin(ts+iTime/12.0);\n        my = -0.20-0.10*cos(ts+iTime/8.0);\n    }\n    \n    camTgt = vec3(0,1.2,0); \n\n    camPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vx, 89.0*my), vy, -180.0*mx);\n    \n    #ifndef TOY\n        if (space)\n        {\n            camTgt = iCenter;\n            camPos = iCamera;\n            camPos.x *= -1.0;\n            camTgt.x *= -1.0;\n        }\n    #endif\n    \n    camDir = normalize(camTgt-camPos);\n    \n    if (animat) { anim(); }\n    else { pEyeT = camPos; }\n    \n    pose();\n    \n    vec2 ao = vec2(0);\n    vec2 uv;\n    \n    for( int am=ZERO; am<AA; am++ )\n    for( int an=ZERO; an<AA; an++ )\n    {\n        if (AA > 1) ao = vec2(float(am),float(an))/float(AA)-0.5;\n\n        uv = (fragCoord+ao-.5*iResolution.xy)/iResolution.y;\n                \n        vec3 ww = normalize(camTgt-camPos);\n        vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize(cross(uu, ww));\n            \n        vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n        \n        d = rayMarch(camPos, rd);\n        mat = s.mat;\n        \n        vec3  p = camPos + d * rd;\n        vec3  n = getNormal(p);\n                \n        if      (mat == HEAD)  col = vec3(1.0, 0.6, 0.0);\n        else if (mat == PLANE) col = vec3(0.5, 0.0, 0.0);\n        else if (mat == PUPL)  col = vec3(0.1, 0.1, 0.5);\n        else if (mat == BULB)  col = vec3(1.0, 1.0, 1.0);\n        else if (mat == NONE)  col = vec3(0.22, 0.0, 0.0);\n        foc = vec3(0.22, 0.0, 0.0);\n    \n        col = getLight(p, n, col);\n            \n        if (mat != NONE)\n        {\n            col = fog(col, foc, d);\n        }\n            \n        cols += col;\n    }\n    \n    col = cols/float(AA*AA);\n    \n    col *= clamp(1.0-1.1*length((fragCoord-.5*iResolution.xy)/iResolution.xy), 0.0, 1.0);\n    \n    if (dither)\n    {\n        float dit = gradientNoise(fragCoord.xy);\n        col += vec3(dit/1024.0);\n    }\n    \n    #ifndef TOY\n    vec2  fontSize = vec2(20.0, 35.0);  \n    float isDigit = digit(fragCoord / fontSize, iFrameRate, 2.0, 0.0);\n    col = mix(col, vec3(1.0, 1.0, 1.0), isDigit);\n    #endif\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[778, 778, 802, 802, 827], [828, 828, 852, 852, 877], [879, 879, 901, 901, 1028], [1030, 1030, 1052, 1052, 1185], [1187, 1187, 1211, 1211, 1240], [1242, 1242, 1272, 1272, 1351], [1353, 1589, 1618, 1618, 1776], [1778, 1778, 1865, 1865, 3062], [3064, 3305, 3349, 3349, 3564], [3566, 3566, 3589, 3589, 3633], [3637, 3637, 3669, 3669, 3996], [3998, 3998, 4030, 4030, 4145], [4147, 4147, 4187, 4187, 4308], [4310, 4496, 4554, 4554, 4810], [4812, 4812, 4876, 4876, 4934], [4936, 5067, 5103, 5103, 5218], [5220, 5220, 5265, 5265, 5360], [5362, 5362, 5397, 5397, 5514], [5516, 5516, 5560, 5560, 5657], [5659, 5785, 5826, 5826, 5854], [5856, 5856, 5895, 5895, 5924], [5926, 5926, 5957, 5957, 5984], [5986, 5986, 6019, 6019, 6046], [6048, 6048, 6107, 6107, 6199], [6201, 6201, 6263, 6263, 6597], [6599, 6775, 6818, 6818, 7105], [7107, 7278, 7307, 7307, 7504], [7506, 7687, 7716, 7716, 7878], [7880, 8091, 8104, 8104, 8404], [8410, 8410, 8423, 8423, 9602], [9604, 9840, 9853, 9853, 10599], [10601, 10601, 10623, 10623, 10757], [10759, 10945, 10964, 10964, 11053], [11055, 11055, 11079, 11079, 11271], [11273, 11564, 11598, 11598, 11853], [11855, 12201, 12246, 12246, 12705], [12707, 12963, 13015, 13015, 13184], [13186, 13186, 13227, 13227, 14664], [14666, 14847, 14888, 14888, 14965], [14967, 15309, 15364, 15364, 18302]]}
{"id": "3lVGD3", "name": "Spatial Folding", "author": "zovox", "description": "Spatial Folding", "tags": ["folding", "spatial"], "likes": 4, "viewed": 228, "published": "Public API", "date": "1580063819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*GR*E)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI/GR/E+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\nvec3 eye = vec3 (0.0);\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nfloat sdSphere( vec3 p, vec3 l, float s )\n{\n  return length(p-l)-s;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\n\nfloat dfScene(vec3 rp, vec3 rd) {\n    \n    float msd = 999999.0;\n    \n    float scale = GR;\n    \n    float numLayers = 4.;\n    float numBranches = 4.;\n    vec3 base = vec3(0., 0., 0.);\n    vec3 height = vec3(.75, .75, .75);\n    \n    vec3 po = rp;\n    \n    for(float branch = 0.0; branch < numBranches; branch += 1.)\n    {\n        rp = po;\n        float factor = 1.;\n        for(float layer = 0.0; layer < numLayers; layer += 1.)\n        {\n            vec3 p = rp;\n            float a = atan(p.z,p.x);\n            a = a/PI*.5+.5;\n            a = (saw(a*numBranches)*2.-1.)*PI;\n            float rots = saw(time)*4.;\n\n\n            rp = rotatePoint(p, vec3(0., 1., 0.), -a);\n            for(float branch = 0.0; branch < numBranches; branch += 1.)\n            {\n\n                msd = min(msd, sdSphere(p, base, 0.06*GR)*factor);\n                msd = min(msd, sdCapsule(p, base, base+height, 0.02*GR)*factor);\n                float a = atan(rp.z, rp.x);\n                p = rotatePoint(p, vec3(0., 1., 0.), PI*2./numBranches);\n            }\n            rp = (p-height)/height;\n            factor *= min(height.x, min(height.y, height.z));        \n            rp = rotatePoint(rp, vec3(0., 1., 0.), PI*2./numBranches+time*PI);\n        }\n        po = rotatePoint(po, vec3(0., 1., 0.), PI*2./numBranches);\n    }\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy, rd), d2 = dfScene(p - e.xyy, rd);\n\tfloat d3 = dfScene(p + e.yxy, rd), d4 = dfScene(p - e.yxy, rd);\n\tfloat d5 = dfScene(p + e.yyx, rd), d6 = dfScene(p - e.yyx, rd);\n\tfloat d = dfScene(p, rd) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos, rd)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 64; i++) {\n        rp = ro + rd * d;\n        eye = rp;\n        float ns = dfScene(rp, rd);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, GR, -PI);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    eye = ro;\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 1076, 1095, 1095, 1147], [1148, 1148, 1176, 1176, 1361], [1363, 1363, 1406, 1406, 1432], [1435, 1435, 1487, 1487, 1614], [1660, 1660, 1693, 1693, 2988], [2990, 2990, 3027, 3027, 3357], [3359, 3364, 3407, 3407, 3704], [3706, 3719, 3754, 3754, 4537], [4540, 4540, 4595, 4629, 5081]]}
{"id": "3lVGDG", "name": "Super Smile", "author": "tonywu", "description": "for test", "tags": ["test"], "likes": 1, "viewed": 208, "published": "Public API", "date": "1579751255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t){\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect){\n    return (uv - rect.xy)/(rect.zw - rect.xy);\n}\n\nvec4 Eye(vec2 uv){\n    uv -= 0.5;\n    \n    float d = length(uv);\n\t\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    \n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*0.5);\n    \n    col.rgb *= 1. - S(.45, .5, d)*0.5*sat(-uv.y-uv.x);\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d));\n    \n    col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d));\n    \n    float highlight = S(.1, .09, length(uv - vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv + vec2(-.08, .08)));\n    \n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    col.a = S(.5, .48, d);\n    \n     \n    return col;\n}\n\nvec4 Mouth(vec2 uv){\n\tuv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5+ abs(2.*cos(0.5*3.14*iTime));\n    uv.y -= uv.x * uv.x*2.; \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n     \n    td = length(uv+vec2(0., .5));\n    col.rgb =mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    float d = length(uv);\n    col.a = S(0.5, 0.49, d);\n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    \n    col.rgb *= 1. - edgeShade*.5;\n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(0.47, 0.48, d));\n    \n    float highlight = S(0.41, 0.405, d);\n    highlight *=remap(0.41, -.1, 0.75, 0., uv.y);\n    col.rgb = mix(col.rgb, vec3(1.0), highlight);\n    \n    \n    \n    d = length(uv - vec2(.25, -.2));\n    float cheek = S(0.2, 0.01, d)*0.4;\n    cheek *= S(0.17, 0.16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv){\n\tvec4 col = vec4(0.0);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(0.03, -.1, .37, .25)));\n    vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1)));\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = Smiley(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 141], [143, 143, 200, 200, 240], [242, 242, 274, 274, 323], [325, 325, 343, 343, 1016], [1018, 1018, 1038, 1038, 1489], [1491, 1491, 1510, 1510, 2118], [2120, 2120, 2141, 2141, 2457], [2460, 2460, 2517, 2567, 2807]]}
{"id": "3lVGRD", "name": "square square square", "author": "rocksdanister", "description": "square", "tags": ["square"], "likes": 3, "viewed": 81, "published": "Public", "date": "1578573414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//shader learning attempt #1: Some square animation.\nfloat Square2D(vec2 uv, float scale)\n{\n   vec2 bl = step( .05*scale ,min(uv,1.-uv));\n    return bl.x * bl.y;\n}\n\nfloat Square2DOutline(vec2 uv, float scale)\n{\n    uv = min(uv,1.-uv);\n    return smoothstep( .004 , 0., abs( min(uv.x,uv.y) - .05*scale ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat T =iTime*0.7;// fract(sin(iTime));\n    float anim = T;\n    //vec3 color = vec3(0.0);\n\n    uv = min(uv,1.-uv);\n    float i = round( ( anim +  min(uv.x,uv.y) / .05 ) *2. ) / 2.; \n    fragColor = vec4( Square2DOutline(uv, i - anim) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 91, 91, 163], [165, 165, 210, 210, 307], [309, 309, 366, 366, 647]]}
{"id": "3lVGRh", "name": "Cruz-v3", "author": "jorge2017a1", "description": "Cruz-v3", "tags": ["cruzv3"], "likes": 1, "viewed": 49, "published": "Public", "date": "1578280126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float pi = 3.141592653589793;\n\n\n\n\n///-------------------------------------------------\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n//-----------------------------------------------------\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///---------------------------------------------------\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba) - r;\n}\n\nfloat map(in vec3 p) \n{\n     float planeDist = p.y;\n    vec2 res;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    d=1000.0; \n    p.z=p.z+4.0;\n    \n    \n    \n     float theta = sin(iTime);\n    float c = cos(theta);\n    float s = sin(theta);\n    mat3 m = mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n        );\n    p = m * p;\n    \n    \n    \n  \n    \n    \n    d=min(d,planeDist);\n    \n    \n    //repetir\n   ///// p.x=mod(p.x,20.0) -6.0;\n    //////p.z=mod(p.z,30.0) -6.0;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,4.0,5.0),vec3(1.0,8.0,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,9.0,4.6),vec3(3.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,9.0,4.6),vec3(3.0,0.4,1.0));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,0.5,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.5,0.25,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    \n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    \n\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(-1.0, 1.0) * 0.01;\n    return normalize(\n            e.xyy * map(p + e.xyy) +\n            e.yxy * map(p + e.yxy) +\n            e.yyx * map(p + e.yyx) +\n            e.xxx * map(p + e.xxx)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(1.0);\n    \n    vec3 ro = vec3(0.0, 2.0, -10.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    //vec3 rd = vec3(p, 1.0);\n    \n    \n    float t = 0.0;\n    float h = 0.001 * 2.0;\n    float tmax = 20.0;\n    for(int i = 0; i < 60; i++) {\n        if(h < 0.001 || t > tmax) continue;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize(vec3(1.0));\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        float spe = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 32.0);\n        float fre = pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 3.0);\n        col *= (vec3(0.94, 0.66, 0.5) * dif + spe) * 0.9 + vec3(0.7, 0.2, 1.0) * fre * 0.5;\n        col = 0.9 * col + 0.1;\n    }\n    else {\n        col = vec3(0.5);\n    }\n    \n        fragColor = vec4(col,1.0);\n \t//= vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 95, 131, 131, 200], [202, 217, 248, 248, 398], [400, 457, 503, 503, 535], [537, 537, 579, 579, 611], [613, 613, 660, 660, 693], [696, 696, 725, 725, 851], [853, 908, 956, 956, 1059], [1061, 1061, 1111, 1111, 1240], [1242, 1242, 1265, 1265, 2621], [2623, 2623, 2651, 2651, 2869], [2871, 2871, 2928, 2928, 3947]]}
{"id": "3lVGWz", "name": "learn11", "author": "schlaffi", "description": "Using the tutorial> https://www.youtube.com/watch?v=zfcCHPeDOhU\nbased on> https://www.shadertoy.com/view/lt33z7 ", "tags": ["lemmepost"], "likes": 2, "viewed": 31, "published": "Public", "date": "1578684068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// shadertoy to gsls\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nint MAX_MARCHING_STEPS = 100;\nfloat MIN_DIST = 0.1;\nfloat MAX_DIST = 50.0;\nfloat EPSILON = 0.01;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 sp2 = samplePoint;\n    sp2.x = fract(sp2.x*0.5+1.0)/0.5-1.0;\n    sp2.z = fract(sp2.z*0.5+1.0)/0.5-1.0;\n    return length(sp2) - 0.4;\n}\n\nfloat lightSdf(vec3 samplePoint ) {\n    float l = length(samplePoint);\n    if ( l < 0.3 ) {\n    \treturn l+0.3;\n    } else {\n    \treturn l-0.3;\n    }\n}\n\n\nfloat planeSDF(vec3 sp) {\n\treturn abs(sp.y+cnoise(sp*5.0+iTime*vec3(0,1.0,0.0))*.5) ;\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \n    float stuff[10];\n    stuff[0] = lightSdf(samplePoint-light1Pos);\n    stuff[1] = lightSdf(samplePoint-light2Pos);\n    stuff[2] = sphereSDF(samplePoint);\n    stuff[3] = planeSDF(samplePoint);\n\n    float m=99999.0;\n    float mat=0.;\n    for(int i = 0; i<=3; i++) {\n        if( stuff[i] < m ) {\n            mat = float(i);\n            m = stuff[i];\n        }\n    }\n    \n    return vec2(m, mat);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 depth = vec2(start,0.);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth.x * marchingDirection);\n        if (dist[0] < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        depth.y=dist.y;\n        if (depth.x >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// light source material\nvec3 lightSource(vec3 lightColor, vec3 lightPos, vec3 p, vec3 eye){\n\treturn lightColor/pow(length(p-lightPos),1.0);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 light1Pos, vec3 light2Pos, vec3 light1Intensity, vec3 light2Intensity) {\n    vec3 color =  k_a;\n\n    \n    color = color + 10.*light1Intensity/pow(length(p-light1Pos),2.0);\n    color = color + 10.*light2Intensity/pow(length(p-light2Pos),2.0);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 1.5 , 9.0);\n    vec2 dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 initColor = vec3(uv, 1.0-uv.y);\n    vec3 color = initColor;\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n    } else {\n\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 p = eye + dist.x * dir;\n\n        vec3 K_a = vec3(0.5, 0.1, 0.1);\n        vec3 K_d = vec3(0.7, 0.5, 0.4);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 200.0;\n\t\t\n        vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \tvec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \tvec3 light1Intensity = vec3(1., 0.4, 0.1);\n    \tvec3 light2Intensity = vec3(0.0, 0.4, 0.4);\n        \n        if (dist.x>2.) {\n            if (dist.y==2.){\n                color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n            } else if (dist.y==3.) {\n                color = phongIllumination(vec3(0.0, 0., 0.), vec3(0.1, 0.1, 0.5), vec3(.5, .5, 1.), 50., p, eye, light1Pos, light2Pos, light1Intensity, light2Intensity);\n            } else if (dist.y==0.) {\n                color = lightSource(light1Intensity, light1Pos, p, eye);\n            } else if (dist.y==1.) {\n                color = lightSource(light2Intensity, light2Pos, p, eye);\n            }\n        }\n\n        color += estimateNormal(p)*0.2;\n    }\n\n\n    float foctor = fract(dist.x/MAX_DIST);\n    color = color*(1.0-foctor)+foctor*initColor;//vec3(1.,.9,.8)/;\n    \n    //color=vec3(fract(dist));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 519, 540, 540, 577], [578, 578, 605, 605, 653], [654, 654, 673, 673, 709], [711, 711, 732, 732, 3004], [3009, 3098, 3133, 3133, 3277], [3279, 3279, 3314, 3314, 3429], [3432, 3432, 3457, 3457, 3519], [3525, 3765, 3798, 3798, 4459], [4461, 4882, 4972, 4972, 5335], [5350, 5604, 5669, 5669, 5801], [5803, 5892, 5921, 5921, 6243], [6245, 6737, 6877, 6877, 7472], [7474, 7499, 7566, 7566, 7616], [7618, 7990, 8151, 8151, 8345], [8348, 8348, 8405, 8405, 10303]]}
{"id": "3lVGzm", "name": "eindacor_02", "author": "Eindacor_DS", "description": "moving bricks", "tags": ["bricks"], "likes": 2, "viewed": 77, "published": "Public", "date": "1578583564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// they're bricks, you dolt!\n\nfloat normalizeSin(float sinValue)\n{\n  \treturn (sinValue + 1.) / 2.;  \n}\n\nfloat floorSegment(float value, float segment)\n{\n    return floor(value / segment) * segment;\n}\n\nfloat ceilSegment(float value, float segment)  \n{\n    return ceil(value / segment) * segment;\n}\n\nfloat roundSegment(float value, float segment)\n{\n    return round(value / segment) * segment;\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 obscureColor(vec3 original, float factor)\n{\n    float seed = hash(vec2(original.r, factor)) * 2. - 1.;\n    float obscureCoeff = .1;\n    vec3 rgbAdjustmentCoeff = original * factor * obscureCoeff;\n    return original + rgbAdjustmentCoeff * ( 2.*seed-1. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    float aspectRatio =  iResolution.y / iResolution.x;\n    \n    // brickHeight indicates screenspace dimension\n    float brickHeight = .1;\n    float brickWidth = brickHeight * 3.39 * aspectRatio;\n    float colorRepeat = 20.;\n    \n    float timeScale = .15;\n    \n    uv.x += iTime * timeScale;\n    uv.y += normalizeSin(sin(iTime * timeScale)) * colorRepeat * brickHeight;\n    \n    float fractY = fract(uv.y / brickHeight);\n    \n    // calcs based on nominal brick dimensions\n    float mortarThickness = brickHeight * 1.25 / 3. / 2.25 / 2.;\n    float xThickness = mortarThickness * aspectRatio;\n    \n    bool evenRow = mod(floor(uv.y / brickHeight), 2.) == 0.; \n    \n    float repeatIncrementX = colorRepeat * brickWidth;\n    float repeatIncrementY = colorRepeat * brickHeight;\n    float xDist = evenRow ? uv.x + brickWidth / 2. : uv.x;\n    float shadeValue = .6;\n    vec3 mortarColor = vec3(.8);\n    \n    // horizontal mortar\n    if (abs(uv.y - round(uv.y / brickHeight) * brickHeight) < mortarThickness / 2.)\n    {   \n        col = mortarColor;\n        float floorSegY = floorSegment(uv.y, brickHeight);\n        if ((uv.y - floorSegY) < mortarThickness * .75)\n        {\n            if (xDist - floorSegment(xDist, brickWidth) < brickWidth - mortarThickness * aspectRatio)\n            {\n                col *= shadeValue; \n            }\n\t\t\telse // angled shadow\n            {\n                float deltaY = floorSegY + (mortarThickness / 2.) - uv.y;\n                float deltaX = (ceilSegment(xDist, brickWidth) - (xThickness / 2.) - xDist) / aspectRatio;\n                if (deltaY < deltaX)\n                {\n                    col *= shadeValue;\n                } \n            }\n    \t}\n    }\n    else // vertical mortar\n    {\n        // vertical mortar\n        if (abs(xDist - roundSegment(xDist, brickWidth)) < xThickness / 2.)\n        {\n            col = mortarColor;\n            float floorSegX = floorSegment(xDist, brickWidth);\n            if (xDist - floorSegX < xThickness / 2.)\n            {\n                if (ceilSegment(uv.y, brickHeight) - uv.y > mortarThickness)\n                {\n                    col *= shadeValue;\n                }\n                else // angled shadow\n                {\n                    float deltaY = ceilSegment(uv.y, brickHeight) - (mortarThickness / 2.) - uv.y;\n                    float deltaX = (floorSegX + (xThickness / 2.) - xDist) / aspectRatio;\n                    if (deltaY > deltaX)\n                    {\n                        col *= shadeValue;\n                    }                \n                }\n            }             \n        }\n        else\n        {\n            vec2 floored = vec2(floorSegment(xDist, brickWidth), floorSegment(uv.y, brickHeight));\n            \n            col = obscureColor(vec3(1., 156./255., 123./255.), hash(floored));\n            \n            // George's bricks\n            if (false)\n            {\n                float gVal = (fragCoord/iResolution.xy).x;\n                float dividedGVal = fract(gVal / .333);\n\n                vec3[] colors = vec3[](\n                    vec3(1.0, 0.0, 0.0), \t// red\n                    vec3(1.0, .5, 0.0), \t// orange\n                    vec3(1.0, 1.0, 0.), \t// yellow\n                    vec3(0.0, 1.0, 0.0), \t// green\n                    vec3(0.0, 1.0, 1.0), \t// blue\n                    vec3(1.0, 0.0, 1.0) \t// purple\n                );\n\n                int colorCount = 7;\n                float colorStep = 1. / float(colorCount);\n                for (int i=0; i<colorCount; i++)\n                {\n                    vec3 color1 = colors[i];\n                    vec3 color2 = (i == (colorCount - 1)) ? colors[2] : colors[i + 1];\n\n                    float leftSide = float(i) * colorStep;\n                    float rightSide = leftSide + colorStep;\n                    if (gVal < leftSide || gVal > rightSide)\n                        continue;\n\n                    float cVal = smoothstep(leftSide, leftSide + colorStep, gVal);\n\n                    if (cVal > 0.)\n                    {\n                        col = mix(color1, color2, cVal);\n                    }\n                } \n            }   \n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 66, 66, 102], [104, 104, 152, 152, 199], [201, 201, 250, 250, 296], [298, 298, 346, 346, 393], [395, 441, 461, 490, 743], [745, 745, 793, 793, 1006], [1008, 1008, 1065, 1115, 5376]]}
{"id": "3ly3D1", "name": "water tunnel fog", "author": "jojobavg", "description": "Procedural sea tunnel with big fog\nAfter around 30 seconds, there are more details because the \"color\" variable (bad named) adds some noise looks like subsurface.", "tags": ["procedural", "raymarching", "noise", "tunnel", "sea", "water"], "likes": 6, "viewed": 255, "published": "Public", "date": "1578775675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n// TDM for the getSkyColor function\n// https://www.shadertoy.com/view/Ms2SD1\n\n#define time iTime\n#define depth 20.0\n#define fogSize 10.0\n#define seuil 4.0\n#define steps 100.0\nfloat fogCoef=1.0/(depth-fogSize);\n\n\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat water(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tvec3 truc = vec3(p.x+sin(length(p*0.2)+time)*2.0,p.y+sin(length(p*0.2))*2.0,0.0);\n\tfloat coef = length(truc)-4.0;\n\n\tfloat c=1.0;\n\tfloat n1=1.0;\n        \n\tfloat d=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=2.0/c*abs(noise((p*c-time*2.0*d)*scale));\n\t\tc*=2.0;\n\t\td+=1.5;\n\t}\n\n\treturn n1*coef;\n\n}\n\nfloat mapHyper(vec3 p){\n\treturn water(p,vec3(0,0,0),0.3,0.1);\n}  \n\n\nvec3 tunnel(vec3 p){\n\tvec3 off=vec3(0);\n\toff.x += sin(p.z*0.2)*1.5;\n\toff.y += sin(p.z*0.3)*1.3;\n\treturn off;\n}\nvec3 getSkyColor(vec3 e) {\n\te.y = abs(e.y);\n\te.y = max(e.y,0.0);\n\treturn vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 s=vec3(-1.0,-1.0,-3);\n  float t2=(time*1.5);\n  s.xz *= rot(sin(t2)*0.015);\n \n  vec3 t=vec3(0,0,0);\n\ts -= tunnel(s);\n\tt -= tunnel(t);\n  s.x += cos(t2*0.2)*1.0*sin(time*0.01);\n  s.y += sin(t2*0.2)*1.0*sin(time*0.01+10.0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\n\tvec3 p=s;\n\n\tfloat c= 0.0;\n\tfloat color = 0.0;\n\tvec3 p2;\n\tbool hit = false;\n\tfor(int i=0; i<int(steps); ++i) \n\t{\n\t\tfloat truc;\n\t\ttruc = mapHyper(p);\n\t\tc =truc;    \n\t\tif( c>seuil )\n\t\t{\n\t\t\tcolor+=1.0;\n\t\t\n\t\t}\n\t\tp+=r*(truc-seuil)*0.09;\n        if(length(p-s)>depth){hit = false;break;}\nhit = true;\n\t}\n\tvec3 col=vec3(0);\n    float fresnel;\n    vec3 reflected;\nif (hit)\n{\n\tvec2 off=vec2(0.01,0.0);\n\tvec3 n=normalize(mapHyper(p)-vec3(mapHyper(p-off.xyy), mapHyper(p-off.yxy), mapHyper(p-off.yyx)));\n\tcol = mix(vec3(0.2,0.3,0.4),vec3(0.1,0.365,0.441),1.0-clamp(color,0.0,1.0));\n\n\t fresnel = clamp(1.0- dot(n,s), 0.05, 0.75);\n\t reflected = getSkyColor(reflect(r,normalize(n*0.5+vec3(0.0,1.0,0.0)*0.5)))*0.7;\n\tcol = mix(col,reflected,fresnel*reflected);\n    //col = vec3(spec);\n\n}else\n    col=vec3(0.95,0.95,0.95);//getSkyColor(r)*0.8;\n    float fog =  clamp((length(p-s)-fogSize)*fogCoef,0.0,1.0);\n    col = mix(col,vec3(0.85,0.85,0.85),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 336, 363, 363, 392], [395, 395, 419, 419, 1128], [1130, 1130, 1149, 1149, 1215], [1217, 1217, 1284, 1284, 1570], [1572, 1572, 1595, 1595, 1635], [1640, 1640, 1660, 1660, 1750], [1751, 1751, 1777, 1777, 1877], [1879, 1879, 1934, 1934, 3416]]}
{"id": "3ly3RV", "name": "color mix", "author": "henrybergstrom", "description": "Inspired by http://glslsandbox.com/e#49898.1", "tags": ["2d", "sin"], "likes": 3, "viewed": 148, "published": "Public", "date": "1579301840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.5 * (fragCoord.xy-0.5)/max(iResolution.x, iResolution.y);\n    vec2 mse = 0.3 * iMouse.xy/iResolution.xy - 0.3;\n    float speed = 20.0; \n    float t = iTime/100. * speed;\n    \n    //uv.x += uv.y * 0.4 * sin(t);    \n    //uv.y += uv.x * 0.4 * cos(t);\n\t//uv.x += sin(t);\n    \n\tfor(float i=1.0;i<10.;i+=1.)\n\t{\n\t\tvec2 newUv=uv;\n\t\tnewUv.x += mse.x/i*sin(i*i*uv.y+0.3*t)+1.0;\n\t\tnewUv.y += mse.y/i*sin(i*i*uv.x+0.3*(t+10.))-1.4;\n\t\tuv=newUv;\n\t}\n\tvec3 col= vec3(0.5 + sin(3.*uv.x)*.5,\n                   0.5 + sin(3.*uv.y)*.5,\n                   0.5 + sin(3.*(uv.x+uv.y)) *.5);\n\n    \n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 677]]}
{"id": "3ly3Wh", "name": "Hexagonal Game Board", "author": "exqt", "description": "Origin : https://comic.naver.com/challenge/detail.nhn?titleId=734597&no=16 (korean cartoon by hwang-han)\nUsed Template : https://www.shadertoy.com/view/3sSGWt (by BigWIngs)", "tags": ["hexagon", "tiling", "hexagonaltiling"], "likes": 15, "viewed": 249, "published": "Public", "date": "1578758435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Origin : https://comic.naver.com/challenge/detail.nhn?titleId=734597&no=16 (by hwang-han)\n// Used Template : https://www.shadertoy.com/view/3sSGWt (by BigWIngs)\n// Thanks to FabriceNeyret2 for giving me some advices\n\n#define V120        vec2(-1./2., sqrt(3.)/2.)\n#define V30         vec2(sqrt(3.)/2., -1./2.)\n#define TILE_WALL   vec4(.75, .44, .19, 1)\n#define TILE_GROUND vec4(.95, .87, .66, 1)\n#define S(v)        smoothstep(0.,10./R.y, v - .01)\n#define HexDist(p)  max(dot(abs(p), normalize(vec2(1.,sqrt(3.)))), abs(p).x)\n#define rand(n)     fract(sin(dot(n+vec2(12.3, 32.1), vec2(12.989, 4.1414))) * 123.321)\n\nvec4 HexCoords(vec2 uv) {\n    vec2 r = vec2(1, 1.73), \n         h = r*.5,\n         a = mod(uv  , r ) -h,\n         b = mod(uv-h, r ) -h,\n        gv = dot(a,a) < dot(b,b) ? a : b;\n    return vec4(gv, uv-gv);\n}\n\nvoid mainImage( out vec4 O,  vec2 u ) {\n    vec2 R = iResolution.xy, \n         U = 5.*( 2.*u - R ) / R.y;\n    U.y -= iTime;\n\n    vec4 hc = HexCoords(U);\n    float typ = rand(hc.zw), d,b;\n    vec2 t = hc.xy; \n\n    if(typ < .8) {\n        if(typ < .4) t.y *= -1.;\n        d = .5 - t.y/length(t);\n        t.x = abs(t.x);\n        b = S(abs(dot(V120, t)));\n        if(t.y < 0.) b *= S(t.x);\n    }\n    else {\n        if(typ > .9) t.y *= -1.;\n        d = abs(dot(V30, t)) - 1./sqrt(12.);\n        b = S(abs(d));\n    }\n    O = d>0. ? TILE_WALL : TILE_GROUND; \n    O *= S(.5-HexDist(t)) *b;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3Wh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[88, 704, 729, 729, 911], [913, 913, 952, 952, 1494]]}
{"id": "3ly3z3", "name": "kalamari", "author": "monsterkodi", "description": "kalamari", "tags": ["sdf"], "likes": 25, "viewed": 158, "published": "Public", "date": "1579646448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TOY  1\n\n#define MAX_STEPS 64\n#define MIN_DIST   0.01\n#define MAX_DIST  20.0\n#define SHADOW     0.1\n\n#define PI 3.1415926535897\n#define ZERO min(iFrame,0)\n\n#define NONE  0\n#define HEAD  1\n#define TAIL  2\n#define BULB  3\n#define PUPL  4\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nsdf s;\nint mat;\nbool soft;\nbool animat;\nvec3 camPos;\nvec3 camTgt;\nvec3 camDir;\n\nfloat aa = 0.0;\n\nvec3 v0 = vec3(0,0,0);\nvec3 vx = vec3(1,0,0);\nvec3 vy = vec3(0,1,0);\nvec3 vz = vec3(0,0,1);\n    \nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\nfloat gradientNoise(vec2 uv)\n{\n    return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715))));\n}\n\n// 0000000    000   0000000   000  000000000  \n// 000   000  000  000        000     000     \n// 000   000  000  000  0000  000     000     \n// 000   000  000  000   000  000     000     \n// 0000000    000   0000000   000     000     \n\nfloat digitBin(const int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat digit(vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces)\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = fValue < 0.0;\n    fValue = abs(fValue);\n    \n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if (fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if (fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {        \n            if (fDigitIndex == -1.0) {\n                if (fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if (fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = digitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n//  0000000   000   000   0000000   000000000  \n// 000   000  000   000  000   000     000     \n// 000 00 00  000   000  000000000     000     \n// 000 0000   000   000  000   000     000     \n//  00000 00   0000000   000   000     000     \n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    vec4 qr;\n    float half_angle = deg2rad(angle * 0.5);\n    qr.x = axis.x * sin(half_angle);\n    qr.y = axis.y * sin(half_angle);\n    qr.z = axis.z * sin(half_angle);\n    qr.w = cos(half_angle);\n    return qr;\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 quat, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\nvec3 rotate(vec4 quat, vec3 o, vec3 p)\n{\n    vec4 conj = quatConj(quat);\n    vec4 q_tmp = quatMul(quat, vec4(p-o, 0));\n    return o + quatMul(q_tmp, conj).xyz;\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{ \n    vec4 qr = quatAxisAngle(axis, angle);\n    vec4 qr_conj = quatConj(qr);\n    vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n    \n    vec4 q_tmp = quatMul(qr, q_pos);\n    qr = quatMul(q_tmp, qr_conj);\n    \n    return vec3(qr.x, qr.y, qr.z);\n}\n\nvec3 rotRayAngle(vec3 position, vec3 ro, vec3 rd, float angle)\n{ \n    return rotAxisAngle(position-ro, rd-ro, angle)+ro;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opUnion(float d1, float k, float d2) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opDiff(float d1, float k, float d2) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opInter(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\nfloat sdTetra(vec3 p, vec3 a, float s, float r)\n{\n    p = p - a;\n    vec3 c1 = vec3( 0, 1, 0);\n    vec3 c2 = vec3( 0.8165, -0.3333,  0.47140);\n    vec3 c3 = vec3( 0,      -0.3333, -0.94281);\n    vec3 c4 = vec3(-0.8165, -0.3333,  0.47140);\n    \n    c1 *= s;\n    c2 *= s;\n    c3 *= s;\n    c4 *= s;\n        \n    vec3 n1 = vec3( 0.0000,  0.3333,  0.942812);\n    vec3 n2 = vec3( 0.8165,  0.3333, -0.471400);\n    vec3 n3 = vec3( 0.0000, -1.0000,  0.000000);\n    vec3 n4 = vec3(-0.8165,  0.3333, -0.471400);\n    \n    float d = sdSphere(p,v0,2.0); \n    d = opDiff(d, r, sdPlane(p, c1, -n1));\n    d = opDiff(d, r, sdPlane(p, c2, -n2));\n    d = opDiff(d, r, sdPlane(p, c3, -n3));\n    d = opDiff(d, r, sdPlane(p, c4, -n4));\n  \n    return d;\n}\n\nfloat sdSocket(vec3 p, vec3 a, vec3 n, float r)\n{\n    return opDiff(opDiff(sdSphere(p, a, r), 0.2, sdPlane(p, a, -n)), 0.2, sdSphere(p, a, r-0.2));\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t, 0.0, 1.0);\n    vec3 c = a + t*ab;\n    return length(p-c)-(t*r2+(1.0-t)*r1);      \n}\n\n// 00000000  000   000  00000000  \n// 000        000 000   000       \n// 0000000     00000    0000000   \n// 000          000     000       \n// 00000000     000     00000000  \n\nvoid eye(vec3 pos, vec3 pupil, vec3 lens)\n{\n    float d = sdSphere(s.pos, pos, 0.4);\n    if (d > s.dist) return;\n    \n    d = opDiff(d, 0.05, sdSphere(s.pos, pupil, 0.2));\n\n    if (d < s.dist) { s.mat = BULB; s.dist = d; }\n    \n    d = min(d, sdSphere(s.pos, lens, 0.21));\n    \n    if (d < s.dist) { s.mat = PUPL; s.dist = d; }\n}\n\n//  0000000   00000000   00     00  \n// 000   000  000   000  000   000  \n// 000000000  0000000    000000000  \n// 000   000  000   000  000 0 000  \n// 000   000  000   000  000   000  \n\nvoid arm(vec3 pos, vec3 r, vec3 n, float aa)\n{\n    vec3 p = s.pos-pos;\n    \n    float d = 1000.0;\n    \n    d = min(d, sdSphere(p, v0, 0.25));\n    \n    n *= 0.3;\n    \n    vec3 p1 = v0;\n    vec3 p2 = p1 + n;\n    \n    float lf = 1.0;\n    float sf = 1.0;\n    float a  = -(1.0+aa)*17.0+4.5;\n    \n    for (int i = 0; i < 25; i++)\n    {\n        d = opUnion(d, sdCone(p, p1, p2, 0.2*sf, 0.2*sf*0.9));\n        p1 = p2;\n        n  = rotAxisAngle(n, r, a) * lf;\n        sf *= 0.9;\n        lf *= 0.988;\n        p2 += n;\n    }\n    \n    if (d < s.dist) { s.mat = TAIL; s.dist = d; }\n}\n\n// 000   000  00000000   0000000   0000000    \n// 000   000  000       000   000  000   000  \n// 000000000  0000000   000000000  000   000  \n// 000   000  000       000   000  000   000  \n// 000   000  00000000  000   000  0000000    \n\nvoid head(vec3 pos)\n{    \n    pos -= 0.3*vy*(aa+1.0);\n    \n    float d = sdTetra(s.pos, pos, 2.0, 0.7);\n    if (d < s.dist) { s.mat = HEAD; s.dist = d; }\n    \n    float ed = 0.8;\n    float pd = 0.4;\n    float ld = 0.2;\n    \n    vec3 left  = vec3( 0.8165,  0.3333, -0.471400);\n    vec3 right = vec3(-0.8165,  0.3333, -0.471400);\n    vec3 back  = vec3( 0.0000,  0.3333,  0.942812);\n    \n    float dpy = sdPlane(s.pos, pos, vy);\n    \n    vec3 eyel = pos + ed*left;\n    vec3 eyer = pos + ed*right;\n    vec3 eyeb = pos + ed*back;\n    \n    if (dpy > -.5)\n    {\n        float sr = 0.56;\n        d = opUnion(d, sdSocket(s.pos, eyel, left,  sr));\n        d = opUnion(d, sdSocket(s.pos, eyer, right, sr));\n        d = opUnion(d, sdSocket(s.pos, eyeb, back,  sr));\n    }\n        \n    float oo = 0.4;\n    float od = 0.8;\n    \n    vec3 arml = pos - od*vy - oo*left;\n    vec3 armr = pos - od*vy - oo*right;\n    vec3 armb = pos - od*vy - oo*back;\n    \n    vec3 armln = normalize(arml - 0.03*left  - vy);\n    vec3 armrn = normalize(armr - 0.03*right - vy);\n    vec3 armbn = normalize(armb - 0.03*back  - vy);\n    \n    if (dpy < 0.0)\n    {\n        d = opUnion(d, sdSocket(s.pos, arml, armln, 0.35));\n        d = opUnion(d, sdSocket(s.pos, armr, armrn, 0.35));\n        d = opUnion(d, sdSocket(s.pos, armb, armbn, 0.35));\n    }\n            \n    if (d < s.dist) { s.mat = HEAD; s.dist = d; }\n        \n    if (dpy > -.5)\n    {        \n        vec3 cp = camPos + 0.2*vec3(sin(iTime*5.5), -7.0*sin(iTime)*aa+sin(iTime*3.7), 0);\n        vec3 nl = normalize(cp - eyel);\n        vec3 nr = normalize(cp - eyer);\n        vec3 nb = normalize(cp - eyeb);\n        \n        eye(eyel, eyel + pd*nl, eyel + ld*nl);\n        eye(eyer, eyer + pd*nr, eyer + ld*nr);\n        eye(eyeb, eyeb + pd*nb, eyeb + ld*nb);\n    }\n        \n    if (dpy < 0.5)\n    {    \n        vec3 armlr = normalize(cross(arml, armln));\n        vec3 armrr = normalize(cross(armr, armrn));\n        vec3 armbr = normalize(cross(armb, armbn));\n            \n        float t = (aa+1.0)*15.0;\n        \n        if (animat) t *= -sin(iTime*PI-PI/4.0);\n        \n        armln = rotAxisAngle(armln, armlr, t);\n        armrn = rotAxisAngle(armrn, armrr, t);\n        armbn = rotAxisAngle(armbn, armbr, t);\n        \n        float dpl = sdPlane(s.pos, eyel, left);\n        float dpr = sdPlane(s.pos, eyer, right);\n        float dpb = sdPlane(s.pos, eyeb, back);\n        \n        if (dpl < -1.0) arm(arml, armlr, armln, aa);\n        if (dpb < -1.0) arm(armb, armbr, armbn, aa);\n        if (dpr < -1.0) arm(armr, armrr, armrn, aa);\n    }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n         \n    head(vec3(0,1,0));\n\n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    float shade = 1.;\n    float dist = .0035;    \n    vec3 rd = (lp-ro);\n    float end = max(length(rd), 0.001);\n    float stepDist = end/12.0;\n    rd /= end;\n    for (int i=0; i<12; i++)\n    {\n        float h = map(ro+rd*dist);\n        shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0001 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col)\n{\n    if (mat == NONE) return col;\n    \n    vec3 cr = cross(camDir, vec3(0,1,0));\n    vec3 up = normalize(cross(cr,camDir));\n    vec3 lp = 4.0 * (camPos + vec3(0,2.0*sin(iTime),0) + up*(5.0+cos(iTime*1.3)) + cr*2.0*sin(iTime*1.73)); \n    vec3 l = normalize(lp-p);\n \n    float ambient = 0.005;\n    float dif = clamp(dot(n,l), 0.0, 1.0);\n    \n    if (mat == PUPL || mat == TAIL)\n    {\n        dif = clamp(dot(n,normalize(mix(camPos,lp,0.1)-p)), 0.0, 1.0);\n        dif = mix(pow(dif, 16.0), 1.0*dif, 0.2);\n        dif += 1.0 - smoothstep(0.0, 0.2, dif);\n        if (mat == PUPL) ambient = 0.1;\n    }\n    else if (mat == BULB)\n    {\n        dif = mix(pow(dif, 32.0), 3.0*dif+1.0, 0.2);\n        ambient = 0.2;\n    }\n    else if (mat == HEAD)\n    {\n        float exp = soft ? 8.0 : 2.0;\n        float smx = soft ? 0.5 : 0.99;\n        \n        vec3  n2c = normalize(camPos-p);\n        vec3  bcl = normalize(n2c + l);\n        float dnh = clamp01(dot(n, bcl));\n        float shi = shiny(0.45, dnh, bcl);\n        \n        dif = clamp01(mix(pow(dif, exp), shi, smx));\n    }\n    \n    if (mat != PUPL && mat != BULB)\n    {\n        dif *= softShadow(p, lp, 4.0);        \n    }\n    \n    vec3 hl = vec3(pow(clamp01(smoothstep(0.9,1.0,dot(n, l))), 20.0));\n    \n    return col * clamp(dif, ambient, 1.0) + hl;\n}\n\n// 00000000   0000000    0000000   \n// 000       000   000  000        \n// 000000    000   000  000  0000  \n// 000       000   000  000   000  \n// 000        0000000    0000000   \n\nvec3 fog(vec3 col, vec3 bg, float dist)\n{\n    float f = smoothstep(5.0, 9.5, dist);\n    return mix(col, bg, f);\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    bool dither = true;\n    bool camrot = texelFetch(iChannel0, ivec2(KEY_RIGHT, 2), 0).x < 0.5;\n    bool water  = texelFetch(iChannel0, ivec2(KEY_LEFT,  2), 0).x < 0.5;\n    bool space  = texelFetch(iChannel0, ivec2(KEY_SPACE, 2), 0).x < 0.5;\n         soft   = texelFetch(iChannel0, ivec2(KEY_DOWN,  2), 0).x < 0.5;\n         animat = texelFetch(iChannel0, ivec2(KEY_UP,    2), 0).x < 0.5;\n        \n    if (animat) \n    {\n        float tt = 1.0-fract(iTime*0.5);\n        aa = cos(tt*tt*PI*2.0);  \n    }\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float md = 7.0;\n    float mx = 2.0*(iMouse.x/iResolution.x-0.5);\n    float my = 2.0*(iMouse.y/iResolution.y-0.5);\n    \n    if (iMouse.z <= 0.0 && camrot)\n    {\n        mx = iTime/16.;\n        my = -0.35*sin(iTime/8.);\n        dither = true;\n    }\n    \n    camTgt = vec3(0,-0.6,0); \n    camPos = rotAxisAngle(rotAxisAngle(vec3(0,0,md), vx, 89.0*my), vy, -180.0*mx);\n    \n    #ifndef TOY\n        if (space)\n        {\n            camTgt = iCenter;\n            camPos = iCamera;\n            camPos.x *= -1.0;\n            camTgt.x *= -1.0;\n        }\n    #endif\n    \n    camDir = normalize(camTgt-camPos);\n    \n    vec3 ww = normalize(camTgt-camPos);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n        \n    float ss, sc;\n    if (water) \n    {\n        ss = sin(iTime*1.5+2.0*PI*uv.x) * cos(iTime*0.5+20.0*uv.y);\n        sc = cos(iTime*0.5+2.0*PI*uv.y);\n    }\n    else\n    {\n        ss = 0.0;\n        sc = 0.0;\n    }\n    \n    uv.y+=ss*0.005; uv.x+=sc*0.01; // foreground wobble\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n\n    float d = rayMarch(camPos, rd);\n    mat = s.mat;\n    \n    uv.y+=ss*0.2; uv.x+=sc*0.4; // stronger bg wobble\n\n    vec3  p = camPos + d * rd;\n    vec3  n = getNormal(p);\n        \n    vec3 col;\n    \n    vec3 bg = vec3(.001, .001, .01) * clamp(1.0-1.0*length(uv), 0., 1.);\n    \n    if      (mat == HEAD)  col = vec3(0.23,0.23,1.0); \n    else if (mat == TAIL)  col = vec3(0.2,0.2,0.9); \n    else if (mat == PUPL)  col = vec3(0.1,0.1,0.5);\n    else if (mat == BULB)  col = vec3(1.0,1.0,1.0);\n    else if (mat == NONE)  \n    {        \n        col = bg;\n    }\n\n    col = getLight(p, n, col);\n    \n    if (mat != NONE)\n    {\n        col = fog(col, bg, d);\n    }\n    \n    if (dither)\n    {\n        float dit = gradientNoise(fragCoord.xy);\n        col += vec3(dit/10000.0);\n    }\n    \n    #ifndef TOY\n    vec2  fontSize = vec2(20.0, 35.0);  \n    float isDigit = digit(fragCoord / fontSize, iFrameRate, 2.0, 0.0);\n    col = mix( col, vec3(1.0, 1.0, 1.0), isDigit);\n    #endif\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ly3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 546, 570, 570, 595], [596, 596, 620, 620, 645], [647, 647, 669, 669, 796], [798, 798, 822, 822, 851], [853, 853, 883, 883, 962], [964, 1200, 1229, 1229, 1387], [1389, 1389, 1476, 1476, 2612], [2614, 2855, 2899, 2899, 3114], [3116, 3116, 3139, 3139, 3183], [3187, 3187, 3219, 3219, 3546], [3548, 3548, 3580, 3580, 3695], [3697, 3697, 3737, 3737, 3858], [3860, 4046, 4104, 4104, 4360], [4362, 4362, 4426, 4426, 4484], [4486, 4617, 4653, 4653, 4768], [4770, 4770, 4815, 4815, 4910], [4912, 4912, 4947, 4947, 5064], [5066, 5066, 5110, 5110, 5207], [5209, 5209, 5245, 5245, 5360], [5362, 5488, 5529, 5529, 5557], [5559, 5559, 5598, 5598, 5627], [5629, 5629, 5678, 5678, 6360], [6362, 6362, 6411, 6411, 6511], [6513, 6513, 6571, 6571, 6749], [6751, 6927, 6970, 6970, 7256], [7258, 7444, 7490, 7490, 8014], [8016, 8252, 8273, 8273, 10809], [10811, 10997, 11016, 11016, 11101], [11103, 11103, 11127, 11127, 11319], [11321, 11612, 11646, 11646, 11901], [11903, 12249, 12294, 12294, 12719], [12721, 12977, 13029, 13029, 13206], [13208, 13208, 13249, 13249, 14541], [14543, 14724, 14765, 14765, 14837], [14839, 15181, 15236, 15236, 17931]]}
{"id": "3lyGDd", "name": "Sunset Waves", "author": "peterbraden", "description": "Mix of other peoples work.", "tags": ["waves", "sunset", "rayleigh", "mie"], "likes": 8, "viewed": 229, "published": "Public", "date": "1580143133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// - rand sea from https://www.shadertoy.com/view/Ms2SD1\n// - various from https://github.com/erichlof/THREE.js-PathTracing-Renderer/blob/gh-pages/js/pathTracingCommon.js\n\nprecision mediump float;\nstruct Ray { vec3 origin; vec3 direction; };\n\n#define INFINITY         999.9e16\n#define PI               3.14159265358979323\n#define PHI              1.61803398874989484820459  // Golden Ratio   \n#define EARTH_RADIUS      6360000.0 // in m\n#define ATMOSPHERE_RADIUS 6420000.0 // in m\n#define SUN_POWER 20.0\n#define SKY_SAMPLES 16\n#define SUN_SAMPLES 8\n#define SUNTIME (iTime/2.0)\n#define EPSILON_NRM (0.1 / iResolution.x)\n    \nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\nconst int NUM_STEPS = 8;\n\nfloat hash( vec2 p ) {\n  return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);}\n\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(Ray ray, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ray.origin + ray.direction * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ray.origin + ray.direction * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ray.origin + ray.direction * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1){\n\tfloat discrim = b * b - 4.0 * a * c;\n\tif (discrim < 0.0) return false;\n\tfloat rootDiscrim = sqrt(discrim);\n\tfloat q = (b > 0.0) ? -0.5 * (b + rootDiscrim) : -0.5 * (b - rootDiscrim); \n\tt1 = q / a; \n\tt0 = c / q;\n\treturn true;\n}\n\nbool PlanetSphereIntersect( Ray ray, float rad, vec3 pos, inout float t0, inout float t1 ) {\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\t\n\tfloat temp;\n\tif (t0 > t1)\n\t{\n\t\ttemp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\treturn true;\n}\n\nvec3 calculateSkySphereColor(Ray r, float tmin, float tmax, vec3 sunDirection){ \n  vec3 earthCenter = vec3(0, -1.0 * EARTH_RADIUS, 0);\n\tvec3 betaR = vec3(3.8e-6, 13.5e-6, 33.1e-6); \n\tvec3 betaM = vec3(21e-6);  \n\tfloat Hr = 7994.0;\n\tfloat Hm = 1200.0;\n\tfloat t0, t1; \n\tif (!PlanetSphereIntersect(r, ATMOSPHERE_RADIUS, earthCenter, t0, t1) || t1 < 0.0) return vec3(0); \n\tif (t0 > tmin && t0 > 0.0) tmin = t0; \n\tif (t1 < tmax) tmax = t1; \n  float segmentLength = (tmax - tmin) / float(SKY_SAMPLES); \n\tfloat tCurrent = tmin; \n\tvec3 sumR = vec3(0); // rayleigh contribution\n\tvec3 sumM = vec3(0); // mie contribution \n\tfloat opticalDepthR = 0.0;\n\tfloat opticalDepthM = 0.0; \n\tfloat mu = dot(r.direction, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n\tfloat phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu); \n\tfloat g = 0.76; \n\tfloat phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g * g) * pow(max(0.0, 1.0 + g * g - 2.0 * g * mu), 1.5)); \n\n  for (int i = 0; i < SKY_SAMPLES; ++i) { \n\t\tvec3 samplePosition = r.origin + (tCurrent) * r.direction; \n\t\tfloat height = length(samplePosition - earthCenter) - EARTH_RADIUS; \n\n\t\t// compute optical depth for light\n\t\tfloat hr = exp(-height / Hr) * segmentLength; \n\t\tfloat hm = exp(-height / Hm) * segmentLength; \n\t\topticalDepthR += hr; \n\t\topticalDepthM += hm; \n\n\t\t// light optical depth\n\t\tfloat t0Light, t1Light; \n\t\tPlanetSphereIntersect(Ray(samplePosition, sunDirection), ATMOSPHERE_RADIUS, earthCenter, t0Light, t1Light); \n\t\tfloat segmentLengthLight = t1Light / float(SUN_SAMPLES);\n\t\tfloat tCurrentLight = 0.0; \n\t\tfloat opticalDepthLightR = 0.0;\n\t\tfloat opticalDepthLightM = 0.0; \n\t\tint jCounter = 0; \n    for (int j = 0; j < SUN_SAMPLES; ++j) { \n\t\t\tvec3 samplePositionLight = samplePosition + (tCurrentLight) * sunDirection; \n\t\t\tfloat heightLight = length(samplePositionLight - earthCenter) - EARTH_RADIUS; \n\t\t\tif (heightLight < 0.0) break;\n\t\t\tjCounter += 1;\n\t\t\topticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight; \n\t\t\topticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight; \n\t\t\ttCurrentLight += segmentLengthLight; \n\t\t} \n\t\tif (jCounter == SUN_SAMPLES) { \n\t\t\tvec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM); \n\t\t\tvec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z)); \n\t\t\tsumR += attenuation * hr; \n\t\t\tsumM += attenuation * hm; \n\t\t} \n\t\ttCurrent += segmentLength; \n  } \n\n  vec3 attenuate_vec = (sumR * betaR * phaseR + sumM * betaM * phaseM) * SUN_POWER;\n  //return attenuate_vec;\n  // color map\n  if (attenuate_vec.x < 1.413) { \n    attenuate_vec.x = pow(attenuate_vec.x * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.x = 1.0 - exp(-attenuate_vec.x);\n  } \n  if (attenuate_vec.y < 1.413){\n    attenuate_vec.y = pow(attenuate_vec.y * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.y = 1.0 - exp(-attenuate_vec.y);\n  } \n  if (attenuate_vec.z < 1.413){\n    attenuate_vec.z = pow(attenuate_vec.z * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.z = 1.0 - exp(-attenuate_vec.z);\n  }\n  return attenuate_vec;\n} \n\nvec3 calculateSkyColor(Ray r, float tmin, float tmax, vec3 sunDirection){\n  return calculateSkySphereColor(r, tmin, tmax, sunDirection);\n}\n\nvec3 perspectiveCameraRayDirection(in vec2 pixelCoord) {\n  vec2 pixelPos = (pixelCoord) * 2.0 - 1.0;\n  vec3 camRight   = vec3( 1.0,  0.0,  0.0);\n  vec3 camUp      = vec3( 0.0,  1.0,  0.0);\n  vec3 camForward = vec3(0.0, 0.0, 1.0);\n  return normalize( pixelPos.x * camRight + pixelPos.y * camUp + camForward );\n}\n\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = calculateSkyColor(Ray(vec3(0), reflect(eye,n)), 0.0, INFINITY, l);    \n    vec3 base = SEA_BASE * calculateSkyColor(Ray(vec3(0), vec3(1.0)), 0.0, INFINITY, l); // SEA_BASE\n    vec3 refracted = base + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.01, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    color += vec3(specular(n,l,eye,20.0))* 0.8 * reflected;\n    return color;\n}\n\nvec4 pixel(in vec2 uv ) {\n  Ray r = Ray( vec3(0.0, 3.0,  -15.0), perspectiveCameraRayDirection(uv));\n  vec3 sunDir = normalize(vec3(0,abs(cos(SUNTIME))/2.0 - 0.2, abs(sin(SUNTIME)) * 2.0));\n  vec3 sky = calculateSkyColor(r, 0.0, INFINITY, sunDir);\n  vec3 p;\n  heightMapTracing(r,p);\n  vec3 dist = p - r.origin;\n  vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n\n  vec3 waves = mix(\n        sky,\n        getSeaColor(p,n, sunDir, r.direction, dist),\n    \tpow(smoothstep(0.0,-0.5,r.direction.y),0.5));\n\n  return vec4(waves, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aa = 0.25 / iResolution.xy;\n  fragColor = pixel(uv); \n  fragColor += pixel(uv + aa);\n  fragColor *= 0.5;  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 967, 989, 989, 1058], [1059, 1059, 1085, 1085, 1385], [1388, 1388, 1429, 1429, 1600], [1602, 1602, 1621, 1621, 2059], [2061, 2061, 2089, 2089, 2527], [2529, 2529, 2564, 2564, 2755], [2757, 2757, 2802, 2802, 3365], [3367, 3367, 3405, 3405, 3447], [3448, 3448, 3494, 3494, 3594], [3597, 3597, 3672, 3672, 3900], [3902, 3902, 3994, 3994, 4295], [4297, 4297, 4376, 4376, 7437], [7440, 7440, 7513, 7513, 7578], [7580, 7580, 7636, 7636, 7890], [7893, 7893, 7956, 7956, 8587], [8589, 8589, 8614, 8614, 9120], [9122, 9122, 9178, 9178, 9337]]}
{"id": "3lyGRd", "name": "Republic of India Flag", "author": "piyushslayer", "description": "Couldn't really find any accurate depictions of the Indian flag here, so decided to lazily doodle one myself for this year's Republic day.", "tags": ["flag"], "likes": 19, "viewed": 3086, "published": "Public API", "date": "1579974383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n A very lazy and quick doodle of the Indian flag on this year's Indian Republic Day.\n Not the most efficient code, but I think it still looks cool. \n*/\n\n#define PI 3.1415926535\n\n#define ROT(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define ORANGE vec3(255., 154., 48.) / 255.\n#define GREEN vec3(9., 137, 1.) / 255.\n#define NAVY_BLUE vec3(0., 0., 137.) / 255.\n\n#define RADIUS .7\n#define HALF_RADIUS RADIUS * .5\n\n// Hash by Dave_Hoskins\nfloat hash(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) / float(0xffffffffU);\n}\n\n// iq's 2d sdf for iscosceles triangles (https://www.shadertoy.com/view/MldcD7)\nfloat isoscelesTriangle(in vec2 q, in vec2 p)\n{\n    p.y -= .5;\n    p.x = abs(p.x);\n    \n\tvec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0., 1.);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0., 1.), 1.);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n\treturn -sqrt(d.x) * sign(d.y);\n}\n\n// Probably not the best way to model the chakra, would have used the abs\n// mirroring technique to efficiently draw it, but since it's a lazy and quick\n// doodle so I said whatever, it doesn't matter either way.\nfloat getChakra(vec2 uv)\n{\n\tfloat outerCircle = smoothstep(.01, -.01, abs(length(uv) - RADIUS - .22) - .06);\n    float innerCircle = smoothstep(.22, .20, length(uv));\n    float spokes = 0., spokeThickness = .03, notches = 0., theta = 2. * PI / 24.;\n    for (int i = 0; i < 24; ++i)\n    {\n        vec2 suv = ROT(float(i) * theta) * uv;\n        // shorter inward pointing triangle\n        suv.y += HALF_RADIUS;\n        spokes += smoothstep(.015, -.015,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, RADIUS * .334), suv));\n        // longer outward pointing triangle\n        suv.y -= RADIUS + .0025;\n        spokes += smoothstep(.015, -.015,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, -RADIUS * .666), suv));\n        \n        // boundary notches\n\t\tvec2 nuv = ROT(float(i) * theta + theta * .5) * uv;\n        nuv.y -= RADIUS + .16;\n        notches += smoothstep(.04, .032, length(nuv));\n    }\n    \n    float chakra = notches + innerCircle + outerCircle + spokes;\n    return clamp(chakra, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 st = fragCoord / iResolution.xy;\n\tfloat w = sin((uv.x + uv.y - iTime * .75 + sin(1.5 * uv.x + 4.5 * uv.y) * PI * .3)\n                  * PI * .6); // fake waviness factor\n    \n    uv *= 1. + (.036 - .036 * w);\n    vec3 col = vec3(0.);\n    \n    // flag colors\n    col += 1.;\n    col = mix(col, ORANGE, smoothstep(.35, .36, uv.y));\n    col = mix(col, GREEN, smoothstep(-.35, -.36, uv.y));\n    col = mix(col, NAVY_BLUE, getChakra(uv * 3.2));\n    col += w * .225;\n    \n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y); // vignette\n\tcol *= 1. - .6 * exp2(-1.75 * v);\n    col = clamp(col - hash(fragCoord) * .004, 0., 1.);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 439, 459, 459, 599], [601, 681, 728, 728, 1064], [1066, 1279, 1305, 1305, 2272], [2275, 2275, 2332, 2332, 3087]]}
{"id": "3lyGRm", "name": "Dodecahedron Colored Sphere", "author": "novogrammer", "description": "Dodecahedron Colored Sphere", "tags": ["sphere", "dodecahedron"], "likes": 3, "viewed": 91, "published": "Public", "date": "1578475300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//rotate function from https://wgld.org/d/glsl/g017.html\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from -1 to 1\n    vec2 pos2d=( 2.*fragCoord - iResolution.xy )/iResolution.y;\n    \n    vec3 pos=vec3(pos2d,0.);\n    float length2dSquared=dot(pos2d,pos2d);\n    if(length2dSquared<=1.){\n        pos.z=sqrt(1.0-length2dSquared);\n    }else{\n        discard;\n    }\n    pos=rotate(pos,iTime,vec3(0.,1.,0.));\n    \n    float t=(1.+sqrt(5.))/2.;\n    vec3 planes[12];\n    planes[0]=normalize(vec3(-1.,+t,0.));\n    planes[1]=normalize(vec3(+1.,+t,0.));\n    planes[2]=normalize(vec3(-1.,-t,0.));\n    planes[3]=normalize(vec3(+1.,-t,0.));\n\n    planes[4]=normalize(vec3(0.,-1.,+t));\n    planes[5]=normalize(vec3(0.,+1.,+t));\n    planes[6]=normalize(vec3(0.,-1.,-t));\n    planes[7]=normalize(vec3(0.,+1.,-t));\n    \n    planes[8]=normalize(vec3(+t,0.,-1.));\n    planes[9]=normalize(vec3(+t,0.,+1.));\n    planes[10]=normalize(vec3(-t,0.,-1.));\n    planes[11]=normalize(vec3(-t,0.,+1.));\n    \n    vec3 colorR=vec3(1.,0.,0.);\n    vec3 colorG=vec3(0.,1.,0.);\n    vec3 colorB=vec3(0.,0.,1.);\n    vec3 colorC=vec3(0.,1.,1.);\n    vec3 colorM=vec3(1.,0.,1.);\n    vec3 colorY=vec3(1.,1.,0.);\n    vec3 colors[12];\n    colors[0]=colorR;\n    colors[1]=colorG;\n    colors[2]=colorG;\n    colors[3]=colorR;\n\n    colors[4]=colorB;\n    colors[5]=colorC;\n    colors[6]=colorC;\n    colors[7]=colorB;\n\n    colors[8]=colorM;\n    colors[9]=colorY;\n    colors[10]=colorY;\n    colors[11]=colorM;\n    \n    int nearestIndex=0;\n    float nearestCos=-1.;\n    for(int i=0;i<12;i++){\n        float c=dot(pos,planes[i]);\n        if(nearestCos<c){\n            nearestIndex=i;\n            nearestCos=c;\n        }\n    }\n    fragColor=vec4(colors[nearestIndex]*nearestCos*nearestCos,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 101, 101, 530], [532, 532, 589, 608, 2238]]}
{"id": "3lyGWh", "name": "Learning Code [12]", "author": "ozu", "description": "rgb, circles, add", "tags": ["circles", "rgb", "add"], "likes": 2, "viewed": 63, "published": "Public", "date": "1578945657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Circle(vec2 uv, vec2 p,float r, float blur, vec3 c){\n    \n    float d = length(uv - p);    \n    d = smoothstep(blur, 0., d -r);\n    \n    \n    vec3 col = vec3(d*c.r, d*c.g, d*c.b);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 p = vec2(0., 0.);\n    float offset = .125 * (sin(iTime)*.5+.5);\n    vec3 c = Circle(uv, p, 0.3, 0.004, vec3(1., 0., 0.));\n    c += Circle(uv, vec2(p.x - offset, p.y), 0.3, 0.004, vec3(0., 1., 0.));\n    c += Circle(uv, vec2(p.x + offset, p.y), 0.3, 0.004, vec3(0., 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 202], [204, 204, 261, 311, 754]]}
{"id": "3lyGWV", "name": "Blue spheres 1", "author": "valsag", "description": "And old shader I did just for fun a while ago. Decided to clean it up a bit and shared. Still far from optimal and has some lighting artifacts, but it looks pretty cool. Nothing special on the technical end, just the usual stuff.", "tags": ["sphere", "sonic"], "likes": 10, "viewed": 205, "published": "Public", "date": "1579828757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ZERO (min(iFrame,0))\n#define PI 3.1415926535898\n#define FAR 12.\n#define bg_color vec3(0.02,0.15,0.5)\n#define bg_color2 vec3(0.2,0.35,0.5)\n\nfloat camYaw;\nvec3 camPos;\nvec2 global_uv;\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec3 get_background( vec3 pos )\n{\n    return mix( bg_color2, bg_color, global_uv.y * 2. + 0.5 );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 distortPos(in vec3 pos)\n{\n    vec3 p = pos;\n    float xx = (p - camPos).x;\n    float zz = (p - camPos).z;\n    float xxx = -(cos(camYaw)*zz-sin(camYaw)*xx);\n    float zzz = -(cos(camYaw)*xx+sin(camYaw)*zz);\n    float cx = cos(xxx * 0.3 ) * 1.1;\n    if (cx < 0.0) cx *= 2.0;\n    float cz = cos((zzz + 3.0)* 0.3 ) * 1.1;\n    if (cz < 0.0) cz *= 1.5;\n    p.y -= cx + cz;\n    return p;\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 p = distortPos(pos);\n    vec2 res;\n\n    res.x = FAR; // distance\n    res.y = 0.0; // material id\n\n    // floor plane\n    if(p.y > 0.0) res = vec2(min(FAR, p.y), 1.);\n\n    vec3 sPos;\n    // blue spheres\n    sPos.x = mod(p.x - 0.5, 2.0) -0.5;\n    sPos.y = p.y - 0.15;\n    sPos.z = mod(p.z - 0.5, 4.0) - 0.5;\n    float d2 = sdSphere(sPos, 0.15);\n    if (d2 < res.x) res = vec2(d2, 3.0);\n\n    // red spheres\n    sPos.x = mod(p.x - 1.5, 4.0) -0.5;\n    sPos.z = mod(p.z - 1.5, 1.0) - 0.5;\n    float d3 = sdSphere(sPos, 0.15);\n    if (d3 < res.x) res =vec2(d3, 4.0);\n\n    // white spheres\n    sPos.x = mod(p.x - 0.5, 2.0) -0.5;\n    sPos.z = mod(p.z - 1.5, 2.0) - 0.5;\n    float d4 = sdSphere(sPos, 0.15);\n    if (d4 < res.x) res = vec2(d4, 5.0);\n\n    return res;\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0);\n    return normalize(vec3(map(p + e.xyy).x-map(p - e.xyy).x,\n                          map(p + e.yxy).x-map(p - e.yxy).x,\n                          map(p + e.yyx).x-map(p - e.yyx).x));\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.0, dt;\n    vec2 r;\n    for(int i=0; i<128; i++){\n        r = map(ro + rd * t);\n        dt = r.x;\n        if(dt<0.002 || t>FAR){ break; }\n        t += dt * 0.8;\n    }\n    return vec2(t,r.y);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 star2d(in vec3 pos)\n{\n    // adapted from: http://pryme8.com/tag/glsl/\n    vec3 c = vec3(1.5,1.5,1.5);\n    vec2 offsetFix = vec2(1.,0.83);\n    float ss, tt, angle, r, a;\n    float starAngle = 2.*PI/5.;\n    vec3 p0 = 0.14*vec3(cos(0.),sin(0.), 0.);\n    vec3 p1 = 0.06*vec3(cos(starAngle/2.),sin(starAngle/2.), 0.);\n    vec3 d0 = p1 - p0;\n    vec3 d1;\n    vec3 p = distortPos(pos);\n    ss = mod(p.x,2.0) - offsetFix.x;\n    tt = (1. - mod(p.y,2.0)) - offsetFix.y;\n    angle = atan(ss, tt) + PI;\n    r = sqrt(ss*ss + tt*tt);\n    a = mod(angle, starAngle)/starAngle;\n    if (a >= 0.5){a = 1.0 - a;}\n    d1 = r*vec3(cos(a), sin(a), 0.) - p0;\n    float in_out = smoothstep(0., 0.001, cross(d0 , d1).z);\n    return mix(vec3(1.5), vec3(1.,0.,0.0), in_out); ;\n}\n\nvec3 lighting(vec3 rd, vec3 ro, vec3 pos, vec3 n, float matid)\n{\n    if ( matid < 1.0 ){\n        return get_background( pos );\n    }\n\n    float z = length(pos - ro);\n\n    vec3 mate = vec3(1.0);\n\n    float spe_factor = 3.0;\n    float fog_factor = 0.005;\n    float black_rim_factor = 1.0;\n\n    if (matid < 1.9)\n    {\n        mate = vec3(1.0,0.5,0.1) * (vec3(0.4) + vec3(checkersGradBox( vec2(pos.x, pos.z) ) ));\n        spe_factor = 0.05;\n        fog_factor = 0.002;\n        black_rim_factor = 0.0;\n    }\n    else if (matid < 3.9)\n    {\n        // blue spheres\n        mate = vec3(0.05,0.3,0.9);\n    }\n    else if (matid < 4.9){\n        // red spheres\n        mate = vec3(1.0,0.05,0.0);\n    }\n    else if (matid < 5.9)\n    {\n        // white spheres\n        mate = star2d(pos);\n    }\n\n    vec3 lp0 = camPos +  vec3(0.0, 1.0, -1.0);\n    vec3 ld0 = normalize(lp0 - pos);\n    float dif = max(0.0, dot(n, ld0));\n    vec3 lin = vec3(1.0);\n    float spe = max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 20.0));\n    float ao = get_ao(pos, n);\n    lin = 10.0 * vec3(1.0) * spe * spe_factor;\n    lin += (1.0 + dif) * ao;\n    lin = lin * 0.22 * mate;\n    vec3  lig = normalize( vec3(0.0, 1.0, 0.0) );\n    lin *= vec3(0.5) + calcSoftshadow( pos, lig,  0.05, 1.0 );\n    // extra black rim to mimic original game spheres shade\n    float black_rim = max(dot(n,-rd),0.);\n    black_rim += max(dot(n,vec3(0.,1.,0.)),0.);\n    black_rim *= black_rim;\n    black_rim = smoothstep(0.,0.6,black_rim);\n    lin = mix( lin, lin * (0.25+0.75*black_rim), black_rim_factor);\n    // fog\n    lin = mix( lin, get_background(pos), 1.-exp(-fog_factor*z*z));\n\n    return lin;\n}\n\nvec3 shade(vec3 ro, vec3 rd)\n{\n    vec3 col = get_background(camPos);\n    vec2 res = intersect(ro, rd);\n    if(res.x < FAR)\n    {\n        vec3 pos = ro + rd * res.x;\n        vec3 n = get_normal(pos);\n        col = lighting(rd,ro, pos, n, res.y);\n    }\n    return col;\n}\n\nvoid updateCamera( in vec2 fragCoord, out vec3 rayOrigin, out vec3 rayDirection )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/ iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    global_uv = uv;\n    float velocity = 1.25;\n\n    float t = iTime;\n\n    float xpos = 0.0;\n    xpos = sin(t * 0.5)*cos(t * 0.25) * 4.0;\n\n    float phase = t * 0.1;\n    vec3 ro = vec3(xpos, 3.25+0.75*cos(phase)*cos(phase), -t * velocity);\n    vec3 ta = ro + vec3( sin(phase), 0.85 - 0.25*sin(phase)*sin(phase) , cos(phase)*cos(phase));\n\n    float FOV = 1.0;\n    vec3 fwd = normalize(ro - ta);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt);\n    vec3 rd = fwd + FOV*(uv.x*rgt + uv.y*up);\n    camYaw = atan( fwd.z, fwd.x );\n    rd = normalize(rd);\n\n    rayOrigin = ro;\n    rayDirection = normalize(rd);\n\n    camPos = ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro, rd;\n    updateCamera( fragCoord, ro, rd );\n    vec3 col = shade(ro, rd);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 267, 303, 303, 449], [451, 451, 484, 484, 549], [551, 551, 586, 586, 610], [612, 612, 642, 642, 999], [1001, 1001, 1021, 1021, 1788], [1790, 1790, 1815, 1815, 2038], [2040, 2040, 2070, 2070, 2259], [2261, 2261, 2295, 2295, 2503], [2505, 2567, 2645, 2645, 2919], [2921, 2921, 2947, 2996, 3677], [3679, 3679, 3743, 3743, 5328], [5330, 5330, 5360, 5360, 5599], [5601, 5601, 5684, 5684, 6452], [6454, 6454, 6511, 6511, 6727]]}
{"id": "3lyGzc", "name": "barandal-test1", "author": "jorge2017a1", "description": "Usar el MOUSE para mover!!!", "tags": ["barandaltest1"], "likes": 1, "viewed": 45, "published": "Public", "date": "1579449144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 13);\n             \n         } \n     }\n   \n    \n     float numbar;\n    float anchoMat;\n    float numLuz;\n    float total;\n    float Luz;\n    float sdbfin;\n    \n    numbar=10.0;\n    anchoMat=0.25;\n    numLuz=numbar-1.0;\n    total=13.0;\n    Luz=(total-numbar*anchoMat)/numLuz;\n    \n    sdbfin=999.9;\n    \n    \n    \n    //horizontal\n    float sdbh1sup =sdBox(p-vec3(-total/2.0,6.0,0.0), vec3(total/2.0,0.25,0.25) );\n    float sdbh1inf =sdBox(p-vec3(-total/2.0,1.0,0.0), vec3(total/2.0,0.25,0.25) );\n    \n    //vertical\n    float sdbv1 =sdBox(p-vec3(-total-0.,0.0,0.0), vec3(0.25,6.5,0.25) ); //inicio\n    float sdbv2 =sdBox(p-vec3(total-0.,0.0,0.0), vec3(0.25,6.5,0.25) );  //fin\n    \n    \n    res =opU(res, vec2(sdbh1sup,8.0));\n    res =opU(res, vec2(sdbh1inf,8.0));\n    \n    \n    for(float ii=0.0; ii<numbar; ii++) \n    {\n        float sdbtmp1 =sdBox(p-vec3(-total+ (Luz+anchoMat)*(ii+0.0),3.5,0.0), vec3(anchoMat,3.0,0.25) ); //inicio\n        sdbfin=min(sdbfin,sdbtmp1);\n    }\n   \n    \n    res =opU(res, vec2(sdbfin,9.0));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,4.5,20.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1523, 1523, 1554, 1554, 1742], [1745, 1799, 1821, 1821, 3081], [3084, 3148, 3184, 3184, 3457], [3459, 3509, 3555, 3555, 3587], [3589, 3589, 3632, 3632, 3664], [3666, 3666, 3714, 3714, 3747], [3750, 3750, 3779, 3779, 3905], [3907, 3907, 3943, 3943, 4060], [4062, 4062, 4098, 4098, 4216], [4268, 4280, 4302, 4302, 4610], [4611, 4637, 4662, 4662, 4852], [4853, 4898, 4915, 4915, 4988], [4991, 5024, 5050, 5050, 5247], [5248, 5294, 5346, 5346, 5501], [5566, 5675, 5712, 5712, 5747], [5749, 5749, 5768, 5768, 5843], [5849, 5849, 5874, 5874, 7448], [7451, 7451, 7485, 7485, 7874], [7879, 7879, 7903, 7903, 8135], [8139, 8139, 8163, 8163, 8548], [8551, 8551, 8577, 8577, 8941], [8944, 8944, 8969, 8969, 8997], [8999, 8999, 9051, 9051, 9447], [9550, 9594, 9611, 9611, 9682], [9707, 9799, 9824, 9824, 10087], [10089, 10148, 10176, 10176, 12059], [12063, 12063, 12120, 12120, 13530]]}
{"id": "3t3GWl", "name": "Puma Stripe Logo", "author": "yasuo", "description": "Happy New Year!", "tags": ["puma"], "likes": 2, "viewed": 224, "published": "Public API", "date": "1577851679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define PI 3.14159265\n\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/wdGXzK\n// http://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.*fix;\n    p = vec2(cos(a), sin(a))*r;\n\n    return p;\n}\n\n// puma logo\nfloat dPumaLogo(vec3 p, float artifact) {\n    float y = 0.25;\n    // stripe\n    mat3 rot = matRotateX(radians(90.0));\n    float dstripe0 = sdCappedCylinder((p-vec3(0.0,1.0+y,0.0))*rot,1.0,0.1);\n    float dstripe1 = sdCappedCylinder((p-vec3(-1.15,1.0+y,0.0))*rot,1.0,0.2);\n    \n    mat3 rotZ = matRotateZ(radians(6.0));\n    vec3 bp = (p-vec3(-0.63,1.88+y,0.0));\n    \n    const float k = -1.0;\n    float c = cos(k*bp.x);\n    float s = sin(k*bp.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*bp.xy,bp.z);\n    \n    mat3 rotZ2 = matRotateZ(radians(3.5));\n    vec3 bp2 = (p-vec3(-0.85,1.87+y,0.0));\n    float sc = mix(1.5,0.77,smoothstep(-1.0,1.0,bp2.x));\n    bp2.y *= sc;    \n    \n    float dstripe2 = sdBox(q*rotZ,vec3(1.0,0.15,0.1))*0.6;\n    float dstripe3 = sdBox(bp2*rotZ2,vec3(1.0,0.15,0.1))*0.6;\n    \n    float dstripe = min(max(-p.y+1.3,max(-dstripe1,dstripe0 )),min(max(-p.x-0.5, dstripe2),dstripe3));\n    \n    // logo outline\n    p.x *= 0.55;\n    float doutline0 = sdCappedCylinder((p-vec3(-0.2,1.55+y,0.0))*rot,1.1,0.1)*artifact;\n    float doutline1 = sdCappedCylinder((p-vec3(-0.2,1.55+y,0.0))*rot,1.0,0.2)*artifact;\n    float doutline = max(-doutline1,doutline0);\n    return min(dstripe,doutline);\n}\n\nvec4 pumaLogo(vec3 p){\n    p.y -= iTime*5.0;\n    p.y = mod(p.y,10.0)-5.0;\n    p *=  matRotateY(radians(-90.0));\n    p*=0.8;\n    \n    \n    float dlogo = dPumaLogo(p,0.3);\n    \n    return vec4(vec3(1.0),dlogo*0.9);\n}\n\nfloat dTwoZeroX2(vec3 p) {\n    vec3 prevP = p;\n    p.x = mod(p.x,2.8)-1.4;\n    \n    vec3 twoPos = vec3(-0.7,0.0,0.0);\n    float dtwo = sdBox(p+twoPos,vec3(0.6,1.0,0.1));\n    float dtwo1 = sdBox(p+twoPos+vec3(-0.6,-0.4,0.0),vec3(0.8,0.25,0.2));\n    float dtwo2 = sdBox(p+twoPos+vec3(0.6,0.45,0.0),vec3(0.8,0.25,0.2));\n    float dresTwo = max(-dtwo2,max(-dtwo1,dtwo))*0.9;\n    \n    vec3 zeroPos = vec3(0.7,0.0,0.0);\n    float dzero = sdBox(p+zeroPos,vec3(0.6,1.0,0.1));\n    float dzero1 = sdBox(p+zeroPos,vec3(0.3,0.7,0.2));\n    float dresZero = max(-dzero1,dzero)*0.9;\n    \n    p = prevP;\n    \n    float dres = max(sdBox(p,vec3(2.8,2.0,0.3)),min(dresTwo,dresZero));\n    return dres*0.9;\n}\n\nfloat cubicInOut(float t) {\n    return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.xz = pModPolar(p.xz,10.0,1.0);\n    p.x -= 20.0;\n    \n    vec4 logo = pumaLogo(p);\n    \n    p = prevP;\n    float d2020 = dTwoZeroX2(p);\n    float dlogo = dPumaLogo(p+vec3(0.0,1.7,0.0),0.6);\n    \n    float animTime = mod(iTime,6.0);\n    float morphVal = 0.0;\n    morphVal += cubicInOut(animscene(animTime, 1.0, 1.0))*1.0;\n    morphVal -= cubicInOut(animscene(animTime, 3.0, 1.0))*1.0;\n    \n    vec4 logo2 = vec4(vec3(1.0),mix(dlogo,d2020,morphVal));\n    \n    vec4 model = combine(logo,logo2);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 bg(vec2 p){\n    vec3 col = .94*max(mix(vec3(0.0,0.5,0.0)+(.1-length(p)/3.),vec3(1),.1),0.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*-30.0));\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),20.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(bg(r.xy),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col = bg(uv);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3GWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 558, 594, 594, 636], [638, 638, 667, 667, 751], [753, 753, 805, 805, 912], [914, 986, 1046, 1046, 1266], [1268, 1281, 1322, 1322, 2495], [2497, 2497, 2519, 2519, 2711], [2713, 2713, 2739, 2739, 3400], [3402, 3402, 3429, 3429, 3515], [3517, 3629, 3676, 3676, 3717], [3719, 3719, 3741, 3741, 4283], [4285, 4285, 4318, 4318, 4571], [4573, 4573, 4597, 4597, 4798], [4800, 4800, 4834, 4834, 5148], [5150, 5150, 5193, 5193, 5496], [5498, 5498, 5521, 5521, 5922], [5924, 5924, 5966, 5966, 6161], [6163, 6163, 6179, 6179, 6277], [6279, 6279, 6336, 6336, 7132]]}
{"id": "3t3SR4", "name": "RayMarchJackBasic", "author": "JackSolace", "description": "simple example of sdf unions to create more complex shapes,\n\nBased on https://www.shadertoy.com/view/tdXGWr", "tags": ["ray", "sdf", "sphere", "cone", "diffuse", "march", "jack"], "likes": 3, "viewed": 58, "published": "Public", "date": "1580430761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Jan 2020\n//Basic Raymarch of a Jack\n//Based on https://www.shadertoy.com/view/tdXGWr\n\n\n//from the Sphere example\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n// Most Shadertoy users use these sd functions to define implicit volumes\n// I typically prefer more descriptive names in educational code but\n// IQ's code is so widely used on the site that I'm going to begin using functions here and there\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{\n    float jack_dist = sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.4,0.0,0.0), 0.1, 0.05 );\n\tjack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(-0.4,0.0,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.4,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,-0.4,0.0), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.4), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,-0.4), 0.1, 0.05 ));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.4,0.0,0.0),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(-0.4,0.0,0.0),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.0,0.0,0.4),0.1));\n    jack_dist = min(jack_dist,distance_from_sphere(p,vec3(0.0,0.0,-0.4),0.1));\n    \n    \n    \n    return jack_dist;\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) );  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //the bulk of this comes from https://www.shadertoy.com/view/tdXGWr\n    //Ive removed the Anti-Aliasing for simplicity and performance\n    \n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color\n    vec3 total = vec3(0.0);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.0; //max march depth\n    float t = 0.0;//current depth\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        float h = map_the_world(pos);\n        //if we hit something break\n        if( h<0.0001 || t>tmax ) break;\n        //step forward\n        t += h;\n    }\n        \n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {\n        vec3 pos = ray_origin + t*ray_direction;\n        vec3 normal = calculate_normal(pos);\n        float diffuse = clamp( dot(normal,ray_origin + vec3(0.2,0.0,0.0)), 0.0, 1.0 );\n        float ambient = 0.7 + 0.5*dot(normal,vec3(1.0,1.0,0.0));\n        color = vec3(0.2,0.3,0.4)*ambient + vec3(0.8,0.7,0.5)*diffuse*0.5;\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3SR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 125, 184, 184, 216], [218, 529, 553, 553, 572], [573, 573, 636, 700, 1287], [1290, 1464, 1496, 1496, 2422], [2425, 2474, 2512, 2512, 2777], [2779, 2779, 2836, 3004, 4519]]}
{"id": "3tcSz4", "name": "red mandelbrot", "author": "funnbot", "description": "mandelbrot shader because i can.", "tags": ["mandelbrot"], "likes": 0, "viewed": 48, "published": "Public", "date": "1580446407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 1000.0\n\n#define float highp float\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nbool absLessThan(vec2 c, float b) {\n\treturn c.x * c.x + c.y * c.y < b * b;\n}\n\nvec2 mandelbrot(vec2 c) {\n    float i = 0.;\n\tvec2 z = c;\n    while (++i < MAX_ITER && absLessThan(z, 2.0)) {\n    \tz = complexMul(z, z) + c;\n    }\n    \n    return vec2(i, z.x * z.x + z.y * z.y);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0/(iTime*iTime);\n    vec2 offset = 1.0-iMouse.xy/iResolution.xy*2.0;\n\t\n    vec4 w = vec4(-2.5, 1.0, -1.0, 1.0);\n    vec2 coord = vec2(map(fragCoord.x, 0.0, iResolution.x, w.x, w.y), \n                      map(fragCoord.y, 0.0, iResolution.y, w.z, w.w)) * zoom + offset;\n    \n    vec2 iter = mandelbrot(coord);\n    \n    // Time varying pixel color\n    vec3 col = vec3(iter/(MAX_ITER-800.0), 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 124, 124, 190], [192, 192, 225, 225, 287], [289, 289, 324, 324, 365], [367, 367, 392, 392, 562], [565, 565, 622, 622, 1095]]}
{"id": "3tG3Rm", "name": "Dimensional clock", "author": "nodo", "description": "https://cineshader.com/view/3tG3Rm", "tags": ["volume", "raymarch"], "likes": 2, "viewed": 5112, "published": "Public API", "date": "1580216545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define Time floor(iTime)*30.0\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\nfloat pmodid;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 4378.553);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n\nfloat rand(vec2 co){\n    float a = 52.9498;\n    float b = 48.213;\n    float c = 438.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nvec3 hsv(float h, float s, float v) {\n\tvec3 a = fract(h+vec3(0.,2.,1.)/3.)*6.-3.;\n\ta = clamp(abs(a)-1.,0.,1.)-1.;\n\ta = a*s +1.;\n\treturn a*v;\n}\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    pmodid = floor(a / n);\n    a = pmodid * n;\n    return p * rot(-a);\n}\n\nvec2 opI(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d2 : d1;\n}\n\nvec2 map(vec3 p){\n        \n    vec3 bp = p;    \n    vec3 pp = p;\n \n    float period = 5.0;\n    float v = floor(iTime/period)*period+smoothstep(0.2, 0.8,mod(iTime,period));\n    p.xz *= rot(pi*v);\n    \n    float period2 = 8.0;\n    v = floor(iTime/period2)*period2+smoothstep(0.2, 0.8,mod(iTime,period2));\n    p.yz *= rot(pi*v*2.0);\n    \n    \n    float f = fbm(bp * 0.2+iTime+0.001);\n    \n\n    bp.xy = pmod(bp.xy,40.0);\n  \n\n    bp.y -= 30.0;\n    vec2 bd = vec2(0.1 - length(bp) * 0.1+f*0.6,1.0);\n\n\n    for(int i = 0; i < 2;i++){\n        bp.y -= 6.0;\n\n        bp.xy *= rot(pi/20.0*float(i));\n    \tbd = opI(bd,vec2(0.1 - length(bp) * 0.1+f*0.6,1.0));\n    }\n    \n    \n    vec3 lp = p;\n    lp.xy *= rot(-Time/60.0);  \n    float f2 = fbm(lp * 0.1+iTime);\n    \n    \n    lp.y -= 10.;\n    vec2 longhand = vec2(0.1 - length(lp*vec3(1.5,0.3,1.0)) * 0.1 +f2,3.0);\n    \n    \n    vec3 sp = p;  \n    sp.xy *= rot(-Time/720.0);   \n    sp.y -= 6.;\n    vec2 shorthand = vec2(0.1 - length(sp*vec3(1.5,0.5,1.0)) * 0.1 +f2,3.0);\n    \n    \n    \n    p.xy = pmod(p.xy,12.0);\n    p.y -= 23.0;\n    vec2 dial = vec2(0.1 - length(p) * 0.1 + f*0.5,2.0);\n    \n    pmod(pp.xy,40.0);\n    \n    //return opI(opI(shorthand,longhand),bd);\n    return opI(opI(dial,opI(shorthand,longhand)),bd);\n}\n\n\n//https://www.shadertoy.com/view/WslGWl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ro = vec3(0.0,0.0,-45.0);\n    float screenZ = 1.0;\n    vec3 rd = normalize(vec3(uv,screenZ));\n\n    \n    // For raymarching const values.\n    const int sampleCount = 34;\n    const int sampleLightCount = 2;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 65.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 60.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    vec4 col = vec4(0.0);\n    \n    vec2 mat;\n    \n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n\n        \n        mat = map(p);\n        float density = mat.x;\n        \n        if (density > 0.0)\n        {\n\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            float Tl = 1.0;\n\n            vec3 lp = p;\n            \n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = map(lp).x;\n                \n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                lp += sun_direction * zstepl;\n            }\n            \n            float opaity = 50.0;\n            float k = opaity * tmp * T;            \n            \n            vec4 cloudColor = vec4(vec3(0.01,0.11,0.5),1.0);\n            \n            if(mat.y == 1.0){\n                cloudColor.rgb = hsv(pmodid/40.0,1.,1.5);           \n            }else if(mat.y == 3.0){\n                cloudColor.rgb = vec3(.0,.8,.9); \n                         \n            }else{\n                pmod(p.xy,12.0);\n                cloudColor.rgb = hsv(pmodid/12.0,1.0,1.8);                   \n            }\n            \n            vec4 col1 = cloudColor * k;\n                       \n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(.0, 0., .1, 1.0);\n            vec4 col2 = lightColor * kl;\n            \n            col += col1 + col2*3.0;\n        }\n        \n        p += rd * zstep;\n    }\n    \n    col.a *= 0.5;\n    \n    if(col.a == 0.0){\n        col.rgb = vec3(0.0);\n    }\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 252, 252, 291], [293, 320, 344, 344, 780], [783, 783, 803, 803, 970], [972, 1116, 1135, 1135, 1284], [1286, 1286, 1323, 1323, 1428], [1430, 1430, 1448, 1448, 1510], [1512, 1512, 1540, 1540, 1675], [1677, 1677, 1705, 1705, 1741], [1743, 1743, 1760, 1760, 2999], [3002, 3043, 3100, 3100, 5932]]}
{"id": "3tG3Wh", "name": "TransferWise logo raymarched", "author": "kow", "description": "Playing with shape extrusion and distortion of the TW logo. \n\n2D version of the logo: https://www.shadertoy.com/view/wtV3zW", "tags": ["raymarching", "logo", "transferwise"], "likes": 2, "viewed": 71, "published": "Public", "date": "1578959082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Used the scene from this shader\n// https://www.shadertoy.com/view/lsKcDD\n\n// make this 1 is your machine is too slow\n#define AA 1\n#define ENABLE_BENDING 1\n//\n#define LOGO 0.\n#define PLANE 1.\n\n//------------------------------------------------------------------\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nvec2 uniOp(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nconst int N = 12;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;\n    }\n\n    return s*sqrt(d);\n}\n\nfloat sdLogo(vec2 p) {\n    vec2 center = vec2(-.45, .75);\n    float scale = .75;\n    vec2 v0 = center - vec2(-0.127,0) * scale;\n    vec2 v1 = center - vec2(-0.295,0.262) * scale;\n    vec2 v2 = center - vec2(-0,0.524) * scale;\n    vec2 v3 = center - vec2(-0.51,0.524) * scale;\n    vec2 v4 = center - vec2(-0.558,0.419) * scale;\n    vec2 v5 = center - vec2(-0.277,0.419) * scale;\n    vec2 v6 = center - vec2(-0.447,0.261) * scale;\n    vec2 v7 = center - vec2(-0.348,0.105) * scale;\n    vec2 v8 = center - vec2(-0.812,0.105) * scale;\n    vec2 v9 = center - vec2(-0.404,1) * scale;\n    vec2 v10 = center - vec2(-0.544,1) * scale;\n    vec2 v11 = center - vec2(-1,0) * scale;\n\n    // add more points\n    vec2[] poly = vec2[](v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);\n\n\treturn sdPoly(poly, p);\n}\n\n//------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n#if ENABLE_BENDING == 1\n    float k = 2. * sin(iTime) * .15;\n#else\n    float k = 0.;\n#endif\n    float c = cos(k*pos.y);\n    float s = sin(k*pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy, pos.z);\n\n    vec2 logo = vec2(opExtrussion(q, sdLogo(q.xy), 0.05), LOGO);\n    vec2 plane = vec2(sdPlane(pos.xyz), PLANE);\n    return uniOp(plane, logo);\n}\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tvec2 h = map( ro + rd*t );\n        float y = h.x * h.x / (2.0 * ph);\n        float d = sqrt(h.x * h.x - y * y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h.x;\n\n        t += h.x;\n\n        if( res<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    vec2 m = vec2(0., 0.); // dist marched + material info\n\n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro + rd * t );\n        m.y = res.y;\n\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n    }\n\n    if( t > tmax ) t = -1.0;\n    m.x = t;\n    return m;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        vec2 d = map( pos + h*nor );\n        occ += (h - d.x)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\n    vec2 t = castRay(ro,rd);\n\n    if( t.x > -0.5 )\n    {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal( pos );      \n\t\tvec3 color = vec3(.14, .21, .3);\n        \n        if(t.y == LOGO) {\n        \tcolor = vec3(0., 0.72, 1.);\n        }\n\n        // key light\n        vec3  lig = normalize( vec3(-0.5, 0.2, 0.25) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) *\n                    calcSoftshadow( pos, lig, 0.01, 4.0 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = color * dif * .7;\n        col += spe * vec3(1.);\n\n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n        col += color * amb * .7 * occ * .25;\n\n        // fog\n        col *= exp( -0.03 * t.x * t.x * t.x );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 8.0 - sin(2.0 * iTime);\n    vec3 ro = vec3(cos(.58 * an), 1., .9 + sin(an));\n    vec3 ta = vec3(0.0, -.5, -3.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 265, 288, 288, 303], [305, 305, 335, 335, 370], [372, 372, 392, 392, 427], [429, 429, 488, 488, 584], [605, 605, 646, 646, 1187], [1189, 1189, 1211, 1211, 1975], [1977, 2047, 2070, 2070, 2432], [2434, 2504, 2582, 2582, 3009], [3011, 3011, 3043, 3043, 3248], [3250, 3250, 3290, 3290, 3961], [3963, 3963, 4005, 4005, 4265], [4267, 4267, 4306, 4306, 5293], [5295, 5295, 5347, 5347, 5524], [5526, 5526, 5583, 5597, 6435]]}
{"id": "3tG3zV", "name": "Joseph Albers 4", "author": "danamuise", "description": " This is a color experiment based on a popular painting by Joseph Albers, The Interaction of Color: \"we do not see colors as they really are. In our perception they alter one another.\" \nSpecial thanks to Patricio Vivo's The Book of Shaders.", "tags": ["illusion", "colortheory", "albers"], "likes": 1, "viewed": 1180, "published": "Public API", "date": "1579656766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float u_time;\n\nfloat rect(in vec2 st, in vec2 size){\n\tsize = 0.25-size*0.25;\n    vec2 uv = step(size,st*(1.0-st));\n\treturn uv.x*uv.y;\n}\n\nvec3 DrawBox(int i, vec2 uv, vec4 dim, vec3 col, float blend){\n\tvec3 colorBox = vec3(0.0);\n\n    if(uv.x>dim[0] && uv.x<dim[1] && uv.y>dim[2] && uv.y<dim[3] ) {\n        colorBox = col;\n    }\n    \n    vec3 blendBar = vec3(177.0/255., 162./255., 97./255.);\n\n     if(uv.x>dim[0] && uv.x<dim[1] && uv.y>-0.2 && uv.y<0.2 ){\n     \tcolorBox = mix(colorBox, blendBar, blend);\n\t}\n    \n    if(uv.x>dim[0]+0.1 && uv.x<dim[1]+0.1 && uv.y>-0.2 && uv.y<0.2 ){\n\n       colorBox = mix(colorBox, blendBar, .7);;\n    }\n    \n    if(uv.x>-9.0 && uv.x<dim[0]-1.0 && uv.y>-0.2 && uv.y<0.2 ){\n\n       colorBox = mix(colorBox, blendBar, .7);;\n    }\n    return colorBox; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // move center\n    \n    vec3 rectColor = vec3(1., abs(sin(iTime))/4.0, 0.0);\n\n    float rectHeight = 0.6;\n    float vOffset = 0.1;\n    float hOffset = 0.1;\n    int numRects = 8;\n\tvec4 dimArray [8];\n    float tempOffset = -0.55 + (sin(iTime)*.1);\n\n    //init rect dimentions array\n    for(int i=1; i<numRects-1; i++){\n\t    //vec4(L, R, T, B)\n    \tdimArray[i] = vec4 (tempOffset, tempOffset+hOffset, -0.35, 0.35);\n    \ttempOffset += hOffset*2.0;\n    }\n    \n    vec3 color = vec3(87.0/255.0, 106.0/255.0, 87.0/255.0);\n    float blend = 0.1/0.6;\n    float index = 0.0;\n    for(int i=0; i<numRects; i++){\n    \tcolor += DrawBox(i, uv, dimArray[i], rectColor, blend*index);\n    \tindex +=1.0;   \n    }    \n    vec3 col = mix(color, vec3(0.5, 0.0, 0.5), abs(sin(iTime))/4.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 60, 60, 143], [145, 145, 207, 207, 792], [794, 794, 851, 851, 1704]]}
{"id": "3tGGWw", "name": "Mandelbrot set zoom", "author": "n1nes", "description": "zooming in and out of the Mandelbrot set", "tags": ["2d", "fractal"], "likes": 3, "viewed": 85, "published": "Public", "date": "1579027928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Step 1: Definition of constants\n    const int maxIt = 1000;\n\tvec2 c = fragCoord/iResolution.xy;\t//complex number\n    vec2 zoomp = vec2(-0.9, 0.23);\n    //vec2 zoomp = vec2(0.0,0.0);\n\t\n    //Step 2: Setting window boundaries\n    float r = 500.0*(cos(iTime * 0.1 + 3.141592) + 1.0) / 2.0;\n    float zoomf = 1.0 / (r*r);\n\n    vec2 P1 = vec2(zoomp.x-2.0 * zoomf, zoomp.y-1.0 * zoomf);\n    vec2 P2 = vec2(zoomp.x+1.0 * zoomf, zoomp.y+1.0 * zoomf);\n    \n    //Step 3: Transforming c into new coordinate space\n    c.x = (P2.x - P1.x) * c.x + P1.x;\n    c.y = (P2.y - P1.y) * c.y + P1.y;\n\t\n\t//Step 4: Calculating limit of z\n    vec2 z = vec2(0.0,0.0);\n    int anzIt = 0;\n    for(int i = 0; i<maxIt; i++){\n        z = vec2((z.x * z.x - z.y * z.y), (z.x * z.y + z.x * z.y)) + c;\n        if (length(z)>1.9) {\n           anzIt = i;\t//number of iterations -> color\n        }\n    }\n    \n\t//Step 5: Checking whether c is an element of the Mandelbrot set\n    if(length(z) <= 2.0){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\t\t//color it black\n    }else{\n    \t//fragColor = vec4(1.0,1.0,1.0,1.0);\t//color it white\n        fragColor = vec4(\t(sin(float(anzIt))+1.0) / 2.0,\t\t\n\t\t\t\t\t\t\t(cos(float(anzIt))+1.0) / 2.0,\n\t\t\t\t\t\t\t(sin(float(anzIt)+2.0)+1.0) / 2.0,1.0);\n    }\t\t\t\t\t\t\t\t//color it depending on anzIt\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 92, 1344]]}
{"id": "3tK3RD", "name": "AA-maze-ing", "author": "spalmer", "description": "hacked my aa checker testbed to filter Fabrice's clever one-line maze.  It's not perfect, still WIP, but better than the unfiltered version!", "tags": ["antialias", "maze"], "likes": 3, "viewed": 116, "published": "Public", "date": "1578418495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// an antialiased ALU maze.\n// Fabrice Neyret's teensy golfed maze algorithm:\n// https://www.shadertoy.com/view/lt2cRR\n// I just put his maze on a 3d plane since I had some code handy.\n// https://www.shadertoy.com/view/3tVGRz\n\nfloat smoothGrid(float x, float s, float g, float w)\n{\n    return mix(x, s, exp2(-g / w));    \n}\n\n// it's not his exact macro, but changed to have less gaps\nfloat mazeFabrice(vec2 p)\n{\n\treturn mod(p[int(1e4*length(ceil(p/4.)))&1], 4.) >= 1. ? 0. : 1.;\n}\n\nfloat mazeFabriceAA(vec2 p)\n{\n    vec2 dx = dFdx(p), dy = dFdy(p);\n    // fine, I give up on analytically filtering this; I'm just gonna discretely filter it.\n    // at least to get the value to blend to along the edge.\n    // still shows some unwanted grid cell edges though. \n    // Probably blurs too much toward the horizon.\n    vec2 w = vec2(length(dx), length(dy)); //filterWidth2(p);\n    w = w + .0001;\n\tfloat x = mazeFabrice(p);\n\tfloat y = .25 * (mazeFabrice(p + dx*vec2( .5, 0.))\n                   + mazeFabrice(p + dx*vec2(-.5, 0.))\n                   + mazeFabrice(p + dy*vec2( 0., .5))\n                   + mazeFabrice(p + dy*vec2( 0.,-.5)));\n    y = mix(y, .2, min(1., length(w))); // rebalance due to scale of maze empty vs. walls ratio; maze has more empty than filled\n    vec2 f = fract(p);\n    float g = min(f.x * (1.-f.x), f.y * (1.-f.y)) * 4.; //1.; // parabola box?\n    return smoothGrid(x, y, .125 * g, length(w));\n}\n\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return mazeFabriceAA(uv);\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n    return mazeFabrice(uv);\n}\n\n\nconst float maxd = 850.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. : //maxd :\n    \trp.y / -rd.y;\n}\n\n// cs is a cosine,sine pair representing angle of rotation as unit spinor\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y;\n    // inlined rotation matrix 2x2 transforming v.\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n// there're so many ways to do this though.  at least it's not all inlined and undocumented.\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y; // Fabrice's aspect-correct signed uv trick :)  I like it!\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\nconst vec3 C1 = vec3(.5,.9,.8); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 C2 = vec3(0.,.2,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07f) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(fragCoord);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1., 0.);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.0; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = fragCoord.x - iMouse.x;\n    bool left = splits < 0.; //fragCoord.x < iMouse.x;\n    // depending on last mouse click, split screen between two different functions\n    float check = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    vec3 c = mix(C1, C2, check); // colorize\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c = mix(c, Csky, fog);\n    // green vertical line at split\n    c = mix(c, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    c = pow(c, vec3(1./2.2)); // to srgb gamma\n    // output to screen\n    fragColor = vec4(c, 1.);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 227, 281, 281, 323], [325, 384, 411, 411, 480], [482, 482, 511, 511, 1420], [1423, 1462, 1485, 1485, 1517], [1518, 1556, 1579, 1579, 1609], [1638, 1651, 1688, 1688, 1771], [1773, 1847, 1880, 1880, 2022], [2023, 2117, 2156, 2156, 2211], [2214, 2214, 2238, 2238, 2498], [2533, 2643, 2698, 2721, 3708]]}
{"id": "3tK3Rm", "name": "norm interpolated sphere ", "author": "kaji", "description": "test", "tags": ["imi202001"], "likes": 0, "viewed": 66, "published": "Public", "date": "1578549609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n#define PI 3.14159265359\n\nfloat euc(vec3 p, float e){\n    float scale = 1.0;\n    return scale * pow(pow(abs(p[0]),e)+pow(abs(p[1]),e)+pow(abs(p[2]),e),1.0/e) ;\n}\nfloat dist(vec3 p){\n    float max_p = 4.0;\n    float min_p = 0.2;\n    float t = (max_p-min_p)*(0.5*(sin(0.8*iTime)+1.0))+min_p;\n    return euc(p,t);\n}\nfloat ballSDF(vec3 p) {\n    return dist(p) - 1.;\n}\n\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        ballSDF(p + vec3(d, 0.0, 0.0)) - ballSDF(p + vec3(-d, 0.0, 0.0)),\n        ballSDF(p + vec3(0.0, d, 0.0)) - ballSDF(p + vec3(0.0, - d, 0.0)),\n        ballSDF(p + vec3(0.0, 0.0, d)) - ballSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\n\nmat3 euler(float h, float p, float r){\n    return mat3(\n        cos(r)*cos(h)-sin(r)*sin(p)*sin(h), -sin(r)*cos(p), cos(r)*sin(h)+sin(r)*sin(p)*cos(h),\n        sin(r)*cos(h)+cos(r)*sin(p)*sin(h), cos(r)*cos(p), sin(r)*sin(h)-cos(r)*sin(p)*cos(h),\n        -cos(p)*sin(h), sin(p), cos(p)*cos(h)\n    ); \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightPos = g *vec3(0.0, 1.0, 2.0);\n\n    // ray\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    ray = ray / dist(ray);\n    \n    // marching loop\n    // needs subpix sampling to cover sharp edges?\n    float hit_dist = 0.01;\n    vec3 rPos = cPos;\n    for(int i = 0; i < 1000; i++ ) {\n        rPos += ray * ballSDF(rPos);\n//        rPos += ray * hit_dist;\n//        if (abs(ballSDF(rPos)) < hit_dist){\n//           break;\n//        }\n    }\n    \n    // collision detection\n    if (abs(ballSDF(rPos)) < hit_dist) { //object\n        vec3 normal = gradSDF(rPos);\n        float diff = dot(normalize(lightPos - rPos), gradSDF(rPos));\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {    //background\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 76, 76, 184], [185, 185, 204, 204, 335], [336, 336, 359, 359, 386], [388, 388, 410, 410, 692], [694, 694, 732, 732, 996], [997, 997, 1052, 1077, 2267]]}
{"id": "3tK3W3", "name": "Heart Tree", "author": "zovox", "description": "Heart <3 the Heart Tree!!", "tags": ["tree", "heart"], "likes": 2, "viewed": 197, "published": "Public API", "date": "1580063685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)+.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    p.x = p.x*2.-1.;\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = sin(time*iteration)/PI-1.*PI/4.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(.5, 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n        map += (1.-smoothstep(0., .1, abs(p.x-.5)))*(1.-smoothstep(0.9, 1., abs(p.y)+.5));\n    }\n    fragColor = vec4(flux(map*PI), 1.0 )*clamp(map, 0., 1.)+clamp(1.-map, 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1894, 1894, 1985], [1986, 1986, 2043, 2043, 3496]]}
{"id": "3tK3WK", "name": "test laser", "author": "jojobavg", "description": "test laser", "tags": ["raymarching", "noise", "fog", "laser"], "likes": 21, "viewed": 322, "published": "Public", "date": "1580129291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using code from\n\n// Inigo Quilez for the primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n    const vec3 step = vec3(110.0, 241.0, 171.0);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n                        random(n + dot(step, vec3(1,0,0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,0))),\n                        random(n + dot(step, vec3(1,1,0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0,0,1))),\n                        random(n + dot(step, vec3(1,0,1))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0,1,1))),\n                        random(n + dot(step, vec3(1,1,1))),\n                        u.x),\n                u.y),\n            u.z);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere(in vec3 p, in vec2 uv) {\n  vec3 truc = vec3(p.x,p.y,0.0);\n  return length(truc)-1.0;\n}\n\nfloat fog(in vec3 p, vec3 centerPos, float scale,float radius ) {\n  \n  float x=(noise((p+(time*1.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float y=(noise((p+(time*1.0+5.0)*2.0)*0.2)*2.0-1.0)*15.0;\n  float z=(noise((p+(time*1.0+3.5)*2.0)*0.2)*2.0-1.0)*15.0;\n  p+=vec3(x,y,z);\n\treturn max((noise(p*scale)+noise(p*2.0*scale)*0.5+\n              noise(p*3.0*scale)*0.33+\n              noise(p*4.0*scale)*0.25)*0.4807,0.0)*5.0;\n}\n  \n\nfloat map(vec3 p, vec2 uv){\n  return sphere(p,uv);\n  }\n\n \nfloat mapHyper(vec3 p){ \n  return fog(p,vec3(0,0,0),0.5,0.1);\n  }  \n\n  \nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p){\nreturn udQuad(p,\n              vec3(5, 0, 100.0),\n              vec3(-5.0, 0, 100.0), \n              vec3(-5.0,   cos(time*0.35)*2.0, -100.0),\n              vec3(5.0,  cos(time*0.35)*2.0, -100.0));\n  }\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  vec3 s=vec3(0.0,0.0,-100.0);\n  vec3 t=vec3(0.0,0.0,0.0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n  vec3 p=s;\n float dd=0.0;\n  \n  vec3 col=vec3(0.0);\n//  float text1=mapHyper(p);\n  if(dd==500.0)col = vec3(0.0);\n  p=s;\n  dd=0.0;\n  vec2 c= vec2(0,0);\n  for(int i=0; i<1000; ++i) {\n    float d=map(p,uv);\n    float d2=map3(p);\n   float mH=mapHyper(p);\n    c+=vec2(pow(mH*0.06,2.0)*clamp(0.2-d2,0.0,1.0)*0.55+\n       pow(mH*clamp(cos((p.x+sin(p.x+time*100.0))*20.0),0.0,1.0),4.0)*0.007*clamp(0.05-d2,0.0,1.0)+mH*0.0004,0.0)+\n       pow(mH*0.06,2.0)*clamp(1.0-d2,0.0,1.0)*0.20;\n\n    if( d>0.0001 ){ break;}\n    p+=r*(0.1);\n    dd+=0.1;\n  }\n  \n \n  \n  col = mix(vec3(0,0,0),vec3(0.5,0.5,0.8),c.x);\n  \n  \n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 263, 290, 290, 322], [325, 325, 349, 349, 1366], [1368, 1368, 1387, 1387, 1456], [1458, 1458, 1495, 1495, 1557], [1559, 1559, 1624, 1624, 1970], [1975, 1975, 2002, 2002, 2029], [2033, 2033, 2056, 2056, 2098], [2105, 2105, 2130, 2130, 2149], [2151, 2151, 2207, 2207, 2852], [2854, 2854, 2873, 2873, 3075], [3079, 3079, 3134, 3134, 4118]]}
{"id": "3tK3WV", "name": "square pair", "author": "jes5199", "description": "donut blocks turning into aliasing artifacts", "tags": ["2d", "aliasing", "moire"], "likes": 3, "viewed": 99, "published": "Public", "date": "1579913356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv; // = ((120.0 + iTime) / 3.0) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n  \n    uv = vec2(0, 0.5 * 3.14159) + (vec2(0, iResolution.y / 2.0) - fragCoord.xy) / (iResolution.x / 3.14159 / 2.0);//) * iResolution.y / 2000.0;\n    \n    float r = 0.0 / 4.0 ; //mod(iTime / 100.0 + acos(-1.0) / 4.0, acos(-1.0)*2.0);\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    uv = uv * rot;\n    \n    float value = sin(uv.x) * sin(uv.y) * iTime * 6.0;\n    float color = sin(value) * 3.0;\n    //color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, high,1.0);\n    } else {\n      fragColor = vec4(high, high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 850]]}
{"id": "3tK3Wz", "name": "learn16", "author": "schlaffi", "description": "Using the tutorial> https://www.youtube.com/watch?v=zfcCHPeDOhU\nbased on> https://www.shadertoy.com/view/lt33z7 ", "tags": ["dwdwd"], "likes": 3, "viewed": 58, "published": "Public", "date": "1578684288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nint MAX_MARCHING_STEPS = 100;\nfloat MIN_DIST = 0.1;\nfloat MAX_DIST = 50.0;\nfloat EPSILON = 0.01;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 sp2 = samplePoint;\n    sp2.x = fract(sp2.x*0.5+1.0)/0.5-1.0;\n    sp2.z = fract(sp2.z*0.5+.5*(iTime))/0.5-1.0;\n    return length(sp2) - 0.4;\n}\n\nfloat lightSdf(vec3 samplePoint ) {\n    float l = length(samplePoint);\n    if ( l < 0.3 ) {\n    \treturn l+0.3;\n    } else {\n    \treturn l-0.3;\n    }\n}\n\n\nfloat planeSDF(vec3 sp) {\n\treturn abs(sp.y+cnoise(sp*5.0+iTime*vec3(0,1.0,0.0))/20.) ;\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \n    float stuff[10];\n    stuff[0] = lightSdf(samplePoint-light1Pos);\n    stuff[1] = lightSdf(samplePoint-light2Pos);\n    stuff[2] = sphereSDF(samplePoint);\n    stuff[3] = planeSDF(samplePoint);\n\n    float m=99999.0;\n    float mat=0.;\n    for(int i = 0; i<=3; i++) {\n        if( stuff[i] < m ) {\n            mat = float(i);\n            m = stuff[i];\n        }\n    }\n    \n    return vec2(m, mat);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 depth = vec2(start,0.);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth.x * marchingDirection);\n        if (dist[0] < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        depth.y=dist.y;\n        if (depth.x >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// light source material\nvec3 lightSource(vec3 lightColor, vec3 lightPos, vec3 p, vec3 eye){\n\treturn lightColor/pow(length(p-lightPos),1.0);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 light1Pos, vec3 light2Pos, vec3 light1Intensity, vec3 light2Intensity) {\n    vec3 color =  k_a;\n\n    \n    color = color + 10.*light1Intensity/pow(length(p-light1Pos),2.0);\n    color = color + 10.*light2Intensity/pow(length(p-light2Pos),2.0);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 1.5 , 9.0);\n    vec2 dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 initColor = vec3(uv, 1.0-uv.y);\n\n    vec3 color = initColor;\n\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n    } else {\n\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 p = eye + dist.x * dir;\n\n        vec3 K_a = vec3(0.5, 0.1, 0.1);\n        vec3 K_d = vec3(0.7, 0.5, 0.4);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 200.0;\n\t\t\n        vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \tvec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \tvec3 light1Intensity = vec3(1., 0.4, 0.1);\n    \tvec3 light2Intensity = vec3(0.0, 0.4, 0.4);\n        \n        //color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n        float f = fract(dist.x*1.1);\n        color=  mix(vec3(0.), mix( vec3(1., 0., 0.), mix(vec3(1., 1., 0.), vec3(1., 1., 1.),f*3.-2.), f*3.-1. ), f*3. );\n        /*\n        if (dist.y==2.){\n            color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n        } else if (dist.y==3.) {\n            color = phongIllumination(vec3(0.0, 0., 0.), vec3(0.1, 0.1, 0.5), vec3(.5, .5, 1.), 50., p, eye, light1Pos, light2Pos, light1Intensity, light2Intensity);\n        } else if (dist.y==0.) {\n            color = lightSource(light1Intensity, light1Pos, p, eye);\n        } else if (dist.y==1.) {\n            color = lightSource(light2Intensity, light2Pos, p, eye);\n        }*/\n\n        //color *= estimateNormal(p);\n    }\n\n\n    float foctor = fract(dist.x/MAX_DIST);\n    color = color*(1.0-foctor)+foctor*initColor;//vec3(1.,.9,.8)/;\n    \n    //color=vec3(fract(dist));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 500, 521, 521, 558], [559, 559, 586, 586, 634], [635, 635, 654, 654, 690], [692, 692, 713, 713, 2985], [2990, 3079, 3114, 3114, 3265], [3267, 3267, 3302, 3302, 3417], [3420, 3420, 3445, 3445, 3508], [3514, 3754, 3787, 3787, 4448], [4450, 4871, 4961, 4961, 5324], [5339, 5593, 5658, 5658, 5790], [5792, 5881, 5910, 5910, 6232], [6234, 6726, 6866, 6866, 7461], [7463, 7488, 7555, 7555, 7605], [7607, 7979, 8140, 8140, 8334], [8337, 8337, 8394, 8394, 10520]]}
{"id": "3tKGD3", "name": "3D Hypercube", "author": "zovox", "description": "3D Hypercube", "tags": ["3d", "hypercube"], "likes": 4, "viewed": 530, "published": "Public API", "date": "1580063417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR))*.25+.5))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\n\nfloat sphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    \n    vec3 oc = rp - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return 0.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return (t1-t0)/r;\n}\n\n\nfloat line(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,rp-a);\n    float e = dot(rp-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((rp+ray*t1)-(a+ray2*t2));\n    return dist > r || t2 < r || t2 > length(a-b)+r? 0.0 : 1.0-dist/r;\n}\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\n\nfloat dancer(vec3 p, vec3 rd) {\n    \nfloat t = mod(time,1.0);\nfloat s = sin(time)/PI/GR;\n\nvec3 lbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\nvec3 rbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\nvec3 lbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\nvec3 rbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\nvec3 ltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\nvec3 rtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\nvec3 ltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\nvec3 rtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n\nvec3 lbf_lbfi = mix(lbf,lbfi,t);\nvec3 ltf_ltfi = mix(ltf,ltfi,t);\nvec3 lbb_lbbi = mix(lbb,lbbi,t);\nvec3 ltb_ltbi = mix(ltb,ltbi,t);\n\nvec3 rbb_lbb = mix(rbb,lbb,t);\nvec3 rbf_lbf = mix(rbf,lbf,t);\nvec3 rtf_ltf = mix(rtf,ltf,t);\nvec3 rtb_ltb = mix(rtb,ltb,t);\n\nvec3 lbfi_rbfi = mix(lbfi,rbfi,t);\nvec3 lbbi_rbbi = mix(lbbi,rbbi,t);\nvec3 ltfi_rtfi = mix(ltfi,rtfi,t);\nvec3 ltbi_rtbi = mix(ltbi,rtbi,t);\n\nvec3 rbbi_rbb = mix(rbbi,rbb,t);\nvec3 rbfi_rbf = mix(rbfi,rbf,t);\nvec3 rtfi_rtf = mix(rtfi,rtf,t);\nvec3 rtbi_rtb = mix(rtbi,rtb,t);\n    \n    float d = 0.0;\n\n    float radius = .025;\n\t// outside\n\td += line(p,rd,lbf_lbfi,rbf_lbf,radius);\n\td += line(p,rd,lbb_lbbi,rbb_lbb,radius);\n\td += line(p,rd,ltf_ltfi,rtf_ltf,radius);\n\td += line(p,rd,ltb_ltbi,rtb_ltb,radius);\n\n\td += line(p,rd,lbf_lbfi,lbb_lbbi,radius);\n\td += line(p,rd,ltf_ltfi,ltb_ltbi,radius);\n\td += line(p,rd,lbf_lbfi,ltf_ltfi,radius);\n\td += line(p,rd,lbb_lbbi,ltb_ltbi,radius);\n\n\td += line(p,rd,rbf_lbf,rbb_lbb,radius);\n\td += line(p,rd,rtf_ltf,rtb_ltb,radius);\n\td += line(p,rd,rbf_lbf,rtf_ltf,radius);\n\td += line(p,rd,rbb_lbb,rtb_ltb,radius);\n\n    // inside\n\td += line(p,rd,lbfi_rbfi,lbbi_rbbi,radius);\n\td += line(p,rd,ltfi_rtfi,ltbi_rtbi,radius);\n\td += line(p,rd,lbfi_rbfi,ltfi_rtfi,radius);\n\td += line(p,rd,lbbi_rbbi,ltbi_rtbi,radius);\n\n\td += line(p,rd,lbbi_rbbi,rbbi_rbb,radius);\n\td += line(p,rd,lbfi_rbfi,rbfi_rbf,radius);\n\td += line(p,rd,ltfi_rtfi,rtfi_rtf,radius);\n\td += line(p,rd,ltbi_rtbi,rtbi_rtb,radius);\n\n\td += line(p,rd,rbfi_rbf,rtfi_rtf,radius);\n\td += line(p,rd,rbbi_rbb,rtbi_rtb,radius);\n\td += line(p,rd,rbfi_rbf,rbbi_rbb,radius);\n\td += line(p,rd,rtfi_rtf,rtbi_rtb,radius);\n\n    // connections\n\td += line(p,rd,rtbi_rtb,rtb_ltb,radius);\n\td += line(p,rd,rbfi_rbf,rbf_lbf,radius);\n\td += line(p,rd,rbbi_rbb,rbb_lbb,radius);\n\td += line(p,rd,rtfi_rtf,rtf_ltf,radius);\n\t\n\td += line(p,rd,ltfi_rtfi,ltf_ltfi,radius);\n\td += line(p,rd,ltbi_rtbi,ltb_ltbi,radius);\n\td += line(p,rd,lbfi_rbfi,lbf_lbfi,radius);\n\td += line(p,rd,lbbi_rbbi,lbb_lbbi,radius);\n\n    return d;\n}\n\nvec4 draw(vec3 ro, vec3 rd, vec2 uv0) {\n    float depth = dancer(ro, rd);\n    \n    float weight = clamp(depth, 0.0, 1.0);;\n    \n    return vec4(flux(depth+time*PI)*weight, weight);//clamp(+(1.0-weight)*sample, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //coordinate system\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = (uv0* 2.0 - 1.0)*vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    float t = time;\n    vec3 axis = rormal();//vec3(0.0, 1.0, 0.0);\n    \n    ro = rotatePoint(ro, axis, t);\n    rd = rotatePoint(rd, axis, t);\n    ro *= FAR/PI;\n    \n    fragColor = draw(ro, rd, uv0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 1046, 1096, 1096, 1659], [1662, 1662, 1717, 1717, 2220], [2358, 3397, 3428, 3428, 5835], [5837, 5837, 5876, 5876, 6059], [6062, 6062, 6117, 6146, 6567]]}
{"id": "3tKGWD", "name": "procedural topography thing", "author": "MickLH", "description": "Based on Jon's world generator tutorial:\nhttp://www.jgallant.com/procedurally-generating-wrapping-world-maps-in-unity-csharp-part-1/\n\nUses Makio64's noise function:\nhttps://www.shadertoy.com/view/Xd3GRf", "tags": ["procedural"], "likes": 2, "viewed": 311, "published": "Public API", "date": "1578968464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "lowp vec4 permute(in lowp vec4 x) {\n    vec4 z = mod(x*x*34.0+x,vec4(289.0));\n    z = mod(z*z*12.0 + x*z*23.0 + x*x*34.0,vec4(289.0));\n    return z;\n}\nlowp float snoise(in mediump vec3 v) {\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    float noise = 0.0, fac = 0.5, oct = 2.0;\n    for(int i=0;i<6;i++) {\n        noise += fac * snoise(vec3(pos*oct, iTime*0.05 + float(i)*257.0));\n        oct *= 2.0;\n        fac *= 0.5;\n    }\n    noise = smoothstep(0.0, 1.0, noise);\n    vec3 color = vec3(0.0, 0.0, 0.5);\n    if (noise > 0.2) color = vec3( 25.0,  25.0, 150.0) / 255.0;\n    if (noise > 0.4) color = vec3(240.0, 240.0,  64.0) / 255.0;\n    if (noise > 0.5) color = vec3( 50.0, 220.0,  20.0) / 255.0;\n    if (noise > 0.7) color = vec3( 16.0, 160.0,   0.0) / 255.0;\n    if (noise > 0.8) color = vec3(0.5);\n    if (noise > 0.9) color = vec3(1.0);\n    \n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1721, 1721, 1778, 1778, 2467]]}
{"id": "3tKGWh", "name": "capsula-test1", "author": "jorge2017a1", "description": "uso del mouse-----MOUSE", "tags": ["capsulatest1"], "likes": 2, "viewed": 84, "published": "Public", "date": "1578801600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n        \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            res=vec2(res.x, 5);\n                 } \n     }\n    \n   \n    float sdSp1 = sdSphere( p-vec3(0.+0.5*sin(iTime),3.0+cos(iTime),-5.), 0.5 );\n    float sdSp2 = sdSphere( p-vec3(0.+0.5*cos(iTime),3.0,-5.+cos(iTime)), 0.5 );\n    float sdSp3 = sdSphere( p-vec3(0.+1.5*cos(iTime),3.0+0.5*sin(iTime*cos(iTime*0.5)),-5.+2.5*cos(iTime)), 0.25 );\n\n    float sdcy1 =sdCylinder(  p.yzx, vec2(7.0,6.0) ) ;\n    float sdcy2 =sdCylinder(  p.yzx, vec2(5.85,6.78) ) ;\n   \n    \n    dif1 = differenceSDF(sdcy1,sdcy2);\n    \n    \n    res=opU(res, vec2(dif1,13.0) );\n    res=opU(res, vec2(sdSp1,8.0) );\n    res=opU(res, vec2(sdSp2,18.0) );\n    res=opU(res, vec2(sdSp3,19.0) );\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n\n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.1*cb2)*0.8;\n     case 15:\n     \t\t/*\n         \t\tvec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V, plane.color)*intensity; //地板色\n      \t\t*/\n        case 16:\n        \tvec3 p,rd,ro;\n        \tfloat dist;\n        \t\t\n        \t\tro= mObj.ro;\n                rd= mObj.rd;\n                dist =mObj.dist;\n        \t\t//dist =0.001;\n        \n        \t\tp =ro+rd*dist;\n                \n          \t\tvec3 sn =GetNormal(p);\n     \t\t\t// SECOND PASS - REFLECTED RAY\n    \t\t\tvec3 rdrf = reflect(-rd, sn);\n        \t\t//vec3 prf = (ro + rdrf * d); \n        \t\tvec3 prf = (ro + rdrf * dist); \n    \t\t\t//vec3 prf = (ro + rdrf * 0.01); \n    \t\t\tfloat difrf = GetLight(prf);\n        \t\treturn difrf*vec3(1.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,2.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1522, 1576, 1598, 1598, 2858], [2861, 2925, 2961, 2961, 3234], [3236, 3286, 3332, 3332, 3364], [3366, 3366, 3408, 3408, 3440], [3442, 3442, 3489, 3489, 3522], [3525, 3525, 3554, 3554, 3680], [3682, 3682, 3718, 3718, 3835], [3837, 3837, 3873, 3873, 3991], [4043, 4055, 4077, 4077, 4385], [4386, 4412, 4437, 4437, 4627], [4628, 4673, 4690, 4690, 4763], [4766, 4799, 4825, 4825, 5022], [5023, 5069, 5121, 5121, 5276], [5341, 5450, 5487, 5487, 5522], [5524, 5524, 5543, 5543, 5618], [5624, 5624, 5649, 5649, 6816], [6819, 6819, 6853, 6853, 7214], [7219, 7219, 7243, 7243, 7475], [7479, 7479, 7503, 7503, 7888], [7891, 7891, 7917, 7917, 8281], [8284, 8284, 8309, 8309, 8337], [8339, 8339, 8391, 8391, 8787], [8890, 8934, 8951, 8951, 9022], [9047, 9139, 9164, 9164, 9427], [9429, 9488, 9516, 9516, 12275], [12279, 12279, 12336, 12336, 13746]]}
{"id": "3tKGWm", "name": "Spinning spiral", "author": "dtsmio", "description": "spiral", "tags": ["spiral"], "likes": 7, "viewed": 83, "published": "Public", "date": "1579102339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec2 st = rotate(uv, PI * 8. * (-iTime / 8. + length(uv)));\n\n    float line1 = smoothstep(-0.25, 0.25, st.x);\n    float line2 = 1. - line1;\n\t\n    float h = 1.4 * smoothstep(-1., 1., sin(st.x * PI / 2. + 0.75 * PI));\n    h -= 1.4 * smoothstep(-1., 1., sin(st.x * PI / 2. + 0.25 * PI));\n    \n    vec3 c1 = vec3(0.8, 0.2, 0.3);\n    vec3 c2 = vec3(0.9, 0.92, 0.96);\n    \n    // how to create normal normal?\n    vec3 normal = normalize(vec3( uv.x, h, uv.y));\n    vec3 light = normalize(vec3(0.2 * sin(iTime/2.), 2.0, 1. * cos(iTime/2.)));\n    float shading = dot(normal, light) * 0.5;\n    shading += (1. - length(light.xz - uv) * 2.) * 0.4; \n\tfloat spec = smoothstep(0.46, 1., shading);\n    \n    col = 1.2 * max(0.2, shading) * (c1 * line1 + c2 * line2);\n    col += 2. * smoothstep(0.46, 1., shading);\n    col += 0.2 * smoothstep(0.4, 1., shading);\n    col += 0.1 * smoothstep(0.3, 1., shading);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 49, 49, 133], [136, 136, 193, 193, 1212]]}
{"id": "3tKGWR", "name": "Gabor/Phasor flow", "author": "FabriceNeyret2", "description": "Look of phasor/Gabor noise along a random divergence-free flow from Perlin noise.\nUsing convolution with hash grid instead of sparse convolution with random splats.\n( NB: time evolution is not physically correct: better change slowly )\nMouse.y tunes freq", "tags": ["noise", "perlin", "fluid", "flow", "field", "complex", "screenspace", "curlnoise", "stream", "fingerprint", "gabornoise", "phasornoise"], "likes": 24, "viewed": 593, "published": "Public API", "date": "1578672840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"flow by Perlin noise\"     https://shadertoy.com/view/Xl3Gzj\n//   and \"Moebius Spiral Gabor field\" https://shadertoy.com/view/wtt3RH\n// ( see also https://www.shadertoy.com/view/ldtSzn\n//            https://shadertoy.com/view/wtt3z8 \n//            https://shadertoy.com/view/wtcGRH )\n// see also: distance field variant https://www.shadertoy.com/view/WtK3DR\n\n// --- Gabor params & utils\n\nfloat F = 1.2;                     // frequency\n#define W 12.                      // filtering neighborhood\n#define N int(W*2.+0.)             // sampling = NxN   ( N=2W+1 but smaller may work )\n#define PI 3.14159\n#define TG 0.*iTime                // try 1\n#define CS(a)       vec2( cos(a+TG), sin(a+TG) )\n#define hash2(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n\n// --- flow params\n\n#define TF .2*iTime                // flow speed\nfloat S = 3.;                      // scaling of flow\n \n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\n//     (extended to 3D)\nvec3 hash( vec3 p )\n{\n\tp *= mat3( 127.1,311.7,-53.7,\n\t\t\t   269.5,183.3, 77.1,\n\t\t\t  -301.7, 27.3,215.3 );\n\n\treturn 2.*fract(sin(p)*43758.5453123) -1.;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n \n    return 2.*mix(\n              mix( mix( dot( hash( i + vec3(0,0,0) ), f - vec3(0,0,0) ), \n                        dot( hash( i + vec3(1,0,0) ), f - vec3(1,0,0) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,0) ), f - vec3(0,1,0) ), \n                        dot( hash( i + vec3(1,1,0) ), f - vec3(1,1,0) ), u.x), u.y),\n              mix( mix( dot( hash( i + vec3(0,0,1) ), f - vec3(0,0,1) ), \n                        dot( hash( i + vec3(1,0,1) ), f - vec3(1,0,1) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,1) ), f - vec3(0,1,1) ), \n                        dot( hash( i + vec3(1,1,1) ), f - vec3(1,1,1) ), u.x), u.y), u.z);\n}\n\nfloat Mnoise(vec3 U ) {\n    return noise(U);                      // base turbulence\n  //return -1. + 2.* (1.-abs(noise(U)));  // flame like\n  //return -1. + 2.* (abs(noise(U)));     // cloud like\n}\n\nfloat turb( vec2 U, float t )\n{ \tfloat f = 0., q=1., s=0.;\n\t\n    float m = 2.; \n // mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for (int i=0; i<2; i++) {\n      U -= t*vec2(.6,.2);\n      f += q*Mnoise( vec3(U,t) ); \n      s += q; \n      q /= 2.; U *= m; t *= 1.71;  // because of diff, we may rather use q/=4.;\n    }\n    return f/s; \n}\n// -----------------------------------------------\n\n// draw line segment\n#define L(a,b) O+= .3/R.y/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a )\n\n// === Gabor noise =============\n\nvec2 Gabor(vec2 U, vec2 V) {\n    vec2 P, v, s = vec2(0);\n    float T=0., K;    \n    for( int k = 0; k < N*N; k++) {            // Gabor noise: convolve with noise with K*oscill\n        P = vec2( k%N, k/N ) -  W;             // sample neighborhood ( W = float(N-1)/2. )\n      //v = CS( 2.*PI* hash2( U+P ));          // random complex signal\n      //v = cmul( v, CS(-F*dot(P,V)));         // mul by oscillator in main direction\n        v = CS( 2.*PI* hash2( U+P )            // random complex signal\n                - F* dot(P,V) );               // mul by oscillator in main direction\n        K = .5+.5*cos(PI*min(1.,length(P)/W)); // smoothing kernel\n        s += v * K;\n        T += K;\n    }\n    return s / T; \n}\n\n// ========================================================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R.y;\n    O -= O;\n                                        // --- generates flow\n\tfloat eps = 1e-3;\n    //U -= t*vec2(.3,.1);                      // translation (or do it per band)\n    \n    float n = turb(S*U,TF);                     // pure noise = stream\n \n                                               // flow = rot(stream) \n\tvec2  V = vec2( turb(S*U+vec2(0,-eps),TF) - turb(S*U+vec2(0,eps),TF),\n                    turb(S*U+vec2(eps,0),TF)  - turb(S*U+vec2(-eps,0),TF)\n                  )/ eps;\n    //V += vec2(3,0);                          // linearly combine other base flows\n    V /= R.y;\n    \n#if 0                                   // --- draw flow ( debug )\n  //O += pow(.5+.5*sin(100.*n),1./2.2); return;\n\tO = clamp(vec4(n,0,-n,0),0.,1.);           // draw stream value (note that curl = lapl(stream) so they are very similar)\n    S = R.y/10.;\n    vec2 p = floor(U*S+.5)/S, v;               // draw velocity vectors\n    L ( p-V*2., p+V*2.);  //O.rb = u-u;  \n    //return;\n#endif\n    O += .2*vec4(n,0,-n,0);                    // show stream ( for debug )\n \n    vec2 M = iMouse.xy;                 // --- draw Gabor/Phasor noise\n    if (length(M)>10.) F = .2+M.y/R.y*1.8; \n    V = normalize(V);  // direction only\n  //V *= R.y;          // variant: varying length\n#if 1\n    if (fract(iTime/3.8)>.5) V = vec2(-V.y,V.x); // normal field\n    vec2 s = Gabor(u -.5*R, V );\n    float T = \n         //   4.*length(s);                    // show contrast oscillations\n              .5+.5*normalize(s).x;            // phasor profile\n // T = pow( T, 1./2.2);                       // to sRGB\n    O += T;\n#else                                          // local grid\n    O.r = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n    V = vec2(-V.y,V.x); \n    O.g = .5+.5*normalize(Gabor(u -.5*R, V )).x;\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[986, 1096, 1117, 1117, 1247], [1249, 1249, 1272, 1272, 2000], [2002, 2002, 2025, 2025, 2200], [2202, 2202, 2233, 2233, 2536], [2699, 2733, 2761, 2761, 3447], [3449, 3510, 3548, 3548, 5391]]}
{"id": "3ttSzr", "name": "crumpledWave", "author": "nasana", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 24, "viewed": 17130, "published": "Public API", "date": "1580304104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n   \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  }\n    \n   vec3 col;\n   col.r  = uv.y - 0.1;\n   col.g = uv.y + 0.3;\n   col.b = uv.y + 0.95;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 416]]}
{"id": "3ttXRr", "name": "music color water", "author": "tonywu", "description": "color", "tags": ["fft"], "likes": 3, "viewed": 231, "published": "Public API", "date": "1580300182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6. * fragCoord/iResolution.xy;\n    \n        // the sound texture is 512x2\n    //int tx = int(uv.x*512.0);\n    int tx = 1;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    for(int n=1; n<8; n++){\n    \n        float i = float(n);\n        uv += vec2(.7 / i * sin(fft * i *uv.y + iTime*5. + 0.3 *i)+0.8, 0.4 / i * sin(uv.x*0.5 +iTime +0.3 * i *fft) +1.6);\n        \n    }\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(0.5 * sin(uv.x) +0.5, 0.5*sin(uv.y) + 0.5, sin(uv.x + uv.y)+0.5+wave);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 970]]}
{"id": "3tV3DR", "name": "cube raytrace debug", "author": "nabr", "description": "just playing around\n\nmouse = everything", "tags": ["cube", "raytrace", "box", "debug", "idontdodrugs", "wuerfel", "quader", "wannabebox"], "likes": 3, "viewed": 156, "published": "Public", "date": "1578698456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----------------------------------------------------\n// cube raytrace debug by nabr\n// https://www.shadertoy.com/view/3tV3DR\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n\n\n// -------- texture\nfloat f(vec2 pp)\n{\n    vec3 ht = smoothstep(0., 12., 1. - dot(pp, pp)) * vec3(pp, 10. * exp(1.25 * sin(.5 * iTime))),\n         n = 100. * normalize(-abs(ht) - vec3(0, 0, .91)), p = vec3(0);\n    float tm = .35 * iTime;\n    for (float i = 0.; i <= 7.; i++)\n    {\n        p = 20. * n + vec3(cos(tm + i - p.x) + cos(tm + i - p.y), sin(i - p.y) + cos(i + p.x), 1);\n        p.xy = n.yz + (cos(i) * p.xy + sin(i) * abs(vec2(p.y, -p.x)));\n    }\n    return dot(vec3(4, 6, -10), -p);\n}\nfloat tex(in vec2 p)\n{\n    float m = .5 / texture(iChannel0, vec2(0.3)).x; // music\n    // -------- kinda bump\n    const vec2 e = vec2(.0009, 0);\n    vec3 sn = normalize(vec3(f(p + e) - f(p - e), f(p + e.yx) - f(p - e.yx), -.25));\n    return clamp(dot(normalize(vec3(2. * p, m)), -sn), .05, .85);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R = iResolution.xy;\n    float _asp = ((min(iResolution.x/iResolution.y,iResolution.y/iResolution.x)));\n    float dc = max(0.,(abs(fract(U.x/_asp)-.5)-abs(fract(U.y/_asp)-.5))); //backtothe70seffect\n\n    O.xyz = dc + vec3(.2, 0.2, 0.25);\n    vec2 M = .2 * iTime + (6. * atan(iMouse.xy / R));\n    #define R3d(_a)(mat3(1,0,0,0,cos(_a.y),-sin(_a.y),0,sin(_a.y),cos(_a.y))*mat3(cos(_a.x),0,sin(_a.x),0,1,0,-sin(_a.x),0,cos(_a.x)))\n    vec3 o = R3d(M) * vec3(.001, .001, float( (fract(.1*iTime)<.5)?1.:-.25));\n    vec3 d = R3d(M) * vec3((U - .5 * R) / R.y, 1);\n    \n    // -------- box\n    // http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n    vec3 no = o * 1. / d;\n    vec3 k = .25 * abs(1. / d);\n    vec3 pin = (-k) - no, pot = k - no;\n    float tN = max(pin.x, max(pin.y, pin.z));\n    float tF = min(pot.x, min(pot.y, pot.z));\n    if (tN < tF)\n    {\n        vec3 pos = (o + tF * d);\n        vec3 n = /*sign(d) */ step(pot, pot.zxy) * step(pot, pot.yzx);\n        float tx = (abs(n.x * tex(pos.zy) + n.y * tex(pos.zx) + n.z * tex(pos.xy)));\n        // -------- shader box\n        O.xyz = sin(vec3(1.8, 2.4, 2.7) * tx * 2.25 + 2.) * 0.35 + 0.53;\n        O.xyz =(vec3(.7, .1, 0) * pow(dot(pos, vec3(-2, 1, -2)), 2.))//red lines\n            \t+ mix(O.xyz, vec3(.24, .36, .4), tx - 1.);\n    };\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3DR.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[326, 346, 364, 364, 821], [822, 822, 844, 844, 1120], [1122, 1122, 1161, 1161, 2474]]}
{"id": "3tV3Dz", "name": "dsCapsule Sponge", "author": "jorge2017a1", "description": "dsCapsule Sponge", "tags": ["dscapsulesponge"], "likes": 2, "viewed": 67, "published": "Public", "date": "1578691453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia 60442.0\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n  float distToCapsule = dsCapsule(vec3(-0.f,0.0f,0.f), vec3(2.f,1.f,0.1f), 1.f, p);    \n    \n    d=distToCapsule;\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 45, 45, 71], [73, 73, 102, 102, 188], [190, 190, 219, 219, 295], [298, 298, 380, 380, 611], [613, 788, 811, 811, 949], [952, 952, 974, 974, 1044], [1046, 1046, 1065, 1065, 1559], [1561, 1561, 1582, 1582, 1815], [1817, 1817, 1850, 1850, 2133], [2135, 2135, 2192, 2192, 2572]]}
{"id": "3tV3Rc", "name": "Ment for you", "author": "theepicsnail", "description": "https://www.youtube.com/watch?v=4UfEnhnHGhI\n", "tags": ["reproduction"], "likes": 2, "viewed": 70, "published": "Public", "date": "1579563209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WHITE vec3(1)\n#define PURPLE vec3(220, 190, 251)/255.\n#define PURPLE2 vec3(220, 189, 255)/255.\n#define PINK vec3(255, 204, 253)/255.\n#define S smoothstep\n\n#define SCALE 182.\n#define CX 325.\n#define CY 182.\n#define R0 (526.-CX)/SCALE\n#define R1 (537.-CX)/SCALE\n#define R2 (567.-CX)/SCALE\n#define R3 (591.-CX)/SCALE\n#define R4 (750.-CX)/SCALE\n\n#define PI 3.1415926\n#define TAU 2.*PI\n\nvec3 color = WHITE;\nvoid addColor(float amount, vec3 c) { color = mix(color, c, amount); }\n\nfloat triangleRepeat(float f) {return 1.-abs(1.-mod(f,2.));}\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rot(vec2 i, float a) {\n    vec2 cs = vec2(cos(a), sin(a));\n    return i*mat2(cs.x, -cs.y, cs.y, cs.x);\n}\n\nfloat[] rotateMask = float[] (\n    1.\n    // 0:00-0:20\n    // 0:20-0:40\n    // 0:40-1:00\n);\n\n\n\n// \t0:28 rotation starts\n// +37\n// \t1:05 bars enter\n// +18\n// \t1:23 bars exit, rotation stops\n// +28\n// \t1:51 rotation starts\n// +37\n// \t2:28 bars enter\n// +20\n// \t2:48 fade to white\n\n// Bars:\n// 65-83, 148-\n// :18\n\n// Rot:\n// 28-83, 111-\n// :55\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    uv /= min(iTime*2., 1.);\n    \n    float A = 1./iResolution.y; // aliasing size?\n\tfloat R = length(uv);\n    float T = atan(uv.y, uv.x)/PI;\n    float t;\n    float time = iTime;\n    \n    \n    t = T + time*.16;\n    float inner_pink_stripe = S(.45, .55, triangleRepeat(t*64.));\n\taddColor(S(R0-A, R0+A, R) * inner_pink_stripe, PINK);\n    \n    \n    t = T - time*.08;\n    float heart_t = (fract(t*12.-.5)-.5)/12.*PI;\n    vec2 heart_uv = vec2(cos(heart_t), sin(heart_t))*R;\n    vec2 heart_line_center = vec2(1.23, 0);\n    vec2 heart_line_delta = vec2(0.03, .03);\n    float r = .03;\n\theart_uv.y = abs(heart_uv.y);\n    float heart_mask = S(r+A,r-A,sdLine(heart_uv, \n                                              heart_line_center - heart_line_delta,\n                                              heart_line_center + heart_line_delta));\n\taddColor(S(R1-A, R1+A, R), PURPLE);\n\taddColor(S(R1-A, R1+A, R)*heart_mask, WHITE);\n    \n    t = T + time * .04 ;\n    float mask = abs(fract(t*16. - R*3. -.3)-.5);\n    mask = S(.25+A,.25-A,abs(mask));\n    addColor(S(R2-A, R2+A, R), PINK);\n    addColor(S(R2-A, R2+A, R)*mask, WHITE);\n    \n    \n    t = T - time*.08;\n    mask = abs(fract(t*24. + cos(R*2.)+.5)-.5);\n    mask = S(.2+A*4.,.2-A*4.,abs(mask));\n    addColor(S(R3-A, R3+A, R), PURPLE2);\n    addColor(S(R3-A, R3+A, R)*mask, WHITE);\n    \n    //addColor(S(.5-A, .5+A, abs(uv.y)), PINK);\n    \n    \n    addColor(S(R4-A, R4+A, R), WHITE);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 447, 447, 480], [482, 482, 513, 513, 542], [545, 545, 594, 594, 713], [715, 715, 742, 742, 824], [1137, 1168, 1225, 1225, 2775]]}
{"id": "3tV3zh", "name": "3d ray-union intersection", "author": "16807", "description": "Distance field to a CSG union of spheres. The code provides functions to calculate distance to any shape formed from constructive solid geometry, and works in both 2d and 3d. Click the screen to rotate.", "tags": ["raycasting", "csg", "analytic", "minimal"], "likes": 0, "viewed": 39, "published": "Public", "date": "1578286027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n\nFUNC(bool) try_distances_along_line_to_negation(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    if (!is_intersection1)\n    {\n      return false;\n    }\n    entrance = is_intersection2 || entrance1 < entrance2 ? entrance1 : max(exit2,     entrance1);\n    exit     = is_intersection2 || exit1     < exit2     ? exit1     : max(entrance2, exit1    );\n    return !is_intersection2 || entrance1 < entrance2 || exit2 < exit1;\n}\n\nFUNC(bool) try_distances_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    exit     = !is_intersection1 ? exit2     : !is_intersection2 ? exit1     : max(exit1,     exit2    );\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) try_distances_along_line_to_intersection(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = is_intersection1 && is_intersection2 ? max(entrance1, entrance2) : 0.f;\n    exit     = is_intersection1 && is_intersection2 ? min(exit1,     exit2    ) : 0.f;\n    return is_intersection1 && is_intersection2 && entrance < exit;\n}\n\n// 3D FUNCTIONS RETURNING MULTIPLE INTERSECTIONS / CLOSEST APPROACHES\nFUNC(bool) try_distances_along_3d_line_to_sphere(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    float xz = dot(B0-A0, A);\n    float z  = length(A0+A*xz - B0);\n    float y2  = r*r-z*z;\n    float dxr = sqrt(max(y2, 1e-10));\n    entrance = xz - dxr;\n    exit     = xz + dxr;\n    return y2 > 0.;\n}\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    //float intersect = sphIntersect(cameraPosition, ray, vec4(0.0, 0.0, 0.0, 1.0));\n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_to_sphere(view_origin, view_direction, vec3(0,0,0), 0.5f, a_in, a_out);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_to_sphere(view_origin, view_direction, vec3(0,0,0.5), 0.5f, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_line_to_union(a_hits,a_in,a_out, b_hits,b_in,b_out, c_in,c_out);\n    vec3  color = vec3(0);\n    if (c_hits)\n    {\n        color = vec3(c_in/3.f);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tV3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 363, 363, 692], [694, 694, 927, 927, 1190], [1192, 1192, 1432, 1432, 1676], [1678, 1748, 1886, 1886, 2088], [2090, 2090, 2140, 2140, 2768], [2770, 2770, 2827, 2827, 4059]]}
{"id": "3tVGDh", "name": "Escher Puddle", "author": "SSHantaram", "description": "This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'", "tags": ["raymarching", "reflection", "waves", "escher", "reproduction"], "likes": 12, "viewed": 347, "published": "Public API", "date": "1578908062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\n// and animate the scene. The rays are reflected off a displaced\n// plane  into the trees.\n\n// polynomial smooth min (k = 0.1);\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// the wave for each droplet is based on a simple cosine wave\n// the wave in attenuated by the sqared distace to the center\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\n// both the cosine wave and the rings are animated by offsets\n// time is looped in 25 second intervals\n// about the time for the rings to leave the field of view\nfloat waveDisplacement( vec3 p )\n{\n    // drop one\n    float dist = length(p.xz - vec2(-0.5, 6.0));\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop two\n    dist = length(p.xz - vec2(0.5, 5.5));\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    // drop three\n    dist = length(p.xz - vec2(-0.0, 5.0));\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\n    \n    return waves;\n}\n\n// plane with waves\nfloat sdPlane( vec3 p )\n{\n    float dist = p.y;\n    \n    // apply costly displacement only when close\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\n    \n    return dist;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// like capsule, but with different radii at each end\n// https://www.shadertoy.com/view/3lsSzf\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\n}\n\nfloat sdTree( vec3 p )\n{\n    // trunk\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\n    \n    // mirror x-axis\n    p.x = abs( p.x );\n    \n    // big branches\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\n    \n    // mirror z-axis\n    p.z = abs( p.z );\n    \n    // small branches\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\n    \n    // lang thin branches\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\n    \n    return dist;\n}\n\n// combined SDF for scene\n// water is handled seperately for optimization\nfloat map( vec3 p ) {\n   \t\n    // slight distortion of the space\n    // makes the trees look more organic\n    // this makes a big difference\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\n    \n    vec3 p1 = p;\n    \n\t// rotation matrix based on pythagorean tripel\n    p1 *= mat3( 4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, 4.0) / 5.0;\n    \n    float tree1 = sdTree(p1);\n    \n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\n   \t\n    // rotation matrix based on pythagorean tripel\n    p2 *= mat3(-4.0, 0.0, 3.0,\n                0.0, 5.0, 0.0,\n               -3.0, 0.0, -4.0) / 5.0;\n    \n    float tree2 = sdTree(p2);\n    \n    return min(tree1, tree2);\n}\n\n// optimized normal for water\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcWaterNormal( in vec3 pos)\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdPlane(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// get distance to the water surface\n// the water is close, only a few iterations are needed\n// this helps because the displacement is costly\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 10; i++) {\n        float d = sdPlane( eye + dist * ray_dir );\n        if ( d < 0.001) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 10.0 ) {\n            break;\n        }    \n    }\n    return dist;\n}\n\n// get distance to the trees\n// farplane is close to speed things up\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\n    float dist = 0.0;\n    for (int i = 0; i < 70; i++) {\n        float d = map( eye + dist * ray_dir );\n        if ( d < 0.001 * dist) {\n      \t\tbreak;\n        }\n        dist += d;\n        if ( dist > 18.0 ) {\n            break;\n        }\n        \n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv between -1 and 1 and fix aspect ratio\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // camera setup\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\n    \n    vec3 eye = vec3(3.0*sin(angle),\n                    1.6 + 0.2*(sin(iTime*0.23)),\n                    3.0*cos(angle));\n    \n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\n    \n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\n    vec3 view_dir = normalize( look_at - eye );\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\n    vec3 up = cross( view_dir, right );\n    float focal_dist = 5.0;\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\n    \n    // background color\n    vec3 col = vec3(0.5);\n    \n    // reflect ray at water surface\n    float dist = ray_march_water( eye, ray_dir );\n    vec3 p = eye + dist*ray_dir;\n    vec3 normal = calcWaterNormal( p );\n    ray_dir = reflect( ray_dir, normal );\n    \n    // raymarch the trees\n\tdist = ray_march( p + normal * 0.01, ray_dir );\n \n    // color trees black\n    if (dist < 18.0) col = vec3(0);\n    \n    // color moon white\n    // moon is at infinity\n    // render based on angle of the reflected ray\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 253, 299, 299, 385], [387, 741, 775, 791, 1453], [1455, 1475, 1500, 1500, 1655], [1657, 1732, 1784, 1784, 1898], [1900, 1995, 2070, 2070, 2212], [2214, 2214, 2238, 2251, 3204], [3206, 3280, 3301, 3420, 3968], [3970, 4064, 4100, 4100, 4637], [4639, 4781, 4830, 4830, 5095], [5097, 5166, 5209, 5209, 5482], [5484, 5484, 5541, 5593, 6861]]}
{"id": "3tVGDV", "name": "Delaunay triangulation", "author": "hiogawa", "description": "I thought it's fun to utilize \"In Circle Test\" signed volume to reduce sudden triangulation flip.", "tags": ["2d"], "likes": 9, "viewed": 643, "published": "Public API", "date": "1579928484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Delaunay triangulation\n//\n\n#define M_PI 3.14159\n\nfloat SCALE = 5.0;\nfloat SCALE_TIME = .3;\n\nfloat POINT_RADIUS = 3.0;\nfloat GRID_LINE_WIDTH = 1.0;\nfloat QUAD_EDGE_WIDTH = 3.0;\nfloat TRI_EDGE_WIDTH  = 2.0;\n\nvec3 CLEAR_COLOR = vec3(0.15);\nvec3 GRID_LINE_COLOR = vec3(0.3);\nvec3 POINT_COLOR = vec3(0.0, 1.0, 1.0);\nvec3 QUAD_EDGE_COLOR = vec3(1.0, 0.0, 1.0);\nvec3 TRI_EDGE_COLOR  = vec3(1.0, 1.0, 0.0) * 0.8;\nfloat TRI_EDGE_DEGENERACY_FACTOR_SCALE = 0.1; // heuristics to reduce sudden triangulation flip\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nfloat hash31(vec3 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]) + 3.0 * hash11(v[2]));\n}\n\nvec2 hash22(vec2 v) {\n  return vec2(hash21(v), hash31(vec3(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(vec2 hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash22(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * hash_seed + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * hash_seed + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n//\n// Delaunay triangulation\n//\n\nvoid distanceToNoiseSitesTriangulation(\n    vec2 uv, float noise_seed,\n    out float min_distance_vertex,\n    out float min_distance_quad_edge,\n    out float min_distance_tri_edge,\n    out float in_circle_test_det) {\n\n  vec2 lattice_uv = floor(uv);\n  min_distance_vertex = sqrt(2.0);\n  min_distance_quad_edge = 1.0;\n  min_distance_tri_edge = sqrt(2.0);\n\n  // Cache sites coordinate\n  vec2 sites[9];\n  #define _ENCODE_IJ(i, j)       (3 * int(i + 1.0) + int(j + 1.0))\n  #define READ_SITE(i, j)        sites[_ENCODE_IJ(i, j)]\n  #define WRITE_SITE(i, j, site) sites[_ENCODE_IJ(i, j)] = site\n\n  // iterate sites\n  for (float i = -1.0; i <= 1.0; i++) {\n    for (float j = -1.0; j <= 1.0; j++) {\n      vec2 lattice_ij = lattice_uv + vec2(i, j);\n      vec2 site_ij = lattice_ij + someNoise(lattice_ij, noise_seed);\n      min_distance_vertex = min(min_distance_vertex, distance(uv, site_ij));\n      WRITE_SITE(i, j, site_ij);\n    }\n  }\n\n  // iterate quad edges\n  // - these quads are not necessarily convex, but the probablity of such case should be quite low.\n  //   or you could force convexity by weaking the noise factor (e.g. 0.5 * someNoise(...)).\n  for (float k = -1.0; k <= 1.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      float d_kl = distance_Point_LineSegment(uv, READ_SITE(k, l), READ_SITE(k + 0.0, l + 1.0));\n      float d_lk = distance_Point_LineSegment(uv, READ_SITE(l, k), READ_SITE(l + 1.0, k + 0.0));\n      min_distance_quad_edge = min(min_distance_quad_edge, min(d_kl, d_lk));\n    }\n  }\n\n  // iterate triangulation diagonal edges\n  for (float k = -1.0; k <= 0.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      vec2 v0 = READ_SITE(k + 0.0, l + 0.0);\n      vec2 v1 = READ_SITE(k + 1.0, l + 0.0);\n      vec2 v2 = READ_SITE(k + 0.0, l + 1.0);\n      vec2 v3 = READ_SITE(k + 1.0, l + 1.0);\n\n      // Cf. Guibas 1985, Lemma 8.1 (https://doi.org/10.1145%2F282918.282923)\n      mat3 in_circle_test_mat = mat3(\n          (v1 - v0).x, (v1 - v0).y, dot(v1, v1) - dot(v0, v0),\n          (v2 - v0).x, (v2 - v0).y, dot(v2, v2) - dot(v0, v0),\n          (v3 - v0).x, (v3 - v0).y, dot(v3, v3) - dot(v0, v0));\n      float in_circle_test_det_current = determinant(in_circle_test_mat);\n      float d = in_circle_test_det_current > 0.0\n          ? distance_Point_LineSegment(uv, v1, v2)  // edge: 10 <--> 01\n          : distance_Point_LineSegment(uv, v0, v3); // edge: 00 <--> 11\n      if (d < min_distance_tri_edge) {\n        min_distance_tri_edge = d;\n        in_circle_test_det = in_circle_test_det_current;\n      }\n    }\n  }\n\n  #undef _ENCODE_IJ\n  #undef READ_SITE\n  #undef WRITE_SITE\n}\n\n//\n// Misc\n//\n\n// grid\nfloat distanceToGrid(vec2 uv) {\n  vec2 uvf = fract(uv);\n  return min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float b, float d, float w) {\n  return 1.0 - smoothstep(0.0, 1.0, (d - b) / w + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  float inv_view_scale = SCALE / iResolution.y;\n  vec2 uv =  inv_view_scale * frag_coord;\n  float t = SCALE_TIME * iTime;\n\n  vec3 color = CLEAR_COLOR;\n  {\n    float d = distanceToGrid(uv);\n    float coverage = smoothBoundaryCoverage(0.5 * GRID_LINE_WIDTH, d / inv_view_scale, AA);\n    color = mix(color, GRID_LINE_COLOR, coverage);\n  }\n  {\n    float d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det;\n    distanceToNoiseSitesTriangulation(\n        uv, t, d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det);\n\n    float coverage_vertex = smoothBoundaryCoverage(\n        POINT_RADIUS, d_vertex / inv_view_scale, AA);\n    float coverage_quad_edge = smoothBoundaryCoverage(\n        0.5 * QUAD_EDGE_WIDTH, d_quad_edge / inv_view_scale, AA);\n    float coverage_tri_edge = smoothBoundaryCoverage(\n        0.5 * TRI_EDGE_WIDTH, d_tri_edge / inv_view_scale, AA);\n    float degeneracy_factor = smoothstep(\n        0.0, TRI_EDGE_DEGENERACY_FACTOR_SCALE, abs(in_circle_test_det));\n\n    color = mix(color, QUAD_EDGE_COLOR, coverage_quad_edge);\n    color = mix(color, TRI_EDGE_COLOR, coverage_tri_edge * degeneracy_factor);\n    color = mix(color, POINT_COLOR, coverage_vertex);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 541, 568, 568, 627], [628, 628, 693, 693, 760], [762, 762, 822, 885, 1099], [1102, 1118, 1141, 1141, 1199], [1201, 1201, 1223, 1223, 1277], [1279, 1279, 1301, 1301, 1376], [1378, 1378, 1399, 1399, 1449], [1451, 1451, 1480, 1480, 1516], [1518, 1518, 1549, 1549, 2019], [2021, 2021, 2071, 2153, 2504], [2506, 2539, 2755, 2755, 5136], [5153, 5161, 5192, 5192, 5282], [5284, 5298, 5355, 5355, 5413], [5416, 5431, 5485, 5485, 6696]]}
{"id": "3tVGRz", "name": "Plane Checker AA", "author": "spalmer", "description": "draws an analytically antialiased checkered plane.\ncan split-window using mouse click\nand number keys switch right panel methods \nto compare with unfiltered left panel\n", "tags": ["grid", "antialias", "checker", "plane", "splitscreen"], "likes": 17, "viewed": 336, "published": "Public", "date": "1578329363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also https://shadertoy.com/view/wt3Sz2\n//      and https://shadertoy.com/view/wl3Sz2\n\n// a simple testbed for rendering an antialiased checkered plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\nconst vec3 // check colors\n  C1 = vec3(1.,1.,.9) //1.,1.,1.) //1.,1.,0.) //\n, C2 = vec3(0.,0.,0.) //1.,0.,1.)\n, Csky = vec3(.8,.9,1.);\n\n#define R iResolution.xy\n\nconst float pi = acos(-1.); //3.141592;\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped.\n// wound up using fwidth instead, as it's far more convenient!\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\nfloat filterWidthb2(vec2 uvw)\n{\n    vec2 dx = dFdx(uvw), dy = dFdy(uvw);\n    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n}\n\nfloat filterWidthc2(vec2 uvw)\n{\n    vec2 w = fwidth(uvw);\n    return dot(w, w) + .0001; //max(w.x, w.y) + .0001; //\n}\n\nfloat filterWidthc3(vec3 uvw)\n{\n    vec3 w = fwidth(uvw);\n    return dot(w, w) + .0001; //max(w.x, max(w.y, w.z)) + .0001;\n}\n\nfloat tentbox2(vec2 f) // tent box?\n{\n    return min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2.;\n}\n\nfloat parabox2(vec2 f) // parabola box?\n{\n    return min(f.x * (1.-f.x), f.y * (1.-f.y)) * 4.;\n}\n\nfloat paraboloid2(vec2 f) // paraboloid\n{\n\treturn f.x * (1.-f.x) * f.y * (1.-f.y) * 16.;\n}\n\n// exp2 filters return 1 when should blur completely out\n// g is a positive distance to an edge to be smoothed\n// idk if I really needed to refactor this, after all.\nfloat smoothCheck(float x, float g, float w)\n{\n    return mix(x, .5, exp2(-clamp(g / w, 0., 1.)));\n}\n\n\n// simple unfiltered checkerboard texture as reference; aliases badly.\nfloat checkerUnfiltered(vec2 p)\n{\n\treturn float((int(floor(p.x))^int(floor(p.y)))&1);\n}\n\nfloat checkerIso(vec2 p)\n{\n\treturn smoothCheck(checkerUnfiltered(p)\n        , .25 //, tentbox2(fract(p)) //\n        , exp2(max(0., fwidth(p.x) + fwidth(p.y))) - 1.);\n}\n\n// for @FabriceNeyret2; parameterized like a texlodbias but takes a log2 of fraction, so is -1 .. 0 range?! idk\nfloat checkerIso(vec2 p, float miplodbias)\n{\n\treturn smoothCheck(checkerUnfiltered(p)\n        , .25 //, tentbox2(fract(p)) //\n        , 1./(1.-min(0., miplodbias))/*exp2(max(0., .05*miplodbias))*/ - 1.);\n}\n\n// considers each check axis separately\nfloat checkerAA(vec2 p)\n{\n    vec2 f = fract(p);\n    float x = checkerUnfiltered(p)\n    , gx = min(f.x, 1.-f.x)\n    , gy = min(f.y, 1.-f.y)\n    , fx = fwidth(p.x)\n    , fy = fwidth(p.y)\n    , lx = gx / (1./R.x + fx*(1.+16.*fx))\n    , ly = gy / (1./R.y + fy*(1.+16.*fy))\n    , l = 2. * min(lx, ly);\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n//, s = .01*R.y\n//gx / (1. + s * fx) //gx * exp2(-16./R.x*(fx - 64.)) //\n//gy / (1. + s * fy) //gy * exp2(-16./R.y*(fy - 64.)) //\n\n// like checkerAASimple but with squared falloff for\n// distance blur, similar to how checkerExp works; decent\nfloat checkerAA2(vec2 p)\n{\n    vec2 f = fract(p);\n    float x = checkerUnfiltered(p)\n    , g = tentbox2(f) //\n    , w = max(fwidth(p.x), fwidth(p.y)) //\n    , r = 2.*R.y\n    , l = r*g / (1. + r*w*(8.*w+1.)); //r*g / (1. + 2.*r*w); //\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n// it's simple because it uses simple tent function\n// and simple fwidth with relatively simple rational function inlined\nfloat checkerAASimple(vec2 p)\n{\n    vec2 f = fract(p); //p - floor(p); //\n    float x = checkerUnfiltered(p)\n    , g = tentbox2(f) //min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2. //\n    , w = max(fwidth(p.x), fwidth(p.y)) //fwidth(p.x) + fwidth(p.y) //\n    , r = 2.*R.y // can scale more for more blur in distance\n    , l = r*g / (1. + r*w); //min(.5*iResolution.y*g, 1.-w); //8. * g - .5 * w; //8. * g / w; //g; // can try different functions\n    return mix(.5, x, clamp(l, 0., 1.)); // smoothCheck\n}\n// the tent shape is not the main problem\n// the filter width measurement is not the main problem\n// those are both different yet the result\n// appears identical to checkerAASimple\nfloat checkerAAAlt(vec2 p)\n{\n    float x = checkerUnfiltered(p);\n    vec2 f = fract(p);\n    float g = parabox2(f);\n    float w = fwidth(p.x) + fwidth(p.y); //filterWidthc2(p);\n    //w = sqrt(w); // ALL of my filter width measurement wrappers are squared.\n    return mix(x, .5, exp2(-2. * max(0., g / (w + 1e-7))));\n     //min(.5*R.y*g, 1.-w); //8. * g - .5 * w; //8. * g / w; // can try different functions\n}\n\n// my exponential blending over edges, works pretty well but axes are joined awkwardly\nfloat checkerExp(vec2 p)\n{\n    float x = checkerUnfiltered(p);\n    vec2 f = fract(p);\n    float g = parabox2(f);\n    float w = filterWidth2(p);\n    // g and w just get multiplied together anyway; just simplify this?  currently shared with the stripe toy\n    return smoothCheck(x, .125 * g, w);\n}\n\n// my axis-separated exponentiated sinusoid\nfloat checkerSine2(vec2 p)\n{\n    float x = sin(p.x * -pi) * exp2(-24.*fwidth(p.x) + 3.)\n            * sin(p.y *  pi) * exp2(-24.*fwidth(p.y) + 3.); // tune blur rate\n    return clamp(x, -1., 1.) * .5 + .5;\n}\n// mine.  Doesn't hold up when very close.\nfloat checkerSine(vec2 p)\n{\n    float x = sin(p.x * -pi) * sin(p.y * pi);\n    float w = max(fwidth(p.x), fwidth(p.y));\n    x *= exp2(-16.*w + 4.); // tune blur rate\n    return clamp(x, -1., 1.) * .5 + .5;\n}\n\n// I tried a bunch of stuff!\n//\t  float w = abs(f.x) + abs(f.y); w *= 4.;\n//    \n//    g = 1. - g; // HACK reverse\n//    float w = max(dot(dx,dx), dot(dy,dy)); //(length(dx) + length(dy)); //max(length(dx), length(dy)); //;\n//    w *= 4.; // HACK\n//    w *= (1. + g); //(1.-g);\n//    float e = exp2(-.125*(g)/(w+.001)); //1.-g; //(1.-g) * exp2(-.2/w); //0.; //1.- ; //g; //\n\n// I hackjob'd iq checkersTextureGradBox and squared the derivatives; looks much better imho\nfloat checkerSquared(vec2 p)\n{\n    vec2 w = max(abs(dFdx(p)), abs(dFdy(p)));\n    w *= w; // not in iq's original code - I find it works much better and keeps the nearby edges sharp\n    w = w * 12. + .001;\n    vec2 i = 2.*(abs(fract((p - .5*w) * .5) - .5)\n                -abs(fract((p + .5*w) * .5) - .5)) / w;\n    return .5 - .5 * i.x * i.y;\n}\n\n#if 1\n// iq's is good, but doesn't completely suppress aliasing in the extreme distance, where it may as well fade completely to .5, and it gets too blurry on edges up close\n// iq's https://shadertoy.com/view/XlcSz2, originating from GPU Gems ch 25\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// --- analytically box-filtered checkerboard ---\nfloat checkersTextureGradBox(vec2 p, vec2 d_x, vec2 d_y)\n{\n    // filter kernel - iso\n    vec2 w = max(abs(d_x), abs(d_y)) + 0.01;\n    // analytical integral (box filter)\n    vec2 i = 2.*(abs(fract((p - .5*w) * .5) - .5)\n                -abs(fract((p + .5*w) * .5) - .5)) / w;\n    // xor pattern\n    return .5 - .5*i.x*i.y;                  \n}\n// my wrapper computes derivatives\nfloat checkerIq(vec2 p) // unscaled matches the gpu gem better\n{\n\treturn checkersTextureGradBox(p, dFdx(p), dFdy(p));\n}\n// rescaled; aliases less but gets excessively blurry when very close\nfloat checkerIqx4(vec2 p)\n{\n\treturn checkersTextureGradBox(p, dFdx(p) * 4., dFdy(p) * 4.);\n}\n#endif\n\n#if 1\n// FabriceNeyret2's 16x aniso sampler\n// from https://shadertoy.com/view/4lXfzn\nfloat checkerFabriceAniso(vec2 p) \n{\n    mat2 J = inverse(mat2(dFdx(p),dFdy(p)));       // dFdxy: pixel footprint in texture space\n    J = transpose(J)*J;                            // quadratic form\n    float d = determinant(J), t = J[0][0]+J[1][1], // find ellipse: eigenvalues, max eigenvector\n          D = sqrt(t*t-4.*d), \n          V = (t-D)/2., v = (t+D)/2.,                     // eigenvalues \n          M = 1./sqrt(V), m = 1./sqrt(v), l = log2(m*R.y); // = 1./radii^2\n  //if (M/m>16.) l = log2(M/16.*R.y);                     // optional\n    vec2 A = M * normalize(vec2( -J[0][1] , J[0][0]-V )); // max eigenvector = main axis\n    float O = 0.;\n    for (float i = -7.5; i<8.; ++i) {                      // sample x16 along main axis at LOD min-radius\n        vec2 q = p+(i/16.)*A;\n        O += checkerUnfiltered(q); //checkerIso(q); //checkerIso(q, l); //\n    }\n    O /= 16.;\n    //O = mix(.5, O, clamp(1./m, 0., 1.)); // TODO fade in distance to replace lacking mipmaps\n    return O;\n}\n#endif\n\n#if 1\n// oneshade https://shadertoy.com/view/7sKSDV\n// Error function approximation\nfloat erf(float x) \n{\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered checkerboard\nconst float k = 4.; //3.; //\nfloat checkerOneshade(vec2 p)\n{\n    vec2 w = clamp(vec2(fwidth(p.x), fwidth(p.y)), 1e-9, 2.); //vec2(.1,.01); // TODO dFdx, dFdy, may need to rotate to grid somehow\n    p = mod(p, 2.);\n    float s = 1.0 - 2. * mod(k, 2.);\n    float u = 0., v = 0.;\n    for (float n = -k; n <= k; ++n) {\n        u += s * erf((p.x - n) / w.x);\n        v += s * erf((p.y - n) / w.y);\n        s = -s;\n    }\n    return (1. - u * v) / 2.;\n}\n#endif\n// is that a Weierstrass transform? I'm unsure.  You tell me!\n// https://wikipedia.org/wiki/Weierstrass_transform\n\nint mode;\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    switch (mode) {\n      default:\n      case 0:  return checkerAA(uv);\n      case 1:  return checkerOneshade(uv);\n      case 2:  return checkerSquared(uv); // iq^2\n\t  case 3:  return checkerIqx4(uv);\n      case 4:  return checkerAA2(uv);\n\t  case 5:  return checkerFabriceAniso(uv);\n      case 6:  return checkerIq(uv); //checkerAAAlt(uv); //\n      case 7:  return checkerSine2(uv); //checkerSine(uv); //\n      case 8:  return checkerAASimple(uv);\n      case 9:  return checkerExp(uv); //checkerIso(uv); //checkerUnfiltered(uv);\n    }\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n//    return checkerOneshade(uv);\n//\t  return checkerIqx4(uv);\n//\t  return checkerIq(uv);\n//    return checkerFabriceAniso(uv);\n//\t  return checkerIso(uv);\n\treturn checkerUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. : //maxd :\n    \trp.y / -rd.y;\n}\n\nvoid rot(inout vec2 v, float radian)\n{\n    float c = cos(radian), s = sin(radian);\n    v *= mat2(c, s,-s, c);\n}\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = -.4, yaw = iTime * -.04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\nbool key(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > .5;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(.07 * iTime) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1., 0.);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // number keys 1 thru 3 control bit of a binary number mode selector\n    mode = 0;\n    for (int i = 1; i < 10; ++i) \n        if (key(48 + i)) mode = i;\n    \n    // split screen at mouse click\n    float splits = p.x - (iMouse.z == 0. ? .5 * iResolution.x : iMouse.x);\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float check = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(C1, C2, check); // colorize\n    \n    float fog = 1.0 - exp2(-.02*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamut\n    c.a = 1.;\n}\n\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n//    if (!left) fog = 0.; // fog hides the worst of the aliasing at the horizon, though.  So you might want to unhide it, but maybe only for right half?\n//   c = vec3(fract(cc), 0); // show hit uv\n ", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 640, 669, 669, 747], [749, 749, 778, 778, 866], [867, 954, 984, 984, 1073], [1075, 1075, 1106, 1106, 1226], [1228, 1228, 1259, 1259, 1345], [1347, 1347, 1378, 1378, 1471], [1473, 1473, 1510, 1510, 1569], [1571, 1571, 1612, 1612, 1667], [1669, 1669, 1710, 1710, 1759], [1761, 1927, 1973, 1973, 2027], [2030, 2101, 2134, 2134, 2188], [2190, 2190, 2216, 2216, 2357], [2359, 2471, 2515, 2515, 2676], [2678, 2718, 2743, 2743, 3058], [3191, 3302, 3328, 3328, 3578], [3580, 3702, 3733, 3733, 4202], [4203, 4384, 4412, 4412, 4792], [4794, 4881, 4907, 4907, 5176], [5178, 5222, 5250, 5250, 5429], [5430, 5473, 5500, 5500, 5679], [6056, 6149, 6179, 6179, 6493], [10413, 10452, 10475, 10475, 11012], [11013, 11051, 11074, 11230, 11263], [11294, 11307, 11344, 11344, 11427], [11429, 11429, 11467, 11467, 11540], [11542, 11542, 11566, 11566, 11769], [11771, 11771, 11789, 11789, 11848], [11850, 11850, 11886, 11909, 13041]]}
{"id": "3tVGWz", "name": "Galaxy of Color", "author": "CJG", "description": "Dots of color in a Galaxy of sound", "tags": ["abstract"], "likes": 2, "viewed": 83, "published": "Public", "date": "1578687511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CO vec3(0.0, 0.0, 5.0)\n\n#define RME 0.01\n#define RMM 10.0\n\nvec2 uv;\n\nfloat map(vec3 p) {\n    float w = 2.0 * texture(iChannel0, vec2(length(uv))).x;\n    \n    float bigS = distance(vec3(0.0, 0.0, -2.0), p) - 0.25 - 0.25 * texture(iChannel0, vec2(length(uv))).x; \n    bigS += sin(w * p.x) * sin(w * p.y) * sin(w * p.z) * 0.5;\n    \n    w *= 0.5;\n    \n    float smallS1 = distance(vec3(sin(iTime/7.0), sin(iTime*2.4),  -2.0 + cos(iTime*2.0)), p) - 0.1;\n    smallS1 += sin(w * p.x) * sin(w * p.y) * sin(w * p.z) * 0.25;\n    \n    float smallS2 = distance(vec3(sin(iTime*2.2), sin(iTime/3.0),  -2.0 + cos(iTime*2.0)), p) - 0.1;\n    smallS2 += sin(w * p.x) * sin(w * p.y) * sin(w * p.z) * 0.25;\n    \n    float smallS3 = distance(vec3(sin(iTime*2.3), sin(iTime*2.5),  -2.0 + cos(iTime/5.0)), p) - 0.1;\n    smallS3 += sin(w * p.x) * sin(w * p.y) * sin(w * p.z) * 0.25;\n    \n    return min(bigS, min(smallS1, min(smallS2, smallS3)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 hitP, out float steps){\n    steps = 0.0;\n    for(float d = 0.0; d < RMM;){\n        ++steps;\n     \tfloat md = map(hitP = (ro + rd * d));\n        if(md <= RME) return 1.0;\n        d += md;\n    }\n    return 0.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 hitPoint;\n    float steps, hit = rayMarch(CO, normalize(vec3(uv, 0.0) - CO), hitPoint, steps);\n\n    float m = texture(iChannel0, vec2(length(uv))).x;\n    \n    fragColor = vec4(0.0);\n    fragColor.rgb += hsv2rgb(vec3((sin(iTime * (1.0 + hit))+1.0)/2.0, 0.5 + m, (steps / 15.0 / (1.0 + m * 2.0))));\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 96, 96, 932], [934, 934, 999, 999, 1186], [1188, 1188, 1210, 1210, 1379], [1382, 1382, 1439, 1439, 1836]]}
{"id": "3ty3Dd", "name": "PimpThatAss2", "author": "Del", "description": "fork of pimp that ass by makc\noriginal here: https://www.shadertoy.com/view/WtV3Wc", "tags": ["sdf", "animated", "distance", "parametric"], "likes": 15, "viewed": 997, "published": "Public API", "date": "1580142211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork of pimp that ass - https://www.shadertoy.com/view/WtV3Wc - added jiggle anim + various other tweaks :)\n// basically a combination of:\n// - https://mathematica.stackexchange.com/a/66564 by Nikolai Mikuszeit\n// - https://www.shadertoy.com/view/Ws3SDl by Inigo Quilez\n\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\t\n    float jiggle = p.z*1.75;\n    float jsize = 0.5;\n    if (iMouse.z>0.5)\n    {\n        jiggle+=p.y*.5;\n        jsize+=.175;\n    }\n    \n\tdx *= 1.5+(sin(jiggle+iTime*9.65)*jsize);\n\t\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n//\tfloat d1 = (.5 + .5 * smoothstep(.4,1.,p.z)) * (length(vec2(p.y, p.x - dx)) - r_expected);\n\tfloat d1 = (length(vec2(p.y, p.x - dx)) - r_expected)*0.5;\n    \n    p.x -= dx;\n\tfloat d2 = sdSphere(p+vec3(-0.35,0.4,-1.875),0.4);\n\tfloat d3 = sdSphere(p+vec3(-0.35,-0.4,-1.875),0.4);\n    d2 = smin(d2,d3,0.35);\n    return smin(d1,d2,0.07);\n    //return min(d1,min(d2,d3));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = sin(iTime+2.15)*0.7;\t//0.5*iTime - 0.8;\n    if (iMouse.z>0.5)\n        an+=iMouse.x/(iResolution.x*0.25);\n    //an+=3.14;\n    \n\tvec3 ro = vec3( 2.55*sin(an), 0.5, -2.55*cos(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    \n    vec2 p1 = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float val = sin(iTime+p1.x+p1.y*20.0)*(0.8+sin(p1.y+iTime*3.0)*0.3);\n    val = clamp(val,0.0,2.0);\n    vec3 bcol = vec3(val,val*0.2,val*0.1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        vec3 col = bcol;\n        // raymarch\n        if (abs(p.x)<0.8)\n        {\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n            \n            const float tmax = 5.0;\n            float t = 0.0;\n            for( int i=0; i<150; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( h<0.0001 || t>tmax ) break;\n                t += h;\n            }\n            // shading/lighting\t\n            if( t<tmax )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n                float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n                float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n                col = vec3(0.3,0.15,0.1)*amb + vec3(0.8,0.5,0.2)*dif;\n                col += pow(dif,16.0);\n            }\n        }\n\n        // gamma        \n        //col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    // gamma        \n    tot = sqrt( tot );\n    \n   tot *= 1.0 - 0.2*dot(p1,p1);\t\t// vignette\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 329, 403, 403, 455], [456, 456, 491, 491, 517], [518, 518, 559, 559, 652], [654, 654, 702, 702, 746], [748, 748, 781, 781, 1350], [1352, 1420, 1443, 1467, 2253], [2256, 2256, 2282, 2282, 2309], [2311, 2375, 2407, 2407, 2645], [2647, 2647, 2704, 2729, 4855]]}
{"id": "3ty3DV", "name": "Montreal Winter Mood", "author": "antoinefortin", "description": "A Little exploration I made using the Montreal winter mood.", "tags": ["ddd"], "likes": 2, "viewed": 87, "published": "Public", "date": "1580358868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel0, p * 0.055).x ;    \n    float b = (sin(p.x * 2.))  ;\n    b *= (cos(p.y)) / 2.5 ;\n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    \n    return -b - 1.2;\n}\n\n\nfloat sdPlane(vec3 pos)\n{\n\t\n    return pos.y - (h(pos.xz));\n}\n\nfloat sphereDistance(vec3 pos, float radius)\n{\n\t// copy to local scope of SDF \n    vec3 localPos = pos;\n    float localRadius = radius;\n    return length(localPos) - localRadius;\n    \n}\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n    float radius = .5;\n    \n    float r = sin(q.x);\n    \n        \n\t//float d = sphereDistance(vec3(q.x + .5, q.y - .2 , q.z), .25);\n    float rad = .75;\n    rad *=  abs(sin(q.z - iTime * 5.))\n        * cos(q.x + .5 * 1.5) \n        * (abs(sin(q.z * 3.5)) + abs(cos(q.y)) ); // base\n\t\n    float d1 = sphereDistance(q, 1.);    \n    \n    float d2 = sdPlane(pos);\n    \n    \n    return min(d1, d2);\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.00001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t/*\nvec3 ro = vec3(0.0,0.0,1.0);\n   vec3 rd = normalize(vec3(p, -1.5));\n\t*/\n \t\n    // SKY \n    float speed = 00.00001;\n    float scale = 0.0015;\n    vec2 sp = fragCoord * scale; \n    for(int i=1; i<12; i++){\n        sp.x+=(cos(iTime * 0.25)) * 0.75/float(i)*sin(float(i)*2.*sp.y+iTime*speed)+ (iTime * 69.)/1000.;\n        sp.y+=cos(iTime) * 0.15/float(i)*cos(float(i)*5.*sp.x+iTime*speed)+(iTime * .69)/1000.;\n    }\n    float r=cos(sp.x+sp.y+.025)*.9 + 0.33;\n    float g=sin(sp.x+sp.y+1.)*.55+.5;\n    float b=(sin(p.x * 1. +p.y)+cos(sp.x+(sp.y)))*.5+.28;\n    vec3 color = vec3(b,g,1.0);\n    color -= 0.002;\n\n\tvec3 col = vec3(color);\n\n    \n    // Camera Look at\n    \n    float an = iTime * .5;\n    vec3 ro = vec3(3. * sin(an),.75, 5. *  cos(an));\n    \n\tfloat cameraZoom = 1.5;\n\tvec3 target = vec3(0.1, 0., 0.);\n\t\n\tvec3 ww = normalize(target - ro);\n\tvec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n\tvec3 vv = normalize(cross(uu, ww));\n    \n\tvec3 rd = normalize(p.x * uu + p.y * vv + cameraZoom * ww);\n\n    // Rendering part\n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.5)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n       \tvec3 sundir = normalize(vec3(0.8, 0.4, 0.2));\n     \n        \n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha * .7;\n        col += vec3(.0, 0.2, .5) * sky_dif * 2.5;\n    }\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 213], [216, 216, 241, 241, 277], [279, 279, 325, 357, 464], [466, 466, 487, 487, 905], [907, 907, 940, 940, 1245], [1247, 1247, 1274, 1274, 1486], [1488, 1488, 1545, 1595, 3285]]}
{"id": "3ty3Wy", "name": "noise soup?", "author": "yonatan", "description": "idk", "tags": ["noise"], "likes": 13, "viewed": 767, "published": "Public", "date": "1579730657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n    float ret = -1.;\n    float freq = 1.;\n    float amp = 1.;\n    for(int i=0; i<8; i++) {\n\t    float n = cnoise(p*freq+vec3(0,(iTime*.2),0)*2.);\n        ret = ret + n * amp;\n        amp *= .5;\n        freq *= 1.5 + n * .1;\n    }\n\treturn ret;\n}\n\nfloat f(vec3 p) {\n    float n = fbm(p);\n    return p.y - 1. - exp(n) * .5;\n}\n\n\n\nvec3 calcNormal(vec3 p, float h) // for function f(p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, 2, -4);\n    vec3 rd = normalize(vec3(uv, 1.77) + vec3(0,-1.5,0));\n    /*\n    pR(ro.xz, iTime*.1);\n    pR(rd.xz, iTime*.1);\n\t//*/\n    float t = 0., d;\n\n    \n    for(int i=0; i<16; i++) {\n        d = f(ro+rd*t);\n        //if(d<0.) break;\n        t+=d;\n    }\n    \n    vec3 n = calcNormal(ro+rd*t, t*t*.0004);\n    // Time varying pixel color\n    vec3 col = -n.yyy *n.y * .5 + .5;\n    col *= vec3(8,4,16);\n\tcol /= t;\n    col = pow(col, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3Wy.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 442, 463, 463, 512], [514, 514, 535, 535, 584], [586, 586, 608, 608, 645], [647, 647, 675, 675, 727], [729, 729, 748, 748, 788], [790, 814, 836, 836, 3131], [3133, 3140, 3163, 3163, 3408], [3410, 3410, 3427, 3427, 3486], [3490, 3490, 3545, 3545, 3770], [3772, 3772, 3804, 3804, 3846], [3848, 3848, 3905, 3955, 4573]]}
{"id": "3ty3z3", "name": "metaball + twister", "author": "alarch", "description": "hey.", "tags": ["metaball", "twister"], "likes": 1, "viewed": 45, "published": "Public", "date": "1579447757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nfloat metaCalc(vec2 uv, vec3 pos)\n{\n    return 1.0/((pos.x*pos.x)+(pos.y*pos.y)+(pos.z*pos.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // init stuff\n    vec3 pos = vec3(0.2+0.1*cos(iTime),0.3*cos(iTime),0.5);\n    vec3 pos2 = vec3(0.2+-0.1,0.2+-0.3,0.0)*sin(iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5; // set center/origo to vec2(0.0,0.0);    \n    uv.x *= iResolution.x/iResolution.y; // how do you really do aspect ratio?  \n    \n    vec3 varCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // metaball\n    float amplitude1 = metaCalc(uv, vec3(uv.x - pos.x,uv.y - pos.y,pos.z));\n    float amplitude2 = metaCalc(uv, vec3(uv.x - pos2.x,uv.y - pos2.y, pos.z));\n    \n    float amplitude = amplitude1+amplitude2;\n    \n    if(amplitude > 6.0)\n    {\n       float amplitudeColor = amplitude/10.0;\n       float depthColor = amplitudeColor*(pos.z*amplitude1+pos2.z*amplitude2);\n       fragColor = vec4(vec3(depthColor), 0.0);  \n    }\n    else\n    {  \n    \t\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n    \n    // twister\n    #define thick 0.002\n    \n    vec4 white = vec4(1.0,1.0,1.0,1.0);\n    vec4 red = vec4(1.0,0.0,0.0,1.0);\n \n    vec4 green = vec4(0.0,1.0,0.0,1.0);\n    vec4 blue = vec4(0.0,0.0,1.0,1.0);\n    \n    float theta = sin(iTime)*uv.y*10.0;\n/*\n    float x0 = -0.6+0.1*sin(theta);\n    float x1 = -0.6+0.1*sin(theta+90.0); // sin a+90\n    float x2 = -0.6+0.1*sin(theta+180.0); // sin a+180\n    float x3 = -0.6+0.1*sin(theta+270.0); // sin a+180\n  */  \n    \n    float x0 = -0.6+0.1*sin(theta);\n    float x1 = -0.6+0.1*sin(theta+PI*0.5); // sin a+90\n    float x2 = -0.6+0.1*sin(theta+PI*1.0); // sin a+180\n    float x3 = -0.6+0.1*sin(theta+PI*1.5); // sin a+270\n    \n    // from https://www.shadertoy.com/view/lsX3WM \n    if (x0 < x1) {\n\t\tif ((abs(uv.x - x0) < thick) || (abs(uv.x - x1) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x0) && (uv.x < x1)) {\n\t\t\t\tfragColor = red-varCol.r;\n\t\t\t}\n\t\t}\n\t}\n\tif (x1 < x2) {\n\t\tif ((abs(uv.x - x1) < thick) || (abs(uv.x - x2) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x1) && (uv.x < x2)) {\n\t\t\t\tfragColor = green-varCol.g;\n\t\t\t}\n\t\t}\n\t}\n\tif (x2 < x3) {\n\t\tif ((abs(uv.x - x2) < thick) || (abs(uv.x - x3) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x2) && (uv.x < x3)) {\n\t\t\t\tfragColor = blue-varCol.b;\n\t\t\t}\n\t\t}\n\t}\n\tif (x3 < x0) {\n\t\tif ((abs(uv.x - x3) < thick) || (abs(uv.x - x0) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x3) && (uv.x < x0)) {\n\t\t\t\tfragColor = vec4(uv,0.2+0.5*sin(iTime+135.0),1.0);\n\t\t\t}\n\t\t}\n\t}\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ty3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 60, 60, 122], [124, 124, 181, 204, 2659]]}
{"id": "3tyGWz", "name": "Dragon Scale", "author": "riginosk", "description": "Dragon Scales", "tags": ["scales"], "likes": 2, "viewed": 76, "published": "Public", "date": "1579035850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opRepXZ( vec3 p, vec3 c )\n{\n    return vec3(mod(p.x,c.x)-0.5*c.x, p.y, mod(p.z,c.z)-0.5*c.z);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// exponential smooth min (k = 32);\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 rX(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(p.x, c * q.y - s * q.z, s * q.y + c * q.z);\n}\n\nvec3 rY(in vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\treturn vec3(c * q.x + s * q.z, p.y, -s * q.x + c * q.z);\n}\n\n//----------------------------------------------------------------------\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 map(in vec3 pos) {\n    vec2 res = vec2(sdPlane(pos), 1.0);\n    \n    // bledng cubes by groups of 9\n    float gap = 1.2;\n\t\n    vec3 cubeSize = vec3(0.5);\n    for(float i=-1.; i<=1.; i+=1.) {\n        for(float j=-1.; j<=1.; j+=1.) {\n            vec3 p = opRepXZ(pos, vec3(gap, 0., gap))+vec3(i*gap, 0., j*gap);\n//            vec3 p = pos+vec3(i*gap, 0., j*gap);\n            float rotX = iTime+pos.x*0.3;\n\t        float rotY = iTime+pos.z*0.3;\n            vec3 p2 = rY(rX(p, rotX), rotY);\n            \n            float dst = sdBox(p2, cubeSize);\n            \n            // smooth min\n            float a = res.x;\n            float b = dst;\n            // blending power : 0. to 1.\n            float k = .5;\n            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n            \n\t\t    res = vec2(mix( b, a, h ) - k*h*(1.0-h), 3.0);\n        }\n    }\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = -0.15 + 0.1*sin( vec3(10.25,10.08,10.50)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.2, sin(0.7), 0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n//        dif *= softshadow( pos, lig, 0.02, 2.5 );\n//        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n//\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ro = vec3( 0., 8.0, 0.5 + 3.5);\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 41], [43, 43, 74, 74, 161], [163, 237, 270, 270, 296], [298, 298, 328, 328, 361], [363, 363, 393, 393, 422], [424, 424, 456, 456, 524], [526, 562, 603, 603, 696], [698, 734, 776, 776, 847], [849, 849, 873, 873, 1005], [1007, 1007, 1036, 1036, 1141], [1143, 1143, 1172, 1172, 1278], [1280, 1354, 1374, 1374, 1446], [1448, 1448, 1471, 1471, 2317], [2319, 2319, 2359, 2359, 2949], [2952, 2952, 3026, 3026, 3287], [3289, 3289, 3321, 3321, 3542], [3544, 3544, 3586, 3586, 3885], [3890, 3890, 3929, 3929, 5526], [5528, 5528, 5580, 5580, 5757], [5759, 5759, 5816, 5816, 6453]]}
{"id": "3tyGzy", "name": "SL pallete", "author": "victorcesaroni", "description": "SL pallete", "tags": ["sl", "pallete"], "likes": 1, "viewed": 35, "published": "Public", "date": "1579172903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hue2rgb(float p, float q, float t){\n    if(t < 0.) t += 1.;\n    if(t > 1.) t -= 1.;\n    if(t < 1./6.) return p + (q - p) * 6. * t;\n    if(t < 1./2.) return q;\n    if(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}\n\nvec3 hslToRgb(vec3 hsl){\n    float r, g, b;\n    float s = hsl.y;\n    float h = hsl.x;\n    float l = hsl.z;\n\n    if(s == 0.){\n        r = g = b = l; // achromatic\n    }else{\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s;\n        float p = 2. * l - q;\n        r = hue2rgb(p, q, h + 1./3.);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1./3.);\n    }\n\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float anim = mod(iTime*.1,1.f);\n    \n    float h = anim;\n    \n    vec3 col = hslToRgb(vec3(h, uv.x, uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 237], [239, 239, 263, 263, 638], [640, 640, 697, 697, 883]]}
{"id": "4lSBDh", "name": "Spin draft 1", "author": "SudoNhim", "description": "first draft of visual for gabby's song spin", "tags": ["voxels"], "likes": 4, "viewed": 99, "published": "Public", "date": "1579485324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat map(vec2 p)\n{\n    float h = texture(iChannel0, p/800.0).r;\n    return h;\n}\n\nfloat mmap(vec2 p)\n{\n    float f = map(p) * 0.3;\n    return texture(iChannel2, vec2(f, 0.1)).r;\n}\n\nint getVoxelAt(ivec3 ip)\n{ \n    if (ip.y <= 0) return VOXEL_WATER;\n    \n    float h = map(vec2(ip.xz))*20.0-2.0;\n    \n    if (float(ip.y) <= h)\n        return VOXEL_SAND;\n\n    return VOXEL_NONE;\n}\n\nfloat dfVoxel(vec3 p, int voxelType)\n{\n    return length(p) - 0.5;\n}\n\nvec3 nrmVoxel(vec3 p, int voxelType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, voxelType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, voxelType) - base,\n        dfVoxel(p+dd.yxy, voxelType) - base,\n        dfVoxel(p+dd.yyx, voxelType) - base\n    ));\n}\n\nvoid voxelMarch(vec3 ro, vec3 rd, out ivec3 hitVoxels[4], out int hitCount, out float mAccums[4]) \n{\n    hitCount = 0;\n\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    bvec3 mask;\n    \n    float mAccum = 0.0;\n\t\n    for (int i = 0; i < 128; i++) {\n\n        // check current position for voxel\n        if (getVoxelAt(mapPos) != VOXEL_NONE) {\n            // no non-const indexing? :<\n            if (hitCount == 0) hitVoxels[0] = mapPos;\n            else if (hitCount == 1) hitVoxels[1] = mapPos;\n            else if (hitCount == 2) hitVoxels[2] = mapPos;\n            else if (hitCount == 3) hitVoxels[3] = mapPos;\n            hitCount++;\n            if (hitCount == 4) return;\n        }\n        \n        mAccum += mmap(vec2(mapPos.xz));\n        mAccums[hitCount] = mAccum;\n\n        // march forward to next position by discrete digital analyzer\n        if (sideDist.x < sideDist.y) {\n            if (sideDist.x < sideDist.z) {\n                sideDist.x += deltaDist.x;\n                mapPos.x += rayStep.x;\n                mask = bvec3(true, false, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        } else {\n            if (sideDist.y < sideDist.z) {\n                sideDist.y += deltaDist.y;\n                mapPos.y += rayStep.y;\n                mask = bvec3(false, true, false);\n            } else {\n                sideDist.z += deltaDist.z;\n                mapPos.z += rayStep.z;\n                mask = bvec3(false, false, true);\n            }\n        }\n    }\n}\n\nvoid resolveHitVoxels(\n    vec3 ro, vec3 rd, ivec3 hitVoxels[4], float mAccums[4], int hitCount, \n    out ivec3 hitVoxel, out vec3 hit, out int terrainType, out float mAccum) \n{ \n  mAccum = mAccums[0];\n  for (int i=0; i<4; i++) {\n    if (i == hitCount) return;\n    \n    hitVoxel = hitVoxels[i];\n    mAccum = mAccums[i];\n    terrainType = getVoxelAt(hitVoxel);\n    vec3 hitVoxelCenter = vec3(hitVoxel) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n\n    // fallback in case of no distance intersection\n    hit = ro + rd * (d - 0.01) - hitVoxelCenter;\n      \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p = ro + rd * d;\n    for (int j=0; j<4; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, terrainType);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.05) { // good enough distance marched intersection\n      hit = p - hitVoxelCenter;\n      return;\n    }\n  }\n}\n\nvec3 doColoring(vec3 hit, int terrainType, vec3 ldir)\n{\n    vec3 n = nrmVoxel(hit, terrainType);\n    float diffuse = max(dot(-ldir, n), 0.1);\n    \n    // render\n    vec3 color = vec3(0.0);\n    if (terrainType == VOXEL_WATER) color = vec3(0.6, 0.6, 1.0);\n    if (terrainType == VOXEL_EARTH) color.r = 1.0;\n    if (terrainType == VOXEL_SAND) color.rg = vec2(1.0, 0.6);\n    if (terrainType == VOXEL_STONE) color.rgb = vec3(0.5);\n    if (terrainType == VOXEL_GRASS) color.g = 1.0;\n    \n    color *= (0.8 + 0.2*diffuse);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(0., 20., iTime*3.0);\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    int hitCount;\n    ivec3 hitVoxels[4];\n    float mAccums[4];\n    voxelMarch(ro, rd, hitVoxels, hitCount, mAccums);\n\n    // resolve to one accurate intersection by distance marching\n    int terrainType = VOXEL_NONE;\n    ivec3 hitVoxel;\n    vec3 hit;\n    float mAccum;\n    resolveHitVoxels(ro, rd, hitVoxels, mAccums, hitCount, hitVoxel, hit, terrainType, mAccum);\n\n    vec3 hitGlobal = vec3(hitVoxel) + hit;\n    \n    // color\n    vec3 ldir = normalize(hitGlobal - ro);\n    vec3 color = doColoring(hit, terrainType, ldir);\n    \n    // fog\n    float fog = smoothstep(1.0, 0.0, length(hitGlobal - ro)/96.0);\n    color *= fog;\n    \n    color += mAccum/32.0;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XsBSzw", "previewfilepath": "https://soundcloud.com/gabby-chuchro/spin", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gabby-chuchro/spin", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSBDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 199, 225, 225, 535], [537, 537, 556, 556, 617], [619, 619, 639, 639, 716], [718, 718, 744, 744, 914], [916, 916, 954, 954, 984], [986, 986, 1025, 1025, 1267], [1269, 1269, 1369, 1369, 3040], [3042, 3042, 3219, 3219, 4091], [4093, 4093, 4148, 4148, 4633], [4635, 4635, 4692, 4765, 5873]]}
{"id": "ldXcDs", "name": "Mandelbrot - test", "author": "Oneiros", "description": "It is just a test", "tags": ["fractal"], "likes": 2, "viewed": 39, "published": "Public", "date": "1579159646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 colorMap( in float c )\n{\n    return vec4(c, c, c, 1);\n    \n    float d = 7.0;\n    float i = 1.0;\n    if (c > (i-1.0)/d && c < i/d) return vec4(c, 0, 0, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(0, c, 0, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(0, 0, c, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(c, c, 0, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(0, c, c, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(c, 0, c, 1); i++;\n    if (c > (i-1.0)/d && c < i/d) return vec4(c, c, c, 1); i++;\n}\n\nvec2 cpow( in vec2 z, in float n)\n{\n    //float r = pow(z.x, n);\n    //float x = r*cos(n*z.y);\n    //float y = r*sin(n*z.y);\n    float x = z.x*z.x - z.y*z.y;\n    float y = z.x*z.y + z.y*z.x;\n    return vec2(x, y);\n    \n}\n\nvec2 mandelbrot( in vec2 z, in vec2 c )\n{\n    return cpow(z, 2.0) + c;\n}\n\nint mandelbrotIterate( in vec2 c, in int iterations )\n{\n    vec2 z = c;\n    //int iterations = int(abs(sin(iTime)*30.0));\n    int i = 0;\n    for (; i < iterations; i++) {\n    \tz = mandelbrot(z, c);\n        if (length(z) > 2.0)\n            break;\n    }\n    return i;\n}\n\nfloat zoom = -0.9;\nfloat speed = 0.3;\nvec2 center = vec2(-0.761574,-0.0847596);\n\nvec2 toComplexCoords( in vec2 fragCoord )\n{\n    // Get integer version of coords and resolution\n    vec2 xy = vec2(int(fragCoord.x), int(fragCoord.y));\n    vec2 wh = vec2(int(iResolution.x), int(iResolution.y));\n    vec2 ar = vec2(wh.x/wh.y, 1.0);\n    \n    // Transformations\n    xy -= wh*0.5;\t\t// Center as origin\n\txy /= wh;\t\t\t// To homogeneous coords\n    xy *= ar;\t\t\t// Fix aspect ratio\n    xy /= zoom;\n    xy += center;\n    return xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    zoom += exp(iTime * speed);\n    \n    vec2 click = iMouse.xy;\n    click = toComplexCoords(click);\n    //center -= click * zoom;\n    //center = vec2(0.26, 0);\n    vec2 xy = toComplexCoords(fragCoord);\n    \n    // Calculate color\n    float levels = 255.0;\n    int m = mandelbrotIterate(xy, int(levels));\n    float c = (float(m))/float(levels);\n    \n    fragColor = 1.0-colorMap(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 551], [553, 553, 588, 677, 773], [775, 775, 816, 816, 847], [849, 849, 904, 904, 1116], [1199, 1199, 1242, 1294, 1638], [1641, 1641, 1698, 1698, 2083]]}
{"id": "lltBWn", "name": "tunnel of checkboard", "author": "jes5199", "description": "shrinking polar checkerboard", "tags": ["2d", "blackandwhite", "moire"], "likes": 4, "viewed": 82, "published": "Public", "date": "1580250297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 3.0;// + iTime / 3.;\n\n\tvec2 uv = zoom * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n\n    // Normalized pixel coordinates (from 0 to 1)\n   // vec2 uv = fragCoord/iResolution.xy;\n    \n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float theta = atan(uv.x, -uv.y);\n\n    vec2 check = vec2(r, theta);\n    \n    vec2 size = vec2(iTime,iTime) / 3.0;\n        float total = floor(check.x*float(size.x)) +\n                  floor(check.y*float(size.y));\n    bool isEven = mod(total,2.0)==0.0;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float c = isEven ? 1.0 : 0.;\n    \n    vec3 rgb = vec3(c);\n\n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 787]]}
{"id": "MtcBRs", "name": "Ripple Bounce", "author": "cherpumples", "description": "Test shader, randomizers over time", "tags": ["ripples"], "likes": 2, "viewed": 205, "published": "Public API", "date": "1580481074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*10.;\n\n    // Time varying pixel color\n    vec3 col = 0.3 + 0.5*cos(uv.xxx+vec3(2,0,-2));\n    col += 0.3 + 0.3*sin(2.*iTime+uv.xxx+vec3(2,0,4));\n    col += 0.5 + 0.5*sin(5.+iTime+uv.xyx+vec3(4,5,2));\n    col += 0.5 + 0.7*cos(1.-iTime*uv.xyy+vec3(2,0,4));\n \n    col -= 0.5 + 0.7*sin(2.+iTime*uv.xyy+vec3(2,0,4));\n   \n     \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 531]]}
{"id": "td33zf", "name": "BabyRayTracer", "author": "tkozjak", "description": "A simple ray tracer. Baby steps. Just a few spheres rendered with a classic ray tracing method. And a torus rendered with SDF.", "tags": ["raytracer"], "likes": 0, "viewed": 40, "published": "Public", "date": "1580061324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// GLOBALS\nvec3 lightDir  = vec3(-1.0, -1.0, 1.0);\nvec4 backColor = vec4(0.2, 0.1, 0.0, 1.0);\n\nvec3 camPos = vec3(0.0, 1.5, 5.0);\nvec3 camDir = vec3(0.0, -0.3, -1.0);\n\n// SDF GLOBALS\nfloat MARCH_START = 0.001;\nint MAX_MARCHING_STEPS = 300;\nfloat EPSILON = 0.01;\nfloat MARCH_END = 100.0;\n\n// function that returns just a hit: yes or no\nbool hit_sphere( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec3 oc = center - camera;\n    float a = dot(ray, ray);\n    float b = 2.0 * dot(oc, ray);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    \n    return (discriminant > 0.0);\n}\n\n// hit function - returns .w = 1 if hit and hitpoint's normal in .xzy\nvec4 hit_sphere_2( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 shift = camera - center;\n    float a = dot(ray, ray); \n    float b = 2.0 * dot( ray, shift );\n    float c = dot( shift,shift ) - radius*radius;\n        \n    float dicsriminant = b*b - 4.0*a*c;\n    \n    float t_0 = ( -b + sqrt( dicsriminant ) )/2.0*a;\n    float t_1 = ( -b - sqrt( dicsriminant ) )/2.0*a;\n    \n    if( dicsriminant >= 0.0 && t_0 > 0.0){\n\n        vec3 p0 = camera + t_0 * ray;\n        result.xyz = normalize(p0-center);\n        result.w = 1.0;\n        return result;\n    }\n    else\n        return result;\n}\n\n// torus SDF\nfloat sdTorus( vec3 point, vec2 t ){\n    \n    vec2 q = vec2(length(point.xz)-t.x, point.y);\n    \n    return length(q)-t.y;\n}\n\n// ray marching function that returns distance\nfloat rayMarch( vec3 camera, vec3 ray, vec3 objectCenter ){\n    float depth = MARCH_START;\n    \n    for( int i=0; i < MAX_MARCHING_STEPS; i++){\n        float distance = sdTorus( camera + depth * ray, vec2(1.2, 0.2) );\n        \n        if( distance < EPSILON ){\n            return depth;\n        }\n        \n        depth += distance;\n        \n        if( depth >= MARCH_END ){\n            return MARCH_END;\n        }\n    }\n    \n    return MARCH_END;\n}\n\nvec4 rayMarch_Normal( vec3 camera, vec3 ray, vec3 objectCenter ){\n    \n    vec4 normal = vec4 (0.0, 0.0, 0.0, 0.0 );\n    \n    float ray_march_distance = rayMarch( camera, ray, vec3(0.0, 0.0, 0.0) );\n        if( ray_march_distance < MARCH_END ){\n        \n        normal.w = 1.0;\n            \n        // calculate normal\n        vec3 hit_point = camera + ray_march_distance * ray;\n        vec3 p_normal = vec3(\n            sdTorus(vec3(hit_point.x + EPSILON,hit_point.y,hit_point.z), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x - EPSILON,hit_point.y,hit_point.z), vec2(1.2, 0.2)),\n            sdTorus(vec3(hit_point.x,hit_point.y + EPSILON,hit_point.z), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x,hit_point.y - EPSILON,hit_point.z), vec2(1.2, 0.2)),\n            sdTorus(vec3(hit_point.x,hit_point.y,hit_point.z + EPSILON), vec2(1.2, 0.2))-sdTorus(vec3(hit_point.x,hit_point.y,hit_point.z - EPSILON), vec2(1.2, 0.2))\n        );\n            \n        normal.xyz = normalize(p_normal);\n        return normal;\n    }\n    \n    return normal;\n}\n\n// hit function - experiment with texture lookup\nvec4 hit_sphere_3( vec3 center, float radius, vec3 ray, vec3 camera ){\n    \n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 shift = camera - center;\n    float a = dot(ray, ray); \n    float b = 2.0 * dot( ray, shift );\n    float c = dot( shift,shift ) - radius*radius;\n        \n    float dicsriminant = b*b - 4.0*a*c;\n    \n    float t_0 = ( -b + sqrt( dicsriminant ) )/2.0*a;\n    float t_1 = ( -b - sqrt( dicsriminant ) )/2.0*a;\n    \n    if( dicsriminant >= 0.0 && t_0 > 0.0){\n\n        vec3 p0 = camera + t_0 * ray;\n        \n        float fi = atan(p0.z, p0.x);\n        float theta = acos( p0.y / radius );\n        vec4 color = texture( iChannel0, vec2(fi, theta));\n        result.xyz = color.rgb;\n        result.w = 1.0;\n        return result;\n    }\n    else\n        return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    //just an input test\n    vec2 normCoords = iMouse.xy / iResolution.xy - vec2(0.5, 0.5);\n    \n    //just an oscilating light test\n    float oscilator = 1.0*sin(iTime);\n    \n    // cosine factor for light\n    float factor = 1.0;\n    \n    // coordinate vector is a vector that describes a position of a fragment/pixel on the screen\n    // origin is at the center of the screen\n    // positive x axis is to right\n    // postive y axis is to up\n    vec2 coordVector;\n    coordVector = vec2(fragCoord.x, fragCoord.y) - vec2(iResolution.x/2.0, iResolution.y/2.0);    \n\n    // view ray is our primary ray\n    // rays are in world space coordinates\n    // we calculate coordinates of a ray from WS camera direction and coordinate vector\n    // (assuming that camera direction points at the center of the projection plane and is perpendicular to it\n    vec3 viewRay = vec3( vec3(coordVector/800.0, 0.0 ) + normalize(camDir) );\n    \n        \n    fragColor = backColor;\n    vec3 oscliatingLightDir = -normalize( vec3( oscilator, lightDir.yz) );\n\n\n    vec4 isHit2;\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*15.0, 1.0 + normCoords.y*15.0, -30.0), 5.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*5.0, 1.0 + normCoords.y*5.0, -15.0), 2.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    \n    isHit2 = hit_sphere_2( vec3(0.0 + normCoords.x*10.0, 1.0 + normCoords.y*10.0, -10.0), 1.0, normalize(viewRay), camPos);\n\n    if( isHit2.w > 0.0 ){\n        factor = clamp(dot(isHit2.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor, factor, factor, 1.0 );\n    }\n    /*\n    float ray_march_distance = rayMarch( camPos, normalize(viewRay), vec3(0.0, 0.0, 0.0) );\n    if( ray_march_distance < MARCH_END ){\n        fragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n    }\n    */\n    \n    vec4 ray_march_normal = rayMarch_Normal( camPos, normalize(viewRay), vec3(0.0, 0.0, 0.0) );\n    if( ray_march_normal.w > 0.0 ){\n        factor = clamp(dot(ray_march_normal.xyz, oscliatingLightDir), 0.0, 1.0);\n        fragColor = vec4( factor * ray_march_normal.xyz, 1.0 );\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td33zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 336, 404, 404, 625], [627, 697, 767, 767, 1351], [1353, 1366, 1402, 1402, 1490], [1492, 1539, 1598, 1598, 1989], [1991, 1991, 2056, 2056, 3020], [3022, 3071, 3141, 3141, 3864], [3870, 3870, 3927, 3953, 6349]]}
{"id": "tdXSR7", "name": "Multipleye", "author": "polymonster", "description": "Based on my friends concept art for a game.", "tags": ["eye"], "likes": 2, "viewed": 200, "published": "Public API", "date": "1579945913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265358979323846264;\n\nvec3 _00 = vec3(252.0, 64.0, 136.0) / 255.0;\nvec3 _01 = vec3(255.0, 237.0, 12.0) / 255.0;\nvec3 _02 = vec3(151.0, 25.0, 121.0) / 255.0;\nvec3 _03 = vec3(80.0, 246.0, 219.0) / 255.0;\nvec3 _10 = vec3(78.0, 249.0, 177.0) / 255.0;\nvec3 _11 = vec3(80.0, 121.0, 250.0) / 255.0;\nvec3 _12 = vec3(180.0, 69.0, 250.0) / 255.0;\nvec3 _13 = vec3(244.0, 66.0, 100.0) / 255.0;\n\n// from gold noise\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat rand(vec2 coordinate, float seed)\n{\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nfloat test(float i, float j)\n{\n    if(i == j)\n        return 1.0;\n    \n    return 0.0;\n}\n\nvec3 rand_col(vec2 index)\n{   \n    vec3 rc = vec3(0.0);\n    \n    rc += _00 * test(index.y, 0.0) * test(index.x, 0.0);\n    rc += _01 * test(index.y, 0.0) * test(index.x, 1.0);\n    rc += _02 * test(index.y, 0.0) * test(index.x, 2.0);\n    rc += _03 * test(index.y, 0.0) * test(index.x, 3.0);\n    rc += _10 * test(index.y, 1.0) * test(index.x, 0.0);\n    rc += _11 * test(index.y, 1.0) * test(index.x, 1.0);\n    rc += _12 * test(index.y, 1.0) * test(index.x, 2.0);\n    rc += _13 * test(index.y, 1.0) * test(index.x, 3.0);\n    rc += _00 * test(index.y, 2.0) * test(index.x, 0.0);\n    rc += _01 * test(index.y, 2.0) * test(index.x, 1.0);\n    rc += _02 * test(index.y, 2.0) * test(index.x, 2.0);\n    rc += _03 * test(index.y, 2.0) * test(index.x, 3.0);\n    rc += _10 * test(index.y, 3.0) * test(index.x, 0.0);\n    rc += _11 * test(index.y, 3.0) * test(index.x, 1.0);\n    rc += _12 * test(index.y, 3.0) * test(index.x, 2.0);\n    rc += _13 * test(index.y, 3.0) * test(index.x, 3.0);\n    \n    return rc;\n}\n\nvec4 eye(vec2 coord)\n{\n    // useful vars\n    vec2 ii = floor(mod(coord, 4.0));\n    vec2 uv = mod(coord, 1.0);\n    vec2 aspect = iResolution.xy / iResolution.yy;\n    \n    vec2 ndc = uv * 2.0 - 1.0;\n    vec2 ppc = ndc * aspect;\n    vec2 ppn = normalize(ppc);\n    \n    vec2 index = (ii);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // eye\n    vec2 ebc = ndc;\n    ebc.y = pow(abs(ebc.y), 1.0/1.5);\n    float r = step(length(ebc), 0.7);\n    vec3 eyelid = vec3(r, r, r);\n    \n    // eye ball\n    float cd = 0.0;\n    \n    float t = iTime * 0.00001;\n    float pt = t - 0.001;\n    float nt = t + 0.001;\n    \n    float prx = floor(rand(index, pt) * 4.0);\n    float pry = floor(rand(index, pt) * 4.0);\n    \n    float rx = floor(rand(index, t) * 4.0);\n    float ry = floor(rand(index, t) * 4.0);\n    \n    if(length(index - vec2(rx, ry)) < 0.2 )\n        cd = 1.0;\n    \n    float open = 1.0/2.2;\n    float closed = 1.0/20.0;\n    float closedness = mix(open, closed, cd);\n    ebc.y = pow(abs(ebc.y), closedness);\n    r = step(length(ebc), 0.7);\n    vec3 eyeball = vec3(r, r, r);\n    \n    // pupil\n    r = step(length(ppc), 0.2);\n    vec3 pupil = vec3(r, r, r);\n    vec3 pupil_col = vec3(length(ppc));\n    \n    // iris\n    r = step(length(ppc), 0.4);\n    vec3 iris = vec3(r, r, r);\n    \n    r = length(ppc);\n    float at = atan(ppn.x, ppn.y) + sin(iTime);\n    float mat = mod(at, pi / 10.0);\n                    \n    //vec3 iris_col = mix(vec3(0.2, 0.5, 0.9), vec3(0.2, 0.9, 0.9), mat);\n    \n    vec3 iris_col = rand_col(index.yx);\n            \n    col = (eyeball * vec3(1.0, 1.0, 1.0)) * (1.0 - iris);\n   \tcol += iris_col * iris * eyeball * (1.0 - pupil);\n    col += pupil_col* pupil * eyeball;\n    col += rand_col(index) * (1.0 - eyeball) * eyelid;\n    \n    return vec4(col, eyelid);\n}\n\nvec3 bg_func(vec2 uv)\n{\n    float x = uv.x + iTime;\n    float y = uv.y;\n    float yv = uv.y * 2.0 - 1.0;\n    float m = 0.0;\n    \n    if(yv < 0.0)\n    \tm = step(mod(x + y, 0.4), 0.2);\n    else\n    \tm = 1.0 - step(mod(x - y, 0.4), 0.2);\n        \n    vec3 bg3 = mix(_02, _03, sin(iTime*10.0));\n    vec3 bg4 = mix(_12, _13, cos(iTime*10.0));\n    \n    vec3 bg2 = mix(mix(_00, _01, sin(iTime * 5.0) * 0.5 + 0.5), bg3, sin(iTime * 5.0));\n    vec3 bg1 = mix(mix(_10, _11, cos(iTime * 5.0) * 0.5 + 0.5), bg4, sin(iTime * 5.0));\n   \n    vec3 bg = mix(bg1, bg2, m);\n    \n    return bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 _uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    vec2 aspect = iResolution.xy / iResolution.yy;\n    \n    uv.x += sin(iTime * 10.0 + uv.y * 10.0) * 0.01;\n    \n    // eyes   \n    vec2 num = vec2(1.0, 1.0) + vec2(floor(mod(iTime / 4.0, 8.0)));\n    vec4 eyes = eye(uv * num + vec2(iTime, 0.0));\n    \n    // bg\n\tvec3 bg = bg_func(uv);\n\n    // led / pixels\n    float led_size = 0.00005;\n    float edge = 0.04;\n    vec2 led_size2 = vec2(led_size, led_size) / aspect;\n    vec2 mm = mod(_uv * aspect, led_size);\n    vec2 mv = smoothstep(0.0, led_size, mm);\n    vec2 led = step(mv, vec2(edge) * aspect);\n    float third = 1.2/3.0;\n    float led_r = step(mv.x, third);\n    float led_g = step(mv.x, third * 2.0) * (1.0 - led_r);\n    float led_b = step(mv.x, third * 3.0) * (1.0 - led_r) * (1.0 - led_g);\n    vec3 led_rgb = vec3(led_r, led_g, led_b) * clamp(1.0 - (led.x + led.y), 0.0, 1.0);\n        \n   \tbg *= led_rgb;\n        \n    vec3 col = bg * (1.0 - eyes.a);\n    col += eyes.a * eyes.rgb;\n    \n    //col = bg;\n    \n    // output\n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 614, 655, 655, 732], [734, 734, 764, 764, 822], [824, 824, 851, 851, 1818], [1820, 1820, 1842, 1861, 3594], [3596, 3596, 3619, 3619, 4172], [4174, 4174, 4231, 4231, 5366]]}
{"id": "tl33Dl", "name": "Joseph Albers, Squares 1", "author": "danamuise", "description": " This is a color experiment based on Color Squares by Joseph Albers. The two smaller boxes are the same color. They appear to change as their surrounding colors change. This is an illusion, showing how they eye is influenced by multiple colors. ", "tags": ["josephalbers"], "likes": 2, "viewed": 1197, "published": "Public API", "date": "1577923416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 DrawBox(vec2 uv, float L, float R, float B, float T, vec3 col){\n\tvec3 colorBox = vec3(0.0);\n    \n    if (uv.x>L && uv.x<R && uv.y>B && uv.y<T) {\n       colorBox = vec3(col.r/255.0,col.g/255.0,col.z/255.0);\n    }\n    return colorBox; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colorA = vec3(237.0, 139.0, 53.0);\n\tvec3 colorB = vec3(239.0, 234.0, 106.0);\n    vec3 colorC = vec3(56.0, 61.0, 127.0);\n\tvec3 colorD = vec3(85.0, 138.0, 176.0);\n    vec3 brown = vec3(162.0/255.0,94.0/255.0,36.0/255.0);\n    \n    // Time varying pixel color\n    vec3 color = vec3(0.5);\n    \n    float pct = abs(sin(iTime*.25));\n\n    // fill left1\n    color = DrawBox(uv, 0.0, 0.25, 0.0, 1.0, mix(colorA, colorC, pct));\n\n    // fill left2\n    color += DrawBox(uv, 0.25, 0.5, 0.0, 1.0, mix(colorB, colorD, pct));\n    \n    // fill right1\n    color += DrawBox(uv, 0.5, 0.75, 0.0, 1.0, mix(colorC, colorA, pct));\n    \n    // fill right2\n    color += DrawBox(uv, 0.75, 1.0, 0.0, 1.0, mix(colorD, colorB, pct));\n    \n    // fill boxL\n    \n    if (uv.x>0.25*0.5 && uv.x<0.25 && uv.y>0.5*0.75 && uv.y<0.5/0.75) {\n       color = brown;\n    }\n    \n    // fill boxR\n    if (uv.x>0.75 && uv.x<0.75/.85 && uv.y>0.5*0.75 && uv.y<0.5/0.75) {\n       color = brown;\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 240], [242, 242, 299, 349, 1414]]}
{"id": "tl33Rl", "name": "Ball in several metric spaces", "author": "tomoe", "description": "ball, cube and octahedron", "tags": ["imi202001"], "likes": 2, "viewed": 193, "published": "Public API", "date": "1578290734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\nuniform float u_time;\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\n#define PI 3.14159265359\nfloat kyoto(vec3 p){\n    float scale = 1.0 / sqrt(2.0);\n    return scale * (abs(p.x) + abs(p.y) + abs(p.z));\n}\nfloat shogi(vec3 p) {\n    float scale = sqrt(2.0);\n    return scale * max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\nfloat euc(vec3 p){\n    float scale = 1.0;\n    return scale * length(p);\n}\nfloat dist(vec3 p){\n    float t = abs(mod(0.5 * iTime, 4.0) - 2.0);\n    return mix(\n        mix(euc(p), shogi(p), clamp(t, 0.0, 1.0)),\n        kyoto(p), clamp(t - 1.0, 0.0, 1.0)\n    );\n}\nfloat ballSDF(vec3 p) {\n    return dist(p) - 1.;\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        ballSDF(p + vec3(d, 0.0, 0.0)) - ballSDF(p + vec3(-d, 0.0, 0.0)),\n        ballSDF(p + vec3(0.0, d, 0.0)) - ballSDF(p + vec3(0.0, - d, 0.0)),\n        ballSDF(p + vec3(0.0, 0.0, d)) - ballSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\nmat3 euler(float h, float p, float r){\n    return mat3(\n        cos(r)*cos(h)-sin(r)*sin(p)*sin(h), -sin(r)*cos(p), cos(r)*sin(h)+sin(r)*sin(p)*cos(h),\n        sin(r)*cos(h)+cos(r)*sin(p)*sin(h), cos(r)*cos(p), sin(r)*sin(h)-cos(r)*sin(p)*cos(h),\n        -cos(p)*sin(h), sin(p), cos(p)*cos(h)\n    ); \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.5 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightPos = g *vec3(0.0, 1.0, 1.0);\n\n    // ray\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    ray = ray / dist(ray);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 60; i++ ) {\n        rPos += ray * ballSDF(rPos);\n    }\n    \n    // collision detection\n    if (abs(ballSDF(rPos)) < 0.001) { //object\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), gradSDF(rPos)), 0.0, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {    //background\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl33Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 141, 141, 231], [232, 232, 253, 253, 343], [344, 344, 362, 362, 417], [418, 418, 437, 437, 604], [605, 605, 628, 628, 655], [656, 656, 678, 678, 960], [961, 961, 999, 999, 1263], [1264, 1264, 1319, 1344, 2356]]}
{"id": "tl3Xzn", "name": "RayTraceRefractions", "author": "JackSolace", "description": "Ray trace of a half-spheer lens to showcase reflections and refractions", "tags": ["ray", "lens", "light", "sphere", "animated", "reflect", "refract", "learn"], "likes": 2, "viewed": 42, "published": "Public", "date": "1580269671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Jan 2020\n//Basic Raytrace of a Moving Sphere with Reflections and Refractions.\n//normally these checks would be done recursively but for educational purpses it is often\n//easier to see it done iteratively\n//The Reflections and Refractions are only calculated for one bounce\n//This is closer to a halfSphere \"Lens\" than a true glass sphere (need lots of bounces)\n#define PI 3.14159265359\n\nstruct Ray {\n\tvec3 origin; // Origin of ray (not to be confused with world origin)\n\tvec3 direction; // Direction Normalized vector\n};\n\nstruct Sphere {\n    int objID;\n\tvec3 center;  // Center of the Sphere\n\tfloat radius; // Radius of the Sphere\n};\n    \nstruct Plane {\n    int objID;\n\tvec3 normal; //Normal vector\n    vec3 point; //Some point such that for all points p in the plane dot((p-point),normal) == 0\n};\n\n//Simplest light source\nstruct PointLight {\n    vec3 position; //3d point in space\n    vec4 color; //RGBA color\n};\n\n    \n//Move the Sphere over time\nvoid AnimateSphere(inout Sphere sphere) {\n    //Size of the animation loop\n\tfloat loopRadius = 4.0;\n    //initial sphere position\n    float loopOffset = sphere.center.z;\n    //time it takes to complete a loop\n    float loopTime = 8.0;\n    \n    //Based on parametric equations of a circle\n    sphere.center.x = sin((mod(iTime, loopTime))/loopTime*2.0*PI)*loopRadius;\n    sphere.center.z = loopOffset + cos((mod(iTime,loopTime))/loopTime*2.0*PI)*loopRadius;\n    \n}\n    \n//Get the Specular color (shiny light)\nvec4 calculateSpecular(in vec3 rayd, in vec3 normal, in vec3 toLight, in PointLight light) {\n    //specular exponent\n    float shinnyness = 5.0;\n    //get the reflected light vector\n    vec3 reflected = 2.0*dot(toLight, normal)*normal - toLight;\n    //calculate specular color\n    return light.color * max(0.0,pow(dot(rayd,reflected),shinnyness));\n}\n    \n//Get the Diffuse color (Basic light effect)\nvec4 calculateDiffuse(in vec3 normal, in vec3 toLight, in PointLight light) {\n    return light.color * max(0.0,dot(normal,toLight));\n}\n    \n//Get the direction to the light source (no shadows simplifies check)\nvec3 checkLight(in vec3 intersect, in PointLight light) {\n    return normalize(light.position - intersect);\n}\n\n//Get the sphere surface normal from the intersection point\nvec3 getSphereIntersectionNormal(in vec3 intersect, in Sphere sphere) {\n\treturn normalize(intersect - sphere.center);\n} \n\n//Get the 3d point that is depth along the ray\nvec3 calculateIntersectionPoint(in Ray ray, in float depth) {\n\treturn ray.origin + ray.direction*depth;\n}\n    \n// From the Wikipedia page on Line-Plane intersection\nfloat intersectPlane(in Ray ray, in Plane plane) {\n\tfloat denominator = dot(plane.normal,ray.direction);\n    if(abs(denominator) >= 0.001) {//make sure Ray is not parallel to plane (or nearly parallel)\n        return dot((plane.point - ray.origin),plane.normal)/denominator;\n    }\n\treturn -1.0; // Any negative number to indicate no intersect (or intersection from behind)\n}\n\n// From the Wikipedia page on Line-sphere intersection\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance from the ray origin to point of intersection\n    //bear in mind that there may be more than one solution\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, get ray intersection depth\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant);\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nfloat performPlaneCheck(in Ray ray, in Plane plane, in Sphere sphere, out vec4 color){\n//code for plane Check\n// Check if the ray from the camera through the pixel intersects the Plane\n\tfloat intersectionDepth = intersectPlane(ray,plane);\n    if (intersectionDepth >= 0.001 && intersectionDepth <= 1000.0) {//Front and Back Culling\n    \t//Point light is purple and a little to the left and aboveof the camera start\n    \tPointLight light = PointLight(vec3(-5.0,5.0,0.0), vec4(1.0,1.0,1.0,1.0));\n    \t//Get the ray intersection Point\n    \tvec3 intersect = calculateIntersectionPoint(ray,intersectionDepth);\n    \t//Initialize Plane color\n    \tvec4 ambientPlaneColor = vec4(0.0,0.0,0.0,1.0);\n    \t\n        //set Texture to appropriate material\n        if (plane.objID == 1) {\n        \tambientPlaneColor = texture(iChannel0,intersect.xz);\n        }else {\n        \tambientPlaneColor = texture(iChannel1,intersect.xy);\n        }\n        \n        \n    \t//Get the direction to the lightsource from the intersection point\n    \tvec3 toLight = checkLight(intersect, light);\n    \t//contruct Ray for shadow check\n    \tRay shadowRay = Ray(intersect, toLight);\n    \t//Do a shadow check\n    \tfloat shadowIntersectionDepth = intersectSphere(shadowRay,sphere);\n    \tif (shadowIntersectionDepth >= 0.05) { //Sphere is blocking the Light\n        \tcolor = ambientPlaneColor;\n    \t}else{ //Light is visable from this point\n        \tcolor = ambientPlaneColor + 0.25*calculateDiffuse(plane.normal, toLight, light);\n    \t}\n        return intersectionDepth;\n    }else{\n        // else draw background color (black)\n\t\tcolor = vec4(0.0,0.0,0.0,1.0);\n        return -1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // output a 4d fragment color vector [R,G,B,A]\n    // input is a 2d fragment Co-ordinate vector [X,Y]\n    // can interpret input vector as a pixel (function is called 640x360 times by default per frame)\n    \n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat u = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat v = fragCoord.y / iResolution.y; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the image\n\tu = u * 2.0 - 1.0;\n\tv = v * 2.0 - 1.0;\n\n    //the following line is necessary since the image may not be a square\n    //removing this line results in the x dimension being stretched\n    u *= (iResolution.x/iResolution.y);\n    \n\t// The position of this pixel in 3D space \n    //(imagine a plane centered at the origin perpendicular to the camera, what would be the 3d coordinates of this pixel?)\n\tvec3 pixelPos = vec3(u, v, 0);\n\n    // The camera position in this example is on a fixed loop.\n    // Initialize at 0.0\n    vec3 cameraPos = vec3(0.0, 0.0, -4.0); \n    \n\t// The ray direction is ray from the camera through the pixel\n\tvec3 rayDir = normalize(pixelPos - cameraPos);\n    \n    // The Sphere is at the origin\n    Sphere sphere = Sphere(0,vec3(0.0, 0.0, 7.0), 1.0);\n    \n    //Animate the Sphere\n    AnimateSphere(sphere);\n    \n    // The wooden plane is the xz plane at y = -2.0\n    Plane woodPlane = Plane(1,vec3(0.0,1.0,0.0),vec3(0.0,-2.0,0.0));\n    \n    // The tile plane is the xy plane at z = 12.0\n    Plane tilePlane = Plane(2,vec3(0.0,0.0,-1.0), vec3(0.0,0.0,15.0));\n\n    //Create Ray struct from origin through current pixel\n    Ray ray = Ray(cameraPos, rayDir);\n    \n\t// Check if the ray from the camera through the pixel intersects the sphere\n\tfloat intersectionDepth = intersectSphere(ray, sphere);\n\n\t// If the depth at which the ray intersects the sphere is positive (in front of camera)\n\tif (intersectionDepth >= 0.05)//Sphere Check\n\t{//draw the sphere color (basic ambient + diffuse)\n        //ambient color of the sphere is greyish\n        vec4 ambientSphereColor = vec4(0.2,0.2,0.2,1.0);\n        \n        //Point light is white and a little to the left of the camera start\n        PointLight light = PointLight(vec3(-3.0,0.0,0.0), vec4(0.5,0.5,0.5,1.0));\n        \n        //Get the ray intersection Point\n        vec3 intersect = calculateIntersectionPoint(ray, intersectionDepth);\n        \n        //Get the surface normal at that point\n\t\tvec3 normal = getSphereIntersectionNormal(intersect,sphere);\n        \n        //Get the direction to the lightsource from the intersection point\n        vec3 toLight = checkLight(intersect, light);\n        \n        //we are going to skip the checks for shadows for the sphere\n        //but in other scenes we will not have this luxury\n        \n        //Refract Ray see https://en.wikipedia.org/wiki/Refraction for math details\n        vec3 refracted = refract(ray.direction,normal, 0.7);//1.0/1.2 is index of refraction for glass\n        Ray refractedRay = Ray(intersect,refracted);\n        \n        vec4 woodColor = vec4(0.0,0.0,0.0,0.0);//Initialize colors\n        vec4 tileColor = vec4(0.0,0.0,0.0,0.0);\n        \n        //This is a lazy way of handling 2 planes in a scene\n        float intersectedWood = performPlaneCheck(refractedRay,woodPlane,sphere, woodColor);\n        float intersectedTile = performPlaneCheck(refractedRay,tilePlane,sphere, tileColor);\n        vec4 refColor = vec4(0.0,0.0,0.0,0.0);\n        if (intersectedWood < 0.0)\n        {\n        \trefColor = tileColor;\n        }else if (intersectedTile <= intersectedWood){\n        \trefColor = tileColor;\n        }else{\n            refColor = woodColor;\n        }\n        \n        //calculate reflected Ray (normalize here is because im paranoid)\n        vec3 reflected = normalize(ray.direction - 2.0*dot(ray.direction, normal)*normal);\n        Ray rayreflect = Ray(intersect,reflected);\n          \n        //initialize reflected color\n        vec4 reflectColor = vec4(1.0,1.0,1.0,1.0);\n        //Plane Check\n        float intersected = performPlaneCheck(rayreflect,woodPlane,sphere,reflectColor);\n        //For this Scene we can skip the tilePlane check on reflections since\n        //we cannot reflect from the sphere to the back wall.\n        if (intersected > 0.0){\n        \t//Combine it all to get the correct color (with reflected and refracted Color (mostly refracted))\n        \tfragColor = 0.25*ambientSphereColor + 0.25*calculateDiffuse(normal,toLight,light) + 0.15*reflectColor + 0.35*refColor;\n        }else{\n        \t//Combine it all to get the correct color (with refracted)\n        \tfragColor = 0.33*ambientSphereColor + 0.17*calculateDiffuse(normal,toLight,light) + 0.5*refColor;\n        }\n        \n    } else {//Plane Checks (No Sphere Hit)\n        vec4 woodColor = vec4(0.0,0.0,0.0,0.0);//Initialize colors\n        vec4 tileColor = vec4(0.0,0.0,0.0,0.0);\n        \n        //This is a lazy way of handling 2 planes in a scene\n        float intersectedWood = performPlaneCheck(ray,woodPlane,sphere, woodColor);\n        float intersectedTile = performPlaneCheck(ray,tilePlane,sphere, tileColor);\n        \n        if (intersectedWood < 0.0)\n        {\n        \tfragColor = tileColor;\n        }else if (intersectedTile <= intersectedWood){\n        \tfragColor = tileColor;\n        }else{\n            fragColor = woodColor;\n        }\n        //Ideally a well coded ray tracer would handle these checks generically for all obj's in a scene\n        //This is a toy example\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3Xzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[933, 961, 1002, 1035, 1423], [1429, 1468, 1560, 1584, 1817], [1823, 1868, 1945, 1945, 2002], [2008, 2078, 2135, 2135, 2187], [2189, 2249, 2320, 2320, 2368], [2371, 2418, 2479, 2479, 2523], [2529, 2583, 2633, 2633, 2957], [2959, 3014, 3067, 3099, 3675], [3677, 3677, 3763, 3861, 5326], [5328, 5328, 5385, 5660, 10943]]}
{"id": "tlcSR8", "name": "de_ko_bo_ko", "author": "zephyran", "description": "life", "tags": ["cineshader"], "likes": 0, "viewed": 3925, "published": "Public API", "date": "1580355575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv2 *= 16.;\n    \n    vec2 gv = fract(uv2);\n    vec2 id = floor(uv2);\n    \n    float r = Hash21(id);\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 4.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, r+(sin(iTime*r)*.5));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"dekoboko\",\n\t\"description\": \"life\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 116], [118, 118, 175, 225, 919]]}
{"id": "tlcSRH", "name": "HSB test", "author": "tonywu", "description": "for test", "tags": ["hsb"], "likes": 2, "viewed": 222, "published": "Public API", "date": "1580371978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 brickTile2(vec2 _st, float _zoom){\n    _st *= _zoom;\n\n    // Here is where the offset is happening\n    _st.y += step(1., mod(_st.x,2.0)) * 0.5 *iTime;\n\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = iTime*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\n\nfloat rectShape(vec2 position, vec2 scale){\n    scale = vec2(0.5) - scale * 0.5;\n    vec2 shaper = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shaper *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n    return shaper.x * shaper.y;\n}\n\nfloat circleShape(vec2 position, float radius){\n    return step(radius, length(position - vec2(0.5)));\n}\n\nfloat polygonShape(vec2 position, float radius, float sides){\n    position = position * 2.0 - 1.0;\n    float angle = atan(position.x, position.y);\n    float slice = PI * 2.0 / sides;\n    return step(radius, cos(floor(0.5 + angle / slice) * slice - angle) * length(position));\n}\n\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = fragCoord/iResolution.xy;\n    // Divide the space in 4\n    //uv = tile(uv,4.);\n    //uv = brickTile2(uv, 4.);\n    uv = movingTiles(uv,4.,0.5);\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    \n    //int tx = int(uv.x*512.0);\n    int tx = 3;\n     \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    position -= vec2(0.5);\n    // rotate the space\n    position = rotate2d( sin(iTime)*PI*fft ) * uv;\n    position = scale(vec2(0.8*sin(fft))) * position;\n    // move it back to the original place\n    position += vec2(0.5);\n    \n  \n    \n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.)-uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3(radius-iTime,abs(sin(angle+fft*iTime)),1.));\n       \n    color -= vec3(0.,0.,rectShape(position,vec2(1.,abs(sin(fft))-0.5)));\n    color -= vec3(rectShape(position,vec2(abs(sin(fft))-0.5,1.)),0.,0.);\n    \n\n\n    fragColor = vec4(color*1.5*cos(fft),1.0);\n    //fragColor.rgb = pow(color, vec3(1./2.2));\n    // apply gamma correction\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 50, 50, 136], [138, 138, 162, 162, 225], [227, 227, 260, 260, 303], [305, 305, 343, 343, 485], [487, 487, 526, 526, 668], [670, 670, 724, 724, 1130], [1133, 1133, 1176, 1176, 1411], [1413, 1413, 1460, 1460, 1517], [1519, 1519, 1580, 1580, 1796], [1799, 1799, 1825, 1825, 2058], [2060, 2060, 2117, 2167, 3632]]}
{"id": "tlcSzN", "name": "Illusions of squares", "author": "Roninkoi", "description": "Squarey!", "tags": ["square"], "likes": 4, "viewed": 110, "published": "Public", "date": "1580500973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    uv *= 2.5;\n    \n    float a = iTime * 0.2;\n    \n    float x0 = uv.x;\n    uv.x = x0 * cos(a) - uv.y * sin(a);\n    uv.y = x0 * sin(a) + uv.y * cos(a);\n    \n    vec3 ca = 1.0*(1.*iTime+uv.x+vec3(0,2.*PI/3.,4.*PI/3.));\n    vec3 sa = 1.0*(2.0*iTime+uv.x+vec3(0,2.*PI/3., 4.*PI/3.));\n    \n    vec3 col = 0.25 + 0.25*cos(ca) + 0.25*sin(sa);\n    col /= length(uv*uv*uv*uv*uv*uv);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 588]]}
{"id": "tlcSzr", "name": "Spherical harmonics spheroid SDF", "author": "16807", "description": "Click to rotate. The sdf for the blob was approximated as a sphere where radius for a given unit vector is expressed using spherical harmonics . Green indicates larger radius, red indicates smaller radius. Try changing values on lines 144-148 for fun!", "tags": ["raymarching", "sdf", "sphericalharmonics", "signeddistancefunction"], "likes": 1, "viewed": 87, "published": "Public", "date": "1580362003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nfloat get_spherical_harmonics(\n    in vec3 V,\n                                                                in float f00,\n                                                 in float f1n1, in float f10, in float f11, \n                                  in float f2n2, in float f2n1, in float f20, in float f21, in float f22, \n                   in float f3n3, in float f3n2, in float f3n1, in float f30, in float f31, in float f32, in float f33,\n    in float f4n4, in float f4n3, in float f4n2, in float f4n1, in float f40, in float f41, in float f42, in float f43, in float f44\n){\n\n    float x = V.x;\n    float y = V.y;\n    float z = V.z;\n\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n\n    float xy = x*y;\n    float yz = y*z;\n    float zx = z*x;\n\n    float xyz = x*y*z;\n\n    float r = length(V);\n    float r2 = r*r;\n    float r3 = r*r*r;\n    float r4 = r*r*r*r;\n\n    return\n          f00  * 0.5f*sqrt(1.f/PI)  \n\n        + f1n1 * sqrt(0.75f/PI) * y/r  \n        + f10  * sqrt(0.75f/PI) * z/r  \n        + f11  * sqrt(0.75f/PI) * x/r \n\n        + f2n2 * 0.50f*sqrt(15.f/PI) *  xy/r2 \n        + f2n1 * 0.50f*sqrt(15.f/PI) *  yz/r2 \n        + f20  * 0.25f*sqrt(5.0f/PI) * (-x2-y2+2.f*z2)/r2 \n        + f21  * 0.50f*sqrt(15.f/PI) *  zx/r2 \n        + f22  * 0.25f*sqrt(15.f/PI) * (x2-y2)/r2  \n\n        + f3n3 * 0.25f*sqrt(35.0f/(2.f*PI)) * (3.f*x2-y2)*y/r3\n        + f3n2 * 0.50f*sqrt(105.f/     PI)  * (xyz)/r3\n        + f3n1 * 0.25f*sqrt(21.0f/(2.f*PI)) * (y*(4.f*z2-x2-y2))/r3\n        + f30  * 0.25f*sqrt(7.00f/     PI)  * (z*(2.f*z2-3.f*x2-3.f*y2))/r3\n        + f31  * 0.25f*sqrt(21.0f/(2.f*PI)) * (x*(4.f*z2-x2-y2))/r3\n        + f32  * 0.25f*sqrt(105.f/     PI)  * (z*(x2-y2))/r3\n        + f33  * 0.25f*sqrt(35.0f/(2.f*PI)) * (x*(x2-3.f*y2))/r3\n\n        + f4n4 * 0.75  * sqrt(35.f/(    PI)) * (xy*(x2-y2))/r4 \n        + f4n3 * 0.75  * sqrt(35.f/(2.f*PI)) * ((3.f*x2-y2)*yz)/r4\n        + f4n2 * 0.75  * sqrt(5.f /(    PI)) * (xy*(7.f*z2-r2))/r4\n        + f4n1 * 0.75  * sqrt(5.f /(2.f*PI)) * (yz*(7.f*z2-3.f*r2))/r4\n        + f40  * 0.1875* (35.f*z2*z2-30.f*z2*r2+3.f*r4)/r4\n        + f41  * 0.75  * sqrt(5.f /(2.f*PI)) * (zx*(7.f*z2-3.f*r2))/r4\n        + f42  * 0.375 * sqrt(5.f /(    PI)) * ((x2-y2)*(7.f*z2-r2))/r4\n        + f43  * 0.75  * sqrt(35.f/(2.f*PI)) * ((x2-3.f*y2)*zx)/r4\n        + f44  * 0.1875* sqrt(35.f/(    PI)) * (x2*(x2-3.f*y2) - y2*(3.f*x2-y2))/r4 \n      ;\n}\n/*\n\"get_distance_from_point_to_spherical_harmonics_blob\" returns the \nsigned distance of a point to the surface of a spheroid whose surface is \noffset using a linear combination of spherical harmonics. \n\nA0 point position\nB0 blob origin\nr  blob reference radius\n  the radius of a sphere where f00==1 and f1n1..f22 == 0\nf00..f22 blob expansion coefficients\n  the expansion coefficients to the spherical harmonics series\n  that describe the radius of a blob at a given set of lat long coordinates\n*/\nfloat get_distance_of_3d_point_to_spherical_harmonics_blob(\n    in vec3 A0,\n    in vec3 B0,\n    in float r0,\n                                                                in float f00,\n                                                 in float f1n1, in float f10, in float f11, \n                                  in float f2n2, in float f2n1, in float f20, in float f21, in float f22, \n                   in float f3n3, in float f3n2, in float f3n1, in float f30, in float f31, in float f32, in float f33,\n    in float f4n4, in float f4n3, in float f4n2, in float f4n1, in float f40, in float f41, in float f42, in float f43, in float f44\n){\n    vec3 D = A0-B0; // offset\n    vec3 Dhat = normalize(D);\n    float fijYij = get_spherical_harmonics(\n        Dhat, \n                                f00,\n                          f1n1, f10, f11, \n                    f2n2, f2n1, f20, f21, f22, \n              f3n3, f3n2, f3n1, f30, f31, f32, f33, \n        f4n4, f4n3, f4n2, f4n1, f40, f41, f42, f43, f44\n    );\n\n    return length(D) - r0*fijYij; \n}\n\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float r = 0.5f*sqrt(1.f/PI);\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction;\n    vec3 At = A0;\n    \n    float t = 0.f;\n    float sdf = 0.f;\n    const int MAX_STEP_COUNT = 10;\n    const float MIN_SDF = 0.01;\n    const float MAX_T = 10.f;\n    \n    int i;\n    for ( i = 0; i< MAX_STEP_COUNT; i++)\n    {\n        sdf = get_distance_of_3d_point_to_spherical_harmonics_blob(\n            \tAt, vec3(0,0,0), 1.0f,\n            \n                                        1.0f,\n                                  0.0f, 0.2f, 0.0f,\n                            0.0f, 0.0f, 0.0f, 0.2f, 0.0f,\n                      0.0f, 0.0f, 0.0f, 0.1f, 0.0f, 0.0f, 0.0f,\n                0.1f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f\n        \t);\n        if ( sdf < MIN_SDF || t > MAX_T) break;\n        t += sdf;\n        At += A*sdf;\n    }\n    \n    vec3  color = sdf < MIN_SDF && t < MAX_T? \n        vec3(r-length(At), length(At)-r, 0) * 30.f + vec3(0.01) : \n        vec3(0);\n    \n    fragColor = vec4(color/4.f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 601, 601, 2410], [2411, 2909, 3551, 3551, 3952], [3957, 3957, 4007, 4007, 4635], [4637, 4637, 4694, 4694, 6336]]}
{"id": "tlcXz8", "name": "Animated blob", "author": "16807", "description": "An animated blob composed of spherical harmonics. It undulates rhythmically. \nI took my earlier demo from [here](https://www.shadertoy.com/view/tlcSzr) and animated it. ", "tags": ["raymarching", "sdf", "animated", "sphericalharmonics"], "likes": 2, "viewed": 81, "published": "Public", "date": "1580365786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\n\n\n/*\n\"get_distance_from_point_to_spherical_harmonics_blob\"\nreturns the signed distance of a point to the surface of \na blob formed from spherical harmonics. \n\nA0 point position\nB0 blob origin\nr  blob reference radius\n  the radius of a sphere where f00==1 and f1n1..f22 == 0\nf00..f22 blob expansion coefficients\n  the expansion coefficients to the spherical harmonics series\n  that describe the radius of a blob at a given set of lat long coordinates\n*/\nfloat get_distance_of_3d_point_to_spherical_harmonics_blob(\n    in vec3 A0,\n    in vec3 B0,\n    in float r0,\n\n    in float f00,\n\n    in float f1n1,\n    in float f10,\n    in float f11,\n\n    in float f2n2,\n    in float f2n1,\n    in float f20,\n    in float f21,\n    in float f22,\n\n    in float f3n3,\n    in float f3n2,\n    in float f3n1,\n    in float f30,\n    in float f31,\n    in float f32,\n    in float f33\n){\n    vec3 D = A0-B0; // offset\n    vec3 Dhat = normalize(D);\n\n    float x = Dhat.x;\n    float y = Dhat.y;\n    float z = Dhat.z;\n\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n\n    float xy = x*y;\n    float yz = y*z;\n    float zx = z*x;\n\n    float xyz = x*y*z;\n\n    float r = 1.f;//length(D);\n    float r2 = r*r;\n    float r3 = r*r*r;\n\n    float fijYij = \n          f00  * 0.5f*sqrt(1.f/PI)  \n\n        + f1n1 * sqrt(0.75f/PI) * y/r  \n        + f10  * sqrt(0.75f/PI) * z/r  \n        + f11  * sqrt(0.75f/PI) * x/r \n\n        + f2n2 * 0.50f*sqrt(15.f/PI) *  xy/r2 \n        + f2n1 * 0.50f*sqrt(15.f/PI) *  yz/r2 \n        + f20  * 0.25f*sqrt(5.0f/PI) * (-x2-y2+2.f*z2)/r2 \n        + f21  * 0.50f*sqrt(15.f/PI) *  zx/r2 \n        + f22  * 0.25f*sqrt(15.f/PI) * (x2-y2)/r2  \n\n        + f3n3 * 0.25f*sqrt(35.0f/(2.f*PI)) * (3.f*x2-y2)*y/r3\n        + f3n2 * 0.50f*sqrt(105.f/     PI)  * (xyz)/r3\n        + f3n1 * 0.25f*sqrt(21.0f/(2.f*PI)) * (y*(4.f*z2-x2-y2))/r3\n        + f30  * 0.25f*sqrt(7.00f/     PI)  * (z*(2.f*z2-3.f*x2-3.f*y2))/r3\n        + f31  * 0.25f*sqrt(21.0f/(2.f*PI)) * (x*(4.f*z2-x2-y2))/r3\n        + f32  * 0.25f*sqrt(105.f/     PI)  * (z*(x2-y2))/r3\n        + f33  * 0.25f*sqrt(35.0f/(2.f*PI)) * (x*(x2-3.f*y2))/r3\n      ;\n\n    return length(D) - (r0*fijYij); \n}\n\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float r = 0.5f*sqrt(1.f/PI);\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction;\n    vec3 At = A0;\n    \n    float t = 0.f;\n    float sdf = 0.f;\n    const int MAX_STEP_COUNT = 10;\n    const float MIN_SDF = 0.01;\n    const float MAX_T = 10.f;\n    \n    int i;\n    for ( i = 0; i< MAX_STEP_COUNT; i++)\n    {\n        sdf = get_distance_of_3d_point_to_spherical_harmonics_blob(\n            \tAt, vec3(0,0,0), 1.0f,\n            \n                                 1.0f,\n                           0.0f, 0.3f*cos(1.2*iTime), 0.0f,\n                      0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n                0.0f, 0.2f*cos(0.5*iTime), 0.0f, 0.1f*cos(0.4*iTime), 0.0f, 0.0f, 0.1f\n        \t);\n        if ( sdf < MIN_SDF || t > MAX_T) break;\n        t += sdf;\n        At += A*sdf;\n    }\n    \n    vec3  color = sdf < MIN_SDF && t < MAX_T? \n        vec3(r-length(At), length(At)-r, r-length(At)+0.1) * 30.f + vec3(0.01) : \n        vec3(0);\n    \n    fragColor = vec4(color/4.f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 618, 1026, 1026, 2309], [2314, 2314, 2364, 2364, 2992], [2994, 2994, 3051, 3051, 4657]]}
{"id": "tldGDs", "name": "original-27173-2", "author": "jorge2017a1", "description": "original-27173-2", "tags": ["original271732"], "likes": 11, "viewed": 134, "published": "Public", "date": "1578023940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//////my small shader demo.....  \n// todo : text or something on the blue screen ->lookat screen with cam...\n//  feel free to mod it ;-)\n\n\n//Modificado por Jorge f.p fecha- 02/ene/2020\n\n//#define size resolution\nbool bColoring=false;//i luv globals\nvec3 mcol;\n\nconst float mr=0.25, mxr=1.0;\nconst vec4 scale=vec4(-3.12,-3.12,-3.12,3.12),p0=vec4(0.0,1.59,-1.0,0.0);\nconst vec3 light_col=vec3(1.0,0.7,0.4);\nfloat mdl;\n\n\nfloat DE(in vec3 z0){\n\tvec4 z = vec4(z0,1.0);\n\tfor (int n = 0; n < 3; n++) {\n\t\tz.xyz=clamp(z.xyz, -0.94, 0.94)*2.0-z.xyz;\n\t\tz*=scale/clamp(dot(z.xyz,z.xyz),mr,mxr);\n\t\tz+=p0;\n\t}\n\tif(bColoring)mcol+=z.xyz;\n\tz.y-=3.0*sin(iTime*3.0+floor(z0.x+0.5)+floor(z0.z+0.5));\n\tfloat dS=(length(max(abs(z.xyz)-vec3(1.2,49.0,1.4),0.0))-0.06)/z.w;\n\treturn dS;\n}\n\n\nfloat DEL(in vec3 z0){\n\tvec4 z = vec4(z0,1.0),p0=vec4(0.0,1.28,-1.12,0.0);\n\tz.xyz=clamp(z.xyz, -0.94, 0.94)*2.0-z.xyz;\n\tz*=scale/clamp(dot(z.xyz,z.xyz),mr,mxr);\n\treturn (length(z.xyz+vec3(0.0,5.8,2.2))-0.6)/z.w;\n}\n\n\n\nfloat MDE(in vec3 z0){\n\tfloat dL=DEL(z0);\n\tfloat dS=DE(z0);\n\tmdl=min(mdl,dL);\n\treturn min(dS,dL);\n}\n\nfloat rndStart(vec2 co){return 0.8+0.2*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nfloat ShadAO(vec3 ro, vec3 rd, float px, float dist){\n\tfloat res=1.0,d,t=4.0*px*rndStart(gl_FragCoord.xy);\n\tfor(int i=0;i<10;i++){\n\t\td=max(0.0,DE(ro+rd*t))+0.01;\n\t\tif(t+d>dist)break;\n\t\tres=min(res,2.0*d/t);\n\t\tt+=d;\n\t}\n\treturn res;\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\n\n\nvec3 Light(vec3 so, vec3 rd, float px, float dist){\n\tvec2 v=vec2(px,0.05);\n\tmcol=vec3(0.0);\n\tso+=rd*(dist-px);\n\tbColoring=true;//take color samples\n\t\n    vec3 col,norm=normalize(vec3(-DE(so-v.xyy)+DE(so+v.xyy),\n\t\t-DE(so-v.yxy)+DE(so+v.yxy),-DE(so-v.yyx)+DE(so+v.yyx)));\n    \n\tbColoring=false;//crappy lighting below\n\tmcol=vec3(0.9)+sin(mcol)*0.251;\n    \n\tfloat dL=DEL(so);\n\t\n    if(dL>.0*px){\n\t\tv=vec2(dL,0.0);\n\t\tvec3 light_dir=-normalize(vec3(-DEL(so-v.xyy)+DEL(so+v.xyy),-DEL(so-v.yxy)+DEL(so+v.yxy),-DEL(so-v.yyx)+DEL(so+v.yyx)));\n\t\t\n        light_dir=normalize(light_dir+vec3(0.87,1.0,0.95));\n        \n        \n\t\t\n        vec3 diffuse_col=mcol+vec3(-0.125,0.5,0.25)*dot(norm,rd);\n        \n\t\tfloat shad=ShadAO(so,light_dir,px,dL);\n\t\tfloat dif=dot(norm,light_dir)*0.5+0.5;\n\t\tfloat spec=0.25*pow(max(0.0,dot(light_dir,reflect(rd,norm))),0.25);\n        \n\t\tdif=min(dif,shad);\n\t\tcol=diffuse_col*dif+light_col*spec*shad;\n\t\tcol/=(1.0+dL*dL);\n        \n\t}else\n    {\n        col=light_col*1.5;}\n\treturn col;\n}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat hash( vec2 n ){return fract(sin(dot(n*0.123,vec2(78.233,113.16)))*43758.351);}\n\nfloat noise(in float p){\n\tfloat c=floor(p),f=fract(p);\n\treturn mix(hash(c),hash(c+1.0),f);\n}\n\n\nfloat noise(in vec2 p){\n\tvec2 c=floor(p),f=fract(p),v=vec2(1.0,0.0);\n\treturn mix(mix(hash(c),hash(c+v),f.x),\n\t\tmix(hash(c+v.yx),hash(c+v.xx),f.x),f.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat zoom=1.5,px=2.0/(iResolution.y*zoom);//find the pixel size\n\tfloat tim=iTime;\n\t\n\t//position camera\n\tvec3 ro=vec3(sin(tim*0.1),0.0,cos(tim*0.05));\n    \n\tro.z=0.25+ro.z*abs(ro.z);\n\tro*=3.9;\n    \n\tif(abs(ro.x)>3.8)ro.x=3.8*sign(ro.x);\n\tif(abs(ro.z)>3.9)ro.z=3.9*sign(ro.z);\n\t\n    vec3 rd=normalize(vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y,zoom));\n\trd=lookat(vec3(0.25+sin(tim*0.6),sin(tim*0.4),0.25)-ro,vec3(0.01,0.99,0.02))*rd;\n\t\n\t//march\n\tfloat t=rndStart(gl_FragCoord.xy)*0.5,tt=t,d,dm=100.0,tm=0.0,od=1000.0;\n\tfloat ft=(sign(rd.y)-ro.y)/rd.y,ref=1.0,dR=clamp(DE(ro+rd*ft)*10.0,0.0,1.0);\n\tfloat maxT=min((sign(rd.x)*4.0-ro.x)/rd.x,(sign(rd.z)*4.0-ro.z)/rd.z);\n    \n\tbool bGrab=false;\n    \n\tfloat stepGlow=0.0;\n    \n\tmdl=100.0;\n    \n\tfor(int i=0;i<48;i++){\n\t\td=MDE(ro+rd*t);\n\t\tt+=d;tt+=d;stepGlow+=0.006;\n\t\tif(t>ft){\n\t\t\tro+=rd*ft;\n\t\t\tt=t-ft;//the overshoot\n\t\t\tif(tt-t<maxT){//hit floor/ceiling\n\t\t\t\tvec2 p=mod(2.0*vec2(ro.x+ro.z,ro.x-ro.z),2.0)-1.0;\n\t\t\t\tfloat tile=sign(p.x*p.y);\n\t\t\t\tif(tile>0.0){\n\t\t\t\t\trd.y=-rd.y;\n\t\t\t\t\tft=(sign(rd.y)-ro.y)/rd.y;\n\t\t\t\t\tref*=0.75;\n\t\t\t\t}else{\n\t\t\t\t\ttt+=1000.0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{//hit wall\n\t\t\t\tt=maxT-tt+t;\n\t\t\t\tro+=rd*t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else if(d>od){\n\t\t\tif(bGrab && od<px*tt && tm==0.0){\n\t\t\t\tdm=od;\n\t\t\t\ttm=tt-d-od;\n\t\t\t\tbGrab=false;\n\t\t\t}\n\t\t}else bGrab=true;\n\t\tod=d;\n\t\tif(tt>maxT){\n\t\t\tt-=tt-maxT;\n\t\t\tro=ro+rd*t;\n\t\t\tbreak;\n\t\t}\n\t\t\n        if(d<0.0001)break;//hard stop\n        \n\t}\n\t\n\t//color\n\tvec3 col=vec3(0.02,0.0,0.0);\n\tif(tt<maxT){\n\t\tif(d<px*t){\n\t\t\tcol=mix(Light(ro+rd*t,rd,px*t,d),col,clamp(d/(px*t),0.0,1.0));\n\t\t}\n\t\tif(dm<px*tm){\n\t\t\tcol=mix(Light(ro+rd*tm,rd,px*tm,dm),col,clamp(dm/(px*tm),0.0,1.0));\n\t\t}\n\t}else{\n\t\tif(tt>1000.0){\n\t\t\tvec2 p=mod(2.0*vec2(ro.x+ro.z,ro.x-ro.z),2.0)-1.0;\n\t\t\tfloat g=max(0.15,pow(1.55*max(abs(abs(p.x)-0.5),abs(abs(p.y)-0.5)),6.0));\n\t\t\tcol=vec3(dR*g);\n\t\t\ttt-=1000.0;\n\t\t}else{\n\t\t\ttt=maxT;\n\t\t\tif(abs(ro.z)>abs(ro.x))ro.xz=ro.zx;\n\t\t\td=noise(ro.yz*70.0);\n\t\t\tro.y*=4.0;\n\t\t\tod=max(abs(ro.z),abs(ro.y))-1.0;\n\t\t\tdm=pow(1.0-clamp(abs(sin(iTime*10.0+ro.z*150.0*sin(iTime))+ro.y*1.2),0.0,1.0),10.0);\n\t\t\tro.y+=0.5;\n\t\t\tro.z+=floor(mod(ro.y+0.5,2.0))*0.25;\n\t\t\tcol=vec3(0.2,0.15,0.1)*(1.0-0.5*exp(-200.0*abs((fract(ro.z*2.0)-0.5)*(fract(ro.y)-0.5))));\n\t\t\tcol-=d*vec3(0.1,0.05,0.0);\n\t\t\tcol=mix(vec3(0.0,dm,1.0)*clamp(abs(od*2.0),0.0,0.5),col,clamp(od*10.0,0.0,1.0));\n\t\t}\n\t}\n\td=noise(iTime*10.0+rd.x*rd.z);\n\tcol=mix(vec3(dR),pow(col,vec3(ref)),ref);\n\tcol+=light_col*exp(-mdl*100.0*clamp(d,0.05,0.5));\n\tcol+=vec3(0.4,0.8,1.0)*pow(stepGlow*clamp(4.0-d*100.0,1.0,4.0),3.0);\n\tcol=3.0*col*exp(-tt*0.3);\n\tfragColor=vec4(col,1.0);\n} \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 419, 440, 440, 763], [766, 766, 788, 788, 979], [983, 983, 1005, 1005, 1082], [1084, 1084, 1108, 1108, 1173], [1175, 1175, 1228, 1228, 1407], [1409, 1409, 1438, 1438, 1523], [1527, 1527, 1578, 1578, 2529], [2531, 2531, 2553, 2553, 2586], [2588, 2588, 2609, 2609, 2672], [2674, 2674, 2698, 2698, 2766], [2769, 2769, 2792, 2792, 2922], [2925, 2925, 2982, 2982, 5580]]}
{"id": "tlG3D1", "name": "3d ray-sphere intersection", "author": "16807", "description": "Distance field to a cone. Click the screen to rotate.", "tags": ["raycasting", "cone", "analytic", "minimal"], "likes": 1, "viewed": 54, "published": "Public", "date": "1578800230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\n\n\n// 3D FUNCTIONS RETURNING MULTIPLE INTERSECTIONS / CLOSEST APPROACHES\nFUNC(bool) try_distances_along_3d_line_intersecting_sphere(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    float xz = dot(B0-A0, A);\n    float z  = length(A0+A*xz - B0);\n    float y2  = r*r-z*z;\n    float dxr = sqrt(max(y2, 1e-10));\n    entrance = xz - dxr;\n    exit     = xz + dxr;\n    return y2 > 0.;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_intersecting_sphere(A0,A, vec3(0.5,0,0), 0.5f, a_in, a_out);\n    \n    \n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 237, 385, 385, 587], [590, 590, 640, 640, 1268], [1270, 1270, 1327, 1327, 2384]]}
{"id": "tlG3Dc", "name": "Galactic Meteors", "author": "zovox", "description": "One of a few.", "tags": ["meteors", "galactic"], "likes": 9, "viewed": 362, "published": "Public API", "date": "1580063629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time*PI*4.0), 1.0);\n    \n    vec4 final = (acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.)))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 2;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = cmul(uv, multa+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offa\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        vec2 denominator = cmul(uv, multb+sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))) + offb\n            +sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)));\n        quotient += (cdiv(numerator, denominator));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(time+f+s)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 8;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0)*.5+1.0;\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0)*2.0;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0)*.5+1.0;\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0)*2.0;\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        antispeckle *= stretch;\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    \n    fragColor = vec4((color)*GR);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 877, 897, 897, 1014], [1015, 1015, 1033, 1033, 1072], [1074, 1074, 1092, 1092, 1141], [1142, 1142, 1160, 1160, 1219], [1527, 1584, 1606, 1606, 2474], [2476, 2539, 2568, 2568, 2638], [2640, 2640, 2669, 2669, 2753], [2755, 2755, 2823, 2871, 4140], [4142, 4204, 4309, 4309, 5054], [5079, 5079, 5100, 5100, 5407], [5409, 5409, 5466, 5466, 7414]]}
{"id": "tlG3R3", "name": "Lazy Clouds using noise", "author": "sbrown2", "description": "Just me trying out some smoothnoise and understanding simple color gradients. There are artifacts as this is unrefined.", "tags": ["noise", "cloud", "random", "smooth"], "likes": 2, "viewed": 53, "published": "Public", "date": "1579458572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise2d(in vec2 p){\n\t\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n\t\n}\nfloat smoothnoise(vec2 uv,float tile){\nvec2 local_uv = smoothstep(0.,1.,fract(uv*tile));\n    //vec2 local_uv = uv;\n    vec2 grid_id = floor(uv*tile);\n    \n    float bl = noise2d(grid_id);\n    float br = noise2d(grid_id+vec2(1.,0.));\n\n    float tr = noise2d(grid_id+vec2(1.));\n    float tl = noise2d(grid_id+vec2(0.,1.));\n    \n    float b = mix(bl,br,local_uv.x);\n\n    float t = mix(tl,tr,local_uv.x);\n    \n    float c = mix(b,t,local_uv.y);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    uv-=vec2(cos(iTime*.01)+sin(iTime*.1));\n    float c = smoothnoise(uv,4.);\n    c += smoothnoise(uv,8.)*.5;\n    c += smoothnoise(uv,16.)*.25;\n    c += smoothnoise(uv,32.)*.125;\n    c += smoothnoise(uv,64.)*.125/2.;\n    c += smoothnoise(uv,128.)*.125/4.;\n\n    vec3 col = vec3(c);\n    col.b *= 1.2;\n    //col.rg = grid_id*.1;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 80], [81, 81, 119, 119, 534], [536, 536, 593, 643, 1108]]}
{"id": "tlG3Rd", "name": "Xor Stack (254 chars)", "author": "FabriceNeyret2", "description": "code golfing of [url]https://shadertoy.com/view/3llXz2[/url] (528 chars)\n\nNote that blur is done by x 10 oversampling. Maybe it could be done shortly analytically.", "tags": ["loop", "2tweets", "golf"], "likes": 11, "viewed": 248, "published": "Public API", "date": "1579611838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing \"Xor Stack\" by yx: https://shadertoy.com/view/3llXz2 (528 chars)\n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( float t = fract(iTime/4.);\n          O.a++ < 12.; t += .1/60.) {\n        vec2 R = iResolution.xy, s = vec2(-3,3),\n             U = 15.* (u+u-R)/R.y / exp2(t);\n        vec4 p = .33 +smoothstep(.2,0.,t-.1*vec4(1,3,5,7) );\n        p = max( abs(U.x-p*s.xyyx), abs(U.y-p*s.yyxx) ) -2.;\n        p.x*p.y*p.z*p.w < 0. ? O += .1 : O;\n    };\n}/*\n\n\n\n\n\n// -- 259 chars\n\n#define mainImage(O,u)                                      \\\n    float t = fract(iTime/4.);                              \\\n    for (int i = 0; i++ < 10; t += .1/60.) {                \\\n        vec2 R = iResolution.xy, s = vec2(-3,3),            \\\n             U = 15.* (u+u-R)/R.y / exp2(t);                \\\n        vec4 p = .33 +smoothstep(.2,0.,t-.1*vec4(1,3,5,7) );\\\n        p = max( abs(U.x-p*s.xyyx), abs(U.y-p*s.yyxx) ) -2.;\\\n        p.x*p.y*p.z*p.w < 0. ? O += .1 : O;                 \\\n    }                                                      /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 113, 113, 457]]}
{"id": "tlG3WR", "name": "James Bond Rabbit Hole ", "author": "wookworld", "description": "going in then going out", "tags": ["3d", "rabbithole"], "likes": 7, "viewed": 369, "published": "Public API", "date": "1578623805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n \tfloat t = iTime * .2;\n\t//uv *= mat2(cos(t),-sin(t),sin(t),cos(t));\n    vec3 ro = vec3(0, 0, -1);\n    vec3 lookat  = mix(vec3(0),vec3(-1,0,-1),sin(t*1.56)*.5+.5);\n    float zoom = mix(.2,.7,sin(t)*.5+.5);\n    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n                      \n    float radius = .7;\n    float d5, dO;\n    vec3 p;\n                      \n     for(int i = 0; i<100; i++) {\n         p = ro + rd * dO;\n         d5 = -(length(vec2(length(p.xz)-1.,p.y)) - radius);\n     \tif (d5<.001) break;\n     \tdO += d5;\n     }\n   \n    vec3 col = vec3(0);\n\n    if(d5<.001) {\n       float x = atan(p.x,p.z)+t*mix(.4,.8,sin(t)*.01+.5);\n       float y = atan(length(p.xz)-1.,p.y);\n      \n        float bands = sin(y*10.+x*20.);\n        float ripples = sin((x*10.-y*30.)*3.)*.5+.5;\n        float waves = sin(x*2.-y*6.+t*10.);\n        \n       float b1 = smoothstep(-.2,.2, bands);\n       float b2 = smoothstep(-.2,.2, bands-.5);\n        \n        float m = b1*(1.-b2);\n        m = max(m, ripples*b2*b2*max(0.,waves));\n        m += max(0.,waves*.3*b2);\n        \n        col+= mix(m, 1.-m,smoothstep(-.3,.3, sin(x*2.+t)))+texture(iChannel1, uv*.9+iTime*+.001).rgb;\n   \n     col.rg += uv.xy;}\n    fragColor = vec4(col,.2);\n     col.rg = uv;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlG3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1554]]}
{"id": "tlGGDR", "name": "Four Rhombus Tessellation", "author": "revort", "description": "Tessellates four rhombi, varying the angle inside the rhombus.", "tags": ["tiling"], "likes": 10, "viewed": 139, "published": "Public", "date": "1578698081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a)        vec2( cos(a), sin(a) )\nfloat pi = 3.14159265358979;\nfloat sqrt_2 = 1.41421356237;\nfloat sqrt_half = 0.70710678118;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat tesselatedRhombiPos(float theta1, vec2 p){\n    vec2 p_ = p;\n    p_ -= vec2(0.5,0.5);\n    p_ *= rot(-pi/4.0);\n    float d = sdRhombus(p_, CS(pi/4.0));\n    p_ = p;\n    p_ -= vec2(0.5+0.5*cos(theta1),1.0+0.5*sin(theta1));\n    p_ *= rot(-theta1/2.0);\n    d = min(d,sdRhombus(p_, CS(theta1/2.0)));\n    p_ = p;\n    p_ -=vec2(1.0+0.5*sin(theta1),0.5-0.5*cos(theta1));\n    p_ *= rot((pi-theta1)/2.0);\n    d = min(d,sdRhombus(p_, CS(theta1/2.0)));\n    p_ = p;\n    p_ -= vec2(1.0 + sqrt_half*cos(theta1-pi/4.0),1.0 + sqrt_half*sin(theta1-pi/4.0));\n    p_ *= rot(-theta1-pi/4.0);\n    d = min(d,sdRhombus(p_, CS(pi/4.0)));\n    return d;\n}\n\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat getTesselatedRhombusVal(vec2 p, float theta1){\n    vec2 a_vec = vec2(cos(theta1),1.0+sin(theta1));\n    vec2 b_vec = vec2(1.0+sin(theta1),-cos(theta1));\n    float angle = atan(a_vec.y,a_vec.x);\n    float len = length(a_vec);\n    vec2 offset = vec2(len,len);\n    vec2 p_ = p*rot(-angle);\n    p_ = opRep(p_, offset);\n    float val = tesselatedRhombiPos(theta1,(p_*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(offset.x,0.0))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(offset.x,0.0))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(0.0,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(0.0,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(offset.x,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(offset.x,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ + vec2(-offset.y,offset.y))*rot(angle)));\n    val = min(val, tesselatedRhombiPos(theta1,(p_ - vec2(-offset.y,offset.y))*rot(angle)));\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = iTime;\n    vec2 p = uv - vec2(0.5,0.5);\n    p *= iResolution.xy / iResolution.x * 12.0;\n    if (floor(mod(t/2.0,3.0))==1.0){\n        p *= rot(mod(t,2.0)*pi/4.0);\n    }\n    if (floor(mod(t/2.0,5.0))==1.0){\n        p = p + vec2(0.0,1.0);\n    }\n    float theta1 = mod(t,2.0)*pi/4.0;\n    float val = getTesselatedRhombusVal(p, theta1);\n    vec3 col = vec3(0.0);\n    col = mix(col,vec3(1.0),0.5 + 0.5*cos(val*pi*10.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 166, 166, 194], [196, 196, 238, 238, 433], [435, 435, 453, 453, 505], [507, 507, 555, 555, 1139], [1141, 1141, 1176, 1176, 1227], [1229, 1229, 1281, 1281, 2337], [2339, 2339, 2396, 2446, 2950]]}
{"id": "tlGGRm", "name": "Learning Code [8]", "author": "ozu", "description": "Everything you're not supposed to do.", "tags": ["lazyrandomness"], "likes": 1, "viewed": 54, "published": "Public", "date": "1578508327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (u -.5 *R) / R.y;\n\n    float d = length( U / sin( iTime*(U.y +U.x) ) );\n\n    O = vec4( smoothstep(150./R.y, 0., abs( sin(iTime) *.5 + .5 - d ) ) );\n}\n\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 *iResolution.xy) / iResolution.y;\n\n    float col = 0.;\n    //float d = length( uv*sin(uv.y*1. * iTime)  + sin(uv.x*1. * iTime)  );\n    float d = length( uv *  1./(sin( uv.y * iTime +uv.x * iTime ) ) );\n\n    float blur = 1.5/iResolution.y;\n\n   \n    col = smoothstep(blur *100., 0., abs(d - 1.* (sin(iTime) *.5 + .5) ) );\n\t//col = d;\n    fragColor = vec4(vec3(col),1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 230]]}
{"id": "tlGGRR", "name": "Truchet Noise", "author": "michael0884", "description": "Just a random thing I thought about", "tags": ["noise"], "likes": 6, "viewed": 290, "published": "Public API", "date": "1578075262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 truchet(vec2 p)\n{\n    float rnd = hash(floor(p.x) + floor(p.y)*1.55463);\n    bool cond = (rnd>0.5)?(mod(p.x,1.)+mod(p.y,1.)>1.):(mod(p.x,1.)+mod(p.y,1.)<1.);\n    return cond?jet_colormap(0.8*sin(5.*((1.-rnd)*p.x+rnd*p.y))):vec3(1.);\n}\n\nvec3 truchet_noise(vec2 p)\n{\n    float scale =1.;\n    float amp = 1.;\n    float norm = 0.;\n    vec3 col = vec3(0);\n    for(int i = 0; i < 5; i++)\n    {\n        vec3 trc = truchet(scale*p+2.*pow(scale,0.3)*vec2(sin(iTime),cos(iTime)));\n        col += amp*trc;\n        norm += amp;\n        if(length(trc) > 1.5) break; //if white\n        scale*= 1.7;\n        amp*=0.55;\n    }\n    return col/norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Output to screen\n    fragColor = vec4(1.05*truchet_noise(10.*uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 34, 105, 105, 149], [151, 151, 175, 175, 431], [433, 433, 461, 461, 517], [519, 519, 562, 562, 623], [626, 626, 647, 647, 732], [734, 734, 756, 756, 973], [975, 975, 1003, 1003, 1371], [1373, 1373, 1430, 1480, 1600]]}
{"id": "tlGGz1", "name": "Microscopic Algae", "author": "Eggy42", "description": "A riff on BigWIng's Universe Within tutorial. ", "tags": ["2d", "green", "layers", "algae", "microscopic"], "likes": 19, "viewed": 212, "published": "Public", "date": "1578266835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 5.\n\n// Color pallete\n//      A Component  R     G     B   (Y shift)\n#define pal_a vec3( 0.20, 0.50, 0.20 )  \n//      B Component  R     G     B   (amplitude)\n#define pal_b vec3( 0.10, 0.30, 0.20 )  \n//      C Component  R     G     B   (period)\n#define pal_c vec3( 1.00, 0.70, 0.40 )  \n//      D Component  R     G     B   (phase)\n#define pal_d vec3( 0.00, 0.15, 0.20 )    \n\nvec3 pal( in float t )\n{\n    return 1. - pal_a + pal_b*-cos( 6.28318*(pal_c*t+pal_d) );\n}\n\n// Distance from p to line a-b\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * t);\n\n}\n\n// Noise 2 in, 1 out\nfloat N21 (vec2 p) {\n\tp = fract(p*vec2(231.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x * p.y);\n}\n\n// Noise 2 in , 2 out\nvec2 N22 (vec2 p ){\n\tfloat n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\n// Get random position within a cell\nvec2 getPos(vec2 id, vec2 offset) {\n    vec2 r = N22(id+offset)*(iTime+22856.)*.2;\n    return offset+sin(r)*.4;\n}\n\n// Is p within a line from a-b\nfloat drawLine (vec2 p, vec2 a, vec2 b) {\n\tfloat d = distLine(p, a, b);\n    float m = S(.08, .0, d);\n    float d2 = length(a-b);\n    m *= S(1.5, 0., d2);\n    return m;\n}\n\n// Draw a whole layer \nfloat drawLayer(vec2 uv) {\n    float m = 0.;\n    \n    // Grid coords\n  \tvec2 gv = fract(uv)-.5;\n \t// ID for this cell\n    vec2 id = floor(uv);\n    \n    // Get the dot position for this cell and 8 surrounding ones\n    vec2 p[9];\n    int i = 0;\n    for(float y=-1.; y<= 1.; y++) {\n    \tfor(float x=-1.; x<= 1.; x++) {\n            p[i++] = getPos(id, vec2(x, y));\n        }\n    }\n    \n    // draw a line from the center to surrounding cells\n    float t = iTime;\n    for(int i=0; i<9; i++) {\n    \tm += drawLine(gv, p[4], p[i]);\n    }\n    // Fill in the diagonals\n    m += drawLine(gv, p[1], p[3]);\n    m += drawLine(gv, p[1], p[5]);\n    m += drawLine(gv, p[7], p[3]);\n    m += drawLine(gv, p[7], p[5]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n\n    float m = 0.;\n    float t = sin(iTime*.03);\n\n    // Rotate and zoom over time\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    // grab the distance from the bottom\n    float gradient = uv.y;\n    \n    // Grab distance from edges for vignette\n    float vignette = length(uv);\n    \n    // Rotate coords\n    uv *= rot;\n    mouse *= rot;\n    \n    // Draw multiple layers at different scales and positions\n    for (float i = 0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .6, z)*S(1., .9, z);\n        m += drawLayer(uv*size+i*20.-mouse)*fade;\n    }\n    \n    // Color things\n    vec3 base = pal(iTime*.03);\n    vec3 col = m*base;\n    col -= gradient*base*.8;\n    col += smoothstep(0.8, .99, vignette)*2.;\n\n    // Tone mapping? KeepsSee: https://www.shadertoy.com/view/3s3GDn\n    col = 1.0 - exp( -col );\n        \n    // Output to screen\n    fragColor = vec4(vec3(1)-col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 433, 457, 457, 522], [524, 555, 595, 595, 725], [727, 748, 768, 768, 861], [863, 885, 904, 904, 955], [957, 994, 1029, 1029, 1107], [1109, 1140, 1181, 1181, 1309], [1311, 1334, 1360, 1360, 2053], [2055, 2055, 2112, 2162, 3262]]}
{"id": "tlKGD1", "name": "Desert biome map generator", "author": "jarble", "description": "This is a simple biome map generator. It's an infinite desert with many \"lakes\" or \"oases\" that change with the seasons.", "tags": ["fractal", "desert", "biome"], "likes": 1, "viewed": 265, "published": "Public API", "date": "1578873078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the density of the \"oases.\"\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float RED = 2.0;\nconst float YELLOW = 3.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33+iTime/20000.0);\n    return floor(fract((p3.x + p3.y) * p3.z)*2.0);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    while(mag > 1.0){\n    if(color1 == GREEN && is_next_to(fragCoord,mag,BLUE)){\n    \tcolor1 = YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag,GREEN)){\n        color1 = GREEN;\n    }\n    mag -= 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord*2.0 + iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 238, 260, 260, 402], [405, 405, 445, 445, 494], [496, 496, 548, 548, 591], [592, 592, 652, 652, 864], [866, 866, 920, 920, 1132], [1135, 1135, 1163, 1163, 1434], [1437, 1437, 1496, 1496, 1742], [1744, 1744, 1801, 1801, 2089]]}
{"id": "tlKGDR", "name": "Self Reflection", "author": "pocketCoffee", "description": "Little water experiment to get my feet wet in noise and height maps.", "tags": ["water"], "likes": 1, "viewed": 73, "published": "Public", "date": "1579229629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n   \nstruct Mat{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 shininess;\n};\n\nstruct Hit{\n    float d;\n\tMat mat;\n};\n    \nstruct Light{\n\tvec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool isHit = false;\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n      return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 rep(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\n// Noise\nfloat hash(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z); \n}\n\nfloat noise(vec2 x){\n    // Make the waves move\n    x += iTime;\n    x *= .25;\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    float m = mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n\treturn m;\n}\n\nfloat fbm(vec2 x){\n    x *= .3;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );// * iTime*.002;\n    float f = 0.0;\n\tf  = 0.5000*noise(x); \n    x = m*x;\n\tf += 0.2500*noise(x); \n    x = m*x;\n\tf += 0.1250*noise(x); \n    x = m*x;\n\tf += 0.0625*noise(x); \n    return f;\n}\n\nfloat waterHeight(vec2 p){\n    float time = iTime * 0.3;\n    float h = fbm(p*time*.05)*1.2;\n    // Maximize induced nausea by adding more waves\n    h += sin(iTime *.7 + dot(vec2(.3, .1), p));\n    h += sin(iTime *.2 + dot(vec2(.1, .7), p));\n    return h;\n}\n\n// Materials\nMat waterMat = Mat(vec3(.2, .4, .6), vec3(.4, .7, .6), vec3(.5), vec3(1.)); // Water material\nMat redMat = Mat(vec3(.8, .2, .3), vec3(.8, .2, .2), vec3(.3), vec3(0.0)); // Red material\nHit hit; // Global hit that saves material\n\n// Scene map\nHit map(vec3 p){\n\tfloat ground = box(rep(p + vec3(0., 3., 1.1), vec3(0., 0., 1.)), vec3(15., 2.*waterHeight(p.xz)*.07+2., 2.));\n    float ceiling = box(rep(p + vec3(0., -3., 1.1), vec3(0., 0., 1.)), vec3(15., 2.*waterHeight(p.xz)*.05+1.8, 2.));\n    float ball = sphere(p + vec3(0.3, 0.9, .7), .5);\n    \n    float result = min(ground, ceiling);   \n    result = min(result, ball);\n    hit.d = result;\n    if(result == ball){\n        hit.mat = redMat;\n    }\n    else{\n        hit.mat = waterMat;\n    }\n    return hit;\n}   \n\nvec3 march(vec3 ro, vec3 rd){\n    float dt = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dt * rd;\n        p.y += sin(p.z - iTime * 2.) * .03; // Makes everything all wavey\n        Hit mhit = map(p);\n        float dist = mhit.d;\n        if(dist < MIN_DIST){\n            isHit = true;\n            hit.mat = mhit.mat;\n            break;\n        }\n        dt += dist*0.925;\n    }\n    return ro + dt * rd;\n}\n\nvec3 normals(vec3 p){\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(map(p + eps.xyy).d - map(p - eps.xyy).d,\n                          map(p + eps.yxy).d - map(p - eps.yxy).d,\n                          map(p + eps.yyx).d - map(p - eps.yyx).d));\n}\n\nvec4 light(vec3 p, vec3 rd, Light mLight, Mat mat, vec3 n){\n    \n    vec3 l = normalize(mLight.pos - p);\n        \n    // Ambient\n    float ambientStr = 0.8;\n    vec3 ambient = ambientStr * mLight.ambient;\n    \n    // Diffuse\n    float dif = max(dot(n, l), 0.0);\n    vec3 diffuse = dif * mLight.diffuse;\n    \n    // Specular\n    vec3 viewDir = normalize(rd - p);\n    vec3 reflectDir = reflect(-l, n);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float specularStr = 12.;\n    vec3 specular = mLight.specular * (spec * mat.specular * specularStr);\n    \n    return vec4((diffuse * mat.diffuse + ambient * mat.ambient + specular * mat.shininess) , 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= ar;\n    \n    //vec3 camPos = vec3(0, -.3, fract(iTime*.1)*24.);\n    vec3 camPos = vec3(0.1, 0.1, 0.1);\n    camPos.zx *= rot(iTime);\n    camPos.z -=5.;\n    vec3 ro = camPos;\n    vec3 rd = vec3(uv, 1.0);\n    \n    vec3 p = march(ro, rd);\n    vec3 n = normals(p); // Calculating normals\n    p.y += sin(p.z - iTime * 2.) * .3; // Also appears within march\n    \n    vec4 col = vec4(0.0);\n    \n    if ( isHit == true){\n        vec3 lightPos = vec3(0, 2., -8.);\n    \tLight mLight = Light(lightPos, vec3(.3), vec3(.9), 0.5 + 0.3*cos(iTime+uv.xyx+vec3(0,2,4)));\n        \n        vec3 fp = floor(p * 3. + fract(iTime)); // Checkerboard pattern\n        col = light(p, rd, mLight, hit.mat, n);\n        //if(hit.mat == waterMat){\n        // Reflections\n        vec3 reflection = reflect(rd, n);\n        vec3 refraction = refract(rd, n, 5.);\n    \tvec3 rp = march(rd, reflection);\n        vec3 rn = normals(rp);\n        vec4 reflCol = light(rp, reflection, mLight, hit.mat, rn);\n        //reflCol.rgb += refraction;\n        //reflCol.rgb *= hit.mat.shininess;\n    \n    \tcol *= reflCol * vec4(hit.mat.shininess, 1.0) * 4.;\n        //}\n        //col *= vec4(vec3(mod(fp.x + fp.z, 2.)), 1.); // Add checkerboard\n        //vec2 coord = fragCoord.xy * 0.1 - vec2(iTime * 5.0, iResolution.y / 2.0);\n        //col *= fbm(p.xz*iTime*.01)*3.; // Shows the height map\n        \n    }\n    else{\n        col = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1.0);\n        //col = vec4(.7, .2, .4, 1.0);\n        col *= .05;\n    }\n\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 334, 334, 410], [433, 433, 466, 466, 490], [492, 492, 518, 518, 611], [613, 613, 639, 639, 673], [675, 684, 703, 703, 818], [820, 820, 840, 867, 1222], [1224, 1224, 1242, 1242, 1482], [1484, 1484, 1510, 1510, 1739], [1983, 1996, 2012, 2012, 2512], [2517, 2517, 2546, 2546, 2942], [2944, 2944, 2965, 2965, 3209], [3211, 3211, 3270, 3270, 3883], [3885, 3885, 3942, 3942, 5573]]}
{"id": "tlKGDt", "name": "copy plasma", "author": "Sanprieto", "description": "plasma", "tags": ["plasma"], "likes": 2, "viewed": 74, "published": "Public", "date": "1580220287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RM_FACTOR   0.9\n#define RM_ITERS     90\n\nfloat plasma(vec3 r) {\n\tfloat mx = r.x + iTime / 0.130;\n\tmx += 20.0 * sin((r.y + mx) / 20.0 + iTime / 0.810);\n\tfloat my = r.y - iTime / 0.200;\n\tmy += 30.0 * cos(r.x / 23.0 + iTime / 0.710);\n\treturn r.z - (sin(mx / 7.0) * 2.25 + sin(my / 3.0) * 2.25 + 5.5);\n}\n\nfloat scene(vec3 r) {\n\treturn plasma(r);\n}\n\nfloat raymarch(vec3 pos, vec3 dir) {\n\tfloat dist = 0.0;\n\tfloat dscene;\n\n\tfor (int i = 0; i < RM_ITERS; i++) {\n\t\tdscene = scene(pos + dist * dir);\n\t\tif (abs(dscene) < 0.1)\n\t\t\tbreak;\n\t\tdist += RM_FACTOR * dscene;\n\t}\n\n\treturn dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat c, s;\n\tfloat vfov = 3.14159 / 2.3;\n\n\tvec3 cam = vec3(0.0, 0.0, 30.0);\n\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y *= -1.0;\n\n\tvec3 dir = vec3(0.0, 0.0, -1.0);\n\n\tfloat xrot = vfov * length(uv);\n\n\tc = cos(xrot);\n\ts = sin(xrot);\n\tdir = mat3(1.0, 0.0, 0.0,\n\t           0.0,   c,  -s,\n\t           0.0,   s,   c) * dir;\n\n\tc = normalize(uv).x;\n\ts = normalize(uv).y;\n\tdir = mat3(  c,  -s, 0.0,\n\t             s,   c, 0.0,\n\t           0.0, 0.0, 1.0) * dir;\n\n\tc = cos(0.7);\n\ts = sin(0.7);\n\tdir = mat3(  c, 0.0,   s,\n\t           0.0, 1.0, 0.0,\n\t            -s, 0.0,   c) * dir;\n\n\tfloat dist = raymarch(cam, dir);\n\tvec3 pos = cam + dist * dir;\n\n\tfragColor.rgb = mix(\n\t\tvec3(0.4, 0.8, 1.0),\n\t\tmix(\n\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\tvec3(1.0, 1.0, 1.0),\n\t\t\tpos.z / 10.0\n\t\t),\n\t\t1.0 / (dist / 20.0)\n\t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 71, 71, 307], [309, 309, 330, 330, 351], [353, 353, 389, 389, 583], [585, 585, 640, 640, 1480]]}
{"id": "tlKGRG", "name": "luna - sun", "author": "lymiss0", "description": "Sun", "tags": ["2d"], "likes": 1, "viewed": 63, "published": "Public", "date": "1579250142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float len = length(uv); //点到中心的距离\n    float d = len - 0.5; //点到中心的距离-圆的半径\n    float s = 100.0;\n    float k = 0.0;\n    float a = 1.0;\n    int times = int((iTime + PI * 0.5) / PI);\n    int h = int(times / 2);\n    if (h * 2 == times) {\n        //k = tan(iTime);\n        a = 1.0;\n    } else {\n        a = -1.0;\n        //k = -tan(iTime);\n    }\n    k = tan(iTime);\n    \n    \n//    if (k <= -99.0) {\n//        a = -1.0;\n//    }\n//    k = k * a;\n    if ((a > 0.0) && (uv.y < k * uv.x)) {\n        s = 0.01;\n    }\n    if ((a < 0.0) && (uv.y > k * uv.x)) {\n        s = 0.01;\n    }\n//    if (uv.y < k * uv.x) {\n//        s = 0.01;\n//    }\n    \n\n    float t = clamp(d * min(iResolution.y,iResolution.x) * s, 0.0, 1.0);\n    if (t == 0.0) {\n        t = 1.0;\n    }\n    \n    vec4 bg = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 circle = vec4(1.0, 0.0, 0.0, 1.0 - t);\n    \n    fragColor = mix(bg, circle, circle.a);\n    \n    //if (len <= 0.5) {\n    //    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    //} else {\n    //    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    //}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 110, 1280]]}
{"id": "tlKGzK", "name": "Ovni-test1", "author": "jorge2017a1", "description": "Ovni-test1", "tags": ["ovnitest1"], "likes": 1, "viewed": 44, "published": "Public", "date": "1579399603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            res=vec2(res.x, 9);\n             //res=vec2(floorTex(glpRoRd), 3);\n             //res=vec2(res.x, 13);\n             //res=vec2(p.y + 0.5 + 0.2 * sin(5.0 * p.x + 0.6 * iTime) * cos(2.0 * p.z + 0.4 * iTime), 12); \n             //res=vec2(p.y + 0.5 + 0.32 * sin(5.0 * p.x + 0.6 * iTime) * cos( p.z + 0.4 * iTime), 12); \n         } \n     }\n    \n    \n    \n    \n     float num;\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n\n    num =8.0;\n    Incgrados=360./num;\n    Incgrados=Incgrados*PI/180.0;\n    \n    \n\n    vec3 pr =rotate_y(p, iTime);\n    \n\n    \n    for(float ii=0.0; ii<num; ii++) \n\t{\n        \trx=4.0*cos(gr);\n        \try=4.0*sin(gr);\n                \n        \t\n        \tfloat sd1= sdSphere( p-vec3(rx, 3.0,-10.+ ry ),1.0);\n                \n        \tsdfintdo = min(sdfintdo,sd1);\n        \n        gr=gr+Incgrados;\n    }\n    \n    \n    \n    float sdcy1 =sdCylinder(  p-vec3(0, 4.0,-2.0 ), vec2(4.5,1.0) );\n    dif2= unionSDF( sdfintdo,sdcy1 );\n    res =opU(res, vec2(dif2,8));\n    \n \t\n    p.xz=mod(pr.xz,10.0)-3.0; \n\t\n    \n    \n    float sdb1=  sdBox( p, vec3(8.0,2.0,8.0) );\n    float sds1= sdSphere( p-vec3(-1,1.0,-9.), 2.0 );\n    \n    \n    dif1= differenceSDF( sdb1,sds1 );\n    \n    \n    \n    res = opU(res, vec2(dif1, 9));  \n\n\n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n     case 15:\n     \t\t/*\n         \t\tvec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V, plane.color)*intensity; //地板色\n      \t\t*/\n        case 16:\n        /*\n        \tvec3 p,rd,ro;\n        \tfloat dist;\n        \t\t\n        \t\tro= mObj.ro;\n                rd= mObj.rd;\n                dist =mObj.dist;\n        \t\t//dist =0.001;\n        \n        \t\tp =ro+rd*dist;\n                \n          \t\tvec3 sn =GetNormal(p);\n     \t\t\t// SECOND PASS - REFLECTED RAY\n    \t\t\tvec3 rdrf = reflect(-rd, sn);\n        \t\t//vec3 prf = (ro + rdrf * d); \n        \t\tvec3 prf = (ro + rdrf * dist); \n    \t\t\t//vec3 prf = (ro + rdrf * 0.01); \n    \t\t\tfloat difrf = GetLight(prf);\n        \t\treturn difrf*vec3(1.0);\n     */\n        \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,4.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1522, 1576, 1598, 1598, 2858], [2861, 2925, 2961, 2961, 3234], [3236, 3286, 3332, 3332, 3364], [3366, 3366, 3408, 3408, 3440], [3442, 3442, 3489, 3489, 3522], [3525, 3525, 3554, 3554, 3680], [3682, 3682, 3718, 3718, 3835], [3837, 3837, 3873, 3873, 3991], [4043, 4055, 4077, 4077, 4385], [4386, 4412, 4437, 4437, 4627], [4628, 4673, 4690, 4690, 4763], [4766, 4799, 4825, 4825, 5022], [5023, 5069, 5121, 5121, 5276], [5341, 5450, 5487, 5487, 5522], [5524, 5524, 5543, 5543, 5618], [5624, 5624, 5649, 5649, 7413], [7416, 7416, 7450, 7450, 7839], [7844, 7844, 7868, 7868, 8100], [8104, 8104, 8128, 8128, 8513], [8516, 8516, 8542, 8542, 8906], [8909, 8909, 8934, 8934, 8962], [8964, 8964, 9016, 9016, 9412], [9515, 9559, 9576, 9576, 9647], [9672, 9764, 9789, 9789, 10052], [10054, 10113, 10141, 10141, 12922], [12926, 12926, 12983, 12983, 14393]]}
{"id": "tlt3R8", "name": "tunnel serpinski", "author": "Cewein", "description": "It's a tunnel about fractal", "tags": ["raymarching", "fractal", "tunnel"], "likes": 3, "viewed": 87, "published": "Public", "date": "1577899928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCHING_STEP 64.\n\n/////\n// SDF Operation function\n/////\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/////\n// Scene and primitive SDF function\n/////\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n#define Scale 2.0\n#define iteration 10\n\nfloat DE(vec3 z)\n{\n    vec3 a1 = vec3(1,1,1);\n    vec3 a2 = vec3(-1,-1,1);\n    vec3 a3 = vec3(1,-1,-1);\n    vec3 a4 = vec3(-1,1,-1);\n    vec3 c;\n    int n = 0;\n    float dist, d;\n    while (n < iteration) {\n         c = a1; dist = length(z-a1);\n            d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n         d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n         d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n        z = Scale*z-c*(Scale);\n        n++;\n    }\n\n    return length(z) * pow(Scale, float(-n));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n  \tsamplePoint = opRep(samplePoint, vec3(1.5, 5.,5.));\n    float res = DE(samplePoint);\n    //res += sdPlane(-0.5, vec4(0.,1.,0.,1.));\n    return res;\n   \n}\n\n\n/////\n// Ray function\n/////\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y * 0.5 / tan(radians(fov)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n/////\n// Marching function\n/////\n\nfloat march(vec3 pos, vec3 direction, float start, float end, inout float i)\n{\n    float depth = start;\n    for(i = 0.; i < MARCHING_STEP; i++)\n    {\n        float dist =  sceneSDF(pos + direction * depth);\n        if(dist <= 0.05f)\n        {\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end)\n            return end;\n    }\n}\n\n\n/////\n// Main function\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 at = vec3(0, 0, 0);\n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 pos = vec3(cos(iTime/10.),0,sin(iTime/10.));\n\n    vec3 dir = getCameraRayDir(uv, pos, at);\n    \n    float i;\n    float dist = march(pos, dir, 0.f,50.f,i);\n    vec3 col = vec3(dist);\n    \n    if((dist - 50.f) > 0.001f)\n    {\n        col = vec3(0.0529, 0.0808, 0.0922);\n    }\n    else\n    {\n        col = vec3(dist*0.1); \n        col = vec3(0.75 + sin(iTime/10.), 0.515, 0.053 + cos(iTime/10.)) * float(i)/float(MARCHING_STEP);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlt3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 67, 102, 102, 153], [155, 204, 239, 239, 279], [283, 283, 308, 308, 323], [365, 365, 383, 383, 894], [896, 896, 930, 930, 1088], [1091, 1120, 1180, 1264, 1577], [1579, 1579, 1630, 1630, 1756], [1758, 1758, 1804, 1804, 1930], [1932, 1966, 2044, 2044, 2324], [2327, 2357, 2414, 2414, 2970]]}
{"id": "tltXzH", "name": "Rolling Cube", "author": "hZzAaa", "description": "A cube rolling along a blank plane.\n\nThe cube and plane are raymarched individually to achieve shading on the cube but not the plane", "tags": ["raymarching", "cube"], "likes": 0, "viewed": 52, "published": "Public", "date": "1580426786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 10000\n#define MAX_DIST 1000.\n#define SURF_DIST .001\n\n#define PI 3.1415926535897932384626433832795\n#define ROLLSPEED iTime\n\n#define CUBE_COLOUR vec3(.8, .843, .922)\n#define PLANE_COLOUR vec3(.635, .761, .851)\n\n//#define MOUSE_MOVEMENT\n\nmat2 Rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec4 GetCubeDist(vec3 p)\n{\n  float sqrt2 = 1.41421356237;\n  float yMov = max(sin(2.*ROLLSPEED), sin(2.*ROLLSPEED + PI))/(sqrt2+1.) + 1.;\n  vec3 rotatedCubePos = rotation(p-vec3(0,yMov,0), vec3(0,0,1), ROLLSPEED);\n  rotatedCubePos-=vec3(0,-1,0);\n\n  return vec4(CUBE_COLOUR, sdBox(rotatedCubePos - vec3(0, 1, 0), vec3(1)));\n}\n\n// Can remove\nvec4 GetDist(vec3 p) {\n  //Floor\n  vec4 plane = vec4(PLANE_COLOUR, p.y);\n\n  //Cube\n  vec4 box = GetCubeDist(p);\n\n  return plane.w < box.w ? plane : box;\n}\n\nvec4 RayMarchCube(vec3 ro, vec3 rd) {\n  float dO = 0.;\n  vec3 col = vec3(0);\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = GetCubeDist(p).w;\n    dO += dS;\n    if (dO > MAX_DIST || dS < SURF_DIST) {\n      col = GetCubeDist(p).xyz;\n      break;\n    }\n  }\n\n  return vec4(col, dO);\n}\n\nvec4 RayMarchPlane(vec3 ro, vec3 rd) {\n  float dO = 0.;\n  vec3 col = vec3(0);\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = p.y;\n    dO += dS;\n    if (dO > MAX_DIST || dS < SURF_DIST) {\n      col = PLANE_COLOUR;\n      break;\n    }\n  }\n\n  return vec4(col, dO);\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p).w;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(GetCubeDist(p - e.xyy).w, GetCubeDist(p - e.yxy).w, GetCubeDist(p - e.yyx).w);\n\n  return normalize(n);\n}\n\nfloat Shadow(vec3 p) {\n  vec3 lightPos = vec3(0, 5, -25);\n  vec3 l = normalize(lightPos - p);\n  \n  //Get Normal\n  float d = GetDist(p).w;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(GetDist(p - e.xyy).w, GetDist(p - e.yxy).w, GetDist(p - e.yyx).w);\n  n = normalize(n);\n\n  float dif = 1.;\n\n  // Shadow\n  float d2 = RayMarchCube(p + n * SURF_DIST * 2., l).w;\n  if(p.y<.01 && d2<length(lightPos-p)) dif *= .5;\n\n  return dif;\n}\n\nfloat DiffuseLight(vec3 p){  \n  vec3 lightPos = vec3(0, 5, -25);\n  vec3 l = normalize(lightPos - p);\n\n  //Get Normal\n  float d = GetDist(p).w;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(GetDist(p - e.xyy).w, GetDist(p - e.yxy).w, GetDist(p - e.yyx).w);\n  n = normalize(n);\n\n  float dif = clamp(dot(n, l) * .5 + .5, 0., 1.);\n\n  return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)),\n       u = cross(f, r), c = p + f * z, i = c + uv.x * r + uv.y * u,\n       d = normalize(i - p);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(40); // Camera pos\n  \n  #ifdef MOUSE_MOVEMENT\n    vec2 m = iMouse.xy / iResolution.xy;\n    ro.yz *= Rot(-m.y * 3.14 + 1.);\n    ro.xz *= Rot(-m.x * 6.2831);\n  #endif\n\n  vec3 rd = R(uv, ro, vec3(0, 1, 0), 5.); // Camera direction/zoom\n\n  vec4 cube = RayMarchCube(ro, rd);\n  vec4 plane = RayMarchPlane(ro, rd);\n\n  if (cube.w < MAX_DIST || plane.w < MAX_DIST) {\n    col = cube.xyz;\n  \n    vec3 cube_p = ro + rd * cube.w;\n    float dif = DiffuseLight(cube_p);\n    col.yz *= dif/.2;\n    col.x *= dif/.5;\n\n    if (plane.w < cube.w)\n    {      \n      vec3 plane_p = ro + rd * plane.w;\n      col.xyz = plane.xyz;\n      col.yz *= Shadow(plane_p);\n    }\n\n  }\n\n  fragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 253, 272, 272, 342], [344, 344, 383, 383, 480], [482, 482, 532, 532, 1083], [1085, 1085, 1114, 1114, 1198], [1200, 1200, 1226, 1226, 1523], [1525, 1539, 1561, 1571, 1693], [1695, 1695, 1732, 1732, 2011], [2013, 2013, 2051, 2051, 2311], [2313, 2313, 2337, 2337, 2515], [2517, 2517, 2539, 2539, 2943], [2945, 2945, 2972, 2972, 3289], [3291, 3291, 3333, 3333, 3513], [3515, 3515, 3570, 3570, 4354]]}
{"id": "tlV3Dt", "name": "virus 127", "author": "aodnawg", "description": "virus", "tags": ["virus"], "likes": 18, "viewed": 354, "published": "Public", "date": "1580468292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n11(float p) {\n\treturn fract(sin(p*154.101)*313.019);\n} \nfloat n21(vec2 p) {\n    float n = sin(dot(p, vec2(7, 157)));    \n    return n;\n}\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nfloat nebula(in vec3 p) {\n    float amp = 1., sum=0., z= 1., m = 0.;\n    for(int i=1; i<=10;i++){\n    \tvec3 t = vec3(0., 0., p.z+iTime*.1);\n        z *= 2.;\n        m += voronoi(vec3(p.xy*z, 1.)+t) *amp;\n        sum += amp;\n        amp *= .5;\n    }\n    m /= sum;\n    return pow(m, 1.5);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.0);\n    \n    float m = nebula(vec3(uv,1.));\n    m = pow(m*1.8, 3.);\n    col += vec3(m);\n    \n    uv *= rotate2d(m*10.);\n    m = voronoi(vec3(uv*5.,1.));\n    col = vec3(pow(m, 1.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 61], [63, 63, 82, 82, 143], [144, 144, 164, 164, 268], [270, 270, 292, 292, 695], [697, 697, 722, 722, 985], [987, 987, 1015, 1015, 1101], [1103, 1103, 1160, 1160, 1480]]}
{"id": "tlV3Wd", "name": "curvature blindness cubes", "author": "ahihi", "description": "👀", "tags": ["2d"], "likes": 1, "viewed": 186, "published": "Public API", "date": "1580225624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n\nvec3 dark = vec3(0.27);\nvec3 mid = vec3(0.41);\nvec3 light = vec3(0.62);\n\nvec4 sine(vec2 k, float w, float t, vec2 p) {\n    float y = k.y * sin(k.x*p.x);\n    vec3 c = fract(k.x*(p.x+t)/TAU) < 0.5 ? light : dark;\n    return y - 0.5*w <= p.y && p.y <= y + 0.5*w ? vec4(c, 1.0) : vec4(0.0);\n}\n\nfloat map(float x, float l0, float r0, float l1, float r1) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nfloat imod(float x, float l, float r) {\n\treturn map(fract(map(x, l, r, 0.0, 1.0)), 0.0, 1.0, l, r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord/iResolution.xy*2.0 - 1.0)*vec2(1.0, iResolution.y/iResolution.x);\n   \tp = fragCoord * 0.005;\n    \n    float kt = 0.01*iTime;\n    vec2 sine_k = vec2(32.0, 0.013);\n    float dy = 0.1;\n    float w = 0.01;\n    float r = sine_k.y+w;\n    float l = -r;\n    float df = map(p.y + dy, l, r, 0.0, 1.0/3.0);\n    float d = floor(df);\n    float dir = mod(d, 2.0) < 1.0 ? 1.0 : -1.0;\n    float o = d * TAU * (dir >= 0.0 ? 0.5 : 0.0) / sine_k.x;\n    vec2 kp = vec2(kt * dir, dy);\n    vec2 p1 = p + kp;\n    p1.x += o;\n    p1.y = imod(p1.y, l, r); \n\n    vec3 bg = mid;\n    vec3 color = bg;\n    vec4 sine_color = sine(sine_k, w, -kt * dir + (dir >= 0.0 ? 0.5*TAU/sine_k.x : 0.0), p1);\n    color = mix(color, sine_color.rgb, sine_color.a);     \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 149, 149, 319], [321, 321, 381, 381, 430], [432, 432, 471, 471, 533], [535, 535, 592, 592, 1381]]}
{"id": "tlV3Wh", "name": "torus factory", "author": "alwas", "description": "torus factory 2d", "tags": ["2d", "torus", "sinus"], "likes": 2, "viewed": 53, "published": "Public", "date": "1579034276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.5);\n\n    // Calculate torus\n    const float speed = 5.0;\n    const float freq  = 15.0;\n    float gray = sin(iTime*(-speed)+length(uv)*freq);\n    vec3 col = vec3(gray,gray,gray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 395]]}
{"id": "tlV3Wy", "name": "Emissive Effect", "author": "yasuo", "description": "Emissive Effect with Japanease traditional textile", "tags": ["reflection", "emission"], "likes": 8, "viewed": 330, "published": "Public API", "date": "1579807574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 25.\n#define SURF_DIST .01\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// Try to add a glow color to the model, depending on the world position.\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\nfloat linear(float t) {\n  return t;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 Layer1(vec3 p,  float z, float speed, float dir, mat3 rot) {\n    p.z += iTime*3.0;\n    p.z += z;\n    p.z = mod(p.z,9.0)-4.5;\n    \n    p *= rot*matRotateX(radians(30.0*dir))*matRotateY(radians(40.0*dir));\n    p.y+=1.25;\n    \n    float y = 0.25;\n    \n    // box\n    float b = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.5,2.5,0.2));\n    float b2 = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.2,2.2,0.3));\n\n    float animTime = mod(iTime,speed*4.0);\n    float ey = 0.0;\n    ey += linear(animscene(animTime, 0.0, speed))*5.0;\n    ey += linear(animscene(animTime, speed*2.0, speed))*-5.0;\n    \n    float ex = 0.0;\n    ex += linear(animscene(animTime, speed, speed))*2.6;\n    ex += linear(animscene(animTime, speed*3.0, speed))*-2.6;\n    \n    vec3 emitPos = vec3((1.3*dir)-(ex*dir),1.25+(2.5-ey),0.0);\n    vec3 ecol = emitColor(p,emitPos, vec3(0.0,0.7,0.8),0.02,0.9,5.0);\n    \n    float d = max(-b2,b);\n    if(dir == 1.0){\n    \tp *= matRotateZ((z == 6.0) ?radians(30.0):radians(-30.0));\n\t\td = (z == 6.0) ?max(-p.y+0.5,max(-b2,b)):max(p.y-1.5,max(-b2,b));\t\n    }\n    \n    vec4 res = vec4(vec3(0.8)+ecol,d);\n    return res;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float _floor = p.y;\n    \n    vec4 layer1 = Layer1(p,0.0,0.5,1.0,matRotateZ(radians(iTime*50.0)));\n    vec4 layer2 = Layer1(p,3.0,1.0,-1.0,matRotateZ(radians(iTime*-60.0)));\n    vec4 layer3 = Layer1(p,6.0,1.5,1.0,matRotateZ(radians(iTime*70.0)));\n\tvec4 layers = combine(layer1,combine(layer2,layer3));\n\n    return layers;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat typoNine(vec2 p) {\n    float c0 = sdUnevenCapsule(p*Rot(radians(90.0)),0.15,0.15,0.14);\n    float c1 = sdUnevenCapsule(p*Rot(radians(90.0)),0.07,0.07,0.14);\n    float cut0 = dBox2d((p+vec2(-0.26,-0.04))*Rot(radians(20.0)),vec2(0.08,0.08));\n    float cut1 = dBox2d(p+vec2(-0.32,0.1),vec2(0.2,0.1));\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(-cut1,max(-cut0,max(-c1,c0))),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    cut0 = dBox2d((p+vec2(-0.05,0.2)),vec2(0.08,0.08));\n    float btmC = max(-cut0,min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2));\n    \n    return min(topC,btmC);\n}\n\nvec3 jpTraditionalTex(vec2 p, vec3 col, vec3 lcol) {\n    p.y -= iTime*0.1;\n    p*=1.5;\n    p = mod(p,0.4)-0.2;\n\n    \n    float len = 0.2;\n    float len2 = 0.15;\n    float l = sdLine(p,vec2(-len,-len),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,len),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(0.0,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len,0.0),vec2(len,0.0));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(-len*0.3,-len2),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,len2),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));    \n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col,lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(0.0,len),vec2(len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,len),vec2(-len*0.3,len2));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(0.0,-len),vec2(len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(0.0,-len),vec2(-len*0.3,-len2));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(len,0.0),vec2(len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n\tl = sdLine(p,vec2(-len,0.0),vec2(-len*0.7,-len2*0.4));\n\tcol = mix(col, lcol,S(l,0.0));\n    \n    l = sdLine(p,vec2(len*0.3,len2),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,len2*0.4),vec2(len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.3,-len2),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,-len2*0.4),vec2(-len,-len));\n\tcol = mix(col, lcol,S(l,0.0));    \n    \n\tl = sdLine(p,vec2(-len*0.3,len2),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(-len*0.7,len2*0.4),vec2(-len,len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.3,-len2),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));\n    l = sdLine(p,vec2(len*0.7,-len2*0.4),vec2(len,-len));\n\tcol = mix(col, lcol,S(l,0.0));      \n    \n    return col;\n}\n\nvec3 bg(vec2 p){\n    float d = smoothstep(0.0,0.2,p.y-sin(iTime*0.5)*0.5);\n  \tvec3 col = vec3(d);\n\tcol = mix(vec3(0.0,0.2,0.3), vec3(0.0,0.05,0.1),d);\n    \n\tcol = jpTraditionalTex(p,col,vec3(0.5));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 uvref = uv;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refl = bg(r.xy);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz+refl;\n        col *= dif.y;\n    } else {\n        // background\n        col = bg(uv);\n    }\n    \n    uv*=0.45;\n\t\n    float nine = typoNine(uv+vec2(0.05,-0.055));\n    col = mix( col, jpTraditionalTex(uvref,col,vec3(0.0,1.3,0.5))-vec3(0.8), S(nine,0.005) );\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 645, 675, 675, 725], [727, 727, 789, 789, 1028], [1030, 1030, 1079, 1079, 1198], [1200, 1200, 1241, 1241, 1332], [1334, 1334, 1370, 1370, 1412], [1414, 1414, 1443, 1443, 1527], [1529, 1603, 1705, 1705, 1845], [1847, 1847, 1870, 1870, 1884], [1886, 1998, 2045, 2045, 2086], [2088, 2088, 2153, 2153, 3192], [3194, 3194, 3216, 3216, 3563], [3565, 3565, 3598, 3598, 3851], [3853, 3853, 3877, 3877, 4078], [4080, 4080, 4114, 4114, 4428], [4430, 4430, 4473, 4473, 4776], [4778, 4778, 4801, 4801, 5202], [5204, 5204, 5246, 5246, 5441], [5443, 5443, 5467, 5467, 6238], [6240, 6240, 6292, 6292, 8545], [8547, 8547, 8563, 8563, 8767], [8769, 8769, 8826, 8826, 9783]]}
{"id": "tlV3Wz", "name": "3d ray-cone intersection", "author": "16807", "description": "Distance field to a cone. Click the screen to rotate.", "tags": ["raycasting", "cone", "analytic", "minimal"], "likes": 0, "viewed": 61, "published": "Public", "date": "1578718374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\nFUNC(bool) try_distance_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1,\n    IN(bool) is_intersection2, IN(float) entrance2,\n    OUT(float) entrance\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) try_distances_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    exit     = !is_intersection1 ? exit2     : !is_intersection2 ? exit1     : max(exit1,     exit2    );\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) is_3d_point_inside_sphere(IN(vec3) A0, IN(vec3) B0, IN(float) r){\n    return length(A0-B0) < r;\n}\n\nFUNC(float) get_distance_along_3d_line_to_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\nFUNC(bool) try_distance_along_3d_line_to_circle(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N, IN(float) r, OUT(float) intersection){\n    // intersection(plane, sphere)\n    float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    intersection = t;\n    return is_3d_point_inside_sphere(A0+A*t, B0, r);\n}\n\n\n/*\nA0:  origin of line\nA:   unit-length direction of line\nB0:  origin of cone\nB:   unit-length direction of cone\ncosa:cosine of half angle of cone\n*/\n\nFUNC(bool) try_distance_along_3d_line_to_infinite_cone(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) cosb, OUT(float) entrance)\n{\n\n    vec3 D = A0 - B0;\n\n    float a = dot(A,B)*dot(A,B) - cosb*cosb;\n    float b = 2. * (dot(A,B)*dot(D,B) - dot(A,D)*cosb*cosb);\n    float c = dot(D,B)*dot(D,B) - dot(D,D)*cosb*cosb;\n\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) \n    {\n        t = t2;\n    } else {\n        t = t1;\n    }\n\n    vec3 cp = A0 + t*A - B0;\n    float h = dot(cp, B);\n\n    entrance = t;\n    return t > 0. && h > 0.;\n}\n\nFUNC(bool) try_distance_along_3d_line_to_cone(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) B, IN(float) r, IN(float) h, OUT(float) entrance){\n    float a_in; bool a_hits = try_distance_along_3d_line_to_circle(A0,A, B0+B*h,B, r, a_in);\n    float b_in; bool b_hits = try_distance_along_3d_line_to_infinite_cone(A0,A, B0,B, cos(atan(r/h)), b_in);\n    b_hits = b_hits && dot(A0 + b_in*A - B0, B) <= h;\n    float c_in, c_out; bool c_hits = try_distance_along_line_to_union (a_hits, a_in, b_hits, b_in, c_in);\n    entrance = c_in;\n    return c_hits;\n}\n\nFUNC(bool) try_distance_along_3d_line_to_capped_cone(\n    IN(vec3) A0, IN(vec3) A, \n    IN(vec3) B1, IN(vec3) B2, IN(float) r1, IN(float) r2, \n    OUT(float) entrance\n){\n    float dh   = length(B2-B1);\n    float dr   = r2-r1;\n    float rmax = max(r2,r1);\n    float rmin = min(r2,r1);\n    float hmax = rmax * dr/dh;\n    float hmin = rmin * dr/dh;\n    vec3  B    = sign(dr) * normalize(B2-B1);\n    vec3  Bmax = (r2>r1? B2:B1);\n    vec3  B0   = Bmax - B*hmax;\n    vec3  Bmin = Bmax - B*hmin;\n\n    float a_in; bool a_hits = try_distance_along_3d_line_to_circle(A0,A, Bmax, B, rmax, a_in);\n    float b_in; bool b_hits = try_distance_along_3d_line_to_circle(A0,A, Bmin, B, rmin, b_in);\n    float c_in; bool c_hits = try_distance_along_3d_line_to_infinite_cone(A0,A, B0,B, cos(atan(rmax/hmax)), c_in);\n    float c_h = dot(A0 + c_in*A - B0, B);\n    c_hits = c_hits && hmin <= c_h && c_h <= hmax; \n    float d_in; bool d_hits = try_distance_along_line_to_union (a_hits, a_in,  b_hits, b_in, d_in);\n    float e_in; bool e_hits = try_distance_along_line_to_union (a_hits, a_in,  b_hits, b_in, e_in);\n    entrance = c_in;\n    return c_hits;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in; bool a_hits = try_distance_along_3d_line_to_cone(A0,A, vec3(0,0,0), vec3(1,0,0), 0.5f, 0.5f, a_in);\n    \n    \n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 341, 341, 498], [500, 500, 733, 733, 996], [998, 998, 1074, 1074, 1106], [1108, 1108, 1206, 1206, 1246], [1247, 1247, 1383, 1418, 1560], [1563, 1714, 1857, 1857, 2493], [2495, 2495, 2638, 2638, 3042], [3044, 3044, 3213, 3213, 4174], [4177, 4177, 4227, 4227, 4855], [4857, 4857, 4914, 4914, 5961]]}
{"id": "tlV3zK", "name": "Mandelbrot Vanish", "author": "sbrown2", "description": "My attempt at a mandelbrot implementation. ", "tags": ["2d", "fractal", "mandelbrot"], "likes": 0, "viewed": 41, "published": "Public", "date": "1579403612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    //play around to get the right camera. (big zoom)\n    float zoom = .01;\n    uv*=100.;\n    uv.x+=0.;\n    vec2 start = uv*zoom*3.;\n    start+=vec2(-.4,.4);\n    \n    vec2 z = vec2(0.);\n    \n    //control how crisply the set forms and how smoothly it animates\n    float max_steps = 100.*abs(cos(iTime));\n    float iter = 0.;\n    \n    \n    //MANDELBROT ALORITHM F(X) = z^2+c z,c in set of complex nums\n    for(float i = 0.; i < max_steps; i++){\n    \tz = start+vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);\n        if(length(z) > 3.){break;}\n        iter++;\n    }\n    \n    float f = iter/max_steps;\n    // Time varying pixel color\n\tvec3 col = vec3(f)*vec3(cos(f),abs(sin(f)),abs(sin(iTime)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 976]]}
{"id": "tlV3zy", "name": "Snaliens", "author": "noobcsf", "description": "Shader inspired in the artwork of Snaliens.", "tags": ["cute", "cartoon"], "likes": 35, "viewed": 2057, "published": "Public", "date": "1579279173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat saturate(float value)\n{\n\treturn max(0., min(value, 1.));   \n}\n\nvec4 eye_shape(vec2 uv, float blur, float id)\n{\n  uv.y -=0.05;\n\n  float blink = min((cos(iTime * 3. + id*37.) * 0.5 + 0.5)*20., 1.);\n  //uv.y /= blink;\n  //uv.x /= min(blink + 0.5, 1.);\n  float eye = length(uv) - .1;\n  float ring = length(uv) - .07;\n  float inner = length(uv) - .04;\n  vec2 uv2 = uv;\n  uv2.x *= 0.5;\n  uv2.y = -abs(uv2.y);\n  float eye2 = length(uv2-vec2(0., -0.2*blink)) - .1;\n  \n  uv2 = uv;\n  uv2.x = abs(uv2.x);\n  uv2.x *= 0.4;\n  uv2.y *= 1.5;\n  uv2.y += uv2.x*uv2.x*100.;\n  uv2.x -= (uv2.x*uv2.x)*0.01;\n  uv2.y -= 0.035;\n  float eye_white = length(uv2) - .01;\n\n  float eyeMask = smoothstep(blur, -blur, eye);\n  float eyeMask2 = smoothstep(blur, -blur, eye2);\n  float ringMask = smoothstep(blur, -blur, ring);\n  float innerMask = smoothstep(blur, -blur, inner);\n  float eye_whiteMask = smoothstep(blur, -blur, eye_white);\n  vec3 iris = vec3(221./255.,133./255.,37./255.);\n  iris += iris*0.15;\n  iris += (uv.y)/0.7*2.;\n  \n  eyeMask *= 1.-eyeMask2;\n  \n  vec3 color = vec3(1.);\n  color = mix(color, iris, ringMask);\n \n    \n  color -= mix(color, vec3(0.), 1.-innerMask);\n  color = mix(color, vec3(1.), eye_whiteMask);\n  \n  float shade = min(1. , (-eye/0.12/0.2)*0.5 + 0.6); \n  shade *= (uv.y)/0.25+ 0.9;\n  color *=vec3(1) * shade;\n  \n    return vec4(color, eyeMask);\n}\n\nvec4 body(vec2 uv, vec3 color,  float radius, float blur, float id)\n{\n\n  uv *= 1.0+(cos(iTime*4. + id)*0.5+0.5)*0.02;\n  \n  vec2 uvEye = uv - vec2(0., 0.24);\n  vec4 eye_color = eye_shape(uvEye, blur, id);\n\n  uv.x = abs(uv.x) * (1. + smoothstep(0.5, 0.0, uv.y)*0.2);\n\n  uv.x *= uv.x*2.0;\n  uv.x += 0.1;\n  uv.y -= 0.2;\n  uv.y *= 0.7;\n\n  float gradient_y = uv.y;\n\n  float body = length(uv) - radius;\n  \n\n  float bodyMask = smoothstep(blur, -blur, body);\n\n  float bodyShape = smoothstep(-.0 , 0.4, -body/ radius);\n\n  //color *= 0.5*bodyShape;\n  vec3 finalColor = color;\n  float gradient = min(1.,(0.5 + smoothstep(-0.1, 0.2, gradient_y)));\n  finalColor = color* bodyMask;\n  finalColor *= gradient;\n  finalColor += 0.3*(1.-bodyShape)*bodyMask;\n  //color *= smoothstep(0., 0.5, 1.0 - circle); \n\n  finalColor = mix(finalColor, eye_color.rgb, eye_color.w);\n\n  return vec4(finalColor, bodyMask);\n\n}\n\nvec4 starLayer2(vec2 uv)\n{\n  uv *= 10.;\n  uv *= 0.5;\n\n  vec2 lv = (fract(uv)-0.5);\n  vec2 id = ceil(uv);\n\n  float randomValue = (cos(id.y*733.23)*cos(id.x*52629.72))*0.5 + 0.5;\n\n  vec2 random = (sin(id.yx*23.89)*cos(id*3455.7))*0.5 + 0.5;\n\n  float sz = mix(2., 8., randomValue);\n  vec2 mv = vec2(\n    mix(-sz,sz, random.x)/4.,\n    mix(-sz,sz, random.y)/4.\n  );\n  lv *= sz;\n  lv += mv;\n\n\n  float time = cos(iTime*2.+ randomValue*2357.)*1.;\n\n  float len = abs(lv.x) * abs(lv.y);\n  float len2 = length(lv.xy);\n  vec3 col = vec3(1.);\n  len *= 40.0;\n  len = 1.-len;\n  len2 = 1.-len2;\n  col += smoothstep(0.5, 1.0, len2)*(1.-abs(cos(time*0.5)*0.5));\n  len2 = saturate(len2);\n  len*=len2;\n  \n  len -= (1. - abs(cos(time)*0.3));\n  len = smoothstep(-0.1, 0.1, len);\n  len = saturate(len);\n\n  vec3 star1 = vec3(1., 0.5, 0.5);\n  vec3 star2 = vec3(0.5, 0.5, 1.);\n  vec3 star = mix(star1, star2, randomValue);\n\n  col = star*len;\n  col += smoothstep(0.7, 1.0, len2)*1.;\n  return vec4(col, len);\n}\nvec4 stars(vec2 uv, float uvY)\n{\n  float y = uv.y;\n  vec4 s = vec4(0.);\n  uv*= 1.5;\n  vec4 sl = starLayer2(uv);\n  s = mix(s, sl, sl.w);\n\n  uv*= 1.5;\n  uv+=vec2(12.2);\n  sl = starLayer2(uv);\n  s = mix(sl, s, s.w);\n\n  //s = 1./s*0.0091;\n\n  vec3 color = vec3(0);\n  vec3 sky1 = vec3(7./255., 19./255., 44./255.);\n  vec3 sky2 = vec3(115./255., 172./255., 199./255.);\n\n  vec3 sky = mix(sky2, sky1, uvY);\n\n  //color.rg = lv;\n  color = s.rgb;\n  color = mix(sky*1.5, color, uvY - 0.3);\n\n  //color = vec3(1.) * s ;\n\n  return vec4(color, 1.);\n}\n\nfloat square(vec2 uv, float sY, float eY, float top, float bottom)\n{\n  uv.x = abs(uv.x);\n\n\n  float m = 0.001;\n  float h = mix(bottom, top, (uv.y-sY)/(eY-sY));\n\n\n  float k = smoothstep(-m, m, uv.y - sY);\n  k *= smoothstep(m, -m, uv.y - eY);\n  k *= smoothstep(m, -m, uv.x - h);\n\n  return k;\n\n}\nmat2 rot(float a)\n{\n  return mat2(cos(a), - sin(a), sin(a), cos(a));\n}\n\nfloat tree(vec2 uv)\n{\n  float f = square(uv, -0.1, 0.15, 0.10, 0.10);\n  //uv = rot(0.01+ cos(iGlobalTime)*0.1) * uv;\n  uv.y-= 0.16;\n  f += square(uv, -0.1, 0.35, 0.18, 0.35);\n  uv.y-= 0.35;\n  uv = rot(0.01 + cos(iTime)*0.1) * uv;\n  f += square(uv, -0.05, 0.25, 0.15, 0.3);\n  uv.y-= 0.25;\n  uv = rot(0.01 + cos(iTime)*0.1) * uv;\n  f += square(uv, -0.05, 0.45, 0.0, 0.25);\n\n  return f;\n}\n\nvec4 flr(vec2 uv)\n{\n  uv.y -=0.15;\n  vec3 color;\n  vec3 fg_color = vec3(32./255., 56./255., 103./255.);\n\n  float l = 1.;\n\n  uv.y += uv.x*uv.x*0.1;\n\n  l = smoothstep(0.0, 0.001, -uv.y);\n\n  color.rg = uv;\n  color = fg_color;\n\n  vec2 lv = rot(-0.12 + cos(iTime*2.)*0.01 ) * (uv + vec2(-0.55, 0.));\n  lv.y +=0.2;\n  lv*=1.7;\n  l += tree(lv);\n\n  lv = rot(0.12 + cos(iTime*2. + 23.)*0.1 ) * (uv + vec2(0.55, 0.));\n  lv*=1.8;\n  l += tree(lv);\n\n  l = saturate(l);\n\n  color *= 1. - uv.y*0.9;\n\n  return vec4(color, l);\n}\n\nfloat circle(vec2 uv, float radius, float blur)\n{\n  float circle = length(uv) - radius;\n  circle = smoothstep(blur, -blur, circle);\n  return circle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime * 1.0;\n  vec2 uv = (gl_FragCoord.xy / iResolution.x);\n  vec2 normalizedUV = gl_FragCoord.xy/iResolution.xy;\n\n  uv.x -= 0.5; \n  //uv.y -= (iResolution.y/iResolution.x)*0.5;\n  //uv.y\n  uv.y += 0.05;\n\n\n  vec4 col = vec4(0);\n\n  float blur = 0.001;\n  vec3 c1 = vec3(155./255.,197./255.,52./255.);\n  vec3 c2 = vec3(201./255.,45./255.,75./255.);\n  vec3 c3 = vec3(81./255.,169./255.,221./255.);\n\n  col.rg = uv;\n\n  uv *= 1.4;\n\n  vec4 b1 = body(uv, c1, 0.2, blur, 1.);\n  vec2 uv2 = rot(0.4) * (uv + vec2(0.2, 0.));\n  vec4 b2 = body(uv2, c2, 0.2, blur,2.);\n  uv2 = rot(-0.4) * (uv + vec2(-0.2, 0.));\n  vec4 b3 = body(uv2, c3, 0.2, blur,3.);\n\n  col = stars(uv, normalizedUV.y);\n  col = mix(col, b2, b2.w);\n  col = mix(col, b3, b3.w);\n  col = mix(col, b1, b1.w);\n\n  vec4 flr = flr(uv);\n  col = mix(col, flr, flr.w);\n  //col = b1+b2;\n  //col += body(uv, c1, 0.2, blur);\n\n  fragColor = vec4(col.rgb, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlV3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 68], [70, 70, 117, 117, 1353], [1355, 1355, 1424, 1424, 2243], [2245, 2245, 2271, 2271, 3227], [3228, 3228, 3260, 3260, 3761], [3763, 3763, 3831, 3831, 4054], [4055, 4055, 4074, 4074, 4125], [4127, 4127, 4148, 4148, 4512], [4514, 4514, 4533, 4533, 5023], [5025, 5025, 5074, 5074, 5175], [5178, 5178, 5235, 5235, 6148]]}
{"id": "tlVGDc", "name": "Rhombus 3D - distance", "author": "iq", "description": "A rhombus with thickness. Similar to [url]https://www.shadertoy.com/view/XdXcRB[/url], but extruded and with some rounding controls.", "tags": ["3d", "distancefield", "sdf", "distance", "rhombus", "primitive"], "likes": 6, "viewed": 825, "published": "Public API", "date": "1580127774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to rhombus with thickness and rounding.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sdRhombus(pos, 0.6, 0.2, 0.02, 0.02 ) - 0.01;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1141, 1288, 1317, 1317, 1345], [1347, 1387, 1451, 1451, 1709], [1712, 1712, 1738, 1738, 1797], [1799, 1863, 1895, 1895, 2134], [2154, 2154, 2211, 2236, 3770]]}
{"id": "tlVGDd", "name": "The Nautilus, Part 1", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Sea\"; part 1 of a series.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 14, "viewed": 234, "published": "Public API", "date": "1580231119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The Nautilus, Part 1\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Sea\"; part 1 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idGrnd = 14;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[1], rdb[1], bgCol, ltVec;\n  vec2 lbDist, ws;\n  float dstObj, dstGrnd, sh;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n  if (dstGrnd < min (dstObj, dstFar)) {\n    dstObj = dstGrnd;\n    idObj = idGrnd;\n  }\n  sh = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idGrnd) {\n      ro += dstObj * rd;\n      col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n         0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n         0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n      vn = GrndNf (ro);\n      vno = vec3 (0., 1., 0.);\n      if (vn.y > 0.85) {\n        vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n        vn = vn4.xyz;\n        col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n      }\n      vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n      ws = ro.xz - sbPos.xz;\n      ws = Rot2D (ws, sbRot);\n      sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n         vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n         1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n         (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vno = vn;\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n      if (col4.a >= 0.) {\n        col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n        col *= vec3 (0.7, 0.9, 1.);\n      } else {\n        col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n      }\n    }\n    col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n       (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n  } else {\n    col = UnwCol (rd) + WatShd (rd);\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n    if (lbDist.x < min (dstObj, dstFar))\n       col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  uv = fCoord;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  az = 0.;\n  el = 0.;\n  sbPos = vec3 (0., 0.09, 3. * tCur);\n  sbRot = 0.;\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  ro.xz = sbPos.xz + 24. * sin (0.01 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n  ro.y = -2.;\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 100.;\n  zmFac = 2.;\n  sunDir = normalize (vec3 (1., 3., -1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  uv *= vec2 (9./16., 1./0.85);\n  col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[128, 1229, 1252, 1252, 1494], [1496, 1496, 1530, 1530, 2009], [2011, 2011, 2033, 2033, 2172], [2174, 2174, 2199, 2199, 2578], [2580, 2580, 2624, 2624, 2818], [2820, 2820, 2844, 2844, 3175], [3177, 3177, 3217, 3217, 3677], [3679, 3679, 3702, 3702, 4122], [4124, 4124, 4147, 4147, 7028], [7030, 7030, 7052, 7052, 7212], [7214, 7214, 7247, 7247, 7430], [7432, 7432, 7453, 7453, 7708], [7710, 7710, 7747, 7747, 7988], [7990, 7990, 8013, 8013, 8349], [8351, 8351, 8385, 8385, 8607], [8609, 8609, 8632, 8632, 8891], [8893, 8893, 8932, 8932, 11570], [11572, 11572, 11607, 11607, 14022], [14024, 14024, 14069, 14069, 14822], [14824, 14824, 14880, 14880, 15353], [15355, 15355, 15388, 15388, 15477], [15479, 15479, 15525, 15525, 15572], [15574, 15574, 15607, 15607, 15634], [15636, 15636, 15678, 15678, 15729], [15731, 15731, 15790, 15790, 15921], [15923, 15923, 15976, 15976, 16037], [16039, 16039, 16061, 16061, 16099], [16101, 16101, 16137, 16137, 16343], [16345, 16345, 16390, 16390, 16493], [16495, 16495, 16552, 16552, 16635], [16637, 16637, 16667, 16667, 16780], [16814, 16814, 16838, 16838, 16891], [16893, 16893, 16917, 16917, 17047], [17049, 17049, 17073, 17073, 17136], [17138, 17138, 17162, 17162, 17382], [17384, 17384, 17409, 17409, 17595], [17597, 17597, 17622, 17622, 17847], [17849, 17849, 17874, 17874, 18195], [18197, 18197, 18222, 18222, 18368], [18370, 18370, 18392, 18392, 18546], [18548, 18548, 18569, 18569, 18724], [18726, 18726, 18747, 18747, 18902], [18904, 18904, 18933, 18933, 19145], [19147, 19147, 19186, 19186, 19371]]}
{"id": "tlVGDt", "name": "Octagrams", "author": "whisky_shusuky", "description": "Inspired by arabesque.\nhttps://cineshader.com/editor", "tags": ["raymarching", "cineshader"], "likes": 84, "viewed": 93716, "published": "Public API", "date": "1580222118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n\tpos.xy *= 5.;\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat result = -base;\n\treturn result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n\tfloat result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n\treturn result;\n}\n\nfloat map(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tfloat box_set1 = box_set(pos, iTime);\n\n\treturn box_set1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0., -0.2 ,iTime * 4.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\tray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n\tfloat t = 0.1;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\t\n\t\tfloat d = map(pos, iTime);\n\n\t\td = max(abs(d), 0.01);\n\t\tac += exp(-d*23.);\n\n\t\tt += d* 0.55;\n\t}\n\n\tcol = vec3(ac * 0.02);\n\n\tcol +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n\tfragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Octgrams\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 86, 105, 105, 162], [164, 164, 195, 195, 280], [282, 282, 316, 316, 470], [472, 472, 510, 510, 1281], [1283, 1283, 1317, 1317, 1401], [1404, 1404, 1461, 1461, 2147]]}
{"id": "tlVGRG", "name": "C_StarTravelling", "author": "hyrchao", "description": "小池塘遨游星翰\n\ninspired by https://www.youtube.com/watch?v=rvDo9LvfoVE&t=1307s", "tags": ["effect"], "likes": 5, "viewed": 84, "published": "Public", "date": "1579255839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPSILON 0.002\n#define STAR_COUNT 1.0\n#define STAR_LAYER 8.0\n#define STAR_SPEED 0.1\n\nconst float pi = 3.1415926;\n\nfloat saturate(float v) { return clamp(v, 0.0,       1.0);       }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  v) { return clamp(v, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\n// Calc color based on temperature (kelvins)\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n\tvec3 retColor;\n\t\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n    \n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n    \tfloat t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n    \n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor;\n}\n\n// Generate random number according to input vector2\nfloat Rand21(vec2 src)\n{\n\tvec2 rand = fract(src * vec2(233.33, 332.22));\n    rand += dot(rand, rand + vec2(66.6));\n    return fract(rand.x * rand.y);\n}\n\n// 2 dimension rotate \nvec2 Rotate(vec2 coord, float a)\n{\n    mat2 trans = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return trans * coord;\n}\n\n// Star pattern \nfloat DrawStar(vec2 coord , float crossIntensity)\n{\n    float distance = length(coord);\n    float light = 0.05 / distance;\n    float pattern = light;\n \tfloat crs1 = max(0.0, 1. - (abs(coord.x * coord.y * 1000.)));\n    pattern += crs1 * crossIntensity;\n    coord *= Rotate(coord, pi/4.);\n    float crs2 = max(0.0, 1. - (abs(coord.x * coord.y * 1000.)));\n    pattern += crs2 * 0.3 * crossIntensity;\n    \n    return smoothstep(1., .2, distance) * pattern;\n    //return distance / 50.; //debug range \n}\n\nvec3 StarLayer(vec2 coord)\n{\n    vec2 grid = fract(coord) - 0.5;\n    vec2 gridID = floor(coord);\n        \n    vec3 starPattern = vec3(0.0);\n    for (int i = -1; i <= 1; i++)\n        for (int j = -1; j <= 1; j++)\n        {\n            vec2 indexOffset = vec2(i, j);\n            vec2 id = gridID + indexOffset;\n            float rand = Rand21(id) - 0.5;\n            vec2 offset = vec2(rand, fract(rand * 23.3) - 0.5);\n            float size = fract(rand * 223.3);\n            // Calc star color based on star size and temporature\n            float tempRed = mix(7500.0, 1000.0, pow(size, 3.0));\n            // shape increase curve clamp to 0.0 to 1.0\n            float blueCurve = min(1.0, tan(size * 1.5) / 10.0);\n            float tempBlue = mix(7500.0, 30000.0, blueCurve);\n            float tempRand = fract(rand * 123.4) > 0.5 ? 1.0 : 0.0 ;\n            float temporature = mix(tempRed, tempBlue, tempRand);\n            vec3 starCol = ColorTemperatureToRGB(temporature);\n            // blink star based on layer (effected by otmosphere)\n            float blink = sin(iTime * 0.7 + rand * 33.22) * 0.4 + 0.6;\n            starPattern += DrawStar(grid - (indexOffset + offset), smoothstep(0.8, 1.2, size)) * size * starCol * blink;\n        }\n    return starPattern;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord/iResolution.xy - 0.5)* iResolution.y / iResolution.xy;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y ;\n    float t = (1.0 + sin(iTime)) * 1.5;\n    float k = t;\n    //uv *= k;\n    \n\tvec3 col = vec3(0.0);\n\n  \tuv = Rotate(uv, iTime * 0.1);\n    vec2 grid = uv * STAR_COUNT;;\n\n    for (float i = 0.0; i < 1.0; i += 1.0 / STAR_LAYER)\n    {\n    \tfloat depth = fract(iTime * STAR_SPEED + i);\n        float scale = mix(20.0, 0.1, depth);\n        // fade both in the begining and the end\n        float fade = depth * smoothstep(1.0, 0.9, depth);\n        col += StarLayer(grid * scale + i * 222.33) * fade;\n    }\n    //col = StarLayer(grid);\n    \n    // Debug\n    //float debugGridWidth = 0.01;\n    //float debugGrid = abs(grid.x - 0.5 + debugGridWidth) < EPSILON || abs(grid.y - 0.5 + debugGridWidth) < EPSILON ? 1.0 : 0.0;\n    //col *= 1. - debugGrid;\n    //col.b += debugGrid;\n\t//ol.rg *= gridID/.8; \n    \n    // Grid uv debug\n    //vec2 debugUV = grid;\n    //debugUV *= Rotate(debugUV, pi/4.);\n    //col.rg = debugUV;\n    \n    \n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 147, 147, 188], [189, 189, 214, 214, 255], [256, 256, 281, 281, 322], [323, 323, 348, 348, 389], [391, 436, 492, 492, 1279], [1281, 1334, 1358, 1358, 1485], [1487, 1510, 1544, 1544, 1628], [1630, 1647, 1698, 1698, 2145], [2147, 2147, 2175, 2175, 3413], [3415, 3415, 3472, 3554, 4578]]}
{"id": "tlVGzW", "name": "Ghostly Mandelbulb", "author": "onlinerocker", "description": "The mandelbulb!\nCheck the code's comments for more information...", "tags": ["fractal", "mandelbulb", "ghost"], "likes": 2, "viewed": 106, "published": "Public", "date": "1578451967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define ITERATIONS 2.0\n#define AA_SCALE 2.0\n\n//SETTINGS:\n#define VIEW_DIST 2.0\n\n//RESOURCES:\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n//https://www.iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n//https://www.iquilezles.org/www/articles/ftrapsgeometric/ftrapsgeometric.htm\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;    \n    o.dist = 1000.0;\n    \n    float ang = iTime/8.0;\n    float dz = 1.0;\n    float r;\n    \n    pos.xz *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    vec3 z = pos;\n    float power = 10.0+4.0*cos(iTime/8.0);\n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    \n    for(float x=0.0; x < 4.0; x++)\n    {\n        vec3 cartPos;\n    \tr = length(z);\n        float ang = acos(z.y / r);\n        float ang1 = atan(z.x, z.z);\n        \n        dz = power*pow(r, power-1.0)*dz + 1.0;     \n        r = pow(r, power);      \n        ang *= power;\n        ang1 *= power;\n        \n        cartPos.x = sin(ang)*sin(ang1);\n        cartPos.y = cos(ang);\n        cartPos.z = sin(ang)*cos(ang1);\n        \n        z = pos + (r * cartPos);    \n        minDist = min(minDist, length(z - pos)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n\n        if(length(z) > 2.0) { it = x; break; }\n    }\n\n    //Coloring based off orbits: https://www.iquilezles.org/www/articles/ftrapsgeometric/ftrapsgeometric.htm\n    o.color = vec3(0) + vec3(0.55, 0.9, 1.0)*sqrt(minDist);\n    o.color += vec3(0.3,0.3,0)*sqrt(mdX);\n    o.color += vec3(0.0,0.2,0)*sqrt(mdY);\n    o.color += vec3(0.0,0.1,0.2)*sqrt(mdZ);\n    \n    o.dist = 0.5*length(z)*log(length(z)) / length(dz);\n    \n    return o;\n}\n  \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed; \n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {   \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    //AA based off IQ's implementation in many different shaders\n    for(float x=0.0; x<AA_SCALE; x++){\n    for(float y=0.0; y<AA_SCALE; y++){\n        \n    vec2 aaOffset = vec2(x,y);\n    vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,0.0,1.2);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = PI/3.5;\n    float camAngPos = camAng;\n\n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n\n    camEye.xz = rotCamPos * camEye.xz;\n    dir.xz = rotCam * dir.xz;\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    vec3 tempCol = vec3(0);\n    if(res.totalDist < VIEW_DIST)\n    {\n        tempCol = res.obj.color;\n    }else{\n        //no object, no need to run AA\n        done = 1.0;\n     \tbreak;   \n    }\n    col += tempCol;\n\n    }\n        if(done > 0.0)\n            break;\n    }\n    \n    fragColor = vec4(col/(AA_SCALE*AA_SCALE),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 754, 776, 776, 2268], [2272, 2272, 2324, 2324, 2913], [2915, 2915, 2972, 2972, 4106]]}
{"id": "tly3D3", "name": "3D Spiral Flower", "author": "zovox", "description": "3-dimensional spiral flower.", "tags": ["spiral", "flower"], "likes": 4, "viewed": 215, "published": "Public API", "date": "1580063438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define E 2.7182818284\n//#define iTime 2.0*tan(1.0*iTime)\n\nfloat height(vec2 uv)\n{\n    float r = length(uv);\n    \n    if(r > 1.0) return 10.0;\n    \n    float sum = 0.0;\n    \n    \n    \n    for(int i = 0 ; i < 12; i++)\n    {\n        \n        //if(i < 64+int(sin(iTime)*64.0))\n        {\n            \n            //float theta1 = (7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime);\n\n            float awesome = pow(clamp(1.0-acos(cos((7.0*atan(uv.y, uv.x)-r*PI*4.0*cos(float(i)+iTime))+ cos(iTime))), 0.0, 1.0), PI);\n\n            sum = (sum+awesome);\n        }\n    \n    }\n    return -sum;\n}\n\nvec2 flower(vec3 p, vec3 d)\n{\n    \n    float zoom = 1.0;\n        \n    vec2 uv = p.xz*zoom/2.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv = vec2(uv.x*cos(iTime)-uv.y*sin(iTime),\n                 uv.x*sin(iTime)+uv.y*cos(iTime));\n    \n    //fragColor = 1.0-vec4(1.0-pow(1.0/E,2.0*PI*clamp(length(uv), 0.0, 1.0)));\n    \n    vec2 uv2 = uv + vec2(.01/iResolution.x,  0.0);\n    vec2 uv3 = uv + vec2(0.0,  .01/iResolution.y);\n    \n    vec3 p1 = vec3(uv, height(uv)).xzy;\n    vec3 p2 = vec3(uv2, height(uv2)).xzy;\n    vec3 p3 = vec3(uv3, height(uv3)).xzy;\n    \n    vec3 n = normalize(cross(p3-p1, p2-p1));\n    \n    return vec2(dot(p-p1, n), p1.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    \n    \n    vec3 origin = vec3(0.0, 1.0, 0.0);\n    vec3 rayOrigin = vec3(0.0, 1.5, .25);\n    vec3 rayPos = rayOrigin.xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 mainDir = normalize(origin-rayPos);\n    vec3 right = normalize(cross(up, mainDir));\n    up = normalize(cross(right, mainDir));\n    vec3 rayDir = normalize(mainDir-up*uv.y+right*uv.x);\n\n    \n    for(float t = 0.0; t < 100.0; t += 2.5)\n    {\n        vec2 dist = flower(rayPos, rayDir);\n        rayPos += .1*rayDir;\n        if( rayPos.y - dist.y < 0.0)\n            break;\n        else if(length(rayPos-rayOrigin) >= 10.0 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    \n    \n    vec2 sum = flower(rayPos, rayDir);\n    \n    fragColor.r = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*1.0)), 2.0);\n    fragColor.g = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*2.0)), 2.0);\n    fragColor.b = 1.0-pow(cos(rayPos.y*1.0+cos(iTime*3.0)), 2.0);\n    //fragColor.rgb *= sum.y-;\n    \n//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 84, 107, 107, 624], [626, 626, 655, 655, 1283], [1285, 1285, 1342, 1342, 2403]]}
{"id": "tly3Dz", "name": "organic look (II)", "author": "omis", "description": "Experiments with organic looking (pt.II).", "tags": ["2d", "noise", "organic"], "likes": 14, "viewed": 298, "published": "Public", "date": "1578663642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 p)\n{\n\treturn length(p) + 0.25;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = ( 2. * fragCoord - res ) / res.y;\n    \n    float c = circle(p);\n    float d = smoothstep(0.98, 0.99, c);\n    vec3 col = vec3(d-0.1);\n    \n    // fake diffuse\n    col += mix(vec3(smoothstep(c, 0.01, 0.15)*0.25), col, p.x * (1.0-d));\n    \n    // striatures\n\tvec2 pl = p;\n    pl.y*=100.0;\n    pl.y +=-0.5 + noise(iTime+pl*3.51)*0.532 + noise(iTime+pl*7.0)*1.065 + noise(iTime+pl*14.0)*2.13+sin(p.x*4.0)*2.0;\n    float l = sdLine(pl, vec2(-0.9, 0.0), vec2(1.1, -0.25));\n\t\n    // grainy glow\n    vec2 q = p; q*=10.52;\n    float g = noise(0.1*iTime+q*160.01);\n    g*=1.12; g+= noise(iTime+q*80.02)*0.02;\n    \n    col = mix(col, vec3(g), 1.0-l*(1.0-c));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 53], [55, 55, 104, 104, 223], [225, 225, 246, 246, 313], [315, 315, 336, 336, 545], [548, 548, 605, 605, 1392]]}
{"id": "tly3RD", "name": "RayMarching Sample", "author": "challenge", "description": "A basic raymarching demo", "tags": ["raymarchingsdf"], "likes": 2, "viewed": 185, "published": "Public API", "date": "1578562581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 ambientLight = vec3(0.1);\nconst vec3 specColor = vec3(0.04);\n\nconst float EPSILON = 0.00001;\n\nconst float UNITY_INV_PI = 0.31830988618f;\nconst float UNITY_PI = 3.14159265359f;\n\nconst int maxSteps = 256;\n\n#define SHOW_NORMAL 0\n#define SHOW_DEPTH 0\n#define SHOW_MATERIAL_BASECOLOR 0\n#define SHOW_MATERIAL_SMOTHNESS 0\n\n#define SHOW_FOG 1\n#define CAMERA_ROTATE 1\n#define LIGHT_ROTATE 0\n#define LIGHT_ADD 0\n\n#define SMOTHNESS_TEST 1\n\nfloat showNormal;\nfloat showDepth;\nfloat showReflection;\n\nstruct LightData\n{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n    \nLightData mainLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(30.32, 20.77, 0.56);\n    #if LIGHT_ROTATE\n    \tl.pos = vec3(30.32*sin(iTime), 20.77, 0.56*cos(iTime));\n    #endif\n    l.color = vec3(1.0, 1.0, 1.0) * l.intensity;\n    return l;\n}\n\nLightData addLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(-30.32, 20.77, 0.56);\n    l.color = vec3(0.2, 0.9, 0.67) * l.intensity;\n    return l;\n}\n\nstruct MaterialData\n{\n    vec3 diffColor;\n    float smoothness; \n};\n\nfloat sdPlane( vec3 p, vec3 o)\n{\n  return p.y;\n}\n\nfloat udBox( vec3 p, vec3 o, vec3 b )\n{\n  return length(max(abs(p - o)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, vec3 o, float s )\n{\n  return length(p - o)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sceneSDF(vec3 samplePoint) {\n    \n    vec2 res = vec2(1e10, 0.0);\n    \n    vec2 cube = vec2(udBox(samplePoint,vec3(-1.0, 0.8, 0.0), vec3(0.8)), 4.0);\n    vec2 sphere = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, 2.0), 1.0), 2.0);\n    vec2 plane = vec2(sdPlane(samplePoint, vec3(0.0, 0.0, 0.0)), 0.0);\n    vec2 sphere2 = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, -2.0), 1.0), 8.0);\n    \n\tres = opU(res, cube);\n    res = opU(res, sphere);\n    res = opU(res, sphere2);\n    res = opU(res, plane);\n    \n    return res;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat DisneyDiffuse(float NdotV, float NdotL, float LdotH, float perceptualRoughness)\n{\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    float lightScatter   = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL, 5.0));\n    float viewScatter    = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV, 5.0));\n\n    return lightScatter * viewScatter;\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    float a = roughness;\n    float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n    float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);\n}\n\nvec3 FresnelTerm (vec3 F0, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\nvec3 FresnelLerp (vec3 F0, vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return mix (F0, F90, t);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (2.5-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h =sceneSDF( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 BRDF(LightData light, vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n    float smoothness = mat.smoothness;\n    vec3 diffColor = mat.diffColor * 0.96;\n    float perceptualRoughness = 1.0 - smoothness;\n    float roughness = perceptualRoughness * perceptualRoughness;\n    roughness = max(roughness, 0.002);\n    \n    float sd = calcSoftshadow(p, light.pos, 0.03, 2.5);\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.pos - p);\n    vec3 viewDir = normalize(eye - p);\n    vec3 H = normalize(L+viewDir);\n    vec3 R = normalize(reflect(-L, N));\n    \n    // 计算反射\n    vec3 ref = reflect(rd, N );\n    float dom = smoothstep( -0.2, 0.2, ref.y);\n    dom *= calcSoftshadow(p, ref, 0.2, 2.5);\n    \n  \n    //return vec3(dom);\n    vec3 reflectColor = smoothness*dom*vec3(0.40,0.60,1.30);\n    \n    if (showReflection > EPSILON) {\n\t\treturn reflectColor;\n    }\n    float NdotL = clamp(dot(N, L), 0.0, 1.0) * sd;\n    float NdotV = clamp(dot(N, viewDir), 0.0, 1.0);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0);\n    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n    \n    float diffuseTerm = DisneyDiffuse(NdotV, NdotL, LdotH, perceptualRoughness) * NdotL;\n    float D = GGXTerm (NdotH, roughness);\n    float V = SmithJointGGXVisibilityTerm (NdotL, NdotV, roughness);\n    float specularTerm = V*D * UNITY_PI;\n    specularTerm = max(0.0, specularTerm * NdotL);\n    \n    float surfaceReduction = 1.0 / (roughness*roughness + 1.0);\n    vec3 grazingTerm = vec3(clamp(smoothness + 0.04, 0.0, 1.0));\n    \n    vec3 color = diffColor *(ambientLight + light.color * diffuseTerm)\n        \t\t+ specularTerm * light.color * FresnelTerm (specColor, LdotH) \n        \t\t+ surfaceReduction * reflectColor * FresnelLerp (specColor, grazingTerm, NdotV);\n    \n    return color;\n}\n\nvec3 illumination (vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n\tLightData light1 = mainLight();\n    \n    vec3 color = BRDF(light1, p, eye, rd, mat);\n    \n    #if LIGHT_ADD\n    \tLightData light2 = addLight();\n        vec3 addColor = BRDF(light2, p, eye, rd, mat);\n        color += addColor;\n    #endif\n    \n    return color;\n}\n\nvec3 ACESToneMapping(vec3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n \n\tcolor *= adapted_lum;\n\treturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nMaterialData GetDiffColor(vec3 p, float m) \n{\n    MaterialData material;\n    if (m < EPSILON) {\t\n        material.diffColor = checkers(p.xz) * vec3(0.5, 0.0, 0.0);\n        material.smoothness = 1.0;\n    } else if (m - 2.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.5, 0.0) ;\n        material.smoothness = 0.9;\n        #if SMOTHNESS_TEST\n        \tmaterial.smoothness = abs(sin(iTime));\n        #endif\n        \n    } else if (m - 4.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.0, 0.5) ;\n        material.smoothness = 0.2;\n    } else if (m - 8.0 < EPSILON) {\n        material.diffColor = vec3(0.98, 0.51, 0.91) ;\n        material.smoothness = 0.2;\n    } else {\n        material.diffColor = vec3(0.5);\n    \tmaterial.smoothness = 0.5;\n    }\n    \n    return material;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord/iResolution.xy;\n\tvec2 uv = 2.0 * uv1;\n    //vec2 uv = uv1;\n    uv = fract(uv);\n\tuv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv1 -= .5;\n    uv1.x *= iResolution.x / iResolution.y;\n\n    showNormal = step(uv1.x, 0.0) * step(uv1.y, 0.0);\n    showDepth = step(-uv1.x, 0.0) * step(uv1.y, 0.0);\n    showReflection = step(-uv1.x, 0.0) * step(-uv1.y, 0.0);\n   \n    // 设置相机位置\n    vec3 ro = vec3(6.0,6.0, -6.0);\n    //ro += vec3( 4.5*cos(0.1*iTime + 16.0), 1.0 + 2.0, 4.5*sin(iTime + 16.0) );\n    #if CAMERA_ROTATE\n        ro = vec3(10.5*cos(iTime * 0.2), 5.0, -10.5*sin(iTime * 0.2));\n    #endif\n    \t\n\n    float zoom = 1.0;\n   \t// 设置看向的点\n    vec3 lookAt = vec3(0.5, 0.5, 0.5);\n    \n    // 格拉姆—施密特正交化\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    // 将2纬UV 升到 3纬坐标\n    vec3 i = c + uv.x*r + uv.y*u;\n    // 得到相机指向UV点的向量\n\tvec3 rd = i - ro;\n    \n    vec4 color = vec4(0.0);\n    \n    // Ray Marching\n    float t = 0.0;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n       \t\n        vec2 res = sceneSDF(p);\n        float d = res.x;\n        float m = res.y;\n        \n        if(d < EPSILON)\n        {\n            if (showNormal > EPSILON) {\n                color.rgb = (estimateNormal(p) + 1.0) * 0.5;\n            } else if (showDepth > EPSILON) {\n                color.rgb = vec3(t/20.0);\n            } else {\n                \n                // 获取命中物体的材质属性\n                MaterialData mat = GetDiffColor(p, m);\n\n                #if SHOW_MATERIAL_BASECOLOR\n                color.rgb = pow(mat.diffColor, vec3(0.4545));\n                #elif SHOW_MATERIAL_SMOTHNESS\n                color.rgb = vec3(mat.smoothness);\n                #else\n                // 渲染\n                color.rgb += illumination(p, ro, rd, mat);\n                #endif\n            }\n            \t\n\n            \n\n            \n            break;\n        }\n\n        float add = d;\n        \n        t += add;\n        \n        #if SHOW_FOG\n        \tcolor.rgb = mix( color.rgb, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n        #endif\n        \n    }\n    \n    // Tonemapping\n    color.rgb = ACESToneMapping(color.rgb, 1.0);\n    // 抵消屏幕Gamma矫正\n    color.rgb = pow( color.rgb, vec3(0.4545) );\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 576, 599, 599, 833], [835, 835, 857, 857, 1000], [1071, 1071, 1103, 1103, 1119], [1121, 1121, 1160, 1160, 1202], [1204, 1204, 1247, 1247, 1275], [1277, 1277, 1307, 1307, 1340], [1342, 1342, 1375, 1375, 1860], [1862, 1862, 1891, 1891, 2213], [2215, 2215, 2302, 2302, 2588], [2590, 2590, 2636, 2636, 2955], [2957, 2957, 3036, 3036, 3216], [3218, 3218, 3258, 3258, 3358], [3359, 3359, 3409, 3409, 3508], [3510, 3510, 3588, 3611, 4000], [4002, 4002, 4075, 4075, 5765], [5767, 5767, 5832, 5832, 6095], [6097, 6097, 6150, 6150, 6364], [6367, 6367, 6396, 6396, 6449], [6451, 6451, 6496, 6496, 7236], [7239, 7239, 7296, 7296, 9751]]}
{"id": "tly3RV", "name": "RingTest", "author": "dila", "description": "Test", "tags": ["raymarch"], "likes": 10, "viewed": 211, "published": "Public", "date": "1579366195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nmat2 timerot(float f, float t, float n) {\n\treturn rot(mix(f,0.0,clamp(abs(mod(t,n)),0.0,1.0)) * 3.141592);\n}\n\nfloat ismissing(float t) {\n    return min(mod(t, 2.0) * mod(t, 3.0) * mod(t, 5.0), 1.0);\n}\n\nfloat cutbox(vec3 p, float a, float b) {\n    vec3 q = abs(p);\n    float ba = max(q.x - a, q.y - a);\n    float bb = max(q.x - b, q.y - b);\n    return max(max(ba, -bb), q.z - 0.1);\n}\n\nfloat map(vec3 p) {\n    float gt = iTime * 2.0;\n    \n    float t = floor(mod(gt, 30.0));\n    float f = smoothstep(0.0, 1.0, fract(gt));\n    \n\tfloat nt = ismissing(t);\n    \n    vec3 q = p;\n    q.z += mix(0.0, sin(f*3.141592*1.0), nt);\n    q.yz *= timerot(f, t, 2.0);\n    float disk3 = cutbox(q, 3.0, 2.3);\n\n    q = p;\n    q.z += mix(0.0, sin(f*3.141592*2.0), nt);\n    q.xz *= timerot(-f, t, 3.0);\n    float disk2 = max(max(length(q.xy) - 2.0, 1.5 - length(q.xy)), abs(q.z) - 0.1);\n    \n    q = p;\n    q.z += mix(0.0, sin(f*3.141592*3.0), nt);\n    q.xy *= timerot(-f, t, 5.0);\n    float disk1 = cutbox(q, 0.9, 0.4);\n    \n    vec2 r = vec2(p.z + 3.0, (abs(p.x / 5.0) - 0.5) * 5.0);\n    float back = length(r) - 0.2;\n    p.xy *= rot(3.141592 * 0.5);\n    r = vec2(p.z - 4.0, (abs(p.x / 16.0) - 0.5) * 16.0);\n    back = min(back, length(r) - 0.25);\n    \n    return min(min(min(disk1, disk2), disk3), back);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n  float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 light(vec3 w, vec3 n, vec3 p, vec3 c) {\n\tvec3 d = w - p + n * 0.01;\n    float l = length(d);\n    float m = max(sign(trace(p, d / l) - l), 0.0);\n    float a = 1.0 / (1.0 + dot(d, d) * 0.01);\n    float s = max(dot(d / l, -n), 0.0);\n    return s * a * c * m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.2));\n    vec3 o = vec3(0.0, 0.0, -6.0);\n\n    float gt = iTime * 2.0;\n    float nt = floor(mod(gt, 30.0));\n    float nf = smoothstep(0.0, 1.0, fract(gt));\n    float isp = mix(0.0, sin(-nf*3.141592*2.0), ismissing(nt));\n    o.z -= isp;\n    r.xy *= rot(3.141592 * -0.25) * timerot(-nf, nt, 5.0);\n\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 n = normal(w);\n    \n    vec3 lit = light(w, n, vec3(1.0, 2.0, -5.0), vec3(0.75, 0.5, 0.5));\n\tlit += light(w, n, vec3(0.0, 0.0, -6.0), vec3(0.0, 0.5, 1.0));\n\n    fragColor = vec4(vec3(sqrt(lit)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [73, 73, 114, 114, 181], [183, 183, 209, 209, 273], [275, 275, 315, 315, 455], [457, 457, 476, 476, 1359], [1361, 1361, 1382, 1382, 1583], [1585, 1585, 1614, 1614, 1717], [1719, 1719, 1763, 1763, 1981], [1983, 1983, 2040, 2040, 2766]]}
{"id": "tly3zK", "name": "ShaderDojo 043", "author": "antonOTI", "description": "A shader form a wish card project =)\nOn one side of the wish card is the shader, on the other is the code.", "tags": ["star", "minimal", "cookie"], "likes": 1, "viewed": 237, "published": "Public API", "date": "1579474662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tau=6.28318;\nfloat star(vec3 p,float t,out float i){\n float re=tau/5.,a=mod(atan(p.y,p.x)+re*t*.25,re)-re*.5,\n l=length(p.xy);\n vec3 q=vec3(cos(a)*l,sin(a)*l,p.z*p.z*10.),d=vec3(1.,0.,0.);\n i=length(q.xy-d.xy*clamp(dot(q.xy,d.xy),.0,1.))-(.5-q.x*.25);\n return length(q-d*clamp(dot(q,d),.0,1.))-(.5-q.x*.25);\n}\nfloat m(vec3 p,out float i){\n float t=iTime*2.,a=atan(p.y,p.x);\n return min(star(p*vec3(2.,2.,1.),t*.25,i),\n  star(vec3(mod(p.z+1.5,3.)-1.5,\n   mod(a*12.+tau*.5+t*(mod(floor((p.z+1.5)/3.),2.)*3.-1.5),tau)-tau*.5,\n    length(p.xy)-5.),t,a));\n}\nvoid mainImage(out vec4 col,in vec2 coord){\n  vec2 uv=(coord-iResolution.xy*.5)/iResolution.y,e=vec2(.01,.0);\n  vec3 ro=vec3(0.,0.,-3.),rd=normalize(vec3(-uv,1.)),cp=ro+rd;\n  float st=0.,dist=0.,cd=0.,i,g;\n  for(;st<1.;st+=1./200.){\n   cd=m(cp,i);\n   if(abs(cd)<.01||cd>300.)break;\n   dist+=cd*.05;\n   cp=ro+rd*dist;\n  }\n  col=mix(vec4(1.,.8,.0,0.),vec4(0.),length(uv)-st*st)+st*st;\n  if(cd<.01){\n  vec3 n=normalize(vec3(cd-m(cp+e.xyy,g),cd-m(cp+e.yyx,g),\n  cd-m(cp+e.yyx,g)));\n  float li=clamp(dot(n,vec3(.577)),0.,1.);\n  col.rgb=vec3(.95,.4,.12)*.25;\n  col.rgb+=vec3(1.,1.,1.)*li*.75;i=-i;\n  col.rgb=mix(col.rgb,vec3(1.,1.,0.)*1.2,(i+pow(i,4.)+step(.125,i))/3.);\n }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tly3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 58, 58, 315], [316, 316, 344, 344, 558], [559, 559, 602, 602, 1228]]}
{"id": "tlyGDc", "name": "Code Demon", "author": "zovox", "description": "A code demon.", "tags": ["code", "demon"], "likes": 2, "viewed": 189, "published": "Public API", "date": "1580063499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define MATRIX_W (floor(MAX_DIM/75.0))\n#define MATRIX_H (floor(MAX_DIM/75.0))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define zero(x) (smoothstep(-1.0/GR/PI/E, 1.0/GR/PI/E, x))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch;\nvec2 targetResolution = vec2(512.0);\n\n\n//-----------------AUDIO ALGORITHM-----------------\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time/GR), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    final *= 2.0;\n    final -= .25;\n    \n\tfinal = sqrt(clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 numerator = cmul(uv, multa) + offa;\n    vec2 denominator = cmul(uv, multb) + offb;\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = (cdiv(numerator, denominator));\n    \n    for(int i = 0 ; i < 4; i++)\n    {\n        numerator = cmul(uv, multa) + offa+sin(vec2(float(i)-time*GR, -float(i)+time));\n        quotient += (cdiv(numerator, quotient));\n    }\n    \n    \n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    seedling = (floor(quotient.x)*3.0+floor(quotient.y));\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    return final;\n}\n    \n\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*(7.0+saw(time)))/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))*.25+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return vec3(clamp(eyes+teeth, 0.0, 1.0));\n}\n\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\nvec4 fire(vec2 p)\n{\n    p.x *= 1.0/E/GR;\n    p.y *= PI/GR;\n    float tempX = (p.y+.5)*cos(p.x*4.0*PI+time)*2.0;\n    float tempY = (p.y+.5)*sin(p.x*4.0*PI+time)*2.0;\n\n    p.x = tempX;\n    p.y = tempY;\n\n\n    p.x += .5*snoise(vec2(time*.6+256.0, p.y));\n    p.y += .5*snoise(vec2(time*.6+500.0, p.x));\t\n\n    float x_max = 0.56999993;\n    float y_max = 0.74999976;\n\n    float R = x_max;\n    float r = .1;\n\n    float x = snoise(vec2(time*.6+256.0, p.y))*.25+.875;\n    float y = snoise(vec2(time*.6+256.0, p.x))*.25-.625;\n\n    vec4 c = vec4(x, y, 0.0, 0.0);\n\n    vec2 Z = p*vec2(.85,1.0);\n    int iterations_temp;\n    const float max_iterations =6.0;\n    float depth_trap = 4500.0;\n    for(int iterations=0; iterations < int(max_iterations); iterations++) \n    {\n        Z = c.xy + cmul(Z.xy, vec2(tanh(Z.x), tanh(Z.y)));\n\n        if(dot(Z,Z)>depth_trap) {\n            break;\n        }\n        iterations_temp = iterations;\n    }\n\n    float NIC = (Z.x * Z.x) + (Z.y * Z.y);\n    NIC = float(iterations_temp)/max_iterations-log(sqrt(NIC))/float(iterations_temp);\n    float red = clamp(sin(NIC)+.25, 0.0, 1.0);//red*3.0/4.0);\n    float green = clamp(sin(NIC)*sin(NIC), 0.0, red*3.0/5.0);\n\n    /*\nint temp = int(p.x*64.0);\nfor(int i = 0; i < 64 i++)\nif(i == temp)\ngreen = Frequency[int(i)];\n*/\t\n\n    //if(red -green > 0.79) return texture(Frequency, vec2(p.x, p.y)).rgba;\n    return vec4(red, green , 0.0, 0.0);\n\n    /*\n//3-phase flux of 3 different coloring patterns\nreturn vec4(red, green, blue, 0.0) * clamp(sin(time*5.0+0.0), 0.0, 1.0)\n+ vec4(green, red, green, 0.0) * clamp(sin(time*5.0+4.0*PI/3.0), 0.0, 1.0)\n+ vec4(green, green, red, 0.0) * clamp(sin(time*5.0+2.0*PI/3.0), 0.0, 1.0);\n*/\n}\n\nvec3 scienceordie(vec2 uv)\n{\n    \n    float scale = E/GR;\n    uv = uv*scale-scale/2.0;\n    //uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), sin(time*PI)).xy;\n    //uv += cos(vec2(time*PI, time*GR*PI))/GR/PI;\n    uv.y -= .1/GR;\n    float depth = demon(uv).r;\n    float angle =  depth*PI+time;\n    \n    //uv.xy += depth*vec2(cos(angle), sin(angle))/MATRIX_W;\n    \n    vec2 fract_matrix = fract(uv*vec2(MATRIX_W,MATRIX_H));\n    vec2 floor_matrix = floor(uv*vec2(MATRIX_W,MATRIX_H));\n    float number = (mod(time*sin(floor_matrix.x+floor_matrix.y*MATRIX_W), 10.0));\n    float digit = SampleDigit(number, GR*fract_matrix);\n    \n    \n    vec3 body = smoothstep(0.0, 1.0/GR, smoothstep(0.0, 1.0/GR*E/PI, sqrt(clamp(1.0-length(uv*vec2(1.0, 1.0/GR)*GR), 0.0, 1.0)))*demon(uv*1.125));\n    \n    vec3 science = vec3(0.0, digit, 0.0)*(1.0-body)+body;\n\tfloat or = zero(-uv.x);\n    \n    vec4 die = clamp(fire(uv), 0.0, 1.0);\n    \n    vec3 scene = science*or+(1.0-body)*(1.0-or)*die.rgb;;//+(1.0-or)*body*flux(time+body.r*PI*2.0);\n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor.rgb = scienceordie(uv);\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1175, 1228, 1248, 1248, 1626], [1628, 1683, 1704, 1704, 1755], [1757, 1757, 1778, 1778, 1829], [1831, 1831, 1853, 1853, 1892], [1894, 1894, 1916, 1916, 3522], [3524, 3524, 3545, 3545, 3596], [3598, 3598, 3620, 3620, 3659], [3661, 3661, 3689, 3689, 3743], [3745, 3745, 3767, 3767, 6025], [6026, 6150, 6171, 6171, 6534], [6536, 6536, 6558, 6558, 7466], [7468, 7531, 7560, 7560, 7630], [7632, 7632, 7661, 7661, 7745], [7747, 7747, 7815, 7815, 8579], [8581, 8643, 8748, 8748, 9417], [9424, 9424, 9448, 9448, 9912], [9914, 9914, 9939, 9939, 10241], [10243, 10243, 10264, 10264, 10379], [10482, 10482, 10543, 10543, 12284], [12286, 12286, 12305, 12305, 13970], [13972, 13972, 14000, 14000, 15012], [15014, 15014, 15071, 15071, 15184]]}
{"id": "tlyGW1", "name": "Z rotation gone wrong", "author": "timeisbeautifulhere", "description": "For some reason my z rotation matrix does this???", "tags": ["triangle", "barycentric", "rotation"], "likes": 0, "viewed": 41, "published": "Public", "date": "1578794104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Verticies of a basic tesselated square\nvec3 verts[4] = vec3[](\n\tvec3(-1.0,-1.0,1.0),\n\tvec3(1.0,-1.0,1.0),\n\tvec3(-1.0,1.0,1.0),\n\tvec3(1.0,1.0,1.0)\n);\n\n//Faces of the square\nvec3 faces[2] = vec3[](\n\tvec3(0.0, 1.0, 2.0),\n\tvec3(1.0, 3.0, 2.0)\n);\n\n//Not used\nmat3 rotateY = mat3(\n\tcos(45.0), 0.0, (-1.0)*sin(45.0),\n\t0.0, 1.0, 0.0,\n\tsin(45.0), 0.0, cos(45.0)\n);\n\n//Convert to radians\nfloat rads(float deg){\n\treturn deg * (3.14159 / 180.0);\n}\n\n//Z rotation matrix as a function of time\nmat3 getZRotate(float time){\n\tfloat rad = rads(10.0 *time);\n\t\n\tmat3 rot = mat3(\n\t\tcos(rad), sin(rad), 0.0,\n\t\t(-1.0)*sin(rad), cos(rad), 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n\t\n\treturn rot;\n}\n\n\t\n/*\nTransform the face, then convert coordinate to barycentric \ncoordinates of that face to see if it's inside.\n*/\nbool checkTriangleIntersect(vec3 face, vec2 coord){\n\tmat3 rotateZ = getZRotate(iTime);\n\t\n    vec3 v1 = rotateZ * verts[int(face[0])];\n\tvec3 v2 = rotateZ * verts[int(face[1])];\n\tvec3 v3 = rotateZ * verts[int(face[2])];\n\t\n\tfloat b1 = (((v2.y-v3.y)*(coord.x-v3.x)) + ((v3.x-v2.x)*(coord.y-v3.y))) / \n\t\t\t\t(((v2.y-v1.x)*(v1.x-v3.x)) + ((v3.x-v2.x)*(v1.y-v3.y)));\n\t\n\tfloat b2 = (((v3.y-v1.y)*(coord.x-v3.x)) + ((v1.x-v3.x)*(coord.y-v3.y))) / \n\t\t\t\t(((v2.y-v3.y)*(v1.x-v3.x)) + ((v3.x-v2.x)*(v1.y-v3.y)));\n\t\n\tfloat b3 = 1.0 - b1 - b2;\n\t\n\treturn b1>=0.0 && b1<=1.0 && b2>=0.0 && b2<=1.0 && b3>=0.0 && b3<=1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //[-4, 4]\n    vec2 uv = 4.0 * ((2.0 * (fragCoord/iResolution.xy)) - 1.0);\n    \n\t//Check if coord is within any faces\n    vec3 col;\n    for(int i=0;i<faces.length();i++){\n\t\tif(checkTriangleIntersect(faces[i], uv)){\n\t\t\tif(i%2==0)\n\t\t\t\tcol = vec3(1.0, 0.0, 0.0);\n\t\t\telse\n\t\t\t\tcol = vec3(0.0, 1.0, 0.0);\n\t\t}\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 380, 402, 402, 437], [439, 481, 509, 509, 658], [662, 776, 827, 827, 1378], [1381, 1381, 1438, 1452, 1808]]}
{"id": "tt3GRN", "name": "Happy 2020!", "author": "piyushslayer", "description": "Happy new year everyone!\n\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\nv1.2 Improved water reflections.\nv1.3 Added a crescent moon.\nv1.4 Rockets slow down nearing apex.", "tags": ["noise", "reflection", "fbm", "water", "particles", "city", "lights", "fireworks"], "likes": 55, "viewed": 2845, "published": "Public API", "date": "1577835221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n This shader is basically an improvement upon a previous fireworks shader I did a while\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\n instead of the just following the same pattern in a loop, so the fireworks show can be\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\n\n I wish a very happy and a prosperous new year to everyone!\n*/\n\n#define PI  3.141592653589793\n#define TAU 6.283185307179586\n\n// Helper macros \n#define C(x) clamp(x, 0., 1.)\n#define S(a, b, x) smoothstep(a, b, x)\n#define F(x, f) (floor(x * f) / f)\n\n// Fireworks control variables\n#define FIREWORK_COUNT 8\n#define FIREWORK_DURATION 8.\n#define FIREWORK_LOW .75\n#define FIREWORK_HIGH 1.05\n#define ROCKET_PARTICES 16\n#define ROCKET_DURATION 1.5\n#define FLASH_DURATION ROCKET_DURATION + .2 \n#define THRUSTER_SPEED .25\n#define EXPLOSION_STRENGTH .025;\n#define EXPLOSION_PARTICLES 100\n\n// Hash functions by Dave_Hoskins\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 hash31(float p)\n{\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn vec3(n) * (1. / float(0xffffffffU));\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\n\tuint q = (n.x ^ n.y) * 1597334673U;\n\treturn float(q) * (1. / float(0xffffffffU));\n}\n\n// Function to remap a value from [a, b] to [c, d]\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Noise (from iq)\nfloat noise (in vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3. - 2. * f);\n\tf.xy += p.xy + p.z * vec2 (37., 17.);\n\tf.xy = texture (iChannel0, (f.xy + .5) / 256., -256.).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\n// Tiny fbm\nfloat fbm (in vec3 p) {\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\n}\n\n// Building window lights from www.shadertoy.com/view/wtt3WB\nfloat windows (vec2 uv, float offset)\n{\n    vec2 grid = vec2(20., 1.);\n    uv.x += offset;\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\n    uv.x *= n1 * 6.;\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\n    float n = fbm(id.xxx);\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\n    vec2 lPos = fract(uv * lightGrid);\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\n    n2 = smoothstep(.225, .5, n2);\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\n}\n\n// Building skyline \nfloat buildings(vec2 st)\n{\n    // An fbm style amalgamation of various cos functions\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\n    return C((st.y + b - .1) * 100.);\n}\n\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\nfloat stars(vec2 st, vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += .3;\n    uv.y = abs(uv.y);\n    float t = iTime * .1;\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\n    twinkle = twinkle * .5 + .5;\n    return h.x * h.y * twinkle * 1.5;\n}\n\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\nvec3 fireworks(vec2 st)\n{\n\tvec2 fireworkPos, particlePos;\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\n    {\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\n        // This hash changes after each firework cycle (rocket + explosion)\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\n        fireworkCol = fireworkHash * .5 + .5;\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\n        // Random firework x coordinate but confined to a certain column based on j\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\n        \n        // Duration of each firework with a random start time\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\n        if (time > ROCKET_DURATION)\n        {\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\n            {\n                // Unique hash that yeilds a separate spread pattern for each explosion\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \n\t\t\t\t\t* 1619.8196 + 469.7119);\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\n                // Radius expands exponentially over time, i.e. explosion effect\n                radius = radiusScale * time * time;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\n                // Shimmering effect for explosion particles\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\n                shimmerThreshold = FIREWORK_DURATION * .6;\n                // Fade after a certain time threshold\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\n                    * fade * fireworkCol;\n            }\n            \n            // Initial instant flash for the explosion\n            if(time < FLASH_DURATION)\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\n        }\n        else\n        {\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\n            // ease out sine\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\n            fireworkPos = vec2(fireworkHash.x, \n                    rocketPath * fireworkHash.y);\n            // Slight random wiggle for the rocket's path\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\n            \n            // Rockets flying before the explosion\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\n            {\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\n                // rocket trail size\n                float t = time * (2. - time);\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\n\t\t\t\t\t* particleHash.z * .1;\n                // Confine theta to a small value for a vertical thrust effect\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\n            }\n        }\n    }  \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    uv.y += .3; // shift the horizon a bit lower\n    float reflection = 0.;\n    \n    if (uv.y < 0.)\n    {\n        reflection = 1.;\n        // watery distortion in the lake (improved)\n        /**\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\n\t\t*/\n        \n        // slightly better looking water waves\n        uv.x += cos(uv.y * 192. - iTime * .6) * sin(uv.y * 96. + iTime * .75) * .042;\n    }\n\n    // Our special uv coord that gives us reflection effect for pratically free\n    vec2 st = vec2(uv.x, abs(uv.y));\n    vec3 col = vec3(0.);\n    \n    // Background mountain\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\n    mountain = C(S(-.005, .005, mountain));\n    \n    float building = buildings(st);\n    \n    // Finally blend everything together\n    \n    // Sky color\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\n    // Blend the mountain and the sky\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\n    // Occlude the mountain with the building skyline\n    col *= building;\n    \n    // Yellow-ish window color tint\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \n    \n    // Moon white circle\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\n    \n    //Twinkly stars, masked by the buildings, mountain, and the moon\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\n    \n    // Cut the main moon circle with an offset inverted one to make a crescent\n    moon *= smoothstep(.32, .48, length(st-vec2(.92, .88))) * 1.25;\n    \n    // Add the moon to the scene\n    col += moon * vec3(1.2, 1.18, 1.);\n    \n    \n    // Fireworks launch from behind the buildings, but in front of the mountains\n    col += C(fireworks(st)) * (building + moon);\n    \n    // Slightly change of the reflections to watery blueish-green\n    col.r -= reflection * .05;\n    col.gb += reflection * .01;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3GRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1017, 1051, 1073, 1073, 1206], [1208, 1208, 1230, 1230, 1420], [1422, 1422, 1445, 1445, 1589], [1591, 1642, 1700, 1700, 1750], [1752, 1771, 1796, 1796, 1990], [1992, 2004, 2027, 2027, 2092], [2094, 2155, 2194, 2194, 2740], [2742, 2763, 2789, 2847, 3084], [3086, 3161, 3199, 3199, 3615], [3617, 3702, 3727, 3727, 7810], [7812, 7812, 7869, 7869, 10003]]}
{"id": "tt3XzH", "name": "Volumetric Shadows experiment", "author": "peterbraden", "description": "Soft shadows and volumes", "tags": ["raymarch", "shadows"], "likes": 5, "viewed": 107, "published": "Public", "date": "1580405152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INFINITY         999.9e16\n#define STEPS 100\n#define EPSILON         1e-5\n#define MAX_DEPTH       1000.0\n#define LIGHT \t\t\tnormalize(vec3(1.0, 2.0, 0.0))\n\nstruct Ray { vec3 origin; vec3 direction; };\n\nvec3 perspectiveCameraRayDirection(in vec2 pixelCoord) {\n  vec2 pixelPos = (pixelCoord) * 2.0 - 1.0;\n  vec2 aspect = iResolution.xy / iResolution.xx;\n  vec3 camRight   = vec3( 1.0,  0.0,  0.0);\n  vec3 camUp      = vec3( 0.0,  1.0,  0.0);\n  vec3 camForward = vec3(0.0, 0.0, 1.0);\n  return normalize( pixelPos.x * aspect.x * camRight + pixelPos.y * aspect.y * camUp + camForward );\n}\n\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\n                     \nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\n\nfloat sdScene(vec3 p){\n\treturn min(\n        min(\n          sdSphere(p - vec3(0.0, 6.0 + cos(iTime) * 5.0, 0.0), 2.0),\n          sdSphere(p - vec3(5.0, 6.0 + sin(iTime) * 5.0, 0.0), 2.0)\n        ),\n        min(\n          sdSphere(p - vec3(-5.0, 6.0 + sin(iTime-4.0) * 5.0, 0.0), 2.0),\n          sdPlane(p)\n        )\n    );\n}\n\n/*\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)) - sdScene(vec3(p.x - EPSILON, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)) - sdScene(vec3(p.x, p.y - EPSILON, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nfloat intersection(Ray r){\n  float depth = 0.0;\n  for (int i = 0; i < STEPS; i++) {\n    vec3 p = r.origin + depth * r.direction;\n    float dist = sdScene(p);\n    if (dist < EPSILON) {\n        return depth + dist;\n    }\n    depth += dist;\n    if (depth > MAX_DEPTH) {\n        return depth;\n    }\n  }\n  return depth;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow( Ray r, in float mint, in float tmax ){\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++ ) {\n\t\tfloat h = sdScene( r.origin + r.direction*t );\n        float s = clamp(10.0 * h/t, 0.0 ,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += min( res, 10.0*h/t );\n        if( res < 0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 colorPt(vec3 pt){\n\tvec3 normal = estimateNormal(pt);\n    vec3 ambient = vec3(0.1);\n    float diffuse = max(dot(normal, LIGHT), 0.0);\n    float shadow = calcSoftShadow(Ray(pt, LIGHT), EPSILON, INFINITY);\n\treturn ambient + diffuse * shadow;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = 0.05;\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nfloat fogAtPoint(vec3 pt){\n    float shadow = intersection(Ray(pt, LIGHT));\n    if (shadow < MAX_DEPTH) {\n    \treturn 0.99;\n    } else {\n    \treturn 1.005;\n    }\n}\n\nvec4 pixel(in vec2 uv ) {\n  Ray r = Ray( vec3(0.0, 3.0,  -15.0), perspectiveCameraRayDirection(uv));\n  vec3 pixel = vec3(0.0);\n  float depth = intersection(r);\n  vec3 ipt = r.origin + depth * r.direction;\n  if (depth < MAX_DEPTH) {\n    pixel = colorPt(ipt);\n  } else {\n\tpixel = vec3(0.5);\n  }\n    \n  float stepSize = 1.0 / 100.0 * 30.0;\n  pixel = applyFog(pixel, depth, r.direction, LIGHT);\n  for (int i = 0; i < 100; i++){\n    float sd = stepSize * float(i);\n  \tif (sd > depth) break;\n    pixel *= fogAtPoint(r.origin + r.direction * sd);\n  }\n  return vec4(pixel, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aa = 0.25 / iResolution.xy;\n  fragColor = pixel(uv); \n  fragColor += pixel(uv + aa);\n  fragColor *= 0.5;  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 263, 263, 588], [590, 590, 614, 614, 629], [652, 652, 684, 684, 710], [713, 713, 735, 735, 1036], [1038, 1126, 1155, 1155, 1459], [1462, 1462, 1488, 1488, 1778], [1781, 1843, 1903, 1903, 2235], [2237, 2237, 2259, 2259, 2482], [2484, 2484, 2729, 2729, 3064], [3067, 3067, 3093, 3093, 3230], [3232, 3232, 3257, 3257, 3804], [3806, 3806, 3862, 3862, 4021]]}
{"id": "ttcGWs", "name": "Just sum stairs", "author": "Plento", "description": "Wanted to make a stair sdf thing. ", "tags": ["3d", "raymarch", "color", "stars", "stairs"], "likes": 3, "viewed": 250, "published": "Public API", "date": "1577931393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plento\nvec2 R;\nconst float pi = 3.14159;\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n#define s iTime*3.8\n\n// The stairs sdf\nfloat map(vec3 rp){\n    //float k = floor(rp.x*.75)*.25;\n    rp.yz += s;\n    return min(rp.y - floor(rp.z), 1.- (rp.z - floor(rp.y)));\n}\n\n\n\nvec3 normal( in vec3 pos ){ // Can def get rid of this\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 44; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .005 || t > 64.){\n            break;\n        }\n        \n        t += d * .75;\n    }\n    \n    return t;\n}\n\n// Color the stairs and also fake the staircase width\nvec3 render(vec3 ro, vec3 rd, vec3 n, vec2 u, float t){\n    vec3 lp = ro + vec3(0., .016, -.7);\n    vec3 ld = lp-ro;\n   \n    float dif = max(dot(n, ld), .0);\n    vec3 col = vec3(0);\n    \n    \n    ro.yz+=s;\n    ro.x*=.5;\n    \n    float c = smoothstep(0.1, 0.15, sin(ro.x*4.));\n    vec3 cc = .4 + .34*cos(2.*pi*(vec3(0.7, 4.8, 0.5)*floor(ro.z)));\n    \n    col = mix(vec3(.0), cc, c)*dif;\n    col = mix(vec3(0), col,  smoothstep(9.9, 10.1, 30./abs(ro.x-4.33)));\n    \n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.5,6.6 , -6.);\n    \n    rd.yz*=rot(.4);\n    rd.xz*=rot(-.75);\n    \n    float t = march(rd, ro);\n    \n    ro += rd*t;\n    \n    vec3 n = normal(ro);\n    vec3 col = render(ro, rd, n, u, t);\n    \n    col*=smoothstep(.52, .2, uv.y);\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 64, 64, 116], [139, 157, 176, 213, 293], [297, 297, 324, 351, 552], [554, 554, 584, 584, 813], [815, 869, 924, 924, 1350], [1354, 1354, 1394, 1394, 1803]]}
{"id": "ttcSRr", "name": "Unko", "author": "ChoiChoi", "description": "Unko", "tags": ["unko"], "likes": 1, "viewed": 190, "published": "Public API", "date": "1580272391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    r/=5.0;\n  float q1 = length(vec2(length(p.xz)-r,p.y+0.2)) - r;\n  float q2 = length(vec2(length(p.xz)-r,p.y+0.5)) - r-0.1;\n  float q3 = length(vec2(length(p.xz)-r,p.y+0.8)) - r-0.2;\n  \n\n  float q = length(vec2(p.x,p.z));\n // float q4 = p.y>2 ? dot(2,float2(q,p.y-1.2))<0.1 :100000000;\n\n  float q4 =0.0;\n    if(p.y>-0.1){\n        q4=dot(vec2(2.0,2.0),vec2(q,p.y))-0.1;\n    } else {\n        q4=10000000.0;\n    }\n\n  //return length(q1)<_Threshold || length(q2)<_Threshold-0.1|| length(q3)<_Threshold-0.2 || (dot(2,float2(q,p.y-1.2))<0.1 && p.y>0.8);\n\n  return min(q1, min(q2,min(q3,q4)));\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"うんこ\",\n\t\"description\": \"きれいなうんこです\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 189, 189, 780], [783, 783, 802, 802, 1138], [1140, 1140, 1170, 1170, 1452], [1454, 1454, 1511, 1511, 2229]]}
{"id": "ttG3DV", "name": "hyperbola debug", "author": "nabr", "description": "mouse =  look around\nkeyboard: \nspacebar = toggle plane\npause shadertoy + all keys= frame by frame\nlooking into: [url=https://en.wikipedia.org/wiki/Jacobi_elliptic_functions]jacobi[/url] | [url=https://en.wikipedia.org/wiki/Elliptic_filter]filter[/url]", "tags": ["debug", "hyperbola", "sperical"], "likes": 5, "viewed": 99, "published": "Public", "date": "1579890276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// basically i just playing around ... (it looks interessting)\n// best thing if you pause the shadertoy and look around\n// hide plane = space\n\n#define initialZOOM 8.\n\n// copy+paste from iq! thx\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return -1.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t1 < .001 && t2 < .001)\n        return -1.0;\n    if (t1 < .001)\n        return t2;\n    return t1;\n}\nconst float hpi = 3.1415926 / 2.;\n\n// https://www.shadertoy.com/view/llySRh\n#define keyDown(ascii)(texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n\nfloat tex(in vec3 U)\n{\n    vec2 p = U.xy;\n    float f = 0.0;\n    float t = 0.;\n   \n    // anim loop\n    int sec = 5; float speed = 240.;\n    int frm = 1; \n    \n    if(!keyDown(39))\n        frm++;\n    \n    \n    t = float(frm+iFrame%(60*sec)) / speed;\n    \n    \n    for(float i = 0.0; i < 4.; ++i)\n    {\n        float s = sin(t + i * hpi) * p.y * 5.;\n        float c = cos(t + i * hpi) * p.x * 2.;\n        f += .0175 / abs(length(p - vec2(0, 2)) + clamp(c + s, -6., 1.));\n    }\n    \n    // return  .01/length(U.xy); \n    \n    return f;\n}\n\n#define R(_p,_a)_p=(cos(_a)*_p+sin(_a)*vec2(_p.y,-_p.x));\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec3 col = vec3(.501);\n    vec2 R = iResolution.xy;\n    \n    vec3 o = vec3(0, 0,initialZOOM);\n    vec3 d = normalize(vec3((U - .5 * R) / min(R.x, R.y), -.5));\n    vec2 m = (3. * atan(hpi-3. * vec2(iMouse.x, iMouse.y) / R));\n    if (iMouse.z > .0001)\n    {\n        o.z = 10.; //\"zoom\"\n        R(o.yz, m.y) R(d.yz, m.y)R(o.xz, m.x) R(d.xz, m.x)\n    }\n\tvec3 dn = vec3(0, 1, 0), dc = vec3(0, -2, 0.5);//plane\n    vec3 dk = dot(dn, o - dc) / dot(dn, d) * d \n        \t\t\t\t\t\t\t\t\t\t+ dc;//flip texture\n    float pt = dot(dn, dc) / dot(dn, d);\n\n    \n    vec4 sc0 = vec4(0, 0, 6, 200.);//big one\n    vec4 sc1 = vec4(0, 0, 0.5, 2.);//green\n    float t0 = iSphere(o, d, sc0);\n    float t1 = iSphere(o, d, sc1);\n\n    float tmin = 1e10;\n\tif(!(texelFetch(iChannel3,ivec2(32,2),0).x > 0.) ) // spacebar\n    if (pt > 0. && pt < tmin)//plane\n    {\n        tmin = pt;\n        vec3 hit = o + pt * d;\n        vec3 n = normalize(hit - dk);\n        float ntex = tex(n.xyz) + tex(n.yzx) + tex(n.zxy);\n        col = ntex + vec3(0, 0, .5);\n    }\n    if (t0 > 0.0 && t0 < tmin)//big one\n    {\n        tmin = t0;\n        vec3 hit = o + t0 * d;\n        vec3 n = normalize(hit - sc0.xyz);\n        float ntex = tex(n.xyz) + tex(n.yzx) + tex(n.zxy);\n        col = ntex + vec3(.5, 0, 0);\n    }\n    if(t1 > 0.0 && t1 < tmin) //green sph\n    {\n        tmin = t1;\n        vec3 hit = o + t1 * d;\n        vec3 n = normalize(hit - sc1.xyz);\n         n=n-n-n; //rotation\n        //R(n.xy,radians(90.))\n       // R(n.yz,radians(90.))    \n        float ntex = tex(n.xyz) + tex(n.yzx) + tex(n.zxy);\n        // if(mod(iTime, 2.)>1.) ntex = tex(6.*-n.xyz);\n        col = mix(col, (12. * ntex) * vec3(0, .5, 0), .2);\n    }\n    O.xyz = col;\n    O.a = 1.;\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 195, 247, 247, 579], [615, 727, 749, 749, 1262], [1322, 1322, 1361, 1361, 3072]]}
{"id": "ttG3Wc", "name": "ovni-N2-Test", "author": "jorge2017a1", "description": "ovni-N2-Test", "tags": ["ovnin2test"], "likes": 1, "viewed": 54, "published": "Public", "date": "1580051320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +sa, +1.0);\n}\n\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n\n//-*-------------------------------------------------------\n// Smooth combine functions from IQ\nfloat smin(float a, float b, float k)\n{\n\tfloat h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\treturn mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n\treturn -smin(-a,-b,k);\n}\n\nfloat smin( float a, float b)\n{\n\treturn smin(a,b,0.1);\n}\n\nfloat smax( float a, float b)\n{\n\treturn smax(a,b,0.1);\n}\n\nfloat sq(float x){return x*x;}\n\nfloat Torus(float x, float y, float z, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(x)+sq(z))-R)+sq(y))-r;\n}\n\nfloat Torus(vec3 p, float R, float r)\n{\n\treturn sqrt(sq(sqrt(sq(p.x)+sq(p.z))-R)+sq(p.y))-r;\n}\n//---------------------------------------------------------\nfloat plate0(vec3 p)\n{\n\tfloat v=(length(p.xz)*.8-p.y)/sqrt(1.64);\n\tv=smin(v,(length(p.xz)*.3-p.y+.7)/sqrt(1.09));\n\tv=smax(v,-p.y+.8,.1);\n\treturn v;\n}\n\nfloat Plate(vec3 p)\n{\n\tfloat v;\n\tfloat vi=plate0(p);\n\tfloat vo=plate0(p+vec3(0,-.1,0));\n\tv=smax(vi,-vo);\n\tv=smax(v,(length(p.xz)*2.+p.y)/sqrt(3.)-3.);\n\tv=smin(v,Torus(p.x,p.y-.7,p.z,0.8,.025),0.2);\n\treturn v;\n}\n\n//-----------------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 9);\n             \n         } \n     }\n\t\n   \n    \n    \n    p.y=p.y-5.0;  //subir mas alto\n    p.xy= p.xy+cos(iTime);   //rotar ovni\n    p.xz= p.xz+cos(iTime*2.0);  //rotar ovni\n    p.zy= p.zy+cos(iTime*4.0);  //rotar ovni\n    \n    //pp.y=p.y-3.0;\n    pp=p;\n    pp.y=p.y-3.0;   //subir plato opuesto\n    \n    float sdc1= sdCylinder( p-vec3(0.,1.5,0.), vec2(2.0,0.15) );\n    \n    \n    float v1=Plate(p);  //dibujar plato n1\n    \n    pp=rotate_z(pp,180.0*3.141516/180.0);  //rotar plato 2\n    float v2=Plate(pp);    //dibujar plato n2\n    \n    res=opU(res, vec2(v1,8));\n    res=opU(res, vec2(v2,7));\n    res=opU(res, vec2(sdc1,12));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,6.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1281, 1339, 1339, 1603], [1607, 1607, 1689, 1689, 1920], [1923, 1923, 1954, 1954, 2142], [2145, 2199, 2221, 2221, 3481], [3484, 3548, 3584, 3584, 3857], [3859, 3909, 3955, 3955, 3987], [3989, 3989, 4032, 4032, 4064], [4066, 4066, 4114, 4114, 4147], [4150, 4150, 4179, 4179, 4305], [4307, 4307, 4343, 4343, 4460], [4462, 4462, 4498, 4498, 4616], [4618, 4618, 4654, 4654, 4777], [4779, 4779, 4805, 4805, 4899], [4950, 4962, 4984, 4984, 5292], [5293, 5319, 5344, 5344, 5534], [5535, 5580, 5597, 5597, 5670], [5673, 5706, 5732, 5732, 5929], [5930, 5976, 6028, 6028, 6183], [6248, 6357, 6394, 6394, 6429], [6431, 6431, 6450, 6450, 6525], [6528, 6624, 6663, 6663, 6742], [6744, 6744, 6784, 6784, 6810], [6812, 6812, 6843, 6843, 6868], [6870, 6870, 6901, 6901, 6926], [6928, 6928, 6946, 6946, 6958], [6960, 6960, 7018, 7018, 7067], [7069, 7069, 7108, 7108, 7163], [7164, 7224, 7246, 7246, 7373], [7375, 7375, 7396, 7396, 7585], [7587, 7651, 7676, 7676, 8861], [8864, 8864, 8898, 8898, 9287], [9292, 9292, 9316, 9316, 9548], [9552, 9552, 9576, 9576, 9961], [9964, 9964, 9990, 9990, 10354], [10357, 10357, 10382, 10382, 10410], [10412, 10412, 10464, 10464, 10860], [10963, 11007, 11024, 11024, 11095], [11120, 11212, 11237, 11237, 11500], [11502, 11561, 11589, 11589, 13472], [13476, 13476, 13533, 13533, 14943]]}
{"id": "ttG3zc", "name": "The Fractal Void", "author": "acandy", "description": "Trippy moving fractal using code altered from a tutorial made by the youtube channel, \"The Art Of Code\"", "tags": ["fractal"], "likes": 10, "viewed": 141, "published": "Public", "date": "1579482369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Xor(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    float t = iTime*.02+iDate[2];\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float centDist = length(uv)*(8.*pow(0.5*sin(t*2.43)+1., 2.+sin(t*1.06)));\n    \n    \n    float a = 0.786;\n    float totalSpinTime = 2.;\n    float spinOccurance = 20.;\n    //Get it to spin every so often\n    if (mod(t, spinOccurance) <= totalSpinTime) {\n        a += (3.1416*2.)*smoothstep(0., 1., mod(t, spinOccurance)/totalSpinTime);\n    } \n    float s = sin(a);\n    float c = cos(a);   \n    uv *= mat2(c, -s, s, c);\n    \n    float uvZoom = (4.+8.*pow(sin(t*0.187+length(uv))*0.5+0.5, 2.+sin(0.278*t))+4.*sin(t*2.5)) * (0.5*sin(t*5.7)+1.);\n    uv *= uvZoom;\n    \n    float blur = uvZoom*0.003;\n    \n    float lineWidth = uvZoom*0.005 + sin(2.7*t)*0.003;\n    float lineBlur = uvZoom*0.002;\n    vec3 lineCol = vec3(0.);\n    \n    float extraLineWidth = uvZoom*0.01 + sin(2.7*t)*0.003;\n    float extraLineBlur = extraLineWidth/3.;\n    vec3 extraLineCol = vec3(0.);\n    float extraLineCutoff = 11.;\n    float extraLineCutoff2 = 6.;\n    \n    \n    vec2 gv = fract(uv+0.5)-0.5;\n    vec2 id = floor(uv+0.5);\n    \n    float m = 0.;\n    \n    for(float y=-2.; y<=2.; y++) {\n        for(float x=-2.; x<=2.; x++) {\n            vec2 offs = vec2(x, y);\n            \n            float dCir = length(gv-offs);\n            float dSqu = abs(abs((gv-offs)[0])-abs((gv-offs)[1]));\n            float d = mix(dCir, dSqu, 1.*(0.5*sin(t*.63) +0.5));\n            \n   \t\t\tfloat dist = length(id+offs)*.3*(0.5*sin(0.93*t)+0.5);\n            \n            \n            float rMix = 0.6*pow(sin(-t+dist*0.6)*.5 +.5, 4.) + 0.4*(sin(3.*t+dist*0.6)*.5 +.5);\n            float r = mix(1.1, 2.5, rMix);\n            \n            if (d>r-lineWidth/2. && d<r) {\n                float blurRat = (d-(r-lineWidth/2.)) / ((r-lineWidth/2.+lineBlur)-(r-lineWidth/2.));\n                lineCol+=mix(0., 1., smoothstep(0., 1., blurRat));  \n                //lineCol+=1.;\n            }\n            else if((d<r+lineWidth/2. && d>r)) {\n                float blurRat = (d-(r+lineWidth/2.)) / ((r+lineWidth/2.-lineBlur)-(r+lineWidth/2.));\n                lineCol+=mix(0., 1., smoothstep(0., 1., blurRat));\n                //lineCol+=1.;\n            }\n            \n            \n            if (uvZoom < extraLineCutoff) {\n                float extraLineFade = (uvZoom-extraLineCutoff)/(0.-extraLineCutoff);\n                float r2 = r/2.;\n            \tif (d>r2-extraLineWidth/2. && d<r2) {\n                    float blurRat = (d-(r2-extraLineWidth/2.)) / ((r2-extraLineWidth/2.+extraLineBlur)-(r2-extraLineWidth/2.));\n                    extraLineCol+=mix(0., 1., smoothstep(0., 1., blurRat*extraLineFade));  \n            \t}\n            \telse if((d<r2+extraLineWidth/2. && d>r2)) {\n                    float blurRat = (d-(r2+extraLineWidth/2.)) / ((r2+extraLineWidth/2.-extraLineBlur)-(r2+extraLineWidth/2.));\n                    extraLineCol+=mix(0., 1., smoothstep(0., 1., blurRat*extraLineFade));\n            \t}\n            }\n            \n            if (uvZoom < extraLineCutoff2) {\n                float extraLineFade = (uvZoom-extraLineCutoff2)/(0.-extraLineCutoff2);\n                float r3 = r*(0.5*sin(t*5.)+0.5);\n            \tif (d>r3-extraLineWidth/2. && d<r3) {\n                    float blurRat = (d-(r3-extraLineWidth/2.)) / ((r3-extraLineWidth/2.+extraLineBlur)-(r3-extraLineWidth/2.));\n                    extraLineCol+=mix(0., 1., smoothstep(0., 1., blurRat*extraLineFade));  \n            \t}\n            \telse if((d<r3+extraLineWidth/2. && d>r3)) {\n                    float blurRat = (d-(r3+extraLineWidth/2.)) / ((r3+extraLineWidth/2.-extraLineBlur)-(r3+extraLineWidth/2.));\n                    extraLineCol+=mix(0., 1., smoothstep(0., 1., blurRat*extraLineFade));\n            \t}\n            }\n            \n            m = Xor(m, smoothstep(r, r-blur, d));\n        }\n    }\n    \n    //col.rg = gv;\n    vec3 col = vec3(0);\n    col+=vec3(m*(0.5*sin(t*0.2)+0.5), m*(0.5*sin(t*0.25)+0.5), m*(0.5*sin(t*0.15)+0.5));\n    vec3 colMult = vec3(0.5*sin(6.1*t + centDist)+0.7, 0.5*sin(7.2*t+centDist)+0.7, 0.5*sin(8.3*t+centDist)+0.7);\n    lineCol *= colMult;\n    extraLineCol *= col*0.7;\n    \n    col*= colMult;\n    col+=lineCol;\n    col+=extraLineCol;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 63], [65, 65, 122, 122, 4371]]}
{"id": "ttGGD3", "name": "KIFS experiments 5", "author": "rodgzilla", "description": "Smooth extrusion using KIFS.", "tags": ["raymarching", "kifs"], "likes": 3, "viewed": 100, "published": "Public", "date": "1580037431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define SPEED 20.\n\nfloat PI = acos(-1.);\n\nvec3 palette(float x) {\n  vec3 p = vec3(1, .5, 1);\n  vec3 q = vec3(.7, .6, 1);\n  vec3 r = vec3(.3, .6, .3);\n  vec3 s = vec3(.9, .5, .3);\n\n  return p + q * sin(2. * PI * (x * r + s));\n}\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n\n  return mat2(c, s, -s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opSmoothUnion( vec3 d1, vec3 d2, float k ) {\n  vec3 h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 kifs(vec3 p, float d, float s, float tf) {\n  float t = tf * time;\n\n  for (float i = 0.; i < d; i += 1.) {\n    p.xy *= rot2d(t + i);\n    p.xz *= rot2d(t * 0.6 - i);\n \tp = opSmoothUnion(p, -p, -1.);\n    p -= s;\n    s *= 0.7;\n  }\n\n  return p;\n}\n\nfloat map(vec3 p) {\n  float wave = .5 * sin(time) + .5;\n  float d = 100.;\n  vec3 psph = kifs(p, 3., 1., .5);\n  vec3 pextr = kifs(p, 3., 1. + .1 * wave, .6);\n    \n  float dsph = length(psph) - 1.;\n  float dextr = length(pextr + sin(time) * vec3(.5, 0., 0.)) - .9;\n  float dobj = opSmoothUnion(dsph, -dextr, -.1);\n  \n  d = min(d, dobj);\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0, 0, -20.);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  float d = 0.;\n  int i;\n  for (i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n\n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n\n    d += ds * .5;\n  }\n  vec3 p = ro + d * rd;\n  vec2 e = vec2(0.01, 0);\n  vec3 n = normalize(map(p) - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx)));\n  vec3 l = vec3(20., 20., -5.);\n//  l.xz *= rot2d(time / .1);\n  float dif = dot(n, normalize(l - p));\n\n  p.z = clamp(p.z, 0., 50.);\n  vec3 col = vec3(dif * palette(p.z / 1.));\n\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 84, 84, 245], [247, 247, 268, 268, 331], [333, 333, 385, 385, 481], [483, 483, 532, 532, 627], [629, 629, 676, 676, 875], [877, 877, 896, 896, 1226], [1228, 1228, 1285, 1285, 2014]]}
{"id": "ttGGWz", "name": "Polar Patterns in RGB", "author": "tombla", "description": "Two types of patterns (angle- and radius-based) mixed together.", "tags": ["procedural", "radial", "polar", "tuner"], "likes": 2, "viewed": 244, "published": "Public API", "date": "1578651609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define ARMS 6.\n#define ANGLE_SPEED 3.\n#define DENSITY 3.\n#define SPEED 8.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv);\n\n    // Patterns based on the angle.\n    float ap1 = sin(a * ARMS + T * ANGLE_SPEED);\n    // Patterns based on radius.\n    float rp1 = sin(1. / r * PI2 * DENSITY + T * SPEED);\n    // Expose interference-like patters in the middle.\n    float rp2 = smoothstep(9., 1., 1. / r);\n\n    vec3 color = vec3(ap1 * rp2, rp1, rp2);\n    fragColor = vec4(color * 1.2, 1.);\n    //gamma22(fragColor, color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 184, 184, 837]]}
{"id": "ttGGzt", "name": "Perlin Terraformer", "author": "42yeah", "description": "Fake lands generated using Perlin Noise from here: https://thebookofshaders.com/11/", "tags": ["perlinnoise"], "likes": 1, "viewed": 80, "published": "Public", "date": "1579600829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand2d(vec2 uv) {\n    return fract(sin(dot(uv, vec2(13.23, 78.1231))) * 1000000.0);\n}\n\nvec2 ddrand2d(vec2 uv) {\n    vec2 w = fract(sin(vec2(\n        dot(uv, vec2(13.23, 78.1231)),\n        dot(uv, vec2(799.134, 42.52))\n        )) * 1000000.0);\n    return (w - 0.5) * 2.0;\n}\n\nfloat perlin(vec2 uv) {\n    vec2 u = floor(uv);\n    vec2 f = fract(uv);\n    vec2 s = smoothstep(0.0, 1.0, f);\n    \n    vec2 a = ddrand2d(u);\n    vec2 b = ddrand2d(vec2(u.x + 1.0, u.y));\n    vec2 c = ddrand2d(vec2(u.x, u.y + 1.0));\n    vec2 d = ddrand2d(vec2(u.x + 1.0, u.y + 1.0));\n    return mix(mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n               mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x), s.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 off = vec2(iTime / 100.0, 1.0);\n    uv += off;\n    float r = perlin(vec2(uv.x * aspect, uv.y) * 2.0) * 0.5 + 0.5;\n    r *= sin(iTime / 2.5) * 0.25 + 0.75;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (r < 0.4) {\n        // Water\n        col = mix(r * vec3(0.2, 0.8, 0.78), vec3(0.1, 0.7, 0.8), 1.0 - pow(r / 0.4, 5.0));\n    } else if (r > 0.65) {\n        // Snow\n        col = r * vec3(1.0, 1.0, 1.0);\n    } else if (r > 0.5) {\n        // Grass\n        col = r * vec3(0.3, 0.87, 0.4);\n    } else {\n        // Land\n        col = r * vec3(0.989, 0.52, 0.22);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 91], [93, 93, 117, 117, 278], [280, 280, 303, 303, 714], [716, 716, 773, 773, 1467]]}
{"id": "ttK3Dh", "name": "Joseph Albers 3", "author": "danamuise", "description": "Original static code by Patricio Gonzalez Vivo.\nInspired by Joseph Albers' Book \"The interaction of Color:  color intervals and transformation interaction of color\"\nThe three rectangles never change, just the background\n", "tags": ["colortheory", "josephalbers"], "likes": 1, "viewed": 1248, "published": "Public API", "date": "1578869469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nuniform float u_time;\n\nfloat rect(in vec2 st, in vec2 size){\n\tsize = 0.25-size*0.25;\n    vec2 uv = step(size,st*(1.0-st));\n\treturn uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\n    vec2 st = fragCoord/iResolution.xy;\n    \n    vec3 influenced_color = vec3(0.563,0.580, 0.556);\n    vec3 influencing_color_A = vec3(0.040,0.040,0.040);\n    vec3 influencing_color_B = vec3(0.937,0.981,1.000);\n    \n    vec3 color = vec3(0.);\n    \n    // Background Gradient\n    color = mix( influencing_color_A,\n                 influencing_color_B,\n                 st.y*abs(sin(iTime)));\n    \n    // Foreground rectangle\n    vec2 size = vec2(0.020,0.460);\n    vec2 offset = vec2(.3,0.);\n    color = mix(color,\n               influenced_color,\n               rect(st,size));\n    \n    color = mix(color,\n               influenced_color,\n               rect(st+offset,size));\n    \n    color = mix(color,\n               influenced_color,\n               rect(st-offset,size));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Dh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 61, 61, 144], [146, 146, 203, 203, 1016]]}
{"id": "ttK3DK", "name": "Trignac", "author": "mouseshadow", "description": "Gerard Trignac style environment.", "tags": ["raymarch"], "likes": 12, "viewed": 170, "published": "Public", "date": "1580034937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  // This shader is purely a learning exercise for me, so I threw too much into it and got a horrible framerate as a result.\n  // Several resources were used/studied/shamelessly pinched, including:\n  // Inigo Quillez youtube page: https://www.youtube.com/channel/UCdmAhiG8HQDlz8uyekw4ENw\n  // The Art of Code https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n  //\n  // nb. I'm not a coder and this is my first attempt. Don't expect to learn anything from this mess.\n  //\n  // Originally written in HLSL/CG in Unity and converted to Shadertoy.\n  //\n  // I made a version with AA, it was painfully slow on my PC.\n    \n    #define MAX_STEPS 100.0\n    #define MAX_DIST 40.0\n    #define SURF_DIST .01\n    #define lightDir normalize(vec3(-.5, 2, -1))\n\nfloat mmod(float x, float y) {\n\treturn (fract(x/y-.5)-.5)*y;\n}\n\n//White noise.\nfloat whiteNoise(vec3 p) {\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0 +  p.z * 3142.0) * 5647.0); //https://www.shadertoy.com/view/4ddBzl      \n    //Original noise wasn't working on 2060 at work, so trying this new one.\n}\n\n// Perlin Noise Octave\nfloat perlinNoiseOctave3D(vec3 p, float o, float s) { //Position p,Number of octave o, Octave scale s\n\tvec3 lv = smoothstep(0.0,1.0,fract(p*o*s));\n\tvec3 id = floor(p*o*s);\n\tfloat bl = whiteNoise(id);\n\tfloat br = whiteNoise(id+vec3(1,0,0));\n\tfloat b = mix(bl, br, lv.x);\n\tfloat tl = whiteNoise(id+vec3(0,1,0));\n\tfloat tr = whiteNoise(id+vec3(1,1,0));\n\tfloat t = mix(tl, tr, lv.x);\n\tfloat f1 = mix(b, t, lv.y);\n\tfloat bl2 = whiteNoise(id+vec3(0,0,1));\n\tfloat br2 = whiteNoise(id+vec3(1,0,1));\n\tfloat b2 = mix(bl2, br2, lv.x);\n\tfloat tl2 = whiteNoise(id+vec3(0,1,1));\n\tfloat tr2 = whiteNoise(id+vec3(1,1,1));\n\tfloat t2 = mix(tl2, tr2, lv.x);\n\tfloat f2 = mix(b2, t2, lv.y);\n    return mix(f1, f2, lv.z);  \n}\n\n// Perlin Noise 3D\nfloat perlinNoise3D(vec3 p) {\n\tp.z=mmod(p.z,8.0);\n\tp.y+=1.0; // hide 0 values beneath the water\n\tfloat c=0.0;\n\t    for (float i=1.0; i<5.0; i+=2.0) {\n\t\tc+= perlinNoiseOctave3D( p, pow( 2.0 , i-1.0 ), 40.0/i)/i;\n\t\t};\n    return c;\n}\n\n//Brick\nfloat TextureBrick( vec3 p, float s ) { //Position, scale.\n   p *=12.0;\n   p.z = mmod(p.z,64.0);\n   p.x+=(p.y+p.z)*.03*(sin(p.x*.1)+1.1); // Randomize bricks\n   p.z+=(p.y+p.x)*.05*(cos(p.x*.1)+1.1);\n   float v = smoothstep(sin (s*2.0*p.y)-.98,0.1,0.0); //Vertical cement\n   float o = ceil(sin(s*p.y+2.2))*3.141; //Brick Offset\n   float h = smoothstep(sin (s*p.x+o)-0.99,0.1,0.0);\n   float d = smoothstep(sin (s*p.z+o+2.2)-0.99,0.1,0.0);\n   return 1.0-(min(min(v,h),d)*clamp(p.y*-.1+1.0,0.0,1.0));\n}\n\n// 2D (infinite length) Cylinder in y plane\nfloat fCylinder(vec3 p, float r) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y));\n\treturn d;\n}\n\n//Archway\nfloat sdArchway( vec2 rep, vec3 p, vec3 b, float r, float t, vec2 f, vec2 m, vec2 apos, float aradius, float aheight ) {\n    b-=r; //prevent scaling due to erosion.\n    p.x = mmod(p.x,rep.x);\n    p.z = mmod(p.z,rep.y);\n\tb.z +=clamp((-p.y+t),0.0,m.y)*f.y; //flare\n\tb.x +=clamp((-p.y+t),0.0,m.x)*f.x;\n  vec3 q = abs(p) -b;\n  float structure = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  vec2 dc = abs(p.xy-apos+vec2(0,aradius*aheight)) -vec2(aradius,aradius*aheight);   // arch  \n  float darch = length(max(dc,0.0)) + min(max(dc.x,dc.y),0.0) ;\n  darch = min(darch,length(p.xy-apos) - aradius); \n  return max(structure,-darch);\n}\n\n\n//A box with a taper.\nfloat sdCubeTaper( vec2 rep, vec3 p, vec3 b, float r, float t, vec2 f, vec2 m ) { // Position, Size, Roundness, max tapering height, tapering factor, max tapering size\n    b-=r; //prevent scaling due to erosion.\n    p.x = mmod(p.x,rep.x);\n    p.z = mmod(p.z,rep.y);\n\tb.z +=clamp((-p.y+t),0.0,m.y)*f.y;\n\tb.x +=clamp((-p.y+t),0.0,m.x)*f.x;\n  vec3 q = abs(p) -b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r ;\n}\n\n// 3D Cylinder in z plane with details. Position, radius, roundness (bevel), height (z height)\nfloat sdCylinderz(vec3 p, float pivot, float rad, float r, float h) {\n\trad-=r; //prevent scaling due to erosion.\n    p.y+=pivot;\n\tfloat d = length(p.xy) - rad;\n\td = max(d, abs(p.z+clamp(sin(d*100.0)*.01,-1.0,0.0))- h);\n\treturn d;\n}\n\n// 3D Cylinder in y plane. Position, pivot, radius, roundness (bevel), height (z height)\nfloat sdCylindery(vec3 p, float pivot, float rad, float r, float h) {\n\trad-=r; //prevent scaling due to erosion.\n    p.y+=pivot;\n\tfloat d = length(p.xz) - rad;\n\td = max(d, abs(p.y)- h);\n\treturn d;\n}\n\n//  Rotation matrix, Z axis\nmat4 ZRot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n        vec4(c, -s, 0.0, 0.0),\n        vec4(s, c, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n// Animated pendulum\nfloat Pendulum(vec3 p) {\n    vec3 pos = (ZRot(cos(-iTime))*vec4((p-vec3(4.0,1.19,-3.25)),1.0)).xyz;\n\tfloat d = sdCylinderz(pos, 0.60, 0.12, .02, 0.05);\n    float d1 = sdCylindery(pos, 0.35, 0.02, .02, 0.4);\n\td = min(d1, d);\n\treturn d;\n}\n\n\nfloat WaterDist(vec3 p) {\n    p*=vec3(12,1,12);\n    float w1 = iTime*1.2+p.x+cos(p.z);\n\tfloat w2 = (iTime*1.2+p.z-p.x)*0.365;\n\tfloat l = sin(iTime*3.0+p.x)*0.5+0.5;\n\treturn p.y+(.024*mix(abs(sin(w1)),abs(cos(w1)),l)+mix(abs(sin(w2)),abs(cos(w2)),l)*0.01)*.6;\n}\n\n//....Map...............................................................................................................//\nvec3 Map(vec3 p,bool detail, bool geodetail) { // distance, displacement detail, geometry detail\n    vec4 s = vec4 (cos(iTime)*2., 2.2, sin(iTime)*2.+0.0, 1.0);\n    vec4 s2 = vec4 (2.0, 20.0, 10.0, 3.0);\n\tfloat perlinNoiseSample=0.0;\n\tif (detail) { perlinNoiseSample = perlinNoise3D(p);}\n\tfloat d = MAX_DIST;\n\tfloat br = perlinNoiseSample*0.02; //erosion\n\tfloat col = 10.0; //Colour mask\n\tfloat notwaterdist = 0.0; // Distance from water surface to the nearest not-water object.\n\t\n\tvec2 rep1 = vec2(8.0,16.0); //Object Repetition mod Values\n\tvec2 rep2 = vec2(8.0,32.0);\n\tvec2 rep3 = vec2(0.5,32.0);\n\tvec2 rep4 = vec2(0.25,32.0);\n\tvec2 rep5 = vec2(20.0,8.0);\n\t\n\tfloat d1 = sdCubeTaper(rep1, p-vec3(1.0,0.5,1.5) , vec3(0.375,1.3,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.46,0.46));\n    d = d1; //Building 1, Main\n    d1 = sdCubeTaper(rep1, p-vec3(.68,0.5,1.8) , vec3(0.1,1.6,0.10) , br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n    d = min(d1, d); \t//Tall back tower\n\n\n\td1 = sdCubeTaper(rep1, p-vec3(3.45,0.5,1.5) , vec3(0.18,2.0,0.30) , br, 0.5 ,vec2(0.08,0.4), vec2(1.0,1.1));\n    d = min(d1, d); //Building 2\n\td1 = sdCubeTaper(rep1, p-vec3(4.15,0.5,1.5) , vec3(0.18,2.0,0.30) , br, 0.5 ,vec2(0.08,0.4), vec2(1.0,1.1));\n    d = min(d1, d); //Sides\n\td1 = sdCubeTaper(rep1, p-vec3(3.8,0.4,1.5) , vec3(0.3,2.0,0.14) , br, 0.0 ,vec2(0.02,0.2), vec2(0.2,1.1));\n    d = min(d1, d); //Back\n\n\td1 = sdArchway(rep1, p-vec3(1.5,0.3,11.5) , vec3(0.475,0.5,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(2.0,0.0), vec2(0.0,-0.1), 0.17, 2.0);\n    d = min(d1, d); //Building 3\n\td1 = sdCubeTaper(rep1, p-vec3(1.16,1.2,11.5) , vec3(0.14,0.7,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n    d = min(d1, d);\t\n\t\n\td1 = sdArchway(rep2, p-vec3(2.3,0.0,+1.5) , vec3(0.3,1.0,0.20) , br, 1.0 ,vec2(8,0.2), vec2(0.1,0.0), vec2(0.0,0.0), 0.8, 1.5);\n\td = min(d1, d); //Bridge\n\t\n    d1 = sdCubeTaper(rep2, p-vec3(1.5,-.1,9.6) , vec3(0.3,0.12,2.45) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n    d = min(d1, d); //Pier\n\n\td1 = sdCubeTaper(rep2, p-vec3(1.1,0.3,6.5) , vec3(0.15,0.7,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.0,4.0));\n    d = min(d1, d); //Pier end Building\n\td1 = sdCubeTaper(rep2, p-vec3(1.9,0.3,6.5) , vec3(0.15,0.7,0.20) , br, 0.2 ,vec2(0.1,0.2), vec2(0.0,4.0));\n    d = min(d1, d);\n\td1 = sdArchway(rep2, p-vec3(1.5,0.3,6.5) , vec3(0.3,0.5,0.16) , br, 0.0 ,vec2(0.1,0.2), vec2(0.0,4.0), vec2(0.0,0.2), 0.15, 1.0);\n    d = min(d1, d);\n\n\td1 = sdArchway(rep3, p-vec3(-9.4,0.0,22.4) , vec3(0.16,0.4,0.20) , br, 0.5 ,vec2(1.0,0.0), vec2(2.0,0.0), vec2(0.0,0.1), 0.2, 2.0);\n    d = min(d1, d); //Bridge\n\t\n\td1 = sdArchway(rep5, p-vec3(4.0,0.6,-3.5) , vec3(0.300,0.7,0.07) , br, 0.6 ,vec2(0.1,0.2), vec2(0.0,0.0), vec2(0.0,0.45), 0.17, 1.8);\n    d = min(d1, d); //Pendulum building\n\td1 = sdArchway(rep5, p-vec3(4.0,0.6,-3.0) , vec3(0.300,0.7,0.07) , br, 0.6 ,vec2(0.1,0.2), vec2(0.0,0.0), vec2(0.0,0.45), 0.17, 1.8);\n    d = min(d1, d);\n\td1 = sdCubeTaper(rep5, p-vec3(4.0,0.0,-3.25) , vec3(0.3,0.3,0.3) , br, 0.2 ,vec2(0.2,0.2), vec2(0.46,0.46));\n    d = min(d1, d);\n\n\tif (geodetail) {           //Building Small Geometry\n    \td1 = sdCubeTaper(rep1, p-vec3(1.02,1.82,1.46) , vec3(0.34,0.025,0.18), br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n        d = min(d1, d);\n\t    d1 = sdCubeTaper(rep1, p-vec3(.70,2.12,1.85) , vec3(0.04,0.025,0.1), br, 0.7 ,vec2(0.5,0.5), vec2(0.2,0.2));\n        d = min(d1, d); \t\t//Big Roof\n    \td1 = sdCubeTaper(rep2, p-vec3(1.5,-.1,6.5) , vec3(0.5,0.12,0.5) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t//Pier Top\n    \td1 = sdArchway(rep1, p-vec3(0.98,1.1,1.30) , vec3(0.190,0.7,0.05) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0), vec2(0.0,-0.3), 0.13, 2.0);\n        d = min(d1, d);\n    \td1 = sdCubeTaper(rep1, p-vec3(0.98,0.95,1.28) , vec3(0.26,0.04,0.05) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t//Lower Struts, building 1\n        d1 = sdCubeTaper(rep1, p-vec3(1.28,0.5,1.65) , vec3(0.1,1.0,0.10) , br, 1.0 ,vec2(0.5,1.5), vec2(0.,.25));\n        d = min(d1, d);        //roof, building 1\n    \td1 = sdCubeTaper(rep1, p-vec3(3.8,0.4,1.5) , vec3(0.3,0.5,0.20) , br, 0.0 ,vec2(0.02,0.2), vec2(0.2,1.1));\n        d = min(d1, d);\n    \td1 = sdArchway(rep1, p-vec3(3.8,1.9,1.5) , vec3(0.475,0.5,0.20) , br, 0.0 ,vec2(0,0), vec2(0,0), vec2(0.0,-0.0), 0.2, 0.6);\n        d = min(d1, d);\n        d1 = sdCubeTaper(rep1, p-vec3(3.8,2.45,1.5) , vec3(0.3,0.04,0.20) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t// Building 2, Middle Bottom to top\n        d1 = sdCubeTaper(rep1, p-vec3(3.8,2.5,1.5) , vec3(0.5,0.04,0.3) , br, 0.1 ,vec2(0.5,0.5), vec2(1.0,1.0));\n        d = min(d1, d);     \t//Roof\n    \td1 = sdCubeTaper(rep1, p-vec3(1.72,1.2,11.5) , vec3(0.26,0.8,0.20) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n        d = min(d1, d);\n    \td1 = sdCubeTaper(rep1, p-vec3(1.45,1.2,11.5) , vec3(0.2,0.5,0.16) , br, 0.4 ,vec2(0.1,0.2), vec2(0.0,0.0));\n        d = min(d1, d);\n    \td1 = sdArchway(rep1, p-vec3(1.54,1.1,11.4) , vec3(0.16,0.5,0.20) , br, -0.5 ,vec2(0.1,0.2), vec2(2.0,0.0), vec2(0.0,-0.18), 0.08, 1.5);\n        d = min(d1, d);         //Building 3\t\n\t    d1 = sdArchway(rep4, p-vec3(-9.4,0.45,22.4) , vec3(0.16,0.15,0.1) , br, 0.5 ,vec2(1.0,0.0), vec2(2.0,0.0), vec2(0.0,0.02), 0.1, 2.0);\n        d = min(d1, d);     \t// Bridge Top\n    \td1 = sdCubeTaper(rep2, p-vec3(1.5,.88,6.5) , vec3(0.6,0.02,0.2) , br, 0.0 ,vec2(0.0,0.0), vec2(0.0,0.0));\n        d = min(d1, d);     \t// Pier end building roof\n\t\td1=Pendulum(vec3(p.x,p.y,mmod(p.z,8.0)));\n\t    if (d1<d) {d = min(d1, d); col = 2.0;}\n\t\td1 = WaterDist(p);\n\t\tif (d1<d) {notwaterdist = d; col = 3.0; d=d1;}\n}\n\n    if (d<MAX_DIST && col>9.5) {\n\tfloat text = ((TextureBrick(p+.05+perlinNoiseSample*.005,8.0)*0.004+.002)*perlinNoiseSample);\n\tcol=clamp(p.y,0.0,1.0)*.004+text*.2;\n\td+=clamp(1.0-p.y,0.1,1.0)*text*1.2;   //Brick texture\n\t}\n    return vec3(d,col,notwaterdist); // distance,  colour mask, distance to nearest non-water object.\n}\n\n//Raymarch scene\nvec4 RayMarch(vec3 ro, vec3 rd, bool detail, float msm) { // msm - max steps multiplier.\n    float dO=0.0;\n\tvec3 dS=vec3(0.0,0.0,0.0);\n    \n    for(float i=0.0; i<MAX_STEPS*msm; i++) {\n        vec3 p = ro + rd*dO;\n        dS = Map(p, detail,detail);\n        dO += dS.x;\n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n        if(p.y>2.5) {dO=MAX_DIST; break;}\n    }\n    return vec4(min(dO,MAX_DIST),dS.y,dS.z,0); // distance, colour mask, distance to non-water object, unused\n}\n\n//Get Normal\nvec3 GetNormal(vec3 p) {\n    vec3 d = Map(p, true, true);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d.x - vec3(\n        Map(p-e.xyy,true,true).x,\n        Map(p-e.yxy,true,true).x,\n        Map(p-e.yyx,true,true).x); //swizzle\n    return normalize (n);\n}\n\n//Get Water Normal\nvec3 GetWaterNormal(vec3 p) {\n    float d = WaterDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        WaterDist(p-e.xyy),\n        WaterDist(p-e.yxy),\n        WaterDist(p-e.yyx)); //swizzle\n    return normalize (n);\n}\n\n//Raymarch Soft Shadows\nfloat RayMarchss(vec3 ro, vec3 rd, bool detail ) { // http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    float dO=0.0;\n\tvec3 dS=vec3(0.0,0.0,0.0);\n\tfloat s = 1.0;\n\tfloat w = .3; //Shadow width\n    \n    for(float i=0.0; i<MAX_STEPS*.5; i++) {\n        vec3 p = ro + rd*dO;\n\t\tdS = Map(p,false,detail);\n        dO += dS.x;\n\t\ts = min( s, dS.x/(w*dO) );\n        if (dO>MAX_DIST || abs(dS.x)<SURF_DIST || s<0.0) break;\n    }\n    \n    s = max(s,0.0);\n\treturn s;\n}\n\n//lighting\nvec3 GetLight(vec3 p, bool detail) {\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, lightDir), 0.0, 1.0);\n    float shadow=1.0;\n\tif (detail) shadow = RayMarchss( p+n*SURF_DIST*1.8, lightDir, true); //Shadows\n\tvec3 bounce = clamp(dot(n, vec3(0,-1,0)), 0.0, 1.0)*vec3(0.1284, 0.1694, 0.1082);\n    return vec3 (1.124, 0.953, 0.500)*dif*shadow+bounce;  \n}\n\n//reflection\nvec3 GetReflectionWater(vec3 p, vec3 rd) {\n    vec3 n = GetWaterNormal(p);\n    rd = reflect(rd,n); \n    vec4 d = RayMarch(p+n*SURF_DIST, rd, false,0.3); \n    float fresnel = 1.0-abs(dot(n, rd));\n\tp+=rd * d.x;\n    vec3 col = GetLight(p, false);\n\t\n\t//Simple Colourize reflected Geo\n\tif (d.y < 1.5) col *= mix(vec3 (0.7725491, 0.4196079, 0.2196079), vec3 (0.9666667, 0.8254902, 0.709804), d.y*300.0);  //brick\n\tcol = mix(col, mix(vec3 (0.7490196, 0.6352941, 0.3333333),vec3 (0.3137255, 0.2588235, 0.1215686),clamp(p.y*5.0,0.0,1.0)),clamp(d.x*.025,0.0,1.0)); //sky&fog\n    return col*fresnel;\n} \n\nfloat GetSpecular(vec3 p, vec3 rd) {\n\tvec3 n = GetNormal(p);\n\trd = reflect(rd,n);\n\treturn pow(dot(n,lightDir),3.0);\n}\n\n//...Main................................................................................................................//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y*=iResolution.y/iResolution.x;\n \n    vec3 ro = vec3(-.5,.5+sin((iTime-4.5)*.0982)*.4, -3.0+iTime);\n    vec3 lookat = vec3(1.0+uv.x*(cos(uv.y+3.14)+1.0)*10.0, .2+uv.y*(cos(uv.x+3.14)+1.0)*-5.0 , iTime); //fish eye effect.\n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.),f));\n    vec3 u = cross(f, r);\n    vec3 rd = f + uv.x*r + uv.y*u;\n    vec4 d = RayMarch(ro, rd, true, 1.0);\n\tvec3 p = ro + rd * d.x;\n\tvec3 col = GetLight(p, true);\n\n// Colourize scene, 0 to1 - Brick 2 - Pendulum 3 - Water 10 - Sky\n\n\tif (d.y < 1.5) col *= mix(vec3 (0.7725491, 0.4196079, 0.2196079), vec3 (0.9666667, 0.8254902, 0.709804), d.y*300.0);  //brick\n\tif (d.y > 1.5 && d.y < 2.5) col *= vec3 (0.5529412, 0.2980392, 0.1411765)+GetSpecular(p,rd); //pendulum\n\tif (d.y > 2.5 && d.y < 3.5) col *= .5*mix(vec3 (0.0411765, 0.2215687, 0.6215686),vec3 (0.1411765, 0.6215687, 0.9215686),pow(clamp(1.0-d.z*.5,0.0,1.0),2.0))+GetReflectionWater(p,rd)*.5; //water, deep, shallow\n\tcol = mix(col, mix(vec3 (0.7490196, 0.6352941, 0.3333333),vec3 (0.2537255, 0.2288235, 0.1415686),pow(clamp(p.y*.15,0.0,1.0),.4)),clamp(d.x*.025,0.0,1.0)); //sky&fog\n    col += vec3(0.2431373,0.2588235,0.2039216)*.2; //ambient\n\tcol *= pow(1.0-(pow(uv.x*1.4,2.0)+pow(uv.y*2.49,2.0)),.1); //Vignette\n\t\n        fragColor =  vec4(col,1.0);\n}\n\n   \n \n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 753, 783, 783, 815], [817, 832, 858, 858, 1060], [1062, 1085, 1138, 1186, 1788], [1790, 1809, 1838, 1838, 2040], [2042, 2050, 2089, 2108, 2548], [2550, 2594, 2628, 2628, 2693], [2695, 2705, 2825, 2825, 3346], [3349, 3371, 3452, 3538, 3799], [3801, 3896, 3965, 3965, 4127], [4129, 4218, 4287, 4287, 4416], [4418, 4446, 4466, 4466, 4664], [4666, 4687, 4711, 4711, 4923], [4926, 4926, 4951, 4951, 5186], [5188, 5311, 5357, 5407, 11252], [11254, 11271, 11328, 11359, 11754], [11756, 11769, 11793, 11793, 12019], [12021, 12040, 12069, 12069, 12270], [12272, 12296, 12346, 12408, 12763], [12765, 12776, 12812, 12812, 13136], [13138, 13151, 13193, 13193, 13741], [13744, 13744, 13780, 13780, 13861], [13863, 13988, 14045, 14045, 15420]]}
{"id": "ttK3Rm", "name": "bounding box test", "author": "BrianDeLange", "description": "making a bounding box around a transformed shape", "tags": ["box"], "likes": 0, "viewed": 54, "published": "Public", "date": "1578589321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 transformationMat(vec2 scale, float angle, vec2 pos){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1., 0., pos.x,\n                0., 1., pos.y, \n                0., 0., 1.) *\n           mat3(c , -s, 0.,\n           \t\ts ,  c, 0.,\n          \t\t0., 0., 1.)*\n           mat3(1./scale.x, 0., 0.,\n                0., 1./scale.y, 0.,\n                0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col;\n\n    float r = 1.;\n    \n    mat3 transform = transformationMat(vec2(0.125, (1.3+sin(iTime))/8.), iTime, vec2(cos(iTime)/3., sin(iTime)/3.));\n    \n    mat3 inv = inverse(transform);\n    \n    float xPos = inv[0][2];\n    float yPos = inv[1][2];\n    float x = (abs(inv[0][0])+abs(inv[0][1]));\n    float y = (abs(inv[1][0])+abs(inv[1][1]));\n    \n    float minX = xPos-x;\n    float minY = yPos-y;\n    float maxX = xPos+x;\n    float maxY = yPos+y;\n    \n    if(uv.x < maxX && uv.x > minX &&\n       uv.y < maxY && uv.y > minY)\n    {\n        col = vec3(1., 0., 0.);\n    }\n    \n    uv = (vec3(uv.xy, 1.)*transform).xy;\n    \n\t\n    if(uv.x < 1. && uv.x > -1. &&\n       uv.y < 1. && uv.y > -1.)\n    {\n        col = vec3(1., 1., 1.);\n    }\n    \n    if(uv.x*uv.x+uv.y*uv.y < r*r)\n    {\n        col = vec3(0., 1., 0.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 384], [386, 386, 443, 443, 1363]]}
{"id": "ttK3Wt", "name": "Sponge Tunnel", "author": "hatuxes", "description": "Simple Menger.", "tags": ["cineshadermengerspongeraymarching"], "likes": 4, "viewed": 9200, "published": "Public API", "date": "1580216516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=acos(-1.0);\nconst float pi2=pi*2.0;\n\nmat2 rot(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r){\n    float a=atan(p.x, p.y)+pi/r;\n    float n=pi2*(-sin(0.42*iTime)*sin(0.42*iTime)+0.35)/r;\n    a=floor(a/n)*n-pi;\n    return p*rot(-a);\n}\n\nfloat crossf(vec3 p, float r){\n    p=abs(p);\n    float dxy=max(p.x, p.y);\n    float dyz=max(p.y, p.z);\n    float dxz=max(p.z, p.x);\n    return min(dxy, min(dyz, dxz))-r;\n}\n\nfloat boxf(vec3 p, vec3 b){\n    p=abs(p)-b;\n    return length(max(p, 0.0))+min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n\nfloat mengersponge(vec3 p, float scale, float width){\n    float d=boxf(p, vec3(1.0));\n    float s=1.0;\n    for(int i=0; i<5; i++){\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=scale;\n        vec3 r=1.0-scale*abs(a);\n        float c=crossf(r, width)/s;\n        d=max(d,c);\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    p=mod(p, 4.0)-2.0;\n    return mengersponge(p, 3.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro=vec3(0.0, 0.0, 8.0*iTime);\n    vec3 rd=normalize(vec3(uv, 0.8*sin(0.58*iTime)));\n    vec3 col=vec3(0);\n    float dp=0.0, dpp=0.0;\n    for(int i=0; i<99; i++){\n        vec3 pos=ro+rd*dp;\n        pos.xy*=rot(0.1*iTime);\n        pos.xy=pmod(pos.xy, 8.0);\n        float d=map(pos);\n        if(d<0.00001){\n            col=vec3(1.0-float(i)*0.02);\n            break;\n        }\n        dp+=d*0.8;\n        dpp=d*75.516;\n    }\n    fragColor=vec4(col, dpp);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttK3Wt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 70, 70, 132], [134, 134, 161, 161, 300], [302, 302, 332, 332, 473], [475, 475, 502, 502, 586], [589, 589, 642, 642, 882], [884, 884, 902, 902, 965], [967, 967, 1024, 1024, 1567]]}
{"id": "ttKGDK", "name": "Noise  isosurface", "author": "hiogawa", "description": "My first attempt to do somthing 3d-ish.", "tags": ["noise"], "likes": 2, "viewed": 216, "published": "Public API", "date": "1579950851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// - Thin isosurfaces of 3d noise as emission source\n// - Beer-Lambert model of absorption\n//\n\n#define M_PI 3.14159\n\nfloat SCALE_TIME = 0.15;\n\n// Emission source\nfloat NOISE_SCALE = 2.0;\nfloat NOISE_NUM_OCTAVES = 6.0;\nfloat ISOSURFACE_VALUE_HALF_WIDTH = 0.03;\nfloat NUM_ISOSURFACE_SIDES = 2.0;\n\n\n// Volume\nfloat VOLUME_DEPTH = 0.2;\nfloat VOLUME_NUM_SAMPLES = 6.0;\nfloat EMISSION_SCALE = 0.2;\nvec3 EMISSION_COLOR = vec3(0.0, 1.0, 1.0);\n\n\n//\n// Noise\n//\n\nfloat hash31(vec3 v) {\n  vec3 u = vec3(1234.5, 5432.1, 5678.9);\n  return fract(sin(dot(v, u) * 2357.0) * 56789.0);\n}\n\nfloat hash41(vec4 v) {\n  vec4 u = vec4(1234.5, 5432.1, 5678.9, 3456.7);\n  return fract(sin(dot(v, u) * 2357.0) * 56789.0);\n}\n\nvec2 hash32(vec3 v) {\n  return vec2(hash31(v), hash41(vec4(v, 1.0)));\n}\n\nvec3 hashGradient3(vec3 v) {\n  vec2 p = hash32(v);\n\n  // Usual spherical sampling\n  // Prob([0, theta] \\sub [0, pi]) = (1 - cos(theta)) / 2\n  float theta = acos(1.0 - 2.0 * p[0]);\n  float phi = 2.0 * M_PI * p[1];\n\n  return vec3(\n    sin(theta) * cos(phi),\n    sin(theta) * sin(phi),\n    cos(theta)\n  );\n}\n\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nfloat mix3(\n    float f000, float f100, float f010, float f110,\n    float f001, float f101, float f011, float f111,\n    vec3 v) {\n  float fxy0 = mix2(f000, f100, f010, f110, v.xy);\n  float fxy1 = mix2(f001, f101, f011, f111, v.xy);\n  return mix(fxy0, fxy1, v.z);\n}\n\nfloat gradientNoise3(vec3 v) {\n  vec3 vi = floor(v);\n  vec3 vf = v - vi;\n  float f000 = dot(hashGradient3(vi + vec3(0.0, 0.0, 0.0)), vf - vec3(0.0, 0.0, 0.0));\n  float f100 = dot(hashGradient3(vi + vec3(1.0, 0.0, 0.0)), vf - vec3(1.0, 0.0, 0.0));\n  float f010 = dot(hashGradient3(vi + vec3(0.0, 1.0, 0.0)), vf - vec3(0.0, 1.0, 0.0));\n  float f110 = dot(hashGradient3(vi + vec3(1.0, 1.0, 0.0)), vf - vec3(1.0, 1.0, 0.0));\n  float f001 = dot(hashGradient3(vi + vec3(0.0, 0.0, 1.0)), vf - vec3(0.0, 0.0, 1.0));\n  float f101 = dot(hashGradient3(vi + vec3(1.0, 0.0, 1.0)), vf - vec3(1.0, 0.0, 1.0));\n  float f011 = dot(hashGradient3(vi + vec3(0.0, 1.0, 1.0)), vf - vec3(0.0, 1.0, 1.0));\n  float f111 = dot(hashGradient3(vi + vec3(1.0, 1.0, 1.0)), vf - vec3(1.0, 1.0, 1.0));\n  vec3 vf_smooth = smoothstep(vec3(0.0), vec3(1.0), vf);\n  float t = mix3(f000, f100, f010, f110, f001, f101, f011, f111, vf_smooth);\n  // Normalize via upper/lower bound = +- 2 / sqrt(3) ~= 1.15\n  return (t / 1.15 + 1.0) * 0.5;\n}\n\nfloat noise(vec3 v, float n) {\n  float result = 0.0;\n  for (float i = 0.0; i < n; i++) {\n    float p = pow(2.0, i);\n    result += (gradientNoise3(v * p) / p);\n  }\n  result /= (pow(2.0, n) - 1.0) / (pow(2.0, n - 1.0));\n  return result;\n}\n\n//\n// Misc\n//\n\nfloat smoothBump(float fac, float bump, float half_width) {\n  return 1.0 - smoothstep(0.0, half_width, abs(fac - bump));\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  vec2 uv =  frag_coord / iResolution.y;\n  float t = SCALE_TIME * iTime;\n\n  // Compute \"intensity\" by summing each layers\n  float fac_total = 0.0;\n  for (float i = 0.0; i < VOLUME_NUM_SAMPLES; i++) {\n    float z = i / VOLUME_NUM_SAMPLES * VOLUME_DEPTH;\n\n    // Noise\n    float fac_noise = noise(vec3(NOISE_SCALE * uv, z + t), NOISE_NUM_OCTAVES);\n    fac_noise = smoothstep(0.0, 1.0, fac_noise); // tonemap\n\n    // Pickup isosurfaces\n    float fac = 0.0;\n    fac += smoothBump(fac_noise, 0.5, ISOSURFACE_VALUE_HALF_WIDTH);\n    for (float j = 1.0; j <= NUM_ISOSURFACE_SIDES; j++) {\n      fac += smoothBump(fac_noise, 0.5 + 4.0 * j * ISOSURFACE_VALUE_HALF_WIDTH, ISOSURFACE_VALUE_HALF_WIDTH);\n      fac += smoothBump(fac_noise, 0.5 - 4.0 * j * ISOSURFACE_VALUE_HALF_WIDTH, ISOSURFACE_VALUE_HALF_WIDTH);\n    }\n\n    // Attenuate by depth\n    fac_total += exp(- z) * fac;\n  }\n\n\n  frag_color = vec4(fac_total * EMISSION_SCALE * EMISSION_COLOR, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 456, 478, 478, 572], [574, 574, 596, 596, 698], [700, 700, 721, 721, 771], [773, 773, 801, 801, 1077], [1079, 1079, 1144, 1144, 1211], [1213, 1213, 1342, 1342, 1477], [1479, 1479, 1509, 1509, 2478], [2480, 2480, 2510, 2510, 2716], [2718, 2733, 2792, 2792, 2855], [2857, 2872, 2926, 2926, 3871]]}
{"id": "ttKGDt", "name": "Phantom Star for CineShader", "author": "kasari39", "description": "https://cineshader.com/view/ttKGDt", "tags": ["raymarching", "ifs", "phantommode"], "likes": 151, "viewed": 96167, "published": "Public API", "date": "1580219576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 107], [165, 165, 193, 193, 299], [301, 301, 330, 330, 421], [423, 423, 445, 445, 635], [637, 637, 667, 667, 839], [841, 841, 898, 898, 1897]]}
{"id": "ttKGRm", "name": "Ray traced terrain", "author": "jesusdz", "description": "Terrain test:\n- noise-based (fbm) heightmap, water ripples and clouds\n- ambient occlusion effect\n- water reflection\n- camera control", "tags": ["noise", "terrain"], "likes": 8, "viewed": 206, "published": "Public", "date": "1578705309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_HEIGHT 60.0\n#define MAX_DISTANCE 400.0\n#define NOISE_SCALE 0.03\n#define WATER_HEIGHT 23.0\n\n#define PI 3.14159265359\n\nfloat hash( float n )\n{\n  return fract(cos(n)*41375.92653);\n}\n\nfloat noise2(in vec2 x)\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(\n      mix(hash(n+0.0),  hash(n+1.0),  f.x),\n      mix(hash(n+57.0), hash(n+58.0), f.x),\n      f.y);\n}\n\nfloat fbm(in vec2 x)\n{\n    float val = 0.5 * noise2(x);\n    val += 0.25 * noise2(2.01 * x);\n    val += 0.12 * noise2(4.03 * x);\n    val += 0.06 * noise2(7.99 * x);\n    val += 0.03 * noise2(16.02 * x);\n    //val += 0.01 * noise2(32.04 * x);\n    return val/0.96;\n}\n\nfloat fbmDetailed(in vec2 x)\n{\n    float val = 0.5 * noise2(x);\n    val += 0.25 * noise2(2.01 * x);\n    val += 0.12 * noise2(4.03 * x);\n    val += 0.06 * noise2(7.99 * x);\n    val += 0.03 * noise2(16.02 * x);\n    //val += 0.01 * noise2(32.04 * x);\n    val += 0.002 * noise2(512.01 * x);\n    return val/0.962;\n}\n\nfloat heightmap(in vec2 p)\n{\n    float height = MAX_HEIGHT * fbm(NOISE_SCALE * p);\n    return height;\n}\n\nfloat heightmapDetailed(in vec2 p)\n{\n    float height = MAX_HEIGHT * fbmDetailed(NOISE_SCALE * p);\n    return height;\n}\n\nvec3 terrainNormal(in vec3 p)\n{\n    float eps = 0.3;\n    vec3 v1 = p - vec3(p.x-eps, heightmap(p.xz - vec2(eps,0.0)), p.z);\n    vec3 v2 = p - vec3(p.x,     heightmap(p.xz - vec2(0.0,eps)), p.z-eps);\n    vec3 n = normalize(cross(v2, v1));\n    return n;\n}\n\nvec3 terrainNormalDetailed(in vec3 p)\n{\n    float eps = 0.3;\n    vec3 v1 = p - vec3(p.x-eps, heightmapDetailed(p.xz - vec2(eps,0.0)), p.z);\n    vec3 v2 = p - vec3(p.x,     heightmapDetailed(p.xz - vec2(0.0,eps)), p.z-eps);\n    vec3 n = normalize(cross(v2, v1));\n    return n;\n}\n\nfloat fresnel(in vec3 eyeDir, float R0)\n{\n    return R0 + (1.0 - R0)*pow(1.0 - dot(eyeDir, vec3(0.0,1.0,0.0)), 5.0);\n}\n\nvec3 terrainColor(in vec3 p)\n{\n    float h = p.y;\n    float h2 = h + 5.0 * (2.0 * fbm(p.xz) - 1.0);\n    vec3 col = vec3(0.1,0.3,0.0);\n    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(WATER_HEIGHT + 4.0, WATER_HEIGHT + 7.0, h2));\n    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(WATER_HEIGHT + 12.0, WATER_HEIGHT + 15.0, h2));\n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(WATER_HEIGHT + 24.0, WATER_HEIGHT + 27.0, h2));\n    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(WATER_HEIGHT, WATER_HEIGHT + 0.5, h));\n    return col;\n    \n    #if 0\n    float h = p.y / MAX_HEIGHT;\n    float h2 = h + 0.07*(2.0 * fbm(p.xz) - 1.0);\n    vec3 col = vec3(0.1,0.3,0.0);\n    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(0.54, 0.58, h2));\n    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(0.60, 0.64, h2));\n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(0.68, 0.72, h2));\n    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(0.46, 0.465, h));\n    return col;\n    #endif\n}\n\nvec3 horizonCol = vec3(0.8, 0.95, 1.0);\n\nvec3 skyColor(in vec3 d)\n{\n    vec3 skyCol = vec3(0.1, 0.4, 0.8);\n    \n    vec2 uv = d.xz / d.y;\n    float cloudFactor = min(1.0, max(0.0, fbm(uv+iTime*0.05) - 0.5) * 15.0);\n    skyCol = mix(skyCol, vec3(1.0), cloudFactor * d.y);\n    \n    skyCol = mix(horizonCol, skyCol, sqrt(abs(d.y)));\n    \n    return skyCol;\n}\n\nfloat intersectTerrain(in vec3 o, in vec3 d)\n{\n    vec3 p = o;\n    float t0 = 0.0;\n    float t = 0.0;\n    float delta = 0.0;\n    float h = 0.0;\n    bool hit = false;\n    bool involume = true;\n\n    for (int i = 0; i < 140 && !hit && involume; ++i)\n    {\n        delta = max(0.01, 0.2*abs(p.y - h)) + t * 0.01;\n        t0 = t;\n        t += delta;\n        \n        p = o + t * d;\n        h = heightmap(p.xz);\n        hit = (p.y < h);\n        involume = (p.y < MAX_HEIGHT) && (t < MAX_DISTANCE);\n    }\n\n    if (hit)\n    {\n        // binary search\n        for (int i = 0; i < 10; ++i)\n        {\n            float tc = 0.5 * (t0 + t);\n        \tp = o + tc * d;\n\n        \th = heightmap(p.xz);\n            \n        \tif (p.y < h)\n        \t{\n                t = tc;\n                t0 = t0;\n        \t}\n            else\n            {\n                t = t;\n                t0 = tc;\n            }\n        }\n        \n        return t;\n    }\n    \n    return 0.0;\n}\n\nfloat calcAO(in vec3 p, in vec3 n)\n{\n    float ao = 0.0;\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    vec3 uu = normalize(cross(vec3(1.0,0.0,0.0), n));\n    vec3 vv = n;\n    vec3 ww = cross(vv, uu);\n    mat3 rot = mat3(uu, vv, ww);\n    for (int i = 0; i < 6; ++i)\n    {\n        r1 = hash(435.627*r1) * 2.0 - 1.0;\n        r2 = hash(513.128*r2) * 2.0 - 1.0;\n    \tr3 = hash(198.731*r3);\n        vec3 disp = rot * vec3(r1,r3,r2) * float(i) * 1.0;\n        vec3 pb = p + disp;\n        float h = heightmap(pb.xz);\n        ao += max(0.0, smoothstep(float(i), 0.0, pb.y - h));\n    }\n    ao = 1.0 - ao/6.0;\n    ao *= ao;\n    return ao;\n}\n\nvec3 shadeTerrain(in vec3 p)\n{\n    vec3 col = vec3(0.0);\n    \n    // AO\n    float h = p.y;\n    vec3 n = terrainNormalDetailed(p);\n    float ao = calcAO(p, n);\n    vec3 mcolor = terrainColor(p);\n\n    // ambient\n    vec3 acolor = 0.5*vec3(0.5, 0.5, 0.6);\n    float amb = max(0.0, dot(0.5*n + 0.5, vec3(0.0, 1.0, 0.0)));\n    col += vec3(mcolor * acolor * amb * ao);\n\n    // diffuse\n    vec3 l = normalize(vec3(0.5, 1.0, 2.0));\n    vec3 dcolor = vec3(0.5, 0.5, 0.4);\n    float dif = max(0.0, dot(n, l));\n    col += vec3(mcolor * dcolor * dif);\n    \n    return col;\n}\n\nvec3 shadeWater(in vec3 obs, in vec3 p, in vec3 d, float groundDepth, in vec3 groundColor)\n{\n    // normal\n    vec2 eps = vec2(0.1,0.0);\n    vec3 n0 =      vec3(p.x        , fbm(3.0*p.xz + eps.yy + iTime), p.z);\n    vec3 n1 = n0 - vec3(p.x + eps.x, fbm(3.0*p.xz + eps.xy + iTime), p.z);\n    vec3 n2 = n0 - vec3(p.x        , fbm(3.0*p.xz + eps.yx + iTime), p.z + eps.x);\n    vec3 n = cross(n1, n2);\n    float att = length(obs - p) * 1.5;\n    n.y *= att;\n    n = normalize(n);\n    \n    // reflection\n    vec3 r = reflect(d, n);\n    vec3 reflectedCol = skyColor(r);\n    float t = intersectTerrain(p, r);\n    if (t > 0.0)\n    {\n        vec3 p = p + t*r;\n        reflectedCol = shadeTerrain(p);\n    }\n    \n    // refraction\n    vec3 deepBlue = vec3(0.0,0.05,0.2);\n    vec3 refractedCol = mix(deepBlue, groundColor, exp(-groundDepth*0.5));\n    \n    float f = fresnel(-d, 0.03);\n    vec3 col = mix(refractedCol, reflectedCol, f);\n\treturn col;\n}\n\nvec3 cameraPos(float time)\n{\n    float speed = 5.0;\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 pos = vec3(0.0, 0.0, 0.0) + speed*time*dir;\n    pos.y = heightmap(pos.xz) + 5.0;\n    pos.y = max(pos.y,WATER_HEIGHT + 5.0);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // camera\n    float tf = mod(iTime, 1.0);\n    float t1 = iTime - tf;\n    float t2 = t1 + 1.0;\n    vec3 o1 = cameraPos(t1);\n    vec3 o2 = cameraPos(t2);\n    vec3 o = cameraPos(iTime);\n    o.y = mix(o1.y, o2.y, tf/1.0);\n    \n    vec3 c = o + vec3(cos(PI*iMouse.x/iResolution.x), 4.0*sin(iMouse.y/iResolution.y-0.5)-0.5, sin(PI*iMouse.x/iResolution.x));\n    vec3 ww = normalize(o - c);\n    vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n    vec3 vv = cross(ww, uu);\n    vec3 d = normalize(uu * uv.x + vv * uv.y - ww * 2.8);\n\n#if 0\n    // height projected on floor\n    float tf = -o.y / d.y;\n    if (tf > 0.0)\n    {\n       \tvec3 p = o + tf * d;\n        fragColor = vec4(vec3(fbm(0.04*p.xz)), 1.0);\n        return;\n    }\n#endif\n    \n    vec3 col = vec3(0.0);\n    \n    float t = intersectTerrain(o, d);\n        \n    if (t > 0.0)\n    {\n        vec3 p = o + t * d;\n        \n        col = shadeTerrain(p);\n        \n    \t// water\n        if (p.y < WATER_HEIGHT)\n        {\n\t    \tfloat t2 = (WATER_HEIGHT-o.y) / d.y;        \n       \t\tvec3 waterPos = o + t2 * d;\n            \n            col = shadeWater(o, waterPos, d, length(p - waterPos), col);\n        }\n        \n        col = mix(horizonCol, col, 1.0 - smoothstep(0.0, MAX_DISTANCE, t));//exp(-t*0.001));\n    }\n    else\n    {\n   \t\tcol = skyColor(d);\n    }\n    \n#if 0\n    // show material gradient\n    if (uv.y < -0.5)\n    {   \n        vec3 p = vec3(uv.x, MAX_HEIGHT*(uv.x * 0.5 + 0.5), uv.y);\n        col = colormap(p);\n    }\n#endif\n    \n    col = sqrt(col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 152, 152, 190], [192, 192, 217, 217, 428], [430, 430, 452, 452, 692], [694, 694, 724, 724, 1004], [1006, 1006, 1034, 1034, 1109], [1111, 1111, 1147, 1147, 1230], [1232, 1232, 1263, 1263, 1485], [1487, 1487, 1526, 1526, 1764], [1766, 1766, 1807, 1807, 1884], [1886, 1886, 1916, 1916, 2857], [2900, 2900, 2926, 2926, 3214], [3216, 3216, 3262, 3262, 4165], [4167, 4167, 4203, 4203, 4812], [4814, 4814, 4844, 4844, 5376], [5378, 5378, 5470, 5484, 6315], [6317, 6317, 6345, 6345, 6566], [6568, 6568, 6625, 6675, 8351]]}
{"id": "ttKGW1", "name": "Simple Camera Struct", "author": "sbrown2", "description": "a simple 3d skeleton soon to add camera structure.", "tags": ["3d"], "likes": 1, "viewed": 74, "published": "Public", "date": "1578861420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct CAMERA{\n\tvec3  camPos;\n    vec3  rd;\n    \n};\n    \nfloat shortestDistToRay(CAMERA c, vec3 p){\n    \n    \n      return    length(cross(p-c.camPos,c.rd))/length(c.rd);\n}\n\nfloat DrawPoint(CAMERA c, vec3 p){\n\n    float  d       =  shortestDistToRay(c,p);\n\t       d       =  smoothstep(.06,.05,d);\n    \n    return d;\n}\nvec3 getCameraRayDirection(vec2 uv, vec3 lookat, vec3 ro, float zoom){\n\t\n    vec3   f       =  normalize(lookat-ro);\n    vec3   r       =  cross(vec3(0.,1.,0.),f);\n    vec3   u       =  cross(f,r);\n    vec3   sc      =  ro + f*zoom;\n    vec3   i       =  sc + uv.x*r + uv.y*u;\n    vec3   rd      =  i-ro;\n    return rd;\n}\n\nCAMERA createCamera(vec2 uv,vec3 lookat,vec3 ro,float zoom){\n\t\n    vec3   rd      =  getCameraRayDirection(uv,lookat,ro,zoom);\n    \n    CAMERA c       =  CAMERA(ro,rd);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2   uv      =  fragCoord/iResolution.xy;\n\t       uv     -=  .5;\n           uv.x   *=  iResolution.x/iResolution.y;\n    \n    //create camera\n\tvec3   lookat  =  vec3(.5);    \n    vec3   camPos      =  vec3(3.0*sin(iTime),2.,-3.*cos(iTime));\n    vec3   loc     =  camPos;\n    float  zoom    =  .8;\n    \n    CAMERA c       =  createCamera(uv,lookat,camPos,zoom);\n    \n\t       c       =  createCamera(uv,lookat,camPos\n                                   ,zoom);    \n   \t//draw cube by placing 8 points\n    float  d       =  0.;\n    \n           d       +=  DrawPoint(c,vec3(0.,0.,0.));\n           d       +=  DrawPoint(c,vec3(0.,0.,1.));\n           d       +=  DrawPoint(c,vec3(0.,1.,0.));\n           d       +=  DrawPoint(c,vec3(0.,1.,1.));\n           d       +=  DrawPoint(c,vec3(1.,0.,0.));\n           d       +=  DrawPoint(c,vec3(1.,0.,1.));\n           d       +=  DrawPoint(c,vec3(1.,1.,0.));\n           d       +=  DrawPoint(c,vec3(1.,1.,1.));\n\n    vec3   hue     =  vec3(1.);\n    \n    \n    fragColor    =  vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 99, 99, 172], [174, 174, 208, 208, 318], [319, 319, 389, 389, 640], [642, 642, 702, 702, 826], [828, 828, 884, 939, 1963]]}
{"id": "ttKGWV", "name": "KIFS experiments 4", "author": "rodgzilla", "description": "kifs experiments", "tags": ["kifs"], "likes": 1, "viewed": 73, "published": "Public", "date": "1579961069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define SPEED 20.\n\nfloat PI = acos(-1.);\n\nvec3 palette(float x) {\n//  float wave = sin(3. * time) * 0.5 + 0.5;\n  vec3 p = vec3(1, .5, 1);\n  vec3 q = vec3(.7, .6, 1);\n  vec3 r = vec3(.3, .6, .3);\n  vec3 s = vec3(.9, .5, .3);\n/*\n  vec3 p = vec3(1, 1, 1);\n  vec3 q = vec3(.3, .6, 1);\n  vec3 r = vec3(.3, .6, .3);\n  vec3 s = vec3(.9, .5, .3);\n*/\n  return p + q * sin(2. * PI * (x * r + s));\n}\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n\n  return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float d, float s, float tf) {\n  float t = tf * time;\n\n  for (float i = 0.; i < d; i += 1.) {\n    p.xy *= rot2d(t + i);\n    p.xz *= rot2d(t * 0.6 - i);\n    p.xy *= rot2d(PI / 2.);\n\tp = abs(p);\n    p -= s;\n    s *= 0.8;\n  }\n\n  return p;\n}\n\nfloat map(vec3 p) {\n  p.xy *= rot2d(time * .1);\n  p.yz *= rot2d(time * .25);\n  float wave = .5 * sin(time) + .5;\n  float d = 10000.;\n  vec3 p1 = kifs(p, 2., 1., .3);\n  vec3 p2 = kifs(p, 5., .5 + 3. * (.5 * sin(time / 4.) + .5), .8);\n//  vec3 p2 = kifs(p, 5., 2.5, .8);\n  float mix_param = .2 + .8 * wave;\n  p = mix(p1, p2, mix_param);\n//  p = mix(p1, p2, .5 + .5 * sin(2. * time));\n  d = min(d, length(p) - 1.);\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0, 0, -30.);\n  vec3 rd = normalize(vec3(uv, 1));\n\n  float d = 0.;\n  int i;\n  for (i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n\n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n\n    d += ds / 2.;\n  }\n  vec3 p = ro + d * rd;\n  vec2 e = vec2(0.01, 0);\n  vec3 n = normalize(map(p) - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx)));\n  vec3 l = vec3(0, 0, -30.);\n  float dif = dot(n, normalize(l - p));\n\n  vec3 col = vec3(dif * palette(p.z / 5.));\n//  vec3 col = vec3(dif);\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 84, 129, 407], [409, 409, 430, 430, 493], [495, 495, 542, 542, 749], [751, 751, 770, 770, 1176], [1178, 1178, 1235, 1235, 1927]]}
{"id": "ttt3Wl", "name": "tunelv4", "author": "jorge2017a1", "description": "tunelv4", "tags": ["tunelv4"], "likes": 0, "viewed": 53, "published": "Public", "date": "1578000656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat Sphere(vec3 p, vec3 o, float r){\n        return length(p-o)-r;  \n}\n \nfloat Plane(vec3 p){\n\treturn p.y;\t\n}\n\nvec3 DR(vec3 p,vec3 q){\n\treturn mod(p,q)-q/2.;\n}\n\n\n///----------------------------\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\nfloat sdSpherev2( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///---------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n///-------------------------------\n\nfloat h(vec3 p) {\n    \n\n    \n    vec2 res;\n    float dif1, dif2;\n \n    \n    res= vec2(999.9);\n    \n     p.xz=opRep( p.xz, 15. );\n   // p.z=mod( mod(p.z, 7.0),2.0)-0.5;\n   \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(8.5,5.8,8.0) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,5.2,9.0) );\n    \n    float sdb3d=sdBox(p-vec3(0.0,6.0,0.), vec3(1,1.0,1.0) );\n    \n    \n    \n    float sdb3pisoi=sdBox(p-vec3(-5.0,3.0,0.0), vec3(3,1.1,2.) );\n    float sdb4pisod=sdBox(p-vec3(5.0,3.0,0.0), vec3(3,1.1,2.) );\n    \n    float sdb5pisoi=sdBox(p-vec3(-5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    float sdb6pisod=sdBox(p-vec3(5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    \n    \n   \n    dif2=differenceSDF(sdb1,sdb3pisoi);\n    dif2=differenceSDF(dif2,sdb4pisod);\n    dif2=differenceSDF(dif2,sdb5pisoi);\n    dif2=differenceSDF(dif2,sdb6pisod);\n    \n    //dif1=differenceSDF(sdb1, sdb2);\n    dif1=differenceSDF(dif2,sdb2);\n    \n    \n    res=opU(res, vec2(dif1,8));\n    \n    return res.x;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 e=vec2(.001,0);\n\treturn normalize(vec3(\n\t\th(p+e.xyy)-h(p-e.xyy),\n\t\th(p+e.yxy)-h(p-e.yxy),\n\t\th(p+e.yyx)-h(p-e.yyx)\n\t));\n}\n\nfloat AO(vec3 p,vec3 q){\t\t\t// AO at point p with normal q\n\tfloat o=0.,s=1.,r,d;\n    \tfor(float i=0.;i<5.;i++){\n\t\tr=.01+.12*i/4.;\n\t\tvec3 a=q*r+p;\n\t\td=h(a);\n\t\to+=-(d-r)*s;\n\t\ts*=.95;\n    \t}\n    \treturn clamp(1.-3.*o,0.,1.);   \n}\n\nfloat SH(vec3 p, vec3 q){\t\t\t// Calculate shadow amount: p=intersection point; q=light direction\n\tvec3 r = p + q*.01;\n\tfloat d;\n\tfor(int i=0; i<16; i++) {\n\t\td = h(r);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tr += q * d;\t\t\t\t// March along!\n\t}\n\tif (d < 0.001)\n\t\treturn 0.1;\n\telse\n\t\treturn 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\t\n\t//vec3 ro = vec3(1.4, 1.6, -4+iTime);\t\t\t// Cam pos (ray origin)\n    vec3 ro = vec3(1.4, 4.6, -24.0+iTime);\t\t\t// Cam pos (ray origin)\n    \n    \n\tvec3 up = vec3(0, 1, 0);\t\t\t// Cam orientation vecs\n\tvec3 fd = vec3(0, 0, 1);\n\tvec3 right = -cross(fd,up);\n\t\n\tfloat fov=1.8;\n\tvec3 rd = normalize(right*uv.x + up*uv.y + fd*fov);\t// Ray dir \n\t\n\tvec3 p = ro;\t\t\t\t\t// Current test position\n\tfloat d;\t\t\t\t\t// Distance of p from surface\n\tfor(int i=0; i<128; i++) {\n\t\td = h(p);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tp += rd * d;\t\t\t\t// March along!\n\t}\n\t\n    \n    \n    \n    \n\tif (d < .001) {\t\t\t\t\t// We hit something!\n\t\t//vec3 lp = vec3(10,10,-10);\t\t// Light position\n        //vec3 lp = vec3(0.5,5.,-10);\t\t// Light position\n        vec3 lp = vec3(0.0,5.,iTime);\t\t// Light position\n        \n\t\tvec3 ld = normalize(lp-p);\t\t// Light direction\n\t\tvec3 n = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse = dot(n,ld);\t\t// Diffuse amount\n\t\tvec3 c = vec3(.8,.9,1) * diffuse * AO(p,n) * SH(p,ld);\n\t\t\n\t\n        \n        vec3 lp1 = vec3(10.0,1.,iTime-5.0);\t\t// Light position\n        \n\t\tvec3 ld1 = normalize(lp1-p);\t\t// Light direction\n\t\tvec3 n1 = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse1 = dot(n1,ld1);\t\t// Diffuse amount\n\t\tvec3 c1 = vec3(.3,.5,.8) * diffuse1 * AO(p,n1) * SH(p,ld1);\n\t\t\n\t\tfragColor =( vec4(c, 1)+vec4(c1, 1))/1.5;\n        \n        \n        \n\t} else\t\t\t\t\t\t// We fucking hit NOTHING\n\t\tfragColor = vec4(uv.x / 2., uv.y * 1.4, 1, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttt3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 40, 40, 74], [77, 77, 97, 97, 113], [115, 115, 138, 138, 163], [201, 218, 251, 251, 316], [319, 337, 375, 375, 444], [445, 460, 491, 491, 641], [642, 662, 698, 698, 785], [786, 802, 834, 862, 923], [926, 936, 972, 972, 1245], [1247, 1296, 1342, 1342, 1374], [1376, 1376, 1418, 1418, 1450], [1452, 1452, 1499, 1499, 1532], [1535, 1535, 1564, 1564, 1690], [1692, 1801, 1838, 1838, 1873], [1877, 1913, 1930, 1930, 2885], [2887, 2887, 2911, 2911, 3038], [3040, 3040, 3064, 3097, 3265], [3267, 3267, 3292, 3362, 3545], [3547, 3547, 3604, 3604, 5079]]}
{"id": "tttGDs", "name": "Gold and Silver", "author": "DarrenHillmann", "description": "Modified from Edapx", "tags": ["vectorfield"], "likes": 3, "viewed": 57, "published": "Public", "date": "1578021130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modified version of 10092018 by Edapx\n// https://www.shadertoy.com/view/llVyWw\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 vectorField(vec2 uv){\n  vec2 res = uv;\n  float n = noise(res*vec2(3.0));\n  res.y -= iTime*0.01;\n  res += sin(res.yx*40.) * 0.02;\n  res += vec2(n);\n  return res;\n}\n\nfloat plot(float val, float c, float t){\n  float l = smoothstep(c,c-t,val);\n  float r = smoothstep(c,c-t/5.,val);\n  return r-l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec4 m = iMouse / iResolution.xxxx;\n  vec2 st = fragCoord/iResolution.xy;\n  st.y *= iResolution.y / iResolution.x;\n  st = vectorField(st);\n\n  float cell = 0.2 + m.y*0.03;\n  vec2 modSt = mod(st, vec2(cell));\n\n  float x = plot(modSt.x, cell, 0.08); //.1\n  float y = plot(modSt.y, cell, 0.47); //.1\n  // orig bgCol 0.1, 0.9, 0.9\n  // orig col 0.9, 0.5, 0.03\n  // orig 0.95, 0.3, 0.\n  // 1.7, .01\n  vec3 bgCol = vec3(.0,.0,.0);\n  vec3 col = vec3(0.75,0.75,0.75) * x;\n  col     += vec3(0.83,0.69,0.22) * y;\n  col     += bgCol*vec3(smoothstep(1.7, .01,x+y));\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 96, 123, 123, 240], [242, 329, 355, 355, 871], [873, 873, 899, 899, 1040], [1042, 1042, 1082, 1082, 1171], [1173, 1173, 1229, 1229, 1816]]}
{"id": "tttSRH", "name": "Fitting Arc using Bézier 2", "author": "harry7557558", "description": "Cubic version see there: [url]https://www.shadertoy.com/view/wly3WG[/url]\nThese fitting functions are used to convert ellipse arcs in an SVG path into uniform bezier curve, because I don't want to write hundreds of lines of code specifically for ellipses.", "tags": ["bezier", "circle", "arc", "fitting", "leastsquare"], "likes": 2, "viewed": 82, "published": "Public", "date": "1580425863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tFitting an unit arc using a quadratic bezier curve\n\tCubic version: https://www.shadertoy.com/view/wly3WG\n\n\tAs one can see, cubic fitting is much better than quadratic fitting.\n\n    Since rendering quadratic is much faster than cubic, fitting the arc/ellipse\n    using multiple quadratic bezier curves is still better. It's not easy to notice \n    the C0 continuety.\n\n*/\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\nstruct Bezier2{\n    vec2 A, B, C;\n};\n\n\n// ========================= Fitting Code =========================\n\n\n#if 0\n\n// along the tangent\nvoid fitArc(in float theta, out Bezier2 R) {\n    float c = cos(theta), s = sin(theta);\n    float k = theta==0.0 ? 0.0 : (1.0 - c) / s;\n    R.A = vec2(1.0, 0.0), R.B = vec2(1.0, k), R.C = vec2(c, s);\n}\n\n#else\n\n// least square, let the control point be k*(cos(θ/2),sin(θ/2))\nvoid fitArc(in float theta, out Bezier2 R) {\n    // derivative of error: error'=ax³+bx²+cx+d\n    // thanks https://www.integral-calculator.com/ for helping me integrate that disgusting function!\n    float alpha = 0.5 * theta;\n\tfloat s1 = sin(alpha), s2 = s1 * s1, s4 = s2 * s2, s6 = s4 * s2,\n\t\tc1 = cos(alpha), c2 = c1 * c1, c3 = c2 * c1, c4 = c3 * c1, c5 = c4 * c1, c6 = c4 * c2, c7 = c5 * c2;\n    float a = 32.*s4+64.*c2*s2+32.*c4,\n        b = (60.*c1*s4+(120.*c3+60.*c1)*s2+60.*c5+60.*c3) / a,\n        c = (20.*s6+(100.*c2-16.)*s4+(140.*c4+32.*c2-148.)*s2+60.*c6+48.*c4-108.*c2) / a,\n        d = (35.*c1*s6+(105.*c3-5.*c1)*s4+(105.*c5+10.*c3-131.*c1)*s2+35.*c7+15.*c5-111.*c3-91.*c1) / a;\n    // calculate the minima (zero derivative), solve a the cubic function\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b / 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tfloat k = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5 * _13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    // apply the solution of the equation to the control points\n    R.A = vec2(1.0, 0.0), R.B = k * vec2(c1, s1), R.C = vec2(c1*c1-s1*s1, 2.0*c1*s1);\n}\n\n#endif\n\n\n\n// ========================= Rendering Code =========================\n\n\n// quadratic bezier distance approximation by tayholliday: https://www.shadertoy.com/view/XsX3zf\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t);\n}\nfloat sdBezier2(in Bezier2 R, in vec2 p) {\n  return length(get_distance_vector(R.A-p, R.B-p, R.C-p));\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-0.5*res)/length(res);\n    float h = 0.2*length(res); \t// hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x);\n    if (ang<0.0) ang += 2.0*PI;\n    float a = sin(0.6*iTime); a=1.8*PI*a*a;\n    int n = int(abs(a)/1.5) + 1;\n    float da = a / float(n);\n    if (iMouse.z>0.0){\n        vec2 d = iMouse.xy-0.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    \tif (a<0.0) a += 2.0*PI;\n        n=1, da=a;\n    }\n\n    // axis\n    vec2 axis = clamp(h*(abs(p)-0.02),0.0,1.0);\n    float bk = min(axis.x,axis.y);\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),bk);\n\n    // circle\n    float circ = clamp(h*(abs(length(p)-1.0)-0.02),0.0,1.0);\n    vec3 c = (ang<a)?vec3(1,0,0):vec3(0.7);\n    c = mix(c,bkg,circ);\n\n    // bezier curve\n    Bezier2 R;\n    fitArc(da, R);\n    if (ang<a){\n        float t = mod(ang,da);\n        vec2 q = length(p)*vec2(cos(t),sin(t));\n    \tfloat d = sdBezier2(R,q);\n    \tc = mix(vec3(0),c,clamp(h*(d-0.01),0.0,1.0));\n    }\n\n    // control points\n    float d = length(p-R.B)-0.04;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.002),0.0,1.0));\n    d = min(length(p-R.A),length(p-R.C))-0.05;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.005),0.0,1.0));\n\n    col = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2137, 2234, 2261, 2261, 2287], [2288, 2288, 2341, 2341, 2701], [2702, 2702, 2744, 2744, 2805], [2807, 2807, 2848, 2848, 4155]]}
{"id": "tttXR8", "name": "Highly suspicious", "author": "samhattangady", "description": "The blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. \n\nOn Android chrome, (and maybe other platforms), eyes are not \nrendering correctly. They move along with the light, and not with\nthe head. Any guidance", "tags": ["3d", "animation", "face"], "likes": 4, "viewed": 314, "published": "Public API", "date": "1580407579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nday004: \n30 Jan 2020\n\nThe blending led to this. Simplest emotion I could think of.\nNeed to work on the lighting in the eyes. Want to make that\na little more \"glossy\"? Also shadows may help.\n\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    \n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n    \n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\n\nfloat smin(float d1, float d2, float k) {\n    //float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    //return -log2( res )/k;\n    \n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {  \n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nfloat pow5Timing(float i) {\n\tfloat cosPiCycle = -1.0 + 2.0*step(0.0, cos(i*3.14159));\n    float sin2PiCycle = -1.0 + 2.0*step(0.0, sin(i*3.14159*2.0));\n    float pow5 = 1.0 - (pow(fract(i*2.0*sin2PiCycle), 6.0));\n    return pow5 * cosPiCycle;\n}\n\nvec4 faceField(vec3 position) {\n    float animTime = sin(iTime*1.8);\n    float lagAnimTime = sin((iTime-0.1)*1.8);\n    //float posTiming = (abs(animTime) / animTime) * abs(pow(animTime, 0.4));\n    //float lagTiming = (abs(lagAnimTime) / lagAnimTime) * abs(pow(lagAnimTime, 0.4));\n    \n    float speedUp = 0.6;\n    float posTiming = pow5Timing(iTime*speedUp);\n    float lagTiming = pow5Timing((iTime-0.1)*speedUp);\n    position = rotate3D(position, vec3(-0.1+(abs(lagTiming)*0.1), 0.0+(0.13*lagTiming), 0.0));\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    \n    float d = sdfSphere(position, vec3(0.0), 0.55);\n    float d1 = sdfSphere(position, vec3(0.0, -0.55, -.15), 0.4);\n    d = smin(d, d1, 0.5);   \n    // brow\n    d1 = sdfEllipsoid(position, vec3(0.0, 0.04, -0.35), vec3(0.35, 0.2, 0.2));\n    d = smin(d, d1, 0.1);\n    // eye socket\n    d1 = sdfSphere(symPosX, vec3(0.4, -0.08, -.55), 0.1);\n    d = smax(d, -d1, 0.3);\n    \n    \n    // right eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(-0.15, 0.03+(0.05*lagTiming), -0.535+(0.015*lagTiming)), vec3(0.5, 0.0, 1.75), 0.2-(0.05*lagTiming), 0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    // left eyebrow\n    d1 = sdfJoint3DSphere(position, vec3(0.15, 0.03-(0.05*lagTiming), -0.535-(0.015*lagTiming)), vec3(0.5, 0.0, -1.75), 0.2+(0.05*lagTiming), -0.4, 0.01).x;\n    d = smin(d, d1, 0.2);\n    \n    \n    // bottom eyebrow?\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.2, -0.25, -0.48), vec3(0.52, 0.0, -1.95), 0.15, -0.4, 0.001).x;\n    d = smin(d, d1, 0.22);\n    \n    \n    // nose\n    d1 = sdfEllipsoidRotated(position, vec3(0.0, -0.28, -0.55), vec3(0.07, 0.15, 0.1), vec3(3.14159/4.0, 0.0, 0.0));\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.28, -0.49), vec3(0.03, 0.19, 0.1), vec3(3.14159/6.0, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    \n    // eye\n    d1 = sdfSphere(symPosX, vec3(0.18, -0.12, -.38), 0.2);\n    if (d1 < d) {\n    \td = d1;\n        material = 2.0;\n    }\n    // iris\n    vec3 irisPos = position;\n    irisPos.x += posTiming * 0.06;\n    d1 = sdfSphere(irisPos, vec3(0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    d1 = sdfSphere(irisPos, vec3(-0.23, -0.12, -0.545), 0.06);\n    if (d1 < d) {\n    \td = d1;\n        material = 3.0;\n    }\n    return vec4(d, material, 0.0, 0.0);\n}\n\nvec4 distanceField(vec3 position) {\n\tvec4 d = faceField(position);\n    return d;\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x \n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = 0.0;\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;    \n    planePosition.xz = camRotate * planePosition.xz;    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    //lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.4* smoothstep(0.3, 1.0, light);\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.55, 0.55, 0.65);\n            color += 0.3 * smoothstep(0.5, 1.0, light);\n            color += 0.7 * pow(light, 15.0);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.01);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 197, 239, 239, 684], [686, 686, 745, 745, 795], [796, 796, 856, 856, 995], [996, 996, 1078, 1078, 1259], [1261, 1261, 1302, 1302, 1354], [1355, 1355, 1448, 1448, 1626], [1628, 1628, 1648, 1648, 1669], [1670, 1670, 1776, 1776, 2448], [2450, 2450, 2491, 2569, 2650], [2651, 2651, 2692, 2692, 2770], [2772, 2772, 2799, 2799, 3016], [3018, 3018, 3049, 3049, 5345], [5347, 5347, 5382, 5382, 5429], [5431, 5431, 5459, 5691, 6005], [6007, 6007, 6050, 6339, 6723], [6725, 6725, 6782, 6825, 8744]]}
{"id": "ttV3Dd", "name": "Marbling", "author": "fabiojcortes", "description": "generative marbling", "tags": ["water", "generative", "marbling"], "likes": 2, "viewed": 227, "published": "Public API", "date": "1580233059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n//noise algorithme from Morgan McGuire\n//https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec2 st){\n  vec2 ist = floor(st);\n  vec2 fst = fract(st);\n\n  //get 4 corners of the pixel\n  float bl = random(ist);\n  float br = random(ist + vec2(1.0, 0.0));\n  float tl = random(ist + vec2(0.0, 1.0));\n  float tr = random(ist + vec2(1.0, 1.0));\n\n  //smooth interpolation using cubic function\n  vec2 si = fst * fst * (3.0 - 2.0 * fst);\n\n  //mix the four corner to get a noise value\n  return mix(bl, br, si.x) +\n         (tl - bl) * si.y * (1.0 - si.x) +\n         (tr - br) * si.x * si.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = 18.0 * fragCoord / iResolution.xy;\n\n  float angle = sin(0.1*iTime);\n  float c = cos(angle);\n  float s = sin(angle);\n  p *= mat2(c, -s, s, c);\n\n  for(int n = 1; n < 30; n++){\n    float i = float(n);\n    p += vec2(0.8/ i * sin(i * p.y + iTime + 0.3 * i) + 0.8, 0.4 /i * sin(i*p.x + iTime + 2.3 * i) + 1.6);\n  }\n\n  p -= vec2(0.5 / cos(p.x + iTime + 0.3) + 0.8, 0.4 / cos(p.y + iTime + 0.3) + 1.6);\n  // vec3 col = vec3(0.1 * sin(p.x) + 0.2, 0.5 * sin(p.y) + 0.2, sin(p.x));\n  vec3 col = vec3(noise(p), cos(p.y), sin(p.x+0.3) );\n\n  // col *= 0.9;\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 96], [98, 177, 198, 198, 677], [679, 679, 736, 736, 1323]]}
{"id": "ttV3Dt", "name": "Tokamak", "author": "lucasassone", "description": "Inside the Tokamak, use mouse (with button pressed) to look around", "tags": ["raymarching", "mouse"], "likes": 4, "viewed": 223, "published": "Public API", "date": "1580222789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 rotate(vec3 p, float angle, vec3 axis){\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nconst float THRESHOLD = 0.0001;\nconst float maiorRadius = 5.0;\nconst float minorRadius = 3.0;\n\n// --------------------------------------------------------------------------\n\n// distance estimators\nfloat torusDist(vec3 p) {\n\tfloat f1 = min(abs(0.3 * sin(10.0 * atan(p.z, p.x))), 0.1);\n\tvec2 uv = vec2(-atan(p.z, p.x), atan(p.y, length(p.xz) - maiorRadius)) / 2.0 / 3.141592 + 0.5;\n\tfloat f2 = max(sin(200. * uv.x) * sin(200. * uv.y) - 0.95, 0.0);\n\tfloat dis1 = minorRadius - (f1 + f2) - length(vec2(length(p.xz) - maiorRadius, p.y));\n\treturn dis1;\n}\n\nfloat tubesDist(vec3 p) {\n\tfloat d1 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y - 1.3)) - 0.2;\n\tfloat d2 = length(vec2(length(p.xz) - (maiorRadius + minorRadius - 0.5), p.y + 1.3)) - 0.2;\n\tfloat d3 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 0.6), p.y + 1.5)) - 0.2;\n\tfloat d4 = length(vec2(length(p.xz) - (maiorRadius - minorRadius + 1.0), p.y + 2.0)) - 0.2;\n\treturn min(min(d1, d2), min(d3, d4));\n}\n\nfloat floorDist(vec3 p) {\n\treturn p.y + 2.7;\n}\n\nfloat ceilDist(vec3 p) {\n\tfloat f = max(sin(10. * atan(p.z, p.x)) - 0.6, 0.0);\n\tfloat d1 = length(vec2(length(p.xz) - maiorRadius + 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\tfloat d2 = length(vec2(length(p.xz) - maiorRadius - 1.0, p.y - minorRadius - 2.0)) - 2.5 - f;\n\treturn min(d1, d2);\n}\n\nfloat protonsDist(vec3 p) {\n\tvec3 p1 = rotate(p, 10.0 * iTime, vec3(0., 1., 0.));\n\tfloat d1 = length(vec2(length(p1.xz) - maiorRadius, p1.y + 0.0)) - 0.1 * (sin(0.5 * atan(p1.z, p1.x)) + 1.0);\n\treturn d1;\n}\n\nfloat sceneDist(vec3 p) {\n\tfloat v = min(min(torusDist(p), tubesDist(p)), min(floorDist(p), ceilDist(p)));\n\treturn min(v, protonsDist(p));\n}\n\n// --------------------------------------------------------------------------\n\nvec3 torusColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 floorColor(vec3 p) {\n\treturn vec3(max(sin(50.0 * p.x) - 0.5, 0.0) + max(sin(50.0 * p.z) - 0.5, 0.0));\n}\n\nvec3 ceilColor(vec3 p) {\n\treturn vec3(0.9, 0.9, 1.0);\n}\n\nvec3 tubesColor(vec3 p) {\n\treturn vec3(0.8, 0.9, 1.0);\n}\n    \n// --------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( gl_FragCoord.xy * 2. - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec2 mo = iMouse.xy / iResolution.xy - 0.5;\n\n\tvec3 cameraPos = vec3(0., -0.5, -7.);\n\tfloat screenZ = 2.0;\n\tvec3 rayDirection = normalize(vec3(p, screenZ));\n\n\trayDirection = rotate(rayDirection, -0.05, vec3(0., 0., 1.));\n\n\trayDirection = rotate(rayDirection, 2. * mo.x, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, 2. * mo.y, vec3(1., 0., 0.));\n\n\tcameraPos = rotate(cameraPos, iTime, vec3(0., 1., 0.));\n\trayDirection = rotate(rayDirection, iTime, vec3(0., 1., 0.));\n\n\tfloat depth = 0.0;\n\tvec3 col = vec3(1.0);\n\tvec3 rayPos;\n\n\t// ray marching\n\tint i = 0;\n\tfor (i = 0; i < 99; i++) {\n\t\trayPos = cameraPos + rayDirection * depth;\n\t\tfloat dist = sceneDist(rayPos);\n\t\tif (dist < THRESHOLD) {\n\t\t\tif      (torusDist(rayPos) < THRESHOLD) col = torusColor(rayPos);\n\t\t\telse if (floorDist(rayPos) < THRESHOLD) col = floorColor(rayPos);\n\t\t\telse if (ceilDist(rayPos)  < THRESHOLD) col = ceilColor(rayPos);\n\t\t\telse if (tubesDist(rayPos) < THRESHOLD) col = tubesColor(rayPos);\n\t\t\tif (protonsDist(rayPos) < THRESHOLD) col = vec3(100.0);\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist;\n\t}\n\n\tcol = col * (1.6 / (1.0 + 0.1 * depth)); // scurisce con la profondita'\n\tcol = 0.1 * col * max(0.3 * float(i), 1.0); // effetto aura (schiarisce all'aumentare di i)\n    col = mix(col, vec3(0.6, 0.5, 1.0), max(1.0 - minorRadius - rayPos.y, 0.0));\n\n\t// luce rossa lampeggiante\n\tfloat f = sin(6. * iTime) * 0.3 + 0.3;\n\tcol = col * vec3(1., 1. - f, 1. - f);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 45, 45, 399], [575, 598, 623, 623, 949], [951, 951, 976, 976, 1389], [1391, 1391, 1416, 1416, 1437], [1439, 1439, 1463, 1463, 1730], [1732, 1732, 1759, 1759, 1938], [1940, 1940, 1965, 1965, 2080], [2082, 2161, 2186, 2186, 2217], [2219, 2219, 2244, 2244, 2327], [2329, 2329, 2353, 2353, 2384], [2386, 2386, 2411, 2411, 2442], [2448, 2527, 2584, 2584, 4157]]}
{"id": "ttV3zd", "name": "Endless Rubber Balls", "author": "jake_r", "description": "I wanted to try deforming a ball as it got close to the ground so I made this! I think using buffers would have made this easier.", "tags": ["circles", "balls", "rubber", "loop", "bouncing"], "likes": 5, "viewed": 113, "published": "Public", "date": "1579664627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ground = -0.42;\nfloat bounciness = 0.7;\nfloat loopLength = 6.;\nfloat bounceFrequency = 8.;\nfloat ballCount = 20.;\nfloat randomSeed = 5.;\n\nvec2 uv; //assigned in main\n\nfloat random(float val){\n \treturn fract(sin(randomSeed+val*219142.349034753957)*54643.624304578);   \n}\nfloat randomT2(float val){\n    return fract(sin(randomSeed+val*4386.48748530579)*95347.206309475);\n}\nfloat randomT3(float val){\n    return fract(sin(randomSeed+val*5432.35609374583759)*26467.557573805);\n}\n\nfloat square(float value){\n\treturn value*value;   \n}\n\n\nfloat ellipse(vec2 position, vec2 size){\n    float t = square(uv.x-position.x)/square(size.x) + square(uv.y-position.y)/square(size.y);\n    return smoothstep(1., 0.9, t);\n}\nfloat bouncingBall(float radius, float bounceWidth, float t){\n    //Bouncing\n    float potentialEnergy = pow(bounciness, t*bounceWidth); //bounciness determines how much energy is lost in each bounce\n    float bounce = abs(sin(t*3.141*bounceWidth))*potentialEnergy; //a sine wave that shortens each half oscillation\n    float bounceOffset = (-radius/2.)*potentialEnergy; //based on potentialEnergy the center can get closer to the ground\n    vec2 currentPos = vec2(-1.2+2.4*t, ground+radius+bounce+bounceOffset);\n    \n    //The ball squishes to never overlap the ground\n    float compression = min(1., abs(ground - currentPos.y)/radius); //distance to ground / radius\n    vec2 deform = vec2(max(1., 1.+0.9*(1.-compression)), min(1., compression)); \n    \n    return ellipse(currentPos, radius*deform);\n}\nvec4 randomBall(float i){\n \tfloat time = mod(iTime + randomT2(i+2.)*loopLength, loopLength)/loopLength; //random offset to avoid overlap, and make them loop\n    \n    i = i+random(floor((iTime + randomT2(i+2.)*loopLength)/loopLength)); //i changes with every loop\n    vec4 randomColor = vec4(random(i+1.), randomT2(i+1.), randomT3(i), 1.);\n    randomColor.rgb = 0.9*randomColor.rgb + 0.1; //lightens it up my making the minimum vec3(0.1)\n    float mask = bouncingBall(random(i)*0.1+0.1, (randomT2(i)*0.75 + 0.25)*bounceFrequency, time);\n    return mask * randomColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy - 0.5;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n\n    vec4 col = vec4(0.);\n    for(float i = 1.; i <= ballCount; i+=1.){\n        col += randomBall(i) * (1.-col.a);\n    }\n    \n    //col += vec4(max(0., 1.-floor(length(uv)+0.995))); //shows the origin\n    col.xyz += vec3(smoothstep(0., 0.01, ground - uv.y)); //the ground\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttV3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 173, 197, 197, 275], [276, 276, 302, 302, 376], [377, 377, 403, 403, 480], [482, 482, 508, 508, 534], [537, 537, 577, 577, 709], [710, 710, 771, 786, 1512], [1513, 1513, 1538, 1538, 2081], [2083, 2083, 2140, 2140, 2559]]}
{"id": "ttVGDD", "name": "Colors Shaded Blob", "author": "Llerd", "description": "blob", "tags": ["blob"], "likes": 2, "viewed": 68, "published": "Public", "date": "1579022780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _PI 3.1415926535897932384626433832795\n\nfloat getAngle(float x, float y)\n{\n    return acos(dot(normalize(vec2(1, -0.5)), normalize(vec2(x, y))));\n}\n\nfloat makePoint(float x, float y, float fx, float fy, float sx, float sy, float t)\n{\n\tfloat xx = x + sin(t * fx) * sx;\n\tfloat yy = y + cos(t * fy) * sy;\n    float a = 1.0 / sqrt(xx * xx + yy * yy);\n\t//a = 0.13 * a * a * a;\n\t//a = 0.35 * a * a;\n    a =  1.5 * sqrt(a);\n    //a = 1.85 * sqrt(sqrt(a));\n    return a;\n}\n\nfloat addBlob(float x, float y, float t)\n{\n    float a = makePoint(x, y, 3.3, 2.9, 0.3, 0.3, t);\n\ta = a + makePoint(x, y, 1.9, 2.0, 0.4, 0.4, t);\n\ta = a + makePoint(x, y, 0.8, 0.7, 0.4, 0.5, t);\n\ta = a + makePoint(x, y, 2.3, 0.1, 0.6, 0.3, t);\n\ta = a + makePoint(x, y, 0.8, 1.7, 0.5, 0.4, t);\n\ta = a + makePoint(x, y, 0.3, 1.0, 0.4, 0.4, t);\n\ta = a + makePoint(x, y, 1.4, 1.7, 0.4, 0.5, t);\n\ta = a + makePoint(x, y, 1.3, 2.1, 0.6, 0.3, t);\n\ta = a + makePoint(x, y, 1.8, 1.7, 0.5, 0.4, t);\n    return a;\n}\n\nvec3 int2rgb(int c)\n{\n\tfloat r = float((c >> 16) & 255) / 255.0f;\n\tfloat g = float((c >> 8) & 255) / 255.0f;\n\tfloat b = float((c >> 0) & 255) / 255.0f;\n\treturn vec3(r, g, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 c1 = int2rgb(0xFFB340);\n\tvec3 c2 = int2rgb(0xFFB340);\n\tvec3 c3 = int2rgb(0xFFFF00);\n\tfloat cutoff = 20.0;\n\tfloat speed = 0.2;\n    float separation = 0.15;\n\n\tvec2 p = 2.0 * ((fragCoord.xy / iResolution.x) * 2.0 - vec2(1.0, iResolution.y / iResolution.x));\n\n\tfloat t = (iTime + 13.0) * speed;\n\n    float x, y;\n\tx = p.x + sin(t * 0.123) * separation;\n\ty = p.y + cos(t * 0.312) * separation;\n\n    float dd = 0.01;\n    float a = addBlob(x, y, t);\n    float a1 = addBlob(x + dd, y, t);\n    float a2 = addBlob(x, y + dd, t);\n\n/*\tx = p.x + sin(t * 0.323) * separation;\n\ty = p.y + cos(t * 0.112) * separation;\n\n    float b = makePoint(x, y, 1.2, 1.9, 0.3, 0.3, t);\n\tb = b + makePoint(x, y, 0.7, 2.7, 0.4, 0.4, t);\n\tb = b + makePoint(x, y, 1.4, 0.6, 0.4, 0.5, t);\n\tb = b + makePoint(x, y, 2.6, 0.4, 0.6, 0.3, t);\n\tb = b + makePoint(x, y, 0.7, 1.4, 0.5, 0.4, t);\n\tb = b + makePoint(x, y, 0.7, 1.7, 0.4, 0.4, t);\n\tb = b + makePoint(x, y, 0.8, 0.5, 0.4, 0.5, t);\n\tb = b + makePoint(x, y, 1.4, 0.9, 0.6, 0.3, t);\n\tb = b + makePoint(x, y, 0.7, 1.3, 0.5, 0.4, t);\n\n\tx = p.x + sin(t * 0.223) * separation;\n\ty = p.y + cos(t * 0.212) * separation;\n\n    float c = makePoint(x, y, 3.7, 0.3, 0.3, 0.3, t);\n\tc = c + makePoint(x, y, 1.9, 1.3, 0.4, 0.4, t);\n\tc = c + makePoint(x, y, 0.8, 0.9, 0.4, 0.5, t);\n\tc = c + makePoint(x, y, 1.2, 1.7, 0.6, 0.3, t);\n\tc = c + makePoint(x, y, 0.3, 0.6, 0.5, 0.4, t);\n\tc = c + makePoint(x, y, 0.3, 0.3, 0.4, 0.4, t);\n\tc = c + makePoint(x, y, 1.4, 0.8, 0.4, 0.5, t);\n\tc = c + makePoint(x, y, 0.2, 0.6, 0.6, 0.3, t);\n\tc = c + makePoint(x, y, 1.3, 0.5, 0.5, 0.4, t);*/\n\n\tvec3 d = vec3(1.0);\n\tif (a > cutoff)\n    {\n\t\td = c1;\n        float f = 2.85 * a / cutoff - 2.0;\n        if (f < 1.0)\n        {\n            float vv = getAngle(a2 - a, a1 - a) / _PI / 2.0;\n        \tfloat aa = 1.0 - clamp(vv, 0.0, 0.25) * 4.0;\n            float vv2 = getAngle(a - a2, a - a1) / _PI / 2.0;\n        \tfloat bb = 1.0 - clamp(vv2, 0.0, 0.25) * 4.0;\n        \t//float bb = (clamp(vv, 0.5, 0.75) - 0.5) * 4.0 * 1.0;\n            f = 1.0 - f;\n            d *= 1.0f - 4.0 * aa *aa * f;\n            d += bb * bb * f;\n        }\n        \n        //d *= clamp(2.7 * a2 / cutoff - 2.0, 0.0, 1.0);\n    }\n\n\tvec3 as = clamp(d, vec3(0), vec3(1));\n\td = as;\n\t//d=hsv2rgb(as);\n\t//vec3 d = hsv2rgb(e);\n\n\tif (as == vec3(0))\n\t\tfragColor = vec4(1.0);\n\telse\n\t\tfragColor = vec4(d.x, d.y, d.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 81, 81, 154], [156, 156, 240, 240, 471], [473, 473, 515, 515, 977], [979, 979, 1000, 1000, 1155], [1157, 1157, 1212, 1212, 3585]]}
{"id": "ttVGDh", "name": "Colorful Waves", "author": "ju", "description": "Colorful Waves", "tags": ["2d"], "likes": 17, "viewed": 465, "published": "Public API", "date": "1578857032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define WAVES 8.\n\nfloat wavePosition(vec2 uv, float i) {\n    return sin((uv.x + i * 8.456) * (sin(iTime * 0.1 + 7.539 + i * 0.139) + 2.) * 0.5) * 0.65\n        + sin(uv.x * (sin(iTime * 0.1 + i * 0.2) + 2.) * 0.3) * 0.3\n        - (i - WAVES / 2.) * 2. - uv.y;\n}\n\n// http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 colorPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(PI * 2. * (c * t + d));\n}\nvec3 color(float x) {\n    return colorPalette(x, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2., 1., 0.), vec3(0.5, 0.2, 0.25));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 waveUv = (2. * fragCoord - iResolution.xy) / iResolution.y * (WAVES - 1.);\n\n    float aa = WAVES * 2. / iResolution.y;\n\n    for (float i = 0.; i < WAVES; i++) {\n        float waveTop = wavePosition(waveUv, i);\n        float waveBottom = wavePosition(waveUv, i + 1.);\n\n        vec3 col = color(i * 0.12 + uv.x * 0.2 + iTime * 0.02);\n\n        col += smoothstep(0.3, 0., waveTop) * 0.05;\n        col += (1. - abs(0.5 - smoothstep(waveTop, waveBottom, 0.))) * 0.06;\n        col += smoothstep(-0.3, 0., waveBottom) * -0.05;\n\n        fragColor.xyz = mix(fragColor.xyz, col, smoothstep(0., aa, waveTop));\n    }\n\n    fragColor.w = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 81, 81, 285], [287, 347, 407, 407, 456], [457, 457, 478, 478, 590], [592, 592, 647, 647, 1328]]}
{"id": "ttVGDz", "name": "HSV pallete", "author": "victorcesaroni", "description": "HSV pallete", "tags": ["hsv", "pallete"], "likes": 1, "viewed": 40, "published": "Public", "date": "1579172628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    return c.z*mix(vec3(1),max(abs(mod(c.x/60.+vec3(0,4,2),6.)-3.)-1.,0.),c.y);\n}\n\nconst float PI = 3.1315;\n\nfloat rad2deg(float a) {\n    return a/PI*180.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord)/iResolution.xy;\n    \n    float anim = mod(iTime*0.1f,1.);\n    \n    vec3 col = hsv2rgb(vec3(rad2deg((uv.x+anim)*2.*PI),uv.y,1.f));\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 109], [137, 137, 161, 161, 185], [187, 187, 244, 244, 434]]}
{"id": "tty3Wc", "name": "Fractal Spiral Mapping", "author": "zovox", "description": "2-dimensional spiral mapping of a Julia set fractal.", "tags": ["fractal", "spiral", "mapping"], "likes": 2, "viewed": 200, "published": "Public API", "date": "1580063614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nfloat draw(vec2 p)\n{\n    \n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scale = 2.0*PI;\n    uv *= scale;\n    uv -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv = spiral(uv*scale);\n    uv = spiral(uv);\n   fragColor = vec4(draw(saw(uv*1.0*PI)*2.0-1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 70, 70, 102], [103, 103, 121, 121, 153], [155, 155, 177, 177, 351], [353, 353, 373, 396, 970], [972, 972, 1029, 1029, 1333]]}
{"id": "tty3z1", "name": "eindacor_harmonics_01", "author": "Eindacor_DS", "description": "harmonics test", "tags": ["harmonics"], "likes": 2, "viewed": 80, "published": "Public", "date": "1578319207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float normalizeSin(float sinValue)\n{\n  \treturn (sinValue + 1.) / 2.;  \n}\n\nstruct harmonicSettings\n{\n    float rowCount; \t\t\t\t\t\t// number of vertical divisions\n    float cycleTime; \t\t\t\t\t\t// duration for the sync of all rows\n    float oscillationsPerCycleOfSlowest;  \t// oscillations of the slowest band per cycle\n    float thickness;\t\t\t\t\t\t// thickness of horizontal bands\n    bool showThickness;\n    bool showShade;\n    bool showMirror;\n};\n    \nvec3 getColor(harmonicSettings settings, vec2 uv)\n{\n    float rowIndex = floor(uv.y * settings.rowCount);    \n    float oscillations = settings.oscillationsPerCycleOfSlowest + rowIndex;\n    \n    float period = settings.cycleTime / oscillations; \n    \n    float twoPiR = 6.28318531;\n     \n    if (settings.showThickness)\n    {\n    \tsettings.thickness = settings.thickness * (1. - 2. * abs(uv.x - .5));\n    }\n     \n    // normalizes -1,1 sin values to 0,1\n    float xPos = (sin(twoPiR * iTime / period) + 1.) / 2.;\n    \n    float baseColorVal = .25;\n    vec3 color = vec3(baseColorVal);\n    \n    bool mask = false;\n    \n    if (abs(xPos - uv.x) < settings.thickness)\n    {\n        color.r += (1. - baseColorVal);\n        mask = true;\n    }\n    \n    if (settings.showMirror && abs(xPos - (1. - uv.x)) < settings.thickness)\n    {\n        color.b += (1. - baseColorVal);\n        mask = true;\n    }\n    \n    if (mask)\n    {\n     \tcolor.g = uv.y;   \n    }\n     \n    if (settings.showThickness && settings.showShade && mask)\n    {    \n        float minShade = .25;\n        float halfShade = 1. - ((1. - minShade) / 2.);\n        \n        float minShadeLocal, maxShadeLocal, centerValue;\n        \n        // background       \n        if (cos(twoPiR * iTime / period) < 0.)\n        {\n            minShadeLocal = minShade;\n            maxShadeLocal = halfShade;\n            centerValue = 1. - cos(twoPiR / 2. * (abs(uv.x - .5)));\n        }   \n        else // foreground\n        {\n            minShadeLocal = halfShade;\n            maxShadeLocal = 1.;\n            centerValue = cos(twoPiR / 2. * (abs(uv.x - .5)));\n        }\n        \n        float shadeValue = mix(minShadeLocal, maxShadeLocal, centerValue);\n        \n        color *= shadeValue;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // settings: rowCount, cycleTime, oscillations, thickness, showThickness, shade, mirror\n    harmonicSettings preset00 = harmonicSettings(8., 20., 4., .25, true, true, true);  \n    harmonicSettings preset01 = harmonicSettings(40., 120., 30., .25, true, true, true);\n    harmonicSettings preset02 = harmonicSettings(120., 120., 10., .25, true, true, true);\n    harmonicSettings preset03 = harmonicSettings(200., 120., 10., .25, false, true, false);\n    harmonicSettings preset04 = harmonicSettings(120., 240., 10., .02, true, true, true);\n    harmonicSettings preset05 = harmonicSettings(12., 1200., 10., .4, true, true, true);\n    \n    vec3 color = getColor(preset02, uv);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [443, 443, 494, 494, 2207], [2209, 2209, 2266, 2266, 3020]]}
{"id": "tty3zh", "name": "First landscape", "author": "olealgo", "description": "shadertoy fun. Learning the basics. Thanks to artOfCode for being a great tutor!", "tags": ["shading"], "likes": 6, "viewed": 71, "published": "Public", "date": "1578759670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* artOfCode is the best tutor :-) \n*\n*/\n\n#define S(a, b, t) smoothstep(a,b,t)\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n    float m = S(-blur, blur, p.y-yb);\n    m *= S(blur, -blur, p.y-yt);\n    \n    p.x = abs(p.x);\n    \n    // 0 when p.y=yb and 1 when p.y=yt\n    \n    float w = mix(wb, wt, (p.y-yb)/ (yt-yb)); \n    m *= S(blur, -blur, p.x-w);\n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur) {\n\n    float m = TaperBox(uv, .03, .03, -.05, .25, blur); // bottom\n   \tm += TaperBox(uv, .15, .05, .25, .5, blur); // first tapered element\n    m += TaperBox(uv, .15, .05, .5, .75, blur); // first tapered element\n    m += TaperBox(uv, .1, .01, .75, 1., blur); // first tapered element\n   \n    float shadow = TaperBox(uv-vec2(0.2,0), .1, .5, .15, .25, blur);\n    shadow += TaperBox(uv-vec2(0.25,0), .1, .5, .45, .5, blur);\n    shadow += TaperBox(uv-vec2(0.25,0), .1, .5, .7, .75, blur);\n    \n    \n    col -= shadow;\n    return vec4(col, m);\n}\n\nfloat GetHeight(float x) {\nreturn sin(x*.423)+sin(x)*.3;\n\n}\n\nvec4 Layer(vec2 uv, float blur) {\n    // Fixed pixel color\n    vec4 col = vec4(0);\n    \n    float id = floor(uv.x);\n    float n = fract(sin(id*234.12)*5422.3)*2.-1.; // between 0-1 fractions\n\tfloat x = n*.3;\n    float y = GetHeight(uv.x); \n    float ground = S(blur, -blur, uv.y+y); // ground\n    col += ground;\n    \n    y = GetHeight(id+.5+x);\n    \n    uv.x = fract(uv.x)-0.5;\n    \n \n    vec4 tree = Tree((uv-vec2(x, -y))*vec2(1,1.+n*.2), vec3(0.3), blur);\n    //col.rg = uv;\n    \n    col = mix(col, tree, tree.a);\n    col.a = max(ground, tree.a);\n    return col;\n\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.25,754.34));\n    p += dot(p, p+478.23);\n    return fract(p.x*p.y);\n}\n\nvec4 TwinkleStarLayer(vec2 uv, float t) {\n    vec4 col = vec4(0);\n    // Create snow / stars / contrast pixels\n    float twinkle = dot(length(sin(uv+t*3.)), length(cos(uv*vec2(22.,6.7)-t*3.)));\n    //twinkle = sin(twinkle*10.)*.5+.5;\n    \n    float stars = pow(Hash21(uv), 1000.) * twinkle; // Functions that returns between 1 and 2 + add twinkle\n    col += stars * 13.;\n   \n    // show twinkle in front\n    //col += twinkle;   \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    \n    vec2 Mouse = (iMouse.xy / iResolution.xy)*2.-1.;\n\n    //uv.x += iTime*.1;\n    // zoom out\n    //uv *=2.0; \n   \n    \n    float t = iTime *.3;\n\n    float blur = 0.005;\n\n    // black\n    vec4 col = vec4(0);\n    \n    \n    // stars = first layer\n    vec4 stars = vec4(TwinkleStarLayer(uv, t));\n    col += stars;\n    \n    \n    float moon = S(.35, .0003, length(uv-vec2(.15, .005)) -.05);\n    //moon *= S(.3, .15, length(uv-vec2(.001,.001)));\n    \n    col += moon;\n    \n    vec4 layers;\n    \n    \n    // Create several layers\n    for(float i=0.; i < 1.; i+= 1./5.) {\n    \t\n        float scale = mix(30., 1., i);\n        blur = mix(.09, .005, i);\n        layers = Layer(uv*scale+vec2(t+i*100., i)-Mouse, blur);\n        layers.rgb *= (1.-i)*vec3(.3,.7,.8);\n        \n        col = mix(col, layers, layers.a);\n    }\n    \n    layers = Layer(uv+vec2(t*0.5, 1)-Mouse, .025);\n    \n    col = mix(col, layers*.1, layers.a);\n\n    \n    //  coordinate axis X + Y\n    //  float thickness = 1./iResolution.y;\n \t//  if (abs(uv.x) < thickness) col.g = 1.;\n \t//  if (abs(uv.y) > thickness) col.r = 1.;\n    \n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 158, 158, 398], [400, 400, 442, 442, 983], [985, 985, 1011, 1011, 1044], [1046, 1046, 1079, 1104, 1613], [1615, 1615, 1637, 1637, 1731], [1733, 1733, 1774, 1774, 2184], [2186, 2186, 2243, 2293, 3496]]}
{"id": "tty3zR", "name": "my first working raymarcher", "author": "izutionix", "description": "following along ray marching for dummies by The Art of Code: https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 65, "published": "Public", "date": "1578086990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = max(dot(n, l), 0.);\n    float d = RayMarch(p+n*SURF_DIST*2., vec3(l));\n    if(d<length(lightPos-p)) dif *= .02;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tty3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 260], [262, 262, 296, 296, 505], [507, 507, 531, 531, 723], [725, 725, 749, 749, 1055], [1057, 1057, 1114, 1114, 1457]]}
{"id": "ttyGR1", "name": "Learning Code [7]", "author": "ozu", "description": "More: you can just apply some sin or saw function to radial distance.", "tags": ["sin"], "likes": 2, "viewed": 59, "published": "Public", "date": "1578259057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 *iResolution.xy) / iResolution.y;\n    float col = 0.;\n    float d = length( uv )   ;\n    float blur = 1.5/iResolution.y;\n\n    d = sin(d*300. - iTime * 3.) * .5 + .5;\n\n    col = smoothstep(blur * 150., 0., d );\n    \n    fragColor = vec4(vec3(col),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340]]}
{"id": "ttyGWc", "name": "Clockwork Chaos", "author": "zovox", "description": "Reminds me of chaotic clockwork.", "tags": ["chaos", "clockwork"], "likes": 2, "viewed": 507, "published": "Public API", "date": "1580063486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S 83.0\n#define D 68.0\n#define C 67.0\n#define T 84.0\n#define Y 89.0\n#define F 70.0\n\n#define SDCTYF (S+D+C+T+Y+F)\n#define PI 3.14159265359\n\n#define jitter ((tan(iTime)+iTime*10.0)/10.0)\n//#define iTime ((tan(iTime)+iTime*10.0)/10.0)\n#define iTime iTime*.5\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  c = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  d = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, c.yyy) );\n  vec3 x0 =   v - i + dot(i, c.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + c.xxx;\n  vec3 x2 = x0 - i2 + c.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - d.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * d.wyz - d.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float count = 7.0+cos(iTime)*5.0;\n    \n\tfloat sum = 0.;\n    \n    for(float i = 0.0; i < 100.0; i+=1.0)\n    {\n        if(i > count)\n            break;\n        \n        float theta = float(i)/float(count)*PI*2.0+iTime;\n        vec2 p1 = vec2(cos(theta), sin(theta))*.75;\n        \n        float radialCount = 7.0+cos(iTime/PI)*5.0;\n        \n        for(float j = 0.0; j < 100.0; j+=1.0)\n        {\n        \tfloat theta2 = float(j)/float(radialCount)*PI*2.0-iTime*2.0;\n            vec2 p2 = p1+vec2(cos(theta2), sin(theta2));\n\n            if(j > radialCount)\n                break;\n            \n            float d = \n                    (p2.y-p1.y)*uv.x-\n                    (p2.x-p1.x)*uv.y+\n                    p2.x*p1.y-p2.y*p1.x/\n                    length(p2-p1);\n            float maxd = 10./max(iResolution.x,iResolution.y);\n            \n            if(abs(d) < maxd)\n            {\n                sum += (cos(d/maxd*PI/2.0));\n            }\n        }\n    }\n    fragColor = vec4((cos(iTime*PI+length(uv.xy)*PI+sum*PI/2.+vec3(0., 4.*PI/3.,2.*PI/3.))*.5+.5)*clamp(sum,0., PI), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 262, 283, 283, 332], [334, 334, 355, 355, 404], [406, 406, 428, 428, 468], [470, 470, 498, 498, 550], [552, 552, 576, 576, 2720], [2722, 2722, 2779, 2779, 3964]]}
{"id": "ttyGWh", "name": "Psychedelic Mind Blood", "author": "Nightmare", "description": "Neon Light Psychedelic", "tags": ["mindneon"], "likes": 1, "viewed": 262, "published": "Public API", "date": "1578778060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 UV = fragCoord.xy / iResolution.xy;\n    \n    float XRed = pow(abs((-UV.x + 0.5) * abs(sin(iTime))), 0.5);\n    float YRed = pow(abs((-UV.y + 0.5) * abs(sin(iTime))), 0.5);\n    \n    float XRedB = pow(abs((-UV.x + 0.25) * abs(sin(iTime))), 0.5);\n    float YRedB = pow(abs((-UV.y + 0.25) * abs(sin(iTime))), 0.5);\n    \n    float XRedC = pow(abs((-UV.x + 0.75) * abs(sin(iTime))), 0.5);\n    float YRedC = pow(abs((-UV.y + 0.75) * abs(sin(iTime))), 0.5);\n    \n    \n    float XBlue = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 8.0))), 0.5);\n    float YBlue = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 8.0))), 0.5);\n    \n    float XBlueB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 8.0))), 0.5);\n    float YBlueB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 8.0))), 0.5);\n    \n    float XBlueC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 8.0))), 0.25);\n    float YBlueC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 8.0))), 0.25);\n    \n    float XGreen = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreen = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float XGreenB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreenB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float XGreenC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 16.0))), 0.25);\n    float YGreenC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 16.0))), 0.25);\n    \n    float FinalRedX = XRed * XRedB * XRedC;\n    float FinalRedY = YRed * YRedB * YRedC;\n    \n    float FinalBlueX = XBlue * XBlueB * XBlueC;\n    float FinalBlueY = YBlue * YBlueB * YBlueC;\n    \n    float FinalGreenX = XGreen * XGreenB * XGreenC;\n    float FinalGreenY = YGreen * YGreenB * YGreenC;\n    \n    float FinalRed = YRed * XRed;\n    float FinalBlue = YBlue * XBlue;\n    float FinalGreen = YGreen * XGreen;\n    \n    float HorizontalOverlay = abs(sin((UV.x * 500.0) + (iTime * 2.0)));\n    float VerticalOverlay = abs(sin((UV.y * 400.0) + (iTime * 2.0)));\n    \n    vec4 FirstPass = vec4(1.0 - FinalRed, 1.0 - FinalGreen, 1.0 - FinalBlue, 1.0);\n    vec4 SecondPass = vec4(HorizontalOverlay, HorizontalOverlay, HorizontalOverlay, 1.0);\n    vec4 ThirdPass = vec4(VerticalOverlay, VerticalOverlay, VerticalOverlay, 1.0);\n    vec4 FourthPass = vec4(FinalRed, FinalBlue, FinalGreen, 0.60);\n    vec4 EirdPass = vec4(VerticalOverlay, VerticalOverlay, VerticalOverlay, 1.0);\n    \n    \n    \n\n    \n    \n    \n    \n    fragColor = FirstPass * SecondPass * ThirdPass;\n    \n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2526]]}
{"id": "ttyGWR", "name": "RayTracing Basics", "author": "GrisWoldDiablo", "description": "Translating a traytraycing compute shader I've  made in unity.\nCONTROL:\nHit Space to toggle rotating light.\nClick Mouse to move camera.", "tags": ["raytracing", "reflection", "sphere"], "likes": 5, "viewed": 114, "published": "Public", "date": "1579061258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\tAlexandre Lepage\n\t14 Jan 2020\n\tgitHub: https://github.com/GrisWoldDiablo\n*/\n#define REFLECTION_AMOUNT 4\n#define Inf 10000.\n\nstruct Sphere\n{\n\tvec3 position;\n\tfloat radius;\n\tvec3 albedo;\n\tvec3 specular;\n};\n \nSphere CreateSphere(vec4 it, vec3 alb, vec3 spec)\n{\n    Sphere sphere;\n    sphere.position = it.xyz;\n \tsphere.radius = it.w;\n\tsphere.albedo = alb;\n\tsphere.specular = spec;\n\treturn sphere;\n}\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\n    \nRay CreateRay(vec3 origin, vec3 direction)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    ray.energy = vec3(1);\n    return ray;\n}\n\nstruct RayHit\n{\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\tvec3 albedo;\n\tvec3 specular;\n};\n\nRayHit CreateRayHit()\n{\n\tRayHit hit;\n\thit.position = vec3(0);\n\thit.distance = Inf;\n\thit.normal = vec3(0);\n\treturn hit;\n}\n\nvoid IntersectGroundPlane(Ray ray, inout RayHit bestHit)\n{\n    float t = -ray.origin.y / ray.direction.y;\n    if(t > 0. && t < bestHit.distance)\n    {\n        bestHit.distance = t;\n        bestHit.position = ray.origin + t * ray.direction;\n        bestHit.normal = vec3(0,1,0);\n        bestHit.albedo = vec3(.2);\n        bestHit.specular = vec3(.1);\n    }\n}\n\nvoid IntersectSphere(Ray ray, inout RayHit bestHit, Sphere sphere)\n{\n\t// Calculate distance along the ray where the sphere is intersected\n\tvec3 d = ray.origin - sphere.position;\n\tfloat p1 = -dot(ray.direction, d);\n\tfloat p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n\tif (p2sqr < 0.)\n\t{\n\t\treturn;\n\t}\n\n\tfloat p2 = sqrt(p2sqr);\n\tfloat t = p1 - p2 > 0. ? p1 - p2 : p1 + p2;\n\tif (t > 0. && t < bestHit.distance)\n\t{\n\t\tbestHit.distance = t;\n\t\tbestHit.position = ray.origin + t * ray.direction;\n\t\tbestHit.normal = normalize(bestHit.position - sphere.position);\n\t\tbestHit.albedo = sphere.albedo;\n\t\tbestHit.specular = sphere.specular;\n\t}\n\n}\n\nRay CreateCameraRay(vec2 uv, vec2 M)\n{\n    vec3 origin = vec3(20.*sin(M.x*5.),2.,-30.*cos(M.x*5.));\n    \n    vec3 lookat = vec3(0,2.*M.y*5.+10.,10.);\n    vec3 f = normalize(lookat-origin);\n    vec3 rg = normalize(cross(vec3(0,1,0),f));\n    vec3 u = normalize(cross(f,rg));\n    vec3 c = origin + f*1.;\n    vec3 i  = c + uv.x*rg + uv.y*u;\n\n    vec3 direction = normalize(i-origin);\n    return CreateRay(origin, direction);\n}\n\nRayHit Trace(Ray ray)\n{\n    RayHit bestHit = CreateRayHit();\n    IntersectGroundPlane(ray, bestHit);\n    \n    Sphere sphere = CreateSphere(vec4(0,2.+sin(iTime)/2.,5,1),vec3(1,0,0),vec3(0));\n    IntersectSphere(ray, bestHit, sphere);\n    Sphere sphere2 = CreateSphere(vec4(2,2,5.+cos(iTime),.5),vec3(0,1,0),vec3(1));\n    IntersectSphere(ray, bestHit, sphere2);\n    Sphere sphere3 = CreateSphere(vec4(-2,2,5.+cos(iTime),.5),vec3(0,1,1),vec3(1));\n    IntersectSphere(ray, bestHit, sphere3);\n    Sphere sphere4 = CreateSphere(vec4(0.+sin(iTime),4.,5.,.5),vec3(1,1,0),vec3(.5));\n    IntersectSphere(ray, bestHit, sphere4);\n    Sphere sphere5 = CreateSphere(vec4(0.,15,20,10),vec3(1),vec3(1));\n    IntersectSphere(ray, bestHit, sphere5);\n    return bestHit;\n}\nconst int KEY_SPACE = 32;\nvec3 Shade(inout Ray ray, RayHit hit)\n{\n    float newTime = iTime + 10.;\n\tif(hit.distance < Inf)\n    {\n    \tray.origin = hit.position + hit.normal * 0.001;\n        ray.direction = reflect(ray.direction, hit.normal);\n        ray.energy *= hit.specular;\n        \n        float rot = texelFetch( iChannel0, ivec2(KEY_SPACE,2),0 ).x;\n        vec3 lightPos;\n        if(rot == 0.){\n        \tlightPos = normalize(vec3(5.*sin(newTime),5.,-5.*cos(newTime)*2.));\n        }else{\n        \tlightPos = normalize(vec3(1.,2.,-5.));\n        }\n        \n        Ray shadowRay = CreateRay(hit.position + hit.normal * 0.001, lightPos);\n\t\tRayHit shadowHit = Trace(shadowRay);\n        if (shadowHit.distance != Inf)\n\t\t{\n\t\t\treturn vec3(0);\n\t\t}\n        return clamp(dot(hit.normal, lightPos) * 1.,0.,1.)* hit.albedo;\n    }\n    else\n    {\n        ray.energy = vec3(0);\n        return vec3(.2);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    Ray ray = CreateCameraRay(uv, M);\n    \n    vec3 result = vec3(0);\n    for (int i = 0; i < REFLECTION_AMOUNT; i++)\n    {\n    \tRayHit hit = Trace(ray);\n    \tresult += ray.energy * Shade(ray, hit);\n        if(ray.energy.x == 0. || ray.energy.y == 0. || ray.energy.z == 0.) break;\n    }\n    \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 260, 260, 398], [471, 471, 515, 515, 628], [727, 727, 750, 750, 847], [849, 849, 907, 907, 1206], [1208, 1208, 1276, 1345, 1854], [1856, 1856, 1894, 1894, 2278], [2280, 2280, 2303, 2303, 3033], [3060, 3060, 3099, 3099, 3940], [3942, 3942, 3999, 3999, 4433]]}
{"id": "ttyGWz", "name": "KxcSquaresTest", "author": "Harekelas", "description": "Practicing with shader toy", "tags": ["tests"], "likes": 0, "viewed": 40, "published": "Public", "date": "1578655898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DrawCircle (vec2 coord, vec2 c, float r, float th)\n{\n    float d = length(coord - c * iResolution.xy);\n    float col = 0.;\n    \n    if(d < r) col = 1.;\n    else if(d < r + th) col = 1. - (d - r) / th;\n    \n    return col;\n}\n\nfloat DrawSquare (vec2 coord, vec2 c, vec2 r)\n{\n    float xd = length(coord.x - c.x * iResolution.x);\n    float yd = length(coord.y - c.y * iResolution.y);\n    \n    float col = 0.;\n    if(xd <= r.x && yd <= r.y) col = 1.;\n    \n    return col;\n}\n\nvec3 DrawFace(vec2 fragCoord, vec2 fc, float fr, vec3 col)\n{\n    float fTh = fr * 0.02; \n    float oTh = fr * 0.01;\n    if(fTh < 2.) fTh = 2.;\n    if(oTh < 2.) oTh = 2.;\n    \n    float face = DrawCircle(fragCoord, fc, fr, fTh);\n\tfloat lEye = DrawCircle(fragCoord, vec2(fc.x - fr * 0.0005,fc.y + fr * 0.001), fr * 0.15,oTh);\n\tfloat rEye = DrawCircle(fragCoord, vec2(fc.x + fr * 0.0005\t,fc.y + fr * 0.001), fr * 0.15,oTh);    \n    \n    float lowMouth = DrawCircle(fragCoord, vec2(fc.x,fc.y - fr * 0.00005), fr * 0.675,oTh);\n    float upMouth = DrawCircle(fragCoord, vec2(fc.x,fc.y + fr * 0.00075), fr * 0.9,oTh);\n    float smile = lowMouth - upMouth;\n    if(smile < 0.) smile = 0.;\n    \n    float mask = face - smile - lEye - rEye;\n       \n    return col * mask;\n}\n\nvec3 DrawFrame(vec2 fragCoord)\n{\n    return vec3(0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //float s = sin(iTime) * 0.3 + 0.5;\n    //float c = cos(iTime) * 0.3 + 0.5;\n    //float as = -sin(iTime) * 0.3 + 0.5;\n    //float ac = -cos(iTime) * 0.3 + 0.5;\n    \n\t//vec3 face1 = DrawFace(fragCoord, vec2(s - 0.1,ac), 40.,vec3(1.,1.,0));    \n    //vec3 face2 = DrawFace(fragCoord, vec2(s + 0.1,c), 40.,vec3(0.5,1.,1.));\n    \n    float size = sin(iTime) * 0.5 + 0.5;\n    \n    float square1 = DrawSquare(fragCoord,vec2(0.166667,0.166667), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);    \n    float square2 = DrawSquare(fragCoord,vec2(0.5,0.166667), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    float square3 = DrawSquare(fragCoord,vec2(0.83333,0.166667), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    \n    float square4 = DrawSquare(fragCoord,vec2(0.166667,0.5), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);    \n    float square5 = DrawSquare(fragCoord,vec2(0.5,0.5), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    float square6 = DrawSquare(fragCoord,vec2(0.83333,0.5), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    \n    float square7 = DrawSquare(fragCoord,vec2(0.166667,0.83333), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);    \n    float square8 = DrawSquare(fragCoord,vec2(0.5,0.83333), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    float square9 = DrawSquare(fragCoord,vec2(0.83333,0.83333), vec2(0.15 * iResolution.x,0.15 * iResolution.y)*size);\n    \n    //vec3 final = face1 + face2;\n    vec3 final = (square1 + square2 + square3 + square4 + square5 + square6 + square7 + square8 + square9)* vec3(1.,1.,1.);\n    \n    // Output to screen\n    fragColor = vec4(final,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 229], [231, 231, 278, 278, 475], [477, 477, 537, 537, 1239], [1241, 1241, 1273, 1273, 1302], [1304, 1304, 1361, 1361, 3079]]}
{"id": "ttyGz3", "name": "ShaderDojo 044", "author": "antonOTI", "description": "Tweaking my precedent shader.\nThe idea was to better showcase the 3D nature of the scene.\nHowever This reveal several artefacts.", "tags": ["raymarch", "stars", "minimal"], "likes": 5, "viewed": 251, "published": "Public API", "date": "1579474704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tau=6.28318;\nfloat star(vec3 p,float t,float r,out float i){\n p.xz*=mat2(cos(t*r),-sin(t*r),sin(t*r),cos(t*r));\n float re=tau/5.,a=mod(atan(p.y,p.x)+re*t*.25,re)-re*.5,\n l=length(p.xy);\n vec3 q=vec3(cos(a)*l,sin(a)*l,p.z*p.z*10.),d=vec3(1.,0.,0.);\n i=length(q.xy-d.xy*clamp(dot(q.xy,d.xy),.0,1.))-(.5-q.x*.25);\n return length(q-d*clamp(dot(q,d),.0,1.))-(.5-q.x*.25);\n}\nfloat m(vec3 p,out float i,out float j){\n float t=iTime*2.,a=atan(p.y,p.x);\n return min(star(p*vec3(2.,2.,1.),t*.25,1.,i),\n  star(vec3(mod(p.z+1.5,3.)-1.5,\n   mod(a*12.+tau*.5+(t+tau*.9)*\n    (mod(floor((p.z+1.5)/3.),2.)*3.-1.5),tau)-tau*.5,\n     length(p.xy)-5.),(t+tau)*.25,1.,j));\n}\nvoid mainImage(out vec4 col,in vec2 coord){\n  vec2 uv=(coord-iResolution.xy*.5)/iResolution.y,e=vec2(.01,.0);\n  vec3 ro=vec3(0.,0.,-3.),rd=normalize(vec3(-uv,1.)),cp=ro+rd;\n  float st=0.,dist=0.,cd=0.,i,j,g;\n  for(;st<1.;st+=1./300.){\n   cd=m(cp,i,j);\n   if(abs(cd)<.01||cd>200.)break;\n   dist+=cd*.05;\n   cp=ro+rd*dist;\n  }\n  st=pow(st+(fract(sin(uv.x+ uv.y*7512.)*4573.1)-.5)*.1,5.);\n  col=mix(vec4(1.,.8,.0,0.),vec4(0.),length(uv)-st)+st;\n  if(cd<.01){\n  vec3 n=normalize(vec3(cd-m(cp+e.xyy,g,g),cd-m(cp+e.yyx,g,g),\n  cd-m(cp+e.yyx,g,g)));\n  float li=clamp(dot(n,vec3(.577)),0.,1.);\n  col.rgb=vec3(.95,.4,.12)*.25;\n  col.rgb+=vec3(1.,1.,1.)*li*.75;i=-(i>.1?j:i);\n  col.rgb=mix(col.rgb,vec3(1.,1.,0.)*1.2,(i+pow(i,4.)+step(.125,i))/3.);\n }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 66, 66, 374], [375, 375, 415, 415, 660], [661, 661, 704, 704, 1404]]}
{"id": "wdGGDh", "name": "Judgement of the Sun", "author": "irwatts", "description": "Praise the Sun!", "tags": ["procedural", "2d", "sun", "sinusoidal", "solaire", "praise"], "likes": 12, "viewed": 291, "published": "Public API", "date": "1579370135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Judgement of the Sun\n\n// Many thanks to IQ\n// https://www.iquilezles.org/www/articles/smin/smin.htm\n// Polynomial Cubic Smooth Min (k = 0.1);\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a,b)-h*h*h/(6.0*k*k);\n}\n\n// Noise\nfloat randFloat(float n)\n{\n \treturn fract( sin( n*64.19 )*420.82 );\n}\nvec2 randVec2(vec2 n)\n{\n \treturn vec2(randFloat( n.x*12.95+n.y*43.72 ),randFloat( n.x*16.21+n.y*90.23 )); \n}\nfloat worley(vec2 n, float s)\n{\n    float dist = 2.0;\n    for( int x=-1;x<=1;x++ )\n    {\n        for( int y=-1;y<=1;y++ )\n        {\n            vec2 p = floor( n/s )+vec2(x,y);\n            float d = length( randVec2( p )+vec2(x,y)-fract( n/s ) );\n            if ( d < dist )\n            {\n             \tdist = d;   \n            }\n        }\n    }\n    return dist;\n}\n\nfloat wave(float dist, float offset)\n{\n    return (0.01*sin(29.0*dist-0.9*(iTime+offset)))\n        +(0.005*sin(72.0*dist-3.1*(iTime+offset)))\n        +(0.003*sin(96.0*dist-4.2*(iTime+offset)));\n}\n\n// Clouds\nvoid clouds(inout vec3 col, in vec2 uv)\n{\n    float noise = 0.8*worley(uv*64.0+vec2(-20.42*iTime,0.0), 128.0)+0.15*worley(uv*64.0+vec2(923.324-1.2*iTime,10.234), 5.0);\n    float grain = randFloat(uv.x*12.95+uv.y*43.72+0.001*noise);\n    noise -= grain*0.05;\n    vec3 lightDir = normalize(vec3(-0.25, 0.75, 0.1));\n    vec3 norm = normalize(vec3(worley(uv*256.0+vec2(90.1921,403.32), 32.0-8.0*noise)-0.5, 0.4*(worley(uv*(64.0+128.0*noise)+vec2(90.1921,3.14159), 24.0)-0.5), 0.5));\n    float lightDot = dot(lightDir, norm);\n    float disp = 10.0*wave(lightDot+uv.y,0.0);\n    float light = clamp(0.64+lightDot, 0.0, 1.0);\n    \n    col = mix(vec3(0.1,0.42,0.64), col, light);\n}\n\n// Sun Arms\nconst vec3 ARMS_COLOR = vec3(0.4745098, 0.1098039, 0.1647059);\nconst vec3 ARMS_END_COLOR = vec3(0.3803922, 0.1254902, 0.1647059);\nconst vec3 ARMS_SPLOTCH_COLOR = vec3(0.1901961, 0.0627451, 0.0823530);\nconst float ARMS_INNER_RADIUS = 0.18;\nconst float ARMS_OUTLINE = 0.005;\nconst float ARMS_FEATHER = 0.0025;\nconst float ARMS_LENGTH = 0.48;\nconst float ARMS_THICKNESS = 0.042;\n\nvoid arms(inout vec3 col, in vec2 uv, in vec2 id)\n{\n    float dist = 1.0;\n    float innerDist = length(uv)-ARMS_INNER_RADIUS;\n    \n    //float thickness = pow((ARMS_THICKNESS*cos((2.6/ARMS_LENGTH)*dist)),0.9);\n    float thickness = (1.0-pow(clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0),2.0))\n        *ARMS_THICKNESS;\n    \n    vec3 armColor = mix(ARMS_COLOR, ARMS_END_COLOR, \n                        clamp(innerDist/(ARMS_LENGTH-ARMS_INNER_RADIUS),0.0,1.0));\n    \n    float armDist = 0.0;\n    // Horizontal '-'\n    armDist = length(uv+vec2(clamp(-uv.x,-ARMS_LENGTH,ARMS_LENGTH),\n                             wave(innerDist,12.92*id.x)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Vertical '|'\n    armDist = length(uv+vec2(wave(innerDist,91.42*id.y),\n                             clamp(-uv.y,-ARMS_LENGTH,ARMS_LENGTH)))-thickness+0.006;\n    dist = min(dist, armDist);\n    // Diagonal '\\'\n    armDist = abs(uv.x+uv.y-wave(innerDist,69.32*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x-uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    // Diagonal '/'\n    armDist = abs(uv.x-uv.y+-wave(innerDist,128.13*(id.x+3.0*id.y)))\n        +0.012*abs(uv.x+uv.y)-thickness*1.4;\n    dist = min(dist, armDist);\n    \n    dist = smin(dist, innerDist, 0.05);\n    \n    // Background Sky Blue\n    col = mix(col, vec3(0.1,0.42,0.64), dist*2.0 );\n    \n    float outlineMask = smoothstep(ARMS_OUTLINE+ARMS_FEATHER,ARMS_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float armsMask = smoothstep(ARMS_FEATHER,0.0,dist);\n    float noise = 0.42*worley(uv*512.0, 32.0);\n    col = mix(col, armColor*(1.0+noise), armsMask);\n    \n    // Splotches\n    float splotchMask = pow(abs(1.0-worley(uv*(512.0), 12.0+20.0*wave(innerDist,42.13))), 4.0)*smoothstep(0.1, 0.0, innerDist)*\n        smoothstep(ARMS_FEATHER+0.03,0.0,dist+0.04);\n    col = mix(col, ARMS_SPLOTCH_COLOR, splotchMask);\n}\n\n// Sun Center\nconst vec3 CENTER_COLOR = vec3(0.6823529, 0.7058824, 0.3294118);\nconst float CENTER_RADIUS = 0.14;\nconst float CENTER_OUTLINE = 0.006;\nconst float CENTER_FEATHER = 0.004;\n\nvoid center(inout vec3 col, in vec2 uv)\n{\n    float dist = length(uv)-CENTER_RADIUS;\n    float outlineMask = smoothstep(CENTER_OUTLINE+CENTER_FEATHER,CENTER_OUTLINE,dist);\n    col = mix(col, vec3(0.0), outlineMask);\n    float centerMask = smoothstep(CENTER_FEATHER,0.0,dist);\n    //col = mix(col, CENTER_COLOR, centerMask);\n    //col = mix(col, CENTER_COLOR, 0.3*pow(1.0-dist,3.0));\n    // Shading\n    vec3 lightDir = normalize(vec3(-0.5, -0.042, 0.2));\n    float light = clamp(dot(lightDir, normalize(vec3(uv/CENTER_RADIUS, \n                                                     sqrt(1.0-clamp(dot(uv, uv),0.0,1.0))))), 0.0, 1.0);\n    //light = pow(light, 0.5);\n    float cells1 = 1.0-pow(worley(uv*1024.0, 32.0+100.0*wave(dist,189.37)), 0.2);\n    float cells2 = 1.0-pow(worley(uv*1024.0, 24.0+100.0*wave(dist,42.13)), 0.2);\n    float noise = 0.8*smin(cells1, cells2, 0.5);\n    float shading = 1.6*(1.0-((1.0-light)*(0.2+noise)));\n    //shading = light;\n    vec3 centerColor = mix(CENTER_COLOR, shading*CENTER_COLOR, 0.42);\n    col = mix(col, centerColor, centerMask);\n    \n}\n\n// Sun Face\nconst float BROW_WIDTH = 0.032;\nconst float BROW_THICKNESS = 0.0025;\nconst float BROW_L_X = -0.045;\nconst float BROW_L_Y = -0.074;\nconst float BROW_R_X = 0.06;\nconst float BROW_R_Y = -0.072;\nconst float SOCKET_WIDTH = 0.038;\nconst float SOCKET_THICKNESS = 0.001;\nconst float SOCKET_L_X = -0.053;\nconst float SOCKET_L_Y = -0.052;\nconst float SOCKET_R_X = 0.06;\nconst float SOCKET_R_Y = -0.052;\nconst float NOSE_HEIGHT = 0.035;\nconst float NOSE_THICKNESS = 0.0025;\nconst float NOSE_X = -0.015;\nconst float NOSE_Y = -0.029;\nconst float NOSTRILS_WIDTH = 0.02;\nconst float NOSTRILS_THICKNESS = 0.003;\nconst float NOSTRILS_X = 0.0;\nconst float NOSTRILS_Y = 0.015;\nconst float EYE_RADIUS = 0.005;\nconst float EYE_L_X = -0.052;\nconst float EYE_L_Y = -0.04;\nconst float EYE_R_X = 0.06;\nconst float EYE_R_Y = -0.04;\nconst float MOUTH_WIDTH = 0.042;\nconst float MOUTH_THICKNESS = 0.001;\nconst float MOUTH_Y = 0.05;\nconst float CHIN_WIDTH = 0.015;\nconst float CHIN_HEIGHT = 0.015;\nconst float CHIN_THICKNESS = 0.002;\nconst float CHIN_X = 0.0;\nconst float CHIN_Y = 0.08;\nconst float FACE_FEATHER = 0.0025;\n\nvoid face(inout vec3 col, in vec2 uv)\n{\n    float dist = 1.0;\n    float thickness = 0.0;\n    float disp = 0.0;\n    \n    vec2 eyesOffset = vec2(0.008*(sin(iTime*0.2+0.42)+0.42*sin(iTime*0.31)+0.1*sin(iTime*1.3)),0.0);\n    \n    // Left Eyebrow\n    thickness = BROW_THICKNESS+(0.001*sin(54.0*uv.x+2.1));\n    disp = (0.006*sin(50.0*uv.x+4.9));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_L_X-BROW_WIDTH,BROW_L_X+BROW_WIDTH),\n                                    BROW_L_Y-disp))-thickness);\n    \n    // Right Eyebrow\n    thickness = BROW_THICKNESS+(0.0015*sin(54.0*uv.x-2.9));\n    disp = (0.006*sin(90.0*uv.x+1.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          BROW_R_X-BROW_WIDTH,BROW_R_X+BROW_WIDTH),\n                                    BROW_R_Y-disp))-thickness);\n    // Left Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-1.8));\n    disp = (0.004*sin(80.0*uv.x+4.2+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.005),\n                                    SOCKET_L_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.002*sin(54.0*uv.x+2.2));\n    disp = (0.013*sin(120.0*uv.x+1.2));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.0008,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.072),\n                                    SOCKET_L_Y+0.004-disp))-thickness,\n               0.01);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(80.0*uv.x-3.1));\n    disp = (0.003*sin(120.0*uv.x+2.2+eyesOffset.x*200.1));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_L_X-SOCKET_WIDTH+0.02,\n                                          SOCKET_L_X+SOCKET_WIDTH-0.015),\n                                    SOCKET_L_Y+0.022-disp))-thickness);\n    \n    // Right Eye Socket\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.005*sin(100.0*uv.x+1.1+eyesOffset.x*42.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH,\n                                          SOCKET_R_X+SOCKET_WIDTH),\n                                    SOCKET_R_Y-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.001*sin(54.0*uv.x-2.9));\n    disp = (0.02*sin(70.0*uv.x-3.2));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH-0.01,\n                                          SOCKET_R_X-0.04),\n                                    SOCKET_R_Y+0.022-disp))-thickness);\n    thickness = SOCKET_THICKNESS+(0.0003*sin(54.0*uv.x-2.9));\n    disp = (0.01*sin(70.0*uv.x-4.5+eyesOffset.x*60.0));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,\n                                          SOCKET_R_X-SOCKET_WIDTH+0.015,\n                                          SOCKET_R_X+SOCKET_WIDTH-0.008),\n                                    SOCKET_R_Y+0.015-disp))-thickness);\n    \n    // Nose Bridge\n    thickness = NOSE_THICKNESS+(0.0015*sin(54.0*uv.y-2.9));\n    disp = (0.003*sin(120.0*uv.y-3.1));\n    dist = smin(dist, length(uv+vec2(NOSE_X-disp,\n                              clamp(-uv.y,NOSE_Y-NOSE_HEIGHT,NOSE_Y+NOSE_HEIGHT)))-thickness, \n                0.01);\n    // Nose Nostrils\n    thickness = NOSTRILS_THICKNESS+(0.002*sin(54.0*uv.x+1.0));\n    disp = (0.004*sin(160.0*uv.x-2.4));\n    dist = smin(dist, length(uv+vec2(clamp(-uv.x,NOSTRILS_X-NOSTRILS_WIDTH,\n                                          NOSTRILS_X+NOSTRILS_WIDTH),NOSTRILS_Y-disp))-thickness,\n               0.02);\n\n    // Left Eyeball\n    dist = min(dist, length(uv+vec2(EYE_L_X+eyesOffset.x,EYE_L_Y+eyesOffset.y))-EYE_RADIUS);\n    // Right Eyeball\n    dist = min(dist, length(uv+vec2(EYE_R_X+eyesOffset.x,EYE_R_Y+eyesOffset.y))-EYE_RADIUS);\n    \n    // Mouth\n    thickness = MOUTH_THICKNESS+(0.0015*sin(54.0*uv.x-1.7));\n    disp = (0.002*sin(120.0*uv.x-2.4));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,-MOUTH_WIDTH,MOUTH_WIDTH),\n                                    MOUTH_Y-disp))-thickness);\n    \n    // Chin\n    thickness = CHIN_THICKNESS+(0.005*sin(54.0*uv.x+0.4));\n    disp = (0.003*sin(80.0*(CHIN_X+uv.x)-2.8));\n    dist = min(dist, length(uv+vec2(clamp(-uv.x,CHIN_X-CHIN_WIDTH,CHIN_X+CHIN_WIDTH),\n                                    CHIN_Y-disp))-thickness);\n    thickness = CHIN_THICKNESS+(0.0005*sin(54.0*uv.y-2.9));\n    disp = (0.006*sin(120.0*(CHIN_Y+uv.y)+3.9));\n    dist = min(dist, length(uv+vec2(CHIN_X-0.022-disp,\n                              clamp(-uv.y,CHIN_Y+0.02-CHIN_HEIGHT,\n                                    CHIN_Y+0.01+CHIN_HEIGHT)))-thickness);\n    \n    col = mix(col, vec3(0.0), smoothstep(FACE_FEATHER,0.0,dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-(0.5*iResolution.xy))/iResolution.y;\n    //cuv *= 1.0+(0.5*sin(iTime*0.5));\t// Scale in out\n    vec3 col = vec3(1.0);\n    vec2 id = floor(uv*2.0);\n    clouds(col, cuv);\n    arms(col, cuv, id);\n    center(col, cuv);\n    face(col, cuv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 145, 184, 184, 258], [260, 269, 295, 295, 338], [339, 339, 362, 362, 447], [448, 448, 479, 479, 812], [814, 814, 852, 852, 1009], [1011, 1021, 1062, 1062, 1692], [1694, 2083, 2134, 2134, 3972], [3974, 4160, 4201, 4201, 5235], [5237, 6343, 6382, 6382, 11262], [11264, 11264, 11319, 11319, 11653]]}
{"id": "WdKSRc", "name": "Codevember #24 - Reflex", "author": "desertsky", "description": "reflecting on the past", "tags": ["reflections"], "likes": 2, "viewed": 206, "published": "Public API", "date": "1580398973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smoothMin(float distA, float distB, float k){\n\tfloat h = max(k-abs(distA - distB),0.0)/k;\n    return min(distA, distB) - h*h*h*k*1.0/6.0;\n}\n\nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;    \n\t}\n\treturn 1.-r*.5;\n}\n//courtesy of https://www.shadertoy.com/view/4l23Rh\nvec3 sky(in vec2 p)\n{\t\nreturn sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*iTime))+.25;\n}\n\nvec2 r(vec2 ax, float a) {return mat2(cos(a),-sin(a),sin(a),cos(a))*ax;}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 boxpos = pos;\n    boxpos/=1.25;\n    boxpos.xy = r(boxpos.xy,1.); \n    boxpos.xz -=.025*sin(pos.x*20.*(mod(sin(iTime/8.)*1.2,2.4)-1.2)*1.25);\n    boxpos*=2.;\n    float sphere2 = float(length(vec3(sin(iTime)*1.25,-.90-sin(iTime),cos(iTime)*1.25)-pos)-.35);\n    float sphere3 = float(length(vec3(cos(iTime+1.43)*1.25,-.90-cos(iTime),sin(iTime)*1.25)-pos)-.35);\n    float box = length(boxpos)-1.25;\n    float plane = float(pos.y+1.5);\n    \n    vec2 scene = vec2(10.);\n\n    //SDF+materials\n    scene = vec2(smoothMin(scene.x,sphere2,0.4), scene.x<sphere2 ? scene.y:2.);\n    scene = vec2(smoothMin(scene.x,box,0.4), scene.x<box ? scene.y:3.);\n    scene = vec2(smoothMin(scene.x,sphere3,0.4), scene.x<sphere3 ? scene.y:4.);\n    scene = vec2(smoothMin(scene.x,plane,.4),scene.x<plane ? scene.y:1.);\n    return scene;\n}\n\nvec2 rm(vec3 ro, vec3 rd)\n{\n    vec2 dO = vec2(0.);\n    \n    for (int i = 0; i < 128; i++)\n    {\n    \tvec2 t = map(ro + dO.x * rd);\n        dO.x += t.x;\n        dO.y = t.y;\n        if(t.x < .01 || dO.x > 50.) break;\n    }\n    return dO;\n}\n\nvec3 n(vec3 pos)\n{\n    float d = map(pos).x;\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d - vec3(\n        map(pos-e.xyy).x,\n        map(pos-e.yxy).x,\n        map(pos-e.yyx).x\n        );\n\treturn normalize(pn);\n}\n\nvec3 l(vec3 pos)\n{\n    vec3 total = vec3(0.);\n    vec3 nor = n(pos);\n    vec3 sundir = normalize(vec3(6.0,5.,0.)); \n    vec3 sundif = clamp(dot(nor,sundir),.0,1.)*vec3(.67);  \n    vec3 skydif = clamp(dot(nor,vec3(.0,1.,.0)),.0,1.)*vec3(.5,.0,.5);\n    vec3 bounce = clamp(dot(nor,-sundir),.0,1.)*vec3(.15);  \n    total+=sundif+bounce+skydif;  \n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;   \n    \n    //bg\n    vec3 col = vec3(.5,-.5+uv.y,uv.y+.75)*sky(vec2(uv.x/3.+iTime/14.,uv.y/3.));\n    \n    vec3 ro = vec3(3.*sin(10.*iMouse.x/iResolution.x+0.),-1.,3.*cos(10.*iMouse.x/iResolution.x));\n    vec3 ta = vec3(.0,.0,.0);\n    \n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(.0,1.,.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(uv.x*uu+uv.y*vv+ww*1.5);\n    vec2 r = rm(ro,rd);\n    vec3 pos = ro+rd*r.x;\n    \n    if(r.x < 50.)\n    {\n        //floor\n        if(r.y == 1.) \n        {            \n            vec3 ro = pos+n(pos)*.02;\n            vec3 rd = normalize(reflect(rd,n(pos)));\n            vec2 r = rm(ro,rd);\n            vec3 prf = ro+rd*r.x;\n\t\t\tfloat f = checkers(pos.xz);\n            if(r.y == 2.) {\n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n                } \n            else if(r.y == 4.) {\n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n            } else {\n\t\t\t\tcol=l(prf*vec3(f))*sky(vec2(iTime/4.+uv.x,uv.y))*vec3(.5,.0+uv.y,.5);\n               }\n        }\n        \n        //ballz\n        if(r.y == 2.) {  \n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n        }\n        if(r.y == 4.) {  \n            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n        }\n\n        //glass sphere\n        if(r.y == 3.) \n        {\n            col = vec3(.05,.06,.02);\n            vec3 ro = pos+n(pos)*.02;\n            vec3 rd = normalize(reflect(rd,n(pos)));\n            vec2 r = rm(ro,rd);\n            vec3 prf = ro+rd*r.x;  \n               if(r.y == 2.) {\n            col = l(pos)*vec3(2)+fbmabs(pos.xy*10.)*vec3(.1,.1,2.9);   \n               } else if(r.y == 4.) {\n\t            col = l(pos)*vec3(.2)+fbmabs(pos.xy*10.)*vec3(2.1,.1,.6);   \n               } else if(r.y ==1.) {\n                   float f = checkers(prf.xz);\n                   col+=l(prf*vec3(f))*sky(-iTime/4.+prf.xz)*(vec3(.5+uv.y))*vec3(.75,.50+uv.y,.75);\n               }  \n               else\n               {\n                col+=l(prf)*vec3(.5,.5,uv.y+.75)/1.+sky(vec2(uv.x+-iTime/8.,uv.y))/2.*vec3(.5,.0+uv.y,.5);\n               }\n        }      \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 145], [228, 228, 251, 251, 426], [428, 428, 452, 452, 610], [611, 663, 684, 684, 751], [753, 753, 779, 779, 825], [827, 827, 872, 872, 963], [965, 965, 994, 994, 1047], [1049, 1049, 1069, 1069, 1889], [1891, 1891, 1918, 1918, 2129], [2131, 2131, 2149, 2149, 2340], [2342, 2342, 2360, 2360, 2704], [2706, 2706, 2763, 2763, 5040]]}
{"id": "wl33Ds", "name": "sin(x*x+y*y)=cos(x*y)", "author": "changjiu", "description": "the graph of the function:sin(x*x+y*y)=cos(x*y)", "tags": ["mathfunction"], "likes": 3, "viewed": 260, "published": "Public API", "date": "1577954959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool near(float a, float b){\n\treturn abs(a-b)<0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime;\n    while(t>6.){\n    \tt = t - 6.;\n    }\n    float scale = t*10.-float(int(t*10./50.))/50.+10.;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (fragCoord-0.5*iResolution.xy)/scale;\n    \n    float x= uv.x;\n    float y= uv.y;\n\n    float gray;\n    \n    if(near(sin(x*x+y*y),cos(x*y))){\n        gray = 1.;\n    }else{\n    \tgray = 0.;\n    }\n\n\n    float r = gray;\n    float g = gray;\n    float b = gray;\n    \n    vec3 col = vec3(r,g,b);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 111, 111, 598]]}
{"id": "wl33Ws", "name": "watermelon", "author": "lomateron", "description": "click to explore\nsame algorithm as https://www.shadertoy.com/view/tlcGWs\nbut with different constants", "tags": ["fractal"], "likes": 3, "viewed": 277, "published": "Public API", "date": "1577936387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n\n    vec2 p = cos(4.1+vec2(0.,pi*.5))*(2.7+sin(iTime)*.2);\n    if(iMouse.z > .5) p = m;\n    \n    u = u*length(p);\n\n    for(float i = .5; i < 20.; ++i)\n    {\n        float e = mod(i,2.)-.5;\n        e = mix(   6.,\t\t\t\t//close hand fan\n                1./6.,\t\t\t\t//open  hand fan\n                e);\t\t\t\t\t\t\t\t\t\t\n        u = sin(atan(u.x,u.y)*e+vec2(0.,pi*.5))*pow(length(u),e);\n        u-= p;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    }\n    fragColor = .5+.5*sin(6.28*(.55+length(u)/length(p)+vec4(.2,.05,.1,.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 692]]}
{"id": "wl3GWs", "name": "raytraced telescope", "author": "micahbro", "description": "Simple two-lens refracting telescope, with physically accurate raytraced optics (non-dispersive), showing the natural optical aberrations that appear in such a simple instrument. Play w/aberrations by adjusting powerDelta (lens bending) & aperture sizes.", "tags": ["raytracing", "optics", "lenses"], "likes": 8, "viewed": 137, "published": "Public", "date": "1577931354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TESTGRID true\n#define BACKIMAGE true\n\n\nstruct stopDef {\n    vec2 center;\n    float z;\n    float radius;\n};\n    \nbool clipStop(vec3 start, vec3 ray, stopDef stop) {\n    float t = (stop.z - start.z) / ray.z;\n    if (t >= 0.) {\n    \tvec2 hitPos = (start + ray * t).xy;\n        vec2 hitxy = hitPos - stop.center;\n        return dot(hitxy, hitxy) <= stop.radius * stop.radius;                \n    } else {    \n    \treturn false;\n    }\n}\n\n\nstruct surfaceDef {\n    vec2 center;\n    float z;\n    float curvRadius;\n    float nRatio;\n};\n\n\nbool refractSurface(in vec3 start, in vec3 ray, surfaceDef surface, out vec3 end, out vec3 endRay) {\n    //x = x0 + v*t\n    //sphere:\n    //v^2*t^2 + 2*(x0 - c)*v*t + (c0 - x)^2 - r^2 = 0\n    //dc = c0 - x\n    //tca = -(x0 - c) * v/v^2 = dc * v/v^2\n    //==> \n    //t^2 - 2*tca*t + dc^2/v^2 - r^2/v^2 = 0\n    //==> t = tca +/- sqrt(tca^2 + r^2/v^2 - dc^2/v^2)\n    \n    vec3 curvCenter = vec3(surface.center, surface.z + surface.curvRadius);\n    vec3 dc = curvCenter - start;\n    float tca = dot(dc, ray);\n    float tdelta = sqrt(tca * tca + surface.curvRadius * surface.curvRadius - dot(dc, dc));\n   \t\n    float t;\n    if (tca - tdelta >= 0. && surface.curvRadius >= 0.) {\n        t = tca - tdelta;\n    } else if (tca + tdelta >= 0. && surface.curvRadius <= 0.) {\n        t = tca + tdelta;\n    } else {\n        return false;\n    }\n\n    vec3 hitPos = start + ray * t;\n    \n    vec3 normal = normalize(hitPos - curvCenter);\n    vec3 perp = dot(ray, normal) * normal;\n   \tvec3 parallel = ray - perp;    \n    vec3 parallelOut = parallel / surface.nRatio;\n    float po2 = dot(parallelOut, parallelOut);\n    if (po2 > 1.) {\n        // total internal reflection\n        return false;\n    }\n    \n    endRay = parallelOut + normalize(perp) * sqrt(1. - po2);\n    \n    end = hitPos;\n    return true;\n}\n\nstruct lensDef {\n    surfaceDef front;\n    surfaceDef back;\n    stopDef stop;\n};\n\nlensDef makeLens(float z, float power, float powerDelta, float radius, float thickness, float nIndex) {    \n    lensDef lens;\n   \tlens.front.nRatio = nIndex;\n    lens.back.nRatio = 1.0 / nIndex;\n    lens.front.center = vec2(0.);\n    lens.back.center = vec2(0.);\n    \n    float r1 = (nIndex - 1.) * 2. / (power + powerDelta + .00001);\n    float r2 = -(nIndex - 1.) * 2. / (power - powerDelta + .00001);\n    \n    lens.front.curvRadius = r1;\n    lens.back.curvRadius = r2;\n    \n    lens.front.z = z;\n    lens.back.z = z + thickness;\n    \n    lens.stop.center = vec2(0.);\n    lens.stop.z = z - 0.00001;\n    lens.stop.radius = radius;\n    \n    return lens;\n}\n\nbool traceLens(in vec3 start, in vec3 ray, lensDef lens, out vec3 end, out vec3 endRay) {\n    if (clipStop(start, ray, lens.stop)) {                \n        //ray = normalize(ray);\n        if (refractSurface(start, ray, lens.front, start, ray)) {\n            //ray = normalize(ray);\n            if (refractSurface(start, ray, lens.back, start, ray)) {\n                end = start;\n                endRay = ray;\n                return true;\n            }\n        }\n    }\n    \n    return false;\t\t    \n}\n\nvec4 sampleBackground(vec2 upvp) {\n    vec4 hitColor = vec4(0.);\n    if (BACKIMAGE) {\n            hitColor = texture(iChannel0, clamp(upvp + 0.5, 0., 1.));\n    }\n    // test grid\n    if (TESTGRID) {\n        hitColor = hitColor / 3. + vec4(0.);\n        vec2 upvpc = mod(upvp + 0.01, 0.02) - 0.01;\n        if (sqrt(dot(upvpc, upvpc)) < 0.002) hitColor = vec4(1.);\n        if (min(abs(upvpc.x), abs(upvpc.y)) < 0.0002) hitColor = vec4(1.);\n    }\n\treturn hitColor;\n}\n\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. interpretation: sin(alpha), sin(beta)\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Infinity coordinates. interpretation: sin(alpha'), sin(beta')    \n    vec2 upvp;\n    \n    fragColor = vec4(0.);\n\n    stopDef aperture;\n    aperture.center = vec2(0.);\n    aperture.z = 1.5; //????\n    aperture.radius = .1;\n    \n\n    lensDef l1 = makeLens(\n        2.,\t\t// z\n        1.5,\t// power\n        0.,\t\t// powerDelta\n        aperture.radius * 4., // radius\n        .1,\t\t// thickness\n        2.5\t\t// nIndex\n        );\n\n\tlensDef l2 = makeLens(\n        9.5 - 1. * sin(iTime/2.) + .001, // z (focus!)\n        0.15,\t// power\n        -0.15,\t\t// powerDelta\n        3.,\t\t// radius\n        1.,\t\t// thickness\n        2.5\t\t// nIndex\n        );\n    \n   \n    float rSampleAperture = aperture.radius;\n    \n    int nXSamples = 18;\n    int nSamples2D = nXSamples * nXSamples;\n    for (float r = 0.; r < float(nXSamples); r++) {\n        vec2 lastupvp;\n\t    for (float th = 0.; th <= 2. * r; th++) {\n            float xnoise = mod(r * 1871. + th * 1607., 43.) / 43. - .5;\n            float ynoise = mod(r * 1061. + th * 1637., 57.) / 57. - .5;\n            //vec2 ij = vec2(i, j) + vec2(xnoise, ynoise);\n            //vec2 ppxy = (ij - float(nXSamples / 2)) / float(nXSamples) * rSampleAperture * 2.;\n            float th0noise = 5.*(mod(float((int(r) ^ 98765) * 1061), 57.) / 57. - .5);\n            float theta = 6.28318 * (th + th0noise) / (2. * r + 1.);\n            vec2 noisexy = vec2(xnoise, ynoise) / float(nXSamples) * rSampleAperture;\n            vec2 ppxy = r / float(nXSamples) * rSampleAperture * vec2(cos(theta), sin(theta)) + noisexy;\n            \n            vec3 start = vec3(ppxy, aperture.z);\n            vec3 ray = vec3(uv, sqrt(1. - dot(uv, uv)));\n            \n            if (clipStop(start, ray, aperture)) {                \n                if (traceLens(start, ray, l1, start, ray)) {\n\t                if (traceLens(start, ray, l2, start, ray)) {\n                        \n                        vec2 deltaupvp = vec2(0.);\n                        if (iMouse.z > 0.) {\n                            deltaupvp = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n                        }\n                        upvp = ray.xy + deltaupvp;\n\n                        vec4 sampledValue = sampleBackground(upvp);\n                        if (th > 0.) {\n                            sampledValue = \n                                (sampledValue +\n                                 sampleBackground((upvp + lastupvp * 4.) / 5.) +\n                                 sampleBackground((upvp * 2. + lastupvp * 3.) / 5.) +\n                                 sampleBackground((upvp * 3. + lastupvp * 2.) / 5.) +\n                                 sampleBackground((upvp * 4. + lastupvp) / 5.)\n                                ) / 5.;\n                        }\n                        \n                        fragColor += sampledValue;\n                        \n                        lastupvp = upvp;\n                    }\n                }\n            }\n\n        }\n    }\n    \n\n    // Output to screen\n    fragColor /= float(nSamples2D);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3GWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 171, 171, 439], [537, 537, 637, 896, 1827], [1911, 1911, 2014, 2014, 2564], [2566, 2566, 2655, 2655, 3066], [3068, 3068, 3102, 3102, 3530], [3542, 3542, 3599, 3664, 6762]]}
{"id": "Wl3SR4", "name": "PolarRepetition with limits", "author": "gvameta", "description": "Combined the concepts from \nhttps://www.shadertoy.com/view/wdtGDM\nand\nhttps://www.shadertoy.com/view/3syGzz", "tags": ["polar", "limited", "repetitions"], "likes": 7, "viewed": 155, "published": "Public", "date": "1580431189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader shows the correct way to compute a number of\n// copies of an object (left), and the usual but incorrect\n// way to do it (right), which does infinite repetition\n// followed by a box that clips the unwanted copies away.\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// Create multiple copies of an object - http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRepLim( in vec2 p, in vec2 s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\nvec2 opPolarRepetition(in vec2 p, in float numrep, in float NumS, in float NumEnd)\n{\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    float aNum = numrep;\n    \n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*aNum);\n    ia = (ia + .5)/aNum*6.2831853;\n   // if(abs(ia)<3.14156/(6.0/2.0))//need to fix this for constraining start and end angles\n    { // Converting the radial centers to their positions.\n        \n       if(cos(iTime*0.25)<0.0)\n       {\n           //use this to keep the shape from deforming\n           p *= r2(ia);\n    \t  // Above is equivalent to:\n    \t  //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n       }\n       else\n       {\n           //use this to deform the shapes\n    \t   p = vec2(length(p), mod(a, 6.2831/aNum) - 6.2831/aNum/2.);\n       }\n        \n    // Setting the radial distance.\n    // Moving the points out a bit along the radial line. If you didn't perform this,\n    // all objects would be superimposed on one another in the center.\n    //p.x -= 3.5;\n  \n    \tp.x = p.x-1.0*clamp(round(p.x/1.0),NumS,NumEnd); // correct radial repetition instead of mod\n    }\n    return p;\n}\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//-----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    // sdf\n    float d1;\n    float d2;\n    if( p.x<0.0 ) \n    {\n    \tvec2 q = p*6.0 + vec2(5.25,0.0);\n        vec2 r1 = opPolarRepetition(q,1.0+8.0*abs(cos(iTime*0.25)),2.0,3.0);\n        //8 repetitions in 360 degrees, along radius start at 2 and end at 3\n        \n        //d1 = length(r1); // for circular primitive\n        //trying to find the right width to only show deformed white rectangle (not more not less)\n        d1 = sdBox( r1, vec2(0.1,0.3))-0.1;//2.5/(1.0+8.0*abs(cos(iTime*0.25)))) ) -  0.1;// for box primitive;\n        \n        d1 = max( -d1,length(q)-3.70);//showing inside of a circle instead of outside\n    }\n    else      \n    {\n        vec2 q = p*6.0 - vec2(5.25,0.0);\n        vec2 r1 = opPolarRepetition(q,1.0+6.0*abs(cos(iTime*0.25)),0.0,2.0);;//time varying repetitions\n        //6 repetitions in 360 degrees, along radius start at 0 and end at 2\n        \n        d2 = length(r1)-0.5;//for circular primitive\n     }\n    \n\tfloat d = d1+d2;\n    \n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(40.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.05,abs(d)) );\n\n    col *= smoothstep(0.005,0.010,abs(p.x));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3SR4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1876, 1984, 2051, 2051, 2097], [2099, 2099, 2119, 2119, 2177], [2179, 2179, 2263, 2283, 3350], [3352, 3461, 3498, 3498, 3533], [3535, 3605, 3649, 3649, 3674], [3676, 3746, 3784, 3784, 3866], [3868, 3901, 3958, 3958, 5263]]}
{"id": "Wl3SRr", "name": "Halftone Noise", "author": "liamegan", "description": "Points in space", "tags": ["halftone", "noisegrid"], "likes": 7, "viewed": 287, "published": "Public API", "date": "1580249495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n  vec2 getScreenSpace() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    return uv;\n  }\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = getScreenSpace();\n    \n    float w = 30./iResolution.y;\n    \n    uv *= 30.;\n    vec2 grid = floor(uv);\n    vec2 subuv = fract(uv);\n    \n    vec3 colour = vec3(0);\n    float d = 0.;\n    \n    for(int x = -1; x < 2; x++) {\n      \n      for(int y = -1; y < 2; y++) {\n        vec2 os = vec2(x,y);\n        vec2 _grid = grid + os;\n        vec2 _subuv = subuv - os;\n        \n        float r = snoise(_grid*.1 + iTime*.5)*.2+.3;\n          d = r;\n        colour += vec3(smoothstep( r+w, r-w, length(_subuv-.5) ));\n      }\n      \n    }\n    \n\n    fragColor = vec4(colour, mix(0., d, colour.x));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Dot Grid\",\n\t\"description\": \"Points in space\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3SRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 26, 26, 142], [144, 144, 166, 166, 205], [207, 207, 228, 228, 1048], [1050, 1050, 1107, 1107, 1711]]}
{"id": "Wl3Xzr", "name": "ikeryou circles", "author": "ikeryou", "description": "many circles", "tags": ["circle"], "likes": 0, "viewed": 222, "published": "Public API", "date": "1580255134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * d * 35.0 - iTime * 13.0;\n \n    \n    // Calculate the ripple thickness\n    d = (sin(t * 0.1) * cos(t * 2.1) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\tcol.rgb = vec3(pow(col.r, 20.0) + 0.2);\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3Xzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 724]]}
{"id": "wlcGDs", "name": "グシグシ", "author": "ShnitzelKiller", "description": "これいいな", "tags": ["oscillation"], "likes": 3, "viewed": 282, "published": "Public API", "date": "1577946112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cubic interpolation\nfloat cubemix(float a, float b, float t) {\n    float c = t*t*(3.-2.*t);\n    return mix(a, b, c);\n}\n\nfloat rand( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat valuenoise(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 offset = vec2(0.,1.);\n    float v00 = rand(iuv);\n    float v01 = rand(iuv+offset.xy);\n    float v10 = rand(iuv+offset.yx);\n    float v11 = rand(iuv+offset.yy);\n    vec2 disp = fract(uv);\n    float v0 = cubemix(v00, v01, disp.y);\n    float v1 = cubemix(v10, v11, disp.y);\n    return cubemix(v0, v1, disp.x)*.5+.5;\n}\n\nfloat fractalnoise(vec2 uv, float mag) {\n    float d = valuenoise(uv);\n    int i;\n    float fac = 1.;\n    vec2 disp = vec2(0., 1.);\n    for (i=0; i<3; i++) {\n        uv -= mag * iTime * disp * fac;\n        fac *= 0.5;\n        d += valuenoise(uv/fac)*fac;\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x*20.;\n\tuv.y -= iTime*10.;\n    float val = fractalnoise(uv, 5.);\n    vec3 col = mix(vec3(1., 0.2, 0.), vec3(1., 1., 0.5), smoothstep(0.5, 1., val));\n    float phase1 = iTime * 20.5;\n    float offset = smoothstep(-0.5, 0.5, sin(iTime*20.))*40.;\n    float offset2 = sin(iTime*15.25) * 40.;\n\tfloat left = iResolution.x*(0.5 + 0.1*(sin(phase1) - 1.)) + offset + offset2;\n    float right = iResolution.x*(0.5 - 0.1*(cos(phase1) - 1.)) + offset + offset2;\n    float bottom = iResolution.y*0.2 + offset * 0.5;\n    float top = iResolution.y*0.55 + offset*0.5;\n    if (fragCoord.x < left || fragCoord.x > right || (fragCoord.y < top && fragCoord.y > bottom)) {\n    \tcol = vec3(0.);   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 65, 65, 121], [123, 123, 145, 145, 378], [380, 380, 407, 407, 757], [759, 759, 799, 799, 1035], [1038, 1038, 1095, 1095, 1846]]}
{"id": "WlcGR2", "name": "Lerp between spheres ", "author": "tomoe", "description": "Lerp between spheres ", "tags": ["raymarching", "imi202001"], "likes": 3, "viewed": 266, "published": "Public API", "date": "1578290783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), sin(t),\n        0.0, - sin(t), cos(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        - sin(t), 0.0, cos(t)\n    );\n}\nmat3 rotZ(float t) {\n    return mat3(\n        cos(t), sin(t), 0.0,\n        - sin(t), cos(t), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\nfloat sphereSDF(vec3 p, vec3 cent, float rad) {\n    return distance(p, cent) - rad;\n}\nfloat sceneSDF(vec3 p){\n    float t = 0.5* iTime;\n    p *= rotY(t) * rotX(t) * rotZ(t);\n    float dist = 1.0;\n    for (float i = 0.0; i < 6.0; i++){\n        vec3 cent = vec3(cos(2.0 * PI * i / 6.0), sin(2.0 * PI * i / 6.0), 0.0);\n        dist = min(dist, sphereSDF(p, cent, 0.2));\n    }\n    return mix(dist, sphereSDF(p, vec3(0.0), 1.), abs(mod(t, 2.0) - 1.0));\n}\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p + vec3(-d, 0.0, 0.0)),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p + vec3(0.0, - d, 0.0)),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    // lightDir *= rotY(u_time);\n\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    vec3 rPos = cPos;\n    for(int i = 0; i < 40; i++ ) {\n        rPos += ray * sceneSDF(rPos);\n    }\n    \n    // collision detection\n    if (abs(sceneSDF(rPos)) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(lightDir, gradSDF(rPos)), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 153], [154, 154, 174, 174, 282], [283, 283, 303, 303, 411], [412, 412, 459, 459, 497], [498, 498, 521, 521, 861], [862, 862, 884, 884, 1172], [1174, 1174, 1230, 1255, 2123]]}
{"id": "WlcSRn", "name": "fbm motion", "author": "jiaolyulu1", "description": "fish in the pool", "tags": ["2d", "noise", "fbm"], "likes": 2, "viewed": 124, "published": "Public", "date": "1580238572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\n\nfloat N21 (vec2 p){\n\tfloat d = fract(sin(p.x*110.+(8.21-p.y)*331.)*1218.);\n    return d;\n}\n\nfloat Noise2D(vec2 uv){\n    vec2 st = fract(uv);\n    vec2 id = floor(uv);\n    st = st*st*(3.0-2.0*st);\n    float c=mix(mix(N21(id),N21(id+vec2(1.0,0.0)),st.x),mix(N21(id+vec2(0.0,1.0)),N21(id+vec2(1.0,1.0)),st.x),st.y);\n\treturn c;\n}\n\nfloat fbm (vec2 uv){\n    \n    float c=0.;\n\tc+=Noise2D(uv)/2.;\n    c+=Noise2D(2.*uv)/4.;\n    c+=Noise2D(4.*uv)/8.;\n    c+=Noise2D(8.*uv)/16.;\n    return c/(1.-1./16.);\n}\n\nvec3 fbm3(vec2 uv){\n    vec3 color;\n\tfloat f1 = fbm(uv);\n    color= mix(vec3(0.1,0.0,0.0),vec3(0.9,0.1,0.1),2.5*f1);\n    \n    float f2 = fbm(2.4*f1+uv+0.15*sin(iTime)*vec2(7.0,-8.0));\n    color= mix(color,vec3(0.6,0.5,0.1),1.5*f2);\n    float f3 = fbm(3.5*f2+uv-0.15*cos(1.5*iTime)*vec2(4.0,3.0));\n    color= mix(color,vec3(0.1,0.35,0.45),f3);\n    \n    color= mix(color,vec3(0.45,0.35,0.25),S(0.7,0.75,f2));\n    color= mix(color,vec3(0.2,0.4,0.2),S(0.75,0.8,f2));\n    color= mix(color,vec3(0.55,0.55,0.35),S(0.88,0.99,f2));\n    color= mix(color,vec3(0.55,0.55,0.35),S(0.88,0.99,f3));\n    \n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    // Time varying pixel color\n    vec3 c = fbm3(2.0*(length(uv-mouse)+0.7)*vec2(5.0,5.0)*uv+sin(0.3*iTime)*0.5);\n    vec3 col = c;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 56, 56, 127], [129, 129, 152, 152, 361], [363, 363, 383, 383, 531], [533, 533, 552, 552, 1141], [1143, 1143, 1200, 1250, 1521]]}
{"id": "WlcSz4", "name": "Magnetic Field Lines #2", "author": "adasba", "description": "A modified version of my others \"magnetic field lines\" shader.", "tags": ["2d", "physics", "magnet"], "likes": 4, "viewed": 279, "published": "Public API", "date": "1580448886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I didn't make this. Credit to:\n//https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//I didn't make this either. Credit to:\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst int pointCount = 32;\n    \n#define PI 3.1415926535897932384626433832795\n    \nvec2 magneticField(vec3[pointCount] pts, vec2 position) {\n    vec2 netForce = vec2(0, 0);\n    for (int i = 0; pointCount > i; i++) {\n    \tnetForce += (position - pts[i].xy) / pow(distance(position, pts[i].xy), 3.0) * pts[i].z;\n    }\n    return netForce;\n}\n\nfloat modsign(float a, float b) {\n\treturn mod(a, b) * sign(a);\n}\n\nvec3 points[pointCount];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    for (int i = 0; pointCount > i; i++) {\n        int pc = pointCount;\n    \tpoints[i] = vec3(0.0);\n        points[i].x = rand(vec2(i, i + pc)) + sin(iTime * rand(vec2(i + pc * 5, i + pc * 6)) * 0.25) * 0.6;\n        points[i].y = rand(vec2(i + pc * 2, i + pc * 3)) + sin(iTime * rand(vec2(i + pc * 7, i + pc * 8)) * 0.25) * 0.6;\n        points[i].z = rand(vec2(i + pc * 4)) * 2.0 - 1.0;\n    }\n    \n    points[1].x = m.x;\n    points[1].y = m.y;\n    points[1].z = -1.0;\n    \n    //points[0] = vec3(0.25, 0.25, 1.0);\n    \n    //points[2] = vec3(0.75, 0.75, 1.0);\n\t//points[1] = vec3(m.x, m.y, -1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 mField = magneticField(points, uv);\n    float fieldMag = distance(vec2(0, 0), mField);\n    float fieldDir = atan(mField.y, mField.x);\n    //fragColor = vec4(log(fieldMag * 5.2) * 0.2, fieldDir / (2.0 * PI) + 0.5, 0.0, 1.0);\n    vec2 mField2 = magneticField(points, uv + vec2(0.005));\n    vec2 mDeriv = mField - mField2;\n    \n    float logmag2 = log(distance(vec2(0), mField2)) * 5.0;\n    \n    //fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, log(fieldMag * 20.0) * 0.1)), 1.0);\n    float logmag = log(fieldMag) * 5.0;\n    //float threshold = pow(distance(vec2(0.0), mDeriv), 0.33);\n    //float col = (mod(5.0 * logmag, 2.0) > threshold) ? 0.0 : 1.0;\n    float col = (abs(mod(logmag, 2.0) - mod(logmag2, 2.0)) > 1.0) ? 1.0 : 0.0;\n    fragColor = vec4(hsv2rgb(vec3(fieldDir / (PI * 2.0), 1.0, col)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 109, 109, 278], [280, 398, 418, 418, 490], [575, 575, 632, 632, 830], [832, 832, 865, 865, 896], [925, 925, 982, 982, 2730]]}
{"id": "WlcXR4", "name": "Fractal.4", "author": "gaetanThiesson", "description": "Old fractal exploration for CineShader", "tags": ["fractal", "cineshader"], "likes": 0, "viewed": 9113, "published": "Public API", "date": "1580444051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 f(vec2 x, vec2 c) {\n    return mat2(x,-x.y,x.x)*x + c;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;uv *= 1.3;uv += 0.5;\n    vec4 col = vec4(1.0);\n    float time = iTime;\n    \n    int u_maxIterations = 75;\n    \n    float r = 0.7885*(sin((time/3.) - 1.57)*0.2+0.85);\n\tvec2 c = vec2(r*cos((time/3.)), r*sin((time/3.)));\n    \n    vec2 z = vec2(0.);\n    z.x = 3.0 * (uv.x - 0.5);\n    z.y = 2.0 * (uv.y - 0.5);\n    bool escaped = false;\n    int iterations;\n    for (int i = 0; i < 10000; i++) {\n        if (i > u_maxIterations) break;\n        iterations = i;\n        z = f(z, c);\n        if (dot(z,z) > 4.0) {\n            escaped = true;\n            break;\n        }\n    }\n\t\t\t\n    vec3 iterationCol = vec3(palette(float(iterations)/ float(u_maxIterations),\n                                     vec3(0.5),\n                                     vec3(0.5),\n                                     vec3(1.0, 1.0, 0.0),\n                                     vec3(0.3 + 0.3 * sin(time),\n                                          0.2 + 0.2 * sin(1. + time),\n                                          0.2  + 0.2 * sin(1.5 + time))));\n\t\t\n\tvec3 coreCol = vec3(0.);\n\t\n    float f_ite = float(iterations);\n    float f_maxIte = float(u_maxIterations);\n    fragColor = vec4(escaped ? iterationCol : coreCol, f_ite/f_maxIte );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Fractal.4\",\n\t\"description\": \"Old fractal exploration https://codepen.io/gThiesson/pen/PowYRqg\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 61], [63, 63, 118, 118, 161], [163, 163, 220, 220, 1478]]}
{"id": "WlcXRH", "name": "Eye Fuck", "author": "adkaros", "description": "draft", "tags": ["illusion", "loop", "weird", "hypnagogia"], "likes": 1, "viewed": 37, "published": "Public", "date": "1580349302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 100.;\n\n    // Time varying pixel color\n    vec3 col = 1.0 + 10.0*cos((iTime)+uv.xyx*iTime*0.05+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 315]]}
{"id": "wlcXRr", "name": "3d ray-shape intersections", "author": "16807", "description": "Click the screen to rotate. Shapes are determined analytically as opposed to using ray marching. This shader demonstrates a way to build any shape made using unions, intersections, and negations using ray-line intersections.", "tags": ["csg", "distance", "analytic", "minimal"], "likes": 2, "viewed": 83, "published": "Public", "date": "1580280668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define SMALL 1e-10\n#define PI 3.1415926\n\n\nbool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n\nstruct maybe_vec2\n{\n    vec2 value; \n    bool  exists; \n};\nstruct maybe_float\n{\n    float value;  \n    bool  exists; \n};\n\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\n\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y  : !shape2.exists ? shape1.value.y  : max(shape1.value.y,  shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\n\n\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),\n             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),\n        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)\n    );\n}\n\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.f;\n    float y  = shape1.exists && shape2.exists ? min(shape1.value.y,  shape2.value.y ) : 0.f;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\n\nfloat get_distance_along_2d_line_nearest_to_point(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0\n){\n    return dot(B0 - A0, A);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\n\nmaybe_float get_distance_along_2d_line_to_line(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    return maybe_float(\n        length(R) / dot(B, normalize(-R)), \n        abs(abs(dot(A, B)) - 1.f) > 0.f\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\n\nmaybe_float get_distance_along_2d_line_to_ray(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line segment endpoint 1\nB1 line segment endpoint 2\n*/\n\nmaybe_float get_distance_along_2d_line_to_line_segment(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|\n    vec2 B = normalize(B2 - B1);\n    vec2 D = B1 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B2 - B1));\n}\n\nmaybe_vec2 get_distances_along_2d_line_to_circle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in float r\n){\n    vec2 D = B0 - A0;\n    float xz = dot(D, A);\n    float z2 = dot(D, D) - xz * xz;\n    float y2 = r * r - z2;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\n*/\n\nmaybe_vec2 get_distances_along_2d_line_to_triangle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2,\n    in vec2 B3\n){\n    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);\n    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);\n    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);\n    return maybe_vec2(\n        vec2(min(line1.value, min(line2.value, line3.value)), \n             max(line1.value, max(line2.value, line3.value))), \n        line1.exists || line2.exists || line3.exists\n    );\n}\n\nfloat get_distance_along_3d_line_nearest_to_point(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0\n){\n    return dot(B0 - A0, A);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_line(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 C = normalize(cross(B, A));\n    // cross\n    vec3 R = D - dot(D, A) * A - dot(D, C) * C;\n    // rejection\n    return maybe_float(\n        length(R) / -dot(B, normalize(R)), \n        abs(abs(dot(A, B)) - 1.f) > 0.f\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_ray(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 line segment endpoint 1\nB2 line segment endpoint 2\n*/\n\nmaybe_float get_distance_along_3d_line_nearest_to_line_segment(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B1\n){\n    vec3 B = normalize(B1 - B0);\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B1 - B0));\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\n\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 circle origin\nN  circle surface normal, normalized\nr  circle radius\n*/\n\nmaybe_float get_distance_along_3d_line_to_circle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N,\n    in float r\n){\n    // intersection(plane, sphere)\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\n\nmaybe_float get_distance_along_3d_line_to_triangle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3\n){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3 B0 = (B1 + B2 + B3) / 3.;\n    vec3 N = normalize(cross(B1 - B2, B2 - B3));\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3 At = A0 + A * t.value;\n    vec3 B2B1hat = normalize(B2 - B1);\n    vec3 B3B2hat = normalize(B3 - B2);\n    vec3 B1B3hat = normalize(B1 - B3);\n    return maybe_float(t.value, \n        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) && \n        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) && \n        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float xz = dot(B0 - A0, A);\n    float z = length(A0 + A * xz - B0);\n    float y2 = r * r - z * z;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(\n        vec2(xz - dxr, xz + dxr), \n        y2 > 0.\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\n\nmaybe_float get_distance_along_3d_line_to_ellipsoid(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 R\n){\n    // NOTE: shamelessly copy pasted, all credit goes to Inigo: \n    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    vec3 Or = (A0 - B0) / R;\n    vec3 Ar = A / R;\n    float ArAr = dot(Ar, Ar);\n    float OrAr = dot(Or, Ar);\n    float OrOr = dot(Or, Or);\n    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);\n    return maybe_float(\n        (-OrAr - sqrt(h)) / ArAr, \n        h >= 0.0\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\n\nmaybe_float get_distance_along_3d_line_to_tetrahedron(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3,\n    in vec3 B4\n){\n    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);\n    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);\n    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);\n    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);\n    maybe_float hit;\n    hit = get_distance_along_line_to_union(hit1, hit2);\n    hit = get_distance_along_line_to_union(hit,  hit3);\n    hit = get_distance_along_line_to_union(hit,  hit4);\n    return hit;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.f));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a), \n        h > 0.0\n    );\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y,  a_in);\n    float exit     = min(tube.value.x, a_out);\n    return maybe_vec2( \n        vec2(entrance, exit), \n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 ring endpoint 1\nB2 ring endpoing 2\nro ring outer radius\nri ring inner radius\n*/\n\nmaybe_vec2 get_distances_along_3d_line_to_ring(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float ro,\n    in float ri\n){\n    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);\n    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);\n    maybe_vec2 ring  = get_distances_along_line_to_negation(outer, inner);\n    return ring;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\ncosb cosine of cone half angle\n*/\n\nmaybe_float get_distance_along_3d_line_to_infinite_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float cosb\n){\n    vec3 D = A0 - B0;\n    float a = dot(A, B) * dot(A, B) - cosb * cosb;\n    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);\n    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;\n    float det = b * b - 4. * a * c;\n    if (det < 0.)\n    {\n        return maybe_float(0.f, false);\n    }\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t)\n    {\n        t = t2;\n    }\n    else {\n        t = t1;\n    }\n\n    vec3 cp = A0 + t * A - B0;\n    float h = dot(cp, B);\n    return maybe_float(t, t > 0. && h > 0.);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\nr  cone radius\nh  cone height\n*/\n\nmaybe_float get_distance_along_3d_line_to_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r,\n    in float h\n){\n    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));\n    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;\n    cone = get_distance_along_line_to_union(end, cone);\n    return cone;\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB1 cone endpoint 1\nB2 cone endpoint 2\nr1 cone endpoint 1 radius\nr2 cone endpoint 2 radius\n*/\n\nmaybe_float get_distance_along_3d_line_to_capped_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r1,\n    in float r2\n){\n    float dh = length(B2 - B1);\n    float dr = r2 - r1;\n    float rmax = max(r2, r1);\n    float rmin = min(r2, r1);\n    float hmax = rmax * dr / dh;\n    float hmin = rmin * dr / dh;\n    vec3 B = sign(dr) * normalize(B2 - B1);\n    vec3 Bmax = (r2 > r1? B2 : B1);\n    vec3 B0 = Bmax - B * hmax;\n    vec3 Bmin = Bmax - B * hmin;\n    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);\n    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));\n    float c_h = dot(A0 + cone.value * A - B0, B);\n    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;\n    cone = get_distance_along_line_to_union(cone, end1);\n    cone = get_distance_along_line_to_union(cone, end2);\n    return cone;\n}\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    \n    maybe_vec2 shapes;\n    maybe_vec2 shape;\n    maybe_float shapes2;\n    maybe_float shape2;\n    float scale = 0.23;\n    float separation = 0.25;\n    vec3 center;\n    \n    center = separation * vec3(-1,-1,0);\n    shapes = get_distances_along_3d_line_to_sphere(A0, A, center, scale);\n    \n    center = separation * vec3(-1, 1,0);\n    shape  = get_distances_along_3d_line_to_cylinder(A0, A, center+scale*vec3(0,0,-1), center+scale*vec3(0,0,1), scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n    \n    center = separation * vec3(1,-1,0);\n    shape  = get_distances_along_3d_line_to_capsule(A0, A, center+scale*vec3(0,0,-1), center+scale*vec3(0,0,1), scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n     \n    center = separation * vec3(1,1,0);\n    shape  = get_distances_along_3d_line_to_ring(A0, A, center+scale*vec3(0,0,-0.5), center+scale*vec3(0,0,0.5), scale, 0.7*scale);\n    shapes = get_distances_along_line_to_union(shapes, shape);\n     \n    // some line intersection functions only solve for entrance distance\n    // so we do those functions next\n    \n    shapes2 = maybe_float(shapes.value.x, shapes.exists);\n    \n    center = separation * vec3(-3,-1,0);\n    shape2 = get_distance_along_3d_line_to_tetrahedron(A0, A, center+scale*vec3(1,0,0), center+scale*vec3(0,1,0), center+scale*vec3(0,0,1), center+scale*vec3(-1,-1,-1) );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(-4,1,0);\n    shape2 = get_distance_along_3d_line_to_ellipsoid(A0, A, center+scale*vec3(1,0,0), scale*vec3(1,2,3)/2.f );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(3,-1,0);\n    shape2 = get_distance_along_3d_line_to_circle(A0, A, center, vec3(0,0,1), scale );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n     \n    center = separation * vec3(3,1,0);\n    shape2 = get_distance_along_3d_line_to_triangle(A0, A, center+scale*vec3(1,0,0), center+scale*vec3(0,1,0), center+scale*vec3(0,0,1) );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n    \n    center = separation * vec3(5,-1,0);\n    shape2 = get_distance_along_3d_line_to_cone(A0, A, center, vec3(0,0,1), scale, 2.f*scale );\n    shapes2= get_distance_along_line_to_union(shapes2, shape2);\n    \n    vec3  color = vec3(0);\n    if (shapes2.exists)\n    {\n        color = vec3(shapes2.value, shapes.value.y, 0);\n    }\n    \n    fragColor = vec4(color/4.f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 250, 250, 282], [406, 406, 508, 508, 685], [687, 687, 787, 787, 1099], [1102, 1102, 1205, 1205, 1518], [1521, 1521, 1628, 1628, 1888], [1890, 1890, 1989, 1989, 2019], [2021, 2124, 2235, 2235, 2437], [2439, 2537, 2647, 2748, 3037], [3039, 3148, 3268, 3379, 3724], [3726, 3726, 3840, 3840, 4049], [4051, 4148, 4280, 4280, 4741], [4743, 4743, 4842, 4842, 4872], [4874, 4977, 5096, 5096, 5364], [5366, 5464, 5582, 5582, 5871], [5873, 5982, 6110, 6110, 6455], [6457, 6567, 6679, 6679, 6760], [6762, 6888, 7017, 7052, 7206], [7208, 7326, 7458, 7526, 8078], [8080, 8196, 8310, 8310, 8533], [8535, 8657, 8773, 8915, 9189], [9191, 9330, 9481, 9481, 10016], [10018, 10148, 10288, 10599, 10916], [10918, 11038, 11170, 11170, 11910], [11911, 12028, 12159, 12159, 12579], [12581, 12716, 12862, 12862, 13122], [13124, 13255, 13394, 13394, 14096], [14098, 14228, 14371, 14371, 14702], [14704, 14849, 15002, 15002, 15844], [15848, 15848, 15898, 15898, 16526], [16528, 16528, 16585, 16585, 19762]]}
{"id": "WlcXzN", "name": "The Nautilus, Part 2", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 2 of a series", "tags": ["water", "submarine", "sciencefiction", "verne"], "likes": 2, "viewed": 243, "published": "Public API", "date": "1580470612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The Nautilus, Part 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"; part 2 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14, idGrnd = 15;\nconst float pi = 3.14159;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.6 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[1], rdb[1];\n  vec2 lbDist, ws;\n  float dstObj, dstCave, dstGrnd, sh;\n  dstObj = ObjRay (ro, rd);\n  dstCave = CaveRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar)) {\n    dstObj = dstCave;\n    idObj = idCav;\n  }\n  dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n  if (dstGrnd < min (dstObj, dstFar)) {\n    dstObj = dstGrnd;\n    idObj = idGrnd;\n  }\n  sh = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idGrnd) {\n      ro += dstObj * rd;\n      col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n         0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n         0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n      vn = GrndNf (ro);\n      vno = vec3 (0., 1., 0.);\n      if (vn.y > 0.85) {\n        vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n        vn = vn4.xyz;\n        col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n      }\n      vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n      ws = ro.xz - sbPos.xz;\n      ws = Rot2D (ws, sbRot);\n      sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n         vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n         1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n         (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n      sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), \n         0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else if (idObj == idCav) {\n      ro += dstObj * rd;\n      vn = CaveNf (ro);\n      vno = vn;\n      col = vec3 (0.4, 0.4, 0.4);\n      col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));\n      vn = VaryNf (ro, vn, 12.);\n      col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n         0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));\n      col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vno = vn;\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n      if (col4.a >= 0.) {\n        col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n        col *= vec3 (0.7, 0.9, 1.);\n      } else {\n        col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n      }\n    }\n    col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n       (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n  } else {\n    col = UnwCol (rd) + WatShd (rd);\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n    if (lbDist.x < min (dstObj, dstFar))\n       col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, dVu, tVuCyc;\n  uv = fCoord;\n  cvSize = 7.;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  fpF = TrackPathCv (t + 0.1);\n  fpB = TrackPathCv (t - 0.1);\n  sbPos = 0.5 * (fpF + fpB);\n  sbPos.y = 0.09;\n  vd = fpF - fpB;\n  sbRot = atan (vd.x, vd.z);\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  t += 20. * dVu;\n  fpF = TrackPathCv (t + 0.1 * sign (dVu));\n  fpB = TrackPathCv (t - 0.1 * sign (dVu));\n  ro = 0.5 * (fpF + fpB);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 50. * cvSize;\n  zmFac = 1.4;\n  sunDir = normalize (vec3 (1., 3., -1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  uv *= vec2 (9./16., 1./0.85);\n  col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXzN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[128, 1288, 1316, 1316, 1415], [1417, 1417, 1440, 1440, 1701], [1703, 1703, 1737, 1737, 1942], [1944, 1944, 1977, 1977, 2168], [2170, 2170, 2192, 2192, 2448], [2450, 2450, 2488, 2488, 2734], [2736, 2736, 2759, 2759, 3001], [3003, 3003, 3037, 3037, 3516], [3518, 3518, 3540, 3540, 3679], [3681, 3681, 3706, 3706, 4085], [4087, 4087, 4131, 4131, 4325], [4327, 4327, 4351, 4351, 4682], [4684, 4684, 4724, 4724, 5184], [5186, 5186, 5209, 5209, 5629], [5631, 5631, 5654, 5654, 8535], [8537, 8537, 8559, 8559, 8719], [8721, 8721, 8754, 8754, 8937], [8939, 8939, 8960, 8960, 9215], [9217, 9217, 9254, 9254, 9495], [9497, 9497, 9520, 9520, 9856], [9858, 9858, 9892, 9892, 10114], [10116, 10116, 10139, 10139, 10398], [10400, 10400, 10439, 10439, 13077], [13079, 13079, 13114, 13114, 16230], [16232, 16232, 16277, 16277, 17372], [17374, 17374, 17430, 17430, 17903], [17905, 17905, 17938, 17938, 18027], [18029, 18029, 18075, 18075, 18122], [18124, 18124, 18157, 18157, 18184], [18186, 18186, 18228, 18228, 18279], [18281, 18281, 18340, 18340, 18471], [18473, 18473, 18526, 18526, 18587], [18589, 18589, 18611, 18611, 18649], [18651, 18651, 18687, 18687, 18893], [18895, 18895, 18940, 18940, 19043], [19045, 19045, 19102, 19102, 19185], [19187, 19187, 19217, 19217, 19330], [19364, 19364, 19388, 19388, 19441], [19443, 19443, 19467, 19467, 19597], [19599, 19599, 19623, 19623, 19686], [19688, 19688, 19712, 19712, 19932], [19934, 19934, 19959, 19959, 20145], [20147, 20147, 20172, 20172, 20397], [20399, 20399, 20424, 20424, 20745], [20747, 20747, 20772, 20772, 20918], [20920, 20920, 20942, 20942, 21096], [21098, 21098, 21119, 21119, 21274], [21276, 21276, 21297, 21297, 21452], [21454, 21454, 21483, 21483, 21695], [21697, 21697, 21736, 21736, 21921]]}
{"id": "WldXRH", "name": "Truchet Tiles Test", "author": "tonywu", "description": "for test", "tags": ["cineshader"], "likes": 2, "viewed": 5083, "published": "Public API", "date": "1580400667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  \n    uv = tile(uv,6.0);\n    uv = rotateTilePattern(uv);\n\n    // Make more interesting combinations\n    //uv *= tile(uv,2.0);\n    //uv *= rotate2D(uv,-PI*sin(iTime));\n    //uv = rotateTilePattern(uv*2.);\n    uv *= rotate2D(uv,PI*iTime*0.25);\n\n    // step(st.x,st.y) just makes a b&w triangles\n    // but you can use whatever design you want.\n    float f = step(uv.x,uv.y);\n    fragColor = vec4(vec3(f*.5,f*cos(iTime), f*sin(iTime)),1.0);\n    float gamma = 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 76, 76, 216], [218, 218, 253, 253, 296], [298, 298, 331, 375, 1127], [1129, 1129, 1186, 1236, 1798]]}
{"id": "wldXRr", "name": "Fractal 001", "author": "bananoid", "description": "Mandelbrot 3d", "tags": ["fractal"], "likes": 1, "viewed": 59, "published": "Public", "date": "1580314632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n\n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec4 fractal(vec3 position, float power) {\n  vec3 z = position + cos(iTime * 0.34236) ;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n  float iterations = 0.0;\n  vec3 col = vec3(0.0);\n\tfor (float i = 0.0; i < 8.0 ; i++) {\n    iterations = i;\n\t\tr = length(z);\n\n\t\tif (r>2.0) break;\n\n    col =mix(vec3(3.0,0.8,0.2), vec3(0.0,0.9,5.2),r*0.3);\n\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=position;\n\t}\n  float dst = 0.5*log(r)*r/dr;\n\n  return vec4(col,dst);\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float a, float b, float k ) {\n    float h = clamp( 0.5-0.5*(b+a)/k, 0., 1. );\n    return mix( b, -a, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec4 opSmoothUnionColor( vec4 a, vec4 b, float k ) {\n    float h = clamp( 0.5+0.5*(b.w-a.w)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 objectSDFColor(vec3 p) {\n  float planeDist = p.y +0.1;\n\n\tvec4 s = vec4(0, 0.9, 0., 1);\n\n  p -= s.xyz;\n  p.xz *= Rot(iTime* 0.123 + 1.34);\n  p.xy *= Rot(iTime*0.9861234 * 0.1 + 0.44);\n  p += s.xyz;\n\n  float obj2 =  sdTorus( p - s.xyz, vec2(0.8,0.1));\n  // sdSphere( p - s.xyz, s.w);\n  // p -= s.xyz;\n  // p.xy *= Rot(1.57075);\n  // p += s.xyz;\n\n  // float obj6 = sdTorus( p - s.xyz, vec2(1.0,0.3));\n  // float obj1 = sdRoundBox( p - s.xyz + vec3(0.4,-0.3,0.4), vec3(0.2,0.5,0.2) , 0.3);\n  // float obj3 = sdCapsule( p - s.xyz, vec3(.0,-1.0,.0), vec3(.0,1.0,.0), 0.5 );\n  // vec3 pp = p;\n  // pp.xz *= Rot(3.14);\n\n  // float obj4 = sdRoundCone( pp - s.xyz,  0.4, 0.2, 1. );\n  // float obj5 = sdEllipsoid( p - s.xyz,  vec3(0.6,1.0,0.6) );\n  // float obj7 = sdOctahedron( p - s.xyz, 1.0);\n\n  float d = 0.0;\n  // d = opSmoothSubtraction(obj1, obj3, 0.01);\n  // d = obj2;\n  float power = (sin(iTime * 0.1) * 0.5 + 0.5) + 0.3;\n  vec4 frac = fractal(p - s.xyz, power * 10.0);\n  // d = frac.w;\n  // d = opSmoothSubtraction(obj3, d, 0.01);\n  // d = min(obj4, d);\n  // d = min(d, obj4);\n  // d = rounding(d, sin(iTime) * 0.1 - 0.1);\n  // d = mix(d, obj6, sin(iTime * 2.1) * 0.5 + 0.5);\n  // vec3 colA = vec3(0.0,0.7,1.0);\n  // vec3 colB = vec3(0.0,0.2,1.0);\n\n  // vec4 dC = opSmoothUnionColor(vec4(colB,d), vec4(colA,planeDist),0.9);\n\n  // return dC;\n  // return vec4(colB,d);\n  return frac;\n}\n\nfloat objectSDF(vec3 p) {\n  return objectSDFColor(p).w;\n}\n\nvec4 RayMarchColor(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n\n  vec3 color = vec3(0.0);\n\n  for(int i=0; i<MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n    vec4 dSC = objectSDFColor(p);\n    float dS = dSC.w;\n    color = dSC.rgb;\n    dO += dS;\n    if(dO>MAX_DIST || dS<SURF_DIST) break;\n  }\n  color = normalize(color);\n  return vec4(color,dO);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  return RayMarchColor(ro,rd).w;\n}\n\n// float softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n// {\n//  \tfloat t = mint;\n//     float res = 1.0;\n//     for( int i=0; i<256; i++ )\n//     {\n//      \tfloat h = objectSDF(ro + t*rd);\n//         res = min( res, h/(w*t) );\n//     \tt += clamp(h, 0.005, 0.10);\n//         if( res<-1.0 || t>tmax ) break;\n//     }\n//     res = max(res,-1.0); // clamp to [-1,1]\n\n//     return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n// }\n\n// float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n// {\n// \tfloat res = 1.0;\n//   float t = mint;\n//   float ph = 1e10; // big, such that y = 0 on the first iteration\n\n//   for( int i=0; i<32; i++ )\n//   {\n//     float h = objectSDF( ro + rd*t );\n//     // use this if you are getting artifact on the first iteration, or unroll the\n//     // first iteration out of the loop\n//     //float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n\n//     float y = h*h/(2.0*ph);\n//     float d = sqrt(h*h-y*y);\n//     res = min( res, 10.0*d/max(0.0,t-y) );\n//     ph = h;\n\n//     t += h;\n\n//     if( res<0.0001 || t>tmax ) break;\n\n//   }\n//   return clamp( res, 0.0, 1.0 );\n// }\n\n// vec3 GetNormal(vec3 p) {\n// \tfloat d = objectSDF(p);\n//   vec2 e = vec2(.01, 0);\n\n//   vec3 n = d - vec3(\n//       objectSDF(p-e.xyy),\n//       objectSDF(p-e.yxy),\n//       objectSDF(p-e.yyx));\n\n//   return normalize(n);\n// }\n\n// float GetLight(vec3 p, vec3 lightPos) {\n//   vec3 l = normalize(lightPos-p);\n\n//   vec3 n = GetNormal(p);\n//   float dif = clamp(dot(n, l), 0., 1.0);\n\n//   // float d = RayMarch(p+n*SURF_DIST*2., l);\n//   // if(d<length(lightPos-p)) dif *= .1;\n\n//   float shadow = calcSoftshadow( p, l, 0.01, 3.0);\n//   dif *= shadow;\n\n//   return dif;\n// }\n\n// float GetContour(vec3 p, float z){\n//   // vec3 n = GetNormal(p);\n//   // float dif = dot( camPos, n);\n//   // float c = 0.0;\n//   // if(dif > 0.5){\n//   //   c = 1.0;\n//   // }\n//   return z;\n// }\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0, 4, 1.);\n  ro.yz *= Rot(-m.y*3.14+1.);\n  ro.xz *= Rot(-m.x*6.2831);\n\n  vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n  vec4 dC = RayMarchColor(ro, rd);\n  float d = dC.w;\n\n  float z = 1.0 - (d*0.2 - 0.7);\n  z = clamp(z, 0.0, 1.0);\n\n  vec3 colA = vec3(1.0,0.8,0.8) * 1.5;\n  vec3 colB = vec3(1.0,0.3,0.2);\n\n  // col = vec3(z);\n  vec3 zC = mix(colB,colA, z);\n\n  col = mix(zC,dC.rgb * z, 1. ) ;\n  // col = z * dC.rgb;\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 104, 104, 128], [130, 130, 161, 161, 248], [250, 250, 295, 295, 386], [388, 388, 440, 440, 561], [563, 563, 595, 630, 687], [689, 689, 747, 747, 995], [997, 997, 1034, 1034, 1117], [1119, 1119, 1152, 1152, 1217], [1219, 1219, 1257, 1257, 1310], [1312, 1312, 1354, 1354, 2065], [2067, 2067, 2109, 2109, 2129], [2131, 2131, 2150, 2150, 2226], [2228, 2228, 2278, 2278, 2369], [2371, 2371, 2427, 2427, 2519], [2521, 2521, 2580, 2580, 2675], [2677, 2677, 2729, 2729, 2824], [2826, 2826, 2855, 2855, 4213], [4215, 4215, 4240, 4240, 4272], [4274, 4274, 4312, 4312, 4607], [4609, 4609, 4643, 4643, 4678], [6388, 6590, 6632, 6632, 6827], [6829, 6829, 6886, 6886, 7460]]}
{"id": "wlG3Dh", "name": "Julia Set explorer", "author": "xenix1337", "description": "Use mouse to change constants", "tags": ["fractal", "julia", "set"], "likes": 2, "viewed": 49, "published": "Public", "date": "1578785978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getPixel(vec2 pos, vec2 con) {\n    vec2 z = pos;\n    float i = 0.f;\n    for(i = 0.f; i < 255.f; i++) {\n    \tz = vec2(z.x * z.x - z.y*z.y, 2.f * z.x * z.y) + con;\n        if(length(z) > 2.f) break;\n    }\n    return i / 255.f;\n}\n\nvec3 color(float b) {\n\tvec3 c;\n    c.r = 0.9f * sin(b * 0.45f);\n    c.g = sin(b * 1.f);\n    c.b = 0.5f * sin(b * 0.5f);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5f * iResolution.xy)/iResolution.y;\n    uv *= 2.f;\n\n    \n    vec2 xy = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    xy *= 2.f; xy -= 1.f;\n    if( iMouse.z<=0.f )  xy = vec2(cos((iTime + 6.f) * 0.3f) * 0.7f, sin((iTime + 6.f) * 0.3f) * 0.7f);\n    float b = getPixel(uv, xy);\n    vec3 col = color(b);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Dh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 232], [234, 234, 255, 255, 369], [371, 371, 428, 428, 805]]}
{"id": "wlG3Rd", "name": "2D noise contour", "author": "hiogawa", "description": "I just heard that you can make contour lines simply by feeding it to any periodic function.\nAlso, I was curious how it looks if we rotate gradient used for noise interpolation.", "tags": ["2d", "noise"], "likes": 5, "viewed": 366, "published": "Public API", "date": "1579611982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float M_PI = 3.1415;\n\nfloat SCALE = 3.0;\nfloat NUM_OCTAVES = 2.0;\nfloat SCALE_TIME = 0.1;\n\nfloat SCALE_CONTOUR = 32.0;\nvec2 CLIP_RANGE = vec2(0.8, 1.0);\nvec3 COLOR1 = vec3(1.0, 0.0, 1.0);\nvec3 COLOR2 = vec3(0.0, 1.0, 1.0);\n\n// R -> [0, 1)\nfloat hash11(float t) {\n  return fract(sin(t * 56789.0) * 56789.0);\n}\n\n// R^2 -> [0, 1)\nfloat hash21(vec2 uv) {\n  return hash11(hash11(uv[0]) + 2.0 * hash11(uv[1]));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  float t = hash21(uv);\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\n\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvec2 rotate2(vec2 uv, float r) {\n  mat2 R = mat2(\n    cos(r), sin(r),\n   -sin(r), cos(r)\n  );\n  return R * uv;\n}\n\n// R^2 -> [0, 1)\n// support additional argument to rotate gradient\nfloat gradientNoise(vec2 uv, float r) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  vec2 g00 = rotate2(hashGradient2(uvi + vec2(0.0, 0.0)), r);\n  vec2 g10 = rotate2(hashGradient2(uvi + vec2(1.0, 0.0)), r);\n  vec2 g01 = rotate2(hashGradient2(uvi + vec2(0.0, 1.0)), r);\n  vec2 g11 = rotate2(hashGradient2(uvi + vec2(1.0, 1.0)), r);\n  float f00 = dot(g00, uvf - vec2(0.0, 0.0));\n  float f10 = dot(g10, uvf - vec2(1.0, 0.0));\n  float f01 = dot(g01, uvf - vec2(0.0, 1.0));\n  float f11 = dot(g11, uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n\n  // Normalize via upper/lower bound = +- 1 / sqrt(2) ~ 0.7\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nfloat noise(vec2 uv, float r) {\n  float result = 0.0;\n  for (float i = 0.0; i < NUM_OCTAVES; i++) {\n    float p = pow(2.0, i);\n    result += (gradientNoise(uv * p, r) / p);\n  }\n  result /= (pow(2.0, NUM_OCTAVES) - 1.0) / (pow(2.0, NUM_OCTAVES - 1.0));\n  return result;\n}\n\nfloat wave(float t) {\n  return 0.5 * (1.0 - cos(SCALE_CONTOUR * M_PI * t));\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  vec2 uv =  SCALE * frag_coord / iResolution.y;\n\n  float noise_fac = noise(uv, SCALE_TIME * 2.0 * M_PI * iTime);\n  float contour_fac = wave(noise_fac);\n  float clip = smoothstep(CLIP_RANGE[0], CLIP_RANGE[1], contour_fac);\n  vec3 color = mix(COLOR1, COLOR2, noise_fac);\n\n  frag_color = vec4(color * clip, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 239, 262, 262, 308], [310, 327, 350, 350, 406], [408, 408, 437, 437, 520], [522, 522, 587, 587, 654], [656, 656, 688, 688, 768], [770, 837, 876, 876, 1527], [1529, 1529, 1560, 1560, 1799], [1801, 1801, 1822, 1822, 1878], [1880, 1880, 1934, 1934, 2247]]}
{"id": "wlG3Rh", "name": "OverThemoon", "author": "Sando", "description": "ShaderCoding from the art of code", "tags": ["tutoexample"], "likes": 6, "viewed": 92, "published": "Public", "date": "1578258751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n\tfloat m = S(-blur, blur, p.y-yb);\n    m *= S(blur, -blur, p.y-yt);\n    \n    p.x = abs(p.x);\n    \n    float w = mix(wb, wt, (p.y-yb) / (yt-yb)); \n    m *= S(blur, -blur, p.x-w);\n    \n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur){\n    \n    float m = TaperBox(uv, .03, .03, -.05, .25, blur);\n\tm += TaperBox(uv, .2, .1, .25, .5, blur);\n\tm += TaperBox(uv, .16, .07, .5, .75, blur);\n\tm += TaperBox(uv, .12, .0, .75, 1., blur);\n    \n    float shadow = TaperBox(uv - vec2(.2,.0), .1, .5, .17, .25, blur);\n    shadow += TaperBox(uv + vec2(.25,.0), .1, .5, .45, .5, blur);\n    shadow += TaperBox(uv - vec2(.3,.0), .1, .5, .7, .75, blur);\n    \n    \n    col -= shadow * 0.75;\n    \n    return(vec4(col, m));\n}\n\nfloat GetHeight(float x){\n    return sin(x*.423) + sin(x+.1)*.3;\n}\n\nvec4 Layer(vec2 uv, float blur){\n    vec4 col;\n\tfloat id = floor(uv.x);\n    float n = fract(sin(id*234.12)*(4663.3))*2.-1.;\n    float x = n * .3;\n    float y = GetHeight(uv.x);\n    \n    float ground = S(blur, -blur, uv.y+y);\n    col += ground;\n    \n    y = GetHeight(id+.5+x);\n    \n    uv.x = fract(uv.x) - .5;\n   \tvec4 tree = Tree((uv-vec2(x,-y))*vec2(1,1.+n*.2), vec3(1), blur);\n    \n    col = mix(col, tree, tree.a);\n    col.a = max(ground, tree.a);\n    \n    return col;\n}\n\nfloat Hash21(vec2 p){\n \tp = fract(p*vec2(234.45, 765.34));\n    p += dot(p, p+547.123);\n    return fract(p.x*p.y);              \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blur = .005;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    float t = iTime*.3;\n    \n        \n    float twinkle = dot(length(sin(uv+t*.3)), length(cos(uv*vec2(22,6.7)-t*.3)));\n    twinkle = sin(twinkle*10.)*.5+.5;\n    float stars = pow(Hash21(uv*2.), 75.) * twinkle;    \n    vec4 col = vec4(stars);\n    \n    float moon = S(.01, -.01, length(uv-vec2(.4, .2))-.15);\n    col *= 1.-moon;\n    moon *= S(-.01, .075, length(uv-vec2(.5, .25))-.15);\n\tcol += moon;\n    \n   \tvec4 layer;    \n    \n    for(float i=0.; i<1.; i+=1./10.){\n        float scale = mix(30., 1., i);\n        blur = mix(.1, .005, i);\n        layer = Layer(uv*scale+vec2(t+i*100., i)-M, blur);\n        layer.rgb *= (1.-i)*vec3(.9,.9,1.);\n        col = mix(col, layer, layer.a);\n    }           \t\n    layer = Layer(uv+vec2(t, 1)-M, .07);\n    col = mix(col, layer*.07, layer.a);\n\n\n    float thickness = 1./iResolution.y;\n    //if(abs(uv.x)<thickness) col.g = 1.;\n    //if(abs(uv.y)<thickness) col.r = 1.;\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 113, 113, 312], [314, 314, 355, 355, 823], [825, 825, 850, 850, 891], [893, 893, 925, 925, 1368], [1370, 1370, 1391, 1391, 1499], [1501, 1501, 1558, 1558, 2622]]}
{"id": "wlG3Wy", "name": "HexTorus", "author": "NivBehar", "description": "HexTorus\nPlay with the mouse to change the torus's mood ;)", "tags": ["raymarching", "torus", "spiral", "hexagons"], "likes": 21, "viewed": 329, "published": "Public", "date": "1579745708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200. // max steps for ray marching\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\n\nvec3 torus1Pos() {return vec3(0.,0.,0.);}\nvec2 torus1Size() {return vec2(45.3,17.5);} //45.3 17.5\n\nfloat torusRotSpeed() {return time;}\nfloat inOut = -1.; // -1 inside torus, 1 outside torus\n\nvec2 hexCoordsMul = vec2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nvec3 spherePos() {return vec3(0, 2.5, 40.) \n                         + 12.*vec3(0., sin(pow(cos(0.75*time),2.)*cos(1.125*time)), 0.)\n                         + 0.*2.*vec3(sin(time*0.4), 0., cos(time*0.4));}\nfloat sphereRad() {return 6.;}\nvec3 spherePosNew(vec3 p, vec3 spherePos)\n{\n    vec3 spherePosNew = RotZ(spherePos, time); // rotate around the torus\n    spherePosNew = RotY(spherePosNew, time);\n    // rotate around itself\n    spherePosNew = RotZ(p - spherePosNew, time);\n    spherePosNew = RotY(spherePosNew, time);\n    return spherePosNew;\n}\n\nvec3 camerapos() {return vec3(0., 2.5, 60.);}\nvec3 cameralookat() {return vec3(15.*cos(time*0.582),35.*sin(time*0.298),0.);}\nvec3 LightPos()\n//{   \n//    float a = 40.;   \n//    return vec3(sin(time)*a,2.5,cos(time)*a);\n//}\n{return camerapos()+vec3(0.,0.,5.);} //vec3(35*sin(time), 15, 35*cos(time)); //vec3(0,1.7 + 1.3*sin(0.3*q26),0); //vec3(sin(q26*4 + time*0.5)*8, 10 + 4*sin(time),cos(q26*2.5 + time*0.3)*8); //camerapos + 0*vec3(sin(time)*5,4,cos(time)*5) + 0*vec3(0,4.5 + 0*2.4*sin(time*0.3),0);\n\nvec3 lum(vec3 col)\n{\n    float gray = 0.2989 * col.x + 0.5870 * col.y + 0.1140 * col.z;\n    return vec3(gray);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n// Hash function by BigWings\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n// Hexagon Coords by BigWings\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec3 Hive(vec2 UV, float a)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y); // inside each hexagon (without the edges)\n    \n    // waves based on hexagon's ID\n    float b1 = 0.5 + 0.43*sin(hc.z*5. + hc.w*3. + 4.*time);\n    // Spirals on each hexagon\n    float b2 = 0.5 + 0.5*cos(hc.x*10. + hc.y*45. + 8.*time);\n    \n    //vec4 ehc = HexCoords((hc.xz+0.1*vec2(0., time))*3.*vec2(2.0693,2.5) + 100. + vec2(4.,0.));\n    //float hexagons = smoothstep(0.,0.01, ehc.y)*mod(ehc.z,2.)*mod(ehc.w,2.);\n    //float b3 = b1*(1.-hexagons);\n\n    float everyOtherTile = mod(floor(hc.z),2.);\n\n    float edges = 1.-c;\n    float eSquares = cos(hc.y*20. + time)*sin(hc.x*20. + time); // edges squares\n    eSquares = smoothstep(0.,0.01,eSquares);\n    float b4 = edges * eSquares; \n\n    // bottom color\n    vec3 col1 = b2*(1.-b1)*c*vec3(0.4274,0.847,0.8941) // azur color for the inverse of the waves\n          + b1*c*vec3(0.4078,0.1725,0.0705)  // brown color for the waves\n          + vec3(b1,0,(1.-b1))*c*0.2          // add some rg colors to the waves and to the inverse of them\n          + b4*vec3(0.8431,0.7607,0.5019);   // brown-ish color for the edges of each hexagon\n    // top color\n    vec3 col2 = b2*(1.-b1)*c*vec3(0.4745,0.3705,0.9039) //  purple color for the inverse of the waves\n          + b1*c*vec3(0.8431,0.7607,0.5019)  // brown color for the waves\n          + vec3(b1,0,(1.-b1))*c*0.08          // add some rg colors to the waves and to the inverse of them\n          + b4*1.3;   // white color for the edges of each hexagon\n    \n    col = mix(col1,col2, a);\n    \n    //vec3 test = vec3(hc.zw*0.005,0.);//everyOtherTile;\n    \n    vec3 woodTex = texture(iChannel0, UV*0.2).xyz;\n    return (woodTex*col+0.7*col);\n}\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\nfloat sdTorus1(vec3 p, vec2 r, float a) {\n    float torusDist = length( vec2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    vec2 tUV = GetTorusUV(p, torus1Size());   \n    vec4 h = HexCoords(tUV*hexCoordsMul + hexCoordsAdd + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.1,h.y) - 0.4*smoothstep(0.1,0.2,h.y);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = inOut*hexTorus;\n    \n    float toreturn;\n    if(a == 1.)\n        toreturn = holesTorus;\n    else \n        toreturn = hiveTorus;\n    return toreturn;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r, float a)\n{\n    vec2 sUV = GetSphereUV(p, r);\n    vec4 h = HexCoords(sUV*vec2(6.,3.3) + 100.);\n    float sphereDist = length(p)-r;\n    float hive = -0.25*smoothstep(0.,0.1,h.y) + 0.4*smoothstep(0.1,0.2,h.y);\n    float HexSphere = sphereDist + hive; // + 0.3*h.y*sin(h.y*15. + time) - h.y\n    return a==1. ?  HexSphere : max(-sphereDist,HexSphere);\n}\nvec2 GetDist(vec3 p, float a)\n{\n    vec2 distToReturn; \n\n    // torus\n    vec3 torusPosNew = RotY(p - torus1Pos(), time);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size(), a);\n    float torusID = 1.;\n\n    // a big black sphere around the scene\n    float worldDist = -sdSphere(p, 200., 0.); // I did this because I dont want to discard\n    float worldID = 2.;                   // the pixels that doesnt intersect with the torus, \n                                          // unless - the line in the middle will look odd    \n    // a sphere inside the torus\n    vec3 spherePosNew = spherePosNew(p, spherePos());\n    float sphereDist = sdSphere(spherePosNew, sphereRad(), a);\n    float sphereID = 3.;\n\n    float dist = min(torusDist, sphereDist);\n    dist = min(dist,-worldDist);\n\n    if(dist == torusDist)\n        distToReturn = vec2(dist, torusID);   \n    if(dist == worldDist)\n        distToReturn = vec2(dist, worldID); \n    if(dist == sphereDist)\n        distToReturn = vec2(dist, sphereID);\n    return distToReturn;\n}\nvec3 RayMarch(vec3 ro, vec3 rd, float steps, float a) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;\n    for(float i = 0.; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p, a);\n        if(dS.x < 0.0001) {break;}\n        dO += dS.x*0.8;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p, float a)\n{\n    float d = GetDist(p, a).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy, a).x, \n                        GetDist(p-e.yxy, a).x, \n                        GetDist(p-e.yyx, a).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 lightpos, float lightpower, float shadowstrength, float steps, float a)\n{\n    //vec3 lightpos = LightPos;\n    //lightpos = camerapos;\n    vec3 l = normalize(lightpos - p);\n    vec3 n = GetNormal(p, a);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    //dif = dot(n,l);\n    float d = RayMarch(p + n*0.2, l, steps, a).x;\n    if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    return dif;\n}\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float a, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p, a);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nvec3 GetCol(vec3 ro, vec3 rd, vec3 p, vec3 d, vec2 a) \n{\n    vec3 ret;\n\tfloat dif = GetLight(p, LightPos(), 1., 1.,  100., a.x); //***\n    float spRef = specularReflection(p, rd, LightPos(), a.x, 0.8, 10.);\n    //float dif = 1.;\n\n    if(d.z == 1.) //torus painting\n    {        \n        vec3 col;\n        vec2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n        col = Hive(tUV*hexCoordsMul+hexCoordsAdd+torusRotSpeed(), a.y);\n        ret = vec3(dif);\n        ret = dif*col;\n    }\n    if(d.z == 2.) // world painting - black\n    {\n        ret = vec3(0.);\n    }\n    if(d.z == 3.) // sphere painting\n    {\n        vec3 col;\n        vec3 spherePosNew = spherePosNew(p, spherePos());\n        vec2 sUV = GetSphereUV(spherePosNew, sphereRad());\n        col = Hive(sUV*vec2(6.,3.3) + 100., 1.-a.y);\n        ret = col*dif;//vec3(dif)*vec3(0.5,0.7,0.9);\n    }\n    ret *= ret*1.5;\n\tret += spRef;\n    \n    return ret;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ret = vec3(0);\n    \n    vec2 uv_temp = uv;\n    \n    uv = RotZ(vec3(uv,0.), 0.4*sin(time*0.368)).xy;\n    \n    vec3 col = vec3(0);\n \n    vec3 lookat = cameralookat();\n\n    float zoom = 0.3;//0.5 + 0.3*sin(time*0.326);\n    vec3 ro = camerapos();\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    // a.x will determine if the pixel will get the torus with the holes\n    // a.y will determine the color \n    vec2 a = vec2(0.,0.);\n    vec2 b = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    if(uv_temp.x > b.x) {a.x = 1.;}\n    if(uv_temp.y > b.y) {a.y = 1.;}\n    \n    vec3 d = RayMarch(ro,rd, MaxSteps, a.x);\n    vec3 p = ro + rd*d.x;\n    \n    ret = GetCol(ro, rd, p, d, a);\n    \n    //ret = dif;\n    //ret = Hive(uv*5.+10.);\n    \n    float mouseClicked = iMouse.w > 0. ? 0.12 : 0.;\n    vec3 vline = exp(-80.*length(uv_temp.x-b.x))*vec3(1.,1.,1.); // vertical line\n    vec3 hline = exp(-80.*length(uv_temp.y-b.y))*vec3(1.,1.,1.); // horizontal line\n    vec3 lineCol = texture(iChannel1,uv_temp*0.05\n                           + mouseClicked*vec2(time*0.5,time)\n                           + vec2(time*0.01, time*0.02)).xyz;\n    lineCol = (lineCol)*3.*vec3(0.8,1.,0.4);\n    ret *= 1.-vline;\n    ret += vline*lineCol;\n    ret *= 1.-hline;\n    ret += hline*lineCol;\n    \n    \n    //ret = line;\n    //ret = lineCol;\n\n    fragColor = vec4(ret,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3Wy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 131, 131, 223], [224, 224, 257, 257, 348], [349, 349, 382, 382, 474], [476, 476, 494, 494, 517], [518, 518, 537, 537, 561], [562, 575, 598, 598, 611], [631, 732, 750, 750, 938], [939, 939, 958, 958, 969], [970, 970, 1013, 1013, 1281], [1283, 1283, 1301, 1301, 1328], [1329, 1329, 1350, 1350, 1407], [1408, 1408, 1508, 1508, 1543], [1544, 1787, 1807, 1807, 1899], [1900, 1900, 1941, 1941, 2029], [2030, 2058, 2081, 2081, 2189], [2190, 2219, 2237, 2237, 2363], [2364, 2394, 2420, 2420, 2705], [2706, 2706, 2735, 2735, 4469], [4470, 4470, 4511, 4511, 4620], [4621, 4621, 4662, 4662, 5197], [5198, 5198, 5256, 5256, 5357], [5358, 5358, 5410, 5410, 5510], [5511, 5511, 5546, 5546, 5670], [5671, 5671, 5714, 5714, 6052], [6053, 6053, 6084, 6084, 7087], [7088, 7088, 7144, 7144, 7375], [7376, 7376, 7409, 7409, 7636], [7637, 7637, 7738, 7798, 8065], [8066, 8066, 8170, 8170, 8623], [8624, 8624, 8680, 8680, 9541], [9542, 9542, 9599, 9599, 11193]]}
{"id": "wlG3zV", "name": "star in a star in a star in a ..", "author": "julianlumia", "description": ":)", "tags": ["star"], "likes": 11, "viewed": 149, "published": "Public", "date": "1579642412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nconst float PI = 3.14159265;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  return (p.y+p.z)*0.735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\n return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d;\n d.x =p.y +10.;\n for(int i=0; i<5; i++)\n {\n  p = abs(p);\n // p = rotate( normalize( vec3(2. ,0.,2. ) ), sin(59.*0.2)*100.)*p;\n   p = rotate( normalize( vec3(1.3 ,-.1,2. ) ), sin(59.*0.2)*80.)*p;\n  vec2 dbox = vec2(sdOctahedron( p- vec3(-0.,0,abs(sin(p.z-iTime)*2.)),1.),1.);\n  if( dbox.x < d.x)\n  {\n   g1 +=3./(0.6+pow(abs(dbox.x),10.));\n   d = condmin( d,dbox);\n  }\t\n }\n return d ;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);  \nfor (int i=0; i<64; i++) \n {   \n  h = GetDist(ro + t.x * rd);   \n  if(h.x<0.001||abs(t.x)>70.) break;\n  t.x+=h.x *.6;\n  t.y=h.y;\n }\n if(t.x>70.) \n t.x=.0;\nreturn t;\n}\n\n\nvec3 GetNormal(vec3 p){\n vec2 d = GetDist(p);\n vec2 e = vec2(0.001,0);\n vec3 n = d.x - vec3(\n GetDist(p-e.xyy).x,\n GetDist(p-e.yxy).x,\n GetDist(p-e.yyx).x);\n return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime),cos(iTime),0.);\n vec3 l = normalize(lightPos-p);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*.001*1., l);\n if (d.x<length(lightPos-p)) dif *= .01;\n return dif;       \n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 col = vec3(0);  \n vec3 ro = vec3(-3, -10., 1.);\n ro.yz *= Rot(-m.y*3.14+1.);\n ro.xz *= Rot(-m.x*6.2831);\n ro.xy *= Rot(cos(iTime*0.1)*3.14+2.);\n //ro.xz *= Rot((cos(iTime*0.1))*3.2831-0.1);   \n vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n vec2 d = RayMarch(ro, rd);   \n float t =d.x *1.;   \n if(t>0.){\n vec3 p = ro + rd *t;\n vec3 baseColor = vec3(1.,1.,0.);\n if(d.y==1.) baseColor=vec3(sin(p.z+iTime)+1.,1.,1.);\n float dif = GetLight (p); \n col = vec3(dif);  \n col+=baseColor; \n float fog = 1. / (1. + t * t * .004);\n col *= vec3(fog);   \n }\n vec3 sky = vec3(1., 1., 1.);\n col = mix(sky, col, 0.84/(d.x/100.*.9+1.)); \n col *=g1*vec3(.001);\n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlG3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 139, 139, 503], [506, 506, 544, 544, 575], [577, 577, 596, 596, 663], [665, 665, 706, 706, 791], [794, 794, 832, 832, 900], [913, 913, 935, 935, 1329], [1331, 1331, 1364, 1364, 1554], [1557, 1557, 1580, 1580, 1737], [1739, 1739, 1763, 1763, 2013], [2015, 2015, 2057, 2057, 2211], [2213, 2213, 2270, 2270, 3032]]}
{"id": "wlGGDc", "name": "Corridors of Galaxies", "author": "zovox", "description": "Corridors of Galaxies.", "tags": ["galaxies", "corridors"], "likes": 6, "viewed": 371, "published": "Public API", "date": "1580063525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\n\nvec4 galaxy(vec2 uv)\n{\n\tuv *= 5.0;\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux(time+seedling), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n    final *= 2.0;\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i != 0)\n        {\n\t\t\thit += galaxy(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n            \n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n\n        }\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n\n    hit = hit;\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = hit;\n}\n", "image_inputs": [{"id": "Mtj3z1", "previewfilepath": "https://soundcloud.com/majorleaguewobs/space-odyssey-2001-theme-trap-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/majorleaguewobs/space-odyssey-2001-theme-trap-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 1215, 1237, 1237, 1411], [1413, 1413, 1442, 1442, 1512], [1514, 1514, 1543, 1543, 1627], [1629, 1629, 1697, 1697, 1780], [1782, 1782, 1808, 1808, 2015], [2017, 2017, 2083, 2083, 2691], [2692, 2692, 2764, 2764, 2815], [2817, 2817, 2929, 2929, 3667], [3668, 3668, 3691, 3691, 3794], [3796, 3796, 3816, 3816, 4194], [4222, 4222, 4244, 4244, 4986], [4987, 4987, 5044, 5044, 8240]]}
{"id": "WlGGDw", "name": "Moving 2d light", "author": "mosaic", "description": "modified from https://www.shadertoy.com/view/tlV3Wh", "tags": ["2d"], "likes": 3, "viewed": 65, "published": "Public", "date": "1579035982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.5,0.5);\n\n    // Calculate torus\n    const float speed = 3.0;\n    const float freq  = 30.0;\n    \n    float wave_pattern = sin(iTime*(-speed)+length(uv)*freq);\n    float light = length(freq*tan(iTime)*uv-1.5);\n    float gray=wave_pattern/light;  //remove wave_pattern/ from here to see light by itself\n    \n    vec3 col = vec3(gray,gray,gray*.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 557]]}
{"id": "wlGGRR", "name": "Wind Waker Water (Voronoi)", "author": "onlinerocker", "description": "Tried my best to emulate the water from Wind Waker using a Voronoi pattern...\nIt's not exactly the same, but I think I got pretty close.\n\nlet me know what you think!\n", "tags": ["voronoi", "water"], "likes": 6, "viewed": 218, "published": "Public", "date": "1578113304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat random(float pos, float range, float start)\n{\n \treturn start + mod(sin(pos*3.43)*23432.4, range);   \n}\n\nvec2 random(vec2 pos, vec2 range, vec2 start)\n{\n    float newX = sin(dot(pos, vec2(32.1232, 7.324)))*23432.4;\n    float newY = cos(dot(pos, vec2(432.23, 21.4)))*32145.4;\n    \n    newX = start.x + mod(newX, range.x);\n    newY = start.y + mod(newY, range.y);\n    \n    return vec2(newX, newY);\n}\n\nfloat floatRandom(vec2 pos, float range, float start)\n{\n    float val = cos(dot(pos, vec2(54.54, 6.766)))*12344.4;\n\tval = start + mod(val, range);\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    vec3 waterCol = vec3(0, 0.5, 1.0);\n    \n    float minDist = 100.0;\n    float minDist2 = 100.0;\n    float d;\n    float scale = 5.0;\n    \n    \n    vec2 newUv = scale*uv;\n    float z = 1.0+(0.5 + 0.5*sin(newUv.y/2.0 + 1.5*iTime)/5.0);\n    \n\tnewUv /= z;\n    \n    vec2 frac = mod(newUv+vec2(0.5, 0.5), 1.0);\n   \tvec2 id = floor(newUv);\n    \n    vec2 newId, newId2;\n    \n    for(float x=-1.0; x<=1.0; x++){\n        for(float y=-1.0; y<=1.0; y++){   \n     \t\tvec2 off = vec2(x,y);\n            vec2 offId = id+off;\n            vec2 posOff = offId;\n            \n            posOff += random(posOff, vec2(1.0), vec2(0.0));\n            posOff.y += 0.1*sin(frac.x * PI);\n            posOff.x += 0.1*sin(frac.y * PI);\n            \n\n            d = length(posOff - newUv);\n\n            \n            if(d < minDist)\n            {\n                minDist2 = minDist;\n                newId2 = newId;\n                \n                minDist = d;\n            \tnewId = offId;\n            }else if(d < minDist2)\n            {\n                minDist2 = d;\n                newId2 = offId;\n            }\n       \t}\n    }\n    \n    float val = smoothstep(0.05, 0.08, minDist2-minDist);\n    col = mix(waterCol/2.25, waterCol/2., val);\n    \n    minDist = 100.0;\n    minDist2 = 100.0;\n    //uv+=iTime*0.1;\n    newUv = scale*uv;\n    newUv += vec2(5.0, 0.0);\n\tnewUv /= z;\n    \n    frac = mod(newUv+vec2(0.5, 0.5), 1.0);\n   \tid = floor(newUv);\n    \n    newId, newId2;\n    \n    for(float x=-1.0; x<=1.0; x++){\n        for(float y=-1.0; y<=1.0; y++){   \n     \t\tvec2 off = vec2(x,y);\n            vec2 offId = id+off;\n            vec2 posOff = offId;\n            \n            posOff += random(posOff, vec2(1.0), vec2(0.0));\n            posOff.y += 0.1*sin(frac.x * PI);\n            posOff.x += 0.1*sin(frac.y * PI);\n            \n\n            d = length(posOff - newUv);\n\n            \n            if(d < minDist)\n            {\n                minDist2 = minDist;\n                newId2 = newId;\n                \n                minDist = d;\n            \tnewId = offId;\n            }else if(d < minDist2)\n            {\n                minDist2 = d;\n                newId2 = offId;\n            }\n       \t}\n    }\n    \n    val = smoothstep(0.05, 0.06, minDist2-minDist);\n    col += mix(vec3(1), waterCol/2., val);\n    \n\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 77, 77, 134], [136, 136, 183, 183, 428], [430, 430, 485, 485, 594], [596, 596, 653, 653, 3050]]}
{"id": "wlGGRt", "name": "SphereGlitch", "author": "johannprell", "description": "Based on Art Of Code Youtube tutorial.\nRaymarching sphere with some glitchy animated values.", "tags": ["raymarching", "glitch"], "likes": 1, "viewed": 79, "published": "Public", "date": "1579596470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    float t = iTime;\n    float intensity = sin(iTime*.1);\n    return d+(sin(p.x*iTime)*intensity)*(cos(p.y*iTime*.2)*intensity); // makes sphere glitch out\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n \tfloat dO = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO*(cos(iTime*.1));\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*.6;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l); // shadow\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    float t = iTime;\n    \n    vec3 ro = vec3(0, 2, 2);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.18, 1));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n\tcol = mix(vec3(dif), vec3(p), sin(t*.5)*.1); // creates some weird colors\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 91, 91, 400], [402, 402, 436, 436, 659], [661, 661, 685, 685, 866], [868, 868, 892, 892, 1196], [1198, 1198, 1255, 1255, 1649]]}
{"id": "wlGGRy", "name": "Simple Perspective Grid", "author": "izutionix", "description": " ", "tags": ["grid", "perspective"], "likes": 9, "viewed": 311, "published": "Public", "date": "1579194549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float d = 1./abs(uv.y); //depth\n    vec2 pv = vec2(uv.x*d, d); //perspective\n    pv.y += iTime; //offset\n    pv *= 2.; //scale\n    \n#if 0\n    // my anti-aliasing attempt\n    pv = abs((fract(pv)-.5)*2.); //grid vector\n    float b = 10./iResolution.y*d; //blur\n    float t = .02; //thickness\n    float g = 1.-smoothstep(t-b,t+b,pv.x)*smoothstep(t-b,t+b,pv.y); //grid\n    \n    vec3 col = vec3(g/d);\n#else\n    // better version by iq:\n    // http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n    pv += 0.5;\n    const float N = 64.0;\n    vec2 w = fwidth(pv) + 0.001;\n    vec2 a = pv + 0.5*w;\n    vec2 b = pv - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-floor(b)-min(fract(b)*N,1.0))/(N*w);\n    float g = i.x + i.y - i.x*i.y;\n    \n\tvec3 col = vec3(g);\n#endif    \n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 951]]}
{"id": "wlGGW3", "name": "Knotted Hyper/Epitrochoid", "author": "hiogawa", "description": "What I call \"Knotted Hyper/Epi-Trochoid\". Tring to show depth by changing size of point, but not really good.\nThis one was the base for https://www.shadertoy.com/view/Wty3Dc.", "tags": ["2d", "epitrochoid", "hypertrochoid"], "likes": 5, "viewed": 206, "published": "Public API", "date": "1580024434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Knotted Hyper/Epi-Trochoid\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 1.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 2.2;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\nconst float EPI_OR_HYPER = kEpi;\nfloat NUM_SYMMETRY = 4.0;\nconst float NUM_POINTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat POINT_RADIUS = M_PI / NUM_POINTS * (EPI_OR_HYPER == kEpi ? 2.0 : 0.9);\nvec4  TROCHOID_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\n// TODO:\n// - reduce loop by taking symmetry into account\n// - for higher n, there is different kind of qualitative change (e.g. intersection with neighbor).\n//\nfloat signedDistanceToKnottedTrochoidPoints(\n    vec2 p, float trochoid_type, float knotness, float num_symmetry,\n    float num_points, float point_radius, float knot_offset) {\n\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (trochoid_type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (trochoid_type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  float min_distance = 1000.0;\n  for (float i = 0.0; i < num_points; i++) {\n    float t = 2.0 * M_PI * i / num_points;\n    vec3 q; {\n      if (trochoid_type == kHyper) {\n        q = vec3(\n          // usual hyper-trochoid formula\n          (r1 - r2) * cos(t) + r3 * cos((1.0 - num_symmetry) * t),\n          (r1 - r2) * sin(t) + r3 * sin((1.0 - num_symmetry) * t),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n      if (trochoid_type == kEpi) {\n        q = vec3(\n          // usual epi-trochoid formula\n          (r1 + r2) * cos(t) + r3 * cos((1.0 + num_symmetry) * t - M_PI),\n          (r1 + r2) * sin(t) + r3 * sin((1.0 + num_symmetry) * t - M_PI),\n          // knot by waving z coord along symmetry\n          sin(num_symmetry * (t + knot_offset)));\n      }\n    }\n    float radius = point_radius * mix(0.6, 1.0, q.z);\n    float sd = distance(p, q.xy) - radius;\n    if (sd < min_distance) {\n      min_distance = sd;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Hyper/Epi-Trochoid\n    float knotness = 3.0 * (0.5 + 0.5 * sin(t));\n    float knot_offset = 0.0; // not used now\n    float sd = signedDistanceToKnottedTrochoidPoints(\n        uv, EPI_OR_HYPER, knotness, NUM_SYMMETRY, NUM_POINTS, POINT_RADIUS, knot_offset);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, TROCHOID_COLOR.xyz, TROCHOID_COLOR.w * coverage);\n  }\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 1051, 1227, 1227, 2605], [2608, 2623, 2676, 2676, 2919], [2921, 2921, 2971, 2971, 3216], [3218, 3218, 3293, 3293, 3372], [3375, 3390, 3444, 3444, 4322]]}
{"id": "wlGGWh", "name": "Psychodelic First Shader", "author": "wobbumash", "description": "Just some overlaying of many different effects to grasp how to blend and create effects.", "tags": ["newbie", "learning", "firstshader", "firststudy"], "likes": 1, "viewed": 62, "published": "Public", "date": "1578777253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 UV = fragCoord.xy / iResolution.xy;\n    \n   \tfloat XRed = pow(abs((-UV.x + 0.5) * abs(sin(iTime))), 0.25);\n    float YRed = pow(abs((-UV.y + 0.5) * abs(sin(iTime))), 0.25);\n    \n    float XRedB = pow(abs((-UV.x + 0.25) * abs(sin(iTime))), 0.25);\n    float YRedB = pow(abs((-UV.y + 0.25) * abs(sin(iTime))), 0.25);\n    \n    float XRedC = pow(abs((-UV.x + 0.75) * abs(sin(iTime))), 0.25);\n    float YRedC = pow(abs((-UV.y + 0.75) * abs(sin(iTime))), 0.25);\n    \n    float XBlue = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 2.0))), 0.25);\n    float YBlue = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 2.0))), 0.25);\n    \n    float XBlueB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 2.0))), 0.25);\n    float YBlueB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 2.0))), 0.25);\n    \n    float XBlueC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 2.0))), 0.25);\n    float YBlueC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 2.0))), 0.25);\n    \n    float XGreen = pow(abs((-UV.x + 0.5) * abs(sin(iTime * 4.0))), 0.25);\n    float YGreen = pow(abs((-UV.y + 0.5) * abs(sin(iTime * 4.0))), 0.25);\n    \n    float XGreenB = pow(abs((-UV.x + 0.25) * abs(sin(iTime * 4.0))), 0.25);\n    float YGreenB = pow(abs((-UV.y + 0.25) * abs(sin(iTime * 4.0))), 0.25);\n    \n    float XGreenC = pow(abs((-UV.x + 0.75) * abs(sin(iTime * 4.0))), 0.25);\n    float YGreenC = pow(abs((-UV.y + 0.75) * abs(sin(iTime * 4.0))), 0.25);\n    \n    float FinalRedX = XRed * XRedB * XRedC;\n    float FinalRedY = YRed * YRedB * YRedC;\n    \n    float FinalGreenX = XGreen * XGreenB * XGreenC;\n    float FinalGreenY = YGreen * YGreenB * YGreenC;\n    \n    float FinalBlueX = XBlue * XBlueB * XBlueC;\n    float FinalBlueY = YBlue * YBlueB * YBlueC;\n    \n    float FinalRed = FinalRedX * FinalRedY;\n    float FinalGreen = FinalGreenX * FinalGreenY;\n    float FinalBlue = FinalBlueX * FinalBlueY;\n    \n    float HorizontalOverlay = abs(sin(((UV.x * 3.141592) * 400.0)));\n    float VerticalOverlay = abs(sin(((UV.y * 3.141592) * 225.0)));\n    \n    vec4 FirstPass = vec4(1.0 - FinalRed, 1.0 - FinalGreen, 1.0 - FinalBlue, 1.0);\n    vec4 SecondPass = vec4(HorizontalOverlay, HorizontalOverlay, HorizontalOverlay, 1.0);\n    vec4 ThirdPass = vec4(VerticalOverlay, VerticalOverlay, VerticalOverlay, 1.0);\n    \n    fragColor = FirstPass * SecondPass * ThirdPass;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2368]]}
{"id": "wlK3DD", "name": "A Colorful Hallway", "author": "zheck", "description": "Another very pointless shader to add to the collection! Thanks to iq for the hallway https://www.shadertoy.com/view/XsX3Rn", "tags": ["rainbow"], "likes": 4, "viewed": 111, "published": "Public", "date": "1579025402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define colorWidth        0.1  // Ranges from 0.0 to 1.0\n#define colorCenter       0.7  // Ranges from 0.0 to 1.0\n#define repetition        5.0  // Ranges from 1.0 to infinity (starts to look ridiculous past 20)\n#define colorShiftSpeed   10.0 // Frequency at which colors \"move\"\n#define direction         1.0  // Positive makes colors shift away from you, negative towards you\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0+2.0*fragCoord/iResolution.y;\n    \n    float an = iTime*0.1;\n    \n    p = mat2(cos(an),-sin(an),sin(an),cos(an)) * p;\n     \n    vec2 uv = vec2(p.x,1.0)/abs(p.y) + iTime;\n\t\n\tfragColor = vec4( texture(iChannel0,uv).xyz*abs(p.y), 1.0);\n    \n    float average = (fragColor.r + fragColor.g + fragColor.b) / 3.0;\n    average *= repetition * direction;\n\tfloat red = sin(iTime * colorShiftSpeed + average + 2.0) * colorWidth + colorCenter;\n\tfloat green = sin(iTime * colorShiftSpeed + average + 0.0) * colorWidth + colorCenter;\n\tfloat blue = sin(iTime * colorShiftSpeed + average + 4.0) * colorWidth + colorCenter;\n\tfragColor = vec4(red, green, blue, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 435, 435, 1103]]}
{"id": "wlK3Dw", "name": "RaymarchTest_Honorfil", "author": "Honorfil", "description": "raymarch test", "tags": ["raymarch"], "likes": 3, "viewed": 73, "published": "Public", "date": "1579155596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nmat2 GetRot(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat smoothMin(float p1, float p2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (p2 - p1) / k,0., 1.);\n    return mix(p2, p1, h) - k * h * (1.0-h);\n}\n\nfloat BoxDist(vec3 p, vec3 s)\n{\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p)\n{\n    float t = iTime * .5;\n    \n    vec4 s1 = vec4(cos(t)*0.1 + 1.1, 1, 6, 1);\n    vec4 s2 = vec4(-cos(t)*0.1 - 1.1, 1, 6, 1);\n    vec4 s3 = vec4(0, 1. + cos(t) + 0.1, 5.2 , 0.4);\n    \n    vec3 boxPos = p - vec3(0,1,6);\n    boxPos.xz *= GetRot(t);\n    boxPos.xy *= GetRot(-t);\n    \n    float sd1 = length(p - s1.xyz) - s1.w;\n    float sd2 = length(p - s2.xyz) - s2.w; \n    float sd3 = BoxDist(boxPos, vec3(.5)); \n    float pd = p.y;\n    \n    float s21Min = smoothMin(sd1, sd2, .15);\n    float s21_3Min = smoothMin(sd3, s21Min, .3);\n    \n    return min(pd, s21_3Min);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, .0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p - e.xyy),\n    \tGetDist(p - e.yxy),\n    \tGetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * d0;\n            float ds = abs(GetDist(p));\n            d0 += ds;\n            if (d0 > MAX_DIST || ds < SURF_DIST)\n            {\n                break;\n            }\n        }\n    \n    return d0;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(2, 5, 1);\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float distToLight = RayMarch(p + n * SURF_DIST * 2., l);\n    if (p.y<.01 && distToLight < length(p - lightPos))\n    {\n        diff *= 0.4;\n    }\n\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize (vec3(uv.x, uv.y - 0.2, 1));\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    vec3 col = vec3(0.8, 0.7, 0.9);\n    \n    fragColor = vec4(vec3(dif),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 94, 94, 183], [185, 185, 231, 231, 333], [335, 335, 366, 366, 447], [449, 449, 472, 472, 1040], [1042, 1042, 1066, 1066, 1257], [1259, 1259, 1293, 1293, 1595], [1597, 1597, 1621, 1621, 1949], [1951, 1951, 2008, 2008, 2320]]}
{"id": "WlK3W3", "name": "Tree Fractal", "author": "zovox", "description": "Tree Fractal", "tags": ["fractal", "tree"], "likes": 4, "viewed": 301, "published": "Public API", "date": "1580063872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n//--------------------------------------------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\n\nvec2 saw(vec2 x) { return vec2(saw(x.x), saw(x.y)); }\nvec3 saw(vec3 x) { return vec3(saw(x.x), saw(x.y), saw(x.z)); }\nvec4 saw(vec4 x) { return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w)); }\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\nfloat draw(vec2 uv)\n{\n    return (1.-smoothstep(0., .1, abs(uv.x-.5)))*(1.-smoothstep(0.9, 1., abs(uv.y)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy)/iResolution.xy;//*2.-1.;\n    p.x = p.x*2.-1.;\n    p.x *= iResolution.x/iResolution.y;\n\tp.x = p.x *.5+.5;\n    \n    vec3 col = vec3(0.);\n\n    const float max_iterations = 16.;\n    \n    float map = 0.;\n    map += draw(p);\n    for(float f = 0.; f < max_iterations; f+=1.){\n        float iteration = (f/max_iterations+1.);\n        float angle = (time*iteration)/PI-1.*PI/4.;//floor(((angle/PI)*.5+.5)*rots);\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 0.);\n        \n        p = p*2.-1.;\n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(.5, 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\n        \n        /*\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n            \n\n        \n        //map += 1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.x+p.y)));\n        map += draw(p)*iteration;//1.-smoothstep((f)/max_iterations, (f+1.)/max_iterations, (abs(p.y-.5)));\n    }\n\n    fragColor = vec4(flux(map*PI)*clamp(map, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 362, 382, 382, 487], [489, 489, 507, 507, 542], [543, 543, 561, 561, 606], [607, 607, 625, 625, 680], [683, 683, 705, 705, 753], [755, 755, 794, 794, 822], [824, 824, 899, 899, 1871], [1873, 1873, 1894, 1894, 1982], [1983, 1983, 2040, 2040, 3620]]}
{"id": "WlK3WV", "name": "Acid trip at the gay bath house", "author": "timeisbeautifulhere", "description": "( ͡° ͜ʖ ͡°)", "tags": ["circle", "moving"], "likes": 0, "viewed": 37, "published": "Public", "date": "1579917102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float CIRCLE_RADIUS = 0.1;\nconst float CIRCLE_SPEED = 0.5;\nconst float CIRCLE_Y = 0.5;\n\n/*\nCircle moves at a constant speed from the left side of\nthe screen to the right side, changing direction\nwhen it hits one side.\n\nPosition normalized to [0,1]\n*/\nvec2 circlePosition(float time){\n    \n    float dist = time * CIRCLE_SPEED;\n    \n    float distInt = floor(dist);\n    \n    bool isRight = int(distInt) % 2 == 0;\n    \n    float circleX = isRight? (dist - distInt) : 1.0 - (dist - distInt);\n    \n    return vec2(circleX, CIRCLE_Y);\n}\n\nbool isInCircle(vec2 coord, vec2 circleCoord, float circleR){\n    return distance(circleCoord, coord) < circleR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 circleCoord = circlePosition(iTime);\n    if(isInCircle(uv, circleCoord, CIRCLE_RADIUS)){\n        col = vec3(0.0,0.0,0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 258, 290, 290, 538], [540, 540, 601, 601, 654], [656, 656, 713, 763, 1092]]}
{"id": "wlK3WW", "name": "Color Oscilloscope", "author": "flemmingdjensen", "description": "Testing an oscilloscope effect", "tags": ["oscilloscope", "sin", "cos", "lissajous"], "likes": 1, "viewed": 364, "published": "Public API", "date": "1578994408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Back to good old times when playing with an oscilloscope in X/Y mode\n\n#define S smoothstep\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n        \n    vec2 rp = vec2(cos(iTime*20.5), sin(iTime*20.));\n    vec2 gp = vec2(cos(iTime*15.5), sin(iTime*17.));\n    vec2 bp = vec2(cos(iTime*17.4), sin(iTime*18.));\n    \n    col += vec3(S(.15, .1, distance(uv, rp * .4)), 0., 0.);\n    col += vec3(0., S(.15, .1, distance(uv, gp * .4)), 0.);\n    col += vec3(0., 0., S(.15, .1, distance(uv, bp * .4)));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3WW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 95, 152, 152, 633]]}
{"id": "WlK3Wz", "name": "learn 18", "author": "schlaffi", "description": "Using the tutorial> https://www.youtube.com/watch?v=zfcCHPeDOhU\nbased on> https://www.shadertoy.com/view/lt33z7 ", "tags": ["dwdwq"], "likes": 3, "viewed": 145, "published": "Public", "date": "1578684498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nint MAX_MARCHING_STEPS = 100;\nfloat MIN_DIST = 0.1;\nfloat MAX_DIST = 50.0;\nfloat EPSILON = 0.05;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 sp2 = samplePoint;\n    sp2.x = fract(sp2.x*0.5+1.0)/0.5-1.0;\n    sp2.z = fract(sp2.z*0.5+1.0)/0.5-1.0;\n    return length(sp2) - 0.4;\n}\n\nfloat lightSdf(vec3 samplePoint ) {\n    float l = length(samplePoint);\n    if ( l < 0.3 ) {\n    \treturn l+0.3;\n    } else {\n    \treturn l-0.3;\n    }\n}\n\n\nfloat planeSDF(vec3 sp) {\n\treturn abs(sp.y+cnoise(sp*5.0+iTime*vec3(0,1.0,0.0))/20.) ;\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 l1p, vec3 l2p, vec3 samplePoint) {\n    vec3 light1Pos = l1p;\n    \n    vec3 light2Pos = l2p;\n    \n    float stuff[10];\n    stuff[0] = lightSdf(samplePoint-light1Pos);\n    stuff[1] = lightSdf(samplePoint-light2Pos);\n    stuff[2] = sphereSDF(samplePoint);\n    stuff[3] = planeSDF(samplePoint);\n\n    float m=99999.0;\n    float mat=0.;\n    for(int i = 0; i<=3; i++) {\n        if( stuff[i] < m ) {\n            mat = float(i);\n            m = stuff[i];\n        }\n    }\n    \n    return vec2(m, mat);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 l1p, vec3 l2p, vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 depth = vec2(start,0.);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(l1p, l2p, eye + depth.x * marchingDirection);\n        if (dist[0] < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        depth.y=dist.y;\n        if (depth.x >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 l1p, vec3 l2p, vec3 p) {\n    return normalize(vec3(\n        sceneSDF(l1p, l2p, vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(l1p, l2p, vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(l1p, l2p, vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(l1p, l2p, vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(l1p, l2p, vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(l1p, l2p, vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(lightPos, lightPos, p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// light source material\nvec3 lightSource(vec3 lightColor, vec3 lightPos, vec3 p, vec3 eye){\n\treturn lightColor/pow(length(p-lightPos),1.0);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 light1Pos, vec3 light2Pos, vec3 light1Intensity, vec3 light2Intensity) {\n    vec3 color =  k_a;\n\n    \n    color = color + 10.*light1Intensity/pow(length(p-light1Pos),2.0);\n    color = color + 10.*light2Intensity/pow(length(p-light2Pos),2.0);\n    \n    color+=phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    color+=phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \tvec3 light2Pos = vec3(0., 0.8, -5.);\n    \tvec3 light1Intensity = vec3(1., 0.4, 0.1);\n    \tvec3 light2Intensity = vec3(.0, .3, .1);\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 1.5 , 9.0);\n    vec2 dist = shortestDistanceToSurface(light1Pos, light2Pos, eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 initColor = vec3(uv, 1.0-uv.y);\n\n    vec3 color = initColor;\n\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n    } else {\n\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 p = eye + dist.x * dir;\n\n        vec3 K_a = vec3(0.5, 0.1, 0.1);\n        vec3 K_d = vec3(0.7, 0.5, 0.4);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 200.0;\n\t\t\n\n        \n        //color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n        float f = fract(1.-dist.x/MAX_DIST)*0.6;\n        color = mix(vec3(0.), mix( vec3(1., 0., 0.), mix(vec3(1., 1., 0.), vec3(1., 1., 1.),f*3.-2.), f*3.-1. ), f*3. );\n\n        color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n   \n        color += estimateNormal(light1Pos,light2Pos, p)*0.3;\n    }\n\n\n    float foctor = fract(dist.x/MAX_DIST);\n    color = color*(1.0-foctor)+foctor*initColor;//vec3(1.,.9,.8)/;\n    \n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 499, 520, 520, 557], [558, 558, 585, 585, 633], [634, 634, 653, 653, 689], [691, 691, 712, 712, 2984], [2989, 3078, 3113, 3113, 3257], [3259, 3259, 3294, 3294, 3409], [3412, 3412, 3437, 3437, 3500], [3506, 3746, 3799, 3799, 4258], [4260, 4681, 4791, 4791, 5164], [5179, 5433, 5498, 5498, 5630], [5632, 5721, 5770, 5770, 6152], [6154, 6646, 6786, 6786, 7401], [7403, 7428, 7495, 7495, 7545], [7547, 7919, 8080, 8080, 8447], [8450, 8450, 8507, 8507, 10115]]}
{"id": "wlK3zc", "name": "Dot screensaver", "author": "sbrown2", "description": "I got sidetracked working on a project, this is the result. Really simple, just a set of tiles with animated circles inside each tile. ", "tags": ["2d", "distancefunction", "tile"], "likes": 1, "viewed": 73, "published": "Public", "date": "1579549019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 p, vec2 a, vec2 b){\n\tfloat h = clamp(dot(p-a,b-a)/dot((b-a),(b-a)),0.,1.);\n    return length((p-a)-(b-a)*h);\n    \n}\nfloat rand21(vec2 p){\n\treturn fract(sin(p.y*123.2)*231.4*fract(sin(p.x)*123.142)*123.24);\n\n}\nvec2 rand22(vec2 p){\n    float r1 = rand21(p);\n\treturn vec2(r1,rand21(vec2(r1,r1+32.)));\n}\n\nvec2 tile(vec2 uv, float amount){\n\treturn fract(uv*amount);\n}\n\nfloat circle(vec2 uv, vec2 center){\n\treturn length(uv-center)*1.75;\n}\nfloat GetPos(vec2 id, vec2 inneruv){\nfloat rx = clamp(rand21(id+123.2),.3,.7);\n    float ry = clamp(rand21(id*rx+134.23),.3,.7);\n    \n    float rmx = clamp(rand21(id+978.1),.1,.9);\n    \n    float rmy = clamp(rand21(id+542.8),.1,.9);\n    \n    //draw circle in each square\n    float d = circle(inneruv, vec2(rx,ry)+\n                     (cos(iTime*rmx)*.2*sin(iTime*rmy)));\n\treturn d;    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n //   uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\tvec3 lemon_chiffon = vec3(1.,.95,.9);\n    vec3 col = vec3(0.);\n    \n    vec2 inneruv = tile(uv,5.);\n    vec2 id = floor(uv*5.);\n    uv-=.5;\n\n    //get a random position\n    float d = GetPos(id,inneruv);\n    col+= smoothstep(.1,.09,d)\n                     *clamp(cos(iTime*.4),.4,7.); \n    \n    //color selection\n    if(length(id) < abs(10.*sin(iTime/2.))){\n        col*=vec3(.5+.3*cos(iTime),\n                  .5+.7*cos(iTime),\n                  .5+.5*cos(iTime));}\n    \n    //if(inneruv.x > .98 || inneruv.y > .98) col = vec3(1.);\n    // Output to screen\n\t//col = vec3(rx);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlK3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 131], [132, 132, 153, 153, 224], [225, 225, 245, 245, 315], [317, 317, 350, 350, 378], [380, 380, 415, 415, 449], [450, 450, 486, 486, 838], [839, 839, 896, 946, 1650]]}
{"id": "WlK3zd", "name": "Learning Code [14]", "author": "ozu", "description": "Still trying to figure out uv coordinates :)", "tags": ["time", "line", "uv", "color"], "likes": 2, "viewed": 54, "published": "Public", "date": "1579641849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    vec3 col = vec3 (0.);\n\n    float pix = 1.5 / iResolution.y;\n    \n    //vec2 st = vec2(atan(uv.x, uv.y)*4., length(uv));\n    //uv = vec2(st.x/6.2831, st.y);\n    \n    uv.x += iTime * .2;\n    \n    vec3 d = vec3( sin( ( uv.y - uv.x ) *30. ) );\n    col = smoothstep(pix, 0., d);\n\n    col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlK3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 495]]}
{"id": "WlKGDR", "name": "glass hourglass apollonean", "author": "ollj", "description": "mouse sets somewhat intuitive and hourglass shaped modifiers.\n\nhttps://www.shadertoy.com/view/4slSzj      glass shader\n+\nhttps://www.shadertoy.com/view/XtVfRW      vesica\n\nalso begs for lathe logic of:\nhttps://www.shadertoy.com/view/MlyfRW", "tags": ["glass", "bone", "vesica", "vesica", "lathe", "linb", "appolonean"], "likes": 1, "viewed": 291, "published": "Public API", "date": "1578675291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from: https://www.shadertoy.com/view/ldfXzn\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t7\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t100\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.6\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t1.5\n#define LUMINOSITY_FACTOR\t2.0\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz*ry*rx;\n}\n\nvec3 k;\n\nfloat sdVesica(vec2 p, float r, float d\n){p = abs(p)\n ;float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n ;return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                             : length(p-vec2(-d,0.0))-r;}\n\nfloat getDistance(vec3 p\n){//float a=min(length(p-vec3(0,0,3.5)),length(p))-2.\n ;//float a=sdVesica(vec2(p.y,length(p.xz)),2.,-1.)+1.6\n ;vec2 m=iMouse.xy/iResolution.xy  \n ;//float a=sdVesica(vec2(p.y,length(p.xz)),1.9+m.x,-1.-m.y)+1.5+m.x-m.y\n ;float a=sdVesica(vec2(p.y,length(p.xz)),1.9+m.y*.25+m.x,-1.-m.y)+1.5+m.y*.3-m.y \n ;a=abs(a+.05)\n ;return (a-.05)\n ;}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t}\n\t\telse {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord\n   ){\n\n\t// Define the ray corresponding to this fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    ;frag*=.3;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;\n\n\t// Set the fragment color\n\tfragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 464, 494, 494, 817], [828, 828, 870, 870, 1078], [1080, 1080, 1107, 1158, 1442], [1444, 1444, 1503, 1503, 3804], [3806, 3806, 3865, 3916, 4523]]}
{"id": "WlKGDt", "name": "Four Planets With Moons", "author": "timF", "description": "Weird looking moons spinning around planets. This is only my second real shader and realize this was not done efficiently, but don't know how to do it better!\nI still am learning how to add colors.", "tags": ["raymarching"], "likes": 1, "viewed": 183, "published": "Public API", "date": "1580183934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 30.0\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.0\n#define PI 3.14159265359\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nfloat map(vec3 p){\n \n    vec3 boxPos = p;\n    boxPos.y -= 2.0;\n    \n    float box = sdBox( boxPos, vec3(.5,.2,1.0 ));\n    \n    vec4 pPos = vec4(p,0.0);\n    \n    vec4 planets[4] = vec4[4](pPos,pPos,pPos,pPos);\n    \n    float finalShape = 0.0;\n    \n    float planetShapes[4];\n    \n    float speed = 3.0;\n    \n  \tfloat moonShapes[4];\n    \n    for (int i = 0; i < 4; i++){\n        float iAsFloat = float(i);\n        \n        float randomSpeed = rand(iAsFloat+1.0);\n        \n        \n        float curRotation =  randomSpeed * speed ;\n     \tplanets[i] = rotationMatrix(iTime * curRotation, vec3(0.0,1.0,0.0)) * planets[i];   \n    \tplanets[i].x += 3.0+ iAsFloat*3.0;\n        float newPlanet = sdSphere(planets[i].xyz, .30 * randomSpeed * 2.5);\n\t\n        planetShapes[i] = newPlanet;\n        \n        speed -= .3;\n        \n        vec4 newMoonPos = planets[i];\n        newMoonPos.x += .6* randomSpeed;\n        newMoonPos = rotationMatrix(iTime*20. * randomSpeed, vec3(0.0,1.0,0.0)) * newMoonPos;\n        //newMoonPos += 1.3;\n        //planets[i];\n        \n        \n        \n        newMoonPos = rotationMatrix(iTime*15., vec3(0.0,1.0,0.0))*planets[i]+.7;\n        newMoonPos.y -= 1.0;\n        //newMoonPos = rotationMatrix(iTime, vec3(0.0,1.0,0.0)) * newMoonPos;\n        float newMoon = sdSphere(newMoonPos.xyz, .1);\n        moonShapes[i] = newMoon;\n    }\n    \n    \n\n    float sun = sdSphere(p, 1.50);\n    \n    finalShape = min(planetShapes[0],planetShapes[1]);\n    finalShape = min(sun,finalShape);\n    finalShape = min(planetShapes[2], finalShape);\n    finalShape = min(planetShapes[3], finalShape);\n    \n    // moons\n    finalShape = min(moonShapes[0],finalShape);\n    finalShape = min(moonShapes[1], finalShape);\n    finalShape = min(moonShapes[2],finalShape);\n    finalShape = min(moonShapes[3],finalShape);\n    \n\treturn finalShape;\n}\n\n\nvec3 getNormal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0); //eplison - small offset\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nfloat diffuseLighting(vec3 p) {\n    vec3 lightPosition = vec3(3,9,-3);\n    vec3 light = normalize(lightPosition - p); // normalize the vector\n    vec3 normal = getNormal(p);\n\n    float diffuse = clamp( dot(normal, light), 0., 1.); // percentage of similarity\n    return diffuse;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv.st * 2.0 - 1.0 ; // 0 is the center\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 8.0, -3.5); // change this to change the camera\n    \n    float camOffset = sin(iTime*.2)*-.6-1.0;\n    float camOffsetPos = cos(iTime*.3)*-2.0+.7;//sin(iTime * 5.0);\n    mat4 camRotMat = rotationMatrix(camOffset, vec3(1.0,0.0,0.0));\n    rayOrigin.y -= camOffsetPos;\n    \n    vec3 rayDirection = normalize(camRotMat * vec4(uv, 1.,0.0)).xyz;\n        \n        //normalize();\n    float diffuse;\n    float distanceOrigin = 0.0; // initial distance from cam is 0\n\n    vec3 normal;\n    // you must define a max limit for marching...\n    // good upper limit is 128\n    for ( int i = 0; i < 128; i++ ) {\n\n        // start with camera origin + the incremented value, * ray Direction\n        vec3 position = rayOrigin + distanceOrigin * rayDirection;\n        //formula to create a sphere\n        float map = map(position); // just for naming\n        distanceOrigin += map; // check again after hitting the radius of the sphere\n\n        //set the near and far clipping plane\n        if (distanceOrigin < MIN_DISTANCE || distanceOrigin > MAX_DISTANCE) break;\n        diffuse = diffuseLighting(position);\n\n    }\n\n    distanceOrigin /= 2.; // couldn't see the map, so divide by 2\n\n    vec3 shape = vec3(1,1,1) * diffuse;\n    \n\n    vec4 color = vec4(shape,1);\n\n    // Output to screen\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 136, 136, 160], [162, 162, 193, 193, 280], [282, 282, 327, 327, 955], [957, 957, 977, 977, 1015], [1018, 1018, 1036, 1036, 2849], [2852, 2852, 2875, 2904, 3077], [3079, 3079, 3110, 3110, 3360], [3363, 3363, 3420, 3470, 4932]]}
{"id": "WlKGRm", "name": "Junk Science", "author": "Hotrhodium", "description": "This happened on accident in Unity so i brought it here. Nothing great just a bunch of magic code.", "tags": ["noise", "perlin"], "likes": 2, "viewed": 55, "published": "Public", "date": "1578543715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 MyVec = uv;\n    vec3 col = vec3(1.0);\n    MyVec.x += iTime*0.3;\n    col.r *= fbm(MyVec);\n    MyVec.x += iTime*0.3;\n    col.g *= fbm(MyVec);\n    MyVec.x += iTime*0.3;\n    col.b *= fbm(MyVec);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 1262], [1263, 1263, 1320, 1320, 1590]]}
{"id": "WlKGWh", "name": "3d ray-tetrahedron intsersection", "author": "16807", "description": "Distance field to a tetrahedron. Click the screen to rotate.", "tags": ["raycasting", "tetrahedron", "analytic", "minimal"], "likes": 1, "viewed": 71, "published": "Public", "date": "1578805584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\nFUNC(bool) try_distances_along_line_to_union(\n    IN(bool) is_intersection1, IN(float) entrance1,\n    IN(bool) is_intersection2, IN(float) entrance2,\n    OUT(float) entrance\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(float) get_distance_along_3d_line_to_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\n\nFUNC(bool) try_distance_along_3d_line_to_triangle(IN(vec3) A0, IN(vec3) A, IN(vec3) B1, IN(vec3) B2, IN(vec3) B3, OUT(float) intersection){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3  B0 = (B1 + B2 + B3) / 3.;\n    vec3  N  = normalize(cross(B1-B2, B2-B3));\n    float t  = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3  At = A0+A*t;\n    intersection = t;\n    vec3 B2B1hat = normalize(B2-B1);\n    vec3 B3B2hat = normalize(B3-B2);\n    vec3 B1B3hat = normalize(B1-B3);\n    return dot(normalize(At-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(At-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(At-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n\nFUNC(bool) try_distances_along_3d_line_to_tetrahedron(IN(vec3) A0, IN(vec3) A, IN(vec3) B1, IN(vec3) B2, IN(vec3) B3, IN(vec3) B4, OUT(float) entrance, OUT(float) exit){\n    float x1; bool hit1 = try_distance_along_3d_line_to_triangle(A0,A,B1,B2,B3, x1);\n    float x2; bool hit2 = try_distance_along_3d_line_to_triangle(A0,A,B2,B3,B4, x2);\n    float x3; bool hit3 = try_distance_along_3d_line_to_triangle(A0,A,B3,B4,B1, x3);\n    float x4; bool hit4 = try_distance_along_3d_line_to_triangle(A0,A,B4,B1,B2, x4);\n    float x;  bool hit;\n    hit = try_distances_along_line_to_union(hit1, x1,  hit2, x2, x);\n    hit = try_distances_along_line_to_union(hit,  x,   hit3, x3, x);\n    hit = try_distances_along_line_to_union(hit,  x,   hit4, x4, x);\n    entrance = x;\n    return hit;\n}\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_to_tetrahedron(A0,A, vec3(-1,0,0), vec3(1,0,0), vec3(0,0,1), vec3(0,1,0), a_in, a_out);\n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/3.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 342, 342, 499], [501, 501, 599, 599, 639], [641, 641, 780, 848, 1357], [1359, 1359, 1528, 1528, 2135], [2137, 2137, 2187, 2187, 2815], [2817, 2817, 2874, 2874, 3948]]}
{"id": "WlKGzK", "name": "Sin Interferencia ", "author": "anothergomes", "description": "Study 01", "tags": ["study"], "likes": 4, "viewed": 86, "published": "Public", "date": "1579474192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 center = iResolution.xy / iResolution.x * 0.5;\n    float amplitude = 100.0;\n    \n    // Fade to black and white\n    float p = cos(iTime - distance(uv, center));\n    p -= sin(iTime * 0.5 - distance(uv, center));\n    \n    // Left waves\n    p += sin(iTime - distance(uv, vec2(center.x - 0.25, center.y + 0.25)) * amplitude);\n    p += sin(iTime - distance(uv, vec2(center - 0.25)) * amplitude);\n    \n    // Right waves\n    p += sin(iTime - distance(uv, vec2(center + 0.25)) * amplitude);\n    p += sin(iTime - distance(uv, vec2(center.x + 0.25, center.y - 0.25)) * amplitude);\n    \n    // Output to screen\n    fragColor = vec4(vec3(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 744]]}
{"id": "wlKGzR", "name": "Fractal orbits", "author": "onlinerocker", "description": "Wanted to play around with fractal structures...\nAlso tried to map a Voronoi pattern to some spheres, which turned out more difficult than anticipated ;p", "tags": ["fractal", "voronoi", "noise", "space", "spheretracing", "planets", "raymach"], "likes": 5, "viewed": 160, "published": "Public", "date": "1578345694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n//SETTINGS:\n#define VIEW_DIST 40.0\n#define ITERATIONS 8.0\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n    float glowAmt;\n\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \nvec2 random(vec2 pos, vec2 range, vec2 start)\n{\n    float newX = sin(dot(pos, vec2(32.1232, 7.324)))*23432.4;\n    float newY = cos(dot(pos, vec2(432.23, 21.4)))*32145.4;\n    \n    newX = start.x + mod(newX, range.x);\n    newY = start.y + mod(newY, range.y);\n    \n    return vec2(newX, newY);\n}\n\nfloat floatRandom(vec2 pos, float range, float start)\n{\n    float val = cos(dot(pos, vec2(54.54, 6.766)))*12344.4;\n\tval = start + mod(val, range);\n    return val;\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n//IQ - https://www.shadertoy.com/view/XsX3RB\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n//https://www.shadertoy.com/view/4dS3Wd\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    \n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    //float ang = PI/2.0;\n    float fracAng = iTime/12.0;\n    vec3 objPos = pos - vec3(0.0, -0.0, 0.0); \n    \n     objPos.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * objPos.xz;\n    float dSphere = sdSphere(objPos, 5.0);\n\n    if(dSphere < o.dist){\n        o.dist = dSphere;\n        o.color = mix(vec3(0, 0.2, 0.9)*fbm(objPos/2.0), vec3(.1, .3, .15)*fbm(objPos*1.5), step(0.5, fbm(objPos*1.5)));\n        o.specVal = 8.0;\n        o.specKs = 0.01;\n    }\n    \n    float size = 1.0;\n    //float angFrac = PI/6.0;\n    vec3 posFracOff = vec3(9, 0.0, 10.);\n    \n    vec3 posFrac = objPos - posFracOff;\n    float dDist;\n    float minDist;\n\n\t\n    dDist = sdSphere(posFrac, size);\n    \n    float scale = 2.7;\n    vec3 p = objPos/scale;\n    float modi;\n    \n    for(float x=0.0; x < ITERATIONS; x++)\n    {        \n        modi =(p.x * p.z) / abs(p.x * p.z);\n        fracAng *= modi;\n        p.x = abs(p.x);\n        p.z = abs(p.z);\n        p = p * scale;\n\n        p -= posFracOff;\n        p.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * p.xz;\n      \n        float newDDist = sdSphere(p, 1.5) / pow(scale, x);\n        \n        //newDDist /= size;\n        dSphere = min(dSphere, newDDist);\n        if(dSphere < o.dist){\n            o.dist = dSphere;\n            \n            float d;\n            float minDist = 10000.0;\n            vec3 minPt;\n            vec3 len = (p);\n            vec3 len1 = p - posFracOff;\n            vec2 id;\n            \n            float angZ = atan(len.z, len.x);\n            float angY =atan(len.y,len.x);\n            \n            float scale = 20.0;\n            float yScale = 24.0;\n            \n            angZ *= scale;\n            id.x = floor(angZ/PI);\n            id.y = floor(p.y*yScale / PI);\n            \n            id += vec2(x*modi);\n  \n            float dVor, minDVor;\n            vec3 vor;\n            vec2 minId;\n            \n            float ang1 = -id.x*PI / scale;\n            vec3 orig = vec3(0, id.y * PI / yScale, 0);\n            float angRise = asin(orig.y / 1.5);\n            vec3 origBase = vec3(1.5, 0, 0);\n            origBase.xy = mat2(cos(angRise), sin(angRise), -sin(angRise), cos(angRise)) * origBase.xy;\n            origBase.xz = mat2(cos(ang1), -sin(ang1), sin(ang1), cos(ang1)) * origBase.xz;\n            orig.xz = origBase.xz;\n            \n            \n            minDVor = 1000.0;\n            minId = id;\n            for(float x=-1.0; x<=1.0; x++)\n            {\n                for(float y=-1.0; y<=1.0; y++)\n                {\n                    vec2 off = vec2(x,y);\n                    vec2 idOff = id+off;\n                    if(idOff.x == scale)\n                        idOff.x = -scale;\n                    if(idOff.x == -(scale+1.))\n                        idOff.x = scale-1.;\n                    \n                    float ang1Off = -idOff.x*PI / scale;\n                    vec3 origOff = vec3(0, idOff.y * PI / yScale, 0);\n                    float angRiseOff = asin(origOff.y / 1.5);\n                    vec3 origBaseOff = vec3(1.5, 0, 0);\n                    origBaseOff.xy = mat2(cos(angRiseOff), sin(angRiseOff), -sin(angRiseOff), cos(angRiseOff)) * origBaseOff.xy;\n                    origBaseOff.xz = mat2(cos(ang1Off), -sin(ang1Off), sin(ang1Off), cos(ang1Off)) * origBaseOff.xz;\n                    origOff.xz = origBaseOff.xz;\n\n                    vec2 rotsOff = random(idOff, vec2(2.*PI/(scale + (scale)), 0), vec2(0, 0));\n                    vor.xz = mat2(cos(-rotsOff.x), -sin(-rotsOff.x), sin(-rotsOff.x), cos(-rotsOff.x)) * origOff.xz;\n                    vor.y = origOff.y;\n                    \n                    dVor = length(p - vor);\n                    if(dVor < minDVor)\n                    {\n                     \tminDVor = dVor;\n                        minId = idOff;\n                    }\n                }\n        \t}\n            \n            vec3 posId = vec3(minId, 1);\n            o.color = mix(vec3(0.1, 0.1, 0.055)*fbm(posId/5.0), vec3(0.3, 0.15, 0.066)*fbm(posId/2.0), \n                          step(posId.y, (yScale/2.0)-2.0) * step(0.5, fbm(posId/5.0)));\n\n            o.specVal = 8.0;\n            o.specKs = 0.01;\n    \t}\n    }\n    \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.glowAmt = 1.0;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<150; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed;\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    float val = clamp(dot(o.normal, dir), 0.0, 1.0);\n    float oVal = val;\n    //val = round(val/0.33);\n    //val = smoothRound(val, 0.33, 0.05);\n    //val *= 0.33;\n    \n    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   \n    //col = colQuant(3.0, col);\n    return col;\n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n    //col = colQuant(2.0, col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,5.0,16.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = iMouse.x/20.0;\n    float camAngPos = -PI/2.0;\n    float camAngX = -PI/6.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n    mat2 rotCamX = mat2( vec2(cos(camAngX), sin(camAngX)), vec2(-sin(camAngX), cos(camAngX)) );\n\n    dir.yz = rotCamX * dir.yz;\n    dir.xz = rotCam * dir.xz;\n    \n    #ifdef ZOOM\n    camEye += vec3(0,1.3,0.5)*-3.5*abs(sin(iTime/rate));\n    #endif\n    \n    Light light;\n    light.intensity = 2.4;\n    light.pos = vec3(50, 5, 10);\n    light.color = vec3(1);\n    \n\tMarchRes res = marchRay(camEye, dir, 0.8);\n    vec3 pos = res.curRay;  \n    \n    float x = uv.x + iResolution.x / iResolution.y;\n    vec3 col = (vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0)*0.1*(x) + vec3(0.0, 0.0, 0.1)*(1.0-x));\n\t\n    col += vec3(0.2) * step(9.9, floatRandom(uv, 10.0, 0.0));\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos);\n        col += calcSpecLight(res.obj, light,pos, camEye);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 432, 479, 479, 724], [726, 726, 781, 781, 890], [892, 932, 953, 953, 1020], [1022, 1067, 1093, 1093, 1724], [1726, 1766, 1785, 1785, 1945], [1948, 1948, 1985, 1985, 2015], [2017, 2017, 2039, 2039, 6345], [6347, 6347, 6384, 6384, 6677], [6683, 6683, 6735, 6735, 7406], [7408, 7408, 7460, 7460, 7789], [7791, 7791, 7853, 7853, 8187], [8189, 8189, 8246, 8246, 9557]]}
{"id": "wltGWs", "name": "Noise Fun #1", "author": "ndxbxrme", "description": "a bit underwatery", "tags": ["2d", "noise", "radial"], "likes": 2, "viewed": 273, "published": "Public API", "date": "1578017148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rotate(in vec2 uv, in float a)\n{\n\t//uv -= .5;\n    uv *= mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n    //uv += .5;\n    return uv;\n}\nfloat pn(vec3 p) {\n\t//noise function by CPU https://www.shadertoy.com/view/4sfGRH\n    vec3 i = floor(p); \n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*3.141592653589793)*(-.5) + .5;  \n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);   \n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat getNoise(vec2 pos, float pulse, float time) {\n\tvec3 q = vec3(pos * 2., pos.x-pos.y + time * 0.3);\n\tfloat b = (pulse * 1.6) + pn(q * 2.) + 2.8;\n\tb +=  .25 * pn(q * 4.);\n\tb +=  .25  * pn(q * 8.);\n\tb +=  .5  * pn(vec3(pos, pos.x-pos.y + time * 0.3) * 12.23);\n\tb = pow(b,0.5);\t\n\treturn b;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y += 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = length(uv) * 2.;\n    float f = 0.;\n    uv = rotate(uv, iTime * .1);\n    for(int j; j<10; j++)\n    {\n        uv = rotate(uv, 1.12);\n        float p = 0.0 + (getNoise(uv * 2., 0., iTime)) * .2 * abs(uv.x);\n        float a = length(uv.y);\n        f += smoothstep(p - .1, p, a) * smoothstep(p + .1, p, a);\n    }\n    f = smoothstep(.6, .9, f);\n    vec3 col = vec3(0.5, 0.5 + .2 * cos(iTime + uv.y), 1.) * (f + f * .5) * 2. - r;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 51, 148], [149, 149, 167, 230, 493], [495, 495, 546, 546, 787], [788, 788, 845, 845, 1454]]}
{"id": "WltSzH", "name": "rainbow on the sea", "author": "Dron", "description": "my first shader", "tags": ["rainbow"], "likes": 3, "viewed": 63, "published": "Public", "date": "1580400819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 p0, vec2 pf){return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));}\nfloat graph(float x){return (cos(x*20.0+iTime*2.0))/20.0 + 0.12;}\nfloat graph2(float x){return (cos(x*20.0-iTime*2.0))/20.0 + 0.1;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 bc = vec2(iResolution.x*0.5,uv.y);\n    \n    //wave 1\n    if ( uv.y < graph(uv.x) ) fragColor = vec4(0.1,0.3,0.8,1.0);\n        else fragColor = vec4(0.1, 0.9, 1.0, 1.0);\n    \n    // rainbow\n    float d = distance(bc.xy,fragCoord.xy)*0.01;\n        if (d < 2.0) ;\n        else if (d < 2.1) fragColor = vec4(0.56, 0.0, 1.0, 1.0);\n        else if (d < 2.2) fragColor = vec4(0.294, 0.0, 0.51, 1.0);\n        else if (d < 2.3) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        else if (d < 2.4) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        else if (d < 2.5) fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n        else if (d < 2.6) fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n        else if (d < 2.7) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            \n    //wave 2\n    if ( uv.y < graph2(uv.x) ) fragColor = vec4(0.0,0.0,1.0,1.0);\n            \n    // sun\n    vec2 sunCoords = vec2(iResolution.x*0.1,iResolution.y*0.8);\n    float sunDistOld = distance(sunCoords.xy,fragCoord.xy)*0.01;\n    float sunDist = distance(sunCoords.xy,fragCoord.xy)*0.01*(sin(iTime*1.5)/3.0 +2.0);\n    if (sunDist < 1.3) fragColor = vec4(0.1, 0.9, 1.0, 1.0);\n    if (sunDist < 1.1) fragColor.rgb = pow(fragColor.rgb, vec3(.454545)); \n    if (sunDistOld < 0.2) fragColor = vec4(1.0, 1.0, 0.0, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 91], [92, 92, 113, 113, 157], [158, 158, 180, 180, 223], [225, 225, 282, 282, 1581]]}
{"id": "WltXRn", "name": "String Field", "author": "scottdarby", "description": "Quantum String Field", "tags": ["stringtheory"], "likes": 4, "viewed": 254, "published": "Public API", "date": "1580288972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// lots of inspiration from IQ and hg_sdf\n\nconst float PI = 3.14159265359;\nconst int MAX_MARCHING_STEPS = 50;\nconst float EPSILON = 0.0001;\n\nvec2 rotate2d(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat opTwist( vec3 p, float fftValue, float time ) {\n    float c = cos((fftValue*1.5) *p.y);\n    float s = sin((fftValue+0.25)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m * p.xz, p.y);\n    \n    return sdTorus(q, vec2(abs(sin(iTime*0.1))+0.5*(fftValue*0.03), fftValue*0.0001));\n\n}\n\nfloat opRep( vec3 p, vec3 c ) {\n            \n    float idx = mod((floor((p.x)/c.x)), 32.0);\n    float idy = mod((floor((p.y)/c.y)), 32.0);\n    float idz = mod((floor((p.z)/c.z)), 32.0);\n    \n\tfloat id = length(vec3(idx, idy, idz));\n    \n    vec3 q = mod(p, c) - 0.5 * c;\n\n    vec3 r = q;  \n    \n    float rotationAmount = (id * 5.0) + (iTime * 2.0);\n   \n    bool xmod2 = mod(idx, 2.0) == 0.0;\n    \n    // offset even rows\n    if (xmod2) {\n    \tq.y += 1.5;\n        r.y -= 1.5;\n    }\n    \n\tpR(q.xy, rotationAmount);\n    pR(q.xz, rotationAmount * 0.1);\n    \n    float shape1 = opTwist(q, 1.0, iTime);\n    \n    if (xmod2) {\n    \n        pR(r.xy, rotationAmount);\n        pR(r.xz, rotationAmount * 0.1);\n        \n        float shape2 = opTwist(r, 1.0, iTime);\n        \n    \treturn min(shape1, shape2);\n        \n    } else {\n        \n        return shape1;\n        \n    }\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n\treturn opRep(samplePoint, vec3(3.0, 3.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir) {\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\t\tfloat dist = sceneSDF(pos);\n        if (dist < EPSILON) {\n\t\t\treturn pos;\n        }\n\t\tpos += dist * dir;\n\t}    \n\treturn pos;\n}\n\n\nfloat lightPointDiffuse(vec3 pos, vec3 lightPos) {\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = 3.0 / (lightDist * lightDist);\n\treturn max(0.0, color*10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n    \n\tmousePos *= vec2(PI / 2.0, PI / 2.0).xyxy;\n    \n    if (iMouse.zw == vec2(0.0)) {\n        mousePos.xy = vec2(0.5, -0.2); \n    }\n\t\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -8.0);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 planeU = vec3(2.0, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 2.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tcameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\trayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\tcameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\trayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n    \n    cameraPos.zy += iTime;\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir);\n\t\n    // base color\n\tvec3 color = vec3(0.0);\n    \n   \n    color += lightPointDiffuse(rayPos, cameraPos) * 9.0;\n    \n    color = pow(color, vec3(0.5));\n    \n    float contrast = 0.5;\n    \n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n\n    float grey = color.r * 0.21 + color.g * 0.71 + color.b * 0.07;\n    \n\tfragColor = vec4(color, min(grey*0.1, 0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 141, 173, 173, 248], [250, 397, 429, 429, 471], [473, 473, 506, 506, 569], [571, 571, 624, 624, 864], [866, 866, 897, 897, 1733], [1736, 1736, 1770, 1770, 1821], [1823, 1823, 1857, 1857, 2033], [2036, 2036, 2086, 2086, 2207], [2209, 2209, 2266, 2266, 3443]]}
{"id": "WltXzH", "name": "Simple hash stars", "author": "rabbitator", "description": "Simple stars based on hash function", "tags": ["stars", "dots"], "likes": 1, "viewed": 109, "published": "Public", "date": "1580402435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(fragCoord);\n    \n    float c = vec3( hash1(p.x + 1920U*p.y - uint(iMouse.x) + (1920U*1080U))).z;\n    \n    c = pow(c, (sin(iTime*0.5)+1.2) * 1000.0);\n    \n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 26, 69, 207], [210, 210, 267, 267, 475]]}
{"id": "WlV3Dh", "name": "title screen sine wave", "author": "Zeradok", "description": "base for game title screen maybe", "tags": ["wave", "animation", "sine", "titlescreen"], "likes": 2, "viewed": 50, "published": "Public", "date": "1578834005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WAVE_WIDTH 0.05\n\nvec3 background() {\n    return vec3(1);\n}\n\nvec3 colorRGB(float x, float y, float z) {\n    return vec3(x/255., y/255., z/255.);\n}\n\nint wave(vec2 uv, float offset, float waveLength, float a, float speed, int layer) {\n    if (abs(a * sin((offset + uv.x + iTime * speed) * 1./waveLength) - uv.y) <= WAVE_WIDTH/3. + WAVE_WIDTH * pow(uv.x, 2.)) {\n    \treturn layer;\n    }\n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = -1. + 2.*fragCoord/iResolution.xy;\n\n    // Clear background as base\n    vec3 col = background();\n    vec3 rd = vec3(normalize(uv), 1.);\n    vec3 red = colorRGB(255., 188., 188.);\n    vec3 blue = colorRGB(147., 255., 255.);\n    vec3 yellow = colorRGB(255., 237., 127.);\n    int wave1 = wave(uv, 0., .5, .25, .25, 1);\n    int wave2 = wave(uv, .4, .5, .20, .3, 2);\n    int wave3 = wave(uv, .7, 1., .20, .2, 3);\n    int wave = max(wave1, wave2);\n    wave = max(wave, wave3);\n    if (wave == 1) {\n        col = red;\n    } else if (wave == 2) {\n        col = blue;\n    } else if (wave == 3) {\n        col = yellow;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3Dh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 66], [68, 68, 110, 110, 153], [155, 155, 239, 239, 406], [408, 408, 465, 516, 1203]]}
{"id": "wlV3DV", "name": "TestC", "author": "visualdmx", "description": "copy\n", "tags": ["copy"], "likes": 4, "viewed": 90, "published": "Public", "date": "1579974935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 (PI/2.)\n\n// tuneables\n#define SCALE 15.0\n#define ROUGH 0.25\n#define REFL 0.02\n#define LIGHTWRAP sin(iTime/2.0)*5.0 // was 5.0, this is clearly more fun\n#define NUM_LIGHTS 64\n#define SPHERE_RAD 1.5\n#define ORBIT_DIST 4.0\n#define ALBEDO vec3(0.25)\n#define HUE_SHIFT_RATE 0.25\n#define HUE_BAND_SCALE 0.25\n#define VERTICAL_ACCUM_SIN_SCALE 0.5\n#define LIGHT_INTENSITY 0.5\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// GGX code borrowed from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n// blatantly stolen from https://gist.github.com/eieio/4109795 (because rainbows)\nvec3 hsv_to_rgb(float h, float s, float v)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec3 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec3(c, x, 0.0);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec3(x, c, 0.0);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec3(0.0, c, x);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec3(0.0, x, c);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec3(x, 0.0, c);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec3(c, 0.0, x);\n\t} else {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n};\n\nvec3 sphereNorm(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3((ws-c.xy)/r, 0);\n    pt.z = -cos(length(pt.xy)*PI2);\n    return normalize(pt);\n}\n\nbool sphereTest(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws-c.xy, c.z);\n    return (dot(pt.xy, pt.xy) < r*r);\n}\n\nvec3 spherePos(vec2 ws, vec3 c, float r)\n{\n    vec3 pt = vec3(ws, c.z);\n    pt.z -= cos(length((ws-c.xy)/r)*PI2)*r;\n    return pt;\n}\n\n\nvec4 sphere(vec3 pt, vec3 N, PointLight pl, float rough, float refl)\n{   \n    vec3 V = vec3(0, 0, -1);\n    vec3 pToL = pl.pos - pt;\n    vec3 L = normalize(pToL);\n    \n    float decay = length(pToL);\n    decay = 1./decay*decay;\n    \n    float diffuse = dot(N,L) / PI;\n    float spec = GGX(N, V, L, rough, refl);\n            \n    if (dot(N,L) >= 0.)\n    {\n    \treturn vec4(decay * pl.color * (spec + diffuse * ALBEDO), pt.z);\n    }\n    else\n    {\n        return vec4(0, 0, 0, pt.z);\n    } \n}\n\nstruct LightAnim\n{\n    vec3 period;\n    vec3 shift;\n    vec3 orbit;\n    vec3 offset;\n};\n\n\nPointLight getLight(vec3 color, LightAnim anim)\n{\n    vec3 pos = sin(iTime * anim.period + anim.shift) * anim.orbit + anim.offset;\n    PointLight mypt = PointLight(pos, color);\n    return mypt;\n}\n\n\nvec4 renderLight(vec2 cs, PointLight pt)\n{\n    return vec4(pt.color * saturate(.1 - abs(length(cs-pt.pos.xy)))*100., pt.pos.z);\n}\n\nvoid drawWriteZ(vec4 result, inout vec4 fragColor)\n{\n    fragColor.xyz += result.xyz;\n    fragColor.w = result.w;\n}\n\nvoid drawTestZ(vec4 result, inout vec4 fragColor)\n{\n\tif (result.w <= fragColor.w || fragColor.w < 0.)\n    {\n        fragColor.xyz += result.xyz;\n    }\n}\n\nvoid planet(vec2 csUv, inout vec4 fragColor, LightAnim anim, bool isGeo, vec3 norm, vec3 pos, vec3 color)\n{\n    PointLight ptL = getLight(color, anim);\n    \n    if (isGeo)\n    {\n    \tdrawWriteZ(sphere(pos, norm, ptL, ROUGH, REFL), fragColor);\n    }\n    drawTestZ(renderLight(csUv, ptL), fragColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;       \n    vec4 csUv = vec4(uv-vec2(0.5, 0.5), iMouse.xy/iResolution.xy);\n    csUv.x *= aspect;\n    csUv.xy *= SCALE;   \n    \n    float sphereRad = SPHERE_RAD;\n    float orbitDelta = ORBIT_DIST;\n    float orbit = sphereRad+orbitDelta;\n    \n    // period, shift, orbit, offset\n    LightAnim anim = LightAnim(vec3(1, 0, 1), vec3(0, PI2, PI2), vec3(orbit, 0, -orbit), vec3(0, 0, 10));\n    \n    vec3 sphereCenter = vec3(0, 0, 10);\n    \n    vec3 sPos = spherePos(csUv.xy, sphereCenter, sphereRad);\n    vec3 sNorm = sphereNorm(csUv.xy, sphereCenter, sphereRad);\n    bool isSphere = sphereTest(csUv.xy, sphereCenter, sphereRad);\n    \n    fragColor.xyzw = vec4(0, 0, 0, -1); // lazy \"depth\" value\n    \n    const int totalPlanets=NUM_LIGHTS;\n    \n    for (int i = 0; i < totalPlanets; ++i)\n    {\n        float rat = 1.-float(i)/float(totalPlanets);\n        \n        float hue = mod(HUE_SHIFT_RATE*-iTime+rat*HUE_BAND_SCALE,1.);\n        \n        vec3 color = hsv_to_rgb(hue, 1., LIGHT_INTENSITY*rat);\n        \n    \tplanet(csUv.xy, fragColor, anim, isSphere, sNorm, sPos, color);\n        \n        anim.orbit.y += sin(iTime)*VERTICAL_ACCUM_SIN_SCALE; // making things more interesting...\n        \n        anim.shift += LIGHTWRAP*2.*PI/float(totalPlanets);\n    \t   \n    }\n    \n    fragColor.xyz = pow(fragColor.xyz, 1./vec3(2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 537, 599, 599, 1207], [1209, 1291, 1335, 1335, 1889], [1945, 1945, 1988, 1988, 2088], [2090, 2090, 2133, 2133, 2207], [2209, 2209, 2251, 2251, 2341], [2344, 2344, 2414, 2414, 2833], [2925, 2925, 2974, 2974, 3120], [3123, 3123, 3165, 3165, 3252], [3254, 3254, 3306, 3306, 3369], [3371, 3371, 3422, 3422, 3523], [3525, 3525, 3632, 3632, 3825], [3827, 3827, 3884, 3884, 5296]]}
{"id": "WlV3Dy", "name": "voronoi caustic", "author": "cdpjohn", "description": "my first shader toy experience :)\nstill far to go", "tags": ["voronoi"], "likes": 4, "viewed": 160, "published": "Public", "date": "1579800618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4  WATER_COLOR    = vec4( 51.0/255.0, 175.0/255.0, 212.0/255.0, 0.19);\nconst vec4  RIPPLE_COLOR   = vec4(255.0/255.0, 255.0/255.0, 255.0/255.0, 0.6);\nconst float GROUND_DENSITY = 1.6;\nconst float RIPPLE_DENSITY = 6.0;\nconst float RIPPLE_SPEED   = 1.5;\nconst vec2  LIGHT_VECTOR   = normalize(vec2(-1.0, 0.5));\n\nvec2 hash(vec2 pos)\n{\n    pos = vec2(dot(pos, vec2(2.71, 81.21)), dot(pos, vec2(1195.113, 114.114)));\n    return fract(sin(pos) * 3.14159265 + sin(pos) * 2.71828);\n}\n\nvec3 voronoi(vec2 pos)\n{\n    float d = 0.01 * sin(iTime * 1.0);\n    pos *= mat2(cos(d), -sin(d), sin(d), cos(d));\n    \n    vec2 grid_pos = floor(pos);\n    vec2 local_pos = fract(pos);\n    \n    float closest_sqr_dist = 4.0;\n    vec2 vector_to_closest_voronoi_point = vec2(0.0);\n    \n    for(int i = -2; i <= 2; ++i)\n        for(int j = -2; j <= 2; ++j)\n        {\n            vec2 near_grid_local_pos = vec2(float(i), float(j));\n            vec2 near_grid_local_voronoi_point = hash(grid_pos + near_grid_local_pos);\n            \n            near_grid_local_voronoi_point = \n                (0.5 * sin(RIPPLE_SPEED * iTime + 71.0 * near_grid_local_voronoi_point));\n            \n            vec2 vector_to_voronoi_point =\n                near_grid_local_pos + near_grid_local_voronoi_point - local_pos;\n            \n            float sqr_dist = dot(vector_to_voronoi_point, vector_to_voronoi_point);\n            if (closest_sqr_dist > sqr_dist)\n            {\n                closest_sqr_dist = sqr_dist;\n                vector_to_closest_voronoi_point = vector_to_voronoi_point;\n            }\n        }\n    \n    return vec3(sqrt(closest_sqr_dist), vector_to_closest_voronoi_point);\n}\n\nvec3 ground_color(const vec2 pos)\n{\n    vec3 v = voronoi(RIPPLE_DENSITY * pos);\n    vec2 distortion = v.yz * 0.018;\n    distortion *= pow(sin(clamp(v.x * 2.0, 0.0, 1.0) * 3.14159265), 2.2);\n    \n    vec3 color = textureLod(iChannel0, GROUND_DENSITY * (pos + distortion), 0.0).xyz;\n    color = pow(color, vec3(1.1));\n    \n    float caustic = voronoi(RIPPLE_DENSITY* 1.7 * (pos + vec2(4.1, 3.7) + distortion)).x;\n    caustic = pow(caustic, 1.0) * 0.9;\n    color = mix(color, vec3(0.0), caustic);\n    \n    return color;\n}\n\nvec4 water_color(const vec2 pos)\n{\n    vec3 v = voronoi(RIPPLE_DENSITY * pos);\n    vec4 water_color = mix(WATER_COLOR, RIPPLE_COLOR, pow(v.x, 3.1));\n    return water_color;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 pixel_pos = (frag_coord.xy - iResolution.xy * 0.5);\n    pixel_pos /= max(iResolution.x, iResolution.y);\n    \n    vec3 ground_color = ground_color(pixel_pos);\n    vec4 water_color = water_color(pixel_pos);\n    \n    frag_color = vec4(mix(ground_color, water_color.xyz, water_color.w), 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 340, 340, 484], [486, 486, 510, 510, 1665], [1667, 1667, 1702, 1702, 2185], [2187, 2187, 2221, 2221, 2361], [2363, 2363, 2420, 2420, 2720]]}
{"id": "WlV3Dz", "name": "water tunnel", "author": "jojobavg", "description": "Procedural sea tunnel.\nAfter around 30 seconds, there are more details because the \"color\" variable (bad named) adds some noise looks like subsurface.\nYou can set the depth to 20.0 and the fogSize to 10.0 if too slow. ", "tags": ["procedural", "raymarching", "noise", "tunnel", "sea", "water"], "likes": 17, "viewed": 213, "published": "Public", "date": "1578775370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n// TDM for the getSkyColor function\n// https://www.shadertoy.com/view/Ms2SD1\n\n#define time iTime\n#define depth 40.0\n#define fogSize 25.0\n#define seuil 4.0\n#define steps 100.0\nfloat fogCoef=1.0/(depth-fogSize);\n\n\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat water(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tvec3 truc = vec3(p.x+sin(length(p*0.2)+time)*2.0,p.y+sin(length(p*0.2))*2.0,0.0);\n\tfloat coef = length(truc)-4.0;\n\n\tfloat c=1.0;\n\tfloat n1=1.0;\n        \n\tfloat d=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=2.0/c*abs(noise((p*c-time*2.0*d)*scale));\n\t\tc*=2.0;\n\t\td+=1.5;\n\t}\n\n\treturn n1*coef;\n\n}\n\nfloat mapHyper(vec3 p){\n\treturn water(p,vec3(0,0,0),0.3,0.1);\n}  \n\n\nvec3 tunnel(vec3 p){\n\tvec3 off=vec3(0);\n\toff.x += sin(p.z*0.2)*1.5;\n\toff.y += sin(p.z*0.3)*1.3;\n\treturn off;\n}\nvec3 getSkyColor(vec3 e) {\n\te.y = abs(e.y);\n\te.y = max(e.y,0.0);\n\treturn vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 s=vec3(-1.0,-1.0,-3);\n  float t2=(time*1.5);\n  s.xz *= rot(sin(t2)*0.015);\n \n  vec3 t=vec3(0,0,0);\n\ts -= tunnel(s);\n\tt -= tunnel(t);\n  s.x += cos(t2*0.2)*1.0*sin(time*0.01);\n  s.y += sin(t2*0.2)*1.0*sin(time*0.01+10.0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\n\tvec3 p=s;\n\n\tfloat c= 0.0;\n\tfloat color = 0.0;\n\tvec3 p2;\n\tbool hit = false;\n\tfor(int i=0; i<int(steps); ++i) \n\t{\n\t\tfloat truc;\n\t\ttruc = mapHyper(p);\n\t\tc =truc;    \n\t\tif( c>seuil)\n\t\t{\n\t\t\tcolor+=1.0;\n\t\t\n\t\t}\n\t\tp+=r*(truc-seuil)*0.09;\n        if(length(p-s)>depth){hit = false;break;}\nhit = true;\n\t}\n\tvec3 col=vec3(0);\n    float fresnel;\n    vec3 reflected;\nif (hit)\n{\n\tvec2 off=vec2(0.01,0.0);\n\tvec3 n=normalize(mapHyper(p)-vec3(mapHyper(p-off.xyy), mapHyper(p-off.yxy), mapHyper(p-off.yyx)));\n\tcol = mix(vec3(0.2,0.3,0.4),vec3(0.1,0.365,0.441),1.0-clamp(color,0.0,1.0));\n\n\t fresnel = clamp(1.0- dot(n,s), 0.05, 0.75);\n\t reflected = getSkyColor(reflect(r,normalize(n*0.5+vec3(0.0,1.0,0.0)*0.5)))*0.7;\n\tcol = mix(col,reflected,fresnel*reflected);\n    //col = vec3(spec);\n\n}else\n    col=vec3(0.95,0.95,0.95);//getSkyColor(r)*0.8;\n    float fog =  clamp((length(p-s)-fogSize)*fogCoef,0.0,1.0);\n    col = mix(col,vec3(0.85,0.85,0.85),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 336, 363, 363, 392], [395, 395, 419, 419, 1128], [1130, 1130, 1149, 1149, 1215], [1217, 1217, 1284, 1284, 1570], [1572, 1572, 1595, 1595, 1635], [1640, 1640, 1660, 1660, 1750], [1751, 1751, 1777, 1777, 1877], [1879, 1879, 1934, 1934, 3415]]}
{"id": "WlV3W3", "name": "3D Tree Forest", "author": "zovox", "description": "3D Tree Forest", "tags": ["3d", "tree", "forest"], "likes": 6, "viewed": 261, "published": "Public API", "date": "1580063471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (20.)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat scale = 3.;\nfloat seed;\nvec3 mcol;\nfloat dfScene(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n    float d = 1E32;\n    \n    float height =1.;\n    float width = .05;\n    const int iterations = 4;\n    float loop = float(1.)/float(iterations);\n\tfloat dB=sdCapsule(z0.xyz, vec3(0.,width,0.), vec3(0.,-height*2.,0.),width); \n    \n    if(dB < d)\n    {\n        d = dB;\n    \tmcol = vec3(loop/GR+(1.-loop)/E, loop, 0.);\n    }\n    \n    dB = z0.y+height*2.;\n    \n    if(dB < d)\n    {\n        d = dB;\n        float grass = pow(cos(z0.x*2.*PI/scale)*cos(z0.z*2.*PI/scale)*.5+.5, 4.);\n    \tmcol = vec3(loop/GR+(1.-loop)/E, loop+grass/PI/GR, 0.);\n    }\n    \n    \n\tfor(int i=0;i<5;i++){\n\t\tz.xz=Kaleido(z.xz,float(i+2)*(1.+floor(saw(seed*float(i+1))*4.)));\n\t\tz.yz=Rotate(z.yz,(saw(time*PI+seed)*.5-.5));\n\t\t\n        float dcap = sdCapsule(z.xyz+vec3(0., 0., .5), vec3(0.,0.,.5), vec3(0.,.5,0.),width);\n        dB = dcap/z.w;\n        if(dB < d)\n        {\n\t\t\td=dB;\n            loop = float(i+1)/float(iterations);\n            mcol = vec3(loop/GR+(1.-loop)/GR, loop, 0.);\n        }\n\t\tz.z+=.5;\n        z.y -= .5;\n\t\tz*=vec4(2.0,2.0,2.0,2.0);\n\t}\n\t//dB=(length(z.xyz)-1.0)/z.w;\n\treturn d;\n\treturn d;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <32; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        seed = floor((rp.x)/scale)*1.2345+floor((rp.z)/scale)*5.4321;\n        p.xz = (fract((rp.xz)/scale)-.5)*scale;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    vec3 sky_color = vec3(.35, .35, .85);\n    float fog = smoothstep(.75, .9, d/FAR);\n    \n\n    vec3 n = surfaceNormal(p);\n    vec3 sc = mcol; //surface colour\n\n    float diff = max(dot(n, lp), 0.0); //diffuse\n    pc = sc * 0.5 + diff * sc ;\n    float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n    pc = (pc + spe * vec3(1.0))*(1.-fog)+fog*sky_color;\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, -.5, -PI)*2.;\n    \n    float movement = time;\n    \n    ro += vec3((sin(movement*PI))*scale, 0., (movement+.5)*scale);\n    //rotate camera\n    rd.yz *= rot(.25+sin(movement/GR)*.1); \n    rd.xz *= rot(cos(movement*PI) * 0.5);\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 1011, 1048, 1048, 1109], [1110, 1110, 1146, 1146, 1209], [1210, 1210, 1264, 1264, 1345], [1347, 1347, 1366, 1366, 1418], [1420, 1420, 1472, 1472, 1599], [1643, 1643, 1669, 1669, 2773], [2775, 2775, 2803, 2803, 3105], [3107, 3120, 3155, 3155, 4079], [4082, 4082, 4137, 4171, 4661]]}
{"id": "WlV3Wc", "name": "4-point voronoi", "author": "Wasserwecken", "description": "I've tried to make a  voronoi noise where a pixel/fragment only has to check three neighbours instead of 9.\n\nit kinda works, but its very uniform due to the limited area for the random points", "tags": ["voronoi", "test", "experiment"], "likes": 4, "viewed": 228, "published": "Public API", "date": "1580080909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 r( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat v(vec2 n)\n{\n\tfloat d = 2.0;\n\tvec2 nfl = floor(n);\n\tvec2 nfr = fract(n);\n\n\tvec2 p;\n\tvec2 ns = sign(nfr - vec2(0.5));\n\tfor(float x = 0.0; x < 2.0; x++)\n\t{\n\t \tfor(float y = 0.0; y < 2.0; y++)\n\t \t{\n\t \t    vec2 ne = vec2(x,y) * ns;\n\t \t   \n\t \t    p = r(nfl + ne) * 0.7 + 0.15 + ne;\n            //p = r(nfl + ne) + ne; //This will create artefacts\n\t \t    d = min(distance(p, nfr), d);\n\t \t}\n\t }\n\n\t return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 10.0;\n    uv += iTime * 0.3;\n\n    // Output to screen\n    fragColor = vec4(vec3(v(uv)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 111], [113, 113, 130, 130, 520], [522, 522, 579, 629, 773]]}
{"id": "WlV3WR", "name": "Rudimentary Solar System", "author": "KVogt", "description": "Shader Proj of a solar system for Computer Graphics", "tags": ["solorsystem"], "likes": 1, "viewed": 66, "published": "Public", "date": "1578926137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nvec4 Sun (vec2 uv)\n    {\n        float sunSize = length(uv);\n        vec4 sunColors = vec4(1.0,abs(sin(iTime))+.6 ,0.00, 0.0);\n        \n       // vec4 planOne = PlanetOne(uv);\n        \n        sunColors.a = smoothstep(.20,.14,sunSize);\n        return sunColors;\n        //return circ;    \n    }\n\nvec4 PlanetOne(vec2 uv){\n   // float len = length(uv); //distance from any edge on the sun to the center of the planet\n    \n   // len = len - (uv.x-.5)\n    float planetPos = length(uv*3.0 + vec2(1.3 * sin(iTime / 3.0), cos(iTime / 3.0)));\n    \n    vec4 planetColors = vec4(0.0, 0.5, 0.6, 0.0);\n    planetColors.a = smoothstep( .26, .25, planetPos);\n    \n    return planetColors;\n}\n\nvec4 PlanetTwo(vec2 uv){ //maybe moon?\n    \n    float moonPos = length(((uv * 3.0 + vec2(1.3 * sin(iTime / 3.0), cos(iTime / 3.0)))*2.5) + vec2(sin(iTime*2.0 ), cos(iTime*2.0)));\n    vec4 moonColors =vec4(0.6, 0.4, 0.4, 0.0);\n    moonColors.a = smoothstep( .13, .12, moonPos);\n    return moonColors;\n}    \n\n\nvec4 Space(vec2 uv){\n   vec4 spaceColor = vec4(.11,.13,.13,0.0);\n    vec4 sun = Sun(uv);\n    spaceColor = mix (spaceColor, sun, sun.a);\n    vec4 plan1 = PlanetOne(uv);\n    spaceColor = mix(spaceColor, plan1, plan1.a);\n    vec4 moon = PlanetTwo(uv);\n    spaceColor = mix(spaceColor, moon, moon.a);\n    \n    return spaceColor;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n   \n    \n    // Output to screen\n    fragColor = Space(uv);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 27, 27, 297], [299, 299, 323, 450, 679], [681, 681, 705, 719, 982], [989, 989, 1009, 1009, 1315], [1320, 1320, 1377, 1377, 1519]]}
{"id": "wlV3Wz", "name": "Noise and RayMarching", "author": "Harekelas", "description": "Practicing with noise and ray marching", "tags": ["practice"], "likes": 0, "viewed": 50, "published": "Public", "date": "1578721005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 0.01\n\nfloat N21(vec2 p)\n{\n    return fract(sin(p.x * 1920. + p.y * 8848.) * 10248.);    \n}\n\nfloat N22(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(156.25,5432.1,2247.58));\n    a += dot(a, a + 78.54);\n    return fract(vec2 (a.x * a.y, a.y*a.z)).x;\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0.,1.,fract(uv));\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl,br,lv.x);\n    \n    float tl = N21(id + vec2(0,1));\n    float tr = N21(id + vec2(1,1));\n    float t = mix(tl,tr,lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv, float s){\n    \n    float c = SmoothNoise(uv * 2. * s);     \n    c += SmoothNoise(uv * 4. * s) * 0.5;\n\tc += SmoothNoise(uv * 8. * s) * 0.25;\n    c += SmoothNoise(uv * 16. * s) * 0.125;\n    c += SmoothNoise(uv * 32. * s) * 0.0625;    \n    c += SmoothNoise(uv * 64. * s) * 0.03125;    \n\n    return c / 1.96875;\n}\n\nfloat GetDist(vec3 p){\n    \n    float Sin = sin(iTime) * 0.5 + 0.5;\n    float Cos = cos(iTime) * 0.5 + 0.5;\n    \n \tvec4 s = vec4(0,1,10.,1.);\n    //vec4 s = vec4(0,1,6.,1.);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    \n    vec2 tuv = p.xz / vec2(100,100);\n    \n    //float terrainDist = sin(p.x) + sin(p.z) + p.y * 2. + 5.;\n    //float terrainDist = p.y;\n    float terrainDist = p.y + SmoothNoise2(tuv, 0.2) * SmoothNoise2(tuv, 0.5) * 150.;\n    \n    float d= min(sphereDist, terrainDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out bool isMax){\n\tfloat dO = 0.;\n    isMax= false;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n    \tvec3 p = ro + rd * dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO > MAX_DIST ){\n        \tisMax = true;\n            break;\n        }\n        else if(ds < SURF_DIST){\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 n){\n    vec3 lightDir = vec3(2,-1,1.);\n    vec3 lightPos = vec3(-2,6,0);\n    vec3 l = normalize(-lightDir);\n    //vec3 l = normalize(lightPos - p);\n    \n    float dif = dot(n,l);\n\treturn dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col = vec3(0);\n    vec2 cuv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //noise scrolling\n    //uv += iTime * 0.1;\n\t//float c = SmoothNoise2(uv,4.);\n    //float c = N22(uv);   \n\t//col = vec3(c);\n    \n    vec3 ro = vec3 (0,2.,iTime * 100.);\n    vec3 rd = normalize(vec3(cuv.x,cuv.y,1.));\n    bool isMax;\n    float d = RayMarch(ro, rd, isMax);\n    vec3 p = ro + rd * d;\n    if(isMax)\n    {        \n        //skybox\n    \tcol = vec3(0.4*(1.-uv.y * .5),.8*(1.-uv.y * .5),1. * (uv.y * 0.5 + 0.5));\n    }\n    else {\n        \n\t\tvec3 n = GetNormal(p);\n    \tfloat dif = GetLight(p,n);\n        \n    \tcol = vec3(1.-n.y * .6,.6 * n.y + .4,.25 * n.y) * (dif * 0.7 + 0.3);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 88, 88, 153], [155, 155, 173, 173, 304], [306, 306, 333, 333, 638], [640, 640, 677, 677, 977], [979, 979, 1001, 1001, 1496], [1498, 1498, 1547, 1547, 1873], [1875, 1875, 1898, 1898, 2086], [2088, 2088, 2119, 2119, 2309], [2311, 2311, 2368, 2368, 3131]]}
{"id": "WlV3zD", "name": "A Simple Raymarched Sphere", "author": "TheCreator", "description": "This is my second raymarching shader. I used a tutorial to create a slightly deviated version. The link for it can be found at the top of the code.", "tags": ["raymarching", "beginner", "second"], "likes": 1, "viewed": 50, "published": "Public", "date": "1578426079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nMy second attempt at raymarching. I think I am finally starting to grasp the concept.\nUsing this tutorial, I was able to create this neat animating sphere: http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\nI used variables with clear names to make the code easier to understand & read for people new to raymarching.\nHave fun messing around in here!\n\n-TheCreator, 07/01/2020\n\n*/\n\n\n\n/*\n\nJust a utility method I created to avoid code duplication. \nAllows me to control a cos curve's parameters for color changes over time\n\n*/\nfloat cosiTime(float centerValue, float intensity, float offset) {\n    return centerValue + intensity * cos(iTime + offset);\n}\n\n\n\n/*\n\nSigned distance functions (short: SDFs) are functions which describe the shapes in a raymarched scene with math.\nOpposed to that are meshes made out of trianges, which most 3D games rely on today.\n\nYou can find a list of functions for describing different shapes here: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n*/\nfloat sphereSDF(vec3 samplePos, vec3 spherePos, float radius) {\n    return length(samplePos - spherePos) - radius;\n}\n\n\n\n/*\n\nThe SDF for all objects in the world. Currently only a sphere with animated displacement is being rendered.\n\n*/\nfloat worldSDF(vec3 samplePos) {\n    float displacement = sin(cosiTime(4.0, 3.0, 0.0) * samplePos.x) * sin(cosiTime(5.0, 2.0, 2.0) * samplePos.y) * sin(cosiTime(3.0, 4.0, 3.0) * samplePos.z) * 0.25;\n    float sphere0 = sphereSDF(samplePos, vec3(0.0), 1.0);\n    \n    return sphere0 + displacement;\n}\n\n\n\n/*\n\nThis function determines the surface normal. I don't fully understand how it works just yet.\n\n*/\nvec3 estimateNormal(vec3 pos) {\n    vec3 smallStep = vec3(0.001, 0.0, 0.0);\n    \n    float gradientX = worldSDF(pos + smallStep.xyy) - worldSDF(pos - smallStep.xyy);\n    float gradientY = worldSDF(pos + smallStep.yxy) - worldSDF(pos - smallStep.yxy);\n    float gradientZ = worldSDF(pos + smallStep.yyx) - worldSDF(pos - smallStep.yyx);\n    \n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n    \n    return normalize(normal);\n}\n\n\n\n/*\n\nThe actual raymarch function. Takes a ray origin and a ray direction and marches along the ray using a\ntechnique called \"sphere tracing\". The code checks for the nearest object using the world SDF and then\nmoves the next point that is checked to the edge of that sphere, ensuring the checked position is\neither outside of the object or on the edge of it. This continues until the ray hits an object\nor the maximum number of steps is reached. I might flesh out this explaination in the future, however\ntutorials online with an illustration can explain sphere tracing far better than a thousand words ever could.\n\n*/\nvec3 raymarch(vec3 rayOrigin, vec3 rayDir) {\n    float marchedDist = 0.0;\n    int maxSteps = 128;\n    float minHitDist = 0.001;\n    float maxTraceDist = 1000.0;\n    \n    for(int i = 0; i < maxSteps; ++i) {\n        vec3 marchPos = rayOrigin + marchedDist * rayDir;\n        \n        float sphereTraceDist = worldSDF(marchPos);\n        \n        if(sphereTraceDist < minHitDist) {\n            vec3 normal = estimateNormal(marchPos);\n            \n            //Manually set light position for now\n            vec3 lightPos = vec3(2.0, -5.0, 3.0);\n            vec3 directionToLight = normalize(marchPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n            \n            return vec3(cosiTime(0.5, 0.5, 0.0), cosiTime(0.5, 0.5, 2.0), cosiTime(0.5, 0.5, 4.0)) * diffuseIntensity;\n        }\n        \n        if(marchedDist > maxTraceDist) {\n            return vec3(0.0);\n        }\n        \n        marchedDist += sphereTraceDist;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, -2.0);\n    vec3 rayDirection = vec3(uv, 1.0);\n\n    vec3 col = raymarch(cameraPos, rayDirection);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 535, 601, 601, 661], [665, 1010, 1073, 1073, 1126], [1130, 1246, 1278, 1278, 1544], [1548, 1649, 1680, 1680, 2083], [2087, 2706, 2750, 2750, 3709], [3711, 3711, 3768, 3768, 4050]]}
{"id": "WlV3zG", "name": "Ray Marching - Comini", "author": "comini", "description": "Ray marching shader ", "tags": ["raymarching", "graphics"], "likes": 1, "viewed": 56, "published": "Public", "date": "1579225446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.0001\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec4 qsqr( in vec4 a ) // square a quaterion\n{\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n}\n\nfloat map(in vec3 p, in vec4 c)\n{\n    vec4 z = vec4(p,0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n\n    float n = 1.0;\n    for( int i=0; i<11; i++ )\n    {\n        // dz -> 2·z·dz, meaning |dz| -> 2·|z|·|dz|\n        // Now we take thr 2.0 out of the loop and do it at the end with an exp2\n        md2 *= mz2;\n        // z  -> z^2 + c\n        z = qsqr(z) + c;  \n\n        mz2 = dot(z,z);\n        if(mz2>4.0) break;\n        n += 1.0;\n    }\n\n    return 0.25*sqrt(mz2/md2)*exp2(-n)*log(mz2);  // d = 0.5·|z|·log|z| / |dz|\n}\n\n\nfloat sceneSDF(vec3 p)\n{\n    vec3 center = vec3(-sin(iTime)*0.2, 1, 1);\n    float radius = 0.1;\n    float sphere = length(p - center) - radius;\n    \n    vec3 boxCenter = vec3(sin(iTime)*0.2, 1, 1);\n    vec3 q = abs(p - boxCenter) - vec3(0.1);\n  \tfloat box = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    \n    return smin(box, sphere, 0.2);\n    \n    // float time = iTime*.15;\n    // vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    \n    // return map(p, c);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n    \n{  \n    vec3 rayOrigin = vec3(0, 1, 0);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.x;\n    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 lightPosition = vec3(sin(iTime), 1, cos(iTime));\n    vec3 lightColor = vec3(1);\n    \n    vec3 lightDirection = normalize(lightPosition - vec3(uv, 0));\n    \n    vec3 sphereColor = vec3(1, 0, 0);\n\n    vec3 ambient = 0.2 * lightColor;\n   \n    float depth = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n        \n        vec3 point = rayOrigin + depth * rayDirection;\n        float dist = sceneSDF(point);\n        \n        if (dist < EPSILON) {\n            float diff = max(dot(estimateNormal(point), lightDirection), 0.0);\n\t\t\tvec3 diffuse = diff * lightColor;\n            \n            fragColor = vec4((ambient + diffuse) * sphereColor, 1);\n            return;\n        }\n        \n        depth += dist;\n    }\n    \n    fragColor = vec4(0);\n    \n}\n                                  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 63, 63, 147], [149, 149, 195, 195, 345], [347, 347, 380, 380, 879], [882, 882, 906, 906, 1408], [1410, 1410, 1439, 1439, 1749], [1752, 1752, 1812, 1812, 2732]]}
{"id": "wlV3zW", "name": "TransferWise logo 3d", "author": "kow", "description": "Raymarching the TransferWise logo", "tags": ["3d", "logo", "transferwise"], "likes": 1, "viewed": 45, "published": "Public", "date": "1578478693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int N = 12;\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdLogo(vec2 p) {\n    vec2 center = vec2(-.45, .5);\n    float scale = 1.;\n    vec2 v0 = center - vec2(-0.127,0) * scale;\n    vec2 v1 = center - vec2(-0.295,0.262) * scale;\n    vec2 v2 = center - vec2(-0,0.524) * scale;\n    vec2 v3 = center - vec2(-0.51,0.524) * scale;\n    vec2 v4 = center - vec2(-0.558,0.419) * scale;\n    vec2 v5 = center - vec2(-0.277,0.419) * scale;\n    vec2 v6 = center - vec2(-0.447,0.261) * scale;\n    vec2 v7 = center - vec2(-0.348,0.105) * scale;\n    vec2 v8 = center - vec2(-0.812,0.105) * scale;\n    vec2 v9 = center - vec2(-0.404,1) * scale;\n    vec2 v10 = center - vec2(-0.544,1) * scale;\n    vec2 v11 = center - vec2(-1,0) * scale;\n\n    // add more points\n    vec2[] poly = vec2[](v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11);\n\n\treturn sdPoly(poly, p);\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 q = pos - vec3(.0, -.5, .0);\n    float logo = opExtrussion(q, sdLogo( q.xy ), 0.15 );\n    //float plane = sdPlane(pos, normalize(vec4(0, 1, 0, -1.5)));\n    return min(logo, 10.);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec3 ro = vec3(0.0, -.25, -1.0);\n        vec3 rd = normalize(vec3(p.x, p.y, 1.));\n\n        float t = 0.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<10.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(sin(iTime)*5., 3.0, -1. - cos(iTime) * .5));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 32.0 );\n            col = vec3(0.025,0.05,0.08) + dif*sha*vec3(.0, 0.09, 0.9);\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 78, 78, 174], [176, 176, 217, 217, 764], [766, 766, 788, 788, 1550], [1553, 1553, 1586, 1612, 1643], [1645, 1645, 1669, 1669, 1859], [1861, 1925, 1957, 1957, 2191], [2193, 2255, 2342, 2342, 2600], [2617, 2617, 2674, 2674, 3898]]}
{"id": "wlV3zy", "name": "[phreax] electric sheep", "author": "phreax", "description": "Kaleidoscopic polar shapes", "tags": ["2d", "rainbow", "kifs"], "likes": 20, "viewed": 296, "published": "Public", "date": "1579307582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2020\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 30.\n#define N 5.\n#define DISTORT .7\n#define SQR(x) ((x)*(x))\n\n\nfloat tt;\n\nvec2 kalei(vec2 uv) { \n    float n = N;\n    float r = TAU/n;\n    \n    for(float i=0.; i<n; i++) {     \n    \tuv = abs(uv);\n        uv.x -= .2*i+.2;\n    \tuv *= rot(r*i-.09*tt);\n    }\n    \n    uv = abs(uv) - (sin(.15*tt)+1.2);\n\n    return uv;\n}\n\n\nfloat flower(vec2 uv) {\n    float n = 3.;\n    float a = atan(uv.y,uv.x);\n\n    float d = length( uv) - cos(a*n);\n    return smoothstep(fwidth(d), 0., abs(d));    \n}\n\n\nvec3 spiral(vec2 uv, float i) {  \n    uv *= rot(i*PI+tt*.3);\n    uv += DISTORT*sin(5.*uv.yx);\n\treturn flower(uv)*SQR(hue(i+tt*.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    tt = iTime;\n    \n    uv = kalei(uv*5.);\n\n    float s = 1./COUNT;\n\t\n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(0., .1, 1.-abs(2.*z-1.));\n        col += spiral(uv*z, i)*fade;\n    }\n\n    col = sqrt(col);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3zy.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 324, 345, 345, 565], [568, 568, 591, 591, 731], [734, 734, 765, 765, 867], [869, 869, 926, 926, 1303]]}
{"id": "wlVGDz", "name": "HSL pallete", "author": "victorcesaroni", "description": "HSL pallete", "tags": ["hsl"], "likes": 2, "viewed": 58, "published": "Public", "date": "1579172586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hslToRgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float anim = mod(iTime*.1,1.f);\n    \n    vec3 col = hslToRgb(vec3(uv.x+anim, 1, uv.y));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 170], [172, 172, 229, 229, 395]]}
{"id": "WlVGRd", "name": "spooky2", "author": "Del", "description": "spooky", "tags": ["spooky"], "likes": 7, "viewed": 275, "published": "Public API", "date": "1579635326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// spooky2 21/01/2019\n\nfloat map(vec3 p)\n{\n\tp.xy += sin(p.x*0.1+iTime*0.8+p.z*1.2)*0.3;\n\tp.x += sin(iTime+p.y*.15)*0.2;\n\tvec3 tp = mod(p, 2.0) - 1.0;\n\tfloat t = length(tp.xz) - 0.26;\n\tp.y = abs(p.y*(sin(iTime*0.4+p.z*0.25)*0.25+1.55));\n\tt = min(t, 2.0 - dot(p, vec3(sin(p.z+iTime*0.2)*0.2, 1, 0)));\t// tilt\n\treturn t;\n}\n\nfloat trace(vec3 p, vec3 d)\n{\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < 22; i++)\n \t t += map(p + d * t);\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tt = step(mod(iTime+4.0,10.0),3.0);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tvec3 pos = vec3(0, 0, iTime*(0.8+tt*4.0));\n\tfloat t = trace(pos, dir);\n\tvec3 col = vec3(t*0.1,t*0.07,t*0.07);\n\tcol -= abs(sin(iTime+t*2.0)*0.05);\n\tif (tt>0.0)\n\t\tcol = 0.7-col;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    float v = 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\tfragColor = vec4(col*v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 42, 42, 319], [321, 321, 350, 350, 433], [435, 435, 492, 492, 951]]}
{"id": "wlVGRG", "name": "Urban Light", "author": "kstyler", "description": "I wanted to practice modeling with distance functions. This is my attempt to reinterpret the Urban light art piece at the LACMA.", "tags": ["raymarch", "infinite", "lamps", "la"], "likes": 2, "viewed": 132, "published": "Public API", "date": "1579409355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//distance functions from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nconst int MAX_DST = 800;\nconst float EPSI = 0.001;\nint mat = 0;//coloring objects\n\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),\n               \tsin(a), cos(a));\n}\n\nfloat roundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat box(vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat octagon(vec3 p, vec3 b){//Using 4 boxes to cut off the 4 conrers of another box and make an octagon.\n    float b1 =  box(p,b);\n    \n    vec3 b2Rot = p;\n    b2Rot.xz*= rotate(0.8);\n    float b2 =  box(b2Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b3Rot = p;\n    b3Rot.xz*= rotate(2.4);\n    float b3 =  box(b3Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n        \n    vec3 b4Rot = p;\n    b4Rot.xz*= rotate(4.0);\n    float b4 =  box(b4Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    vec3 b5Rot = p;\n    b5Rot.xz*= rotate(5.5);\n    float b5 =  box(b5Rot+vec3(b.x*2.0,0.,b.z*0.),b+vec3(0,1.,0));\n    \n    float sm = 0.05;\n    return smoothSub(b5,smoothSub(b4,smoothSub(b3,smoothSub(b2,b1,sm),sm),sm),sm);\n}\n\nfloat lampBase(vec3 p){\n    vec3 octPos = vec3 (0.,10.5,0.);\n    vec3 octPos2 = vec3 (0.,-0.8,0.);\n    return smoothUnion(octagon(p+octPos,vec3(2.0,0.4,2.0)),octagon(p+octPos2+octPos,vec3(1.8,0.4,1.8)),0.3);\n}\n\nfloat cyl(vec3 p){\n    float rad = 0.8;\n    rad -= 0.03*p.y;\n    rad -= 0.15*(0.3+0.3*sin(13.*atan(p.x,p.z)));\n    float d = length(p.xz)- rad;\t\n    d = max(d,p.y-10.);\n    d = max(d,-p.y-10.);\n\treturn d;\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p, bool setMat){\n    float c = 10.;\n    p.x = mod(p.x+c*0.5,c)-c*0.5;\n    p.z = mod(p.z+c*0.5,c)-c*0.5;\n    vec3 cylPos = vec3 (0.,0.,0.); \n    float bulb = roundCone(p+vec3(0,-11.0,0),1.2,1.4,1.);\n    float tip1 = sphere(p+vec3(0,-13.35,0),0.3);\n    float tip2 = sphere(p+vec3(0,-13.1,0),0.5);\n    \n    float minD =min(tip1,\n               \tmin(tip2,\n               \tmin(bulb,\n               \tsmoothUnion(torus(p+vec3(0,-10.2,0),vec2(0.7,0.4)),\n        \t\tsmoothUnion(octagon(p+vec3(0,6.5,0),vec3(1.05,0.4,1.05)),\n               \tsmoothUnion(torus(p+vec3(0,-8.6,0),vec2(0.53,0.1)),\n                smoothUnion(torus(p+vec3(0,-7.8,0),vec2(0.56,0.1)),\n                smoothUnion(cyl(p+cylPos),lampBase(p),1.0),0.1),0.1),0.1),0.5))));\n    \n    if(setMat){\n    if(minD == bulb ||minD == tip1 ||minD == tip2){//Lamp Light\n            mat = 2;\n    }else{mat =3;}//Lamp Body\n        \n    }\n    return minD;\n    \n}\n\nfloat rayMarch(vec3 ro,vec3 rd, bool setMat){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i < MAX_DST; i++){\n        vec3 p = ro + rd*tot;\n        dst = map(p,setMat);\n        tot+=dst;\n        if(dst<EPSI||tot>float(MAX_DST)){\n        \ttot = float(i)/float(MAX_DST);\n            break;\n        }\n     }\n    if(dst>EPSI && setMat){//sky\n    \tmat = 1;\n    }\n\treturn tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x; \n    vec3 ro = vec3(5,-3,-50. + iTime*10.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float rm = rayMarch(ro,rd,true);\n    vec3 col =vec3(rm);\n    \n    if(mat == 1)col = vec3(1);\n    if(mat == 2)col = vec3(1.,1.,0.85); \n    if(mat == 3)col += vec3(0.7,0.73,0.7);\n                \n    col = mix(col,vec3(1),1.-exp(-3.*rm));//fog\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 180, 201, 201, 265], [267, 267, 322, 322, 586], [588, 588, 622, 622, 653], [655, 655, 682, 682, 769], [771, 771, 821, 821, 921], [923, 923, 971, 971, 1072], [1074, 1074, 1104, 1180, 1806], [1808, 1808, 1831, 1831, 2017], [2019, 2019, 2037, 2037, 2225], [2227, 2227, 2257, 2257, 2322], [2324, 2324, 2355, 2355, 3246], [3248, 3248, 3293, 3293, 3634], [3636, 3636, 3692, 3692, 4113]]}
{"id": "WlVGRm", "name": "Four Rhombus Spiral Tessellation", "author": "revort", "description": "Takes the four rhombus tessellation and spiralizes according to two integers (a,b) describing the number of tilings in two vector directions.", "tags": ["spiral", "tiling"], "likes": 5, "viewed": 117, "published": "Public", "date": "1578598829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Using https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm for the rhombus sdf, \nhttps://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm for the repetition of the tiling\nusing rhombus tesselation functions from https://www.shadertoy.com/view/tlGGDR\nspiral stuff based on http://isohedral.ca/escher-like-spiral-tilings/\n*/\n\nfloat tau = 6.28318530718;\nfloat pi = 3.14159265358979;\nfloat sqrt_2 = 1.41421356237;\nfloat sqrt_half = 0.70710678118;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nvec2 rotatePoint(vec2 p, float theta){\n    return vec2(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\n\nvec2 translatePoint(vec2 p, vec2 t){\n    return p - t;\n}\n\nfloat tesselatedRhombiPos(float theta1, vec2 p){\n    vec2 p_ = p;\n    p_ = translatePoint(p_,vec2(0.5,0.5));\n    p_ = rotatePoint(p_,-pi/4.0);\n    float d = sdRhombus(p_, vec2(cos(pi/4.0),sin(pi/4.0)));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(0.5+0.5*cos(theta1),1.0+0.5*sin(theta1)));\n    p_ = rotatePoint(p_,-theta1/2.0);\n    d = min(d,sdRhombus(p_, vec2(cos(theta1/2.0),sin(theta1/2.0))));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(1.0+0.5*sin(theta1),0.5-0.5*cos(theta1)));\n    p_ = rotatePoint(p_,(pi-theta1)/2.0);\n    d = min(d,sdRhombus(p_, vec2(cos(theta1/2.0),sin(theta1/2.0))));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(1.0 + sqrt_half*cos(theta1-pi/4.0),1.0 + sqrt_half*sin(theta1-pi/4.0)));\n    p_ = rotatePoint(p_,-theta1-pi/4.0);\n    d = min(d,sdRhombus(p_, vec2(cos(pi/4.0),sin(pi/4.0))));\n    return d;\n}\n\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat getTesselatedRhombusVal(vec2 p, float theta1){\n    vec2 a_vec = vec2(cos(theta1),1.0+sin(theta1));\n    vec2 b_vec = vec2(1.0+sin(theta1),-cos(theta1));\n    float angle = atan(a_vec.y,a_vec.x);\n    float len = length(a_vec);\n    vec2 offset = vec2(len,len);\n    vec2 p_ = rotatePoint(p, -angle);\n    p_ = opRep(p_, offset);\n    float val = tesselatedRhombiPos(theta1,rotatePoint(p_, angle));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(offset.x,0.0), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(offset.x,0.0), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(0.0,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(0.0,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(offset.x,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(offset.x,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(-offset.y,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(-offset.y,offset.y), angle)));\n    return val;\n}\n\nfloat getFilteredRhombusVal(vec2 p, float theta1){\n    float val = 0.6*getTesselatedRhombusVal(p, theta1);\n    //basic filter to prevent aliasing crap\n    val += 0.1*getTesselatedRhombusVal(p+vec2(0.01,0.0), theta1);\n    val += 0.1*getTesselatedRhombusVal(p-vec2(0.01,0.0), theta1);\n    val += 0.1*getTesselatedRhombusVal(p+vec2(0.0,0.01), theta1);\n    val += 0.1*getTesselatedRhombusVal(p-vec2(0.0,0.01), theta1);\n    return val;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/2.0;\n    // Change these to any integer for more fun\n    vec2 ab = vec2(7.0,5.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    vec2 cart = uv * iResolution.xy / iResolution.x * 12.0;\n    // cart /= length(ab);\n    float angle = atan(cart.y,cart.x);\n    float r = length(cart)/2.0;\n    cart = vec2(angle,r);\n    float rhombus_theta = mod(t,2.0)*pi/2.0;\n    vec2 a_vec = vec2(cos(rhombus_theta),1.0+sin(rhombus_theta));\n    vec2 b_vec = vec2(1.0+sin(rhombus_theta),-cos(rhombus_theta));\n    vec2 ab_vec = ab.x*a_vec + ab.y*b_vec;\n    float theta=atan(ab_vec.y,ab_vec.x);\n    float l = length(ab_vec)/tau;\n    \n    vec2 p = vec2(cart.x*cos(theta)-cart.y*sin(theta),\n                  cart.x*sin(theta)+cart.y*cos(theta))*l;\n    vec2 offset_vec = (a_vec)*mod(t,2.0)/2.0;\n    p = p - offset_vec;\n    //p = p + vec2(offset_vec.x*cos(-theta)-offset_vec.y*sin(-theta), offset_vec.x*sin(-theta)+offset_vec.y*cos(-theta));\n    vec3 col = vec3(1.0);\n    float x_dist = min(abs(p.x-ceil(p.x)),abs(p.x-floor(p.x)));\n    float y_dist = min(abs(p.y-ceil(p.y)),abs(p.y-floor(p.y)));\n    float dist = min(x_dist,y_dist);\n    x_dist = mod(p.x,1.0);\n    y_dist = mod(p.y,1.0);\n    float val = getFilteredRhombusVal(p, rhombus_theta);\n    col = mix(col,vec3(0.0),0.5 + 0.5*cos(val*pi*8.0+t*5.0));\n    /*float d = abs(abs(abs(sdCircle(vec2(x_dist,y_dist)-vec2(0.5,0.5),0.3))-0.19)-0.09)-(0.05+0.025*sin(t+r));\n    if (d < 0.0){\n        col = mix(col,vec3(0.0),1.0-(abs(d)/0.2));\n    }*/\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 485, 514, 514, 542], [544, 544, 586, 586, 781], [783, 783, 821, 821, 901], [903, 903, 939, 939, 959], [961, 961, 1009, 1009, 1790], [1792, 1792, 1827, 1827, 1878], [1880, 1880, 1932, 1932, 3060], [3062, 3062, 3112, 3112, 3494], [3496, 3496, 3531, 3531, 3557], [3559, 3559, 3616, 3616, 5233]]}
{"id": "WlVGRt", "name": "Magma pool", "author": "rrrzzz", "description": "null", "tags": ["interactive", "bw"], "likes": 2, "viewed": 86, "published": "Public", "date": "1579619950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//initial code taken from http://pixelshaders.com/examples/quasicrystal.html\n// click and drag to zoom in / out\n\nfloat time;\nfloat delta = 0.01;\nvec2 p;\n\nfloat wave(vec2 p, float angle) {\n  vec2 direction = vec2(cos(angle), sin(angle));\n  return cos(dot(p, direction));\n}\n\nfloat wrap(float x) {\n  return abs(mod(x, 2.)-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.xxxx;\n    if (m.x < delta && m.y < delta){\n    \tp = (fragCoord / (iResolution.x * 0.9 / 10.) * (iResolution.y * 0.2 / 10.)) * .5;\n\n    }\n    else{\n        p = (fragCoord / (m.x+delta / 10.) * (m.y+delta / 10.)) * .5;\n}\n    \n  float brightness = 0.;\n  for (float i = 1.; i <= 11.; i++) {\n    brightness += wave(p, (iTime / 5.0 ) / i);\n  }\n\n  brightness = wrap(brightness);\n\n  fragColor.xyz = vec3(brightness);\n  fragColor.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 154, 187, 187, 271], [273, 273, 294, 294, 325], [327, 327, 384, 384, 849]]}
{"id": "wlVGRV", "name": "Better marching (updated)", "author": "NLIBS", "description": "-Dynamic relaxed sphere tracing (seems to always be faster)\n-Early sky detection (would only work for this fractal)\nIt's all at line 102\nCircle colours : outline=overstep, red=slow raymarching, green=fast raymarching, blue/purple=early sky detection", "tags": ["raymarching", "fast"], "likes": 15, "viewed": 475, "published": "Public API", "date": "1579679425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nExplanation:\n\n\tEarly sky detecion:\n\n\tIf the point in question returns a large enough distance and \n\tits direction from the origin (0,0,0) is similar to the ray \n\tdirection, it is safe to assume the ray will never hit the \n\tobject again, saving alot of time marching into the distance.\n\n\n\tRelaxed sphere tracing:\n\n\tThis is an old technique. You start your marching with an \n\tomega value. This value multiplies the distance at each step\n\tso that marching is faster. The Only problem is that you \n\tmight march right past something (overstep), but its easy to\n\tdetect if this happened. Just see if the previous distance \n\tplus the Current distance is smaller that what you just \n\tstepped by, and if so go back a bit to make sure you are \n\tcorrect. With this old technique the omega value is set \n\tto 1 after an overstep is detected. But we can do better!\n\n\n\tDynamic relaxed sphere tracing (I just made this up):\n\n\tInstead of just reverting to normal raymarching after an\n\toverstep, simply solve for the highest value of omega that\n\tWouldn't have caused any problems and set it to that! \n\tIts also easy to extend on this by bringing the omega closer\n\tto this optimum amount each step, meaning the marching speed\n\tis always as fast as possible! \n\tWe can also use the distance that was calculated at the \n\toverstep point so that no information is thrown away. (line 140)\n\t\n\n\tThanks, I hope this can help someone out!\n*/\n\n//Ps you can comment line 146 to see normal raymarching instead.\n\n\n\n//fractal params\nconst float w0 = 0.;\nconst float scaleM = 2.;\nconst float iters = 8.;\nconst vec4 offsetM = vec4(0,0,0,0.1);\nconst vec4 ScaleC = vec4(1.,1.,1.,0.5);\nconst vec4 scaleC_c = vec4(\n \tScaleC.x*(scaleM-1.)    /scaleM, // the divide is for more _c\n    ScaleC.y*(scaleM-1.)    /scaleM,\n    ScaleC.z*(scaleM-1.)/scaleM*0.5,\n    ScaleC.w*(scaleM-1.)    /scaleM\n);\nconst float scaleC_c2 = scaleC_c.z*.5;\n\n#define angle 0.12\nconst mat2 rot2D = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n\n//Mixpinski\nfloat de(vec3 p){\n\tvec4 z = vec4(p,w0);\n\n    float i = 0.;\n\tfloat r = 0.;   \n    for (; i<iters; i++){\n        if(z.x+z.y<0.0) z.xy = -z.yx;\n\t\tif(z.x+z.z<0.0) z.xz = -z.zx;\n        if(z.y+z.z<0.0) z.yz = -z.zy;\n        if(z.x+z.w<0.0) z.xw = -z.wx;\n\t\tif(z.y+z.w<0.0) z.yw = -z.wy;\n\t\tif(z.z+z.w<0.0) z.zw = -z.wz;\n\n\t\tz += offsetM;\n        z = scaleM*vec4(z.xyw-scaleC_c.xyw,scaleC_c2-(z.z-scaleC_c2)*sign(z.z)).xywz;\n        z.xy *= rot2D;\n\t}\n\n    return length(z)*exp2(-i)-1./exp2(iters); //.0017\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Boring variables\n    float stime = (iTime+5.5)*0.31415;\n    float zslice = -.158;//cos(stime);\n    vec3 spos = vec3((fragCoord-iResolution.xy*.5f)/iResolution.x * 5.,zslice);\n    vec3 rd = vec3(cos(sin(stime)*.5+.6),sin(sin(stime)*.5+.6),0);\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    vec3 ro = vec3(mouseUV,zslice);\n    float T = 0.;\n    \n    //Colour \n    float h = de(spos);\n    vec3 col = vec3((6.-h)*0.04);\n    if (h<=0.) col = vec3(1); //.002\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<10; ++i) {\n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = de(p);\n        \n        //Drawing circles\n        vec2 shade = mix(vec2(0.1,0.9),vec2(0.9,0.1),smoothstep(1.,2.,omega));\n        float edge = clamp((h-length(spos-p))*100.+1.,0.,1.);\n        col.xy = mix(col.xy, col.xy*shade+1.-shade, edge);\n\t\t//for (int i2 = 0; i2<i+1; i2++) {\n        //   \tcol += step(length(spos-p-vec3((float(i2)-float(i)/2.)*0.03,0,0)),.01)*2.*sign(float(i%2)-.5);\n        //}\n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            col -= smoothstep(0.008,.0,abs(h-length(spos-p)))*6.; //Draw a black outline\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            if (h>.2 && dot(p,rd)>0.3) { //Sky bailout\n            \tif (length(spos-p)<h) col.b = col.b*0.1+0.9; \n            \tbreak;\n            }\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n\t\n\t\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1986, 1998, 2015, 2015, 2496], [2499, 2499, 2556, 2584, 4637]]}
{"id": "wlVGRz", "name": "Echeveria", "author": "tdhooper", "description": "Click to see different distributions", "tags": ["plant", "succulent"], "likes": 132, "viewed": 4385, "published": "Public API", "date": "1578176135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI  = 3.14159265359;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat time;\n\nvec4 leaf(vec3 p, vec2 uv) {\n    float thick = clamp(uv.y, .7, 1.);\n    thick = 1.;\n    float th = thick * .16;\n    pR(p.xz, -uv.x);\n    float width = mix(.5, .1, min(uv.y, 1.));\n    width = .75 / uv.y;\n    width *= thick;\n    vec3 n = normalize(vec3(1,0,width));\n    float d = -dot(p, n);\n    d = max(d, dot(p, n * vec3(1,1,-1)));\n    float len = mix(PI / 1.2, PI / 2., pow(uv.y/2.9, 2.));\n    len = max(len, 0.);\n    pR(p.yz, PI / 2. - len);\n    d = smax(d, p.y, thick);\n    d = smax(d, abs(length(p) - uv.y) - thick * th, th);\n    vec2 uuv = vec2(\n        atan(p.y, p.z) / -len,\n        p.x\n   \t);\n    vec3 col = mix(vec3(0), vec3(.5,1,.7) * .05, 1.-smoothstep(.0, .5, uuv.x));\n    col += vec3(.06,.0,.03) * max(1. - uv.y / 2., 0.);\n    col = mix(col, col * .2, 1.-smoothstep(.0, .2, uuv.x));\n    return vec4(d, col);\n}\n\nbool lightingPass;\n\nvec4 opU(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 bloom(vec3 p) {\n\n    float bound = length(p - vec3(0,-1.2,0)) - 3.3;\n    bound = max(bound, p.y - 1.1);\n    if (bound > .01 && ! lightingPass) {\n        return vec4(bound, 0, 0, 0);\n    }\n\n    vec2 cc = vec2(5., 8.);\n    if (iMouse.z > 0.) {\n    \tcc = floor(iMouse.xy / iResolution.xy * 10.);\n    }\n    float aa = atan(cc.x / cc.y);\n    float r = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 rot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    \n    vec2 offset = vec2(1, 2) * time * r * rot;\n    \n    vec2 uv = vec2(\n        atan(p.x, p.z),\n        length(p)\n    );\n\n    uv -= offset;\n\n    uv = rot * uv;\n    vec2 cell = round(uv / r);\n\n    vec4 d = vec4(1e12, vec3(0));\n\n    d = opU(d, leaf(p, ((cell + vec2(-1, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 0)) * rot * r) + offset));\n\n    //*\n    d = opU(d, leaf(p, ((cell + vec2(-1, -1)) * rot * r) + offset));\n   \td = opU(d, leaf(p, ((cell + vec2(-1, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 1)) * rot * r) + offset));\n\t//*/\n\n    return d;\n}\n\nvec4 map(vec3 p) {\n    return bloom(p);\n}\n\nvec3 calcNormal(vec3 pos){\n    float eps = .0005;\n    vec2 e = vec2(1.0,-1.0) * 0.5773;\n    return normalize(\n        e.xyy * map(pos + e.xyy * eps).x + \n\t\te.yyx * map(pos + e.yyx * eps).x + \n\t\te.yxy * map(pos + e.yxy * eps).x + \n\t\te.xxx * map(pos + e.xxx * eps).x\n    );\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//#define AA 3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 2., 1.);\n    time = mTime;\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n        lightingPass = false;\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0.5, 7.4, -8.7) * .9;\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-1.4,0), -0.5);\n        vec3 rd = normalize( camMat * vec3(p.xy,2.8) );\n\n        vec3 pos = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        vec4 res;\n\n        for (int i = 0; i < 100; i++) {\n            rayLength += dist;\n            pos = camPos + rd * rayLength;\n            res = map(pos);\n            dist = res.x;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 16.) {\n                bg = true;\n                break;\n            }\n        }\n\n        col = vec3(.19,.19,.22) * 1.9;\n        col = vec3(.35,.24,.0) * 1.8;\n\t\tcol = vec3(.5,1,.7) * .05;\n        \n        if ( ! bg) {\n            \n            lightingPass = true;\n            \n\t\t\tvec3 nor = calcNormal(pos);\n            float occ = calcAO( pos, nor );\n            vec3  lig = normalize( vec3(-.2, 1.5, .3) );\n            vec3  lba = normalize( vec3(.5, -1., -.5) );\n            vec3  hal = normalize( lig - rd );\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            occ = mix(1., occ, .8);\n            \n            dif *= softshadow( pos, lig, 0.001, .9 );\n\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n            vec3 lin = vec3(0.0);\n            lin += 2.80*dif*vec3(1.30,1.00,0.70);\n            lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n            lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n            lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n            col = res.yzw;\n        \tcol = col*lin;\n\t\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n\n            //col = nor * .5 + .5;\n            //col = max(dot(vec3(.1,1,-.2), nor), 0.) * vec3(.2);\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col *= 1.3;    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 66, 66, 111], [113, 113, 151, 151, 262], [264, 264, 303, 303, 334], [349, 349, 377, 377, 1171], [1193, 1193, 1219, 1219, 1251], [1253, 1253, 1273, 1273, 2574], [2576, 2576, 2594, 2594, 2617], [2619, 2619, 2645, 2645, 2892], [2894, 2935, 3009, 3009, 3296], [3298, 3339, 3381, 3381, 3683], [3685, 3685, 3749, 3749, 3927], [3929, 3945, 4000, 4000, 6890]]}
{"id": "wlVGWh", "name": "sdTriPrism Sponge", "author": "jorge2017a1", "description": "sdTriPrism Sponge", "tags": ["sdtriprismsponge"], "likes": 2, "viewed": 36, "published": "Public", "date": "1578849378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n \n    \n    float sdTp1= sdTriPrism(p, vec2(1.5,1.0) );\n    d =sdTp1;\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 50], [52, 52, 81, 81, 167], [169, 169, 198, 198, 274], [277, 277, 359, 359, 590], [593, 593, 629, 629, 732], [734, 734, 770, 770, 1081], [1083, 1083, 1147, 1147, 1425], [1427, 1427, 1463, 1463, 1813], [1814, 1874, 1920, 1920, 1952], [1954, 1954, 1996, 1996, 2028], [2030, 2030, 2077, 2077, 2110], [2173, 2348, 2371, 2371, 2509], [2512, 2512, 2534, 2534, 2604], [2606, 2606, 2625, 2625, 3075], [3077, 3077, 3098, 3098, 3331], [3333, 3333, 3366, 3366, 3649], [3651, 3651, 3708, 3708, 4088]]}
{"id": "WlVGWm", "name": "eindacor_let_it_snow", "author": "Eindacor_DS", "description": "snow test", "tags": ["test"], "likes": 0, "viewed": 55, "published": "Unlisted", "date": "1579104632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float normalizeSin(float sinValue)\n{\n  \treturn (sinValue + 1.) / 2.;  \n}\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat getYGround(\n\tfloat index,\n\tfloat layerScale,\n\tfloat groundVariation,\n    float xCoord)\n{\n    float groundStep = .02 * pow(1.5, index);\n\n    return (.35 + (sin(xCoord / mix(0.01, .05, layerScale))) * groundVariation) - groundStep;\n}\n\nvoid drawGroundLine(\n    out vec3 color, \n    float yGround,\n    vec2 uv, \n\tfloat pixelHeight,\n\tfloat lineThickness)\n{\n    float groundDist = abs(uv.y - yGround);       \n    float groundLineValue = smoothstep(groundDist - pixelHeight / 2., groundDist + pixelHeight / 2., lineThickness);\n\n    if (groundLineValue > 0.)\n    {\n        color = mix(color, vec3(1.), groundLineValue); \n    }\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\n\n\nint getRandomIntFromRange(int minInclusive, int maxInclusive, float value)\n{\n    return int(mix(float(minInclusive), float(maxInclusive + 1), value));\n}\n\nvoid drawLine(\n    out vec3 color,\n    vec3 lineColor,\n\tfloat thickness,\n    vec2 uv,\n\tvec2 first,\n\tvec2 second)\n{\n    if (first.x > second.x)\n    {\n        vec2 temp = first;\n        first = second;\n        second = temp;\n    }\n    \n    // find angle of line\n    float angle = atan((second.y - first.y) / (second.x - first.x));\n    \n    // rotate uv around first by angle\n    vec2 rotatedUV = rotateAroundAxis(uv, first, -angle);\n    \n    // shifting to account for point's endline\n    vec2 edgeShift;\n    \n    if (rotatedUV.x < first.x + distance(first, second) && rotatedUV.x > first.x)\n    {\n        float pixelHeight = 1. / iResolution.y;\n        if (rotatedUV.y > first.y)\n        {\n            float val = smoothstep(first.y + thickness + pixelHeight, first.y + thickness - pixelHeight, rotatedUV.y);\n            color = mix(color, lineColor, val);\n        }\n        else if (rotatedUV.y < first.y)\n        {\n            float val = smoothstep(first.y - thickness - pixelHeight, first.y - thickness + pixelHeight, rotatedUV.y);\n            color = mix(color, lineColor, val);\n        }\n    }\n}\n\nvoid drawTreeHelper(\n\tout vec3 color,\n\tvec3 treeColor,\n\tfloat thickness,\n\tvec2 uv,\n\tvec2 first,\n\tvec2 second,\n\tfloat branchAngle,\n\tout int branchCount,\n\tout float leftAngle,\n\tout float maxBranchLength,\n    out float minBranchLength,\n\tout float treeAngle)\n{\n    drawLine(color, treeColor, thickness, uv, first, second);\n    \n    treeAngle = atan((second.y - first.y) / (second.x - first.x));\n    leftAngle = treeAngle + branchAngle;\n       \n    branchCount = getRandomIntFromRange(3, 8, hash(first * second));\n    branchCount = 10;\n    maxBranchLength = abs(length(second - first)) / float(branchCount) * 3.;\n    minBranchLength = maxBranchLength / 5.;\n}\n\nvec2[3] getBranchCoords(\n    vec2 first, \n    vec2 second, \n    int branchCount, \n    int i, \n    float leftAngle, \n    float maxBranchLength, \n    float minBranchLength, \n    float branchAngle, \n    bool flip,\n\tfloat noise)\n{\n    float branchNoise = hash(vec2(float(i), noise));\n    float branchLength = mix(minBranchLength, maxBranchLength, branchNoise);\n    \n    vec2 branchBase = mix(first, second, float(i + 1) / float(branchCount));    \n    \n    vec2 branchLeft = mix(first, second, float(i + 2) / float(branchCount));\n    branchLeft = mix(branchBase, branchLeft, branchLength / length(branchLeft - branchBase));\n    \n    float branchRotation = flip ? branchAngle : -branchAngle;\n    \n    branchLeft = rotateAroundAxis(branchLeft, branchBase, branchRotation);\n    \n    vec2 branchRight = rotateAroundAxis(branchLeft, branchBase, -2. *branchRotation) ;\n    return vec2[3] (branchBase, branchLeft, branchRight);\n}\n\nvoid drawTreeAtLine0(\n\tout vec3 color,\n    vec3 treeColor,\n\tfloat thickness,\n    vec2 uv,\n\tfloat noise,\n\tvec2 first,\n\tvec2 second,\n\tfloat branchAngle)\n{\n    int branchCount;\n    float leftAngle, maxBranchLength, minBranchLength, treeAngle;\n    \n    drawTreeHelper(color, treeColor, thickness, uv, first, second, branchAngle, branchCount, leftAngle, maxBranchLength, minBranchLength, treeAngle);\n    \n    for (int i=0; i < branchCount; i++)\n    {\n        vec2[3] branchCoords = getBranchCoords(\n            first, \n            second, \n            branchCount, \n            i, \n            leftAngle, \n            minBranchLength, \n            maxBranchLength, \n            branchAngle, \n            tan(treeAngle) < 0.,\n        \tnoise);  \n        drawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[1]);\n        drawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[2]);\n    }\n}\n\n\nvoid drawTreeAtLine1(\n\tout vec3 color,\n    vec3 treeColor,\n\tfloat thickness,\n    vec2 uv,\n\tfloat noise,\n\tvec2 first,\n\tvec2 second,\n\tfloat branchAngle)\n{\n    int branchCount;\n    float leftAngle, maxBranchLength, minBranchLength, treeAngle;\n    \n    drawTreeHelper(color, treeColor, thickness, uv, first, second, branchAngle, branchCount, leftAngle, maxBranchLength, minBranchLength, treeAngle);\n    \n    int subTreeCount = 0;\n    \n    for (int i=0; i < branchCount; i++)\n    {\n        vec2[3] branchCoords = getBranchCoords(\n            first, \n            second, \n            branchCount, \n            i, \n            leftAngle, \n            minBranchLength, \n            maxBranchLength, \n            branchAngle, \n            tan(treeAngle) < 0.,\n        \tnoise); \n        \n        if (subTreeCount < 2 && smoothstep(minBranchLength, maxBranchLength, length(branchCoords[1] - branchCoords[0])) > .8)\n        {\n            drawTreeAtLine0(color, treeColor, thickness, uv, noise, branchCoords[0], branchCoords[1], branchAngle);\n        \tdrawTreeAtLine0(color, treeColor, thickness, uv, noise, branchCoords[0], branchCoords[2], branchAngle);\n            subTreeCount++;\n        }\n        else\n        {\n            drawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[1]);\n        \tdrawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[2]);\n        }      \n    }\n}\n\nvoid drawTreeAtLine2(\n\tout vec3 color,\n    vec3 treeColor,\n\tfloat thickness,\n    vec2 uv,\n\tfloat noise,\n\tvec2 first,\n\tvec2 second,\n\tfloat branchAngle)\n{\n    int branchCount;\n    float leftAngle, maxBranchLength, minBranchLength, treeAngle;\n    \n    drawTreeHelper(color, treeColor, thickness, uv, first, second, branchAngle, branchCount, leftAngle, maxBranchLength, minBranchLength, treeAngle);\n    \n    int subTreeCount = 0;\n    \n    for (int i=0; i < branchCount; i++)\n    {\n        vec2[3] branchCoords = getBranchCoords(\n            first, \n            second, \n            branchCount, \n            i, \n            leftAngle, \n            minBranchLength, \n            maxBranchLength, \n            branchAngle, \n            tan(treeAngle) < 0.,\n        \tnoise); \n        \n        if (subTreeCount < 2 && smoothstep(minBranchLength, maxBranchLength, length(branchCoords[1] - branchCoords[0])) > .8)\n        {\n            drawTreeAtLine1(color, treeColor, thickness, uv, noise, branchCoords[0], branchCoords[1], branchAngle);\n        \tdrawTreeAtLine1(color, treeColor, thickness, uv, noise, branchCoords[0], branchCoords[2], branchAngle);\n            subTreeCount++;\n        }\n        else\n        {\n            drawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[1]);\n        \tdrawLine(color, treeColor, thickness, uv, branchCoords[0], branchCoords[2]);\n        }      \n    }\n}\n\nvoid drawSnowflake(\n    out vec3 color, \n    float flakeArmThickness, \n    float noise, \n    vec2 uv, \n    vec2 cursor, \n    float flakeRadius)\n{\n    float segments = 6.;\n    float rotationStep = 6.28318 / segments;\n    float bisectedRotationStep = rotationStep / 2.;\n    for (int c=0; c < int(segments); c++)\n    {\n        float angle = float(c) * rotationStep;\n        float adjustedRotation = angle + iTime;// + noise;\n        \n        if (noise < .5)\n            adjustedRotation *= -1.;\n        \n        float thickness = 1.;\n        float branchAngle = 3.14159 / 3.;\n        vec2 perimeterPoint = rotateAroundAxis(cursor + vec2(0., flakeRadius), cursor, angle);\n        drawTreeAtLine2(color, vec3(1., 1., 1.), thickness, uv, noise * floor(iTime / 3.), cursor, perimeterPoint, branchAngle);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 normalizedUV = uv / iResolution.xy;   \n    \n    int flakeLayers = 6;\n      \n    vec3 skyColor = vec3(.5, .75, 1.);\n    vec3 color = mix(vec3(1.), skyColor, normalizedUV.y * 1.3);\n    \n    // proportion of smallest flakes to largest\n    float distFactor = .1;\n    \n    float xSpacingMax = .4;\n    float fuzzValueMax = 10.;\n    float radiusMax = .03;\n    //radiusMax = .1;\n    float fallingTimeScaleMax = 1.;\n    float shiftTimeScale = 4.;\n    float pixelHeight = 1. / iResolution.y;\n    float groundFadeCoeff = .1;\n    float lineThickness = .003;\n    float groundVariation = .002;\n    \n    //for (int i=flakeLayers; i > 0; i--)\n    for (int i=0; i < flakeLayers; i++)\n    {     \n        if (i != flakeLayers - 1 && false)\n            continue;\n        \n        float layerScale = float(i) / float(flakeLayers);\n        float depthScale = mix(distFactor, 1., layerScale);\n        \n        float yGround = getYGround(float(i), layerScale, groundVariation, normalizedUV.x);\n        \n        if (normalizedUV.y < yGround)\n        {\n            color = mix(mix(skyColor, vec3(1.0), .8), mix(skyColor, vec3(1.0), .95), layerScale);\n            continue;\n        }\n        \n        drawGroundLine(color, yGround, normalizedUV, pixelHeight, lineThickness);\n                   \n       \tfloat xSpacing = xSpacingMax * depthScale;\n        float fuzzValue = fuzzValueMax * depthScale;\n        float radius = radiusMax * depthScale;\n        float horizontalShift = xSpacing * depthScale;\n        float fallingTimeScale = fallingTimeScaleMax * depthScale;\n\n        float xOrigin = round(normalizedUV.x / xSpacing) * xSpacing;\n        \n        float ySpacing = radius * 40.;\n    \n        float yRepetitions = 1. / ySpacing;\n        for (int n=0; n < int(yRepetitions) + 1; n++)\n        {\n            float noise = hash(vec2(xOrigin * float(i + 1), float(n + 1)));\n            \n            float yCoord = 1. - fract(iTime * fallingTimeScale + float(n) * ySpacing + noise);\n            if (yCoord > 1. || yCoord < yGround)\n            {\n             \tcontinue;   \n            }\n\n            float xCoord = xOrigin + (sin((iTime + noise) * shiftTimeScale) * ((xSpacing / 2.) - radius));\n         \n            vec2 cursor = vec2(xCoord, yCoord) * iResolution.xy;\n\n            float dist = length(uv - cursor);\n\n            //float value = smoothstep(dist - fuzzValue / 2., dist + fuzzValue / 2., radius * iResolution.y);\n            //color = mix(color, vec3(1.), value);       \n\n            float flakeRadius = radius * iResolution.y;\n            if (dist < radius * iResolution.y)\n            {     \n                drawSnowflake(color, 2. * depthScale, noise, uv, cursor, flakeRadius);\n            }  \n        }     \n    }   \n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 72], [74, 120, 140, 140, 206], [208, 208, 302, 302, 445], [447, 447, 565, 565, 834], [836, 836, 896, 896, 1065], [1069, 1069, 1145, 1145, 1221], [1223, 1223, 1337, 1337, 2323], [2325, 2325, 2581, 2581, 2978], [3899, 3899, 4051, 4051, 4815], [4818, 4818, 4970, 4970, 6220], [6222, 6222, 6374, 6374, 7624], [7626, 7626, 7771, 7771, 8430], [8431, 8431, 8488, 8538, 11321]]}
{"id": "wlVGWV", "name": "Color translation", "author": "khadari", "description": "Color change by translation", "tags": ["color", "translation"], "likes": 0, "viewed": 72, "published": "Public", "date": "1579963714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(cos(iTime)+1.0,iTime+sin(iTime),iTime*10.0))-iTime*sin(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 367]]}
{"id": "WlVGWz", "name": "learn10", "author": "schlaffi", "description": "Using the tutorial> https://www.youtube.com/watch?v=zfcCHPeDOhU\nbased on> https://www.shadertoy.com/view/lt33z7 ", "tags": ["dwdwdwd"], "likes": 2, "viewed": 69, "published": "Public", "date": "1578684223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nint MAX_MARCHING_STEPS = 100;\nfloat MIN_DIST = 0.1;\nfloat MAX_DIST = 50.0;\nfloat EPSILON = 0.01;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n \n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    vec3 sp2 = samplePoint;\n    sp2.x = fract(sp2.x*0.5+1.0)/0.5-1.0;\n    sp2.z = fract(sp2.z*0.5+1.0)/0.5-1.0;\n    return length(sp2) - 0.4;\n}\n\nfloat lightSdf(vec3 samplePoint ) {\n    float l = length(samplePoint);\n    if ( l < 0.3 ) {\n    \treturn l+0.3;\n    } else {\n    \treturn l-0.3;\n    }\n}\n\n\nfloat planeSDF(vec3 sp) {\n\treturn abs(sp.y+cnoise(sp*5.0+iTime*vec3(0,1.0,0.0))*.5) ;\n}\n    \n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nvec2 sceneSDF(vec3 samplePoint) {\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \n    float stuff[10];\n    stuff[0] = lightSdf(samplePoint-light1Pos);\n    stuff[1] = lightSdf(samplePoint-light2Pos);\n    stuff[2] = sphereSDF(samplePoint);\n    stuff[3] = planeSDF(samplePoint);\n\n    float m=99999.0;\n    float mat=0.;\n    for(int i = 0; i<=3; i++) {\n        if( stuff[i] < m ) {\n            mat = float(i);\n            m = stuff[i];\n        }\n    }\n    \n    return vec2(m, mat);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 depth = vec2(start,0.);\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth.x * marchingDirection);\n        if (dist[0] < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        depth.y=dist.y;\n        if (depth.x >= end) {\n            return vec2(end,0.);\n        }\n    }\n    return vec2(end,0.);\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// light source material\nvec3 lightSource(vec3 lightColor, vec3 lightPos, vec3 p, vec3 eye){\n\treturn lightColor/pow(length(p-lightPos),1.0);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 light1Pos, vec3 light2Pos, vec3 light1Intensity, vec3 light2Intensity) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n;\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n;\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    \n    color = color + light1Intensity/pow(length(p-light1Pos),1.0);\n    color = color + light2Intensity/pow(length(p-light2Pos),1.0);\n    \n    color = estimateNormal(p);\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 dir = rayDirection(50.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 1.5 , 9.0);\n    vec2 dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 initColor = vec3(uv, 1.0-uv.y);\n    vec3 color = initColor;\n    if (dist.x > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n    } else {\n\n        // The closest point on the surface to the eyepoint along the view ray\n        vec3 p = eye + dist.x * dir;\n\n        vec3 K_a = vec3(0.5, 0.1, 0.1);\n        vec3 K_d = vec3(0.7, 0.5, 0.4);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 200.0;\n\t\t\n        vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    \tvec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    \tvec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \tvec3 light2Intensity = vec3(0.0, 0.4, 0.4);\n        \n        if (dist.x>2.) {\n            if (dist.y==2.){\n                color = phongIllumination(K_a, K_d, K_s, shininess, p, eye,  light1Pos, light2Pos, light1Intensity, light2Intensity);\n            } else if (dist.y==3.) {\n                color = phongIllumination(vec3(0.0, 0., 0.), vec3(0.1, 0.1, 0.5), vec3(.5, .5, 1.), 50., p, eye, light1Pos, light2Pos, light1Intensity, light2Intensity);\n            } else if (dist.y==0.) {\n                color = lightSource(light1Intensity, light1Pos, p, eye);\n            } else if (dist.y==1.) {\n                color = lightSource(light2Intensity, light2Pos, p, eye);\n            }\n        }\n    }\n\n    float foctor = fract(dist.x/MAX_DIST);\n    color = color*(1.0-foctor)+foctor*initColor;//vec3(1.,.9,.8)/;\n    \n    //color=vec3(fract(dist));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 499, 520, 520, 557], [558, 558, 585, 585, 633], [634, 634, 653, 653, 689], [691, 691, 712, 712, 2984], [2989, 3078, 3113, 3113, 3257], [3259, 3259, 3294, 3294, 3409], [3412, 3412, 3437, 3437, 3499], [3505, 3745, 3778, 3778, 4439], [4441, 4862, 4952, 4952, 5315], [5330, 5584, 5649, 5649, 5781], [5783, 5872, 5901, 5901, 6223], [6225, 6717, 6857, 6857, 7452], [7454, 7479, 7546, 7546, 7596], [7598, 7970, 8131, 8131, 8749], [8752, 8752, 8809, 8809, 10666]]}
{"id": "wlVGz3", "name": "My test01", "author": "tonywu", "description": "Just for test", "tags": ["test"], "likes": 1, "viewed": 194, "published": "Public API", "date": "1579524077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float mask = Circle(uv, vec2(0), 0.4, 0.05);\n    mask -= Circle(uv, vec2(0.3*sin(iTime), 0.3*cos(iTime)), 0.25, 0.05);\n    vec3 col = vec3(1);\n    col *= mask;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 132], [134, 134, 191, 241, 651]]}
{"id": "wlVGzw", "name": "MovingCircle", "author": "Harekelas", "description": "Practice shader", "tags": ["test"], "likes": 0, "viewed": 63, "published": "Public", "date": "1578573520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 DrawCircle (vec2 coord, vec2 c, float r, float th)\n{\n    float d = length(coord - c * iResolution.xy);\n    float col = 0.;\n    \n    if(d < r) col = 1. - (d - r + th) / th;\n    \n    return vec4(vec3(col), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float s = sin(iTime) * 0.2 + 0.5;\n    float c = cos(iTime) * 0.2 + 0.5;   \n    float as = -sin(iTime) * 0.2 + 0.5;\n    float ac = -cos(iTime) * 0.2 + 0.5;   \n       \n    vec4 c1 = DrawCircle(fragCoord, vec2(c - 0.1,s - 0.1), 100.,30.);\n    vec4 c2 = DrawCircle(fragCoord, vec2(s + 0.1,c + 0.1), 100.,40.);\n    vec4 c3 = DrawCircle(fragCoord, vec2(as + 0.1,c + 0.1), 100.,25.);\n    vec4 c4 = DrawCircle(fragCoord, vec2(as - 0.1,ac - 0.1), 100.,30.);\n    \n\tfragColor = c1 * vec4(0, s, c,1.) * c * 2. + \n        \t\tc2 * vec4(c, s, 0,1.) *  s * 2. + \n        \t\tc3 * vec4(c, 0, s,1.) * as * 2. +\n        \t\tc4 * vec4(s * 0.5, as, ac,1.) * as * 2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 214], [216, 216, 273, 273, 965]]}
{"id": "wly3DD", "name": "sdOpN01-Sponge-fractal", "author": "jorge2017a1", "description": "sdOpN01-Sponge-fractal", "tags": ["sdopn01spongefractal"], "likes": 3, "viewed": 69, "published": "Public", "date": "1578949265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n   \td=999.9;\n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(2.65,1.5,0.8));\n    \n    \n    float sdc0=sdCylinder( p.xzy-vec3(-1.5,4.5,1.5), vec2(0.5,5.0) ) ;\n    float sdc1=sdCylinder( p.xzy-vec3(0.0,4.5,1.5), vec2(0.5,3.0) ) ;\n    float sdc2=sdCylinder( p.xzy-vec3(1.5,4.5,1.5), vec2(0.5,5.0) ) ;;\n  \n    \n        \n    d = unionSDF(d, bxInf);\n    \n    d = unionSDF(d, sdc0);\n    d = unionSDF(d, sdc1);\n    d = unionSDF(d, sdc2);\n    \n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 4.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 50], [52, 52, 81, 81, 167], [169, 169, 198, 198, 274], [277, 277, 359, 359, 590], [593, 593, 629, 629, 732], [734, 734, 770, 770, 1081], [1083, 1083, 1147, 1147, 1425], [1428, 1488, 1534, 1534, 1566], [1568, 1568, 1610, 1610, 1642], [1644, 1644, 1691, 1691, 1724], [1787, 1962, 1985, 1985, 2123], [2126, 2126, 2148, 2148, 2218], [2220, 2220, 2239, 2239, 3059], [3061, 3061, 3082, 3082, 3315], [3317, 3317, 3350, 3350, 3633], [3635, 3635, 3692, 3692, 4072]]}
{"id": "wly3Dy", "name": "Cosmic Cycles", "author": "BigWIngs", "description": "See comments. Watch full screen with sound!", "tags": ["star", "space", "stars", "starfield", "universe", "bigbang"], "likes": 71, "viewed": 2310, "published": "Public API", "date": "1579749264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cosmic Cycles\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/weareallastronauts/ether\n//\n// Starfields used to be super cool back in the day. It was one of the first\n// effects I ever made sometime at the end of the 1980's. \n// This started out as a normal star field (comment out BURST to see)\n// After trying it with a circle inversion I decided to make it into some\n// sort of big bang scenario.\n\n#define BURST\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Star(vec2 uv, float a, float sparkle) {\n    vec2 av1 = abs(uv);\n \tvec2 av2 = abs(uv*Rot(a));\n    vec2 av = min(av1, av2);\n    \n    vec3 col = vec3(0);\n    float d = length(uv);\n    float star = av1.x*av1.y;\n    star = max(av1.x*av1.y, av2.x*av2.y);\n    star = max(0., 1.-star*1e3);\n    \n    float m = min(5., 1e-2/d);\n    \n    return m+pow(star, 4.)*sparkle;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,145.54));\n    p += dot(p, p+45.23);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv, float t, float sparkle) {\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\tvec3 col = vec3(0);\n    \n    #ifndef BURST\n    t = 0.;\n    #endif\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x, y);\n            float n = Hash21(id-offs);\n\t\t\tvec3 N = fract(n*vec3(10,100,1000));\n            vec2 p = (N.xy-.5)*.7;\n            \n            float brightness = Star(gv-p+offs, n*6.2831+t, sparkle);\n            vec3 star = brightness*vec3(.6+p.x, .4, .6+p.y)*N.z*N.z;\n            \n            \n            \n            star *= 1.+sin((t+n)*20.)*smoothstep(sin(t)*.5+.5, 1., fract(10.*n));\n            \n            float d = length(gv+offs);\n            \n            col += star*smoothstep(1.5, .8, d);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    M *= 10.;\n    \n\tfloat t = -iTime*.3;\n\t\n    float twirl = sin(t*.1);\n    twirl *= twirl*twirl*sin(dot(uv,uv));\n    uv *= Rot(-t*.2);\n    \n    uv *= 2.+sin(t*.05);\n    \n    vec3 col = vec3(0);\n    float speed = -.2;\n    #ifdef BURST\n    speed = .1;\n    float bla = sin(t+sin(t+sin(t)*.5))*.5+.5;\n    float d = dot(uv,uv);\n    \n    float a = atan(uv.x, uv.y);\n    uv /= d;\n    float burst = sin(iTime*.05);\n    uv *= burst+.2;\n    #endif\n    \n    float stp = 1./NUM_LAYERS;\n        \n    for(float i=0.; i<1.; i+=stp) {\n    \tfloat lt = fract(t*speed+i);\n        float scale = mix(10., .25, lt);\n        float fade = smoothstep(0., .4, lt)*smoothstep(1., .95, lt); \n        vec2 sv = uv*scale+i*134.53-M;\n        //sv.x += t;\n        col += StarLayer(sv, t, fade)*fade;\n    }\n    \n    #ifdef BURST\n    //t = iTime*.5;\n    float burstFade = smoothstep(0., .02, abs(burst));\n    float size = .9*sin(t)+1.;\n    size = max(size, sqrt(size));\n    float fade = size/d;\n    col *= mix(1., fade, burstFade);\n    col += fade*.2*vec3(1., .5, .1)*bla*burstFade;\n    \n    t*=1.5;\n    \n    a -= M.x*.1;\n    float rays = sin(a*5.+t*3.)-cos(a*7.-t);\n    rays *= sin(a+t+sin(a*4.)*10.)*.5+.5;\n    col += rays*bla*.1*burstFade;\n    col += 1.-burstFade;\n    #else\n    col *= 4.;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtjGz1", "previewfilepath": "https://soundcloud.com/weareallastronauts/ether", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/weareallastronauts/ether", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3Dy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 678, 697, 697, 756], [758, 758, 803, 803, 1124], [1126, 1126, 1148, 1148, 1241], [1243, 1243, 1292, 1292, 2052], [2054, 2054, 2111, 2111, 3523]]}
{"id": "wly3zG", "name": "My first RayMarcher", "author": "Lamashnikov", "description": "My first raymarcher using GLSL\n\nFramerate is awfull, so don't hesitate if you have any suggestion about how to optimise this shader", "tags": ["raymarching"], "likes": 0, "viewed": 60, "published": "Public", "date": "1579192116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 100\n#define NORMAL_EPSILON 0.01\n\nstruct Camera {\n \tvec3 lookat;\n    vec3 pos;\n};    \n    \nfloat SphereSDF(vec3 pos, vec3 point, float radius)\n{\n \treturn (length(point- pos) - radius);   \n}\n\nfloat planeSDF(float posY, vec3 point)\n{\n \treturn (point.y - posY);   \n}\n\nmat4 getRotationMatY(float angle)\n{\n    return mat4 (\n        vec4(cos(angle),0,sin(angle),0),\n        vec4(0,1,0,0),\n        vec4(-sin(angle),0,cos(angle),1),\n        vec4(0,0,0,1)\n        );\n}\n\nmat4 getRotationMatX(float angle)\n{\n \treturn mat4 (\n\t\tvec4(1, 0         ,0           ,0),\n        vec4(0, cos(angle), -sin(angle),0),\n        vec4(0, sin(angle), cos(angle),0),\n        vec4(0, 0          ,0          ,1)\n    );\n}\n\nvec3 rotateX(vec3 pos, float angle)\n{\n    \n \treturn vec3(inverse(getRotationMatX(angle)) * vec4(pos,1.)\n               ).xyz;   \n}\n\nvec3 rotateY(vec3 pos, float angle)\n{\n \treturn vec3(\n        inverse(getRotationMatY(angle))* vec4(pos,1.) \n        ).xyz;   \n}\n\nfloat SceneSDF(vec3 pos)\n{\n    float dist =  SphereSDF((vec3(0.,0.,0.)), pos, 1.);\n    dist = min(dist,  SphereSDF(\n\t\t\t\t\t\t\t\trotateY( vec3(-3,.5,0),iTime)\n        \t\t\t\t\t\t\t, pos, 1.));\n    dist = min(dist,  SphereSDF(\n                                 rotateY(vec3(-6,-.5,0), 2. * iTime)\n        \t\t\t\t\t\t\t, pos, 1.));\n\n    dist = min(dist, planeSDF(-2.,pos));\n    return dist;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec3 normal;\n    \tnormal.x = SceneSDF(vec3(point.x + NORMAL_EPSILON, point.yz)) - SceneSDF(vec3(point.x - NORMAL_EPSILON, point.yz));\n        normal.y = SceneSDF(vec3(point.x, point.y + NORMAL_EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - NORMAL_EPSILON, point.z));\n\t\tnormal.z = SceneSDF(vec3(point.xy, point.z + NORMAL_EPSILON)) - SceneSDF(vec3(point.xy, point.z -NORMAL_EPSILON));\n    return normalize(normal);\n}\n\nfloat lightIntensitie(vec3 vertice, vec3 lightPos)\n{\n    return (max(0.,dot(normalize(lightPos - vertice), getNormal(vertice) )));\n}\n\nvec2 normalizeScreenCoordinate(vec2 coordinate)\n{\n    vec2 uv = (coordinate - (iResolution.xy /2.))/ iResolution.xy;\n\tuv.y *= (iResolution.y / iResolution.x);\n    return uv;\n}\n\nbool lightMarching(vec3 lightPos, vec3 vertex)\n{\n    float distanceToPoint;\n    vec3 pos = lightPos;\n    vec3 dir = normalize(vertex - lightPos);\n\n \t  for (int i = 0 ; i < MAX_STEP ; ++i) {\n    \t  distanceToPoint = SceneSDF(pos);\n          if(distanceToPoint < 0.01 )\n            return (length(pos-vertex) < 0.3) ? true : false;\n        pos += distanceToPoint * dir;\n     } \n    return true;\n}\n\n\n\nvec3 rayMarching(Camera camera)\n{\n    float distanceToPoint;\n    vec3 pos = camera.pos;\n    \n \t  for (int i = 0 ; i < MAX_STEP; ++i) {\n    \t  distanceToPoint = SceneSDF(pos);\n          if(distanceToPoint < 0.01)\n            return pos;\n        pos += distanceToPoint * camera.lookat;\n     } \n    return camera.pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = normalizeScreenCoordinate(fragCoord);\n    vec3 lightPos = vec3(0.,4.,0.); \n    vec3 ambiantLight = vec3(0., .3 ,0.) ;\n    \n    Camera camera;\n    camera.pos = rotateX(vec3(0., 1., -20.), radians(20.));      \n    camera.lookat = rotateX(normalize(vec3(uv, 1.)), radians(20.));\n   \n        \n    vec3 vertex = rayMarching(camera);\n\n    if (vertex == camera.pos){\n       fragColor = vec4(.01,0.,.05,1.);\n    } else if(lightMarching(lightPos, vertex) == false) {\n          fragColor = vec4(ambiantLight ,1.);\n    } else {\n        fragColor = vec4(\n            vec3(0.,1.,0.) * lightIntensitie(vertex, lightPos) + ambiantLight\n            ,1.);\n    }\n    \n    \n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2)); // gamma value de l'écran j'ai rien bité\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 160, 160, 205], [207, 207, 247, 247, 279], [281, 281, 316, 316, 475], [477, 477, 512, 512, 705], [707, 707, 744, 744, 837], [839, 839, 876, 876, 966], [968, 968, 994, 994, 1340], [1342, 1342, 1370, 1370, 1797], [1799, 1799, 1851, 1851, 1931], [1933, 1933, 1982, 1982, 2108], [2110, 2110, 2158, 2158, 2504], [2508, 2508, 2541, 2541, 2824], [2827, 2827, 2884, 2934, 3710]]}
{"id": "wly3zh", "name": "bandera-n1", "author": "jorge2017a1", "description": "bandera-n1", "tags": ["banderan1"], "likes": 1, "viewed": 47, "published": "Public", "date": "1578257936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n//------------------------------------\n\n#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.1\n#define CR30 0.3\n#define CR31 1.0\n#define CR32 0.2\n#define CR33 0.1\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.1*cb2)*0.8;\n     case 15:\n        /*\n        // Metallic material.\n            else if (material.type == METAL)\n            {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 direction = randomUnitVector() * material.v + reflected;\n                \n                if (dot(direction, normal) > 0.0) \n                {\n               \t\tray = Ray(position, direction);\n                \tcolor *= material.albedo * attenuation;\n               \t \tattenuation *= material.albedo;\n                }\n            }\n          */\n        \n        // Metallic material.\n            vec3 materialv  = vec3(0.75, 0.75, 0.75);\n        \tvec3 color=vec3(0.8);\n        \tvec3 materialalbedo= vec3(0.85, 0.85, 0.85);\n        \tfloat attenuation=0.03;\n        \n                vec3 reflected = reflect(mObj.rd, mObj.normal);\n                vec3 direction = randomUnitVector() * materialv + reflected;\n                \n                if (dot(mObj.rd, mObj.normal) > 0.0) \n                {\n               \t\t///ray = Ray(position, direction);\n                \t color *= materialalbedo * attenuation;\n               \t \t///attenuation *= material.albedo;\n                }\n            \n            return  color;\n        \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n  \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            res=vec2(res.x, CPlane2);\n            \n         } \n     } \n    \n    \n\t\n    float  sdb1= sdBox( p-vec3(0.0), vec3(0.1,4.5,0.1)); //palo vertical\n    p.z =p.z +  0.2 * sin(5.0 * p.x + 0.6 * iTime) * cos(2.0 * p.z + 0.4 * iTime);\n    p.y =p.y +  0.2 * sin(5.0 * p.x + 0.8* iTime) * cos(2.0 * p.z + 0.8* iTime);\n    float  sdb2= sdBox( p-vec3(2.2,3.5,0.), vec3(2,1.0,0.2)); //Bandera\n    \n    \n    res=opU(res, vec2(sdb1,8));\n    res=opU(res, vec2(sdb2,14));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = gres2; //RayMarch(ro,rd);\n    vec3 Ambient= vec3(0.1,0.1,0.1);\n         \n    float t = res.x;\n\tfloat m = res.y;\n    \n    if (mObj.tipo==12.0 )\n     { return  getSphereColor(int( mObj.tipo)) ; }\n    \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    \n    \n    return col;\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n   \n    vec3 ta = vec3(5.,1.95,-10.);\n\n    vec3 ro = vec3(-5.,2.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n\n    float dif = GetLight(p);\n    //float dif2 = abs(1.0- GetLight(pluz));\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    \n    vec3 sn =GetNormal(p);\n     // SECOND PASS - REFLECTED RAY\n    vec3 rdrf = reflect(-rd, sn);\n    vec3 prf = (ro + rdrf * d ); \n    float difrf = GetLight(prf);\n    \n    \n    mObj.normal=sn;\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    vec3 coll=  calcLuz(p, ro, pluz, sn );\n\n    \n    dif=(dif+dif2+dif3+difrf)/2.0;\n    \n    \n    col =  ( vec3(dif)*colobj+colobj+coll)/2.5;\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wly3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1012, 1029, 1062, 1062, 1127], [1128, 1146, 1182, 1182, 1251], [1252, 1267, 1298, 1298, 1448], [1449, 1469, 1505, 1505, 1592], [1593, 1609, 1641, 1669, 1730], [1733, 1743, 1779, 1779, 2052], [2054, 2105, 2151, 2151, 2183], [2185, 2185, 2227, 2227, 2259], [2261, 2261, 2308, 2308, 2341], [2344, 2344, 2373, 2373, 2499], [2501, 2501, 2537, 2537, 2654], [2656, 2656, 2692, 2692, 2810], [2862, 2874, 2896, 2896, 3204], [3205, 3231, 3256, 3256, 3446], [3447, 3492, 3509, 3509, 3582], [3585, 3618, 3644, 3644, 3841], [3842, 3889, 3917, 3917, 6717], [6771, 6880, 6917, 6917, 6952], [6955, 6955, 6980, 6980, 7933], [7936, 7936, 7970, 7970, 8329], [8331, 8331, 8368, 8368, 8698], [8702, 8702, 8726, 8726, 8958], [8962, 8962, 8986, 8986, 9371], [9374, 9374, 9400, 9400, 9764], [9767, 9767, 9792, 9792, 9820], [9822, 9822, 9874, 9874, 10270], [10373, 10417, 10434, 10434, 10505], [10530, 10622, 10647, 10647, 10910], [10912, 10968, 11040, 11040, 11067], [11069, 11069, 11126, 11126, 12730]]}
{"id": "WlyGD3", "name": "Peter Shirley", "author": "feresr", "description": "Shader implementation of Peter Shirley's Ray Tracing in One Weekend\n ", "tags": ["raytracing"], "likes": 1, "viewed": 74, "published": "Public", "date": "1580179769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct hit_record {\n\tfloat t;\n    vec3 p;\n    vec3 normal;\n    bool hit;\n    vec3 color;\n    int material;\n};\n    \nstruct sphere {\n\tvec3 center;\n    float radius;\n    vec3 color;\n    int material;\n};\n    \nvec3 walk(ray r, float t) {\n\treturn r.origin + normalize(r.direction) * t;\n}\n\nhit_record hit_sphere(sphere s, const ray r, float t_max, float t_min) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    float discriminant = b*b - a*c;\n   \n\tif (discriminant > 0.) {\n        float temp = (-b - sqrt(discriminant)) / a;\n        if (temp < t_max && temp > t_min) {\n            hit_record rec = hit_record(\n                temp,\n                walk(r, temp),\n                (walk(r, temp) - s.center) / s.radius,\n                true,\n                s.color,\n                s.material\n            );\n       \n            return rec;\n        }\n        \n        temp = (-b + sqrt(discriminant)) / a;\n        if (temp < t_max && temp > t_min) {\n            hit_record rec = hit_record(\n            temp,\n            walk(r, temp),\n            (walk(r, temp) - s.center) / s.radius,\n            true,\n                s.color,\n                s.material\n            );\n          \n            return rec;\n        }\n    }\n\n    return hit_record(\n            0.0,\n            vec3(0.0,0.0,0.0),\n            vec3(0.0,0.0,0.0),\n            false,\n        \tvec3(0.0,0.0,0.0),\n        \t0\n           );\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 bounce(ray r, inout sphere[3] spheres) {\n    for(int i = 0; i < spheres.length(); i++) {\n        hit_record t = hit_sphere(spheres[i], r, 100.0, 0.0);\n        if (t.hit == true) {\n            vec3 N = normalize(t.normal);\n            return t.color;\n        }\n    }\n    \n \tvec3 unit_direction = normalize(r.direction);\n    float t = 2.0*(unit_direction.y);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n}\n\nvec3 random_in_unit_sphere(vec3 p) {\n  return normalize(vec3(rand(p.xy * iTime), rand(p.yz / iTime), rand(p.zy + iTime)));\n}\n\n\nvec3 color(ray r, inout sphere[3] spheres) {\n    for(int i = 0; i < spheres.length(); i++) {\n        hit_record t = hit_sphere(spheres[i], r, 100.0, 0.0);\n        if (t.hit == true) {\n            vec3 N = normalize(t.normal);\n            if (t.material == 1) {\n                vec3 reflected = reflect(normalize(t.p), t.normal);\n                ray scattered = ray(t.p, reflected);\n            \treturn .5 * t.color + .5 * bounce(scattered,spheres);\n            } else {\n                vec3 target = t.p + t.normal + random_in_unit_sphere(t.p);\n                ray scattered = ray(t.p, target - t.p);\n            \treturn t.color + .5 * bounce(scattered,spheres);\n            }\n        }\n    }\n    vec3 unit_direction = normalize(r.direction);\n    float t = 2.0*(unit_direction.y);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0); \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 horizontal = \tvec3(1.0, 0.0, 0.0);\n    vec3 vertical \t= \tvec3(0.0, 1.0, 0.0);\n    vec3 origin \t=\tvec3(.2 + cos(iTime * 2.) * .05, sin(iTime) * .01,-.1 - sin(iTime) * .1);\n    vec3 center\t\t=\tvec3(0.0, 0.0, -1.0);\n    \n    \n    // X axis\n    if (uv.y < 0.005 && uv.y > -0.005) {\n    \tfragColor = vec4(1.0,0.0,0.0,1.0);\n        //return;\n    }\n    \n    // Y axis\n    if (uv.x < 0.005 && uv.x > -0.005) {\n    \tfragColor = vec4(0.0,1.0,0.0,1.0);\n        //return;\n    }\n    \n    sphere[3] spheres = sphere[3](\n        sphere(vec3(0.0,0.0,-1.), .25, vec3(.2, 0.1, 0.1), 0),\n        sphere(vec3(.5 + cos(iTime) * .2, -0.15, - 1.2 - sin(iTime) *.1), .10, vec3(.0, 0.0, 0.5), 1),\n        sphere(vec3(0.0,-100.25,-1.), 100.00, vec3(0.2, 0.5, 0.2), 0)\n    );\n    \n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    int N = 10;\n    \n    for (int i = 0; i < N; i++) {\n        ray r = ray(origin, \n                    center + \n                    uv.x * horizontal \n                    + uv.y * vertical\n                    //Antialiasing\n                    + vec3((cos(float(i)/float(N) * 3.1415) * 0.001), (sin(float(i)/float(N) * 3.1415) * 0.001),0.0)\n                   );\n    \tresult += color(r, spheres);\n    }\n    result /= float(N);\n    \n    fragColor = vec4(result, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 287, 287, 336], [338, 338, 410, 410, 1564], [1566, 1566, 1586, 1586, 1658], [1660, 1660, 1705, 1705, 2087], [2089, 2089, 2125, 2125, 2213], [2216, 2216, 2260, 2260, 3063], [3067, 3067, 3124, 3174, 4549]]}
{"id": "wlyGDd", "name": "Curvature blindness but more so", "author": "vonrosceau", "description": "https://www.shadertoy.com/view/WtVGDc wasn't distressing enough", "tags": ["illusion"], "likes": 2, "viewed": 208, "published": "Public API", "date": "1580163352", "time_retrieved": "2021-10-01T00:00:00", "image_code": " void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wave_uv_y = fragCoord.y / 12.0 + sin(fragCoord.x / 10.0) * 0.5;\n    float wave_cos = cos(fragCoord.x / 10.0);\n    \n    float wave_fract = fract(wave_uv_y);\n    \n    float wave = 1.0 - clamp(abs(wave_fract * 2.0 - 1.0) * 6.0 - 1.0, 0.0, 1.0);\n    wave *= mod(wave_uv_y, 4.0) < 2.0 ? 0.0 : 1.0;\n    \n    float wave_color_offset = (cos(iTime * 0.6) * 2.0) + (floor(wave_uv_y * 0.25) * acos(-1.0) * 0.5);\n    float wave_color = sin(fragCoord.x / 10.0 + wave_color_offset) > 0.0 ? 0.65 : 0.35;\n    \n    vec2 uv = fragCoord/iResolution.xx;\n    float offset = sin(iTime * 0.5) * 0.35;\n    if (iMouse.z > 0.0)\n        offset = 0.5 - iMouse.x / iResolution.x;\n    \n    float diag = uv.x - 0.5 + offset - (uv.y - 0.5*iResolution.y/iResolution.x) * 0.5;\n    float back_color = 0.5;\n    back_color = mix(1.0, back_color, clamp((diag + 0.35) * iResolution.x * 0.75, 0.0, 1.0));\n    back_color = mix(back_color, 0.0, clamp((diag - 0.35) * iResolution.x * 0.75, 0.0, 1.0));\n    \n    float col = mix(back_color, wave_color, wave);\n\n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1128]]}
{"id": "wlyGDm", "name": "single circle", "author": "hocchang", "description": "single circle", "tags": ["singlecircle"], "likes": 0, "viewed": 48, "published": "Public", "date": "1579065431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float r =  iResolution.y / 2.0;\n    if(distance(fragCoord, iResolution.xy / 2.0) < r)\n    {\n        // Time varying pixel color\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n    else\n    {\n        // Output to screen\n    \tfragColor = vec4(1.0);\n    }\n\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 491]]}
{"id": "WlyGDw", "name": "CylinderSphereCollision", "author": "BeardThings", "description": "cylinder sphere collision", "tags": ["collision"], "likes": 2, "viewed": 114, "published": "Public API", "date": "1579038360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on: https://bartwronski.com/2017/04/13/cull-that-cone/\n// Has similar fail states as the final solution in the linked site.\n// A more robust test could be implemented by finding the closest\n// point to the sphere on the cylinder and\n// testing the distance from that point to the center of the sphere.\n// http://shader-playground.timjones.io/0c8f28cf32450dcbdc5ffd178b06fb16\nbool cylinderSphereTest_imperfect(vec2 cylinderOrg, vec2 cylinderDir, float cylinderHeight, float cylinderRad, vec2 sphereOrg, float sphereRad)\n{\n    vec2 v = sphereOrg-cylinderOrg;\n    float a = dot(cylinderDir, v);\n    float bSqr = dot(v,v) - a*a;\n    \n    bool frontCull = a > cylinderHeight + sphereRad;\n    bool backCull = a < -sphereRad;\n    bool sideCull = bSqr > (sphereRad + cylinderRad) * (sphereRad + cylinderRad);\n    \n    return !(frontCull || backCull || sideCull);\n}\n\nbool cylinderSphereTest(vec2 cylinderOrg, vec2 cylinderDir, float cylinderHeight, float cylinderRad, vec2 sphereOrg, float sphereRad)\n{\n    vec2 v = sphereOrg-cylinderOrg;\n    \n    float da = dot(cylinderDir,v);\n    vec2 a = cylinderDir * clamp(da,0.0,cylinderHeight);\n    \n    vec2 b = v - (cylinderDir * da);\n    float bl = length(b);\n    b = b/bl * min(bl,cylinderRad);\n    \n    vec2 s = cylinderOrg + a + b;\n    float distSqr = dot(s-sphereOrg,s-sphereOrg);\n    \n    return distSqr < sphereRad * sphereRad;\n}\n\nbool circle(vec2 p, vec2 c, float r)\n{\n    return dot(p-c,p-c)<r*r;\n}\n\nbool cylinder(vec2 p, vec2 o, vec2 d, float h, float r)\n{\n    float a=dot(p-o,d);\n    vec2 pr=clamp(a,0.0,h)*d+o;\n    return (dot(pr-p,pr-p)<(r*r))&&a<h&&a>0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cylinderOrg = vec2(cos(iTime),sin(iTime))*0.5+0.6;\n    vec2 cylinderDir = vec2(-cos(iTime),-sin(iTime));\n    float cylinderHeight = 0.5;\n    float cylinderRad = 0.1;\n    \n    vec2 sphereOrg = vec2(0.1,0.0);\n    float sphereRad = 0.3;\n    \n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    if(cylinder(uv,cylinderOrg,cylinderDir,cylinderHeight,cylinderRad))\n    {\n        fragColor=vec4(1.0);\n    }\n    \n    if(circle(uv,sphereOrg,sphereRad))\n    {\n        bool intersect=cylinderSphereTest(cylinderOrg,cylinderDir,cylinderHeight,cylinderRad,sphereOrg,sphereRad);\n        bool intersect_imperfect=cylinderSphereTest_imperfect(cylinderOrg,cylinderDir,cylinderHeight,cylinderRad,sphereOrg,sphereRad);\n        \n        fragColor = intersect?vec4(0.0,1.0,0.0,1.0):vec4(0.0,0.0,0.0,1.0);\n\t\tfragColor += intersect_imperfect?vec4(1.0,0.0,0.0,1.0):vec4(1.0,1.0,1.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 384, 529, 529, 865], [867, 867, 1002, 1002, 1379], [1381, 1381, 1419, 1419, 1450], [1452, 1452, 1509, 1509, 1614], [1616, 1616, 1673, 1673, 2555]]}
{"id": "wlyGR1", "name": "Sewer (Practice #7)", "author": "Coda_", "description": "Sewer (Practice #7)", "tags": ["sewer", "subtraction"], "likes": 4, "viewed": 69, "published": "Public", "date": "1578260729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time  iTime\n\nfloat box (vec3 p, vec3 s)\n{\n \treturn length(max(abs(p)-s,0.0));   \n}\n\nfloat capsule (vec3 p, vec3 a,vec3 b,float r)\n{\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap)/dot(ab,ab);\n    t = clamp(t,0.0,1.0);\n    vec3 c = a +t*ab;\n    \n  \treturn length(p-c) - r;   \n}\n\nfloat trace (vec3 o, vec3 r)\n{\n  \tfloat t = 0.0;\n  \tfor(int i = 0;i < 100;i++)\n  \t{\n      \tvec3 p = o+r*t;\n      \tvec3 q = fract(p)*2.0-1.0;\n\n      \tfloat d0 = box(q-vec3(0,0,0),vec3(1,1,0.5));\n      \tfloat d1 = capsule(q-vec3(0,0,0),vec3(0,0,0),vec3(0,0,1),0.85);\n\t  \tfloat d = max(-d1,d0);\n\n      \n      \tt += d*0.12;\n  \t}\n  \treturn t;\n}\n\nfloat water (vec3 o, vec3 r)\n{\n  \tfloat t = 0.0;\n  \tfor(int i = 0;i < 100;i++)\n  \t{\n      \tvec3 p = o+r*t;\n      \tvec3 q = fract(p)*2.0-1.0;\n\n        float d = box(q-vec3(0,-0.55,0),vec3(1,0.3,1.5))-(sin(q.z*2.0*q.x+time*1.05)*0.5+0.5)*0.05;\n        d-=(sin(q.x*5.0*q.z+time*1.05)*0.5+0.5)*0.05;\n         d-=(sin(q.y*1.5*q.z+time*1.05)*0.5+0.5)*0.05;\n\n\n      \n      \tt += d*0.15;\n  \t}\n  \treturn t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  \tuv -= 0.5;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1.0);\n\n  \tvec3 r = normalize(vec3(uv,1.0));\n\n  \tvec3 o = vec3(0.5,0.5,time*0.1);\n  \tfloat t = trace(o,r); \n    float w = water(o,r); \n  \n  \tfloat fog = 1.0/(1.0+t*t*1.0);\n    float fogw = 1.0/(1.0+w*w*6.0);\n\n    fragColor = max(vec4(vec3(fogw+vec3(0,0.05,0)),1.0),vec4(vec3(fog+vec3(0,0,0))+vec3(0.05,0,0),1.0))*0.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 49, 49, 90], [92, 92, 139, 139, 301], [303, 303, 333, 333, 642], [644, 644, 674, 674, 1043], [1047, 1047, 1104, 1104, 1557]]}
{"id": "WlyGR3", "name": "interference 1234", "author": "alarch", "description": "whee", "tags": ["interference"], "likes": 2, "viewed": 60, "published": "Public", "date": "1579429159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 pos1 = vec2(0.0+sin(iTime)/4.0,0.0);\n    vec2 pos2 = vec2(0.2*cos(iTime),-0.2*sin(iTime));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5; // set center/origo to vec2(0.0,0.0);\n    \n    uv.x *= iResolution.x/iResolution.y; // Aspect ratio\n    \n    if(mod(distance(uv, pos1),0.05) > 0.025)\n    {\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col, 1.0);\n    }\n    else\n        fragColor = vec4(0.0);\n    \n    // Draw the second thing of top of first.\n    if(mod(distance(uv, pos2),0.05) > 0.025)\n    {\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 785]]}
{"id": "wlyGRh", "name": "42PRINT", "author": "zikbakguru", "description": "Yet another 10print stuff..\nWith all those fancy light maths and bitmap rendering.\n(Best enjoyed with Earthbound music)", "tags": ["10print"], "likes": 7, "viewed": 326, "published": "Public API", "date": "1578344200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HEXRGB(hex) vec3(float((hex & 0xff0000) >> 16) / 255.0, float((hex & 0x00ff00) >> 8) / 255.0, float(hex & 0x0000ff) / 255.0)\n\n// Declare sprite data\nconst int[] sprHead =\n    int[](\n        0xF9, 0xFF, 0xFF, 0xBF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0x3F, 0xF0, \n        0xF, 0xFC, 0xFF, 0xF3, \n        0xFF, 0xFC, 0xD7, 0xF3, \n        0xFF, 0xFC, 0xFF, 0xFF, \n        0xFF, 0xF, 0x0, 0xF8, \n        0xFF, 0x7F, 0x0, 0xFC, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFD, 0xFF, 0xFF, 0xBF, \n        0x0, 0x0, 0x0, 0x0\n    );\n\nconst int[] sprBody1 =\n    int[]\n    (\n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x15, 0xAA, 0x4A, 0x55, \n        0xA5, 0xAA, 0x6A, 0x55, \n        0xA1, 0xA8, 0x2A, 0x55, \n        0x28, 0xA8, 0x2A, 0x55, \n        0x68, 0xA8, 0x2A, 0x7E, \n        0x7F, 0xA8, 0x2A, 0x6E, \n        0x6F, 0xA9, 0x2A, 0x40, \n        0x40, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55\n    );\n\nconst int[] sprBody2 =\n    int[]\n    (\n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xAB, 0xEA, 0xFF, \n        0xFF, 0x54, 0x15, 0xFF, \n        0x7F, 0x55, 0x55, 0xFC, \n        0x4F, 0x1, 0x40, 0xFD, \n        0x4F, 0xFC, 0xF, 0xF5, \n        0xF, 0xFC, 0x3F, 0xC0, \n        0x57, 0xFC, 0x3F, 0x50\n    );\n\nfloat sampleSpriteHead (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 16.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprHead[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody1 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody1[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody2 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody2[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat getrectmix (vec2 uv, vec2 sz)\n{\n    float val = 0.0;\n    vec2 rectsz = (vec2(0.5) - sz * 0.5);\n    vec2 rect = step(rectsz, uv);\n    val = rect.x * rect.y;\n    \n    rect = step(rectsz, vec2(1.0) - uv);\n    val *= rect.x * rect.y;\n    return val;\n}\n\nvec3 mixSpriteHead (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteHead(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody1 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody1(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0 / 3.0; // discard if image idx == 1\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody2 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody2(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0; // discard if image idx == 3\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\n// Noise functions from\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// HSV -> RGB routine from\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat samplenaejang (vec3 uv, float time)\n{\n    // prevent floating point error\n    // time = mod(time, 6.285);\n    \n    // apply wobble\n    vec2 wobblyUV = vec2(uv.x, uv.y);\n    wobblyUV.x += sin(uv.y * 10.0 + mod(time * 0.82, 6.28) + cos(uv.x * 2.5 + time * 0.5) * 0.15) * 0.065;\n    wobblyUV.y += cos(uv.x * 14.2 + mod(time * 0.75, 6.28) + sin(uv.y * 1.5 + time * 0.6) * 0.2) * 0.065;\n    \n    // calculate 10PRINT\n    vec2 uvMult = wobblyUV * 8.0;\n   \tvec2 uvChunky = floor(uvMult) / 8.0;\n    vec2 uvChunkyLocal = fract(uvMult);\n    float chunkFlip = sign(floor(noise(uvChunky * 10.0) + 0.5) - 0.5);\n    \n    vec2 gridDelta = fract(vec2(uvChunkyLocal.x * chunkFlip, uvChunkyLocal.y)) - 0.5;\n    float dist1 = min(distance(vec2(0.5), gridDelta), distance(vec2(0.5), -gridDelta));\n    float dist2 = abs(0.5 - dist1);\n    float thiccness = 0.8 + pow(sin(time), 3.0) * 0.4;\n    float shape = dist2 * thiccness;//smoothstep(0.3, 0.75, dist2 * thiccness);\n    \n    return clamp((1.0 - shape) - uv.z, 0.0, 1.0);\n}\n\nvec3 getnaejangnormal (vec2 uv, float time)\n{\n    vec3 normal;\n    vec2 smol = vec2(0.00001, 0.0);\n    vec3 uv3D = vec3(uv, 0.0);\n    \n    // calculate normal via central whatever method\n    normal.x = (samplenaejang(uv3D - smol.xyy, time) - samplenaejang(uv3D + smol.xyy, time));\n    normal.y = (samplenaejang(uv3D - smol.yxy, time) - samplenaejang(uv3D + smol.yxy, time));\n    normal.z = 2.0 * smol.x;\n    return normalize(normal);\n}\n\nvec3 samplerectBG (vec2 absuv, vec2 rectUV, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 colourRect;\n    \n    // Prepare rect properties\n    const float rectScrollPower = 3.0;\n    vec2 rectUVOffset = vec2(pow(sin(time * 0.5), rectScrollPower) * 1.0, pow(cos(time * 0.25), rectScrollPower) * 4.0);\n    rectUV += rectUVOffset; // / (rectHalfSize * 2.0);\n\n    // Foreground : 10PRINT\n    float naejangSDF = samplenaejang(vec3(rectUV, 0.0), time);\n    vec3 naejangNormal = getnaejangnormal(rectUV, time); // vec3(clamp(getnaejangnormal(rectUV, time), -1.0, 1.0), 0.5);\n\tfloat naejangCenterMix = pow(1.0 - pow(1.0 - naejangSDF, 1.0), 4.0);//smoothstep(0.0, 0.75, naejangSDF - 0.1);\n    naejangNormal.xy = mix(naejangNormal.xy, vec2(0.0), naejangCenterMix);\n    naejangNormal.z = 1.0;//mix(0.0, 1.0, naejangCenterMix);\n    \n    // Calculate light\n    vec3 viewVector = vec3(0.0, 0.0, 1.0);\n    float lightTime = mod(time * 2.0, 6.254);\n    vec3 lightPos = vec3(uvsizeHalf + vec2(cos(lightTime), sin(lightTime)) * (uvsizeHalf * 0.75), 1.0);\n    vec3 lightDelta = lightPos - vec3(absuv, 0.05 + naejangSDF * 0.35);\n    vec3 lightDir = normalize(lightDelta);\n    float lightDist = length(lightDelta);\n    \n    // 1] albedo\n    vec3 plasmacolour1 = hsv2rgb(vec3(fract(time * 0.2), 0.5, 1.0));\n    vec3 plasmacolour2 = hsv2rgb(vec3(fract(1.0 - time * 0.2), 1.0, 0.5));\n    \n    vec3 diffuse = mix(plasmacolour2, plasmacolour1, naejangCenterMix);\n    //colourRect = diffuse;\n    \n    // 2] lambert\n    float lightAmbient = 0.5;\n    float lightDot = dot(naejangNormal, lightDir);\n    float lightDistRange = smoothstep(0.3, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float lightLit = clamp((lightDot * lightDistRange + lightAmbient), 0.0, 1.0);\n    colourRect = diffuse * lightLit;\n    \n    // 3] Blinn-phong specular reflection\n    vec3 phongH = normalize(lightDelta + viewVector);\n    float phongDistRange = naejangCenterMix * smoothstep(0.5, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float phongDot = dot(naejangNormal, phongH);\n    float phongClamped = clamp(phongDot, 0.0, 1.0);\n    float phong = pow(phongClamped, 800.0);\n    \n    colourRect += vec3(phong * phongDistRange);\n    \n    return colourRect;\n}\n\nvec3 samplescene (vec2 uv, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 final = vec3(0.0);\n    \n    // Prepare rect properties\n    vec2 rectHalfSize = vec2(0.4, 0.225);\n    const float rectUVScale = 1.5;\n    vec2 rectUV = (uv - (uvsizeHalf - rectHalfSize)) * rectUVScale;\n    \n    // Downscale the rectangle's resolution\n    const float crunchfactor = 64.0;\n    vec2 uvcrunchy = floor(rectUV * crunchfactor) / crunchfactor;\n    vec2 uvcrunchylocal = fract(rectUV * crunchfactor);\n    \n    // Commodore colours\n    vec3 colourBG = HEXRGB(0x887ecb);\n    vec3 colourRect = HEXRGB(0x50459b);\n    \n    // Background C64 loading screen-like raster bars\n    float rasterScale = 15.0;\n    float rasterOff = time * 0.5;\n    float rasterMix = floor(fract((uv.y + rasterOff) * rasterScale + (uv.x * sin(time * 3.0)) * 0.5) + 0.5);\n    const vec3 colours[3] = vec3[3](HEXRGB(0x6abfc6), HEXRGB(0xa1683c), HEXRGB(0x9ae29b));\n    \n    colourBG = mix(colours[int(time) % 3], HEXRGB(0xadadad), rasterMix);\n    \n    // Foreground : 10PRINT\n    const float uvdownscaleFactor = 64.0;\n    vec2 uvdownscale = (rectUV * uvdownscaleFactor + 0.5);\n    vec2 uvdownscaleLocal = fract(uvdownscale);\n    uvdownscale = floor(uvdownscale) / uvdownscaleFactor;\n    \n    vec3 rectBG = samplerectBG(uv, uvdownscale, time);\n    float rectBGLuma = clamp(dot(rectBG, rectBG), 0.0, 1.0);\n    \n    // apply LED light effect to foreground's 10PRINT BG(??)\n    float ledDiscRadius = 0.25 * rectBGLuma + 0.20;\n    const float ledDiscRadiusSmooth = 0.1;\n    float ledDiscDelta = distance(vec2(0.5), uvdownscaleLocal);\n    float ledDiscMix = smoothstep(ledDiscRadius + ledDiscRadiusSmooth, ledDiscRadius, ledDiscDelta);\n    colourRect = mix(rectBG * 0.5, rectBG, ledDiscMix);\n    colourRect = clamp(colourRect + pow(1.0 - ledDiscDelta, 2.0) * 0.2, 0.0, 1.0);\n\n    // Foreground : Sprites\n    vec2 sprUV;\n    float sprAnimTime = time * 2.0;\n    float sprRot = sin(sprAnimTime);\n    float sprScale = 8.0;\n    vec2 sprOff = vec2(sin(time * 0.5 + cos(time * 0.1) * 0.01) * 0.05, cos(time * 0.5) * 0.025 + sin(time * 0.1) * 0.01);\n    \n    // body\n    float rot = radians(pow(sprRot, 4.0) * 12.0 * 0.1);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.6;\n    colourRect = mixSpriteBody2(colourRect, sprUV);\n    \n    // body\n    rot = radians(pow(sprRot, 3.0) * 12.0 * 0.3);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.65 + sin(sprAnimTime * 2.0) * 0.05;\n    colourRect = mixSpriteBody1(colourRect, sprUV);\n    \n    // head\n    rot = radians(sprRot * 12.0 * -0.5);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += sin(sprAnimTime * 2.0) * 0.1;\n    colourRect = mixSpriteHead(colourRect, sprUV);\n    \n    // debug light\n    //float lightCircleMix = smoothstep(0.01, -0.01, length(lightDelta.xy) - 0.01);\n    //colourRect = mix(colourRect, vec3(0.0, 1.0, 1.0), lightCircleMix);\n    \n    // Draw commodore 64-esque screen\n    // shadow\n    vec2 centerDelta = uvsizeHalf - uv + vec2(0.025, -0.025);\n    float rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    float rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    vec3 rect = mix(colourBG, colourBG * vec3(0.5), rectfactor);\n    \n    // screen\n    centerDelta = uvsizeHalf - uv;\n    rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    rect = mix(rect, colourRect, rectfactor);\n    \n\treturn rect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvratio = (iResolution.xy / iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvPixelperfect = fragCoord/iResolution.xy * uvratio;\n\n    // Uh yeah woo yeah woo hoo\n    vec3 col = samplescene(uvPixelperfect, iTime);\n    \n    // Test : sprite\n    // vec3 col = vec3(sampleSpriteHead(vec2(uv.x, 1.0 - uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 2123, 2157, 2157, 2726], [2728, 2728, 2763, 2763, 3333], [3335, 3335, 3370, 3370, 3940], [3942, 3942, 3979, 3979, 4195], [4197, 4197, 4238, 4238, 4496], [4498, 4498, 4540, 4540, 4918], [4920, 4920, 4962, 4962, 5334], [5336, 5429, 5449, 5449, 5516], [5517, 5517, 5538, 5538, 5747], [5749, 5835, 5857, 5857, 6026], [6028, 6028, 6071, 6164, 7038], [7040, 7040, 7085, 7085, 7475], [7477, 7477, 7534, 7534, 9781], [9783, 9783, 9823, 9823, 13741], [13743, 13743, 13800, 13850, 14239]]}
{"id": "wlyGW1", "name": "whiteness", "author": "Carandiru", "description": "finding how white a color truly is", "tags": ["white", "luma", "convert"], "likes": 2, "viewed": 227, "published": "Public API", "date": "1578808896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/supersinfulsilicon\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\nfloat saturation(vec3 rgb) {\n    float mini = min(rgb.r,min(rgb.g,rgb.b));\n    float maxi = max(rgb.r,max(rgb.g,rgb.b));\n    \n    return (maxi - mini) / maxi;\n}\n\nfloat whiteness(vec3 rgb) {\n    \n    return (1.0f-saturation(rgb)) * ((rgb.r+rgb.g+rgb.b)/3.0f);\n}\n\nvec3 enhance(vec3 a, float x) {\n\treturn a * (x + dot(a, LUMA));    \n}\n\nvec3 blackbody(float t){\n    // http://en.wikipedia.org/wiki/Planckian_locus\n\n    vec4 vx = vec4( -0.2661239e9, -0.2343580e6, 0.8776956e3, 0.179910   );\n    vec4 vy = vec4( -1.1063814,   -1.34811020,  2.18555832, -0.20219683 );\n    //vec4 vy = vec4(-0.9549476,-1.37418593,2.09137015,-0.16748867); //>2222K\n    float it = 1. / t;\n    float it2= it * it;\n    float x = dot( vx, vec4( it*it2, it2, it, 1. ) );\n    float x2 = x * x;\n    float y = dot( vy, vec4( x*x2, x2, x, 1. ) );\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 xyzToSrgb = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n\n    vec3 srgb = vec3( x/y, 1., (1.-x-y)/y ) * xyzToSrgb;\n\n    return max( srgb, 0. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 section_begin = vec3(lessThan(uv.yyy,vec3(0.333f,0.666f,0.999f)));\n    vec3 section_end = vec3(greaterThan(uv.yyy,vec3(0.0f,0.333f,0.666f)));\n    \n    float tt = 0.5f;\n    float xx = uv.x * 0.5f + 0.5f;\n    \n    float t = xx * abs(sin(iTime * tt)) * 0.5f;\n    \n    float c = xx * abs(cos(iTime * tt)) * 0.5f;\n    \n    vec3 p = vec3(xx);\n    \n    vec3 rgb = vec3(0);\n    rgb += enhance(c + vec3(t*t*t,     p.x+t,      p.x*t), uv.x ) * section_begin.x * section_end.x;\n    rgb += enhance(c + vec3(p.y*t,     t*t*t,      p.y+t), uv.x ) * section_begin.y * section_end.y;\n    rgb += enhance(c + vec3(p.z+t,     p.z*t,      t*t*t), uv.x ) * section_begin.z * section_end.z;\n    //rgb = rgb*rgb;\n    \n    vec3 color = rgb;\n    float iswhite = whiteness(rgb);\n    \n    float highlight = mod(uv.x, iswhite) + iswhite * ((rgb.x+rgb.y+rgb.z)/3.0f);\n    color = mix(rgb, vec3(highlight), iswhite);\n\n    vec3 bbody = blackbody(667.0f * 2.0f+iswhite* 15000.0f);\n    \n    bbody = (bbody*0.5f);//*(1.0f-bbody*0.5f);\n    bbody.x = ((bbody.x+bbody.y+bbody.z)/3.0f);\n    \n    color = mix(enhance(vec3(iswhite), bbody.x), color, bvec3(int(iTime) & 4));\n    color = mix(color, enhance(color, iswhite), vec3(int(fragCoord.y) & 3));\n    \n    fragColor.rgb = color;//vec3(whiteness(rgb.rgb));\n    \n    \n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 111, 111, 243], [245, 245, 272, 272, 343], [345, 345, 376, 376, 414], [416, 416, 440, 492, 1219], [1221, 1221, 1278, 1278, 2616]]}
{"id": "WlyGW3", "name": "2D section of rotating torus", "author": "hiogawa", "description": "I wasn't sure how to obtain distance on 2d section, but it seems okay to just use usual 3d distance.\nThis only leads to under-estimation, so, for example, when torus is tilted, there is more blur to it.", "tags": ["2d", "torus"], "likes": 4, "viewed": 222, "published": "Public API", "date": "1579979581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// 2D Section of Rotating Torus\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 0.6;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 3.2;\n\nfloat TORUS_R1 = 1.0;\nfloat TORUS_R2 = 0.35;\nvec3  TORUS_ROT_VELOCITY = vec3(M_PI, 0.0, M_PI * 2.5 / 2.0);\nvec4  TORUS_COLOR = vec4(vec3(0.95, 1.0, 1.0), 0.8);\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\n\n\n// Torus boundary given by\n//   q(u, v) = R_{z, u} (r1 e1 + R_{y, v} (r2 e1))\nfloat signedDistanceToTorus(vec3 p, float r1, float r2) {\n  return length(vec2(length(p.xy) - r1, p.z)) - r2;\n}\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat2 rot2(float t) {\n  return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nmat4 rotationTransform(vec3 r) {\n  mat2 x = rot2(r.x);\n  mat2 y = rot2(r.y);\n  mat2 z = rot2(r.z);\n  mat3 X = mat3(\n      1.0,     0.0,     0.0,\n      0.0, x[0][0], x[0][1],\n      0.0, x[1][0], x[1][1]);\n  mat3 Y = mat3(\n    y[1][1],   0.0, y[0][1],\n        0.0,   1.0,     0.0,\n    y[1][0],   0.0, y[0][0]);\n  mat3 Z = mat3(\n    z[0][0], z[0][1],   0.0,\n    z[1][0], z[1][1],   0.0,\n        0.0,     0.0,   1.0);\n  mat4 R = mat4(Z * Y * X);\n  return R;\n}\n\n// [0, W] x [0, H]  <-->  [c.x - A, c.x + A] x [c.y - B, c.y + B]\n// where AR = W / H\n//       A = AR * height / 2\n//       B = height / 2\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\n// Anti aliasing\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Animating Torus\n    mat4 torus_xform = rotationTransform(TORUS_ROT_VELOCITY * t);\n\n    // Approximate 2D section distance as 3D distance\n    //   this approximation under-estimates distance on 2d section\n    //   when 3d closest point's normal is not orthogonal to 2d section.\n    //   For example, there will be too much AA blur when torus is tilted.\n    vec3 p = vec3(uv, 0.0);\n    vec3 p_in_torus = vec3(inverse(torus_xform) * vec4(p, 1.0));\n    float sd = signedDistanceToTorus(p_in_torus, TORUS_R1, TORUS_R2);\n\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, TORUS_COLOR.xyz, TORUS_COLOR.w * coverage);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 495, 552, 552, 606], [608, 608, 661, 661, 904], [906, 906, 926, 926, 976], [978, 978, 1010, 1010, 1433], [1435, 1574, 1624, 1624, 1869], [1871, 1888, 1963, 1963, 2042], [2045, 2060, 2114, 2114, 3246]]}
{"id": "wlyGWw", "name": "Fractal archipelago", "author": "jarble", "description": "This fractal looks like a sea of \"islands\" with many \"rivers\" or \"canals.\"", "tags": ["fractal", "islands"], "likes": 0, "viewed": 228, "published": "Public API", "date": "1579051931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the scale\nconst float mag = 128.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float RED = 2.0;\nconst float YELLOW = 3.0;\nconst float GRAY = 4.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*2.0);\n}\n\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/mag));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\n\nstruct function{\n    int x;\n};\n\nfunction magnify(){\n    return function(1);\n}\nfloat call(function func,vec2 fragCoord,float mag){\n    if(func == magnify()){\n        return magnify(fragCoord,mag);\n    }\n}\n\n\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn call(magnify(),fragCoord+vec2(0,1),mag) == color\n        && call(magnify(),fragCoord+vec2(1,0),mag) == color\n        && call(magnify(),fragCoord-vec2(0,1),mag) == color\n        && call(magnify(),fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(function func,vec2 fragCoord,float mag,float color){\n\treturn call(func,fragCoord+vec2(0,1),mag) == color\n        || call(func,fragCoord+vec2(1,0),mag) == color\n        || call(func,fragCoord-vec2(0,1),mag) == color\n        || call(func,fragCoord-vec2(1,0),mag) == color;\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(0.392,0.392,0.392);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == YELLOW){\n        return vec3(0.149,0.141,0.912);\n   \t}\n}\n\nfloat get_color(float color1,vec2 fragCoord,float mag){\n    if(color1 == GREEN && is_next_to(magnify(),fragCoord,mag/2.0,BLUE)){\n    \treturn YELLOW;\n    }\n    else if(color1 == BLUE && is_next_to(magnify(),fragCoord,mag/2.0,GREEN)){\n        return GREEN;\n    }\n    return color1;\n}\n\nfloat iterations(in vec2 fragCoord,float mag){\n    float color1 = magnify(fragCoord,mag/64.0);\n    float mag1 = 32.0;\n    while(mag1 >= 1.8){\n    \tcolor1 = get_color(color1,fragCoord,mag/mag1);\n        mag1 /= 2.0;\n    }\n    return get_color(color1,fragCoord,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + iTime*vec2(50.0,0.0);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    float color1 = iterations(fragCoord,mag);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 246, 268, 268, 396], [400, 400, 440, 440, 480], [482, 482, 534, 534, 577], [611, 611, 630, 630, 656], [657, 657, 708, 708, 782], [785, 785, 845, 845, 1085], [1087, 1087, 1155, 1155, 1375], [1379, 1379, 1407, 1407, 1758], [1760, 1760, 1815, 1815, 2041], [2043, 2043, 2089, 2089, 2309], [2311, 2311, 2368, 2368, 2604]]}
{"id": "wlyGzh", "name": "Palette Sandbox", "author": "Eggy42", "description": "A simple visualization sandbox based on IQ's procedural palette example. I made this to play around with palettes interactively for use in my own projects.", "tags": ["palette", "sandbox"], "likes": 3, "viewed": 100, "published": "Public", "date": "1578261404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sandbox based on IQ's procedural pallete example:\n// Pallette Sandbox based on IQ's example:\n//\n// https://www.shadertoy.com/view/ll2GD3\n// http://iquilezles.org/www/articles/palettes/palettes.htm\n// The MIT License\n// Copyright © 2015 Inigo Quilez\n\n// === cut/paste start here ===\n//      A Component  R     G     B   (Y shift)\n#define pal_a vec3( 0.50, 0.50, 0.50 )  \n//      B Component  R     G     B   (amplitude)\n#define pal_b vec3( 0.50, 0.50, 0.50 )  \n//      C Component  R     G     B   (period)\n#define pal_c vec3( 1.00, 0.70, 0.40 )  \n//      D Component  R     G     B   (phase)\n#define pal_d vec3( 0.00, 0.15, 0.20 )  \n\nvec3 pal( in float t )\n{\n    return pal_a + pal_b*cos( 6.28318*(pal_c*t+pal_d) );\n}\n// === cut/paste end here ===\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float thickness = .015;\n    \n    // Animate\n    p.x += 0.05*iTime;\n    \n    // Default color\n    vec3 col = vec3(0);\n    \n    // Band\n    float f = fract(p.y*4.0);\n    \n    // Curve for B\n    col = vec3(0, 0, smoothstep(thickness+.01, thickness, abs(pal(p.x).z-f)));\n    \n    // Curve for G\n    if( p.y>(1.0/4.0) ) {\n\t    col = vec3(0, smoothstep(thickness+.01, thickness, abs(pal(p.x).y-f)), 0);\n    }\n    // Curve for R\n    if( p.y>(2.0/4.0) ) {\n\t    col = vec3(smoothstep(thickness+.01, thickness, abs(pal(p.x).x-f)), 0, 0);\n    }\n    \n    // Compute palette color\n    if( p.y>(3.0/4.0) ) col = pal( p.x );\n    \n    // Borders\n    col = mix(col, vec3(.5), vec3(step( .5-thickness, abs(f-0.5))));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGzh.jpg", "access": "shaders20k", "license": "mit", "functions": [[551, 638, 662, 662, 721], [722, 753, 810, 810, 1592]]}
{"id": "wlyGzy", "name": "Waves on flat sea surface", "author": "mrange", "description": "Based on a earlier shader I did that relier but simplified to waves rotation. Detects the intersection of the flat sea surface and computes the wave normal to produce the wave effect. Looks best in FF for me and doesn't work properly in Edge. ", "tags": ["raytracing", "flat"], "likes": 12, "viewed": 390, "published": "Public API", "date": "1579203898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 1.0;\nconst float waterTension = 0.01;\n\nconst vec3 skyCol1 = vec3(0.6, 0.35, 0.3);\nconst vec3 skyCol2 = vec3(1.0, 0.3, 0.3);\nconst vec3 sunCol1 = vec3(1.0,0.5,0.4);\nconst vec3 sunCol2 = vec3(1.0,0.8,0.7);\nconst vec3 seaCol1 = vec3(0.1,0.2,0.2);\nconst vec3 seaCol2 = vec3(0.8,0.9,0.6);\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*iTime);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*iTime);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*iTime);\n}\n\nvoid mrot(inout vec2 p, in float a) {\n  // c*c + s*s\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  const int maxIter = 8;\n  const int midIter = 4;\n\n  float kk = 1.0/1.3;\n  float aa = 1.0/(kk*kk);\n  float k = 1.0*pow(kk, -float(maxIter) + 1.0);\n  float a = ia*0.25*pow(aa, -float(maxIter) + 1.0);\n\n  float h = 25.0;\n  p *= 0.5;\n  \n  vec2 waveDir = vec2(0.0, 1.0);\n\n  for (int i = midIter; i < maxIter; ++i) {\n    float t = dot(-waveDir, p) + float(i);\n    y += capillaryWave(t, a, k, h).y;\n    vec2 dw = capillaryWaveD(-t, a, k, h);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, PI/3.0);\n\n    k *= kk;\n    a *= aa;\n  }\n  \n  waveDir = vec2(0.0, 1.0);\n\n  for (int i = 0; i < midIter; ++i) {\n    float t = dot(waveDir, p) + float(i);\n    y += gravityWave(t, a, k, h).y;\n    vec2 dw = gravityWaveD(t, a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    \n    d += vec3(waveDir.x, dw.y, waveDir.y);\n\n    mrot(waveDir, -step(2.0, float(i)));\n\n    k *= kk;\n    a *= aa;\n  }\n\n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}\n\nvec3 sunDirection() {\n  vec3 dir = normalize(vec3(0, 0.06, 1));\n  return dir;\n}\n\nvec3 skyColor(in vec3 rd) {\n  vec3 sunDir = sunDirection();\n\n  float sunDot = max(dot(rd, sunDir), 0.0);\n  \n  vec3 final = vec3(0.0);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n\n  final += 0.5*sunCol1*pow(sunDot, 90.0);\n\n  final += 4.0*sunCol2*pow(sunDot, 900.0);\n    \n  return final;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float dsea = (0.0 - ro.y)/rd.y;\n  \n  vec3 sunDir = sunDirection();\n  \n  vec3 sky = skyColor(rd);\n  \n  if (dsea > 0.0) {\n    vec3 p = ro + dsea*rd;\n    vec4 s = sea(p.xz, 1.0);\n    float h = s.x;    \n    vec3 nor = s.yzw;\n    nor = mix(nor, vec3(0.0, 1.0, 0.0), smoothstep(0.0, 200.0, dsea));\n\n    float fre = clamp(1.0 - dot(-nor,rd), 0.0, 1.0);\n    fre = pow(fre, 3.0);\n    float dif = mix(0.25, 1.0, max(dot(nor,sunDir), 0.0));\n    \n    vec3 refl = skyColor(reflect(rd, nor));\n    vec3 refr = seaCol1 + dif*sunCol1*seaCol2*0.1; \n    \n    col = mix(refr, 0.9*refl, fre);\n    \n    float atten = max(1.0 - dot(dsea,dsea) * 0.001, 0.0);\n    col += seaCol2*(p.y - h) * 2.0 * atten;\n    \n    col = mix(col, sky, 1.0 - exp(-0.01*dsea));\n    \n  } else {\n    col = sky;\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.1, 1.0));\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 412, 412, 478], [480, 480, 540, 540, 614], [616, 616, 682, 682, 756], [758, 758, 826, 826, 923], [925, 925, 992, 992, 1067], [1069, 1069, 1138, 1138, 1236], [1238, 1238, 1275, 1290, 1375], [1377, 1377, 1411, 1411, 2464], [2466, 2466, 2487, 2487, 2545], [2547, 2547, 2574, 2574, 2831], [2833, 2833, 2870, 2870, 3683], [3685, 3685, 3740, 3740, 4124]]}
{"id": "Wsc3Wn", "name": "additive fractal", "author": "unnick", "description": "a thing i made a while ago that im making public", "tags": ["2d", "fractal"], "likes": 7, "viewed": 233, "published": "Public API", "date": "1578507508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* it basically works by making scaled copies of a repeating pattern,\n * summing those copies together, and then using a pallete to turn the sum\n * into a color.\n */\n\n#define SIZE 5.\n#define STRIDE 5\nconst float pattern[] = float[](\n    2.,1. , 0.,1. , 2.,\n    1.,1.5, 1.,1.5, 1.,\n    0.,1. ,-2.,1. , 0.,\n    1.,1.5, 1.,1.5, 1.,\n    2.,1. , 0.,1. , 2.\n);\n\n/*\n#define SIZE 3.\n#define STRIDE 3\nconst float pattern[] = float[](\n    -1., 0.,-1.,\n     0., 1., 0.,\n    -1., 0.,-1.\n);\n*/\n\nmat2 rotmat(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = exp(sin(iTime * 1.5) * .7);\n    \n    vec2 pos = (fragCoord*2. - iResolution.xy) / iResolution.y;\n    pos *= rotmat(iTime * .5);\n    pos *= zoom;\n    pos += vec2(1., 1.5) * iTime;\n    {\n        float tmp = pow(3., SIZE);\n        pos /= tmp; zoom /= tmp;\n    }\n    \n    float detail = (log(iResolution.y / zoom)) / log(SIZE) - 1.3;\n    \n    float sum = detail * -1.;\n    for(int i = 0; i < 16; i++) {\n        pos = fract(pos);\n        pos *= SIZE;\n        if(i >= int(detail)) break;\n        sum += pattern[int(pos.x) + int(pos.y) * STRIDE];\n    };\n    sum += pattern[int(pos.x) + int(pos.y) * STRIDE] * fract(detail);\n    \n    fragColor = sin(sum + vec3(0.,.5,1.) + iTime * 3.).xyzz * .5 + .5;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 482, 504, 504, 580], [582, 582, 639, 639, 1351]]}
{"id": "wscSWf", "name": "shadetober #30 (catch)", "author": "percentcer", "description": "Inktober, but with shaders\n\nWanted to try some subsurface scattering stuff, https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/ has a good guide!", "tags": ["subsurfacescattering", "sss", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 0, "viewed": 177, "published": "Public API", "date": "1580087488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXD 30.\n#define PI 3.141\n#define TAU 6.283\n\n#define REPETITION_PERIOD 4.\n#define HALF_PERIOD REPETITION_PERIOD * .5\n\n#define DEBUG_LIGHT_SOURCE 0\n\nmat3 roty(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\nmat3 rotx(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nvec3 spherical(vec3 cart)\n{\n    float rho = length(cart);\n    float theta = atan(cart.y, cart.x); // [-pi, pi]\n    float phi = acos(cart.z / rho);     // [0, pi]\n    return vec3(rho, theta, phi);\n}\n\nfloat expStep(float x, float k, float n) { return exp(-k * pow(x, n)); }\n\nfloat sphere(vec3 p, float rad) { return length(p) - rad; }\n\n\nfloat shape(vec3 p)\n{\n#if 1\n    // da experiment zone\n    //p = p.zxy;\n    mat3 rot = roty((iMouse.x / iResolution.x - .5) * 10.);\n    // mat3 rot = roty(iTime);\n    p *= rot;\n#endif\n#if 1\n    vec3 sp = spherical(p);\n\n    const float latPeaks = 5.;\n    const float latMin = .7;\n    float lateralRadius = mix(latMin, 1.0, cos(sp.y * latPeaks) * .5 + .5);\n\n    const float longPeaks = 6.;\n    const float longSpeed = 8.;\n    const float longDamp = 0.1;\n    float longitudinalWiggle = cos((sp.z * 2.) * longPeaks + iTime * longSpeed) * longDamp;\n\n    return length(p) - (lateralRadius + longitudinalWiggle);\n#else\n    return sphere(p, 1.);\n#endif\n}\n\nvec2 map(vec3 p)\n{\n    // return a distance and a material id\n    vec2 cur = vec2(MAXD, 0.);\n\n    vec2 shp = vec2(shape(p), 1.);\n    if (shp.x < cur.x)\n    {\n        cur = shp;\n    }\n\n#if DEBUG_LIGHT_SOURCE\n    vec2 dbg = vec2(sphere(p - vec3(0., 1., 3.) * roty(iTime), .01), 2.);\n    if (dbg.x < cur.x)\n    {\n        cur = dbg;\n    }\n#endif\n\n    return cur;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 ep = vec2(0.001, 0.0);\n    return normalize(\n        map(p).r - vec3(map(p - ep.xyy).r, map(p - ep.yxy).r, map(p - ep.yyx).r));\n}\n\nvec3 cell(vec3 p) { return floor((p + vec3(HALF_PERIOD)) / REPETITION_PERIOD); }\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 localpos = mod(p + c / 2., c) - c / 2.;\n    vec3 cell = cell(p);\n    vec3 noise = texture(iChannel0, vec2(cell.x, cell.y * cell.z) * .1).rgb;\n    vec3 offs = noise - .5;\n    \n    return localpos*rotx(sin(iTime*noise.x)*noise.y) + offs*2.;\n}\n\nvec4 march(vec3 ro, vec3 rd, int invert)\n{\n    float t = 0.;\n    vec4 ret;\n\n    for (int i = 0; i < 100; i++)\n    {\n        ret.xyz = ro + rd * t;\n        vec2 d = map(opRep(ret.xyz, vec3(REPETITION_PERIOD))) * vec2(invert, 1);\n\n        if (d.x < .1)\n        {\n            ret.w = d.y;\n            break;\n        }\n\n        // only using a portion of the sphere step\n        // because I was getting a lot of errors from the\n        // shape distortion with the full step\n        t += d.x * .2f;\n\n        if (t > MAXD)\n        {\n            break;\n        }\n    }\n    return ret;\n}\n\nvec3 sss(vec3 p, vec3 rd, vec3 lp, vec3 lc)\n{\n    vec3 origP = p;\n    p = opRep(p, vec3(REPETITION_PERIOD));\n    // from https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\n    vec3 L = normalize(lp - p);\n    const float subsurfaceDistortion = .5;\n\n    // figure out if our point is the light's entry or exit\n    float inShadow = -sign(dot(norm(p), L));\n    vec3 lightEgress = march(p + (inShadow * L * .05), inShadow * L, -1).xyz;\n    vec3 lightIngress = p;\n    if (inShadow > 0.)\n    {\n        lightIngress = lightEgress;\n        lightEgress = p.xyz;\n    }\n\n    // fudging a bit but a length of 2 is about the max width of this shape\n    // todo currently unused\n    // float thickness = length(lightEgress - lightIngress) / 2.;\n    vec3 N = norm(lightEgress);\n\n    vec3 cell = cell(origP);\n    vec3 noiseOffset =\n        texture(iChannel0, vec2(cell.x, cell.y + cell.z) * .1).rgb-.5;\n    vec3 basecolor = vec3(.6, 1., .2) + noiseOffset;\n\n    float lightAlign = max(0., dot(norm(p.xyz), L));\n\n    vec3 I_sss =\n        max(0., dot(rd, normalize(L + N * subsurfaceDistortion))) * basecolor;\n    vec3 I_diff = lightAlign * basecolor;\n\n    vec3 refl = reflect(L, norm(p.xyz));\n    float specAlign = abs(dot(rd, refl)); // abs so we get shinies on both sides\n    float I_spec = pow(specAlign, 50.);\n\n    return I_sss + I_diff + I_spec;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\tvec3 bgcol = vec3(.4,.6, 0.);\n    vec3 col = bgcol;\n\n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n\n    // start the march a little ahead of the\n    // actual ro to enforce a near plane\n    vec4 p = march(ro + rd * 2., rd, 1);\n\n    vec3 lp = vec3(0., 0., -3.);\n    vec3 lc = vec3(1., 1., .878);\n    lp *= roty(iTime);\n\n    if (p.w == 1.)\n    {\n        col = sss(p.xyz, rd, lp, lc);\n    }\n#if DEBUG_LIGHT_SOURCE\n    if (p.w == 2.)\n    {\n        col = lc;\n    }\n#endif\n    \n    col = mix(col, bgcol, length(p.xyz)/MAXD);\n    col *= 1.-length((uv+vec2(sin(iTime),0.))*.25);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 176, 176, 248], [249, 249, 269, 269, 341], [343, 343, 370, 370, 540], [542, 542, 584, 584, 614], [616, 616, 649, 649, 675], [678, 678, 699, 699, 1323], [1325, 1325, 1343, 1386, 1685], [1687, 1687, 1706, 1706, 1845], [1847, 1847, 1866, 1866, 1927], [1929, 2000, 2034, 2034, 2284], [2286, 2286, 2328, 2328, 2867], [2869, 2869, 2914, 2914, 4220], [4222, 4222, 4277, 4277, 4979]]}
{"id": "wsy3DK", "name": "dalp Flat Waves", "author": "dalp", "description": "basic waves", "tags": ["waves"], "likes": 0, "viewed": 30, "published": "Public", "date": "1578062115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\nfloat N11(float p) {\n    float a = fract(p*345.65);\n\ta += dot(a, a+34.45);\n    return fract(a);\n}\n\nvec3 wave(vec2 uv, float t, vec3 col, float seed, float h) {\n    uv += .22;\n    float ti = t*4.5;\n    vec3 m = vec3(0.);\n    h = (h*0.1)+.22;\n    float x = uv.x;\n    float y = uv.y;\n    float w1 = sin(x+seed*ti);\n    float w2 = sin(x*2.+seed*(ti*1.5+seed));\n    float w3 = sin(x*3.+seed*ti);\n    float wavey = (w1+w2+w3)*.15;\n    //wavey += sin(t*3.+uv.x*seed*6.)*.3;\n    uv.y += wavey*.1;\n    m = smoothstep(h*.99,h,uv.y)*col;\n    m = mix(m, smoothstep(h,h*0.90,uv.y)*col,uv.y)*0.8;\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float  t = iTime*.6+m.x+(m.y*4.);\n    \n\tvec3 col = vec3(0.);\n    \n    col += wave(uv,t,vec3(.1,.5,.6),N11(12.),1.);\n    col += wave(uv,t,vec3(.1,.5,.55),N11(1.),2.);\n    col += wave(uv,t,vec3(.1,.5,.5),N11(34.),3.);\n    col += wave(uv,t,vec3(.1,.5,.45),N11(21.),4.);\n    \n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsy3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 132], [134, 134, 194, 194, 633], [635, 635, 692, 692, 1103]]}
{"id": "wt3SR4", "name": "大龙猫 - On the train to fosdem", "author": "totetmatt", "description": "Killing time on the train to Fosdem !", "tags": ["fosdem"], "likes": 2, "viewed": 286, "published": "Public API", "date": "1580473210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cTime floor(iTime) + pow(fract(iTime),.5 + (sin(iTime*10.)*.5+.5)+.1)\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=r(iTime*.1+smoothstep(5.9,.1,length(uv)));\n    \n    uv = abs(uv);\n   \n    uv*=10.;\n    uv*=sin(length(cos(uv)*.5+cTime));\n    uv*=r(length(uv*.1-iTime*.1)+iTime*.12);\n    vec2 id= floor(uv);\n     uv = fract(uv+cTime*.13)-.5;\n    float d = 0.;\n       \n    if(mod(id.x,2.) - mod(id.y,2.) == 0.) {\n        d = min(abs(uv.x+uv.y),.1);\n    } else {   \n        d = min(abs(uv.y-uv.x),.1);\n    }\n    d = smoothstep(0.2,.09-length(uv+sin(iTime)*.4),d);\n    vec3 col;\n    if( mod(id.x,2.) - mod(id.y,2.) == 0.) {\n        col = mix(vec3(.1),vec3(.9,.3,.2*(1.-d)),vec3(d));\n    } else {\n        col = mix(vec3(.1),vec3(.2,.3*(1.-d),.9),vec3(d));\n    }\n       \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 94, 94, 138], [139, 139, 194, 194, 942]]}
{"id": "Wt3SR8", "name": "Mars Sun", "author": "zarly", "description": "Small flashing light", "tags": ["sun"], "likes": 0, "viewed": 44, "published": "Public", "date": "1580325811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float R1 = 0.1;\nfloat R2 = 0.03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float x = uv.x - 0.5 * iResolution.x / iResolution.y;\n    float y = uv.y - 0.5;\n    float r = x * x + y * y;\n    if (r > R1) {\n    \tfragColor = vec4(col,1.0);\n    } else if (r > R2) { \n        float v = (R1 - r) / (R1 - R2);\n        if (col.g < v) {\n        \tcol.g = v;\n        }\n    \tfragColor = vec4(col,1.0);\n    } else {\n    \tfragColor = vec4(1.0,1.0,0.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 141, 647]]}
{"id": "wt3SRn", "name": "Fading Boardwalk", "author": "timeisbeautifulhere", "description": "An early concept for something", "tags": ["lines", "fade", "scrolling"], "likes": 0, "viewed": 187, "published": "Public API", "date": "1580257449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float LINE_WIDTH = 0.05;\nconst float LINE_SPACING = 0.1;\nconst float LINE_VELOCITY = 0.2;\n\n/**\nCheck if coordinate is in the series of moving\nlines. Expects the coordinate to be normalized [0,1]\n*/\nbool isInScrollingLines(vec2 coord){\n    float halfwidth = LINE_WIDTH/2.0;\n    float offset = mod(iTime * LINE_VELOCITY, LINE_SPACING);\n    \n    for(float pos = 0.0 - offset; pos <= 1.0 + LINE_WIDTH; pos=pos+LINE_SPACING){\n        if(coord.x > (pos-halfwidth) && coord.x < (pos+halfwidth)){\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    if(isInScrollingLines(uv))\n        col = vec3(0.0);\n    else{\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n        float bgOpacity = (sin(iTime) + 1.0) / 2.0;\n        col = col * bgOpacity;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 205, 241, 241, 561], [563, 563, 620, 670, 1061]]}
{"id": "Wt3XR8", "name": "Apollonian Zoom", "author": "mla", "description": "Zooming in to an Apollonian Gasket. Mouse moves centre of image.\n\na: disable mouse\nv: vary circle radius\nz: disable zoom\n", "tags": ["2d", "zoom", "apollonian"], "likes": 13, "viewed": 315, "published": "Public API", "date": "1580487748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a ring of circles.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float N = 5.0; // Number of circles\nconst int max_iterations = 40;\nconst float pi = 3.14159265;\n\n// Circles are represented as vec3(x,y,r2) where\n// (x,y) is the centre and r2 is the squared radius.\n\n// Invert pos in circle c\nvec2 invert(vec2 pos, vec3 c) {\n  vec2 p = pos-c.xy;\n  float p2 = dot(p,p);\n  return p*c.z/p2 + c.xy;\n}\n  \n// Invert pos in circle if it is inside \nbool checkinverse(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 > c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\nbool checkinverse2(inout vec2 pos, vec3 c, inout float r2min) {\n  vec2 p = pos-c.xy; \n  float p2 = dot(p,p);\n  r2min = min(r2min,abs(p2-c.z));\n  if (p2 < c.z) {\n    return false;\n  } else {\n    pos = p*c.z/p2 + c.xy;\n    return true;\n  }\n}\n\n// N circles in a ring, with tangency points on unit circle,\n// plus a central circle, tangent to the others, plus an\n// surrounding circle, tangent to the ring circles.\n// The radius of the ring circles can vary so as to overlap\n// or to leave a gap.\nvec4 gasket(vec2 pos, bool varyradius){\n  float theta = pi/N;\n  float r = 1.0/cos(theta);\n  float s = tan(theta);\n  float r2min = 1e10;\n  float t = -0.2*iTime;\n  float rfactor = !varyradius?1.0:0.95 + 0.26*(1.0+cos(0.5*iTime));\n  for(int n = 0; n < max_iterations; n++){\n    vec3 c = vec3(0,0,pow(r-s,2.0));\n    // Try inverting in central circle\n    if (!checkinverse(pos,c,r2min) &&\n        !checkinverse2(pos,vec3(0.0,0.0,pow(r+s,2.0)),r2min)) {\n      bool found = false;\n      // else try in the circles of the ring.\n      for (float i = 0.0; i < N; i++) {\n        vec3 c = vec3(r*sin(2.0*i*theta+t),\n                      r*cos(2.0*i*theta+t),\n                      rfactor*s*s);\n        if (checkinverse(pos,c,r2min)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) return vec4(pos,n,r2min);\n    }\n  }\n  return vec4(pos,max_iterations,r2min);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec4 n){\n  vec3 col = hsv2rgb(vec3(mod(n.z/20.0,1.0),0.8,0.8));\n  col *= 0.6+0.4*smoothstep(0.05,0.1,sqrt(n.w));\n  return col;\n}\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_D = 68;\nconst int CHAR_H = 72;\nconst int CHAR_J = 74;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return z/dot(z,z)*vec2(1,-1);\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\n#define AA 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  fragColor.xyz = vec3(0);\n  vec2 z0 = 2.0 * fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n  float zoom = 1.0; \n  if (!keypress(CHAR_Z)) zoom = exp(45.0-mod(0.4*iTime,60.0));\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      float delta = 1.0/(AA*iResolution.y);\n      vec2 z = z0 + delta*vec2(i,j);\n      z *= zoom;\n      if (keypress(CHAR_H)) {\n        z.y += 1.0;\n        z = invert(z,vec3(0,-1,2)); // Map half plane to unit disk.\n      }\n      if (keypress(CHAR_D)) {\n        z = invert(z,vec3(0,0,1)); // Invert in unit disk\n      }\n      if (!keypress(CHAR_A) && iMouse.x != 0.0) {\n        vec2 m = 2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n        //m = 1.2*vec2(cos(0.0789*iTime),sin(0.0789*iTime));\n        m *= zoom;\n        // Map origin to m with an inversion\n        vec2 c = m/dot(m,m); // m inverted in unit circle\n        z = invert(z,vec3(c,dot(c,c)-1.0));\n      }\n      bool varyradius = !keypress(CHAR_V);\n      vec4 data = gasket(z,varyradius);\n             \n      fragColor.xyz += getCol(data);\n    }\n  }\n  fragColor.xyz /= AA*AA;\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 465, 496, 496, 568], [572, 613, 675, 675, 851], [853, 853, 916, 916, 1092], [1094, 1346, 1385, 1385, 2227], [2229, 2324, 2351, 2351, 2527], [2529, 2529, 2549, 2549, 2669], [2671, 2671, 2696, 2696, 2756], [2897, 2897, 2924, 2924, 2979], [2981, 2981, 3000, 3000, 3034], [3036, 3036, 3056, 3056, 3143], [3161, 3161, 3217, 3217, 4365]]}
{"id": "Wt3Xzr", "name": "Je t'aime", "author": "sbrown2", "description": "My valentines day shader for my girlfriend to be sent that day. Tried to make something nice with limited knowledge. I want to shoutout iq's distance functions and bigwings tutorials.\n", "tags": ["2d", "voronoi", "sdf", "love", "valentinesday"], "likes": 0, "viewed": 122, "published": "Public", "date": "1580260312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p){\n\tfloat d = fract(cos(605.43*fract(sin(p.x*p.y*6725.)))*9284.);\n    \n\treturn d;\n}\nvec2 N22(vec2 p){\n    float r = N21(p);\n\treturn vec2(r,N21(vec2(r)));\n}\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += .6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .2;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2−1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - (7.*max(abs(sin(2.*iTime)),abs(cos(2.*iTime))));\n}\n\nfloat heart2(vec2 p) {\n    // Center it more, vertically:\n    float fft = texelFetch(iChannel0,ivec2(.7,0.), 0).x;\n    float wave = texelFetch(iChannel0,ivec2(10.,0.),0).x;\n\tfft*=(wave);\n    p.y += .3;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2−1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - 1.*(1.5*fft);\n}\n\nvec3 background(vec2 uv){\n    \n\tfloat wave = texelFetch(iChannel0,ivec2(10.,0.),0).x;\n\twave*=abs(uv.y*.2);\n    return vec3(wave)*vec3(2.,.8,.8)+vec3(.1,.1,.1); \n}\nvec3 voro(vec2 uv){\nfloat m = 0.;\n    float t = iTime;\n    float minD = 100.;\n    float closestcell = 0.;\n    \n    \tuv*=5.;\n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        \n        for(float x = -1.; x <=1.; x++){\n            for(float y=-1.; y<=1.; y++){\n            \tvec2 offset = vec2(x,y);\n            \tvec2 n = N22(vec2(id+offset));\n\n                vec2 p = .5*sin(n*t)+offset; //-1 to 1 \n                \n                float d = pow(heart2(gv-p),3.)*.6;\n                if(d<minD){\n                minD = d;\n                //closestcell = float(i);\n                }\n        \n           }\n        \n    }\n    vec3 voro = (vec3(.5,.0,.1)-minD)*pow(vec3(1.,.4,.4),vec3(.4)); \n\treturn voro;    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates -.5 to .5\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    //the inner voronoi pattern in the heart\n    vec3 voro = voro(uv);\n    col=voro;\n    \n    //create heart shape and background effect\n    uv*=5.;\n    float heart = heart(uv);\n    \n    //ad background\n    vec3 back_ground = background(uv);\n    if(heart>0.){\n    col = back_ground;\n    }\n    \n    //add border to heart uncomment 2nd color\n    //to have a PPG like effect\n    if(heart > 0. && heart < 1.){\n    col = mix(back_ground,vec3(1.),heart*heart);\n\t    \n    \n    }\n    \n    //assumes animation start from beginning\n\t//col = 1.-smoothstep(back_ground,vec3(1.),vec3(heart*heart));\n    if((iTime > 66. && iTime < 97.) ||\n       (iTime>129. && iTime < 160.) ){\n    \tcol *= 1.-smoothstep(back_ground,vec3(1.),vec3(heart*heart));\n    \tcol+=voro;\n    }\n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4lB3zW", "previewfilepath": "https://soundcloud.com/jalnaf/jalen-santoy-foreplay-official-video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jalnaf/jalen-santoy-foreplay-official-video", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Xzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 99], [100, 100, 117, 117, 171], [172, 172, 193, 228, 511], [513, 513, 535, 570, 947], [949, 949, 974, 974, 1111], [1112, 1112, 1131, 1131, 1835], [1836, 1836, 1893, 1939, 2857]]}
{"id": "Wtc3WS", "name": "zooming hexagon", "author": "julianlumia", "description": "just playing around:)", "tags": ["hexagon"], "likes": 1, "viewed": 62, "published": "Public", "date": "1578347962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot (float a)\n{\n float s = sin(a);\n float c = cos(a);\n return mat2(c,-s,s,c);      \n}\n\nfloat hex (vec2 p)\n{\n p = abs(p);\n //p *= (Rot ((((floor(p.y*10.)))*0.5+sin(iTime))*1.));\n //p *= (Rot ((((floor(p.x*5.)))+cos(iTime))*.5));\n float c = dot(p,normalize(vec2(1,1.73)));\n c = max(c,p.x);\n return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n uv *= 1.;   \n        \n// uv = abs (uv)-0.5;   \n    \nuv *= (Rot ((sin(iTime)*+1.5)));\n    \n    \n float c = tan(hex(uv)*2.+iTime);   \n vec3 col = vec3(step(c,.1));\n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtc3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 90], [92, 92, 112, 112, 305], [307, 307, 364, 364, 614]]}
{"id": "wtcGDl", "name": "2K20", "author": "Gaxil", "description": "Just a first quick shader to celebrate 2020 ... Happy new year to all shader fans (and to the others too, you just don't know what you're missing)", "tags": ["tunnel", "raymarch", "kifs", "celebration"], "likes": 8, "viewed": 132, "published": "Public", "date": "1577921864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SURF_DIST 0.001\n#define MAX_STEPS 64\n\nfloat PI = 3.1415926535897932384626433832795;\n\n// Many functions are directly taken from IQ's site : http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// So many thanks for this, IQ\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r, float angle )\n{\n  p.xy = p.xy*rot(angle);\n  \n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, float angle)\n{\n  p.xy = p.xy*rot(angle);\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdLine(vec2 pos, float r)\n{\n    return length(pos)-r;\n}\n\nfloat sdZero(vec3 p)\n{\n  return sdLink(p+ vec3(0,0.125,0), 1.125, 1.0, 0.5);  \n}\n\nfloat sdTwo(vec3 p)\n{\n  float dist;\n  float an = 1.57*1.25;\n  vec2 c = vec2(sin(an),cos(an));\n  dist = sdCappedTorus(p + vec3(0,-1.45,0), c, 1.0, 0.5, 0.39);  \n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1.75,0), 2.5, 0.5, 1.57),0.05);\n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1,0), 2.25, 0.5, 1.57*0.5),0.05);\n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1.75,0.0), 0.5, 0.5, 0.0),0.05);\n  return dist;  \n}\n\nfloat sd2020(vec3 p)\n{\n  float dist;\n  \n  dist = sdZero(p-vec3(5.0, 0.5, 0.));\n  dist = min(dist, sdZero(p-vec3(-1.55, 0.5, 0.)));\n  dist = min(dist, sdTwo(p-vec3(1.55, 0., 0.)));\n  dist = min(dist, sdTwo(p-vec3(-5.0, 0., 0.)));\n  \n  return dist;\n}\n\n// Thanks to Antoine Zanuttini for this : https://www.youtube.com/channel/UCdiiD1ukw39XTRj9h6LKCeQ/videos\nfloat sdKIFF(vec3 pos)\n{\n  vec3 oPos = pos;\n  \n  float dist = 100000.;\n\n  pos.xz = pos.xz * rot(iTime*0.2);\n  pos.xy = pos.xy * rot(iTime*0.3);\n\n  mat3x3 rMat = mat3x3(1,0,0, 0,1,0, 0,0,1);\n  \n \n  float scale = 2.0;\n  float rScale = 5.0;\n  for(int i=0;i<8;i++)\n  {\n    pos = abs(pos);\n    pos -= vec3(1.5,1.5,1.5)*scale;\n    pos.xz = pos.xz * rot(1.0+iTime*0.1*rScale);\n    pos.zy = pos.zy * rot(2.0+iTime*0.15*rScale);\n    scale *= 0.5;\n    rScale -= 2.5;\n  }\n  \n  dist = min(dist, sdSphere(pos, 2.5 * scale));\n  return dist; \n}\n\n// From http://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm\nfloat elastic(float t)\n{\n  float ts= t*t;\n  float tc = ts*t;\n\treturn (56.*tc*ts + -175.*ts*ts + 200.*tc + -100.*ts + 20.*t);\n}\n\nfloat getDist2020(vec3 pos)\n{ \n  float dist = 0.0; \n  \n  float angle = atan(pos.x, pos.y);\n  vec3 oPos = pos;\n  \n  pos.xy = rot(sin(iTime*.021)*0.1) * pos.xy;\n  pos.xz = rot(sin(iTime*0.121)*0.25) * pos.xz;\n  \n  float delta = elastic(min(fract(iTime*0.1)*2., 1.))*10.;\n  \n  float tDist = sd2020(pos-vec3(0.0, 0.0, 11.-delta));\n  dist = tDist;\n  dist = opSmoothSubtraction(tDist-.5, sdKIFF(pos-vec3(0.0, 0.0, 8.)), .25);\n  dist = min(dist, tDist);\n\n\n  return dist;\n}\n\nvec3 calcNormal2020(vec3 pos)\n{\n  vec2 delta = vec2(-1, 1) * 0.01f;\n\n  return normalize(\n    delta.xyy * getDist2020(pos + delta.xyy) +\n    delta.yyx * getDist2020(pos + delta.yyx) +\n    delta.yxy * getDist2020(pos + delta.yxy) +\n    delta.xxx * getDist2020(pos + delta.xxx)); \n}\n\nvec4 getColor2020(vec3 ro, vec3 rd, out vec3 emissive)\n{\n  float d0 = 2.0f;\n  vec3 p = vec3(0.0);\n  float dS = 0.0f;\n  float acc = 0.0f;\n  float glow = 0.0f;\n  \n  for(int i=0;i<MAX_STEPS;i++)\n  {\n    p = ro + rd * d0;\n    dS = abs(getDist2020(p));\n    d0 += dS*0.75;\n    if (dS<1000.)\n      glow += 0.001/(0.01+dS*0.1);\n    \n    if (dS<SURF_DIST) break;   \n  }\n\n  vec4 rm = vec4(p, dS); \n  \n  vec4 color;\n  \n\n  if (dS < SURF_DIST)\n  {\n    // Object hit\n    color = vec4(1.0);\n    \n    vec3 nrm = calcNormal2020(rm.xyz);\n    vec3 light = vec3(0, 3, -5.);\n    vec3 dirLight = light - rm.xyz;\n    \n    float intensity = clamp(dot(nrm, normalize(dirLight)), 0., 1.);\n    intensity *= 8./dot(dirLight, dirLight);\n    intensity += 0.005;\n  \n    glow *= 0.1;\n    \n    color.rgb *= intensity;  \n  }\n  else \n  {\n    color = vec4(0);\n  }\n  \n  emissive = glow*vec3(1.0, 0.35, 0.1);\n    \n  return color;\n  \n}\n\nvec3 radial(vec3 p, float rep, float off)\n{\n  vec2 rp = vec2(atan(p.y,p.x)/(2.0*PI), length(p.xy));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,sin(rp.x)*rp.y,p.z);\n}\n\nfloat getDistTunnel(vec3 pos)\n{ \n  float dist = 0.0; \n  pos.xy *= rot(pos.z*0.3 + iTime + sin(pos.z*1.3 +iTime*0.3));\n  pos = radial(pos, 3., 0.);\n  dist = sdLine(pos.xy + vec2(-2.+sin(pos.z*10. - iTime*5.)*0.25,0.), 0.1);\n  \n  return dist;\n}\n\nvec3 calcNormalTunnel(vec3 pos)\n{\n  vec2 delta = vec2(-1, 1) * 0.01f;\n\n  return normalize(\n    delta.xyy * getDistTunnel(pos + delta.xyy) +\n    delta.yyx * getDistTunnel(pos + delta.yyx) +\n    delta.yxy * getDistTunnel(pos + delta.yxy) +\n    delta.xxx * getDistTunnel(pos + delta.xxx)); \n}\n\nvec4 getColorTunnel(vec3 ro, vec3 rd, out vec3 Emissive)\n{\n  float d0 = 2.0f;\n  vec3 p = vec3(0.0);\n  float dS = 0.0f;\n  float acc = 0.0f;\n  float glow = 0.0f;\n  Emissive =vec3(0.);\n  \n  for(int i=0;i<MAX_STEPS;i++)\n  {\n    p = ro + rd * d0;\n    dS = abs(getDistTunnel(p));\n    d0 += dS*0.1;\n    if (dS<1000.)\n      glow += 0.005/(0.1+dS);\n    \n    if (dS<SURF_DIST) break;   \n  }\n\n  vec4 rm = vec4(p, dS); \n  \n  vec4 color;\n  \n\n  if (dS < SURF_DIST)\n  {\n    color = vec4(1.0);\n   \n    vec3 nrm = calcNormalTunnel(rm.xyz);\n    vec3 light = vec3(-3, 2, -4);\n    vec3 dirLight = light - rm.xyz;\n    \n    float intensity = clamp(dot(nrm, normalize(dirLight)), 0., 1.);\n    intensity *= 30./dot(dirLight, dirLight);\n    intensity += 0.005;\n  \n    color.rgb *= intensity;\n    color.a = 1.0;\n    Emissive += vec3(0.1, 0.35, 1.0);\n  }\n  else \n  {\n    color = vec4(0);\n  }\n\n  glow*=glow;\n  Emissive += glow*vec3(0.1, 0.35, 1.0);\n\n  return color;  \n}\n\n// From http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemapFilmic(const vec3 color) \n{\n\tvec3 x = max(vec3(0.0), color - 0.004);\n\treturn (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = vec3(0.0, 0.0, -15);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  vec4 color = vec4(0.0); \n  vec3 colorEmissive2020;\n  vec4 color2020 = getColor2020(ro, rd, colorEmissive2020);\n  vec3 colorEmissiveTunnel;\n  vec4 colorTunnel = getColorTunnel(ro, rd, colorEmissiveTunnel);\n  color = colorTunnel; \n  color = mix(color, color2020, color2020.a); \n  color.rgb += colorEmissive2020+colorEmissiveTunnel*(1.0-color2020.a);\n\n  color.rgb = tonemapFilmic(color.rgb);\n  fragColor = color;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 246, 299, 299, 399], [401, 401, 460, 460, 561], [563, 563, 588, 588, 658], [660, 660, 692, 692, 757], [759, 759, 825, 825, 913], [915, 915, 998, 998, 1158], [1160, 1160, 1195, 1195, 1219], [1221, 1221, 1275, 1275, 1377], [1379, 1379, 1412, 1412, 1440], [1442, 1442, 1464, 1464, 1522], [1524, 1524, 1545, 1545, 1975], [1977, 1977, 1999, 1999, 2225], [2227, 2333, 2357, 2357, 2862], [2864, 2951, 2975, 2975, 3077], [3079, 3079, 3108, 3108, 3544], [3546, 3546, 3577, 3577, 3825], [3827, 3827, 3883, 3883, 4723], [4725, 4725, 4768, 4768, 4936], [4938, 4938, 4969, 4969, 5180], [5182, 5182, 5215, 5215, 5471], [5473, 5473, 5531, 5531, 6414], [6416, 6483, 6522, 6522, 6627], [6629, 6629, 6686, 6686, 7321]]}
{"id": "wtcGDs", "name": "\"Cell\"", "author": "tono", "description": "cellernoise", "tags": ["raymarching"], "likes": 3, "viewed": 314, "published": "Public API", "date": "1577939404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//i posted the shader on neort and shadertoy\n\n#define A 3\n\nmat2 rot(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 random33(vec3 st)\n{\n    st = vec3(dot(st,vec3(127.1, 311.7,811.5)),\n                dot(st, vec3(269.5, 183.3,211.91)),\n                dot(st, vec3(511.3, 631.19,431.81))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat norm(vec3 p, float n)\n{\n    vec3 t=pow(abs(p),vec3(n));\n    return pow(t.x+t.y,1./n);\n}\n\nvec4 celler3D(vec3 i,vec3 sepc)\n{\n    float stime = iTime / 1.5;\n    vec3 sep = i * sepc;\n    vec3 fp = floor(sep);\n    vec3 sp = fract(sep);\n    float dist = 5.;\n    vec3 mp = vec3(0.);\n\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(x, y ,z);\n                vec3 pos = vec3(random33(fp+neighbor));\n                pos = sin( (pos*50. +stime/(230. + 100.*cos(stime/130.))) )* 0.5 + 0.5;\n                \n                float shape = 0.5 + clamp(sin(stime),0.,1.) *30.;\n                float rate = clamp( (sin(stime/2.)),0.,1.);\n                float divs = norm(neighbor + pos - sp,shape);\n                divs = mix(length(neighbor + pos - sp),divs,rate);\n                mp = (dist >divs)?pos:mp;\n                dist = (dist > divs)?divs:dist;\n            }\n        }\n    }\n    return vec4(mp,dist);\n}\n\nvoid scene(out vec3 color,in vec2 F)\n{\n    vec2 p = (F.xy * 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n    //vec3 color = vec3(0.);\n    \n    vec3 cp = vec3(0.,0.,-5.);\n    vec3 cd = vec3(0.,0.,1.);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cd,cu));\n    cu = normalize(cross(cd,cs));\n    \n    float target = 5.0;\n    \n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + cd * target));\n    \n    float depth = 0.;\n    \n    float stime = iTime/ 150.;\n    \n    for(int i = 0 ; i < 3 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec4 celler = celler3D(rp,vec3(50.)+1.1*sin(stime) );\n        float w = celler.w;\n        w = max(celler.w,0.001);\n        \n        if (celler.w - 0.3 < 0.0001 && depth > 0.0001)\n        {\n            color += celler.xyz - celler.w;\n            break;\n        }\n        if(depth > 1.){break;}\n        depth += w;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //supersampling | oversampling\n\t//https://youtu.be/Pcph14WlLsk   \n    \n    vec3 color = vec3(0.);\n    \n    for(int i = 0;i < A;i++ )\n    {\n        for(int j = 0; j < A;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(A);\n            scene(color,fragCoord + d);\n        }\n    }\n    color /= float(A * A);\n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 78, 78, 140], [142, 142, 166, 166, 395], [397, 397, 426, 426, 490], [492, 492, 525, 525, 1434], [1436, 1436, 1474, 1474, 2322], [2324, 2324, 2381, 2451, 2794]]}
{"id": "WtcSRH", "name": "Attraction-1", "author": "timF", "description": "Based off user  alijaya's ray marching phong template.\nStill learning..", "tags": ["raymarching"], "likes": 1, "viewed": 196, "published": "Public API", "date": "1580348380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n\tvec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// Octahedron function\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// smooth union function\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// change this\nfloat sdScene( vec3 p ) {\n    float finalShape = 0.0;\n    float sphereTest = sdSphere(p, 200.0);\n    float sphereTest2 = sdSphere(p, 200.0);\n    vec4 spherePos = vec4(p,0.0); // the center sphere position\n    \n    float sphereScale = 1.0;\n    \n    \n    float sphere1 = sdSphere( spherePos.xyz, sphereScale); // center sphere\n    \n    //offsets of the left and right octa so they are uniform\n    vec2 octaOffset = vec2(4.8+sin(iTime*2.)*.2,.4);\n    \n    //sizeing\n    float octaSize = 2.0;\n    float boxSize = .95;\n    \n    float leftOcta = sdOctahedron(p - vec3(octaOffset.x,octaOffset.y,0.0), octaSize);\n    float leftOctaSub = sdBox(p - vec3(octaOffset.x,octaOffset.y,0.0),boxSize,boxSize,boxSize);\n    float rightOcta = sdOctahedron(p + vec3(octaOffset.x,octaOffset.y-1.,0.0), octaSize);\n    float rightOctaSub = sdBox(p + vec3(octaOffset.x,octaOffset.y-1.,0.0),boxSize,boxSize,boxSize);\n    \n    leftOcta = sdSubstract(leftOcta,leftOctaSub);\n    rightOcta = sdSubstract(rightOcta,rightOctaSub);\n    float lConnection = 3.2 + sin(iTime*120.)*.08;\n    float rConnection = 3. + sin(iTime*120.)*.08;\n    \n    \n    \n    finalShape = opSmoothUnion(opSmoothUnion(sphere1, leftOcta,lConnection),rightOcta,rConnection);\n    //finalShape = min(sphereTest,finalShape );\n    \n    //finalShape = min(sphereTest, sphereTest2);\n    \n    return finalShape;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n    \tsdScene(p+xe) - sdScene(p-xe),\n        sdScene(p+ye) - sdScene(p-ye),\n        sdScene(p+ze) - sdScene(p-ze)\n    ));\n}\n\n// ray marching algorithm\nfloat getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d );\n        \n        if (dist < EPSILON) { // inside a scene\n            return depth;\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return MAX_DISTANCE;\n        }\n    }\n    \n    return MAX_DISTANCE;\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(0.0,3.0 + sin(iTime*.2)*4.,-4.0);\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n    \n    // create 8 points of cube\n    vec3 points[8];\n    for (int i=0; i<2; i++) {\n        for (int j=0; j<2; j++) {\n            for (int k=0; k<2; k++) {\n                points[i*4+j*2+k] = vec3(float(i) * 2. - 1., float(j) * 2. - 1., float(k) * 2. - 1.);\n            }\n        }\n    }\n    \n    // render\n    float dist = getSDF(ray);\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1, 0.1, 0.2);\n    vec3 diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(-2,2,-3);\n    light1.color = vec3(1., 0.5, 0.3);\n    \n    Light light2;\n    light2.pos = vec3(2,2,3);\n    light2.color = vec3(1., 0.8, 0.5);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 473, 508, 508, 1390], [1392, 1416, 1459, 1459, 1757], [1759, 1807, 1851, 1851, 2034], [2036, 2125, 2196, 2196, 2260], [2262, 2281, 2321, 2321, 2354], [2356, 2379, 2417, 2417, 2470], [2472, 2497, 2549, 2549, 2648], [2652, 2668, 2731, 2731, 2819], [2821, 2842, 2898, 2898, 2958], [2960, 2960, 2999, 2999, 3027], [3029, 3029, 3072, 3072, 3100], [3102, 3102, 3145, 3145, 3174], [3176, 3176, 3221, 3221, 3849], [3852, 3867, 3892, 3892, 5213], [5215, 5247, 5278, 5278, 5428], [5430, 5456, 5479, 5479, 5880], [5882, 5882, 5922, 5922, 5949], [5951, 5951, 6060, 6060, 6815], [6817, 6817, 6874, 6947, 8627]]}
{"id": "wtcSzH", "name": "Bricks takeoff", "author": "joynes", "description": "Playing with the simple bricks example from bookofshaders along with antialiasing.", "tags": ["bricks"], "likes": 1, "viewed": 223, "published": "Public API", "date": "1580378246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 t = fragCoord/iResolution.y - .5;\n    \n  float x = iTime*.1;\n  float zoom = 10.;\n  float rad = .5*(sin((x-.25)*3.1416*2.)+1.)/2.;\n  rad = -rad*rad;\n  t = mat2(cos(rad), sin(rad), -sin(rad), cos(rad))*t;\n  zoom += 3.*sin((x-.25)*3.1416*2.);\n  t *= zoom;\n  float move = (sin((fract(x)-.5)*3.1416)+1.)/2.+floor(x) + x*.4;\n  t += vec2(move*50., -rad*40.);\n\n  t.x = t.x + mod(floor(t.y), 2.);\n  float enable = mod(floor(t.x), 2.);\n  t = fract(t)-.5;\n  float r = zoom*1.*1.5/iResolution.y;\n  float w = .45;\n  float c = enable*(smoothstep(w+r, w-r, t.x) * smoothstep(w+r, w-r, abs(t.y)));\n  c += (1. - enable)*(smoothstep(-w-r, -w+r, t.x) * smoothstep(w+r, w-r, abs(t.y)));\n  vec3 col = mix(vec3(.4), vec3(.81, .45, .33), c);\n  fragColor = vec4(col, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 816]]}
{"id": "wtcSzN", "name": "DVD Bounce", "author": "tdhooper", "description": "Something for [url]https://cineshader.com/view/wtcSzN[/url]", "tags": ["waves", "logo", "bounce", "dvd", "cineshader"], "likes": 85, "viewed": 93284, "published": "Public API", "date": "1580500099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\n\n//#define DEBUG\n\n  \n    \nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\nfloat halfEllip(vec2 p, vec2 s) {\n    p.x = max(0., p.x);\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\n\nfloat fBox(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat dvd_d(vec2 p) {\n    float d = halfEllip(p, vec2(.8, .5));\n    d = max(d, -p.x - .5);\n    float d2 = halfEllip(p, vec2(.45, .3));\n    d2 = max(d2, min(-p.y + .2, -p.x - .15));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd_v(vec2 p) {\n    vec2 pp = p;\n    p.y += .7;\n    p.x = abs(p.x);\n    vec2 a = normalize(vec2(1,-.55));\n    float d = dot(p, a);\n    float d2 = d + .3;\n    p = pp;\n    d = min(d, -p.y + .3);\n    d2 = min(d2, -p.y + .5);\n    d = max(d, -d2);\n    d = max(d, abs(p.x + .3) - 1.1);\n\treturn d;\n}\n\n\nfloat dvd_c(vec2 p) {\n    p.y += .95;\n\tfloat d = ellip(p, vec2(1.8,.25));\n    float d2 = ellip(p, vec2(.45,.09));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd(vec2 p) {\n    p.y -= .345;\n    p.x -= .035;\n    p *= mat2(1,-.2,0,1);\n\tfloat d = dvd_v(p);\n    d = min(d, dvd_c(p));\n    p.x += 1.3;\n    d = min(d, dvd_d(p));\n    p.x -= 2.4;\n    d = min(d, dvd_d(p));\n    return d;\n}\n\n\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\nvoid drawHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist) {\n\n    float d = length(p - hitPos);\n    \n    #ifdef DEBUG\n    col = mix(col, vec4(0,1,1,0), step(d, .1)); return;\n    #endif\n    \n    float wavefront = d - hitDist * 1.5;\n    float freq = 2.;\n    \n    vec3 spec = (1. - spectrum(-wavefront * freq + hitDist * freq));\n    float ripple = sin((wavefront * freq) * PI*2. - PI/2.);\n    \n    float blend = smoothstep(3., 0., hitDist);\n    blend *= smoothstep(.2, -.5, wavefront);\n    blend *= rangec(-4., .0, wavefront);\n    \n    col.rgb *= mix(vec3(1), spec, pow(blend, 4.));\n    float height = (ripple * blend);\n    col.a -= height * 1.9 / freq;\n}\n\nvec2 ref(vec2 p, vec2 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tp -= (2. * t) * planeNormal;\n    return p;\n}\n\nvoid drawReflectedHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist, vec2 screenSize) {\n    col.a += length(p) * .0001; // fix normal when flat\n\t//drawHit(col, p, hitPos, hitDist); return;\n    drawHit(col, p, ref(hitPos, vec2(0,1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(0,-1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(1,0), screenSize.x/screenSize.y), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(-1,0), screenSize.x/screenSize.y), hitDist);\n}\n\n\n// Flip every second cell to create reflection\nvoid flip(inout vec2 pos) {\n    vec2 flip = mod(floor(pos), 2.);\n    pos = abs(flip - mod(pos, 1.));\n}\n\nfloat stepSign(float a) {\n    //return sign(a);\n\treturn step(0., a) * 2. - 1.;\n}\n\nvec2 compassDir(vec2 p) {\n    //return sign(p - sign(p) * vmin(abs(p))); // this caused problems on some GPUs\n    vec2 a = vec2(stepSign(p.x), 0);\n    vec2 b = vec2(0, stepSign(p.y));\n    float s = stepSign(p.x - p.y) * stepSign(-p.x - p.y);\n    return mix(a, b, s * .5 + .5);\n}\n\nvec2 calcHitPos(vec2 move, vec2 dir, vec2 size) {\n    vec2 hitPos = mod(move, 1.);\n    vec2 xCross = hitPos - hitPos.x / (size / size.x) * (dir / dir.x);\n    vec2 yCross = hitPos - hitPos.y / (size / size.y) * (dir / dir.y);\n   \thitPos = max(xCross, yCross);\n    hitPos += floor(move);\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    #ifdef DEBUG\n    \t//p.xy += vec2(1.2, .6);\n    \t//p *= 3.5;\n    \tp *= 2.;\n   \t#endif\n    \n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.;\n\n    float t = iTime;\n    vec2 dir = normalize(vec2(9.,16) * screenSize );\n    vec2 move = dir * t / 1.5;\n    float logoScale = .1;\n    vec2 logoSize = vec2(2.,.85) * logoScale * 1.;\n\n    vec2 size = screenSize - logoSize * 2.;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    move = move / size + .5;\n\n    // Calculate the point we last crossed a cell boundry\n    vec2 lastHitPos = calcHitPos(move, dir, size);\n    vec4 col = vec4(1,1,1,0);\n    vec4 colFx = vec4(1,1,1,0);\n    vec4 colFy = vec4(1,1,1,0);\n    vec2 e = vec2(.8,0)/iResolution.y;\n\n    #ifdef DEBUG\n\t\tcol.rgb = vec3(0.);\n    #endif\n    \n   \t#ifdef DEBUG\n\t\tconst int limit = 1;\n   \t#else\n    \tconst int limit = 5;\n    #endif\n\t\n    for (int i = 0; i < limit; i++) {\n        vec2 hitPos = lastHitPos;\n \n        if (i > 0) {\n            // Nudge it before the boundry to find the previous hit point\n            hitPos = calcHitPos(hitPos - .00001/size, dir, size);\n        }\n        \n        lastHitPos = hitPos;\n        \n    \t// How far are we from the hit point\n    \tfloat hitDist = distance(hitPos, move);\n        \n        // Flip every second cell to create reflection\n        flip(hitPos);\n\n\t\t// Remap back to screen space\n    \thitPos = (hitPos - .5) * size;\n\t\t\n        // Push the hits to the edges of the screen\n        hitPos += logoSize * compassDir(hitPos / size);\n    \n\t    drawReflectedHit(col, p, hitPos, hitDist, screenSize);\n \t   \tdrawReflectedHit(colFx, p + e, hitPos, hitDist, screenSize);\n    \tdrawReflectedHit(colFy, p + e.yx, hitPos, hitDist, screenSize);\n    }\n        \n    // Flip every second cell to create reflection\n    flip(move);\n\n    // Remap back to screen space\n    move = (move - .5) * size;\n    \n    // Calc normals\n\tfloat bf = .1; // Bump factor\n    float fx = (col.a - colFx.a) * 2.; // Nearby horizontal samples.\n    float fy = (col.a - colFy.a) * 2.; // Nearby vertical samples.\n    vec3 nor = normalize(vec3(fx, fy, e.x/bf)); // Bumped normal.\n    float ff = length(vec2(fx, fy));\n    float ee = rangec(0., 10./iResolution.y, ff);\n    nor = normalize(vec3(vec2(fx, fy)*ee, ff));\n\n    // invert colours\n    col.rgb = clamp(1. - col.rgb, vec3(0), vec3(1));\n    col.rgb /= 3.;\n    \n\n    #ifndef DEBUG\n\t\n    \t// lighting\n    \t// iq https://www.shadertoy.com/view/Xds3zN\n        vec3 lig = normalize(vec3(1,2,2.));\n        vec3 rd = normalize(vec3(p, -10.));\n        vec3  hal = normalize( lig - rd );\n\n        float dif = clamp(dot(lig, nor), 0., 1.);\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.);\n        lin += 5. * dif;\n        lin += .2;\n        col.rgb = col.rgb * lin;\n        col.rgb += 5. * spe;\n\t#endif\n    \n    #ifdef DEBUG\n        float b = vmin(abs(fract(p / screenSize) - .5) * 2.);\n        b /= fwidth(b) * 2.;\n        b = clamp(b, 0., 1.);\n        b = 1. - b;\n        col.rgb = mix(col.rgb, vec3(0), b);\n    #endif\n    \n    // dvd logo\n\tfloat d = dvd((p - move) / logoScale);\n    d /= fwidth(d);\n    d = 1. - clamp(d, 0., 1.);\n    col.rgb = mix(col.rgb, vec3(1), d);\n    \n    // banding be gone\n    col += (texture(iChannel0, fragCoord / iChannelResolution[0].xy) * 2. - 1.) * .005;\n\n    // gamma\n    col.rgb = pow(col.rgb, vec3(1./1.5));\n\n    col.a = col.a * .5 + .5;\n\tcol.a *= .3;\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"DVD\",\n\t\"description\": \"\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 53, 73, 73, 98], [100, 100, 120, 120, 145], [147, 147, 176, 176, 234], [236, 236, 269, 269, 351], [354, 354, 382, 382, 410], [412, 412, 433, 433, 629], [631, 631, 652, 652, 929], [932, 932, 953, 953, 1082], [1084, 1084, 1103, 1103, 1310], [1314, 1314, 1364, 1364, 1407], [1409, 1409, 1450, 1450, 1494], [1496, 1537, 1605, 1605, 1648], [1649, 1649, 1673, 1673, 1771], [1774, 1774, 1840, 1840, 2432], [2434, 2434, 2484, 2484, 2571], [2573, 2573, 2665, 2665, 3048], [3051, 3098, 3125, 3125, 3200], [3202, 3202, 3227, 3249, 3282], [3284, 3284, 3309, 3393, 3562], [3564, 3564, 3613, 3613, 3870], [3872, 3872, 3929, 3929, 7551]]}
{"id": "wtd3Ws", "name": "Apollonian--Modv2", "author": "jorge2017a1", "description": "Modificado poquito!!!", "tags": ["apollonianmodv2"], "likes": 3, "viewed": 77, "published": "Public", "date": "1578020032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu..........y modificado por Jorge flores///---13/jun/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATION 8\n\nvec4 orb;\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n        float r2 = dot(p,p);\n        \n        \n        orb = min( orb, vec4(abs(p+ sin(p)),r2) );\n        float k = 1.2/ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n    \n    \n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n\n    float d0=apollonian(p*0.41)*5.;;\n    float d1=abs(p.y-0.02);\n    float d3 = box(q+vec3(0.,-2.,0.), 2.9*vec3(3.,2.,2.3));\n    float d = max(d0, d3);\n    d=min(d,d1);\n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n    const vec2 g = vec2(0.001, 0.002);\n    \n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\n                          map(p + e.yyx+g.yyx)-map(p - e.yyx-g.yyx)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    vec3 lookat = vec3(0.0, 1.5, 0.);\n\t\n    vec3 ro = 1.4*vec3(-1.+cos(iTime*0.5)*3.0, 1.5,-4.5+ sin( iTime*0.5)*3.0);\n    \n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    \n    vec3 rd=normalize(p.x*right + p.y*up + 4.0*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-12., 1.0, -7.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.0, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.0, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.0,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        \n        col1 = mix(col1, vec3(0.4,0.3,0.9), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.,1.,0.)));\n        \n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 70.0));\n        \n        float sha=softshadow( pos+0.1*n, ld0, 0.05, 32.0 );\n        \n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(5.,5.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(2000.0*exp(-0.74*t),1.0);\n\n     }\n    //col=tonemap(col);\n    \n    col=pow(col,vec3(1.3,1.,1.));\n    \n    \n    \n    \n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtd3Ws.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 197, 223, 223, 528], [530, 530, 557, 557, 656], [658, 658, 677, 677, 877], [879, 879, 904, 904, 1165], [1167, 1167, 1210, 1210, 1464], [1466, 1466, 1531, 1531, 1794], [1796, 1796, 1818, 1818, 2004], [2006, 2006, 2063, 2063, 3929]]}
{"id": "wtdGDs", "name": "poor water (v2)", "author": "mystran", "description": "Version 2: still poor, but now samples sliding noise in 4 directions, to give it a bit more of a wave motion.", "tags": ["water"], "likes": 6, "viewed": 182, "published": "Public", "date": "1578023430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Probably the worst \"water\" shader ever.\n//  - uses simplex noise to animate the surface.\n//  - uses surface normal to displace background\n//  - computes specular lighting for surface\n//  - blends specular vs. background based on normal vs. viewdir\n//  - does not attempt to be particularly correct or good\n//\n// v2: sample noise 4 times: slide in cardinal directions, morph slowly\n\n\n// COPY PASTE SIMPLEX NOISE from https://github.com/stegu/webgl-noise:\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v, out vec3 gradient)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  vec4 m2 = m * m;\n  vec4 m4 = m2 * m2;\n  vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\n\n// Determine noise gradient\n  vec4 temp = m2 * m * pdotx;\n  gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n  gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n  gradient *= 42.0;\n\n  return 42.0 * dot(m4, pdotx);\n}\n// END OF COPY PASTE SIMPLEX NOISE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 t = vec2(.5 * iTime, .5);\n    // sample moving noise in 4 directions, with slower morph\n    vec3 grad0, grad1, grad2, grad3;\n    snoise(vec3(2.*fragCoord.xy/iResolution.y + t.xy, .125*t.x), grad0);\n    snoise(vec3(2.*fragCoord.yx/iResolution.y - t.xy, .125*t.x), grad1);\n    snoise(vec3(2.*fragCoord.xy/iResolution.y + t.yx, .125*t.x), grad2);\n    snoise(vec3(2.*fragCoord.yx/iResolution.y - t.yx, .125*t.x), grad3);\n    \n    // take xy-gradient as surface partial derivative, add together\n    vec2 grad = grad0.xy + grad1.xy + grad2.xy + grad3.xy;\n    \n    // light dir\n    vec3 L = normalize(vec3(-1,1,3));\n    // camera dir\n    vec3 C = vec3(0,0,1);\n    // normal\n    vec3 N = normalize(vec3(grad.xy, 4.));\n    \n    float lit = pow(max(0.,dot(normalize(L+C), N)), 20.);\n    float frac = 1.-max(0., dot(N, C));\n    frac *= frac;\n    \n    vec3 b = texture(iChannel0, uv + (4./iResolution.xy)*N.xy).xyz;\n    \n    b = (1.-frac) * b + frac*(10.*lit);\n    \n    // Output to screen\n    fragColor = vec4(vec3(b),1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGDs.jpg", "access": "shaders20k", "license": "mit", "functions": [[459, 914, 935, 935, 984], [986, 986, 1007, 1007, 1056], [1058, 1058, 1080, 1080, 1120], [1122, 1122, 1150, 1150, 1202], [1204, 1204, 1245, 1245, 3617], [3618, 3654, 3711, 3761, 4826]]}
{"id": "wtdGWl", "name": "Tree Tutorial", "author": "specialsaucewc", "description": "Making trees and parallax", "tags": ["tutorial", "parallax", "trees", "snow", "winter", "boxcutting"], "likes": 6, "viewed": 337, "published": "Public API", "date": "1577998162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\n#define LAYER_COUNT 10.\n#define MOON_SIZE .15\n#define TREE_COL vec3(.8, .8, 1.)\n#define ORBIT_SPEED .025\n#define SCROLL_SPEED .3\n#define ROT -0.785398\n#define ZOOM .4\n#define STAR_SPEED .25\n\nfloat N11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat N21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\n\nfloat DrawLine(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.00125, .000001, d);\n    float d2 = length(a-b);\n    m *= S(1., .5, d2) + S(.04, .03, abs(d2-.75));\n    return m;\n}\n\nfloat ShootingStar(vec2 uv) {    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float h = N21(id);\n    \n    float line = DrawLine(gv, vec2(0., h), vec2(.1, h));\n    float trail = S(.12, .0, gv.x);\n\t\n    return line * trail;\n}\n\nfloat LayerShootingStars(vec2 uv) {\n    float t = iTime * STAR_SPEED;\n    vec2 rv1 = vec2(uv.x - t, uv.y + t);\n    rv1.x *= 1.05;\n    \n    float r = 3. * ROT;\n    float s = sin(r);\n    float c = cos(r);\n    mat2 rot = mat2(c, -s, s, c);\n    rv1 *= rot;\n    rv1 *= ZOOM * .9;\n    \n    vec2 rv2 = uv + t * 1.2;\n    rv2.x *= 1.05;\n    \n    r = ROT;\n    s = sin(r);\n    c = cos(r);\n    rot = mat2(c, -s, s, c);\n    rv2 *= rot;\n    rv2 *= ZOOM * 1.1;\n    \n    float star1 = ShootingStar(rv1);\n    float star2 = ShootingStar(rv2);\n    return clamp(0., 1., star1 + star2);\n}\n\nfloat GetHeight(float x) {\n    return sin(x*.412213)+sin(x)*.512347;\n}\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n    //bottom edge\n    float m = S(-blur, blur, p.y - yb);\n    //top edge\n    m *= S(blur, -blur, p.y - yt);\n    //mirror x to get both edges\n    p.x = abs(p.x);\n    //side edges\n    // 0 p.y = yb 1 p.y = yt\n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= S(blur, -blur, p.x - w);\n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur) {\n    float m = TaperBox(uv, .03, .03, -.05, .25, blur); //trunk\n    m += TaperBox(uv, .2, .1, .25, .5, blur); //canopy 1\n    m += TaperBox(uv, .15, .05, .5, .75, blur); //canopy 2\n    m += TaperBox(uv, .1, .0, .75, 1., blur); //top\n    \n    blur *= 3.;\n    float shadow = TaperBox(uv-vec2(.2,0.), .1, .5, .15, .253, blur);\n    shadow += TaperBox(uv+vec2(.25,0.), .1, .5, .45, .503, blur);\n    shadow += TaperBox(uv-vec2(.25,0.), .1, .5, .7, .753, blur);\n    col -= shadow*.8;\n    \n    return vec4(col, m);\n}\n\nvec4 Layer(vec2 uv, float blur) {\n    vec4 col = vec4(0);\n    float id = floor(uv.x);\n    \n    //random [-1, 1]\n    float n = N11(id)*2.-1.;\n    float x = n*.3;\n    float y = GetHeight(uv.x);\n    \n    //ground\n    float ground = S(blur, -blur, uv.y-y);\n    col += ground;\n    \n    y = GetHeight(id + .5 - x);\n    \n    //vertical grid\n    uv.x = fract(uv.x)-.5;\n    //\t\t\t\t\t offset\t\tscale tree size\t\tcolor\n    vec4 tree = Tree((uv+vec2(x,-y))*vec2(1, 1.+n*.2), vec3(1), blur);\n    \n    col = mix(col, tree, tree.a);\n    col.a = max(ground, tree.a);\n    return col;\n}\n\nvec2 MoonPos() {\n    float t = iTime * ORBIT_SPEED;\n    return vec2(sin(t), cos(t))/2.;\n}\n\nvec4 MoonGlow(vec2 uv) {\n    vec2 moonPos = MoonPos();\n    float md = length(uv-(moonPos - vec2(.07, 0.01)));\n    float moon = S(.1, -.01, md-MOON_SIZE*8.);\n    moon = mix(0., moon, clamp((moonPos.y + .2)*3., 0., 1.));\n    \n    vec4 col = vec4(moon);\n    md = clamp(1.-md, 0., 1.);\n    md *= md;\n    col.rgb *= md;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    float t = iTime * SCROLL_SPEED;\n    float blur = .005;\n    \n    float twinkle = dot(length(sin(uv+t)), length(cos(uv*vec2(22., 6.7)-t*3.)));\n    twinkle = sin(twinkle*5.)*.5+.5;\n    float stars = pow(N21(uv*1000.), 1024.)*twinkle;\n    vec4 col = vec4(stars);\n    \n    vec2 moonPos = MoonPos();\n    float moon = S(.01, -.01, length(uv-moonPos)-MOON_SIZE);\n    col *= 1.-moon;\n    moon *= S(-.01, .05, length(uv-(moonPos+vec2(.1,.05)))-MOON_SIZE);\n    col += moon;\n    \n    col += LayerShootingStars(uv);\n    \n    vec4 layer;\n    for (float i=0.; i <1.; i+=1./LAYER_COUNT) {\n        float scale = mix(30., 1., i);\n        blur = mix(.05, .005, i);\n        layer = Layer(uv*scale+vec2(t+i*100.,i)-M, blur);\n        layer.rgb *= (1.-i) * TREE_COL;\n        col = mix(col, layer, layer.a);\n    }\n    col += MoonGlow(uv);\n    \n    layer = Layer(uv+vec2(t,1.)-M, .07);\n    col = mix(col, layer*.05, layer.a);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 248, 248, 333], [335, 335, 354, 354, 471], [473, 473, 513, 513, 638], [641, 641, 681, 681, 846], [848, 848, 877, 877, 1089], [1091, 1091, 1126, 1126, 1658], [1660, 1660, 1686, 1686, 1730], [1732, 1732, 1808, 1826, 2116], [2118, 2118, 2160, 2160, 2667], [2669, 2669, 2702, 2702, 3233], [3235, 3235, 3251, 3251, 3324], [3326, 3326, 3350, 3350, 3658], [3660, 3660, 3717, 3717, 4758]]}
{"id": "wtdSR8", "name": "Parallax view on Cineshader", "author": "edankwan", "description": "It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though. [url]https://cineshader.com/view/wtdSR8[/url]", "tags": ["cineshader"], "likes": 13, "viewed": 90246, "published": "Public API", "date": "1580405870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat map(vec3 p)\n{\n    p.z += 5.0;\n    p = opRep(p, vec3(4.0), vec3(1.0));\n    return sdBox(p, vec3(1.0));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Parallax view on Cineshader\",\n\t\"description\": \"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [120, 120, 166, 166, 207], [209, 209, 228, 228, 318], [320, 320, 350, 350, 632], [634, 634, 691, 691, 2038]]}
{"id": "wtdXR8", "name": "Simple mountains", "author": "Dijkstra", "description": "First attempt at creating mountains\n\nDepending on your graphic card it seems to be more or less broken... weird...", "tags": ["raymarching", "noise"], "likes": 1, "viewed": 85, "published": "Public", "date": "1580408504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand21(vec2 uv){\n \treturn fract(sin(uv.x*12165431.+uv.y*452654.)*94121.);\n}\n\nfloat smoothnoise(vec2 uv, float size){\n    vec2 lv = smoothstep(0.,1., fract(uv*size));\n    vec2 id = floor(uv*size);\n    \n    float bl = rand21(id + vec2(0.,0.));\n    float br = rand21(id + vec2(1.,0.));\n    float tl = rand21(id + vec2(0.,1.));\n    float tr = rand21(id + vec2(1.,1.));\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float c = mix(b, t, lv.y);\n    \n    return c;\n}\n\nfloat smoothMore(vec2 uv, float size){\n    float total = smoothnoise(uv, size);\n    total += smoothnoise(uv, size*2.)/4.;\n    total += smoothnoise(uv, size*4.)/8.;\n    total += smoothnoise(uv, size*8.)/16.;\n    total += smoothnoise(uv, size*16.)/32.;\n \treturn total;\n}\n\nvec4 sphere(vec3 p, vec3 spherePosition, float radius){\n\treturn vec4(length(abs(p-spherePosition)) - radius, 1.,1.,.6);\n}\n\nvec4 ground(vec3 p){\n    float offset = smoothMore(vec2(p.x,p.z), .5)*1.5;\n    float cursor = p.y+1.5;\n\treturn vec4(p.y+2. - offset, \n                mix(.44, 1., cursor), \t\t//r\n                mix(.35, 1., cursor), \t\t//g\n                mix(.25, 1., cursor));\t\t//b\n}\n\nvec4 scene(vec3 p){\n    vec4 d1 = sphere(p, vec3(25., 8., 20. + iTime), 1.);\n    vec4 d2 = ground(p);\n    if(d1.x < d2.x)\n        return d1;\n    return d2;\n}\n\nconst float EPSILON = 0.0001;\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)).x - scene(vec3(p.x - EPSILON, p.y, p.z)).x,\n        scene(vec3(p.x, p.y + EPSILON, p.z)).x - scene(vec3(p.x, p.y - EPSILON, p.z)).x,\n        scene(vec3(p.x, p.y, p.z  + EPSILON)).x - scene(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat getLight(vec3 p){\n \tvec3 lightPos = vec3(22., 10.,iTime+3.);\n    vec3 ld = normalize(lightPos-p);\n    vec3 n = estimateNormal(p);\n    \n    float dif = dot(n,ld);\n    return dif;\n}\n\nfloat glowing(vec3 p){\n \t return sphere(p, vec3(25., 8., 20. + iTime), 1.).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= (iResolution.x/iResolution.y);\n\n    \n    vec3 ro = vec3(15.,0.,-3.+iTime);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 rp = ro;\n   \tvec3 col = vec3(.3,.4,.98);\n    float i = 0.;\n    for(i=0.; i<100.; ++i){\n    \tfloat dist = scene(rp).x;\n        rp += rd * dist;\n        if(dist < .01){\n            col = scene(rp).yzw;\n            col *= vec3(getLight(rp));\n        \tbreak;\n        }\n        if(dist>100.) break;\n    }\n    \n    \n    rp = ro;\n    for(i=0.; i<100.; ++i){\n    \tfloat dist = glowing(rp);\n        rp += rd * dist;\n        if(dist < 1.){\n            col += vec3(.03);\n        }\n        if(dist>100.) break;\n    }\n    \n\n\n    // Output to screen\n    //fragColor = vec4(vec3(smoothMore(uv, 11.)),1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 81], [83, 83, 122, 122, 488], [490, 490, 528, 528, 758], [760, 760, 815, 815, 881], [883, 883, 903, 903, 1150], [1152, 1152, 1171, 1171, 1309], [1342, 1342, 1371, 1371, 1675], [1677, 1677, 1700, 1700, 1862], [1864, 1864, 1886, 1886, 1943], [1945, 1945, 2002, 2052, 2862]]}
{"id": "wtdXRr", "name": "Day 41", "author": "jeyko", "description": "code is messy", "tags": ["mdtmjvm"], "likes": 9, "viewed": 285, "published": "Public API", "date": "1580338497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pmod(p,x) mod(p,x) - 0.5*x\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define mx (iTime*0.4 + 20.*iMouse.x/iResolution.y)\n#define my (1.*iMouse.y/iResolution.y)\n\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n// check these out for more beastly stuff\n// https://www.shadertoy.com/view/3dXSDH \n// https://www.shadertoy.com/view/XsKGRW\n\n\nvec3 glow = vec3(0);\n// Noise (from iq)\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n#if 1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel2,(uv+0.5)/256.0,0.0).yx;\n#else\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\n\tvec2 rg = mix(mix(texelFetch(iChannel2,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel2,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel2,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n#endif    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat noiseB (vec3 p) {\n\tvec3 f = fract (p);\n\tp = floor (p);\n\tf = f * f * (3.0 - 2.0 * f);\n\tf.xy += p.xy + p.z * vec2 (37.0, 17.0);\n\tf.xy = texture (iChannel2, (f.xy + 0.5) / 256.0, -256.0).yx;\n\treturn mix (f.x, f.y, f.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\nvec3 guide (vec3 p){\n\treturn vec3(\n    \tsin(p.z*0.5) + sin(p.z*0.3) + cos(p.z*0.3),\n    \tcos(p.z*0.8) + sin(p.z*1.3)*0.5,\n        0.\n    )*1.2;\n}\n#define W 1.\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e4);\n    /*\n    for (int i = 0; i < 3; i++){\n    \tp = abs(p);\n        p.y -= 0.25;\n        p.xy *= rot(0.125*3.14);\n    }*/\n    p.xy -= 4.;\n    vec2 id = floor(p.xy/8.);\n    \n    p.xy = pmod(p.xy, 8.);\n    //p.xy *= 1. - pow(fract(sin(iTime + id.x + p.z)), 1.)*0.1;\n    p.xy += normalize(p.xy)*0.1*(sin(iTime + id.x + p.z));\n    p += guide(p + id.x)*0.4;\n    vec3 t = tex3D(iChannel0,p*0.1, normalize(vec3(p.x,p.y, 0.)));\n    vec3 tB = tex3D(iChannel0,p*0.2+ 1., normalize(vec3(p.x,p.y, 0.)));\n    //t.x = 1. - t.x; \n    //t.x *= 0.4;\n    //t.x = pow(smoothstep(0.,1.5,t.x*3.), 1.)*0.4;\n    \n    t.x *= 0.6;\n    float dPlant = length(p.xy) - W - t.x - tB.x*0.4;\n    \n    \n    //dPlant = max(dPlant, sin(p.z)*0.4 + 0.2);\n    \n    p.z = pmod(p.z, 4.);\n    for (float i = 0.; i < 3.; i++){\n        vec3 q = p;\n        q.z += 4.*i/3.;\n        pmod(q.z, 4.);\n        q.xy *= rot(0.7 + i);\n        q.y -= W;\n        dPlant = opSmoothUnion( dPlant, sdTorus( q, vec2(0.25,0.12) ), 0.2 );\n        //q.z -= exp(-clamp(length(q.xy)*20.,0., 20.)*1.) ;\n        q.z -= clamp(pow(length(q.xy)*0.8,3.),0., 1.) ;\n        d = dmin(d, vec2( (sdRoundCone( q, 0.2, 0.007, 1. )- tB.x*0.15)*0.6, 1.) );\n    }\n    d= dmin(d, vec2(dPlant*0.6, 2.));\n\n    d.x *= 0.5;\n    return d;\n}\n\n\n\nvec2 march(vec3 ro, vec3 rd,inout vec3 p ,inout float t, inout bool hit){\n\t\n\thit = false;\n    t = 0.;\n    vec2 d;\n    p = ro + rd*1.;\n    for(int i = 0; i < 150; i++){\n    \td = map(p);\n        glow += exp(-d.x*5.);\n        if(d.x < 0.001){\n        \thit = true;\n        \tbreak;\n        }\n        if(t > 30.){\n        \tbreak;\n        }\n        t += d.x;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    //ro.z += mx;\n    ro.z += mx;\n    //ro.y += 2.2;\n    //ro.xy -= normalize(guide(ro ).xy)*4.;\n    ro.xy += vec2(\n    \tcos(sin(mx*0.5)*1.14 + 0.3),\n    \tsin(sin(mx*0.5)*1.14 + 0.3)\n    )*4.;\n    vec3 lookAt = vec3(0,0,ro.z + 4. + sin(iTime*0.4)*0.2);\n    lookAt -= guide(lookAt)*1.;\n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float t = 0.;\n    bool hit = false;\n    vec3 p =ro + rd*t;\n    vec3 lightCol = vec3(1.,0.6,0.3)*1.32;\n\n     \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 l = normalize(vec3(1));\n        vec3 h = normalize(l - rd);\n        \n        float diff = max(dot(n, l),0.);\n        float spec = pow(max(dot(n, h),0.), 60.);\n        float fres = pow(1. - max(dot(n,-rd),0.), 5.);\n        \n        if (d.y == 1.){\n        \t//col += diff;\n        \tcol += mix(vec3(diff),fres*lightCol + spec*lightCol, 0.2);\n        \t//col += 2.4;\n        }\n        if (d.y == 2.){    \n            vec3 tex = tex3D(iChannel1,p*0.8, n);\n\t\t\ttex = pow(tex, vec3(0.4 ,0.8,0.5));\n        \tcol += mix(diff*tex, 1.* vec3(spec)*lightCol, 0.7)*2.;\n        }\n        col += 0.08*lightCol;\n        \n        //col += max(dot(n, normalize(vec3(1,-2,-1))),0.)* lightCol*0.09;\n        ///col += 1.;\n        //col += 0.02;\n        \n    } else {\n    \n    }\n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\n    \n    col = max(col, 0.);\n    //col += lightCol*(glow*0.04)*0.7;\n    \n    if (t > 20.){\n    \tp = normalize(ro + rd)*20.;\n    }\n                //col -= vec3(1.,1.9,1.5)*lightCol*(1. -glow*0.05)*0.1;\n\n    float n = noise(p*0.9);\n    vec3 c = col;\n    col.r = c.b;\n    col.b = c.r;\n\n    //col = mix(col,vec3(0.6+ length(p) *0.09,0.24+ n * 0.02,0.08 )*4. , smoothstep(0.,1., clamp(t*0.03 - 0.2, 0., 1.) - n*0.0));\n    col = mix(col,vec3(0.2 - length(p) *0.0002,0.24+ n * 0.02,0.38 )*4. , smoothstep(0.,1., clamp(t*0.03 - 0.2, 0., 1.) - n*0.0));\n    //col = mix(col,pal(0.5, 0.5, vec3(2.5,0.3,0.6), 0.5 , 9. + p.z*0.2 ) , smoothstep(0., 1.,t*0.1));\n    col.b *= 1.2;\n            //col -= vec3(1.,1.9,3.9)*lightCol*(1. -glow*0.05)*0.1;\n    col -= vec3(1.,1.9,3.9)*lightCol*(1. -glow*0.05)*0.03;\n    \n\n    col *= 1. - pow(length(uv)*0.8,1.1)*1.2;\n    col = smoothstep(0.,0.9,col);\n    col *= 1.1;\n    col = pow(col, vec3(0.4545));\n    col.r *= 1.5;\n    col.g *= 1.3;\n    col.b *= 0.9 ;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 419, 445, 445, 1000], [1002, 1002, 1025, 1025, 1226], [1228, 1228, 1280, 1280, 1379], [1381, 1381, 1439, 1439, 1703], [1704, 1704, 1737, 1737, 1802], [1804, 1804, 1854, 1854, 2039], [2041, 2041, 2061, 2061, 2186], [2200, 2200, 2217, 2217, 3491], [3495, 3495, 3568, 3568, 3885], [3887, 3887, 3910, 3910, 4050], [4052, 4052, 4094, 4094, 4277], [4279, 4279, 4336, 4336, 6812]]}
{"id": "wtG3Dc", "name": "Polymorphic Polyhedron", "author": "zovox", "description": "A polymorphic polyhedron.", "tags": ["polyhedron", "polymorphic"], "likes": 5, "viewed": 257, "published": "Public API", "date": "1580063781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define carpet_floor(x) (floor(x)+smoothstep(.9, 1.,(fract(x))))\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n        \n    float d = 1E32;\n\n \tconst float outerCount = 2.0;\n \tconst float innerCount = 2.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    float min_scale = 1./GR;\n    float max_scale = 1.;\n    float scale_steps = 1.;\n    float scalar = 1./PI/GR;\n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        \n        float theta1 = i/outerCount*PI;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            \n            float theta2 = j/innerCount*PI;\n\n            \n            float omega1 = theta1+time;\n            float omega2 = theta2+time*sign(cos(i*PI));\n            \n            /*\n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n                           \n            omega2 += PI/outerCount*2.;\n       \t \tvec3 p2 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            \n            omega2 -= PI/outerCount*2.;\n            omega1 += PI/outerCount*2.;\n       \t \tvec3 p3 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            d = min(d, (sdCapsule(p, p1, p2, .05)));\n            d = min(d, (sdCapsule(p, p1, p3, .05)));\n            */\n            /*\n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n\t\t\t*/\n       \t \tvec3 p3 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            p = rotatePoint(p, vec3(1.,0.,0.), omega1);\n            p = rotatePoint(p, vec3(0.,0.,1.), omega2);;\n            \n            d = min(d, (sdOctahedron((p)-vec3(0.), .15)));\n        }\n    }\n    return d;\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\n\nvec4 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    for(int i = 0; i < 24; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        dist += nearest;\n    }\n    return vec4(computeSurfaceNormal(p+dir*dist), dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 cameraPosition = vec3(sin(iTime), 0.0, cos(iTime));\n\tvec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec4 sum = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4((flux(sum.w*PI*12.)+sum.xyz)/sum.w, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3Dc.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[152, 538, 582, 582, 639], [640, 640, 692, 692, 819], [891, 1043, 1082, 1082, 2981], [2984, 3076, 3110, 3110, 3327], [3331, 3331, 3373, 3373, 3601], [3603, 3603, 3660, 3660, 4466]]}
{"id": "wtG3DD", "name": "checkerboard_1234", "author": "nh_cham", "description": "It's a checkerboard", "tags": ["2d"], "likes": 2, "viewed": 72, "published": "Public", "date": "1578947565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANTI_ALIASING\n#define MOTION_BLUR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sum = 0.0;\n    float i = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n\n#ifdef MOTION_BLUR\n    for (float i = 0.0; i < 8.0; i++)\n#endif\n#ifdef ANTI_ALIASING\n    for (float y = -1.0; y <= 1.0; y++)\n    for (float x = -1.0; x <= 1.0; x++)\n#endif\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = ((fragCoord + vec2(x, y) / 3.0)/ iResolution.xy - vec2(0.5)) * 3.0;\n        uv.x /= iResolution.y / iResolution.x;\n\n        float t = (iTime - iTimeDelta / 8.0 * i) * 0.3;\n        float s = sin(t);\n        float c = cos(t);\n\n        uv.xy = mat2(c, -s, s, c) * uv.xy;\n        float r = sqrt(dot(uv.xy, uv.xy));\n        float phi = atan(uv.y, uv.x);\n        \n        r = pow(r, (sin(t * 5.0) + 2.0));\n        uv.x = r * cos(phi);\n        uv.y = r * sin(phi);\n\n        bool flag = false;\n        float mx = mod(uv.x, 1.0);\n        float my = mod(uv.y, 1.0);\n        \n        if (mx > 0.47 && mx < 0.53)\n          flag = true;\n        if (my > 0.47 && my < 0.53)\n          flag = true;\n        float col = flag ? 1.0 : 0.0;\n        sum += col;\n\n    }\n#ifdef ANTI_ALIASING\n    sum /= 9.0;\n#endif\n#ifdef MOTION_BLUR\n    sum /= 8.0;\n#endif\n    // Output to screen\n    fragColor = vec4(vec3(sum), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 1327]]}
{"id": "WtG3Rc", "name": "Wobbly bw checkerboard", "author": "mescalinum", "description": "blah", "tags": ["checkerboard"], "likes": 1, "viewed": 87, "published": "Public", "date": "1579444219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime, r = length(uv) / sqrt(2.);\n    float pi = 3.14159;\n    float k = 3.;\n    float w = t + 2. * sin(-3. * t + 12. * r);\n    vec2 s = sin(w + 8. * k * pi * uv / (1. + k * r));\n    float v = s.x*s.y;\n    fragColor = vec4(v / fwidth(v));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 377]]}
{"id": "WtG3RD", "name": "The ring [color remix]", "author": "avin", "description": "Color version of https://www.shadertoy.com/view/wtV3R1", "tags": ["circle", "shine"], "likes": 32, "viewed": 1098, "published": "Public API", "date": "1578348087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n#define BLACK_COL vec3(16,21,25)/255.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n        \n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/4.;\n    float l = length(uv);                         \n    \n    float m1 = clamp(.1/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.1/smoothstep(.42, 0., l), 0., 1.);\n    float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*3.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .25)) + 1.5);\n    s3 *= smoothstep(0.0, .3345, l);    \n    \n    float sh = smoothstep(0.15, .35, l);\n    \n    \n    float m = m1*m1*m2 * ((s1*s2*s3) * (1.-l)) * sh;\n    //m = clamp(m, 0., 1.);\n    \n    vec3 col = mix(BLACK_COL, (0.5 + 0.5*cos(iTime+uv.xyx*3.+vec3(0,2,4))), m);\n            \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 274], [276, 276, 305, 305, 969], [971, 971, 1028, 1028, 1948]]}
{"id": "WtG3Rz", "name": "Joey's Thanksgiving Pants", "author": "tb", "description": "I saw this pattern and wanted to recreate it.\n[url]https://google.co.uk/search?q=joey's+thanksgiving+pants&tbm=isch[/url]\n\nThe tricky part was getting a random sequence without any repeated neighbours.\n\nEdit: applied antialiasing from FabriceNeyret2", "tags": ["circle", "pattern"], "likes": 2, "viewed": 100, "published": "Public", "date": "1578063025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// for each 8 rows, randomly select one of the two greyscales\n// the values for odd rows are equal and guaranteed to not be\n// the same as whichever colour is chosen for the even row,\n// therefore there is never a repeated colour\nconst float greyscales[16] = float[16]\n    (1./3., 2./3.,\n     0./3., 0./3.,\n     2./3., 3./3.,\n     1./3., 1./3.,\n     3./3., 0./3.,\n     2./3., 2./3.,\n     0./3., 1./3.,\n     3./3., 3./3.);\n\nconst float scale = 4.0;\nconst float red_chance = 0.3;\n\nvec4 get_row_colour(float row)\n{\n    // assign a random value to the row\n    vec2 rand = hash21(row);\n    // select a greyscale for the row\n    row = mod(row, 8.0);\n    float grey = greyscales[int((row * 2.0) + step(rand.x, 0.5))];\n    // randomly replace odd rows with red\n    float is_red = mod(row, 2.0) * step(rand.y, red_chance);\n    // return row colour\n    return vec4(max(is_red, grey), vec2(min(1.0 - is_red, grey)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalise coordinates\n    vec2 R = iResolution.xy, U = ((scale * fragCoord.xy) - R) / min(R.x, R.y) - 0.5;\n    // get the pixel width\n    float pix = scale / min(R.x, R.y);\n\n    // scroll vertically\n    U.y += iTime;\n\n    // get local coordinates [-0.5, 0.5] and select the top left quadrent\n    vec2 UF = abs(fract(U) - 0.5);\n\n    // add 1.0 if outside the circle\n    float c = smoothstep(-pix, pix, length(UF) - 0.5);\n    // reflect the quadrent along the diagonal from top left to bottom right\n    UF = 0.5 - UF;\n    // add 1.0 if inside the circle\n    c += 1.0 - smoothstep(-pix, pix, length(UF) - 0.5);\n    // negate c in the bottom half\n    c *= sign(fract(U.y) - 0.5);\n    // offset c by 4 for each neighbouring circle\n    c += floor(U.y) * 4.0;\n    // c now indicates which row of 'stars' or 'lenses' we are in\n\n    fragColor = mix(get_row_colour(floor(c)), get_row_colour(ceil(c)), fract(c));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 68, 68, 202], [204, 683, 715, 755, 1116], [1118, 1118, 1173, 1202, 2084]]}
{"id": "wtG3WR", "name": "Shippou", "author": "coposuke", "description": "Training. 七宝.", "tags": ["pattern", "training", "japanese"], "likes": 6, "viewed": 157, "published": "Public", "date": "1578900970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265357989\n\n\nvec2 rotate(vec2 pos, float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c) * pos;\n}\n\nfloat hash(vec2 n)\n{\n    return fract(sin(dot(n, vec2(123.0, 458.0))) * 43758.5453);\n}\n\nfloat cubicInOut(float time) {\n  return (time < 0.5) ? (4.0 * time * time * time) : (1.0 - 4.0 * pow(1.0 - time, 3.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv += vec2(1,-1) * iTime * 0.05;\n    \n    float uvScale = 2.5;\n    vec2 uvID = floor(uv * uvScale);\n    vec2 uvID2 = floor(uv * uvScale + vec2(0.5));\n    vec2 uvLocal = fract(uv * uvScale);\n\n    float time = iTime * 1.0;\n    float timef = cubicInOut(fract(time));\n    float timei = floor(time);\n    time = (timef + timei) * 0.5;\n    \n    // animation 1\n    float rotDir = (0.0 == mod(uvID.y, 2.0) ? 1.0 : -1.0);\n    vec2 rotCenter = vec2(0.5, 0.5);\n    vec2 uvAnim1 = uvLocal;\n    uvAnim1 = rotate(uvAnim1 - rotCenter, time * PI * rotDir);\n    uvAnim1 += rotCenter;\n    \n    // animation 2\n    vec2 uvAnim2 = uvLocal;\n    float uvAnim2Corner = floor(uvLocal.x);\n    uvAnim2 += vec2((0.5 < uvAnim2.x ? -0.5 : 0.5), (0.5 < uvAnim2.y ? -0.5 : 0.5));\n    uvAnim2 = rotate(uvAnim2 - rotCenter, time * PI);\n    uvAnim2 += rotCenter;\n    \n    // animation\n    uvLocal = (fract(time) < 0.5) ? uvAnim1 : uvAnim2;\n    \n    // distance\n    float neighborDist = 1e+4;\n    for(float x=-1.0; x<=1.0; x+=2.0)\n        for(float y=-1.0; y<=1.0; y+=2.0)\n            neighborDist = min(neighborDist, distance(uvLocal, vec2(x,y) * 0.5 + vec2(0.5)));\n    \n    float dist = 1e+4;\n    dist = distance(uvLocal, vec2(0.5));\n    dist = max(dist, neighborDist);\n    \n    // color\n    float smoothness = 0.05;\n    float thickness = 0.03;\n    float center = 0.45;\n    float density = smoothstep(center - thickness, center + thickness, dist);\n    density = smoothstep(1.0, 1.0 - smoothness, density) * (smoothstep(0.0, 0.0 + smoothness, density));\n    \n    float colorID = (fract(time) < 0.5) ? hash(uvID) : hash(uvID2);\n    float colorVariation = 0.3;\n    float colorOffset = -0.7;\n    vec3 color = vec3(0,1,2) * PI * 0.5 + colorID * colorVariation + colorOffset;\n    color = max(sin(color), cos(color)) + 0.4;\n    \n    float colorBgWave = (sin((uv.x - uv.y) * 2.0 + iTime * 3.0) + sin((uv.x - uv.y * 0.5) * 1.5 + iTime)) * 0.5;\n    vec3 colorBg = vec3(1.0, 0.8, 0.5) * mix(0.65, 1.0, colorBgWave);\n    fragColor.rgb = vec3(density) * color * (colorBgWave * 0.75 + 0.25 + (1.0 - colorBgWave) * vec3(0.1, 0.0, 0.0));\n    fragColor.rgb = mix(colorBg, fragColor.rgb, density);\n    fragColor.rgb = clamp(fragColor.rgb * (1.2 + sin(iTime) * 0.1), 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 66, 66, 146], [148, 148, 168, 168, 234], [236, 236, 266, 266, 357], [359, 359, 416, 416, 2732]]}
{"id": "WtG3Ww", "name": "Cycloid", "author": "nurof3n", "description": "A circle tracing its corresponding cycloid", "tags": ["parametric", "cycloid"], "likes": 4, "viewed": 121, "published": "Public", "date": "1579037429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float r = 0.5;\nconst float pi = 3.141592;\n\nvec2 cycloid(float t) {\n\treturn vec2( r*(t - sin(t)), r*(1.0 - cos(t)) );    \n}\n\nfloat disttoline(vec2 a, vec2 b, vec2 p) {\n \treturn abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) \n        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*pi*r * (2.0 * fragCoord - iResolution.xy)/iResolution.x + vec2(pi*r, 0.7);\n\n    float dist = 10.0;\n    float x = iTime * 3.0;\n    float tpos = 4.0*pi*r*sin(x*0.25) + pi;// = mod( (x - 2.0*mod(x, 4.0*pi) * step(4.0*pi, mod(x, 8.0*pi))), 4.0*pi ) - pi;\n    for(float t = -pi; t < tpos; t += 0.01) {\n    \tvec2 point = cycloid(t);\n        dist = min(dist, length(point - uv));\n    }\n    \n    vec2 circle = vec2(r*tpos, r);\n    vec2 finalpoint = cycloid(tpos);\n    float linedist = disttoline( circle, finalpoint, uv );\n    vec3 color = mix(vec3(0.0), mix( vec3(1.0), vec3(0.95, 0.96, 0.73), smoothstep(0.0, -0.01, length(uv-circle)-r) ), smoothstep(0.0, 0.01, abs(length(uv-circle)-r)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(0.01, 0.0, dist));\n    color = mix(color, vec3(0.0), step(length(uv - finalpoint), 0.02));\n    color = mix( color, mix( vec3(0.0), vec3(.8, .5, .51) + pow(0.5, 1.2+7.0*abs(circle.x-uv.x))*pow(0.5, 2.0*(-uv.y)), smoothstep(0.0, 0.01, abs(uv.y + 0.005)) ), step(uv.y, 0.00) );\n    color = mix(color, vec3(0.0), smoothstep(0.01, 0.0, linedist));\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtG3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 72, 72, 128], [130, 130, 172, 172, 342], [344, 344, 401, 401, 1547]]}
{"id": "wtG3zR", "name": "Vaporwave Sun", "author": "jhurliman", "description": "Vaporwave inspired sun", "tags": ["sun", "retro", "vaporwave"], "likes": 3, "viewed": 119, "published": "Public", "date": "1578085283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float STEP_SIZE = 20.0;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float dist = length(uv);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n\n    // Cut into a circle\n    col *= step(dist, 0.5);\n\n    // Cut out horizontal lines\n    float invY = 1.0 - uv.y;\n    col *= step(mod(invY * invY * STEP_SIZE, 2.0), 0.9);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 566]]}
{"id": "wtG3zw", "name": "Joseph Albers, Squares 2", "author": "danamuise", "description": "Inspired by Joseph Albers' Book \"The interaction of Color:  color intervals and transformation interaction of color figure xiv-2\"\nCredit to FabriceNeyret2 for rotation snippet, Beefburrito and CGK_4 v1.1 for polygon functions", "tags": ["colortheory", "josephalbers", "interactionofcolor"], "likes": 2, "viewed": 1212, "published": "Public API", "date": "1578531137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\n//Draw background\nvec3 DrawBox(vec2 uv, float L, float R, float B, float T, vec3 col){\n\tvec3 colorBox = vec3(0.0);\n    \n    if (uv.x>L && uv.x<R && uv.y>B && uv.y<T) {\n       colorBox = vec3(col.r/255.0,col.g/255.0,col.z/255.0);\n    }\n    return colorBox; \n}\n\n//POLYGON FUNCTION\nfloat polygon(vec2 uv, vec2 pos, float size, float blur, int sides){\n    uv = uv-pos;\n    //Angle and radius of polygon\n    float angle = atan(uv.x,uv.y)+PI;\n    float rad = TWO_PI/float(sides);\n    float dist = cos(floor(0.5+angle/rad)*rad-angle)*length(uv);\n    float poly = smoothstep(size, size-blur, dist);\n    \n    return poly;\n}\n\n//spinning function\nmat2 spinspin(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//Draw box\nvec4 DrawRectangle(vec4 try,vec2 uv){\n\n    vec2 translate = vec2(cos(iTime));\n    //uv += translate*0.15;\n    uv = spinspin(sin(iTime))*uv;\n    float rectangle = polygon(uv, vec2(0.0,0.0), 0.45, 0.009, 4);\n    \n    float pct = abs(sin(iTime*.25));\n    \n    vec3 colorA = vec3(0.149,0.141,0.912);\n\tvec3 colorB = vec3(1.000,0.833,0.224);\n    \n    vec3 rColor = mix(colorA, vec3(0.0,0.5,0.0), pct) * rectangle;\n    try = vec4(rColor,1.0);\n    \n    return try;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colorA = vec3(168.0, 48.0, 41.0);\n\tvec3 colorB = vec3(221.0, 64.0, 54.0);\n    vec3 colorC = vec3(221.0, 130.0, 125.0);\n\tvec3 colorD = vec3(221.0, 91.0, 82.0);\n    vec3 colorA1 = vec3(0.0, 110.0, 222.0);\n\tvec3 colorB1 = vec3(0.0, 126.0, 255.0);\n    vec3 colorC1 = vec3(63.0, 158.0, 255.0);\n\tvec3 colorD1 = vec3(107.0, 180.0, 255.0);\n    float pct = abs(sin(iTime*.25));\n    \n    // fill top left\n   vec3 color = DrawBox(uv, 0.0, 0.5, 0.5, 1.0, mix(colorA, colorA1, pct));\n    \n    // fill bottom left\n    color += DrawBox(uv, 0.0, 0.5, 0.0, 0.5, mix(colorB, colorB1, pct));\n\n    // fill top right\n    color += DrawBox(uv, 0.5, 1.0, 0.5, 1.0, mix(colorC, colorC1, pct));\n    \n    // fill bottom right\n    color += DrawBox(uv, 0.5, 1.0, 0.0, 0.5, mix(colorD, colorD1, pct));\n    \n    if (uv.x>0.30 && uv.x<0.7 && uv.y>0.20 && uv.y<0.80) {\n       //color /= rectColor;\n    }\n    \n    uv -= 0.5; // move center\n    uv.x *= iResolution.x/iResolution.y;\n  \n\tfragColor+= DrawRectangle(fragColor, uv);\n    fragColor += vec4(color, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtG3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 130, 198, 198, 370], [372, 391, 459, 459, 726], [728, 748, 776, 776, 862], [864, 875, 912, 912, 1333], [1336, 1336, 1393, 1443, 2527]]}
{"id": "wtGGDc", "name": "Spherical Tangents", "author": "zovox", "description": "Tangents of a sphere rotating around.", "tags": ["spherical", "tangents"], "likes": 6, "viewed": 269, "published": "Public API", "date": "1580063830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//#define iTime (iTime*.1)\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t//vec3 eye = vec3(0.0, 0.0, 3.0);\n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n    fragColor = vec4(0.0);\n    \n \tconst float outerCount = 10.0;\n \tconst float innerCount = 8.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    vec2 xy = vec2(0.);\n    \n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        \n        float theta1 = i/outerCount*4.0*PI+time*PI*i/outerCount;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            float theta2 = theta1+j/innerCount*PI*4.0+time*PI*j/innerCount;\n\n       \t \tvec3 p1 = vec3(cos(theta1)*sin(theta2),\n                           sin(theta1)*sin(theta2),\n                           cos(theta2));\n                           \n       \t \tvec3 p2 = vec3(cos(theta1)*sin(theta2+PI/8.0),\n                           sin(theta1)*sin(theta2+PI/8.0),\n                           cos(theta2+PI/8.0));\n            \n            vec3 ray2 = normalize(p2-p1);\n            \n            float a = dot(ray,ray);\n            float b = dot(ray,ray2);\n            float c = dot(ray2,ray2);\n            float d = dot(ray,eye-p1);\n            float e = dot(eye-p1,ray2);\n            \n            float t1 = (b*e-c*d)/(a*c-b*b);\n            float t2 = (a*e-b*d)/(a*c-b*b);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = .1;\n            \n            float lineLength = 1.5+.5*sin(time);\n            \n            if(t1 > 0.0 && abs(t2) < lineLength && dist < lineWidth)\n            {\n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(0.0, lineLength, abs(t2)));\n                float line = sides*ends;\n                \n                map += line;\n                sum += 1.0;\n            }\n        }\n    }\n    \n\tfragColor = vec4(flux(PI*pow(map/sum, 1.0+.5*sin(-time/GR))+time), 1.0)*clamp(map, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 505, 562, 562, 2830]]}
{"id": "wtGGDR", "name": "Big Brass Balls, Pseudo Kleinian", "author": "onlinerocker", "description": "Credits to knighty for the fractal:\nhttps://github.com/Syntopia/Fragmentarium/blob/master/Fragmentarium-Source/Examples/Knighty%20Collection/PseudoKleinian.frag\n\nHad fun playing with the parameters on this one! :)\n", "tags": ["fractal", "kleinian", "metal", "industrial"], "likes": 12, "viewed": 234, "published": "Public", "date": "1578645049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n//SETTINGS:\n#define VIEW_DIST 65.0\n#define ITERATIONS 7\n#define AA_SCALE 2.0\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//Credits to knighty for discovering this!\nObject map(vec3 p)\n{\n    Object o;\n    o.color = vec3(0);\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;\n    \n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    \n    float it;\n    float len;\n    \n    float minD = 1000.0;\n    vec3 minXYZ = vec3(minD);\n    float angBox = 0.0;\n    \n    vec3 Offset = vec3(0,0,-0.1);\n    \n    \n    p.yz = mat2(cos(PI/2.0), -sin(PI/2.0), sin(PI/2.0), cos(PI/2.0))*p.yz;\n    p.y = -1.+mod(p.y, 4.0);\n    p.x = -3.0 + mod(p.x, 13.5);\n\n    vec3 or = p;\n    vec3 ap = p + 1.0;\n    vec3 CSize = vec3(1.,1,1.3);\n    //vec3 CSize = vec3(4.4,2.0,0.5);\n    //vec3 CSize = vec3(2.0,1.0,0.3);\n    float Size = 1.;\n    float DEoffset = 0.;\n    float DEfactor = 1.5;\n    vec3 C = vec3(-0.62,-0.015,-0.025);\n    //vec3 C = vec3(-0.8,0.1,0.2);\n    //vec3 C = vec3(-0.04,0.14,-0.5);\n    vec4 orbitTrap = vec4(1000);\n    \n    for(int i=0; i < ITERATIONS; i++){\n\t\tif(ap == p) break;\n        ap=p;\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n      \n\t\tfloat r2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p,r2)));\n\t\tfloat k=max(Size/r2,1.);\n\t\tp*=k;DEfactor*=k;\n      \n\t\tp+=C;\n        orbitTrap = min(orbitTrap, abs(vec4(p,dot(p,p))));\n        minD = min(minD, length(p-or));\n        minXYZ = min(minXYZ, abs(p - or));\n\t}\n    \n    float dist = abs(0.5*abs(p.z-Offset.z)/DEfactor-DEoffset);\n\n    if(dist < o.dist){\n    \to.dist = dist;\n        o.specVal = 10.0;\n        o.specKs = 0.5;\n        //o.color = vec3(.1, .533, .631)*orbitTrap.x + vec3(0.0,0.3,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;\n        o.color = vec3(.718, .533, .431)*orbitTrap.x + vec3(0.2,0.1,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;\n    \t//o.color = mix(vec3(0.6, 0.4, 0.2), vec3(0.1)*0.4, fbm(pos*500.0));\n    }    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.05 - exp( -distance*0.15 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), \n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<250; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed;\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    float val = clamp(dot(o.normal, dir), 0.0, 30.0);\n    float oVal = val;\n\n    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   \n    return col;\n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    for(float x=0.0; x<AA_SCALE; x++){\n    for(float y=0.0; y<AA_SCALE; y++){\n        \n    vec2 aaOffset = vec2(x,y);\n    vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(4.0,-5.0,2.0-0.6*iTime);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float rate = 8.0;\n    float camAng = PI/5.0;\n    float camAngPos = camAng;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    dir.xz = rotCam * dir.xz;\n    \n    Light light;\n    light.intensity = 2.0;\n    light.pos = vec3(22, -0.3, 50);\n    light.color = vec3(1);    \n   \n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.2);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    vec3 tempCol = vec3(0);\n    if(res.totalDist < VIEW_DIST)\n    {\n        tempCol = res.obj.color;\n        tempCol = calcDiffuseLight(res.obj, light, pos);\n        tempCol += calcSpecLight(res.obj, light, pos, camEye);\n    }else{\n        tempCol = applyFog(4.0*tempCol, res.totalDist, pos, light.pos);\n    \tcol += tempCol;\n        done = 1.0;\n     \tbreak;   \n    }\n    tempCol = applyFog(tempCol, res.totalDist, pos, light.pos);\n    col += tempCol;\n\n    }\n        if(done > 0.0)\n            break;\n    }\n    \n    fragColor = vec4(col/(AA_SCALE*AA_SCALE),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 460, 480, 480, 2174], [2176, 2176, 2213, 2213, 2506], [2508, 2513, 2758, 2758, 3065], [3071, 3071, 3123, 3123, 3769], [3771, 3771, 3823, 3823, 4027], [4029, 4029, 4091, 4091, 4393], [4395, 4395, 4452, 4452, 5916]]}
{"id": "wtGGzy", "name": "Biohazard_Honotfile", "author": "Honorfil", "description": "biohazard v2", "tags": ["raymarch"], "likes": 1, "viewed": 84, "published": "Public", "date": "1579204249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n#define PI 3.1415\n\nmat2 GetRot2d(float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat GetCylinder(vec3 p, vec3 top, vec3 bottom, float radius)\n{\n    vec3 ab = bottom - top;\n    vec3 ap = p - top;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = top + t * ab;\n\n    float x = length(p - c) - radius;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float exterior = length(max(vec2(x, y), 0.));\n    float interior = min(max(x, y), 0.);\n    \n    return exterior + interior;\n}\n\nfloat GetMoon(vec3 p)\n{\n    float cyl1 = GetCylinder(p, vec3(0,0,0), vec3(0,.3,0), 2.);\n    float cyl2 = GetCylinder(p, vec3(0,-1,0.4), vec3(0,2,0.4), 1.7);\n    \n    return max(cyl1, -cyl2);\n}\n\nfloat GetMainShape(vec3 p)\n{\n    vec3 p1 = p;\n    p1.z -= 0.5;\n    float m1 = GetMoon(p1);\n    \n    vec3 p2 = p;\n    p2.xz *= GetRot2d(2. * PI / 3.);\n    p2.xz -= vec2(1.4, 2.76);\n    float m2 = GetMoon(p2);\n    \n    vec3 p3 = p;\n    p3.xz *= GetRot2d(-2. * PI / 3.);\n    p3.xz -= vec2(-1.4, 2.76);\n    float m3 = GetMoon(p3);\n    \n    return min(m3, min(m1, m2));\n}\n\nfloat GetDecor(vec3 p)\n{\n    float outer = GetCylinder(p, vec3(0,0,0), vec3(0,.3,0), 4.2);\n    float inner = GetCylinder(p, vec3(0,-1.,0), vec3(0,1,0), 4.05);\n    float circle = max(outer, -inner);\n    \n    float middleTip = GetCylinder(p, vec3(0,0,0), vec3(0,.3,0), 0.5);\n    \n    return min(circle, middleTip);\n}\n\nfloat GetDist(vec3 p)\n{\n    p.yx *= GetRot2d(iTime);\n    \n    vec3 p1 = p;\n    p1.z -= -1.5;\n    float middleHole = GetCylinder(p1, vec3(0,-1,0), vec3(0,1,0), 1.0);\n    float decor = GetDecor(p1);\n\tfloat result = max(-middleHole, GetMainShape(p));\n    \n    return min(decor, result);\n}\n\nvec3 GetNormal(vec3 p)\n{   \n    float d = GetDist(p);\n    vec2 e = vec2(0.01, .0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p - e.xyy),\n    \tGetDist(p - e.yxy),\n    \tGetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float surfDist)\n{\n    float d0 = 0.;\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * d0;\n            float ds = abs(GetDist(p));\n            d0 += ds;\n            if (abs(d0) > MAX_DIST || ds < surfDist)\n            {\n                break;\n            }\n        }\n    \n    return min(d0, MAX_DIST);\n}\n\nfloat GetGlow(vec3 ro, vec3 rd, vec3 hitPoint)\n{   \n    float glowValue = 0.;\n    float initialDist = length(ro - hitPoint);\n    \n    if (initialDist < 90.)\n    {\n        return 0.0;\n    }\n    \n    for (int i = 0; i < 10; i++)\n    {\n        glowValue += 1. - (RayMarch(ro, rd, 1.2 * float(i) * SURF_DIST) - initialDist);\n    }\n    \n    return glowValue * 0.002;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(-13., 15, 0);\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n, l)*.5+.5, 0., 1.);\n\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 10, -1.5);\n    vec3 rd = normalize (vec3(uv.x, uv.y, 1));\n    rd.yz *= GetRot2d(PI / 2.);\n\n    float d = RayMarch(ro, rd, SURF_DIST);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    vec3 col = vec3(.5, 1, .5);\n    vec3 glow = GetGlow(ro, rd, p)* vec3(.4, 1, .65);\n    \n    fragColor = vec4(vec3(dif) * col + glow, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 114, 114, 203], [205, 205, 269, 269, 614], [616, 616, 639, 639, 808], [810, 810, 838, 838, 1176], [1178, 1178, 1202, 1202, 1492], [1494, 1494, 1517, 1517, 1779], [1781, 1781, 1805, 1805, 1999], [2001, 2001, 2051, 2051, 2372], [2374, 2374, 2422, 2422, 2737], [2739, 2739, 2763, 2763, 2946], [2948, 2948, 3005, 3005, 3422]]}
{"id": "WtK3D3", "name": "Plates Fractal", "author": "zovox", "description": "Plates,Fractal", "tags": ["fractal", "plates"], "likes": 18, "viewed": 537, "published": "Public API", "date": "1580065688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__))*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float height = max(lowAverage(), last_height)-1.0/30.0;\n    float beat = clip(height);\n    float scale = exp(sin(time))*PI;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    uv += cos(vec2(time, time/GR))/PI/E;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 5;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n        border *= GUASS(antispeckle);\n        \n\n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i > 0)\n        {\n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n            border_color += (border+float(i))*GUASS(antispeckle);\n\n        \tborder *= GUASS(antispeckle);\n        }\n    }\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, .5/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 1109, 1131, 1131, 1305], [1307, 1307, 1336, 1336, 1406], [1408, 1408, 1437, 1437, 1521], [1523, 1523, 1591, 1591, 1674], [1676, 1676, 1702, 1702, 1909], [1911, 1911, 1977, 1977, 2585], [2586, 2586, 2658, 2658, 2709], [2711, 2711, 2823, 2823, 3561], [3562, 3562, 3585, 3585, 3688], [3690, 3690, 3710, 3710, 4088], [4116, 4116, 4173, 4173, 7261]]}
{"id": "WtK3Dh", "name": "Night Forest", "author": "yasuo", "description": "generative forest", "tags": ["forest"], "likes": 3, "viewed": 241, "published": "Public API", "date": "1578832532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    //float k = hash(uint(i));\n  \t//float k = 0.5+0.5*sin(i);\n  \tfloat k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nfloat hash(in vec3 x) { return fract(sin(dot(x, vec3(12.9898, 78.233, 49.256)))*43237.5324); }\n\nvec4 tree(vec3 q, float y) {\n    float tree = sdBox(q-vec3(0.0,1.0+y,0.0),vec3(0.2,2.0,0.2));\n    \n    q.xz *= 0.6;\n    float tree0 = sdPyramid(q-vec3(0.0,1.8+y,0.0), 3.0);\n    q.xz *= 1.2;\n    float tree1 = sdPyramid(q-vec3(0.0,3.1+y,0.0), 2.0);\n    tree = min(tree,min(tree0,tree1));\n    vec4 res = vec4(vec3(0.8),tree);\n    return res;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = -0.5;\n    float t = iTime*2.0;\n    \n    // ground\n    p.x +=t;\n    p += bnoise( p.x*0.1)+bnoise( p.z*0.1);\n    _floor = p.y;\n    vec4 resF = vec4(vec3(0.7),_floor*0.9);\n    \n    // tree\n    p = prevP;\n    p.x += t;\n    \n    vec3 q = p;\n    \n    vec3 c = vec3(20., 0., 5.0);\n    vec3 id = floor(p / c) * vec3(1.0,0.0,1.0);\n\tvec4 q2 = vec4(mod(p, c) - 0.5*c, hash(id));\n    float h = 1.0-q2.w*3.0;\n    q.y -= (h<-0.5)?0.1:h;\n    q = vec3(q2.x, q.y, q2.z);\n    q.x -= 3.0*(q2.w*2.0-1.0);\n    \n    vec4 resTree = tree(q,y);\n    \n    vec4 model = combine(resTree,resF);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(-20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n        float fullmoon = smoothstep(0.02,-0.02,length(uv-vec2(.6,.35))-0.08);\n        col *= fullmoon;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Dh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 535, 576, 576, 667], [669, 669, 705, 705, 747], [749, 749, 778, 778, 862], [864, 864, 899, 899, 1384], [1386, 1427, 1455, 1472, 1801], [1803, 1803, 1826, 1826, 1897], [1899, 1899, 1927, 1927, 2239], [2241, 2241, 2263, 2263, 2912], [2914, 2914, 2947, 2947, 3200], [3202, 3202, 3226, 3226, 3427], [3429, 3429, 3463, 3463, 3777], [3779, 3779, 3822, 3822, 4125], [4127, 4127, 4150, 4150, 4551], [4553, 4553, 4595, 4595, 4790], [4792, 4792, 4849, 4849, 5633]]}
{"id": "WtK3Rc", "name": "Sphere Chaser", "author": "kstyler", "description": "Chasing a sphere down a road.", "tags": ["raymarch", "sphere", "chase"], "likes": 4, "viewed": 178, "published": "Public API", "date": "1579499410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define MAX_DST 150\n#define EPSI 0.001\nint mat = 0;\nfloat random(vec2 p){\n    return(fract(sin(p.x*431.+p.y*707.)*7443.));\n}\nfloat noise(vec2 uv){\n     vec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv,int octs){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<octs+1;i++){\n        f+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat sphere(vec3 p){\n    float r = 1.;\n    r*=1.-(sin(p.y*20.+time*22.)*0.001)*20.;\n    r*=1.-(cos(p.x*10.+time*22.)*0.001)*50.;\n\n    return length(p)-r;\n}\n\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p){\n    float sph = sphere(p+vec3(-10.,-6.5,-3.-time*62.));\n    float plane = p.y+8.+octaves((p.xz/30.)+(time/10.)+sin(length(p.xz*2.))*.04,10);\n    float c = 20.;\n    float c2 = 8.;\n    p.x+=sin(p.z*0.2);\n    p.x=mod(p.x+c*.5,c)-c*.5;\n    p.z=mod(p.z+c2*.5,c2)-c2*.5;\n \n    return  min(min(sph,min(sdBox(p,vec3(0.5,4.0,1)),sdBox(p+vec3(0,-4.5,0),vec3(1.5,0.5,4)))),plane);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(10,7,-5);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.yz*=rotate(.3);\n    rd.yz*=rotate(.3);\n   \n    ro.z+=time*62.;\n    ro.x+=sin(time)*4.;\n    ro.y+=cos(time)*2.;\n  \n    float tot = 0.;\n    float dst = 0.;\n    float shad = 0.;\n    vec3 p = vec3(0.) ;\n    mat = 0;\n    for(int i =0;i<MAX_DST;i++){\n        p = ro+rd*tot;\n        dst = map(p);\n        tot+=dst;    \n        if(dst<EPSI){\n            shad = float(i)/float(MAX_DST);\n            break;\n        }\n    }\n    if(dst>EPSI){\n        mat = 1;\n    }\n  \n  \n    col= vec3(shad);\n    uv.y*=5.;\n    if(mat == 1)col =vec3(octaves(uv/10.,8)/1.6)+vec3(.5);\n    col = mix(col,vec3(0.),1.-exp(-0.4*shad));//fog\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 92, 92, 143], [144, 144, 165, 165, 509], [511, 511, 543, 543, 697], [698, 698, 719, 719, 785], [787, 787, 808, 808, 943], [946, 946, 976, 976, 1063], [1065, 1065, 1083, 1083, 1455], [1458, 1458, 1514, 1514, 2317]]}
{"id": "WtK3RG", "name": "Engrane-columna-1ero", "author": "jorge2017a1", "description": "Engrane-columna-1ero", "tags": ["engranecolumna1ero"], "likes": 1, "viewed": 83, "published": "Public", "date": "1579210679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n        \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            res=vec2(res.x, 5);\n             \n         } \n     }\n    \n   \n \t///inicio de engranes o columna\n   \n    float num;\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n    \n    \n    \n    num =10.0;\n    Incgrados=360./num;\n    Incgrados=Incgrados*PI/180.0;\n    \n    \n\n    vec3 pr =rotate_y(p, iTime);\n   \n    \n    for(float ii=0.0; ii<num; ii++) \n\t{\n        \n        \trx=3.0*cos(gr);\n        \try=3.0*sin(gr);\n                \n        \tfloat sd1=sdCylinder( pr-vec3(rx, -0.5, ry ), vec2(0.5,4.0) );\n        \tsdfintdo = min(sdfintdo,sd1);\n     \t\n        \n        gr=gr+Incgrados;\n    }\n    \n    \n    \n    \n    float sd1g =sdCylinder( p-vec3(0, 0.0, 0 ), vec2(3.0,3.0) ); \n    float sd1ch=sdCylinder( p-vec3(0, 0.0, 0 ), vec2(0.5,4.0) );\n    \n    float dif1g=differenceSDF(  sd1g,sdfintdo); \n    dif1g=differenceSDF(dif1g,sd1ch); \n    \n    \n    res =opU(res, vec2(dif1g,8));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n     case 15:\n     \t\t/*\n         \t\tvec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V, plane.color)*intensity; //地板色\n      \t\t*/\n        case 16:\n        \tvec3 p,rd,ro;\n        \tfloat dist;\n        \t\t\n        \t\tro= mObj.ro;\n                rd= mObj.rd;\n                dist =mObj.dist;\n        \t\t//dist =0.001;\n        \n        \t\tp =ro+rd*dist;\n                \n          \t\tvec3 sn =GetNormal(p);\n     \t\t\t// SECOND PASS - REFLECTED RAY\n    \t\t\tvec3 rdrf = reflect(-rd, sn);\n        \t\t//vec3 prf = (ro + rdrf * d); \n        \t\tvec3 prf = (ro + rdrf * dist); \n    \t\t\t//vec3 prf = (ro + rdrf * 0.01); \n    \t\t\tfloat difrf = GetLight(prf);\n        \t\treturn difrf*vec3(1.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,4.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1522, 1576, 1598, 1598, 2858], [2861, 2925, 2961, 2961, 3234], [3236, 3286, 3332, 3332, 3364], [3366, 3366, 3408, 3408, 3440], [3442, 3442, 3489, 3489, 3522], [3525, 3525, 3554, 3554, 3680], [3682, 3682, 3718, 3718, 3835], [3837, 3837, 3873, 3873, 3991], [4043, 4055, 4077, 4077, 4385], [4386, 4412, 4437, 4437, 4627], [4628, 4673, 4690, 4690, 4763], [4766, 4799, 4825, 4825, 5022], [5023, 5069, 5121, 5121, 5276], [5341, 5450, 5487, 5487, 5522], [5524, 5524, 5543, 5543, 5618], [5624, 5624, 5649, 5649, 7081], [7084, 7084, 7118, 7118, 7495], [7500, 7500, 7524, 7524, 7756], [7760, 7760, 7784, 7784, 8169], [8172, 8172, 8198, 8198, 8562], [8565, 8565, 8590, 8590, 8618], [8620, 8620, 8672, 8672, 9068], [9171, 9215, 9232, 9232, 9303], [9328, 9420, 9445, 9445, 9708], [9710, 9769, 9797, 9797, 12556], [12560, 12560, 12617, 12617, 14027]]}
{"id": "wtK3Rz", "name": "The Second After Midnight", "author": "angelo12", "description": "First in my weekly shader series for 2020. Let's see where this takes us! ", "tags": ["time", "clock", "challenge", "weekly"], "likes": 2, "viewed": 273, "published": "Public API", "date": "1578178574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Sunday Shader: 1/52 \"The second after Midnight\"\n    New years resolution: make a shader every week & upload them on Sunday.\n    Yeah this one is pretty simple but you gotta start somewhere.\n    Suggestions, feedback & help is always welcome :D\n\n\tAngel Ortiz\n*/\n\n#define INV_GAMMA 0.454545\n#define AA 4\n#define M_PI 3.1415926535\n\n#define CLOCKFACE_ID 1.0f\n#define CLOCKFACE_RADIUS 0.35f\n\n#define BOX_ID 2.0f\n#define BOX_SIZE vec2(0.0025, 0.17)\n\n#define ONETOZERO(num) (num + 1.0f) / 2.0f\n#define DEBUGCOL vec3(1.0, 0.0,1.0)\n\n/*Game Plan:\n    Todo\n\n    In progress\n\n    Done\n    - [x] Draw clock face\n    - [x] Mark the 12 hours \n    - [x] Background\n    - [x] Clock hands\n    - [x] Moving the clock hands\n\n    Maybe next time\n    [ ] Draw Roman Numerals\n    [ ] Fireworks from behind the clock\n    [ ] Buildings w/ lights\n    [ ] Hand strikes twelve\n*/\n\nfloat\nsdCircle(vec2 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat\nsdBox(vec2 pos, vec2 sizes)\n{\n    return length(max(abs(pos) - sizes, vec2(0.0)));\n}\n\nfloat\nMap(vec2 uv) \n{\n    float res = -1.0;\n\n    vec2 trans = vec2(0.0, -0.12);\n    vec2 bigHand = uv - vec2(0.0, 0.12) - trans;\n    float a = M_PI* (-iTime / 60.0);\n    mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    bigHand = bigHand * (rot) + trans  ;\n\n    trans = vec2(0.0, -0.09);\n    vec2 littleHand = uv - vec2(0.0, 0.09) - trans;\n    a = M_PI* (-iTime / (60.0 * 60.0));\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    littleHand = littleHand * (rot) + trans;\n\n    //If you're inside the sdf, return it's ID\n    res = (sdCircle(uv - vec2(0.0, 0.0), CLOCKFACE_RADIUS) <= 0.0) ? CLOCKFACE_ID : res;  \n    res = (sdBox(bigHand, BOX_SIZE) <= 0.0) ? BOX_ID : res;  \n    res = (sdBox(littleHand, vec2(0.0025, 0.12)) <= 0.0) ? BOX_ID : res;  \n    res = (sdCircle(uv - vec2(0.0, 0.0), 0.01) <= 0.0) ? 3.0f : res;  \n\n    return res;\n}\n\nvec3\nShading(vec2 uv, float id)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n\n    vec3 col;\n    //Default case\n    if (id  == -1.0f)\n    {\n        bool inRadius = r > 0.36 && r < 0.37;\n        bool inAngle = true;\n        bool inCircle = inRadius && inAngle;\n\n        if (inCircle)\n        {\n            col = vec3(0.831, 0.686, 0.216);\n        }\n        else \n        {\n            col = vec3(0.5)* (uv.y + 0.3);\n            col = pow(col, vec3(2.0));\n        }\n\n    }\n\n    if (id == BOX_ID)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n\n    if (id == CLOCKFACE_ID)\n    {\n        col = vec3(1.0, 0.95, 0.85);\n\n\n        //Tick markers\n        {\n            bool inRadius = r > 0.26 && r < 0.325;\n            if (cos(a * 12.0) > 0.97 && inRadius)\n            {\n                col = vec3(0.0);\n            }\n        }\n\n    }\n\n    return col;\n}\n\nvec3\nRender(vec2 uv)\n{\n    //Geometry\n    float id = Map(uv);\n\n    //Shading\n    vec3 col = Shading(uv,id);\n\n    return col;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec3 tot;\n\n    //Supersampling AA\n#if AA > 1\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j)\n    {\n        vec2 offset = vec2(i, j) / float(AA) - 0.5;\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy) / iResolution.y;\n#endif\n\n        //Rendering\n        vec3 col = Render(uv);\n\n        //Gamma correction\n        col = pow(col, vec3(INV_GAMMA));\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[531, 860, 900, 900, 935], [937, 937, 972, 972, 1027], [1029, 1029, 1050, 1050, 1872], [1874, 1874, 1907, 1907, 2733], [2735, 2735, 2757, 2772, 2861], [2863, 2863, 2916, 2916, 3469]]}
{"id": "WtK3W1", "name": "Gamma Verification", "author": "spalmer", "description": "Foundation of everything else!\nCan you notice the circular blob at the center from a meter away or so?\nIf so, your gamma isn't set correctly on your monitor or OS.\nBecause my code is correct.  Well, it's approximately correct enough to get the job done.", "tags": ["gamma"], "likes": 1, "viewed": 53, "published": "Public", "date": "1578838685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n    , uv = p/R\n    , q = (p+p-R)/R.y\n    , s = vec2(0.)\n    ;\n    c.rgb = .5 + .5 * cos(.1*iTime + uv.xyx + vec3(0,2,4));\n    \n    float l = distance(q, s) - .5 // circle    \n    , a = smoothstep(.4, -.4, l)\n    , u = p.x\n  //  * p.y // looks better on my monitor without y; can do either, or both.\n    , check = step(fract(.5*u), .5);\n\n    check = mix(.5, check, a);\n    c.rgb *= check;\n    // obviously gamma is wrong without it.  This is why we test!\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to sRGB gamut\n    c.a = 1.;\n}\n\n//c.rgb = sqrt(c.rgb); // HACK is usually good enough,\n// but since it's an example, may as well do it correctly.\n// or at least more correctly, since actual sRGB is not same as gamma 2.2!\n\n\n// links from https://shadertoy.com/user/aedion\n// See http://iquilezles.org/www/articles/gamma/gamma.htm for basics\n// and this neat video https://youtube.com/watch?v=LKnqECcg6Gw\n// and this cool tutorial https://shadertoy.com/view/lscSzl\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 589]]}
{"id": "wtK3zG", "name": "Aurora curtains", "author": "dolph", "description": ".", "tags": ["aurora"], "likes": 2, "viewed": 189, "published": "Public", "date": "1579266294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nsin(x) (sin(x) * 0.5 + 0.5)\n\nvoid draw_auroras(inout vec4 color, vec2 uv) {\n    const vec4 aurora_color_a = vec4(0.0, 1.2, 0.5, 1.0);\n    const vec4 aurora_color_b = vec4(0.0, 0.4, 0.6, 1.0);\n    \n    float t = nsin(-iTime + uv.x * 100.0) * 0.075 + nsin(iTime + uv.x * distance(uv.x, 0.5) * 100.0) * 0.1 - 0.5;\n    t = 1.0 - smoothstep(uv.y - 4.0, uv.y * 2.0, t);\n    \n    vec4 final_color = mix(aurora_color_a, aurora_color_b, clamp(1.0 - uv.y * t, 0.0, 1.0));\n    final_color += final_color * final_color;\n    color += final_color * t * (t + 0.5) * 0.75;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0, 1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    color = vec4(0.0);\n    \n    draw_auroras(color, uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtK3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 84, 84, 567], [569, 569, 613, 613, 745]]}
{"id": "WtK3zy", "name": "Cardioid animation", "author": "nurof3n", "description": "cardioid", "tags": ["cardioid"], "likes": 7, "viewed": 163, "published": "Public", "date": "1579523012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float r = 0.2;\nconst vec2 h = vec2(0.01, 0.0);\nconst float pi = 3.141592;\n\nfloat disttoline(vec2 a, vec2 b, vec2 p) {\n \treturn abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) \n        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   \n}\n\nfloat sq(float x) {\n\treturn x*x;   \n}\nfloat f(vec2 uv) {\n\treturn sq(dot(uv,uv)) + 4.0*r*uv.x*dot(uv,uv) - 4.0*sq(uv.y)*sq(r);  \n}\nvec2 fparam(float theta) {\n\treturn 2.0*r*(1.0-cos(theta))*vec2(cos(theta), sin(theta));   \n}\nvec2 grad(vec2 uv) {\n\treturn vec2(4.0*uv.x*uv.x*uv.x+4.0*uv.x*sq(uv.y)+12.0*r*sq(uv.x)+4.0*r*sq(uv.y),\n                4.0*uv.y*uv.y*uv.y+4.0*uv.y*sq(uv.x)+8.0*r*uv.x*uv.y-8.0*sq(r)*uv.y);   \n}\n\n#define grad2d(uv, func) (vec2( func(uv+h.xy) - func(uv-h.xy), func(uv+h.yx) - func(uv-h.yx) ) / (2.0*h.x))\n\n#define sdf2d(uv, g, func) ((func(uv)) / length(g))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 g = grad2d(uv, f);\n    float de = sdf2d(uv, g, f);\n    \n    float theta = atan(uv.y, -uv.x) + pi;\n    float thetamax = mod(-iTime, 2.0*pi);\n    vec2 curvepoint = fparam(-thetamax);\n    float factor = step(theta, thetamax);\n    \n    //account for retard gradients\n    de += step(abs(uv.y), 0.017) * step(-0.03, uv.x) * step(uv.x, 0.0);// + mod(floor(theta*pi*50.),2.0);    \n    \n    vec3 color;\n    vec3 bgcolor = vec3(0.9,0.8,0.6) * pow(2.0, -length(uv));\n    color = mix( bgcolor, mix( vec3(0.3, 0.2, 0.4), bgcolor, factor ), smoothstep(0.01, 0.0, abs(de)) );\n    vec2 centre1 = vec2(-r, 0.0);\n    vec2 centre2 = 2.0*r*vec2(cos(iTime), sin(iTime)) - vec2(r, 0.0);\n    color = mix(vec3(0.0, 0.0, 0.0), color, smoothstep(0.0, 0.01, abs(length(uv - centre1) - r)));\n    vec3 color2 = vec3(0.7*sin(iTime), 0.5*cos(iTime), 0.3);\n    color = mix(color2, color, smoothstep(0.0, 0.01, abs(length(uv - centre2) - r)));\n    color = mix(vec3(0.0), color, smoothstep(0.02, 0.03, length(uv - curvepoint)));\n\n    float linedist = disttoline(centre2, curvepoint, uv);\n    color = mix(vec3(0.0), color, smoothstep(0.0, 0.01, linedist) * smoothstep(0.01, 0.02, length(uv - centre2)));\n    \n    color = mix(color, vec3(0.4, 0.07, 0.0), smoothstep(theta, theta-pi, thetamax) \n                \t\t\t* smoothstep(0.0,-0.02,de)\n                \t\t\t* smoothstep(0.0, 0.02, (length(uv - centre1) - r))\n               \t\t\t\t* smoothstep(0.0, 0.01, (length(uv - centre2) - r))); \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 123, 123, 293], [295, 295, 314, 314, 332], [333, 333, 351, 351, 424], [425, 425, 451, 451, 517], [518, 518, 538, 538, 711], [875, 875, 932, 932, 2500]]}
{"id": "WtKGD3", "name": "3D Jack", "author": "zovox", "description": "3D Jack", "tags": ["3d", "jack"], "likes": 1, "viewed": 267, "published": "Public API", "date": "1580063428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0+last_height)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR))*.25+.5))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\nfloat beat = 0.0;\n\nfloat sphere(vec3 rp, vec3 rd, vec3 bp, float r) {\n    \n    vec3 oc = rp - bp;\n    float b = 2.0 * dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return 0.0;\n\n    // compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))/2.0;\n    else\n        q = (-b + sqrt(disc))/2.0;\n\n    float t0 = q;\n    float t1 = c / q;\n\n    // make sure t0 is smaller than t1\n    if (t0 > t1) {\n        // if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    \n    return (t1-t0)/r;\n}\n\n\nfloat line(vec3 rp, vec3 rd, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec3 ray = rd;\n    vec3 ray2 = normalize(b-a);\n\n    float a1 = dot(ray,ray);\n    float b1 = dot(ray,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray,rp-a);\n    float e = dot(rp-a,ray2);\n\n    float t1 = (b1*e-c*d)/(a1*c-b1*b1);\n    float t2 = (a1*e-b1*d)/(a1*c-b1*b1);\n\n    float dist = length((rp+ray*t1)-(a+ray2*t2));\n    \n    float foward = 1.0-abs(t2/length(a-b)*2.0-1.0);\n    return dist > r || t2 < r || t2 > length(a-b)+r? 0.0 : smoothstep(0.0, 1.0/GR, (1.0-dist/r)*foward);\n}\n\nfloat dancer(vec3 p, vec3 rd) {\n    \nfloat t = mod(time,1.0);\nfloat s = sin(time)/PI/GR;\n\nconst vec3 xu = vec3(1.0,0.0, 0.0);\nconst vec3 xd = vec3(-1.0,0.0, 0.0);\n\nconst vec3 yu = vec3(0.0,GR,0.0);\nconst vec3 yd = vec3(0.0,-GR,0.0);\n\nconst vec3 zu = vec3(0.0,0.0,1.0);\nconst vec3 zd = vec3(0.0,0.0,-1.0);\n\n    float d = 0.0;\n\n    float radius = .1;\n\t// outside\n\td += line(p,rd,xu,xd,radius);\n\td += line(p,rd,yu,yd,radius);\n\td += line(p,rd,zu,zd,radius);\n    \n\td += sphere(p,rd,xu,radius);\n\td += sphere(p,rd,xd,radius);\n\td += sphere(p,rd,zu,radius);\n\td += sphere(p,rd,zd,radius);\n\n    return d;\n}\n\nvec4 draw(vec3 ro, vec3 rd, vec2 uv0) {\n    float depth = dancer(ro, rd);\n    \n    float weight = clamp(depth, 0.0, 1.0);;\n    \n    return vec4(flux(depth+time*PI)*weight, weight);//clamp(+(1.0-weight)*sample, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //coordinate system\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = (uv0* 2.0 - 1.0)*vec2(iResolution.x / iResolution.y, 1.0);\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    \n    float t = time;\n    vec3 axis = rormal();//vec3(0.0, 1.0, 0.0);\n    \n    ro = rotatePoint(ro, axis, t);\n    rd = rotatePoint(rd, axis, t);\n    ro *= FAR/PI;\n    \n    fragColor = draw(ro, rd, uv0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 1046, 1096, 1096, 1659], [1662, 1662, 1717, 1717, 2311], [2313, 2313, 2344, 2344, 2908], [2910, 2910, 2949, 2949, 3132], [3135, 3135, 3190, 3219, 3640]]}
{"id": "WtKGDc", "name": "Two-Helix", "author": "timF", "description": "Raymarching", "tags": ["raymarching"], "likes": 3, "viewed": 59, "published": "Public", "date": "1580082058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 30.0\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.0\n#define PI 3.14159265359\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat map(vec3 p){\n    \n    float plane = p.y+2.0; //the floor\n\n    //sphere 2 cuts out sphere 1\n    float the = iTime*.2;\n    float tha = iTime*.5;\n    \n    \n    \n    mat4 rMatrix1 = rotationMatrix(iTime,vec3(0,1,0));\n    mat4 rMatrix2 = rotationMatrix(iTime+3.14,vec3(0,1,0));\n\n    vec4 cyl1P = vec4(0,0,0,0);\n    vec4 cyl2P = vec4(0,0,0,0);\n\n    cyl1P.x += sin(p.y*.5)*2.0;\n    cyl1P.z += cos(p.y*.5)*2.0;\n\n    cyl1P = rMatrix1 * cyl1P;\n    cyl1P.xz += p.xz;\n\n    cyl2P.x += sin(p.y*.5) * 2.0;\n    cyl2P.z += cos(p.y* .5) * 2.0;\n\n    cyl2P = rMatrix2 * cyl2P;\n    cyl2P.xz += p.xz;\n\n    float cyl1 = sdCylinder(cyl1P.xyz + vec3(0.0,0.0,-2.0),vec2(1.0,10.));\n    float cyl2 = sdCylinder(cyl2P.xyz + vec3(0,0,-2),vec2(1,10));\n\n    float finalShape = min(cyl1, cyl2);\n    return finalShape;\n\n}\n\n\nvec3 getNormal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0); //eplison - small offset\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nfloat diffuseLighting(vec3 p) {\n    vec3 lightPosition = vec3(3,9,-3);\n    vec3 light = normalize(lightPosition - p); // normalize the vector\n    vec3 normal = getNormal(p);\n\n    float diffuse = clamp( dot(normal, light), 0., 1.); // percentage of similarity\n    return diffuse;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv.st * 2.0 - 1.0 ; // 0 is the center\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 1.0, -2.0); // change this to change the camera\n    vec3 rayDirection = normalize(vec3(uv, 1.));\n\n    float diffuse;\n    float distanceOrigin = 0.0; // initial distance from cam is 0\n\n    vec3 normal;\n    // you must define a max limit for marching...\n    // good upper limit is 128\n    for ( int i = 0; i < 128; i++ ) {\n\n        // start with camera origin + the incremented value, * ray Direction\n        vec3 position = rayOrigin + distanceOrigin * rayDirection;\n        //formula to create a sphere\n        float map = map(position); // just for naming\n        distanceOrigin += map; // check again after hitting the radius of the sphere\n\n        //set the near and far clipping plane\n        if (distanceOrigin < MIN_DISTANCE || distanceOrigin > MAX_DISTANCE) break;\n        diffuse = diffuseLighting(position);\n\n    }\n\n    distanceOrigin /= 2.; // couldn't see the map, so divide by 2\n\n    vec3 shape = vec3(1,1,1) * diffuse;\n    \n\n    vec4 color = vec4(shape,1);\n\n    // Output to screen\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 138, 138, 241], [244, 244, 289, 289, 917], [919, 919, 937, 937, 1712], [1715, 1715, 1738, 1767, 1940], [1942, 1942, 1973, 1973, 2223], [2226, 2226, 2283, 2333, 3522]]}
{"id": "WtKGDD", "name": "sdCylinder-doble Sponge-Igual", "author": "jorge2017a1", "description": "sdCylinder-doble Sponge-Igual", "tags": ["sdcylinderdoblespongeigual"], "likes": 2, "viewed": 74, "published": "Public", "date": "1578973192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\n// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n\n\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//--------------------------------------------------------\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\n//---------------------------------------------------------\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\tvec3 p;\n    float d;\n    \n    d=999.9;\n    p=pos;\n        \n     p.zx *= rotate(iTime);\n  \t p.yx *= rotate(iTime * 0.5);\n\n   \t\n   \n    float  distToCapsule =sdCylinder( p, vec2(1.0,1.0) );\n    float  distToCapsule2 =sdCylinder( p.yzx, vec2(1.0,2.0) );\n    d= unionSDF(distToCapsule,distToCapsule2);\n    \n    //d=distToCapsule;\n    \n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                        \n    \n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\t//return max( d1, -d0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 230, 259, 259, 345], [347, 347, 376, 376, 452], [455, 455, 537, 537, 768], [771, 771, 807, 807, 910], [913, 993, 1033, 1033, 1062], [1064, 1064, 1103, 1103, 1154], [1156, 1216, 1239, 1239, 1265], [1267, 1327, 1373, 1373, 1405], [1407, 1407, 1449, 1449, 1481], [1483, 1483, 1530, 1530, 1563], [1564, 1626, 1649, 1649, 1787], [1790, 1790, 1812, 1812, 1882], [1884, 1913, 1943, 1943, 2637], [2639, 2656, 2698, 2724, 3557], [3559, 3588, 3615, 3615, 3949], [3951, 3967, 4036, 4036, 4286], [4288, 4309, 4357, 4357, 4533], [4535, 4567, 4598, 4598, 4754], [4756, 4756, 4813, 4833, 5336]]}
{"id": "WtKGDh", "name": "nebula 112", "author": "aodnawg", "description": "inspired https://www.shadertoy.com/view/4tlSzl", "tags": ["nebula"], "likes": 9, "viewed": 276, "published": "Public", "date": "1578834729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n11(float p) {\n\treturn fract(sin(p*154.101)*313.019);\n} \nfloat n21(vec2 p) {\n    float n = sin(dot(p, vec2(7, 157)));    \n    return n;\n}\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat nebula(in vec3 p) {\n    float amp = 1., sum=0., z= 1., m = 0.;\n    for(int i=1; i<=10;i++){\n    \tvec3 t = vec3(0., 0., p.z+iTime*.1);\n        z *= 2.;\n        m += voronoi(vec3(p.xy*z, 1.)+t) *amp;\n        sum += amp;\n        amp *= .5;\n    }\n    m /= sum;\n    return pow(m, 1.5);\n}\n\nfloat star(vec3 p) {\n    float z = 16.;\n    float t = p.z;\n    vec2 gv = fract(p.xy*z)-.5;\n    vec2 id = floor(p.xy*z);\n    gv.x += sin(n21(id)*354.23)*.3;\n    gv.y += sin(n11(n21(id))*914.19)*.3;\n    float r = n11(n21(id));\n    float m =  .1*n11(r)*abs(sin(p.z+r*133.12))*.4/length(gv)*.1;\n    return m;\n}\n\nfloat stars(in vec3 p) {\n    float z= 1., m = 0.;\n    for(int i=1; i<=10;i++){\n    \tvec3 t = vec3(0., 0., p.z+iTime*.2);\n        z *= 2.;\n         m += star(vec3(p.xy*z, 1.)+t);\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.0);\n    \n    vec3 col1 = normalize(vec3(159., 38., 106.))*nebula(vec3(uv,1.));\n    vec3 col2 = normalize(vec3(106., 110., 185.))*nebula(vec3(uv,1298.));\n    col += mix(col1,col2,5.);\n    float m = stars(vec3(uv, iTime*2.));\n    col += vec3(m);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 61], [63, 63, 82, 82, 143], [144, 144, 164, 164, 268], [270, 270, 292, 292, 695], [697, 697, 723, 723, 863], [865, 865, 890, 890, 1153], [1155, 1155, 1175, 1175, 1461], [1463, 1463, 1487, 1487, 1662], [1664, 1664, 1721, 1721, 2103]]}
{"id": "WtKGDw", "name": "DataSphere", "author": "shau", "description": "Another techy scene ", "tags": ["3d"], "likes": 11, "viewed": 245, "published": "Public API", "date": "1579297718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 50.0\n#define ZERO (min(iFrame,0))\n#define T iTime\n#define PI 3.141592\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define S(a, b, v) smoothstep(a, b, v)\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash12(vec2 p) \n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Nimitz\nfloat tri(float x) {return abs(x - floor(x) - 0.5);}\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n//SDF functions - IQ\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n/*\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n*/\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0); //missed\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec3 sphNormal(vec3 pos, vec4 sph) \n{\n    return normalize(pos - sph.xyz);\n}\n\nvec2 boxes(vec3 p)\n{\n    p.z += T;\n    vec3 q = p;    \n    q.y = abs(q.y);\n    q.xz = fract(p.xz*0.125)*8.0 - 4.0;\n    return vec2(sdBox(q - vec3(0.0, 8.0, 0.0), vec3(3., 0.3, 3.0)), \n                hash12(floor(p.xz*0.125)));\n}\n\nvec4 map(vec3 p)\n{\n    vec2 b = boxes(p);\n    \n    /*\n    vec3 q = p;\n    q += vec3(-8.0, -0.0, 3.0);\n    float l = sin(p.x*3.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));\n    q.xy *= rot(sin(p.x*2.0+T*1.2)*0.16);\n    q.xz *= rot(sin(p.x*2.0+T*2.8)*0.2);\n    q = opRepLim(q, 0.25, vec3(30.0, 0.0, 0.0));\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.02);\n    cs = max(cs, -sdSphere(p, 3.0));\n    //*/\n    \n    //capsule stream\n    //right\n    vec3 q = p;\n    q += vec3(0.0, -2.0, 2.0);\n    float l = sin(p.x*2.0)*3.0 * min(1.0, p.x*0.08) * max(0.0, (1.0 - p.x*0.08));  \n    q.xy *= rot(sin(p.x+T*1.2)*0.1);\n    q.xz *= rot(sin(p.x+T*0.8)*0.1);\n    q.x = fract(p.x*4.0)*0.25 - 0.125;\n    q.yz *= rot(floor(p.x*4.0)*0.1+T*0.9);\n    float cs = sdCapsule(q, vec3(0.0, -1.0*l, 0.0), vec3(0.0, 1.0*l, 0.0), 0.01);\n    cs = p.x>0.0 && p.x<20.6 ? cs : FAR;\n    //noise line\n    //left\n    q = p;\n    q.y += sin(q.x*2.0+T*6.)*0.2 + sin((q.x - 4.2)*3.2+T*13.3)*0.1;\n    q.z += sin((q.x - 1.3)*1.7+T*5.)*0.2 + sin((q.x - 5.9)*3.2+T*7.1)*0.14;\n\tq.yz += tri(q.x*0.31 + T*3.6)*0.2;\n\tq.xz += tri(q.x*0.7 + T*1.6)*0.8;\n    cs = min(cs, sdCapsule(q, vec3(-20.0, -7.0 + sin(T*0.4)*2.0, -4.0 + sin((T-3.1)*0.14)), vec3(0.0, -2.0, 0.0), 0.01));\n    //cutout\n    cs = max(cs, -sdSphere(p, 3.0));\n\n    return vec4(min(cs, b.x), cs, b.x, b.y);\n}\n\n// particles (Andrew Baldwin)\n// stolen from Galvanize by Virgill \nfloat snow(vec3 direction) {\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n/*\nvec3 overlay(vec2 uv)\n{\n    vec2 ruv = uv*rot(sin(T*0.03));\n    ruv.x += (sin(ruv.y*4.0 + T*0.3) * 0.08);\n    vec2 c = fract(ruv*vec2(20.0, 12.0)) - 0.5;\n    float cH = hash12(floor(ruv*vec2(20.0, 12.0)));\n    \n    vec3 col = palette(cH*10000.) * S(0.16+cH*0.1, 0.1+cH*0.1, length(c)); //dots\n    //vignette\n    col *= S(0.0, 0.1, uv.x) * S(1.0, 0.9, uv.x) * \n           S(0.0, 0.1, uv.y) * S(1.0, 0.9, uv.y);\n    return col;\n}\n*/\n\n//background\nvec3 background(vec3 rd, vec3 colA, vec3 colB)\n{\n    //radial lines\n    float a = (atan(rd.x, rd.y)/6.2831853) + 0.5, //0->1\n          l = floor(a * 24.0) / 24.0; //partition cells    \n    vec3 pc = colB * 2.0 *\n              S(0.46, 0.5, fract(a*24.0)) * S(0.54, 0.5, fract(a*24.0));\n    //horizontal lines\n    float dY = pow(abs(rd.y), 0.8), //problem with power - thanks iapafotoo\n          cY = fract(dY*6.0-T*0.4),\n          cYID = floor(dY*6.0-T*0.4),\n          cYH = hash11(cYID) - 0.6,    \n          tt = mod(T*cYH*4.0*sign(rd.y), 3.0) - 1.5,\n          dX = length(tt - rd.x);\n    pc += colB * 1.6 * S(0.02, 0.0, length(cY - 0.5)); //lines\n    //noise\n    pc *= (2.0 +n3D(rd*3.6+T)) * n3D(rd*5.0+T*0.3);\n    //sparks\n    pc += (cYH*sign(-rd.y)>0.0 ? step(tt, rd.x) : step(rd.x, tt)) * //clip\n          colA * 6.0 * S(0.05, 0.0, length(cY - 0.5)) / //line \n          (1.0 + dX*dX*60.); //attenuation \n    //fade\n    pc *= max(abs(rd.y*0.4), 0.);\n    //center glow\n    pc += colB / ((1.0 + abs(rd.x)*abs(rd.x)*8.0) * (1.0 + dY*dY*100.0));\n\n    return pc;\n}\n\nvec4 renderScene(vec3 ro, vec3 rd, vec3 lp, vec3 colA, vec3 colB)\n{\n    float t = 0.0;\n    vec3 pc = background(rd, colA, colB); \n    \n    for (int i=ZERO; i<80; i++)\n    {\n        vec3 p = ro + rd*t;\n        vec4 ns = map(p);\n        //if (abs(ns.x)<EPS && ns.x==ns.y) break;\n        pc += 0.3 * colA / (1.0 + ns.y*ns.y*200.0);\n        float atn = 1.0 / (1.0 + length(p-ro)*length(p*ro)*0.0001);\n        pc += step(ns.z, EPS) * step(ns.w, 0.4) * //clip \n              0.008 * colB / (1.0 + ns.z*ns.z*30.0) * atn;\n        t += max(EPS*2.0, ns.x * 0.6);\n        if (t>FAR) break;\n    }    \n        \n    return vec4(pc, t);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec3 col = vec3(0),\n         la = vec3(0),\n         colA = rotHue(vec3(1,0,0), T*0.1),\n         colB = rotHue(vec3(1,0,0), (T-3.0)*0.1),\n         ro = vec3(0.0, sin(T*0.1)*2.0, -11.0 - sin(T*0.2)*2.0);\n    \n    ro.xz *= rot(sin((T+5.0)*0.3)*0.3);\n    vec3 rd = camera(U, ro, la, 1.4);\n    vec3 lp = vec3(3.0, 4.0, -2.0);\n    \n\tvec4 scene = renderScene(ro, rd, lp, colA, colB);\n    col = scene.xyz;\n    \n    vec4 sph = vec4(0.0, 0.0, 0.0, 3.0);\n    vec2 si = sphIntersect(ro, rd, sph);\n    float sd = sphDensity(ro,rd, sph, FAR);\n    if (si.x>0.0)\n    {\n        \n        col *= scene.y==2.0 ? 0.0 : 0.4;\n        vec3 pN = ro + rd*si.x;\n        vec3 pF = ro + rd*si.y;\n        \n        vec3 nN = sphNormal(pN, sph);\n        vec3 nF = sphNormal(pF, sph) * -1.0;\n        \n        vec3 ldN = normalize(lp - pN);\n        vec3 ldF = normalize(lp - pF);\n        \n        float specN = pow(max(dot(reflect(-ldN, nN), -rd), 0.0), 16.0);\n        float specF = pow(max(dot(reflect(-ldF, nF), -rd), 0.0), 16.0);\n        float fres = pow(clamp(dot(nN, rd) + 1.0, 0.0, 1.0), 2.0);\n\n        col += colA * pow(sd, 4.0) * max(0.0, (sin(T*4.0)+0.5) * 0.6);\n        \n        col += vec3(1) * specN;  \n        col += vec3(1) * specF*0.2;  \n        \n        //reflection\n        vec3 rro = pN;\n        vec3 rrd = reflect(rd, nN);\n        vec4 rScene = renderScene(rro, rrd, lp, colA, colB);\n        col += rScene.xyz * fres;\n    }\n    \n    col += colA*2.0*snow(normalize(vec3(0.0, 0.0, -1.0)));\n    \n    C = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGDw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[493, 576, 597, 597, 678], [680, 680, 703, 703, 792], [794, 794, 817, 817, 903], [905, 924, 944, 944, 1249], [1251, 1260, 1280, 1280, 1312], [1313, 1342, 1361, 1361, 1407], [1409, 1566, 1596, 1596, 1965], [1967, 2062, 2092, 2092, 2187], [2189, 2189, 2240, 2240, 2367], [2369, 2369, 2402, 2402, 2430], [2521, 2605, 2652, 2652, 2910], [2912, 2912, 2973, 2973, 3489], [3491, 3491, 3528, 3528, 3567], [3569, 3569, 3589, 3589, 3798], [3800, 3800, 3818, 3818, 5208], [5210, 5277, 5305, 5305, 6128], [6565, 6578, 6626, 6645, 7640], [7642, 7642, 7709, 7709, 8265], [8267, 8267, 8317, 8317, 8502], [8504, 8504, 8543, 8543, 10051]]}
{"id": "wtKGRm", "name": "piccolo blu e piccolo giallo", "author": "omis", "description": "A simple shader in honour of Leo Lionni, Little Blue and Little Yellow children tale.\nIt's the beginning of a personal experiment with trying to recreate organic, collage looking shapes with glsl.", "tags": ["2d", "noise", "mix"], "likes": 0, "viewed": 66, "published": "Public", "date": "1578579660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p) {\n\treturn length(p)+0.5;\n}\n\nfloat frame(vec2 p, float h) {\n\treturn step(p.y, 1.0-h);\n}\n\n// Noise (from iq)\nfloat noise (in vec2 p) {\n    float f = 0.0;\n    p+=iTime*0.05;\n    f += texture(iChannel0, p*0.025).r*0.05; f*=3.0;\n    f += texture(iChannel0, p*8.02).r; f*=1.5;\n    f += texture(iChannel0, p*16.04).r; f*=0.75;\n    f += texture(iChannel0, p*32.03).r; f*=0.325;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n\tuv.x*=iResolution.x/iResolution.y;\n    \n    vec2 p = uv;\n    \n    p.y -= 0.35;\n    float top = frame(p+noise(uv*1.25)*1.2, 0.15);\n    \n    p.y += 0.45;\n    float bottom = 1.0-frame(p+noise(uv*0.55)*0.86, 0.99);\n    \n    uv.x += 0.3+sin(iTime)*.3;\n    float blu = step(0.95, circle(-0.5+uv+noise(uv)));\n    \n    uv.x += -1.2+sin(iTime)*.3;\n    uv.y-=0.5;\n    float giallo = step(0.95, circle(uv+noise(uv)));\n    \n    vec3 bg = vec3(0.99);\n    vec3 green = vec3(0.0, 0.75, 0.);\n    \n    vec3 circle_giallo = vec3(0.95, 0.95, 0.0) * 1.0 - giallo;\n    vec3 circle_blu = vec3(0.1, 0.1, 0.8) * 1.0 - blu;\n\t\n    // circles\n\tvec3 col = mix(circle_blu, circle_giallo, 1.0-giallo);\n    col = mix(col, green, 1.0-blu-giallo);\n    \n    // bg\n    col = mix(bg, col, 1.0-(blu*giallo));\n\n    vec3 head = vec3(0.6-top, 0.4-top, 0.0);\n    vec3 foot = vec3(bottom);\n   \t\n    // bars\n    col = mix(col, foot, 1.0-bottom);\n    col = mix(col, head, 1.0-top);\n    \n    // grain\n    col *= 0.85+(texture(iChannel0, uv*2.0).r*0.15);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 47], [49, 49, 79, 79, 107], [109, 128, 153, 153, 403], [405, 405, 462, 512, 1633]]}
{"id": "WtKGW3", "name": "floating astronaut", "author": "monsterkodi", "description": "MOUSE rotate \nRIGHT  rotation \nLEFT    noise\nDOWN  ambient occlusion\nUP       animation", "tags": ["sdf"], "likes": 21, "viewed": 154, "published": "Public", "date": "1580157552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TOY  1\n\n#define MAX_STEPS 96\n#define MIN_DIST   0.005\n#define MAX_DIST  40.0\n#define SHADOW     0.04\n#define PI 3.1415926535897\n#define ZERO min(iFrame,0)\n\n#define NONE  0\n#define BODY  1\n#define BONE  2\n#define VISOR 3\n#define MOON  4\n\nvec3 v0 = vec3(0,0,0);\nvec3 vx = vec3(1,0,0);\nvec3 vy = vec3(0,1,0);\nvec3 vz = vec3(0,0,1);\n\n\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct sdf {\n    float dist;\n    vec3  pos;\n    int   mat;\n};\n\nstruct pivot {\n    vec3 p;\n    vec3 x;\n    vec3 y;\n    vec3 z;\n    mat3 m;\n};\n\n\n#define pivot0  pivot(v0,vx,vy,vz,mat3(1,0,0,0,1,0,0,0,1))\n\npivot pHip;\npivot pTorso;\npivot pHead;\npivot pArmL;\npivot pArmR;\npivot pElbowL;\npivot pElbowR;\npivot pHandL;\npivot pHandR;\npivot pLegL;\npivot pLegR;\npivot pKneeL;\npivot pKneeR;\npivot pFootL;\npivot pFootR;\n\npivot pCam;\n\nvec3 pTorsoT;   \nvec3 pTorsoB;\nvec3 pHeelL;    \nvec3 pHeelR;\nvec3 pToeL;     \nvec3 pToeR;\n\nvec3 camTgt;\nvec3 pLight;\n\nbool soft;\nbool camrot;\nint  option;\n\nsdf  s;\nvec2 frag, uv;\n\nfloat rad2deg(float r) { return 180.0 * r / PI; }\nfloat deg2rad(float d) { return PI * d / 180.0; }\n\nvec3 hash33(vec3 p)\n{ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat clamp01(float v) { return clamp(v, 0.0, 1.0); }\n\nfloat voronoi(vec3 p)\n{\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = p.z; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\t\n\treturn 1.-d*1.0/p.z;\n}\n\n// 0000000    000   0000000   000  000000000  \n// 000   000  000  000        000     000     \n// 000   000  000  000  0000  000     000     \n// 000   000  000  000   000  000     000     \n// 0000000    000   0000000   000     000     \n\nfloat digit(int x, int y, float value, float format)\n{     \n    float digits  = floor(format);\n    float decimal = fract(format)*10.0;\n    vec2 pos = (frag-vec2(float(x),float(y))) / vec2(16.0, 25.0);\n    \n    if ((pos.y < 0.0) || (pos.y >= 1.0)) return 0.0;\n    if ((pos.x < 0.0) || (pos.x >= digits+decimal+2.0)) return 0.0;\n    \n    bool neg = value < 0.0;\n    value = abs(value);\n    \n    float log10 = log2(abs(value))/log2(10.0);\n    float maxIndex = max(floor(log10), 0.0);\n    float index = digits - floor(pos.x);\n    float bin = 0.;\n    if (index > (-decimal - 1.01))\n    {\n        if (index > maxIndex) { if (neg && index < maxIndex+1.5) bin = 1792.; } // minus sign \n        else if (index == -1.0) { if (decimal > 0.0) bin = 2.; } // decimal dot \n        else \n        {\n            float reduced = value;\n            if (index < 0.0) \n            { \n                reduced = fract(value); \n                index += 1.0; \n            }\n\n            switch (int(floor(mod(abs(reduced/(pow(10.0, index))), 10.0))))\n            {\n            case 0: bin = 480599.; break;\n            case 1: bin = 139810.+65536.; break;\n            case 2: bin = 476951.; break;\n            case 3: bin = 476999.; break;\n            case 4: bin = 350020.; break;\n            case 5: bin = 464711.; break;\n            case 6: bin = 464727.; break;\n            case 7: bin = 476228.; break;\n            case 8: bin = 481111.; break;\n            case 9: bin = 481095.; break;\n            }\n        }\n    }\n\n    return floor(mod((float(bin) / pow(2.0, floor(fract(pos.x)*4.0) + (floor(pos.y*5.0)*4.0))), 2.0));\n}\n\n// 00000000    0000000   000000000  \n// 000   000  000   000     000     \n// 0000000    000   000     000     \n// 000   000  000   000     000     \n// 000   000   0000000      000     \n\nmat3 rotMat(vec3 u, float angle)\n{\n    float s = sin(deg2rad(angle));\n    float c = cos(deg2rad(angle));\n    float i = 1.0-c;\n    \n    return mat3(\n        c+u.x*u.x*i, u.x*u.y*i-u.z*s, u.x*u.z*i+u.y*s,\n        u.y*u.x*i+u.z*s, c+u.y*u.y*i, u.y*u.z*i-u.x*s,\n        u.z*u.x*i-u.y*s, u.z*u.y*i+u.x*s, c+u.z*u.z*i\n        );\n}\n\nvec3 rotAxisAngle(vec3 position, vec3 axis, float angle)\n{\n    mat3 m = rotMat(axis, angle);\n    return m * position;\n}\n\n// 00     00   0000000   000000000  \n// 000   000  000   000     000     \n// 000000000  000000000     000     \n// 000 0 000  000   000     000     \n// 000   000  000   000     000     \n\nmat3 rMatX(float x)\n{\n     float r = deg2rad(x);\n     float c = cos(r), s = sin(r);\n     return mat3(1,0,0,0,c,-s,0,s,c);\n}\n\nmat3 rMatY(float y)\n{\n     float r = deg2rad(y);\n     float c = cos(r), s = sin(r);\n     return mat3(c,0,s,0,1,0,-s,0,c);\n}\n\nmat3 rMatZ(float z)\n{\n     float r = deg2rad(z);\n     float c = cos(r), s = sin(r);\n     return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// 00000000  000   000  000      00000000  00000000   \n// 000       000   000  000      000       000   000  \n// 0000000   000   000  000      0000000   0000000    \n// 000       000   000  000      000       000   000  \n// 00000000   0000000   0000000  00000000  000   000  \n\nmat3 euler(float x, float y, float z)\n{\n    return rMatY(y) * rMatX(x) * rMatZ(z);\n}\n\nvoid eulerPivot(inout pivot p, float x, float y, float z)\n{\n    p.m = euler(x,y,z);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvoid concatPivotXY(inout pivot p, pivot o, float x, float y)\n{\n    p.m = o.m * euler(x,y,0.0);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvoid concatPivotYZ(inout pivot p, pivot o, float y, float z)\n{\n    p.m = o.m * euler(0.0,y,z);\n    p.x = p.m * vx;\n    p.y = p.m * vy;\n    p.z = p.m * vz;\n}\n\nvec3 posOnPlane(vec3 p, vec3 n)\n{\n    return p-dot(p,n)*n;\n}\n\n//  0000000   00000000   \n// 000   000  000   000  \n// 000   000  00000000   \n// 000   000  000        \n//  0000000   000        \n\nfloat opUnion(float d1, float d2, float k) \n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opDiff(float d1, float d2, float k) \n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d1, -d2, h) + k*h*(1.0-h); \n}\n\nfloat opInter(float d1, float d2) \n{\n    float k = 0.05;\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n//  0000000  0000000    \n// 000       000   000  \n// 0000000   000   000  \n//      000  000   000  \n// 0000000   0000000    \n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 c = a+clamp01(dot(ab,p-a)/dot(ab,ab))*ab;\n    return length(p-c)-r;        \n}\n\nfloat sdTorus(vec3 p, vec3 a, vec3 n, vec2 r)\n{\n    vec3 q = p-a;\n    return length(vec2(length(posOnPlane(q, n))-r.x,abs(dot(n, q))))-r.y;\n}\n\nfloat sdSphere(vec3 p, vec3 a, float r)\n{\n    return length(p-a)-r;\n}\n\nfloat sdPlane(vec3 p, vec3 a, vec3 n)\n{   \n    return dot(n, p-a);\n}\n\n// 00000000    0000000    0000000  00000000  \n// 000   000  000   000  000       000       \n// 00000000   000   000  0000000   0000000   \n// 000        000   000       000  000       \n// 000         0000000   0000000   00000000  \n\nvoid poseNeutral()\n{\n    pivot p0 = pivot0;\n    pHip    = p0;\n    pTorso  = p0;\n    pHead   = p0;\n    pArmL   = p0;\n    pArmR   = p0;\n    pElbowL = p0;\n    pElbowR = p0;\n    pHandL  = p0;\n    pHandR  = p0;\n    pLegL   = p0;\n    pLegR   = p0;\n    pKneeL  = p0;\n    pKneeR  = p0;\n    pFootL  = p0;\n    pFootR  = p0;\n}\n\n// 00000000  000       0000000    0000000   000000000  \n// 000       000      000   000  000   000     000     \n// 000000    000      000   000  000000000     000     \n// 000       000      000   000  000   000     000     \n// 000       0000000   0000000   000   000     000     \n\nvoid poseFloating()\n{    \n    float s0 = sin(iTime*0.125);\n    float s1 = sin(iTime*0.25);\n    float s2 = sin(iTime*0.5);\n    float s3 = sin(iTime*1.0);\n    float s4 = sin(iTime*4.0);\n    \n    if (camrot)\n    \teulerPivot(pHip, sin(iTime*0.1)*15.0, 0.0, sin(iTime*0.2)*25.0);\n   \telse\n        pHip = pivot0;\n    \n    concatPivotXY(pTorso, pHip, s2*15.0, s1*35.0);\n    \n    float ht = iTime*0.6;\n    vec3 hsh = mix(hash31(floor(ht)), hash31(floor(ht)+1.0), smoothstep(0.0,1.0,fract(ht)));\n    \n    concatPivotXY(pHead,   pTorso, 10.0-20.0*hsh.x, 20.0-40.0*hsh.y);\n    concatPivotYZ(pArmL,   pTorso,  30.0-s3*20.0, -30.0-s1*20.0);\n    concatPivotYZ(pArmR,   pTorso, -30.0-s3*20.0,  30.0-s1*20.0);\n    \n    concatPivotXY(pElbowL, pArmL,  -60.0+s1*30.0,  0.0);\n    concatPivotXY(pElbowR, pArmR,  -60.0-s2*30.0,  0.0);\n    \n    concatPivotYZ(pHandL, pElbowL,  0.0, 0.0);\n    concatPivotYZ(pHandR, pElbowR,  0.0, 0.0);\n\n    concatPivotYZ(pLegL,   pHip,    s0*20.0, -20.0+s1*20.0);\n    concatPivotYZ(pLegR,   pHip,    s2*20.0,  20.0+s1*20.0);\n    \n    concatPivotXY(pKneeL, pLegL,    60.0-s1*30.0,  0.0);\n    concatPivotXY(pKneeR, pLegR,    60.0+s2*30.0,  0.0);\n    \n    concatPivotXY(pFootL, pKneeL,   0.0,  0.0);\n    concatPivotXY(pFootR, pKneeR,   0.0,  0.0);\n}\n\n//  0000000   000   000  000  00     00  \n// 000   000  0000  000  000  000   000  \n// 000000000  000 0 000  000  000000000  \n// 000   000  000  0000  000  000 0 000  \n// 000   000  000   000  000  000   000  \n\nvoid calcAnim()\n{\n    pHip.p   -= pHip.y;\n\n    pLegL.p   = pHip.p + 0.3*pHip.x -0.1*pHip.y; \n    pLegR.p   = pHip.p - 0.3*pHip.x -0.1*pHip.y; \n    \n    pTorsoB   = pHip.p+1.5*pHip.y;\n    pTorsoT   = pTorsoB + pTorso.y *0.3;\n    pArmR.p   = pTorsoT - pTorso.x *1.2; \n    pArmL.p   = pTorsoT + pTorso.x *1.2; \n    \n    pHead.p   = pTorsoT + pTorso.y;\n    \n    pElbowL.p = pArmL.p   +0.45*pArmL.x -1.20*pArmL.y;\n    pHandL.p  = pElbowL.p -1.15*pElbowL.y;    \n    \n    pElbowR.p = pArmR.p   -0.45*pArmR.x -1.20*pArmR.y;\n    pHandR.p  = pElbowR.p -1.15*pElbowR.y;    \n\n    pHandL.p -= 0.6 * pHandL.y;\n    pHandR.p -= 0.6 * pHandR.y;\n\n    pKneeL.p  = pLegL.p  +0.45*pLegL.x -1.20*pLegL.y;\n    pFootL.p  = pKneeL.p -1.15*pKneeL.y;\n\n    pKneeR.p  = pLegR.p  -0.45*pLegR.x -1.20*pLegR.y;\n    pFootR.p  = pKneeR.p -1.15*pKneeR.y;    \n\n    pHeelL    = pFootL.p -0.75 * pFootL.y;\n    pToeL     = pHeelL -0.75 * pFootL.z;\n    \n    pHeelR    = pFootR.p -0.75 * pFootR.y;\n    pToeR     = pHeelR -0.75 * pFootR.z;    \n}\n\n//  0000000   00000000   00     00  \n// 000   000  000   000  000   000  \n// 000000000  0000000    000000000  \n// 000   000  000   000  000 0 000  \n// 000   000  000   000  000   000  \n\nfloat arm(vec3 pos, float side, vec3 elbow, vec3 ud, vec3 x)\n{\n    float d = sdCapsule(s.pos, pos-side*x*0.15, elbow, 0.45);\n    return opUnion(d, sdCapsule(s.pos, elbow-0.2*ud, elbow-1.0*ud, 0.45), 0.2);\n}\n\n// 00000000   0000000    0000000   000000000  \n// 000       000   000  000   000     000     \n// 000000    000   000  000   000     000     \n// 000       000   000  000   000     000     \n// 000        0000000    0000000      000     \n\nfloat foot(vec3 heel, vec3 toe, vec3 up)\n{\n    float d = sdCapsule(s.pos, heel, toe, 0.7);\n    return opDiff(d, sdPlane(s.pos, heel-0.3*up, up), 0.3);\n}\n\n// 00     00   0000000    0000000   000   000  \n// 000   000  000   000  000   000  0000  000  \n// 000000000  000   000  000   000  000 0 000  \n// 000 0 000  000   000  000   000  000  0000  \n// 000   000   0000000    0000000   000   000  \n\nvoid moon()\n{\n    if (length(uv+vec2(0.5,-0.25)) > 0.12) return;\n    \n    vec3 p = pCam.p+pCam.z*MAX_DIST/2.0+pCam.x*MAX_DIST/4.0+pCam.y*MAX_DIST/8.0;\n    \n    float r = MAX_DIST/20.0;\n    float d = sdSphere(s.pos, p, r);\n    \n    if (d > s.dist) return;\n    \n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x/2.0)      *r*0.95, r/6.0), 0.3);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x*2.0+pCam.y)*r*1.3,  r/2.0), 0.5);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z-pCam.x+pCam.y)    *r*1.1,  r/3.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x-pCam.y)    *r*1.0,  r/4.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z+pCam.x+4.0*pCam.y)*r*1.2,  r/3.0), 0.4);\n    d = opDiff(d, sdSphere(s.pos, p-normalize(pCam.z-0.75*pCam.x-0.75*pCam.y)*r*1.4,  r/1.5), 0.5);\n    \n    if (d < s.dist) { s.mat = MOON; s.dist = d; }\n}\n\n// 00     00   0000000   00000000   \n// 000   000  000   000  000   000  \n// 000000000  000000000  00000000   \n// 000 0 000  000   000  000        \n// 000   000  000   000  000        \n\nfloat map(vec3 p)\n{\n    s = sdf(1000.0, p, NONE);\n    \n    moon();\n    \n    if (length(uv) > 0.44) return s.dist;\n    \n    float d = sdSphere(s.pos, pTorsoB, 1.3);\n    \n    if (option != 1 && d > s.dist-20.0)\n    {\n        return s.dist;\n    }\n    //if (d > 4.1 && p.z > 0.0)\n    //{\n    //    return s.dist;\n    //}\n    \n    d = opDiff (d, sdTorus(s.pos, pTorsoB-1.27*pTorso.z, pTorso.z, vec2(0.45,0.07)), 0.15);\n    d = opUnion(d, sdSphere(s.pos, pHip.p, 0.9), 0.15);\n    d = opUnion(d, sdCapsule(s.pos, pArmL.p-0.0*pTorso.y, pArmR.p-0.0*pTorso.y, 0.7), 0.15);\n        \n    d = min(d, foot (pHeelR,  pToeR,  pFootR.y));\n    d = min(d, foot (pHeelL,  pToeL,  pFootL.y));\n    \n    d =    min(d, sdSphere(s.pos, pHead.p+pHead.y, 1.6));\n    d = opDiff(d, sdSphere(s.pos, pHead.p+pHead.y-(pHead.z-pHead.y*0.5)*0.5, 1.2), 0.5);\n    \n    d = min(d, sdSphere(s.pos, pHandR.p, 0.65));\n    d = min(d, sdSphere(s.pos, pHandL.p, 0.65));\n\n    d = opDiff(d, sdCapsule(s.pos, pHandR.p-pHandR.z-pHandR.y*0.2+pHandR.x*0.2, pHandR.p+pHandR.z-pHandR.y*0.2+pHandR.x*0.2, 0.37), 0.2);\n    d = opDiff(d, sdCapsule(s.pos, pHandL.p-pHandL.z-pHandL.y*0.2-pHandL.x*0.2, pHandL.p+pHandL.z-pHandL.y*0.2-pHandL.x*0.2, 0.37), 0.2);\n    \n    if (d < s.dist) { s.mat = BODY; s.dist = d; }\n\n    d = min(d, arm  (pArmR.p,  1.0, pElbowR.p, pElbowR.y, pArmR.x));\n    d = min(d, arm  (pArmL.p, -1.0, pElbowL.p, pElbowL.y, pArmL.x));\n    d = min(d, arm  (pLegR.p,  1.0, pKneeR.p,  pKneeR.y,  pLegR.x));\n    d = min(d, arm  (pLegL.p, -1.0, pKneeL.p,  pKneeL.y,  pLegL.x));\n\n    if (d < s.dist) { s.mat = BONE; s.dist = d; }\n    \n    \n        \n    d = min(d, sdSphere(s.pos, pHead.p+pHead.y, 1.3));\n    \n    if (d < s.dist) { s.mat = VISOR; s.dist = d; }\n    \n    return s.dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = v0;\n    for (int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return normalize(n);\n}\n\n// 00     00   0000000   00000000    0000000  000   000  \n// 000   000  000   000  000   000  000       000   000  \n// 000000000  000000000  0000000    000       000000000  \n// 000 0 000  000   000  000   000  000       000   000  \n// 000   000  000   000  000   000   0000000  000   000  \n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dz = 0.0;\n\n    for (int i = ZERO; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dz * rd;\n        float d = map(p);\n        dz += d;\n        if (d < MIN_DIST) return dz;\n        if (dz > MAX_DIST) break;\n    }\n    s.mat = NONE;\n    return dz;\n}\n\n//  0000000  000   000   0000000   0000000     0000000   000   000  \n// 000       000   000  000   000  000   000  000   000  000 0 000  \n// 0000000   000000000  000000000  000   000  000   000  000000000  \n//      000  000   000  000   000  000   000  000   000  000   000  \n// 0000000   000   000  000   000  0000000     0000000   00     00  \n\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n    float shade = 1.;\n    float dist = MIN_DIST;    \n    float end = max(length(rd), MIN_DIST);\n    float stepDist = end/25.0;\n    rd /= end;\n    for (int i = ZERO; i < 25; i++)\n    {\n        float h = map(ro+rd*dist);\n        shade = min(shade, k*h/dist);\n        dist += clamp(h, 0.02, stepDist*2.0);\n        \n        if (h < 0.0 || dist > end) break; \n    }\n\n    return min(max(shade, 0.0) + SHADOW, 1.0); \n}\n\n//  0000000    0000000   0000000  000      000   000   0000000  000   0000000   000   000  \n// 000   000  000       000       000      000   000  000       000  000   000  0000  000  \n// 000   000  000       000       000      000   000  0000000   000  000   000  000 0 000  \n// 000   000  000       000       000      000   000       000  000  000   000  000  0000  \n//  0000000    0000000   0000000  0000000   0000000   0000000   000   0000000   000   000  \n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n    float a = 0.0;\n    float weight = .5;\n    for (int i = ZERO; i <= 6; i++)\n    {\n        float d = (float(i) / 6.0) * 0.3;\n        a += weight * (d - map(p + n*d));\n        weight *= 0.9;\n    }\n    return clamp01(1.0-a);\n}\n\n// 000      000   0000000   000   000  000000000  \n// 000      000  000        000   000     000     \n// 000      000  000  0000  000000000     000     \n// 000      000  000   000  000   000     000     \n// 0000000  000   0000000   000   000     000     \n\nfloat shiny(float rough, float NoH, const vec3 h) \n{\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * rough;\n    float k = rough / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nvec3 getLight(vec3 p, vec3 n, vec3 col, int mat)\n{\n    if (mat == NONE) return col;\n    \n    vec3 vLight = normalize(pLight-p);\n    \n \n    float dif = clamp01(dot(n,vLight));\n    \n    if (mat == BODY)\n    {\n        float exp = 0.6;\n        float smx = 0.0;\n        \n        vec3  n2c = normalize(pCam.p-p);\n        vec3  bcl = normalize(n2c + vLight);\n        float dnh = clamp01(dot(n, bcl));\n        float shi = shiny(0.25, dnh, bcl);\n        \n        dif = clamp01(pow(dif, exp) + shi);\n    }\n    else if (mat == MOON)\n    {\n        dif = pow(dif, 2.0);\n    }\n    \n    vec3 hl;\n    if (mat == VISOR)\n    {\n        hl = vec3(pow(clamp01(smoothstep(0.95,1.0,dot(n, vLight))), 10.0));\n    }\n    else if (mat == BONE)\n    {\n        hl = vec3(clamp01(smoothstep(0.5,1.0, dot(n, vLight)))*0.05);\n    }\n\n    float shadow = softShadow(p, vLight, 8.0) * (soft ? getOcclusion(p, n) : 1.0);\n\n    return (col * clamp01(dif) + hl) * shadow;\n}\n\n// 00     00   0000000   000  000   000  \n// 000   000  000   000  000  0000  000  \n// 000000000  000000000  000  000 0 000  \n// 000 0 000  000   000  000  000  0000  \n// 000   000  000   000  000  000   000  \n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_9     = 57;\n\nbool keyState(int key) { return texelFetch(iChannel0, ivec2(key, 2), 0).x < 0.5; }\nbool keyDown(int key)  { return texelFetch(iChannel0, ivec2(key, 0), 0).x > 0.5; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    frag = fragCoord;\n    \n    bool dither =  keyState(KEY_LEFT);\n         camrot =  keyState(KEY_RIGHT);\n         soft   =  keyState(KEY_DOWN);\n    bool animat =  keyState(KEY_UP);\n    bool space  =  !keyState(KEY_SPACE);\n\n    for (int i = KEY_1; i <= KEY_9; i++) \n    { \n        if (keyDown(i)) { option = i-KEY_1+1; break; }\n    }\n    \n    if (animat) poseFloating();\n    else        poseNeutral();\n    \n    calcAnim();\n\n    float aspect = iResolution.x/iResolution.y;\n    \n    float mx = 2.0*(iMouse.x/iResolution.x-0.5);\n    float my = 2.0*(iMouse.y/iResolution.y-0.5);\n    float md = -12.5;\n    \n    if (iMouse.z <= 0.0) { mx = 0.0; my = 0.0; }\n    \n    camTgt = v0;\n    \n    eulerPivot(pCam, -180.0*my, -180.0*mx, 0.0);\n    \n    pCam.p = pCam.z*md;\n\n    #ifndef TOY\n        if (space)\n        {\n            camTgt = iCenter;\n            pCam.p = iCamera;\n            pCam.p.x *= -1.0;\n            camTgt.x *= -1.0;\n            pCam.z = camTgt-pCam.p;\n            pCam.x = normalize(cross(vy, pCam.z));\n            pCam.y = normalize(cross(pCam.x, pCam.z));\n        }\n    #endif\n    \n    pLight = pCam.p + 5.0*pCam.y + 10.0*pCam.x;\n        \n    // float AA = soft ? 2.0 : 1.0;\n    float AA = 1.0;\n    \n    vec3 cols = v0;\n    vec3 col, p, n, uu, vv, rd;\n    vec2 ao = vec2(0);\n    \n    float d, am, an;\n    int mat, mat0;\n    /*\n     for (am = float(ZERO); am < AA; am+=1.0)\n     for (an = float(ZERO); an < AA; an+=1.0)\n    */\n    {\n        if (AA > 1.0) ao = vec2(am,an)/AA-0.5;\n    \n        uv = (fragCoord+ao-0.5*iResolution.xy)/iResolution.y;\n                \n        uu = normalize(cross(pCam.z, pCam.y));\n        vv = normalize(cross(uu, pCam.z));\n        rd = normalize(uv.x*uu + uv.y*vv + pCam.z);\n        \n        d = rayMarch(pCam.p, rd);\n        mat = s.mat;\n        \n        if (am == AA-1.0 && an == AA-1.0) mat0 = mat;\n        \n        p = pCam.p + d * rd;\n        \n        switch (mat)\n        {\n        case BODY: col = vec3(1.0);  break;\n        case BONE: col = vec3(0.2);  break;\n        case MOON: col = vec3(0.04); break;\n        default:   col = v0;         break;\n        }\n        \n        cols += getLight(p, getNormal(p), col, mat);\n    }\n    \n    col = cols/(AA*AA);\n\n    float hsh = hash12(frag);\n    \n    if (mat0 == NONE) // stars\n    {\n        col = vec3(pow(voronoi(vec3(uv*50.0,iResolution.y*0.0002)), iResolution.y/90.0) - length(uv)*0.7);\n    }\n    \n    if (dither)\n    {\n        \n        col -= vec3((hsh-0.25)*0.004);\n        col *= 1.0-hsh*0.1;\n    }\n    \n    col = max(col, v0);\n\n    #ifndef TOY\n    vec3 red    = vec3(0.8,0.0,0.0);\n    vec3 green  = vec3(0.0,0.5,0.0);\n    vec3 blue   = vec3(0.2,0.2,1.0);\n    vec3 white  = vec3(1.0,1.0,1.0);\n    vec3 yellow = vec3(1.0,1.0,0.0);\n    \n    vec2 muv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    col = mix(col, white,  digit(0,    0, iFrameRate,    2.0));\n    col = mix(col, blue,   digit(0,   40, iTime,         4.1));\n    col = mix(col, yellow, digit(0,   80, iCompile,      2.2));\n    col = mix(col, red,    digit(0,  120, float(option), 1.0));\n    col = mix(col, green,  digit(150,  0, iMouse.y,      5.0));\n    col = mix(col, red,    digit(150, 40, iMouse.x,      5.0));\n    col = mix(col, green,  digit(250,  0, muv.x,         2.2));\n    col = mix(col, red,    digit(250, 40, muv.y,         2.2));\n        \n    if (frag.x >= 350. && frag.x < 500. && frag.y < 160.)\n    {\n        uv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n        rd = normalize(uv.x*uu + uv.y*vv + pCam.z);\n        d  = rayMarch(pCam.p, rd);\n        if (d < MAX_DIST)\n        {\n            p = pCam.p + d * rd;\n            col = mix(col, white, digit(350,   0, d,   3.2));\n            col = mix(col, red,   digit(350, 120, p.x, 3.2));\n            col = mix(col, green, digit(350,  80, p.y, 3.2));\n            col = mix(col, blue,  digit(350,  40, p.z, 3.2));\n        }\n    }\n   \t#endif\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[986, 986, 1010, 1010, 1035], [1036, 1036, 1060, 1060, 1085], [1087, 1087, 1108, 1108, 1212], [1214, 1214, 1236, 1236, 1372], [1374, 1374, 1396, 1396, 1517], [1519, 1519, 1543, 1543, 1572], [1574, 1574, 1597, 1597, 1995], [1997, 2233, 2287, 2287, 3835], [3837, 4023, 4057, 4057, 4347], [4349, 4349, 4407, 4407, 4468], [4470, 4656, 4677, 4677, 4779], [4781, 4781, 4802, 4802, 4904], [4906, 4906, 4927, 4927, 5029], [5031, 5307, 5346, 5346, 5391], [5393, 5393, 5452, 5452, 5538], [5540, 5540, 5602, 5602, 5696], [5698, 5698, 5760, 5760, 5854], [5856, 5856, 5889, 5889, 5916], [5918, 6049, 6094, 6094, 6189], [6191, 6191, 6235, 6235, 6332], [6334, 6334, 6370, 6370, 6485], [6487, 6613, 6663, 6663, 6769], [6771, 6771, 6818, 6818, 6912], [6914, 6914, 6955, 6955, 6983], [6985, 6985, 7024, 7024, 7053], [7055, 7286, 7306, 7306, 7601], [7603, 7884, 7905, 7905, 9140], [9142, 9353, 9370, 9370, 10356], [10358, 10544, 10606, 10606, 10750], [10752, 10988, 11030, 11030, 11140], [11142, 11383, 11396, 11396, 12268], [12270, 12456, 12475, 12475, 14198], [14200, 14200, 14224, 14224, 14420], [14422, 14713, 14747, 14747, 15003], [15005, 15351, 15396, 15396, 15808], [15810, 16271, 16307, 16307, 16533], [16535, 16791, 16843, 16843, 17020], [17022, 17022, 17072, 17072, 17954], [17956, 18350, 18374, 18374, 18432], [18433, 18433, 18457, 18457, 18515], [18517, 18517, 18572, 18572, 22519]]}
{"id": "WtKGWG", "name": "Screenspace Glitch FX", "author": "jhurliman", "description": "Misc. screenspace digital and analog glitch effects", "tags": ["noise", "distortion", "glitch", "screenspace"], "likes": 5, "viewed": 282, "published": "Public", "date": "1579735112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NOISE_LEVEL 0.25\n#define DARKEN_FACTOR 0.125\n\n#define DENOMINATOR vec2(213, 5.53)\n#define NEG_X vec2(-1.0, 1.0)\n#define NEG_Y vec2(1.0, -1.0)\n\n#define GLITCH_OFFSET_1 vec2(32.05, 236.0)\n#define GLITCH_OFFSET_2 vec2(-62.05, -36.0)\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Scanline desync\n\tif (mod(iTime, 2.0) > 1.9)\n\t\tuv.x += cos(iTime * 10.0 + uv.y * 1000.0) * 0.01;\n    \n    // Pixelate glitch 1\n    if (mod(iTime, 4.0) > 3.0)\n\t\tuv = floor(uv * 32.0) / 32.0;\n\n    // Pixelate glitch 2\n\tif (mod(iTime, 5.0) > 3.75)\n    \tuv += 1.0 / 64.0 * (2.0 * vec2(\n            rand(floor(uv * 32.0) + GLITCH_OFFSET_1),\n            rand(floor(uv.y * 32.0) + GLITCH_OFFSET_2)) - 1.0);\n\n\tfragColor = texture(iChannel0, uv);\n    fragColor.rgb\n        += NOISE_LEVEL\n        * vec3(rand(iTime + fragCoord / DENOMINATOR * NEG_X),\n               rand(iTime - fragCoord / DENOMINATOR * NEG_Y),\n               rand(iTime + fragCoord / DENOMINATOR))\n        - DARKEN_FACTOR;\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 260, 260, 330], [332, 332, 387, 387, 1124]]}
{"id": "wtKGWh", "name": "sdRoundCone Sponge", "author": "jorge2017a1", "description": "sdRoundCone Sponge", "tags": ["sdroundconesponge"], "likes": 1, "viewed": 66, "published": "Public", "date": "1578847189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n    float  distToCapsule =sdHexPrism( p, vec2(1.0,1.0) );\n    \n    float sdRc1= sdRoundCone(  p,1.0, 2.0, 1.5 );\n    d= unionSDF(distToCapsule,sdRc1);\n    \n    \n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 50], [52, 52, 81, 81, 167], [169, 169, 198, 198, 274], [277, 277, 359, 359, 590], [593, 593, 629, 629, 732], [734, 734, 770, 770, 1081], [1083, 1083, 1147, 1147, 1425], [1428, 1488, 1534, 1534, 1566], [1568, 1568, 1610, 1610, 1642], [1644, 1644, 1691, 1691, 1724], [1787, 1962, 1985, 1985, 2123], [2126, 2126, 2148, 2148, 2218], [2220, 2220, 2239, 2239, 2785], [2787, 2787, 2808, 2808, 3041], [3043, 3043, 3076, 3076, 3359], [3361, 3361, 3418, 3418, 3798]]}
{"id": "WtKGWm", "name": "hamming grid", "author": "alwas", "description": "Zooming into the coloured representation of the hamming distances of x-y positions.", "tags": ["zoom", "distance", "art", "carpet", "beauty", "muster", "hamming"], "likes": 3, "viewed": 83, "published": "Public", "date": "1579100665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Beauty of hamming dists...\n// - alwas 20200115\nint ham(int a, int b) {\n    int h=0;    \n    for (int c = 32; c >= 0; c--){\n      int ak = a >> c;\n      int bk = b >> c;\n      if ((ak & 1) != (bk & 1))\n          h++;\n    }    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxITime = 3.;\n    float iTimeFactor = maxITime - mod(iTime,maxITime)/2.;\n    int vCx = int(abs(fragCoord.x-(iResolution.x/2.))*iTimeFactor);\n    int vCy = int(abs(fragCoord.y-(iResolution.y/2.))*iTimeFactor);\n    float h = float(ham(vCx, vCy))/10.;\n    fragColor = vec4(vec3(sin(h*iTime),sin(h*4.*iTime),sin(h*5.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 73, 73, 244], [246, 246, 303, 303, 637]]}
{"id": "WtKGWR", "name": "DotConnectVisualizer", "author": "olealgo", "description": "artOfCode helps me get a better understanding of shaders.", "tags": ["procedural"], "likes": 7, "viewed": 149, "published": "Public", "date": "1578750649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 1. Create grid cell 3x3\n// 2. Create a random pixel inside each grid\n// 3. Connect the pixels with lines\n// 4. Add effects\n\n// Procedural programming\n\n\n#define S(a, b, t) smoothstep (a, b, t)\n\n\nfloat DistLine(vec2 p, vec2 startPoint, vec2 endPoint) {\n\n    vec2 pointA = p - startPoint;\n    vec2 pointB = endPoint - startPoint;\n    \n    float t = clamp(dot(pointA, pointB) / dot (pointB, pointB), 0., 1.);\n    return length(pointA - pointB*t);\n}\n\n\nfloat N21(vec2 p) {\n    // Random float between 0 and 1\n    p = fract(p*vec2(233.42, 472.21));\n    \n    // make more random \n    p += dot(p, p+59.31);\n    return fract(p.x*p.y);\n\t\n}\n\n\nvec2 N22(vec2 p) {\n\n    // Random vec2\n    // for Random X and random Y\n    \n   float n = N21(p);\n   return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset) {\n   \t\n    vec2 noise = N22(id + offset)*iTime;\n    \n    return offset + sin(noise) *.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n\n    float d = DistLine(p, a, b);\n\tfloat m = S(.03, .01, d);\n    float dist = length(a-b);\n       \n    m *= S(1.2, .08, dist)*3. + S(.05, .01, abs(dist-.5));\n    return m;\n}\n\nfloat GridDotConnectLayer(vec2 uv) {\n \n    vec2 gridUv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    float m;\n    \n    int i = 0;\n    for (float y=-1.; y <= 1.; y++) {\n    \tfor (float x=-1.; x <= 1.; x++) {\n    \t\t p[i++] = GetPos(id, vec2(x, y));\n    \t}\n    }\n    \n    // Draw lines\n    float t = iTime*10.;\n    \n    for(int i=0; i < 9; i++) {\n        m += Line(gridUv, p[4], p[i]);\n        \n        // Current point\n        vec2 j = (p[i]-gridUv)*25.;\n        float sparkle =  1. / dot(j, j);\n        m += sparkle; //* (sin(t+p[i].*x10.)*.5+.5);\n    }\n    // add additional lines to hidden lines\n    m += Line(gridUv, p[1], p[3]);\n    m += Line(gridUv, p[1], p[5]);\n    m += Line(gridUv, p[5], p[7]);\n    m += Line(gridUv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    // normalized uv coords\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - .5;\n    \n    //vec2 p = GetPos(id);\n    //float dot = length(gridUv-p);\n    //m =  S(.1, .05, dot); \n    \n    float gradient = uv.y;\n    \n    float m = 0.;\n    float t = iTime*.25;\n \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    mouse *= rot;\n    \n    for(float i=0.; i <= 1.; i+= 1./4.) {\n        float z = fract(i+t*1.3);\n        float size = mix(8.5, 2., z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m+= GridDotConnectLayer(uv*size+i*20.-mouse) * fade;\n    }\n    \n    vec3 base = sin( t * vec3( .345, .456, .43 ))*.2 + .5;\n   \n    vec3 col = vec3( m * base);\n    col += gradient + S(.35, .55, base) * .35;\n    \n    // coords for the s-tex\n\tvec2 uv2 = fragCoord.xy / iResolution.xy;\n\n    // s-tex 512x2\n    int tx = int(uv2.x*512.0);\n    \n\t// (48Khz/4 in 512 texels == 23 Hz/texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    float wave = texelFetch( iChannel0, ivec2(tx, 0.5), 0 ).x;\n\tcol += 1.0-S( 0., 0.5, abs(wave - 0.99));\n\n    \n    //m = N22(uv).x;\n    //col.rg += gridUv;\n    //col.rg = id*.2;\n    //if(gridUv.x >0.48 || gridUv.y>0.48) col = vec3(1,0,0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "MtSGR1", "previewfilepath": "https://soundcloud.com/de-best-beats/freestyle-hip-hop-rap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/de-best-beats/freestyle-hip-hop-rap", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 197, 253, 253, 447], [450, 450, 469, 505, 631], [634, 634, 652, 705, 762], [764, 764, 799, 799, 888], [890, 890, 926, 926, 1100], [1102, 1102, 1138, 1138, 1883], [1885, 1885, 1942, 1980, 3288]]}
{"id": "WtKGWW", "name": "sdCruz--Sponge-fractal", "author": "jorge2017a1", "description": "sdCruz--Sponge-fractal", "tags": ["sdcruzspongefractal"], "likes": 3, "viewed": 47, "published": "Public", "date": "1578950519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  //p.zy=p.yz * rotate(iTime);\n  p.zx=p.zx * rotate(iTime);\n  //p.zx *= rotate(iTime);\n  //p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n     \n    d=999.9;\n    \n    \n    //repetir\n   ///// p.x=mod(p.x,20.0) -6.0;\n    //////p.z=mod(p.z,30.0) -6.0;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,6.5,5.0),vec3(1.0,7.0,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,9.0,4.6),vec3(3.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,9.0,4.6),vec3(3.0,0.4,1.0));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,0.5,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.5,0.25,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    \n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.5, -4.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 50], [52, 52, 81, 81, 167], [169, 169, 198, 198, 274], [277, 277, 313, 313, 382], [385, 385, 467, 467, 698], [701, 701, 737, 737, 840], [842, 842, 878, 878, 1189], [1191, 1191, 1255, 1255, 1533], [1535, 1535, 1571, 1571, 1921], [1922, 1982, 2028, 2028, 2060], [2062, 2062, 2104, 2104, 2136], [2138, 2138, 2185, 2185, 2218], [2281, 2456, 2479, 2479, 2617], [2620, 2620, 2642, 2642, 2712], [2714, 2714, 2733, 2764, 4149], [4151, 4151, 4172, 4172, 4405], [4407, 4407, 4440, 4440, 4723], [4725, 4725, 4782, 4782, 5163]]}
{"id": "wtKGzd", "name": "Hologram Toy", "author": "benburrill", "description": "Raymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view", "tags": ["raymarch", "mirror", "hologram", "paraboloid", "parabolic"], "likes": 2, "viewed": 371, "published": "Public API", "date": "1579660224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Hologram Toy -- Ben Burrill\nRaymarch simulation of one of those hologram toys with two parabolic mirrors.\nA ball bounces on a bright circle, but there may be more than meets the eye...\n---\nClick and drag to look inside and see the real ball\nClick again to reset view\n\nI originally wrote this for glslViewer, which has a built-in stateful\ncamera.  On Shadertoy, the best I can do is fake a camera using the\niMouse uniform.  For this shader it's mostly fine, but it would be nice\nto port some of the other shaders I made to Shadertoy and some of those\nrely on the ability to zoom the camera in addition to moving it, and I\ncan't think of any way to finagle Shadertoy's uniforms into getting that\nto work.  If anyone knows of a better way to fake a camera on Shadertoy,\nI'd love to hear about it.\n*/\n\n// A thing in the scene\nstruct Thing {\n    float dist;\n    vec3 color;\n    float refl;  // How reflective the thing is\n};\n\nvoid addThing(inout Thing closest, Thing thing) {\n    if (thing.dist < closest.dist) closest = thing;\n}\n\nfloat paraboloid(vec3 p, float A, float B) {\n    /** Distance function for paraboloid y = A (x^2 + z^2) + B\n    This is an approximation.  I don't know how to get the true closest\n    distance to a paraboloid.  Using the vertical distance above the\n    paraboloid is super easy and works OK, but has some artifacts, so I\n    tried to get closer to true closest distance by making a triangle\n    with the vertical and radial distance.  This seems to converge a lot\n    better on the surface, but it's still not a true distance function.\n    */\n\n    // Shift y so paraboloid starts at origin\n    float y = p.y - B;\n    float r_sq = p.x * p.x + p.z * p.z;\n\n    // Vertical and radial distances\n    float ver = y - A * r_sq;\n    float rad = sqrt(max(y / A, 0.)) - sqrt(r_sq);\n\n    // Pretend it's a cone and find triangular altitude to surface.\n    // It still overshoots, but should be better than either ver or rad.\n    // Sign of vertical distance is ignored.  As a result, the sign of\n    // alt is positive when radially inside, not positive when y is\n    // above the paraboloid like ver is.  So making A negative doesn't\n    // turn the paraboloid inside out like it would if with ver's sign.\n    float alt = abs(ver) * rad / sqrt(ver * ver + rad * rad);\n\n    // When below the paraboloid, use vertical distance to bottom if it\n    // is farther than the altitude.\n    // Otherwise, there would be a line under the paraboloid where the\n    // distance is 0 because the radius of the paraboloid is non-real,\n    // so it is clamped to be 0.\n    return min(sign(A) * y, alt);\n}\n\nThing scene(vec3 p) {\n    float ry = 15.;\n    float y = -ry * .90;\n\n    float sr = 3.;\n    vec3 so = vec3(0., y-ry+sr + ry*(sin(iTime)+1.)/8., 0.);\n    Thing result = Thing(\n        distance(p, so) - sr,\n        // Striped ball coloring\n        (mod(floor(atan(p.z - so.z, p.x - so.x) * 5.), 2.) == 0.)?\n            vec3(1., 0.5, 0.) : vec3(0., 0.5, 0.),\n        0.\n    );\n\n    float foc = 2. * ry - sr;\n    float a = 1. / 4. / foc;\n    addThing(result, Thing(\n        max(p.y, min(paraboloid(p, a, y-ry), paraboloid(p, -a, y+ry))),\n        // Checkerboard pattern coloring\n        (mod(floor(p.x * 0.1) + floor(p.z * 0.1), 2.) == 0.)?\n            vec3(0., 0.2, 0.5) : vec3(0., 0., 0.5),\n        0.8\n    ));\n\n    return result;\n}\n\n// Derivative epsilon.  Seems like a good idea to separate this from the\n// raymarch's epsilon, even though currently they are the same...\n#define DEPS 0.001\nvec3 normal(vec3 p) {\n    /** Normal vector\n    This is pretty inefficient since it needlessly computes colors.\n    I don't really like it, but it works...\n    */\n\n    // The direction of the normal is given by the gradient of the\n    // distance function (direction where distance increases fastest).\n    return normalize(vec3(\n        scene(vec3(p.x + DEPS, p.yz)).dist - scene(vec3(p.x - DEPS, p.yz)).dist,\n        scene(vec3(p.x, p.y + DEPS, p.z)).dist - scene(vec3(p.x, p.y - DEPS, p.z)).dist,\n        scene(vec3(p.xy, p.z + DEPS)).dist - scene(vec3(p.xy, p.z - DEPS)).dist\n    ));\n}\n\n#define EPS 0.001\n#define STEPS 100\nvec3 raymarch(vec3 p, vec3 dir) {\n    float contrib = 1.;\n    vec3 color = vec3(0., 0., 0.);\n\n    for (int i = 0; i < STEPS; i++) {\n        Thing thing = scene(p);\n\n        if (abs(thing.dist) < EPS) {\n            vec3 n = normal(p);\n            vec3 light_dir = normalize(vec3(0., 1., 0.));\n\n            // Ambient lighting\n            color += contrib * (1. - thing.refl) * thing.color;\n\n            contrib *= thing.refl;\n\n            p -= 2. * EPS * dir; // back up a bit\n\n            // Reflection\n            dir -= 2. * dot(n, dir) * n;\n        }\n\n        p += thing.dist * dir;\n    }\n\n    return color;\n}\n\n#define PI 3.14159\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 sc = (fragCoord.xy/iResolution.x -\n               vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n\n    vec2 drag = (iMouse.xy - abs(iMouse.zw)) / iResolution.y;\n    vec2 drag_ang = vec2(1., 0.7) + 0.5 * PI * drag;\n    drag_ang.y = drag_ang.y > 0.? drag_ang.y : 0.;\n    vec3 cam_pos = 50. * vec3(\n        cos(drag_ang.x) * cos(drag_ang.y),\n        sin(drag_ang.y),\n        sin(drag_ang.x) * cos(drag_ang.y)\n    );\n\n    // Allow camera to go upside down.  Is there a better way to do this?\n    vec3 up = drag_ang.y > 0.5 * PI? vec3(0., -1., 0.) : vec3(0., 1., 0.);\n    vec3 forward = normalize(vec3(0., 0., 0.) - cam_pos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    mat3 cam = mat3(right, up, forward);\n\n    fragColor = vec4(raymarch(\n        cam_pos, normalize(cam * vec3(sc, 1.0))\n    ), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[802, 925, 974, 974, 1028], [1030, 1030, 1074, 1619, 2608], [2610, 2610, 2631, 2631, 3339], [3341, 3499, 3520, 3800, 4087], [4125, 4125, 4158, 4158, 4737], [4758, 4758, 4813, 4813, 5670]]}
{"id": "WtKGzm", "name": "Trees Part 2", "author": "GrisWoldDiablo", "description": "Following tutorial https://www.youtube.com/watch?v=XaiYKkxvrFM\nAdded ground movement", "tags": ["forest", "trees"], "likes": 7, "viewed": 149, "published": "Public", "date": "1578553922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur)\n{\n    float m = S(-blur, blur, p.y-yb);\n    m *= S(blur, -blur, p.y-yt);\n\t\n    p.x = abs(p.x);\n    //m *= S(blur, -blur, p.x-wb);\n    \n    float w = mix(wb,wt,(p.y-yb) / (yt-yb));\n    m *= S(blur, -blur, p.x-w);\n    \n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur)\n{\n    \n    float m = TaperBox(uv, .03, .03, -.05, .25, blur); // trunk\n    m += TaperBox(uv, .2, .1, .25, .5, blur); // canopy 1\n    m += TaperBox(uv, .15, .05, .5, .75, blur); // canopy 2\n    m += TaperBox(uv, .1, .0, .75, 1., blur); // canopy 3\n    \n    float shadow = TaperBox(uv - vec2(.2,0), .1, .5, .15, .25, blur);\n    shadow += TaperBox(uv + vec2(.25,0), .1, .5, .45, .5, blur);\n    shadow += TaperBox(uv - vec2(.25,0), .1, .5, .7, .75, blur);\n    col -= shadow*.8;\n    //m = 1.;\n    return vec4(col, m);\n}\n\nfloat GetHeight(float x)\n{\n    return sin(x*.232)+sin(x)*.73;\n}\n\nvec4 Layer(vec2 uv, float blur){\n\tvec4 col = vec4(0);\n\tfloat id = floor(uv.x);\n\tfloat n = fract(sin(id*234.12)*5263.3)*2.-1.;\n    float x = n*.3;\n    float y = GetHeight(uv.x);\n    float groundMod = ((sin(iTime)*.5)+2.)/2.;\n    float ground = S(blur, -blur,uv.y+y*groundMod); // ground\n    \n    col += ground;\n    y = GetHeight(id+.5+x);\n    \n    uv.x = fract(uv.x) -.5;\n    \n    vec4 tree = Tree((uv-vec2(x, -y*groundMod))*vec2(1,1.+n*.2), vec3(1), blur);\n    \n    //col.rg = uv;\n    \n    col = mix(col, tree, tree.a);\n    \n    col.a = max(ground, tree.a);\n    return col;\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(234.52, 657.23));\n    p += dot(p, p+466.123);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    float t = iTime*.3;\n    float blur = .005;\n    \n    \n    float twinkle = dot(length(sin(uv+t)), length(cos(uv*vec2(22,6.7)-t*3.)));\n    twinkle = sin(twinkle*10.)*.5+.5;\n    float stars = pow(Hash21(uv),100.)*twinkle;\n    vec4 col = vec4(stars);\n\n    float moon = S(.01, -.01, length(uv-vec2(.2,.3))-.05);\n    float moon2 = S(.01, -.01, length(uv-vec2(-.7,.2))-.20);\n    float moon3 = S(.01, -.01, length(uv-vec2(.2*sin(iTime)*2./3.+.2,.3*cos(iTime)/3.+.3))-.025);\n    \n    \n    col *= 1.-moon;\n    col *= 1.-moon2;\n    col *= 1.-moon3;\n    \n    moon *= S(-.01, .1, length(uv-vec2(.22,.33))-.02);\n    moon2 *= S(-.01, .1, length(uv-vec2(-.63,.24))-.12);\n    moon3 *= S(-.01, .1, length(uv-vec2(.22*sin(iTime)*2./3.+.22,.33*cos(iTime)/3.+.33))-.0015);\n    \n    \n    \n    col += moon;\n    col += moon2;\n    col += moon3;\n    \n    vec4 layer;\n    for(float i=0.; i<1.; i+=1./10.){\n        float scale = mix(30.,1., i);\n        blur = mix(.05,.005,i);\n    \tlayer = Layer(uv*scale+vec2(t+i*100.,i*2.)-M, blur);\n        layer.rgb *= (1.-i)*vec3(.9,.9,1);\n        col = mix(col, layer, layer.a);\n    }\n\tlayer = Layer(uv+vec2(t,1)-M, .07);\n    col = mix(col, layer*.1, layer.a);\n    \n    float thickness = 1./iResolution.y;\n    //if(abs(uv.x)<thickness) col.g = 1.;\n    //if(abs(uv.y)<thickness) col.r = 1.;\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 113, 113, 344], [346, 346, 388, 388, 901], [903, 903, 929, 929, 966], [968, 968, 1000, 1000, 1543], [1545, 1545, 1567, 1567, 1663], [1665, 1665, 1722, 1722, 3162]]}
{"id": "Wtt3WS", "name": "Deformation of Platonic solids", "author": "tomoe", "description": "platonic solids are made from reflection groups", "tags": ["imi202001"], "likes": 6, "viewed": 250, "published": "Public API", "date": "1578290761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define v1 vec3(1.0, 0.0, 0.0)\n#define v3 vec3(0.0, 0.0, 1.0)\nvec3 v2, w1, w2, w3;\nvec3 vtxP, edgN, faceN;\nfloat rad = 1.0;\nvoid init(float m){\n    v2 = vec3(-0.5, sqrt(0.75 - pow(cos(PI / m), 2.0)), -cos(PI / m));\n    float a = dot(cross(v1, v2), v3);\n    w1 = normalize(cross(v3, v2) / a);\n    w2 = normalize(cross(v1, v3) / a);\n    w3 = normalize(cross(v2, v1) / a);\n}\nfloat edgSDF(vec3 p, float t){\n    return max(abs(dot(p - vtxP, faceN)), abs(dot(p - vtxP, edgN))) - t;\n}\nfloat vtxSDF(vec3 p, float t){\n    return length(p - vtxP) - t;\n}\nfloat faceSDF(vec3 p, float t){\n    return dot(p - vtxP, faceN)- t;\n}\n#define fold(w)p = p - 2.0 * max(dot(w, p), 0.0) * w;\nfloat tetraSDF(vec3 p){\n    init(3.0);\n    fold(v1)fold(v3)fold(v2)fold(v3)fold(v1)fold(v2)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(edgSDF(p, 0.01), vtxSDF(p, 0.05));\n}\nfloat cubeSDF(vec3 p) {\n    init(4.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w3;\n    edgN = w2;\n    faceN = w1;\n    return edgSDF(p, 0.1);\n}\nfloat octaSDF(vec3 p) {\n    init(4.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(faceSDF(p, 0.06), edgSDF(p, 0.01));\n}\nfloat dodecaSDF(vec3 p) {\n    init(5.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w1;\n    edgN = w2;\n    faceN = w3;\n    return min(vtxSDF(p, 0.05), edgSDF(p, 0.002));\n}\nfloat icosaSDF(vec3 p) {\n    init(5.0);\n    fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)fold(v1)fold(v2)fold(v3)\n    vtxP = rad * w3;\n    edgN = w2;\n    faceN = w1;\n    return faceSDF(p, 0.0);\n}\nmat3 euler(float h, float p, float r) {\n    return mat3(\n        cos(r) * cos(h) - sin(r) * sin(p) * sin(h), - sin(r) * cos(p), cos(r) * sin(h) + sin(r) * sin(p) * cos(h),\n        sin(r) * cos(h) + cos(r) * sin(p) * sin(h), cos(r) * cos(p), sin(r) * sin(h) - cos(r) * sin(p) * cos(h),\n        - cos(p) * sin(h), sin(p), cos(p) * cos(h)\n    );\n}\n\n#define seq(v, s)d = mix(d, v, smoothstep(s - 0.3, s, t));\nfloat sceneSDF(vec3 p) {\n    float seqStep = 5.0;\n    float t = abs(mod(iTime * 0.5, seqStep * 2.0) - seqStep);\n    float d = tetraSDF(p);\n    seq(cubeSDF(p), 1.0)\n    seq(octaSDF(p), 2.0)\n    seq(dodecaSDF(p), 3.0)\n    seq(icosaSDF(p), 4.0)\n    return d;\n}\n\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n            sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p),\n            sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p),\n            sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p)\n        ));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    vec3 cSide = cross(cDir, cUp);\n\n    // light\n    vec3 lightPos = g * vec3(0.0, 1.0, 1.0);\n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    vec3 rPos = cPos ;    \n    // marching loop\n    for(int i = 0; i < 60; i ++ ) {\n        rPos += sceneSDF(rPos) * ray;\n    }\n\n    // collision detection\n    if (sceneSDF(rPos) < 0.001) {\n        vec3 normal = gradSDF(rPos);\n        float diff = clamp(dot(normalize(lightPos - rPos), normal), 0.01, 1.0);\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 189, 189, 417], [418, 418, 448, 448, 523], [524, 524, 554, 554, 589], [590, 590, 621, 621, 659], [714, 714, 737, 737, 909], [910, 910, 933, 933, 1106], [1107, 1107, 1130, 1130, 1327], [1328, 1328, 1353, 1353, 1598], [1599, 1599, 1623, 1623, 1845], [1846, 1846, 1885, 1885, 2190], [2251, 2251, 2275, 2275, 2508], [2510, 2510, 2532, 2532, 2771], [2772, 2772, 2826, 2851, 3812]]}
{"id": "wtt3WX", "name": "Murakami Infinity", "author": "PixelPhil", "description": "An infinite field of smiling flowers based on the artwork of Takeshi Murakami.\nI hope this brings you joy.\n\nMusic : Towa No Hana (Flowers of Eternity) by Yoko Ishida", "tags": ["procedural", "art", "flowers", "takashi", "murakami"], "likes": 38, "viewed": 933, "published": "Public API", "date": "1577990695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Murakami Infinity by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// I have recently grown a fascination towards the art of Takashi Murakami, \n// especially his colorful flower series.\n// His vision is, not unlike Andy Warhol, that art can be mass produced with\n// endless variations of a basic concept. This led me to the thinking that, \n// at the extreme, these compositions could be auto-generated.\n//\n// I tried to reproduce Murakami's compositions following rules that are as true as\n// possible to the reference painting.\n//\n// I stuck with the black & white eyes although they are red and blue on most of the\n// paintings because I find them more pleasing this way. I might make a variation someday.\n//\n// The flower is re-created with a serie of ellipses in polar coordinates.\n//\n// I hope this brings you joy.\n\n// p.s : I just realized mhnewman attempted something similar, oh well... ;)\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n// An ellipse signed distance function by iq\n// https://www.iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = vec2(abs(z));\n    \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n\n// rotates pos to align the up vector towards up\nvec2 rotUp(vec2 pos, vec2 up)\n{\n    vec2 left = vec2(-up.y, up.x);\n    return left * pos.x + up * pos.y;\n}\n\nconst float pi = 3.1415926;\nconst float pi2 = 6.2831853;\nconst float quadrant = pi / 6.0;\n\nconst float blackLevel = 0.3; // True black is too aggressive\n\n\n\n// The mouth is the intersection of two ellipses, I traced them in photoshop to\n// compute the right radii and offsets\nfloat mouthDst(vec2 uv)\n{\n    return max(sdEllipse(uv - vec2(0.0, -0.17), vec2(0.30, 0.2055)),\n               sdEllipse(uv - vec2(0.0,  0.07), vec2(0.14, 0.2055)));\n}\n\n// For the eye, I use simpler circle distance maths in a scales and rotated space\n// as I don't need an accurate distance function to create an outline\nvec4 eye(vec2 uv, vec2 up, vec2 spot1, vec2 spot2, float scale)\n{\n    uv = rotUp(uv, up);\n    uv.x *= 1.5;\n    \n    float len = length(uv);\n    float len2 = length(uv + spot1);// vec2(0.010, 0.025));\n    float len3 = length(uv + spot2);// vec2(-0.005, -0.017));\n    \n    float aa = scale * 4.0 / iResolution.x;\n    \n    vec4 eye;\n    \n    eye.a = S(0.04 + aa, 0.04, len);\n    \n    eye.rgb = vec3(S(0.014, 0.014 - aa, len2) + S(0.02, 0.02 - aa, len3) + blackLevel);\n    \n    return eye;\n}\n\nconst float cRatio = 1.0 / 255.0;\n\n// I wanted the color palette to be true to the 16 hue rainbow used\n// by Murakami but I didn't manage to reproduce the orange-yellow-green part\n// using simple maths so I defaulted to a palette. Then I realized I couldn't target\n// Webgl < 3.0 (Wich was one of my objectives) with array constructor so I decided\n// to build a function selecting the right color with a dichotomic approch in hope\n// that the compiler will make a decent job of optimizing all those branches.\nvec3 palette(float id)\n{\n\tif (id < 6.0)\n    {\n        //[0 - 5]\n        if (id < 3.0)\n        {   //[0 - 2]\n            if (id < 1.0) return vec3(181.0, 23.0, 118.0) * cRatio;\n            else if (id < 2.0) return vec3(225.0, 27.0, 104.0) * cRatio;\n            else return vec3(230.0, 40.0, 24.0) * cRatio;\n        }\n        else\n        {   //[3 - 5]\n            if (id < 4.0) return vec3(240.0, 110.0, 14.0) * cRatio;\n            else if (id < 5.0) return vec3(253.0, 195.0, 2.0) * cRatio;\n            else return vec3(253.0, 241.0, 121.0) * cRatio;\n        }\n    }\n    else\n    {   //[6 - 11]\n        if (id < 9.0)\n        {   //[6 - 8]\n            if (id < 7.0) return vec3(167.0, 202.0, 56.0) * cRatio;\n            else if (id < 8.0) return  vec3(0.0, 152.0, 69.0) * cRatio;\n            else return vec3(2.0, 170.0, 179.0) * cRatio;\n        }\n        else\n        {   //[9 - 11] The darker color are at the end to be avoided by mod\n            if (id < 10.0) return vec3(25.0, 186.0, 240.0) * cRatio;\n            else if (id < 11.0) return  vec3(0.0, 98.0, 171.0) * cRatio;\n            else return vec3(40.0, 49.0, 118.0) * cRatio;\n        }\n    }\n}\n\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n// That's where the meat of the shader is, drawing a flower\nvec4 flower(vec2 uv, vec2 id, float minSz, float maxSz, float scale)\n{\n    vec4 rnd = N24(id);//mod(id.x, 300.0) * mod(id.y, 500.0) * 13.56);\n    \n    float rdScale = mix(minSz, maxSz, rnd.z);\n    \n    scale *= rdScale; // The border thickness & AA is scale-independant\n    \n    uv.xy *= rdScale;\n    \n    uv.x += 0.1 + rnd.x * 0.5;\n    uv.y += 0.25 + rnd.y * 0.2;\n    uv.y += sin(iTime * mix(0.4, 1.0, rnd.y) + (rnd.w * 45.0)) * 0.2;\n\n    \n    float aa2 = scale * 3.0 / iResolution.x;\n    \n    float centerDst = length(uv);\n    \n    if (centerDst > 0.5) return vec4(0.0);\n    \n    float edge; // Mask for the outline edge\n    \n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0); // Underlying color\n   \n    \n    float thick = 0.002 * scale;\n    \n    if (centerDst < 0.2)\n    {\n        //Face part\n        \n        float thres = 0.2 - thick;\n        \n        // inner part of edge circle surrounding the head\n        edge =  S(thres, thres - aa2, centerDst);\n        \n        float mouth = mouthDst(uv);\n        \n        // edge of the mouth\n        edge *= S(thick, thick + aa2, abs(mouth));\n        \n        // face color\n        float faceRnd = fract(rnd.x * 45.0 + rnd.y * 23.45);\n        if (faceRnd < 0.5) \n        {\n            // Flowers with classic yellow / red faces\n        \tcolor.rgb = (mouth < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 0.0); \n        }\n        else\n        {\n            // Flowers with white face / random color mouth\n            float colId = mod(faceRnd * 545.456, 11.0);\n            color.rgb = (mouth < 0.0) ? palette(colId) : vec3(1.0); \n        }\n        \n        // Eyes\n        vec4 eyeImg;\n        if (uv.x > 0.0)\n        {\n           eyeImg = eye(uv - vec2(0.075, 0.095), vec2(-0.7, 1.2),\n                       vec2(0.007, 0.025), vec2(-0.004, -0.019), scale);\n        }\n        else   \n        {\n           eyeImg = eye(uv - vec2(-0.075, 0.095), vec2(0.7, 1.2),\n                       vec2(0.024, 0.010), vec2(-0.016, -0.009), scale);\n        }\n\n        color.rgb = mix(color.rgb, eyeImg.rgb, eyeImg.a);\n    }\n    else\n    {\n        float rot = iTime * rnd.y * 0.5;\n        float angle = fract((atan(uv.x, uv.y) + rot) / pi2);\n    \n        float section = angle * 12.0;\n        float sectionId = floor(section);\n        \n        if (rdScale < 0.86 && rnd.w > 0.55)\n        {\n           // Rainbow flower\n           color.rgb = palette(sectionId);//mod(sectionId + (rnd.x + rnd.y) * 345.456, 12.0));\n        }\n        else if (rnd.y > 0.05)\n        {\n            //Alternating flower\n            if (mod(sectionId, 2.0) == 0.0)\n            {\n                // Color 1\n                float colId = mod((rnd.x + rnd.y) * 345.456, 10.0);\n                color.rgb = palette(colId);\n            }\n            else if (rnd.x > 0.75)\n            {\n                // Color 2\n                float colId = mod((rnd.w + rnd.z) * 545.456, 11.0);\n                color.rgb = palette(colId);\n            }\n            // else, Color2 is white by default\n        }\n\t\t// else, fully white petals\n        \n        if (centerDst < 0.36)\n        {\n            //intermediate part, concentric bars\n            \n            float sectionX = fract(section);\n            float edgeDist = 0.5 - abs(sectionX - 0.5);\n            \n            edgeDist *= centerDst; // Untaper bar space so bars have constant thickness\n            \n            float aa = scale * 7.0 / iResolution.x;\n            float bar = thick * 1.7;\n            edge = S(bar, bar + aa, edgeDist);\n\n            // outer part of edge circle surrounding the head\n            float thres = 0.2 + thick;\n            float head = S(thres, thres + aa2, centerDst);\n            edge *= head;\n        }\n        else\n        {\n            // Petal tips are actually ellipses, they could have been approximated them with\n            // circles but I didn't because I have OCD and I needed the ellipse SDF \n            // for the mouth anyways ;)\n            \n            // Angle to the center of the quadrant\n            float quadAngle = (sectionId + 0.5) * quadrant - rot + pi; \n\n            // Center of the ellipse\n            vec2 petalUp = vec2(-sin(quadAngle), -cos(quadAngle));\n            vec2 petalCenter = petalUp * 0.36;\n\n            // Rotation of the ellipse basis\n            vec2 petalSpace = rotUp(uv - petalCenter, petalUp);\n\n            // Signed distance function of the ellipse\n            float petalDst = sdEllipse(petalSpace, vec2(0.0944, 0.09));\n\n            //border edge and alpha mask\n            float borderIn = S(thick + aa2, thick, petalDst);\n            float borderOut = S(-thick, -thick - aa2, petalDst);\n\n            edge = (borderOut);\n            \n            color.a = borderIn;\n        }\n    }\n    \n    color.rgb = mix(vec3(blackLevel), color.rgb,edge);\n    \n    return color;\n}\n\n\nvec3 flowerLayer(vec2 uv, vec3 bg, float minSz, float maxSz, float scale)\n{\n    vec2 cellId = floor(uv);\n    vec2 cellUv = fract(uv) - vec2(0.5);\n   \n    //Check only 4 cells because the flower function is rather costly\n    for (float x = 0.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = 0.0; y <= 1.0; y += 1.0)\n    \t{\n            vec2 offset = vec2(x, y);\n            \n            vec4 f = flower(cellUv - offset, cellId + offset, minSz, maxSz, scale);\n    \t\tbg = mix(bg, f.rgb, f.a);\n    \t}\n    }\n    \n    return bg;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    float sc = 1.65 + cos(iTime* 0.1) * 0.25;\n    \n    uv.xy *= sc;\n    \n    uv.x += 35.9;\n    uv.y += 45.0;\n    \n \n    float scroll = iTime * 0.25;\n    \n\n   \tfloat t = iTime * 0.23;\n    vec3 col = vec3(0.8) + vec3(0.2) * sin(t + vec3(0.0, pi * 0.5, pi));\n    \n    col = flowerLayer(uv * 4.0 + vec2(scroll, -scroll * 0.3 + 59.0), col, 0.8, 1.0, 2.0 * sc);\n    col = flowerLayer(uv * 3.0 + vec2(scroll, -scroll * 0.2 + 59.0), col, 0.7, 1.25, 1.5 * sc);\n    col = flowerLayer(uv * 2.0 + vec2(scroll, -scroll * 0.1 + 345.0), col, 0.8, 2.0, 1.0 * sc);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ll2GRz", "previewfilepath": "https://soundcloud.com/anime-easy/ai-yori-aoshi-towa-no-hana", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/anime-easy/ai-yori-aoshi-towa-no-hana", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtt3WX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1047, 1163, 1205, 1205, 2351], [2354, 2403, 2434, 2434, 2509], [2667, 2786, 2811, 2811, 2952], [2954, 3106, 3171, 3171, 3593], [3630, 4104, 4128, 4128, 5258], [5262, 5287, 5305, 5305, 5446], [5448, 5508, 5578, 5578, 10302], [10305, 10305, 10380, 10380, 10831], [10835, 10835, 10892, 10892, 11574]]}
{"id": "wttGDs", "name": "Cruzv03", "author": "jorge2017a1", "description": "Cruzv03", "tags": ["cruzv03"], "likes": 1, "viewed": 36, "published": "Public", "date": "1578021388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Sphere(vec3 p, vec3 o, float r){\n        return length(p-o)-r;  \n}\n \nfloat Plane(vec3 p){\n\treturn p.y;\t\n}\n\nvec3 DR(vec3 p,vec3 q){\n\treturn mod(p,q)-q/2.;\n}\n\n\n///----------------------------\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///---------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n///-------------------------------\n\nfloat h(vec3 p) {\n   \n    float planeDist = p.y;\n    vec2 res;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    d=1000.0; \n    p.x=p.x+2.0;\n  \n    \n    \n    //d=min(d,planeDist);\n    \n    \n    //repetir\n    if (p.y>60.0) \n    {\n    \tp.y=mod(p.y,20.0) -6.0;\n     }       \n    p.z=mod(p.z,12.0) -6.0;\n    p.x=mod(p.x,12.0) -5.0;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,6.5,5.0),vec3(0.8,7.0,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,10.0,4.6),vec3(4.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,10.0,4.6),vec3(3.0,0.4,1.0));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,1.0,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.5,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.0,5.0),vec3(4.5,0.5,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    \n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 e=vec2(.001,0);\n\treturn normalize(vec3(\n\t\th(p+e.xyy)-h(p-e.xyy),\n\t\th(p+e.yxy)-h(p-e.yxy),\n\t\th(p+e.yyx)-h(p-e.yyx)\n\t));\n}\n\nfloat AO(vec3 p,vec3 q){\t\t\t// AO at point p with normal q\n\tfloat o=0.,s=1.,r,d;\n    \tfor(float i=0.;i<5.;i++){\n\t\tr=.01+.12*i/4.;\n\t\tvec3 a=q*r+p;\n\t\td=h(a);\n\t\to+=-(d-r)*s;\n\t\ts*=.95;\n    \t}\n    \treturn clamp(1.-3.*o,0.,1.);   \n}\n\nfloat SH(vec3 p, vec3 q){\t\t\t// Calculate shadow amount: p=intersection point; q=light direction\n\tvec3 r = p + q*.01;\n\tfloat d;\n\tfor(int i=0; i<16; i++) {\n\t\td = h(r);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tr += q * d;\t\t\t\t// March along!\n\t}\n\tif (d < 0.001)\n\t\treturn 0.1;\n\telse\n\t\treturn 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\t\n\t//vec3 ro = vec3(1.4, 1.6, -4+iTime);\t\t\t// Cam pos (ray origin)\n    //////vec3 ro = vec3(10.4, 4.6, -24.0+iTime*2.0);\t\t\t// Cam pos (ray origin)\n    //vec3 ro = vec3(1.4, 4.6, -12.0);\t\n    \n    vec3 ro = vec3(0.4, 4.6, -10.0+iTime*2.0);\t\t\n    \n    \n\tvec3 up = vec3(0, 1, 0);\t\t\t// Cam orientation vecs\n\tvec3 fd = vec3(0, 0, 1);\n\tvec3 right = -cross(fd,up);\n\t\n\tfloat fov=1.8;\n\tvec3 rd = normalize(right*uv.x + up*uv.y + fd*fov);\t// Ray dir \n\t\n\tvec3 p = ro;\t\t\t\t\t// Current test position\n\tfloat d;\t\t\t\t\t// Distance of p from surface\n\tfor(int i=0; i<128; i++) {\n\t\td = h(p);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tp += rd * d;\t\t\t\t// March along!\n\t}\n\t\n    \n    \n    \n    \n\tif (d < .001) {\t\t\t\t\t// We hit something!\n\t\t//vec3 lp = vec3(10,10,-10);\t\t// Light position\n        //vec3 lp = vec3(0.5,5.,-10);\t\t// Light position\n        vec3 lp = vec3(0.0,100.,iTime);\t\t// Light position\n        \n\t\tvec3 ld = normalize(lp-p);\t\t// Light direction\n\t\tvec3 n = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse = dot(n,ld);\t\t// Diffuse amount\n\t\tvec3 c = vec3(.8,.9,1) * diffuse * AO(p,n) * SH(p,ld);\n\t\tfragColor = vec4(c, 1);\n\t\n        /*\n       \n        vec3 lp1 = vec3(10.0,5.,iTime-23.0);\t\t// Light position\n        \n\t\tvec3 ld1 = normalize(lp1-p);\t\t// Light direction\n\t\t//vec3 n1 = GetNormal(p); \t\t\t// Normal\n        vec3 n1 =n;\n\t\tfloat diffuse1 = dot(n1,ld1);\t\t// Diffuse amount\n       \n\t\t//vec3 c1 = vec3(.3,.5,.8) * diffuse1 * AO(p,n1) * SH(p,ld1);\n        vec3 c1 = vec3(.8,.9,1)  * diffuse1 * AO(p,n1) * SH(p,ld1);\n\t\t\n\t\tfragColor =( vec4(c, 1)+vec4(c1, 1))/1.5;\n       */\n        \n        \n\t} else\t\t\t\t\t\t\n\t\t//fragColor = vec4(uv.x / 2., uv.y * 1.4, 1, 1);\n    \tfragColor = vec4(uv.x/2.0 , uv.y/2.0, 1.0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 73], [76, 76, 96, 96, 112], [114, 114, 137, 137, 162], [200, 217, 250, 250, 315], [318, 336, 372, 372, 441], [442, 457, 488, 488, 638], [639, 659, 695, 695, 782], [783, 799, 831, 859, 920], [923, 933, 969, 969, 1242], [1244, 1293, 1339, 1339, 1371], [1373, 1373, 1415, 1415, 1447], [1449, 1449, 1496, 1496, 1529], [1532, 1532, 1561, 1561, 1687], [1689, 1798, 1835, 1835, 1870], [1874, 1910, 1927, 1927, 3119], [3121, 3121, 3145, 3145, 3272], [3274, 3274, 3298, 3331, 3499], [3501, 3501, 3526, 3596, 3779], [3781, 3781, 3838, 3838, 5584]]}
{"id": "WttSR4", "name": "Tunnel warping", "author": "Roninkoi", "description": "Playing around with mod", "tags": ["tunnel", "warping"], "likes": 2, "viewed": 155, "published": "Public API", "date": "1580503232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nfloat f(vec2 u)\n{\n    return mod(abs(u.y*sin(iTime*0.21) + \n                   u.x*u.y*sin(iTime*0.13+2.) + \n                   u.y*u.y*sin(iTime*0.14+3.) + \n                   u.x*u.x*sin(iTime*0.22+4.)), 0.3*length(u*u*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    uv *= 2.5;\n        \n    vec3 ca = (iTime +uv.x+vec3(0,2.*PI/3.,4.*PI/3.));\n    ca.g = 0.;\n    \n    vec3 col = 0.525 + 0.625*cos(ca);\n    col /= exp(length(uv*uv));\n    col = col * 10.;\n    \n    float p = 2.0 / iResolution.x;\n    \n    float ssx = smoothstep(uv.x-p, uv.x+p, uv.x);\n    float ssy = smoothstep(uv.y-p, uv.y+p, uv.y);\n    \n    vec3 col1 = col * mix(vec3(f(vec2(uv.x-p, uv.y))), vec3(f(vec2(uv.x+p, uv.y))), ssx);\n    vec3 col2 = col * mix(vec3(f(vec2(uv.x, uv.y-p))), vec3(f(vec2(uv.x, uv.y+p))), ssy);\n    vec3 col3 = col * mix(vec3(f(vec2(uv.x-p, uv.y-p))), vec3(f(vec2(uv.x+p, uv.y+p))), sqrt(ssx*ssx + ssy*ssy));\n    vec3 col4 = col * mix(vec3(f(vec2(uv.x-p, uv.y+p))), vec3(f(vec2(uv.x+p, uv.y-p))), sqrt(ssx*ssx + (1.-ssy)*(1.-ssy)));\n    \n    col = (col1 + col2 + col3 + col4) * 0.25;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 40, 40, 250], [252, 252, 309, 309, 1249]]}
{"id": "WttSzn", "name": "Psychedelic Spheres", "author": "kstyler", "description": "Practicing phong shading by making spheres that morph together with other spheres.", "tags": ["phong", "raymarch", "spheres"], "likes": 2, "viewed": 218, "published": "Public API", "date": "1580291549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAXD = 400;\nconst float EPSI  =0.0001;\nint matId = 0;\nmat2 rotate(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat sm( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p,float size){\n    return length(p)-size;\n}\n\nfloat map(vec3 p,bool id){\n    float smo = 2.;\n    float sphere = sdSphere(p,1.);\n    float sphere2 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere3 = sdSphere(p+vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere4 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere5 = sdSphere(p+vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere6 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere7 = sdSphere(p+vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere8 = sdSphere(p+vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere9 = sdSphere(p+vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    float sphere10 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere11 = sdSphere(p-vec3(sin(iTime)*2.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere12 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere13 = sdSphere(p-vec3(sin(iTime)*2.,cos(iTime)*4.,cos(iTime)*4.),0.4);\n    float sphere14 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,sin(iTime)*2.),0.4);\n    float sphere15 = sdSphere(p-vec3(cos(iTime)*4.,sin(iTime)*2.,cos(iTime)*4.),0.4);\n    float sphere16 = sdSphere(p-vec3(cos(iTime)*4.,cos(iTime)*4.,sin(iTime)*2.),0.4);\n    float sphere17 = sdSphere(p-vec3(sin(iTime)*4.,sin(iTime)*4.,sin(iTime)*4.),0.4);\n    \n\n    float plane =1.-(length(p)-550.);\n    float sp = sm(sphere9,sm(sphere8,sm(sphere7,sm(sphere6,sm(sphere5,sm(sphere4,sm(sphere3,sm(sphere2,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float sp2 = sm(sphere17,sm(sphere16,sm(sphere15,sm(sphere14,sm(sphere13,sm(sphere12,sm(sphere11,sm(sphere10,min(sphere,plane),smo),smo),smo),smo),smo),smo),smo),smo);\n    float mn = min(sp,sp2);\n    if(id){\n       \n        if(mn == plane){\n            matId = 3;\n        }\n        else{\n            matId = 2;\n        }\n    }\n    return  mn;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(EPSI,0);\n    return normalize(vec3(map(p+e.xyy,false)-map(p-e.xyy,false),\n                            map(p+e.yxy,false)-map(p-e.yxy,false),\n                            map(p+e.yyx,false)-map(p-e.yyx,false)));\n}\nvec3 rayMarch(vec3 ro,vec3 rd, bool id){\n    \n    float tot = 0.;\n    float dst = 0.;\n    vec3 p;\n    for(int i = 0; i<MAXD; i++){\n        p = ro+rd*tot;\n        dst = map(p,id);\n        tot+=dst;\n        if(dst<EPSI || tot > float(MAXD)){\n            break;\n        }\n    }\n    if(dst > EPSI){\n       // matId = 1;\n    }\n    return p;\n}\nvec3 light(vec3 p,vec3 ro){\n    vec3 lightCol = vec3(1);\n    vec3 objCol = vec3(0);\n    vec3 lightPos = vec3(10,10,12);\n    vec3 viewDir = normalize(ro-p);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n    vec3 reflectDir = reflect(-l,n);\n    float diff = max(dot(l,n),0.);\n    float spec = pow(max(dot(viewDir,reflectDir),0.),25.);\n    float spcStr = 3.;    \n    float ambi = 0.45;\n    \n\n    \n    bool rm = length(rayMarch(p+n*EPSI*2.,l,false))<length(lightPos-p);\n    if(rm){\n        diff *= 0.1;\n    }\n    if(matId == 2){\n        objCol = vec3(1,0.9,0.);\n    }\n    \n    else if(matId == 3){\n    \n        objCol = vec3(0,0,0);\n    }\n    vec3 diffuse = lightCol*diff;\n    vec3 ambient = ambi*lightCol;    \n    vec3 specular = spcStr*spec*lightCol;\n    return (ambient+diffuse+specular)*objCol;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5 * iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0,0,-20);\n    vec3 rd = normalize(vec3(uv,1.));\n    ro.zy*=rotate(iTime*2.);\n    rd.zy*=rotate(iTime*2.);\n    ro.xz*=rotate(iTime);\n    rd.xz*=rotate(iTime);\n    \n    vec3 p = rayMarch(ro,rd,true);\n    vec3 color = (light(p,ro));\n    if(matId == 1){\n        color = vec3(0);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 151], [153, 153, 194, 194, 293], [295, 295, 329, 329, 358], [360, 360, 386, 386, 2363], [2365, 2365, 2385, 2385, 2615], [2616, 2616, 2656, 2656, 2953], [2954, 2954, 2981, 2981, 3766], [3770, 3770, 3824, 3824, 4224]]}
{"id": "WttXR4", "name": "return of the obra dither", "author": "JackSolace", "description": "Basic Raymarch with a dithering effect to show basis of most basic \"toon\" shaders", "tags": ["ray", "sphere", "dither", "march", "learn"], "likes": 4, "viewed": 121, "published": "Public", "date": "1580504742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Jan 2020\n//Basic Raymarch with a dithering effect to show basis of most basic \"toon\" shaders\n\n\n//from the Sphere example\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{//this one is simple since there is only 1 sdf to check\n    float obj_dist = distance_from_sphere(p, vec3(0.0,0.0,0.0), 0.3);\n\n    return obj_dist;\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    //take small steps to find normal\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) );  \n}\n\n//macintosh-like toon dithering\n//Note AA will break dithering\nfloat calculate_dither(vec3 normal, vec3 light_direction, vec2 frag){\n    //constants for dither thresholds (play with these values)\n    float quarter_dither = 0.6;\n    float half_dither = 0.3;\n    float full_dither = -0.1;\n    \n    //get integer pixel coords\n    int x = int(frag.x);\n    int y = int(frag.y);\n    //similar to diffuse calculations\n\tfloat ang = dot(normal,light_direction);\n    \n    //series of threshold checks\n    if (ang > full_dither) {\n        //get checkered coords\n        int rx = x % 2;\n        int ry = y % 2;\n        if (ang > half_dither){\n            if (ang > quarter_dither){\n            \treturn 1.0;\n            }\n        \tif (rx == 1 && ry == 1){//1 in 4 pixels passes this check\n        \t\treturn 0.0;\n        \t}\n        \treturn 1.0;\n        }\n        if (rx == ry){//1 in 2 pixels passes this check\n        \treturn 0.0;\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // camera movement from https://www.shadertoy.com/view/tdXGWr\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color (background)\n    vec3 total = vec3(0.25);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.0; //max march depth\n    float t = 0.0;//current depth\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        float h = map_the_world(pos);\n        //if we hit something break\n        if( h<0.0001 || t>tmax ) break;\n        //step forward\n        t += h;\n    }\n        \n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {\n        //postion of intersect\n        vec3 pos = ray_origin + t*ray_direction;\n        //normal at surface\n        vec3 normal = calculate_normal(pos);\n        // dither value\n        float dither = calculate_dither(normal,normalize(vec3(0.5,0.5,0.5)-pos),fragCoord);\n        //ambient sphere value\n        float ambient = 0.1;\n        //combine it all\n        color = 0.25*vec3(0.2,0.3,0.4)*ambient + 0.75*vec3(0.8,0.7,0.5)*dither;\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 133, 192, 192, 224], [227, 401, 433, 488, 582], [585, 634, 672, 672, 975], [977, 1040, 1109, 1172, 1947], [1949, 1949, 2006, 2073, 3715]]}
{"id": "wttXRr", "name": "Globules", "author": "samhattangady", "description": "Just playing around with the smooth blending functions, and a little bit of randomness... kinda.\nReally need to work on lighting though...", "tags": ["smoothblending"], "likes": 2, "viewed": 205, "published": "Public API", "date": "1580313225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nday003: Globules\n29 Jan 2020\n\nJust playing around with the smooth blending functions,\nand a little bit of randomness... kinda.\nReally need to work on lighting though...\n*/\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\n\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\n\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\n\nfloat smin(float d1, float d2, float k) {\n    float res = exp2( -k*d1 ) + exp2( -k*d2 );\n    return -log2( res )/k;\n}\n\n\nfloat distanceField(vec3 position) {\n    float d = sdfSphere(position, vec3(0.35*sin(iTime*0.5), 0.2*cos(iTime*0.8), 0.0), 0.55);\n    \n    vec3 moon = vec3(0.95*cos(iTime*0.4), 0.85*sin(iTime*1.4), -0.85*cos(iTime));\n    float d1 = sdfSphere(position, moon, 0.2);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, vec3(0.95*cos(iTime*2.3), 0.95*sin(iTime*3.4), 0.95*cos(iTime*1.5)), 0.05);\n    d = smin(d, d1, 3.0);\n    \n    d1 = sdfSphere(position, moon+vec3(0.35*cos(iTime*1.3), 0.49*sin(iTime*2.4), 0.35*cos(iTime*2.8)), 0.01);\n    d = smin(d, d1, 8.0);\n    \n    float d2 = sdfPlane(position, vec4(0.1*sin(iTime*0.2), 1.0, 0.07*sin(iTime*0.3), 0.75+0.2*sin(iTime*0.3)));\n\n    return smin(d2, d, 8.0);\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p)+ distanceField(p+vec3(h,0.0,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,h,0.0)),\n                           -distanceField(p)+ distanceField(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = distanceField(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, -6.0);\n    //vec3 cameraOrientation = vec3(0.0, 0.0, 0.0);\n    vec3 planePosition = vec3(p, -5.0);\n    // planePosition = rotate3D(planePosition, vec3(0.0, 0.0, iTime));\n    \n    vec3 lookingDirection = (planePosition - cameraPosition);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = normalize(vec3(1.0*sin(iTime*0.5), 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    float dist = raymarch(lookingDirection, planePosition);\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        color = vec3(0.05, 0.105, 0.305);\n    \tvec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        color += 0.4* smoothstep(0.3, 1.0, light);\n    }\n    \n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 175, 217, 217, 662], [664, 664, 723, 723, 773], [775, 775, 816, 816, 868], [870, 870, 911, 911, 987], [990, 990, 1026, 1026, 1705], [1707, 1707, 1735, 1967, 2269], [2271, 2271, 2316, 2605, 2953], [2955, 2955, 3012, 3055, 4192]]}
{"id": "WttXzH", "name": "Playing with vectors", "author": "opheliagame", "description": "The normalized pixel coordinates are funny.", "tags": ["colors", "vectors"], "likes": 0, "viewed": 50, "published": "Public", "date": "1580402449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t//uv += 0.5;\n    uv *= 30.0;\n    \n    vec3 a = 0.5 * sin(iTime + uv.xxx);\n \tvec3 b = 0.5 * sin(iTime + uv.yyy);\n    \n    vec3 c = 0.5 * sin(iTime + uv.xyy); //similar to e\n    vec3 e = 0.5 * sin(iTime + uv.yxx);\n    \n\tvec3 d = 0.5 * sin(iTime + uv.xxy); //similar to g\n    vec3 g = 0.5 * sin(iTime + uv.yyx);\n    \t \n    vec3 f = 0.5 * sin(iTime + uv.yxy); //similar to h\n    vec3 h = 0.5 * sin(iTime + uv.xyx);\n    \n    //adding: a+b, c+e, d+g, f+h give same result\n    //similarly for subtracting the groups, although diff for each group\n    //multiplying, same as addition\n    //dividing, same as subtraction\n    \n    //b, c, d, f\n    //a, e, g, h\n    \n    // Output to screen\n    fragColor = vec4(2.0*c-2.0*e,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 868]]}
{"id": "WtV3D1", "name": "sdCylinder-doble Sponge", "author": "jorge2017a1", "description": "sdCylinder-doble Sponge", "tags": ["sdcylinderdoblesponge"], "likes": 2, "viewed": 48, "published": "Public", "date": "1578846440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia 60442.0\n\n\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//---------------------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//----------------------------------------------------------\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n    float  distToCapsule =sdCylinder( p, vec2(1.0,1.0) );\n    float  distToCapsule2 =sdCylinder( p.yzx, vec2(1.0,2.0) );\n    d= unionSDF(distToCapsule,distToCapsule2);\n    \n    //d=distToCapsule;\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 4; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 47, 47, 73], [75, 75, 104, 104, 190], [192, 192, 221, 221, 297], [300, 300, 382, 382, 613], [616, 616, 652, 652, 755], [757, 817, 863, 863, 895], [897, 897, 939, 939, 971], [973, 973, 1020, 1020, 1053], [1116, 1291, 1314, 1314, 1452], [1455, 1455, 1477, 1477, 1547], [1549, 1549, 1568, 1568, 2149], [2151, 2151, 2172, 2172, 2405], [2407, 2407, 2440, 2440, 2723], [2725, 2725, 2782, 2782, 3162]]}
{"id": "WtV3Dd", "name": "Trippy Visualizer", "author": "MinimilisticBits", "description": "My first attempt at making an audio visualizer.", "tags": ["audio", "trippy"], "likes": 3, "viewed": 100, "published": "Public", "date": "1580211298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//const float pi = 3.14159265358979323846264338327950288419716939937510; //just pi\nconst float ni = 3.0778979877877658472;\n\n/*vec2 rot(vec2 a, float c){\nfloat g = c*pi/180.0;\nvec2 b = vec2(cos(g),sin(g));        \nreturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}*/\n\nvec2 rot(vec2 a, float c){ //mine\n//acos 1 to -1 = 0 to pi\nfloat p = length(a);\na = normalize(a);\nfloat ang_x = atan(a.y,a.x);\nang_x +=  c*ni/180.0;\nreturn vec2(p*cos(ang_x), p*sin(ang_x));    \n}\n\n\nfloat box(vec3 p, vec3 s){//mine\nvec3 a = abs(p)-s;\nreturn max(max(a.x, a.y),a.z);\n}\n\n/*\nvec3 r(vec3 p, vec3 c){//not originally thought by me\nreturn mod(p,c)-0.5*c; \n}\n*/\n\nvec3 r(vec3 p, vec3 c){ \nreturn ((p/c - floor(p/c))*c)-0.5*c;\n}\n\n\nfloat dis(vec3 p){ \nreturn min(length(mod(p,8.0)-4.0)-1.3,\n          box(r(vec3(0.0, -4.0, 0.0)-p, vec3(20.0,20.0,3.0)), vec3(40.0,0.5,0.5))\n          );\n}\n\nbool trac(out vec3 p, vec3 d, out float dd){\n    for(int i = 0; i < 40; i++){\n        dd = dis(p);\n        if(dd < 0.01){return true;}\n        p+=d*dd;\n    }\n    return false;\n}\n\n/*\nvec3 norm(vec3 p){//not originally by me\nvec2 k = vec2(0.1,0.0);\nreturn normalize(\nvec3(\ndis(p+k.xyy)-dis(p-k.xyy),\ndis(p+k.yxy)-dis(p-k.yxy),\ndis(p+k.yyx)-dis(p-k.yyx)\n));\n}\n*/\n\nvec3 norm(vec3 p, float dist){ \n    return normalize(vec3(dist-dis(vec3(p.x-0.1,p.yz)),dist-dis(vec3(p.x,p.y-0.1,p.z)),\n                          dist-dis(vec3(p.xy,p.z-0.1))));\n}\n\n\n\nvec3 shadow(vec3 p, vec3 lig){\n    vec3 d = normalize(lig - p);\n    float dist,lgg;\n    for(int i = 0; i < 40; i++){\n     lgg = length(lig-p)-1.3;\n     dist = min(lgg, dis(p));\n     if(dist < 0.01)break;  \n     p+=d*dist;    \n    } \n    if(dist < 0.01 && dist == lgg){\n    return vec3(1.0);\n    }\n    \n    vec3 n = norm(p,dist);\n    float ang = 1.0-dot(-d,n);\n    vec3 c = vec3((cos(iTime-ang*2.0)+1.0)*0.5, (sin(iTime+ang*12.0)+1.0)*0.5, 0.5);\n    return c*ang;\n}\n\nvec3 volumetrics(vec3 prevp, vec3 p, vec3 lig){\n    const int iter = 7;\n    vec3 dp = (p-prevp)/float(iter);\n    \n    vec3 vcol;\n    \n    for(int i = 0; i < iter; i++){\n    vcol += shadow(prevp+dp*float(i+1), lig);\n    }\n    \n    return vcol/float(iter);\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0) - a ,2.0))/(ni*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sp = texture(iChannel0, vec2(0.0 / 512.0, 0.0)).x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= vec2(2.0+sp*2.0);\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    \n    d = abs(-vec3(rot(d.xz, iTime*6.0),d.y));\n    d.yz = rot(d.yz, cos(iTime*0.4 - sp*1.6)*90.0);\n    d.xy = rot(d.xy, sin(iTime*0.2 + sp*1.3)*180.0);\n    vec3 p = vec3(0.0);\n    vec3 prevp = p;\n    vec3 col = vec3(0.0);\n    vec3 lig = vec3(sin(iTime)*5.0,10.0,2.0+cos(iTime)*6.0);\n    float dd;\n    if(trac(p,d,dd)){\n        vec3 n = norm(p,dd);\n        vec3 light = normalize(lig-p);\n        \n        col = vec3(0.6)*max(dot(n,light),0.1);\n        col+= rough(0.4, dot(reflect(d,n),light));\n        col*=shadow(p-d*0.1, lig);\n    }\n    \n    col += volumetrics(prevp,p, lig)*0.7;\n    //col = mix(volumetrics(prevp,p, lig), col, 0.5);\n    \n    float dist = abs(length(vec2(0.5) - fragCoord/iResolution.xy));\n    col-= dist*dist*0.6;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 269, 295, 327, 464], [467, 467, 493, 499, 551], [553, 640, 663, 663, 703], [706, 706, 724, 724, 861], [863, 863, 907, 907, 1040], [1042, 1224, 1254, 1254, 1403], [1407, 1407, 1437, 1437, 1871], [1873, 1873, 1920, 1920, 2129], [2131, 2131, 2161, 2161, 2219], [2221, 2221, 2278, 2278, 3378]]}
{"id": "wtV3R1", "name": "The ring", "author": "avin", "description": "The ring film title replic", "tags": ["circle", "shine"], "likes": 19, "viewed": 509, "published": "Public API", "date": "1578323590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    \n    // float a = fract(atan(uv.y, uv.x)/TAU);\n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/4.;\n    float l = length(uv);                     \n    \n    \n    float m1 = clamp(.1/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.1/smoothstep(.42, 0., l), 0., 1.);\n    float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*1.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .025)) + 1.25);\n    s3 *= smoothstep(0.0, .3345, l);    \n    \n    float sh = smoothstep(0.15, .35, l);\n    float sh2 = smoothstep(0.75, .3, l);    \n    \n    float m = m1*m2 * ((s1*s2*s3) * (1.-l)) * sh * sh2;\n    m = m*m;\n            \n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 84, 84, 236], [238, 238, 267, 267, 931], [933, 933, 990, 990, 1892]]}
{"id": "wtV3RD", "name": "Roller Coaster", "author": "Plento", "description": "Roller coaster shaderrr.", "tags": ["2d", "cartoon", "derivative", "rollercoaster"], "likes": 19, "viewed": 421, "published": "Public API", "date": "1578526935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plento\n\nvec2 R;\n#define st(a, b, t) smoothstep(a, b, t)\n\nvec2 rot(vec2 p, float a){\n \treturn vec2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a));   \n}\n\nfloat height(float x){\n    return sin(x*2.)*.15 + sin(x*3.)*.13 + sin(x*6.)*.02;\n}\n\n\nfloat aDx(float x){\n    float h = .001;\n    float y = height(x+h) - height(x);\n    return atan(y, h);\n}\n\nfloat box(vec2 uv, vec2 dim, float b){\n    uv = abs(uv);\n    float bx = st(b, -b, uv.y - dim.y);\n    bx *= st(b, -b, uv.x - dim.x );\n    return bx;\n}\nfloat circle(vec2 uv, float r, float b){\n \treturn st(r + b, r - b, length(uv));   \n}\nfloat rtr(vec2 uv, vec2 scale, float h,  float b){\n    uv.y -= h;\n    uv *= scale;\n    \n    float tri = st(b, -b, dot(uv, vec2(1., 1.)));\n    tri *= st(-b, b, uv.y + h);\n    tri *= st(-b, b, uv.x);\n    \n    return tri;\n}\n\nvec4 track(vec2 uv){\n    float b = .01;\n    float trk = .0;\n    float sup = .0;\n    \n    trk += st(-.005, .005, uv.y + height(uv.x) + .007);\n    trk *= st(.005, -.005, uv.y + height(uv.x) - .007);\n    \n    vec2 ruv = fract(uv*8.) - .5;\n    \n    sup += st(.08, .07, abs(dot(ruv, vec2(1., 1.))));\n    sup += st(.08, .07, abs(dot(ruv, vec2(-1., 1.))));\n    sup *= st(.001, -.001, uv.y + height(uv.x)+.007);\n    \n    vec3 col = vec3(.7, .7, .7)*trk;\n    \n    return vec4(col, trk + sup);\n}\n\n\nvec4 car(vec2 uv){\n    float b = .02;\n    \n    vec3 col = vec3(0);\n    float a = 0.;\n    float wheel = 0.;\n    \n    a += box(uv, vec2(.7, .1), b);\n    a += box(uv, vec2(0.75, .06), b);\n    a += box(uv - vec2(0., .2), vec2(.5, .1), b);\n    a += box(uv - vec2(0., -.2), vec2(.5, .1), b);\n    \n    a += rtr(vec2(-uv.x, uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    a += rtr(vec2(-uv.x, -uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    \n    a += rtr(vec2(uv.x, uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    a += rtr(vec2(uv.x, -uv.y)-vec2(.5, .1), vec2(1., 1.), .2, b);\n    \n    a -= box(uv-vec2(-.25, .2), vec2(.15, .1), b);\n    a -= box(uv-vec2(.25, .2), vec2(.15, .1), b);\n    \n    a = clamp(a, 0., 1.);\n    \n    wheel += circle(uv-vec2(.4,-.35), .15, .01);\n    wheel += circle(uv-vec2(-.4,-.35), .15, .01);\n    \n    col = a * mix(vec3(.8, 0., 0.),vec3(.8, .8, 0.), \n                  st(.2, .06, abs(uv.y+.2)));\n    col *= st(.01, .4, abs(uv.y+.44));\n    col *= st(.0, .2, abs(uv.y-.38));\n\tcol *= st(.0, .9, abs(uv.x+1.15));\n    \n    col *= 1.-wheel;\n    \n    return vec4(col, a + wheel);\n}\n\nvec4 hill(vec2 uv){\n \tfloat a = st(0.015, -0.015, uv.y - height(uv.x));\n    vec3 col = vec3(0);\n    col += max(uv.y+.9, .1)*vec3(0.1, 0.43, 0.2) * a;\n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = iMouse.xy / R.xy-.5; \n    m.x *= R.x/R.y;\n    \n    vec3 col = mix(vec3(0.6, 0.6, 0.66), vec3(0., .28,.88), uv.y+.5);\n    col = mix(col, vec3(0.9, 0.9, 0.5), exp(-length((uv-vec2(-.6, .3))*14.)));\n    \n    uv *= 1.5;\n    \n    vec2 p = uv, p2 = uv;\n   \n    uv.x += iTime + m.x*5.;\n    \n    vec4 Hill = hill(vec2(2.*uv.x - iTime*.7, uv.y));\n    \n    col = mix(col, Hill.rgb, Hill.a); \n    \n    \n    float pos = -.8;\n    vec4 cars = vec4(0);\n    \n    for(float i = 0.; i < 5.; i++){\n        p = p2;\n        pos +=.25;\n        \n        float ht = height(uv.x - (p.x+pos));    \n    \tp = p2 + vec2(pos , ht);\n    \tp = rot(p, aDx(uv.x - p.x));\n    \n        cars = car((p-vec2(0., .072)) * 7.);\n        col = mix(col,cars.rgb,cars.a); \n    }\n    \n    \n    vec4 trk = track(uv);\n    col = mix(col, trk.rgb,trk.a); \n    \n    //col = 1.-exp(-col*1.4);\n    f = vec4(col, 1.0)*1.05;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 86, 86, 156], [158, 158, 180, 180, 240], [243, 243, 262, 262, 346], [348, 348, 386, 386, 497], [498, 498, 538, 538, 582], [583, 583, 633, 633, 803], [805, 805, 825, 825, 1290], [1293, 1293, 1311, 1311, 2381], [2383, 2383, 2402, 2402, 2559], [2561, 2561, 2601, 2601, 3550]]}
{"id": "WtV3Rw", "name": "Julia Quaternion Cross Section", "author": "onlinerocker", "description": "https://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf", "tags": ["3d", "fractal", "mandelbrot", "4d", "quaternion", "julla"], "likes": 3, "viewed": 127, "published": "Public", "date": "1578542234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define ITERATIONS 2.0\n#define AA_SCALE 2.0\n\n//SETTINGS:\n#define VIEW_DIST 25.0\n#define C vec4(0.2,0.5,0.3,0.3)\n//#define C vec4(0.8,0.-0.1,0.9,0.9)\n\n//RESOURCES:\n//https://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 multQuat(vec4 q1, vec4 q2)\n{\n    vec4 r;\n    r.x   = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 squareQuat(vec4 q)\n{\n \tvec4 r;\n    r.x   = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.0*q.x*q.yzw;\n    return r;  \n}\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;    \n    o.dist = 1000.0;\n    \n    float ang = iTime/8.0;\n    float r;\n    \n    pos.xz *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    \n    vec4 z = vec4(pos, 0.1);\n    vec4 dz = vec4(1, 0, 0, 0);\n\n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    \n    vec4 c = C;\n    c.w += 0.5*sin(iTime*2.0);\n        \n    \n    for(float x=0.0; x < 20.0; x++)\n    {\n        dz = 2.0*multQuat(z,dz);\n    \tz = squareQuat(z) + c;\n        \n        minDist = min(minDist, length(z - c)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n        \n        if(length(z) > 2.0)\n        {\n            it = x;\n            break;\n        }\n    }\n\n    //Coloring based off orbits: https://www.iquilezles.org/www/articles/ftrapsgeometric/ftrapsgeometric.htm\n    o.color = vec3(0) + vec3(1.0, 0.3, 0.55)*sqrt(minDist);\n    o.color += vec3(0.0,0.3,0.3)*sqrt(mdX);\n    o.color += vec3(0.0,0.4,0)*sqrt(mdY);\n    o.color += vec3(0.0,0.1,0.5)*sqrt(mdZ);\n    \n    //o.color = vec3(1)-vec3(it/20.0);\n    o.dist = 0.5*length(z)*log(length(z)) / length(dz);\n    \n    return o;\n}\n  \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<250; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed; \n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {   \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    //AA based off IQ's implementation in many different shaders\n    for(float x=0.0; x<AA_SCALE; x++){\n        for(float y=0.0; y<AA_SCALE; y++){\n\n            vec2 aaOffset = vec2(x,y);\n            vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n            vec3 camEye = vec3(0,0.0,2.2);\n            vec3 dir = normalize(vec3(uv, -1));\n\n\n            float rate = 8.0;\n            float camAng = PI/3.5;\n            float camAngPos = camAng;\n\n            mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n            mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n\n            camEye.xz = rotCamPos * camEye.xz;\n            dir.xz = rotCam * dir.xz;\n\n            MarchRes res = marchRay(camEye, dir, 1.0);\n            vec3 pos = res.curRay;  \n\n            vec3 tempCol = vec3(0.25);\n            if(res.totalDist < VIEW_DIST)\n            {\n                tempCol = res.obj.color;\n            }\n\n            col += tempCol;\n\n        }\n    }\n    \n    fragColor = vec4(col/((AA_SCALE*AA_SCALE)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 622, 655, 655, 795], [797, 922, 947, 947, 1045], [1051, 1176, 1198, 1198, 2477], [2481, 2481, 2533, 2533, 3120], [3122, 3122, 3179, 3179, 4337]]}
{"id": "WtV3W3", "name": "Recursive Drawings", "author": "zovox", "description": "Recursive Drawings", "tags": ["recursive", "drawings"], "likes": 6, "viewed": 299, "published": "Public API", "date": "1580063790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define time ((saw(float(__LINE__)/GR)+1.0)*(iTime/E+1234.4321)/E)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\n\nfloat smooth_floor(float x)\n{\n\treturn floor(x)+smoothstep(.75, 1., fract(x));\n}\n\nvec2 tree(vec2 uv)\n{\n    \n    vec2 p = uv*2.-1.;\n    \n\t\n        float angle = smooth_floor((time))*PI/12.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 1./MAX_DIM);\n        \n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n    return p;\n}\n\nvec2 flower(vec2 p)\n{\n\tp *= rotate(time);\n\tfloat rots = smooth_floor(3.+6.*saw(time/E))+1./MAX_DIM;\n\tfloat angle = atan(-p.y, -p.x);\n\tfloat radius = length(p);\n\tangle = floor(((angle/PI)*.5+.5)*rots);\n\n\n\tvec2 a = vec2(1., 0.);\n\tvec2 b = vec2(1., 1./MAX_DIM);\n\tvec2 c = vec2(0., 1./MAX_DIM);\n\tvec2 d = vec2(0., -1./MAX_DIM);\n\t\n\tb *= rotate(angle/rots*2.*PI);\n\tangle += 1.;\n\ta *= rotate(angle/rots*2.*PI);\n\t\n\treturn (invBilinear( p, a, b, c, d ));\n}\n\n\nfloat square(vec2 uv, vec2 uv0)\n{\n    uv = (uv*2.-1.)*GR;\n    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;\n    return vec2(saw(r+time/E/E),\n                saw(theta+time/GR/E))*2.-1.;\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv.xy*2.-1.;\n    uv0.x *= max(iResolution.x/iResolution.y, 1.);\n    uv0.y *= max(iResolution.y/iResolution.x, 1.);\n\tuv0 = uv0*.5+.5;\n    float map = 0.0;\n    \n    float lambda = 4.0;\n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+(time*PI*GR*E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= max(iResolution.x/iResolution.y, 1.);\n    uv.y *= max(iResolution.y/iResolution.x, 1.);\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n\tfloat m = smoothstep(0.45, .55, saw(time/E/PI));\n    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;\n    \n\tfloat nature = smoothstep(.45, .55, saw(time/GR/E))*(1.-m);\n\tuv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n\t\n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = saw(tree(uv.xy));\n\t\t\tmap += square(uv.xy, uv0);\n\t\tuv0 = uv;\n    }\n    \n    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    fragColor.rgb = (flux(map))*\n        \t\t\t\n        \t\t\tclamp(map, 0.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 323, 323, 351], [353, 353, 373, 373, 478], [479, 479, 497, 497, 536], [538, 538, 556, 556, 605], [606, 606, 681, 681, 1653], [1656, 1656, 1678, 1678, 1726], [1729, 1729, 1758, 1758, 1808], [1810, 1810, 1830, 1830, 2803], [2805, 2805, 2826, 2826, 3252], [3255, 3255, 3288, 3288, 3363], [3366, 3366, 3388, 3388, 3567], [3569, 3569, 3592, 3592, 3701], [3703, 3703, 3760, 3760, 4946]]}
{"id": "WtV3Wc", "name": "pimp that ass", "author": "makc", "description": "I have no idea what am I doing, so would someone please fix this for me? see the line #42, k10x.", "tags": ["sdf", "distance", "parametric"], "likes": 6, "viewed": 286, "published": "Public", "date": "1580080263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// basically a combination of:\n// - https://mathematica.stackexchange.com/a/66564 by Nikolai Mikuszeit\n// - https://www.shadertoy.com/view/Ws3SDl by Inigo Quilez\n\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n\n    // this does work better now, thanks to (...smoothstep(..)) multiplier ~ @Del's patch\n    return (.5 + .5 * smoothstep(.4,1.,p.z)) * (\n           length(vec2(p.y, p.x - dx)) - r_expected\n    );\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime - 0.8;\n\tvec3 ro = vec3( 2.5*sin(an), 0.5, -2.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<150; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.3,0.15,0.1)*amb + vec3(0.8,0.5,0.2)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 218, 292, 292, 344], [346, 346, 394, 394, 438], [440, 440, 473, 473, 1042], [1044, 1112, 1135, 1159, 1593], [1596, 1596, 1622, 1622, 1649], [1651, 1715, 1747, 1747, 1985], [1987, 1987, 2044, 2069, 3608]]}
{"id": "WtV3WR", "name": "Checkerboard tunnel v2", "author": "tombla", "description": "Checkerboard tunnel with improved smoothing.", "tags": ["tunnel", "radial", "checkerboard", "polar"], "likes": 5, "viewed": 253, "published": "Public API", "date": "1578672448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Improved smoothing using smoothstep\n// and mixing trick from \n// https://www.shadertoy.com/view/WdBGzd\n\n#define PI2 6.28318530718\n\n#define COLOR1 vec3(1., 1., 0.6)\n#define COLOR2 vec3(0., 0.1, 0.4)\n#define LIGHTCOLOR  vec3(1., 1., 1.)\n\n#define ARMS 10.\n#define DENSITY 3.\n#define ANGLE_SPEED 1.\n#define SPEED 2.\n#define PULSE_SPEED 4.\n#define SMOOTH 0.08\n\nfloat smoothCheckerboard(in vec2 uv) {    \n    // Shift, as fract gives 0..1 and we will smooth\n    // around 0.25 and 0.75.\n    uv = fract(uv + 0.25);\n    float sm2 = SMOOTH * 0.5;\n    // p01 oscillates between 0 and 1.\n    vec2 p01 =\n        smoothstep(0.25 - sm2, 0.25 + sm2, uv) -\n        smoothstep(0.75 - sm2, 0.75 + sm2, uv);\n    // pn11 oscillates between -1 and 1.\n    vec2 pn11 = (p01 - 0.5) * 2.;\n    // This results in smoothed 0..1 transitions.\n    // We take advantage of the fact that multiplication\n    // of -1/1 behaves like XOR. Then we rescale\n    // -1..1 result of the multiplication to 0..1.\n    return 0.5 - 0.5 * pn11.x * pn11.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2\n        R = iResolution.xy,\n        // Cartesian [-1, 1] along shorter axis.\n        uv = (2. * fragCoord - R) / min(R.x, R.y);\n    float\n        T = iTime,\n        // Angle [-PI, PI] and radius.\n        a = atan(uv.x, uv.y),\n        r = length(uv);\n\n    // Rescale polar coords, as checkerboard generates 1x1 squares.\n    vec2 polar = vec2(\n        a * ARMS / PI2 + T * ANGLE_SPEED,\n        1. / r * DENSITY + T * SPEED \n    );\n\n    vec3 checker = mix(COLOR1, COLOR2, smoothCheckerboard(polar));\n    // Light in the center.\n    float light = smoothstep(0.7 + 0.3 * sin(T * PULSE_SPEED), 0.2, r);\n    vec3 color = mix(checker, LIGHTCOLOR, light);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 359, 397, 483, 1015], [1017, 1017, 1072, 1072, 1763]]}
{"id": "WtV3Ww", "name": "C_HelloRayMarching", "author": "hyrchao", "description": "RayMatching test", "tags": ["test"], "likes": 3, "viewed": 86, "published": "Public", "date": "1579082149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 500\n#define MAX_DISTANCE 1000.0\n#define MIN_SURF_DIST 0.01\n#define SPEC_POW 12.0\n#define AMBIENT_LIGHT 0.0\n#define USE_SHADOW 0.0\n\nfloat sphere(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat ground(vec3 p, float h)\n{\n    return p.y - h;\n}\n\n\nfloat twistGeo(in vec3 p )\n{\n    float k = 5.0 * (1.0 + sin(iTime)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, vec2(0.4 , 0.2));\n}\n\nfloat map(vec3 p)\n{\n    float nd = 0.0;\n    float sd = twistGeo(p);\n    float gd = ground(p, -0.7);\n    nd = min(sd, gd);\n    return nd;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = vec3(\n        map(p + e.xyy) - d,\n        map(p + e.yxy) - d,\n        map(p + e.yyx) - d\n        );\n    return normalize(n);\n}\n    \nfloat tracing(vec3 ro, vec3 rd)\n{\n    float d = 0.0;       // traced distance from light origin\n    vec3 p = ro;         // traced position\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n       \tfloat nd = map(p);\n        d += nd;\n        p = ro + rd * d;\n        if(d > MAX_DISTANCE || nd <MIN_SURF_DIST)\n            break;\n    }\n    return d;\n}\n\n// blin-phong\nvec3 lighting(vec3 p, vec3 rd)\n{\n    float pLightRadius = 10.0;\n    vec3 lightPos = vec3(pLightRadius * sin(iTime), 8.0, pLightRadius * cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = calcNormal(p);\n        \n    float diff = max(dot(n, l), 0.0);   //diffuse  \n    vec3 refl = normalize(-l + 2.0*n*max(dot(l, n), 0.0));\n    float spec = pow(max(dot(rd, refl), 0.0), SPEC_POW); //specular\n    //float spec = 0.0;\n    //diff = 0.0;\n    //spec = 0.0; // debug spec\n    float sd = tracing(p + n * MIN_SURF_DIST * 2.0, l);     \t\t\t\t\t\t// cast a ray from current position to light position\n    float shadow = sd < length(lightPos - p) ? 0.1 : 1.0;            // current position is in shadow if hit anything\n    shadow = mix(1.0, shadow, USE_SHADOW);\n    vec3 col = vec3(diff + spec + AMBIENT_LIGHT);\n    return col * shadow;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float zoom = 0.0;\n    vec3 ro = vec3(30.0 * cos(t), 1.0, 30.0 * sin(t));\n    //vec3 ro = vec3(0.0, 1.0, -5.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    \n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n\tro += f * zoom;\n    vec3 rd = normalize(uv.x * r + uv.y * u - ro);\n    \n    float d = tracing(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    vec3 col = lighting(p, rd);\n\n\n    fragColor = vec4(col, 0.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtV3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 179, 179, 217], [219, 219, 257, 257, 537], [539, 539, 572, 572, 637], [639, 639, 670, 670, 692], [695, 695, 723, 723, 943], [945, 945, 964, 964, 1083], [1085, 1085, 1110, 1110, 1302], [1308, 1308, 1341, 1341, 1652], [1654, 1668, 1700, 1700, 2502], [2505, 2505, 2562, 2562, 3155]]}
{"id": "wtV3zK", "name": "falsoQueso", "author": "jorge2017a1", "description": "falsoQueso", "tags": ["falsoqueso"], "likes": 1, "viewed": 53, "published": "Public", "date": "1579403253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            \n             res=vec2(res.x, 13);\n            \n         } \n     }\n    \n    \n    float sdb1  =sdBox( p, vec3(7.0,9.0,0.5) );\n    float sdfintdo=999.0;\n    \n    float  numi=3.0;\n    float  numj=6.0;\n    \n   for(float j=0.0; j<numj; j++)  \n   {\n    for(float i=0.0; i<numi; i++) \n     {\n   \n        float sdc1 =sdCylinder( p.yzx-vec3(2.0+2.0*i+i*0.5,1.0,-8.0+2.0*j+j*0.5), vec2(1.0,2.0) );\n        sdfintdo = min(sdfintdo,sdc1);\n     }\n    }\n        \n    dif1= differenceSDF(sdb1, sdfintdo);\n    \n   \n    res =opU(res, vec2(dif1,8));\n    \n   \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n     case 15:\n     \t\t/*\n         \t\tvec3 pos = ray.origin + tt * ray.direction;\n                vec3 V = normalize(pos - cameraPos);\n                vec3 L = ray.direction;\n                vec3 normal = plane.normal;\n                vec3 refl = 2.*dot(normal,-ray.direction)*normal + ray.direction;\n                ray = Ray(pos,refl);\n                result += LightShading(normal,L,V, plane.color)*intensity; //地板色\n      \t\t*/\n        case 16:\n        \tvec3 p,rd,ro;\n        \tfloat dist;\n        \t\t\n        \t\tro= mObj.ro;\n                rd= mObj.rd;\n                dist =mObj.dist;\n        \t\t//dist =0.001;\n        \n        \t\tp =ro+rd*dist;\n                \n          \t\tvec3 sn =GetNormal(p);\n     \t\t\t// SECOND PASS - REFLECTED RAY\n    \t\t\tvec3 rdrf = reflect(-rd, sn);\n        \t\t//vec3 prf = (ro + rdrf * d); \n        \t\tvec3 prf = (ro + rdrf * dist); \n    \t\t\t//vec3 prf = (ro + rdrf * 0.01); \n    \t\t\tfloat difrf = GetLight(prf);\n        \t\treturn difrf*vec3(1.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,4.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtV3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1523, 1523, 1554, 1554, 1742], [1745, 1799, 1821, 1821, 3081], [3084, 3148, 3184, 3184, 3457], [3459, 3509, 3555, 3555, 3587], [3589, 3589, 3632, 3632, 3664], [3666, 3666, 3714, 3714, 3747], [3750, 3750, 3779, 3779, 3905], [3907, 3907, 3943, 3943, 4060], [4062, 4062, 4098, 4098, 4216], [4268, 4280, 4302, 4302, 4610], [4611, 4637, 4662, 4662, 4852], [4853, 4898, 4915, 4915, 4988], [4991, 5024, 5050, 5050, 5247], [5248, 5294, 5346, 5346, 5501], [5566, 5675, 5712, 5712, 5747], [5749, 5749, 5768, 5768, 5843], [5849, 5849, 5874, 5874, 6897], [6900, 6900, 6934, 6934, 7323], [7328, 7328, 7352, 7352, 7584], [7588, 7588, 7612, 7612, 7997], [8000, 8000, 8026, 8026, 8390], [8393, 8393, 8418, 8418, 8446], [8448, 8448, 8500, 8500, 8896], [8999, 9043, 9060, 9060, 9131], [9156, 9248, 9273, 9273, 9536], [9538, 9597, 9625, 9625, 12384], [12388, 12388, 12445, 12445, 13855]]}
{"id": "WtVGDV", "name": "Signed circumcircle", "author": "hiogawa", "description": "I can canonically obtain \"sign\" based on \"InCircle test\", but it doesn't give canonical AA-friendly pixel value since it is the volume of a tetrahedra in a quite unrelated 3d space.", "tags": ["2d", "triangle", "circle"], "likes": 2, "viewed": 189, "published": "Public API", "date": "1579928993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Signed circumcircle\n//\n// NOTE:\n//   I can canonically obtain \"sign\" based on \"InCircle test\",\n//   but it doesn't give canonical AA friendly pixel value\n//   since it is the volume of a tetrahedra in a quite unrelated 3d space.\n//   So, \"USE_IN_CIRCLE_TEST = false\" switches to direct computation\n//   of circumcircle and signed area of a triangle.\n//\n\n#define M_PI 3.14159\n\nbool USE_IN_CIRCLE_TEST = true;\nfloat IN_CIRCLE_TEST_VOLUME_SCALE = 1000.0;\n\nfloat SCALE = 1.2;\nfloat SCALE_TIME = .4;\n\nfloat CHECKER_SCALE = 4.0;\nvec3  CHECKER_COLOR0 = vec3(0.20);\nvec3  CHECKER_COLOR1 = vec3(0.60);\n\nfloat POINT_RADIUS = 3.0;\nvec3  POINT_COLOR = vec3(0.0, 1.0, 1.0);\n\nvec3  TRIANGLE_COLOR = vec3(0.0, 1.0, 1.0);\nfloat TRIANGLE_ALPHA = 0.75;\n\nvec3  DISK_COLOR = vec3(1.0);\nfloat DISK_ALPHA = 0.75;\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvoid intersect_Line_Line(\n    vec2 p1, vec2 v1, vec2 p2, vec2 v2,\n    out float t1, out float t2) {\n  // assume v1, v2: linear indep.\n  // p1 + t1 v1 = p2 + t2 v2\n  // <=>  (p1 - p2) + [v1, -v2] {t1, t2} = 0\n  // <=>  {t1, t2} = inv([v1, -v2]) (-p1 + p2)\n  vec2 t1t2 = inverse(mat2(v1, -v2)) * (-p1 + p2);\n  t1 = t1t2[0];\n  t2 = t1t2[1];\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nvec2 hash12(float v) {\n  return vec2(hash11(v), hash21(vec2(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(float hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash12(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * vec2(hash_seed) + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * vec2(hash_seed) + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n\n//\n// Misc\n//\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nfloat signedDistanceToTriangle(vec2 uv, vec2 p0, vec2 p1, vec2 p2) {\n  vec2 v1 = p1 - p0;\n  vec2 v2 = p2 - p0;\n  float signed_area = cross(vec3(v1, 0.0), vec3(v2, 0.0)).z;\n  if (abs(signed_area) <= 0.0000001) {\n    return 1000.0;\n  }\n\n  // Barycentric coord (uv = p0 + s * v1 + t * v2)\n  mat2 v1v2 = mat2(v1, v2);\n  vec2 st = inverse(transpose(v1v2) * v1v2) * transpose(v1v2) * (uv - p0);\n  bool is_inside = st.x >= 0.0 && st.y >= 0.0 && (st.x + st.y) <= 1.0;\n\n  float dist = 1000.0;\n  dist = min(dist, distance_Point_LineSegment(uv, p0, p1));\n  dist = min(dist, distance_Point_LineSegment(uv, p1, p2));\n  dist = min(dist, distance_Point_LineSegment(uv, p2, p0));\n\n  return is_inside ? -dist : dist;\n}\n\nfloat signedDistanceToCircle(vec2 uv, vec2 center, float radius) {\n  return distance(uv, center) - radius;\n}\n\nfloat inCircleTestVolume(vec2 q, vec2 p0, vec2 p1, vec2 p2) {\n  mat3 circle_test_mat = mat3(\n    (p0 - q).x, (p0 - q).y, dot(p0, p0) - dot(q, q),\n    (p1 - q).x, (p1 - q).y, dot(p1, p1) - dot(q, q),\n    (p2 - q).x, (p2 - q).y, dot(p2, p2) - dot(q, q));\n  float circle_test_det = determinant(circle_test_mat);\n  return circle_test_det;\n}\n\nvec2 circumcircleCenter(vec2 p0, vec2 p1, vec2 p2) {\n  // assume non degenerate triangle\n  vec2 q1 = (p0 + p1) / 2.0;\n  vec2 q2 = (p0 + p2) / 2.0;\n  vec2 u1 = p1 - p0;\n  vec2 u2 = p2 - p0;\n  vec2 v1 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u1, 0.0)));\n  vec2 v2 = vec2(cross(vec3(0.0, 0.0, 1.0), vec3(u2, 0.0)));\n  float t1, t2;\n  intersect_Line_Line(q1, v1, q2, v2, t1, t2);\n  return q1 + t1 * v1;\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n// view transform with aspect ratio preserved\nmat3 invViewTransform(vec2 center, float scale_y) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(scale_y * Res.x / Res.y, scale_y);\n  vec2 a = center - size / 2.0;\n  float Sy = scale_y / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0\n  );\n  return xform;\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(vec2(0.5, 0.5), SCALE);\n  float inv_view_scale = inv_view_xform[0][0];\n\n  vec2 uv = vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Draw checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Prepare random 3 points\n    vec2 ps[3];\n    for (int i = 0; i <= 2; i++) {\n      ps[i] = someNoise(float(i), t);\n    }\n\n    // Draw circumcircle\n    if (USE_IN_CIRCLE_TEST) {\n      float volume = inCircleTestVolume(uv, ps[0], ps[1], ps[2]);\n      volume *= IN_CIRCLE_TEST_VOLUME_SCALE;\n      float coverage = 1.0 - smoothstep(-1.0, 1.0, volume);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n\n    } else {\n      vec2 center = circumcircleCenter(ps[0], ps[1], ps[2]);\n      float radius = distance(center, ps[0]);\n      float sd = signedDistanceToCircle(uv, center, radius);\n\n      float signed_area = cross(vec3(ps[1] - ps[0], 0.0), vec3(ps[2] - ps[0], 0.0)).z;\n      sd *= sign(signed_area);\n\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, DISK_COLOR, DISK_ALPHA * coverage);\n    }\n\n    // Draw triangle\n    {\n      float sd = signedDistanceToTriangle(uv, ps[0], ps[1], ps[2]);\n      float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n      color = mix(color, TRIANGLE_COLOR, TRIANGLE_ALPHA * coverage);\n    }\n\n    // Draw point\n    {\n      float min_distance = 1000.0;\n      for (int i = 0; i <= 2; i++) {\n        min_distance = min(min_distance, distance(ps[i], uv));\n      }\n      float coverage = smoothBoundaryCoverage(\n          min_distance / inv_view_scale - POINT_RADIUS, AA);\n      color = mix(color, POINT_COLOR, coverage);\n    }\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[815, 831, 858, 858, 917], [918, 918, 983, 983, 1050], [1052, 1052, 1151, 1306, 1391], [1393, 1393, 1453, 1516, 1730], [1733, 1749, 1772, 1772, 1830], [1832, 1832, 1854, 1854, 1908], [1910, 1910, 1932, 1932, 1982], [1984, 1984, 2013, 2013, 2049], [2051, 2051, 2082, 2082, 2552], [2554, 2554, 2605, 2687, 3050], [3053, 3068, 3121, 3121, 3364], [3366, 3366, 3434, 3434, 4067], [4069, 4069, 4135, 4135, 4177], [4179, 4179, 4240, 4240, 4515], [4517, 4517, 4569, 4605, 4915], [4917, 4931, 5006, 5006, 5085], [5087, 5133, 5184, 5184, 5435], [5438, 5453, 5507, 5507, 7414]]}
{"id": "WtVGDy", "name": "Make noise", "author": "tonywu", "description": "make some useful noise", "tags": ["noise"], "likes": 1, "viewed": 215, "published": "Public API", "date": "1579767542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p){\n\treturn fract(sin(p.x*100. + p.y*643.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    \n \tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3. - 2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl,br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n\tfloat c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.) * .5;\n    c += SmoothNoise(uv*16.) * .25;\n    c += SmoothNoise(uv*32.) * .125;\n    c += SmoothNoise(uv*64.) * .0625;\n    \n    return c /=2.;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t//float c = N21(uv);\n    \n    uv += iTime*.1;\n    float c = SmoothNoise2(uv);\n    \n    \n    vec3 col =vec3(c);\n    \n    //col.rg = lv;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 96, 96, 419], [421, 421, 450, 450, 657], [659, 659, 716, 716, 955]]}
{"id": "wtVGW3", "name": "Hello Sphere", "author": "samhattangady", "description": "27 Jan 2020: day001\nLooking to draw a basic sphere using sdf.\nUsing parallel projectsion.", "tags": ["sdf", "sphere"], "likes": 2, "viewed": 195, "published": "Public API", "date": "1580093618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nday001: Sphere\n27 Jan 2020\n\nLooking to draw a basic sphere using sdf.\nUsing parallel projections\n*/\n\n\nfloat sdfSphere(vec3 position) {\n    vec3 center = vec3(0.0);\n    float radius = 0.25;\n    return distance(position, center) - radius;\n}\n\nvec3 calcNormal( vec3 p ) \n{\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -sdfSphere(p)+ sdfSphere(p+vec3(h,0.0,0.0)),\n                           -sdfSphere(p)+ sdfSphere(p+vec3(0.0,h,0.0)),\n                           -sdfSphere(p)+ sdfSphere(p+vec3(0.0,0.0,h)) \n    \t\t\t\t ));\n}\n\nfloat raymarch( vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    float d = 0.0;\n    vec3 pos = start;\n    for (int i=0; i<100; i++) {\n    \tfloat sphereDistance = sdfSphere(pos);\n        pos += sphereDistance*direction;\n\n        d += sphereDistance;\n        if (sphereDistance < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 q = p - vec2(0.0, 0.0);\n    \n    vec3 planePosition = vec3(0.0, 0.0, -5.0);\n    vec3 lookingDirection = vec3(0.0, 0.0, 1.0);\n    \n    // Rotate light around origin in xz plane\n    float angle = iTime;\n    vec2 lightPos2D = mat2(cos(angle),-sin(angle),sin(angle),cos(angle))*vec2(0.0,1.0); \n    vec3 lightPoint = vec3(lightPos2D.x, 0.0, lightPos2D.y);\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    \n    // raymarch to check for colissions.\n    vec3 start = vec3(p, planePosition.z);\n    float dist = raymarch(lookingDirection, start);\n    float color = 0.0;\n    if (dist < 15.0) {\n    \tvec3 normal = calcNormal(start+ dist*lookingDirection);\n        color = -dot(lightFacing, normal);\n    }\n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 105, 137, 137, 241], [243, 243, 271, 503, 781], [783, 783, 828, 1117, 1461], [1463, 1463, 1520, 1563, 2401]]}
{"id": "wtVGz3", "name": "Smiley Faces for test", "author": "tonywu", "description": "Just for test", "tags": ["test"], "likes": 2, "viewed": 219, "published": "Public API", "date": "1579523433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n\tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur){\n\tfloat step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    float band = step1 * step2;\n    return band;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur){\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    float rect = band1 * band2;\n    return rect;\n}\n\nfloat remap01(float a, float b, float t){\n\treturn (t-a) / (b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n\treturn remap01(a, b, t) * (d-c) + c;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size){\n    \n    uv -= p;\n    uv /= size;\n    \n    float mask = Circle(uv, vec2(0), 0.4, 0.05);\n    vec3 col = vec3(1,1,0);\n    \n    \n    mask -= Circle(uv, vec2(-0.15,0.1), 0.08, 0.015);\n    mask -= Circle(uv, vec2(0.15,0.1), 0.08, 0.015);\n    //mask -= Circle(uv, vec2(0,-0.2), 0.1, 0.015);\n    \n    float mouth = Circle(uv, vec2(0), 0.3, 0.015) * abs(sin(iTime));\n    mouth -= Circle(uv, vec2(0,0.05), 0.3, 0.015) * abs(sin(iTime));\n    \n    mask-= mouth;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float t  = iTime;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n   \tfloat mask = Smiley(uv, vec2(sin(iTime)*0.3,cos(iTime)*0.3), 0.5);\n\tmask += Smiley(uv, vec2(cos(iTime)*0.1,sin(iTime)*0.5), 0.5);\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float m = -(x-0.5)*(x+0.5);\n    //m = m*m*4.0;\n    m = m*sin(t+x*8.0)*0.5;\n    y = y-m;\n    \n    float blur = remap(-0.5, 0.5, 0.01, 0.25, x);\n    blur = pow(blur*4.0,3.0);\n    \n    mask += Rect(vec2(x,y), -0.5, 0.5, 0.1, -0.1, blur);\n    \n    vec3 col = vec3(1,1,0)*mask;\n    //col = vec3(mouth);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 132], [134, 134, 190, 190, 348], [350, 350, 432, 432, 578], [580, 580, 621, 621, 646], [648, 648, 705, 705, 745], [747, 747, 789, 789, 1259], [1261, 1261, 1318, 1368, 2120]]}
{"id": "Wty3Dc", "name": "Hyper/Epitrochoid 2D Section", "author": "hiogawa", "description": "I'm not sure how exactly this is related to \"Torus knot\" since my construction is more like \"Depth modulated hypertrochoid/epitrochoid with thickness\".\nWhat I mean by \"Knotted Hyper/Epitrochoid\" can be seen here https://www.shadertoy.com/view/wlGGW3.", "tags": ["2d", "torus", "epitrochoid", "hypertrochoid"], "likes": 3, "viewed": 197, "published": "Public API", "date": "1580024458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// 2D Section of Rotating Knotted Hyper/Epi-Trochoid\n//\n// NOTE:\n// - \"ROT_VELOCITY\" here doesn't necessarily give angular velocity around any axis\n//   since this is a derivative of extrinsic rotation angles xyz in this order.\n//   This might be the reason why \"vec3(M_PI, M_PI, M_PI)\" already does crazy stuff.\n// - Surprisingly \"Hyper\" and \"Epi\" give visually similar results.\n//   But, \"Epi\" requires more points to approximate curve since \"Epi\" curve is longer thant \"Hyper\".\n//   So \"Hyper\" might be the ones should be used.\n// - \"KNOTNESS > 1.0\" and \"KNOTNESS < 1.0\" give quite different results as expected.\n//\n\n#define M_PI 3.14159\n\nfloat AA = 2.0;\nfloat SCALE_TIME = 0.5;\nvec2  UV_CENTER = vec2(0.0, 0.0);\nfloat UV_HEIGHT = 3.0;\n\nfloat CHECKER_SCALE = 1.0;\nvec3  CHECKER_COLOR0 = vec3(0.1);\nvec3  CHECKER_COLOR1 = vec3(0.2);\nvec4  SECTION_COLOR = vec4(0.8, 1.0, 1.0, 0.9);\n\nconst float kEpi = 0.0;\nconst float kHyper = 1.0;\n\n// == Curve parameter ==\n// [ KNOTNESS > 1.0 ]\nconst float EPI_OR_HYPER = kHyper;\nfloat NUM_SYMMETRY = 4.0;\nfloat KNOTNESS = 2.5;\nfloat NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\nfloat BEBEL_WIDTH = 0.15;\n\n// [ KNOTNESS < 1.0 ]\n// const float EPI_OR_HYPER = kHyper;\n// float NUM_SYMMETRY = 3.0;\n// float KNOTNESS = 0.2;\n// float NUM_SEGMENTS = 128.0 * (EPI_OR_HYPER == kEpi ? 2.0 : 1.0);\n// float BEBEL_WIDTH = 0.15;\n\n// == Rotation ==\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  0.0);\n// vec3  ROT_VELOCITY = vec3(M_PI, 0.0,  M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.0);\nvec3  ROT_VELOCITY = vec3(M_PI, M_PI, M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI, 0.5 * M_PI);\n// vec3  ROT_VELOCITY = vec3(M_PI, M_PI * 4.0 / 3.0, M_PI * 5.0/ 4.0);\n\n\nfloat distance_Point_LineSegment(vec3 p, vec3 q1, vec3 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n  vec3 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0000001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\nvec3 knottedTrochoidPoint(float t, float r1, float r2, float r3, float type) {\n  float n = r1 / r2;\n  vec3 q;\n  if (type == kHyper) {\n    q = vec3(\n      // usual hyper-trochoid formula\n      (r1 - r2) * cos(t) + r3 * cos((1.0 - n) * t),\n      (r1 - r2) * sin(t) + r3 * sin((1.0 - n) * t),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  if (type == kEpi) {\n    q = vec3(\n      // usual epi-trochoid formula\n      (r1 + r2) * cos(t) + r3 * cos((1.0 + n) * t - M_PI),\n      (r1 + r2) * sin(t) + r3 * sin((1.0 + n) * t - M_PI),\n      // knot by waving z coord along symmetry\n      sin(n * t));\n  }\n  return q;\n}\n\n//\n// Re-parameterize hyper/epi-trochoid for easier visual control\n//\n//   \"num_symmetry\"\n//     n = r1 / r2 = 1 / r2 \\in N\n//\n//   \"knotness\" (knot (a > 1), intersecton (1 > a > 0), no-intersection (0 > a))\n//     r3 = (1 - a) r2 + a * (r1 - r2)  (for hyper-trochoid)\n//     r3 = (1 - a) r2 + a * (r1 + r2)  (for epi-trochoid)\n//\nfloat signedDistanceToKnottedTrochoid(\n    vec3 p, float type, float knotness, float num_symmetry,\n    float num_segments, float bebel_width) {\n\n  // Take care reparameterization and normalize overall size to about [-1, 1]^2\n  float r1 = 1.0;\n  float r2 = 1.0 / num_symmetry;\n  float r3, size; {\n    if (type == kHyper) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 - r2);\n      size = r1 - r2 + r3;\n    }\n    if (type == kEpi) {\n      r3 = (1.0 - knotness) * r2 + knotness * (r1 + r2);\n      size = r1 + r2 + r3;\n    }\n  }\n  r1 /= size; r2 /= size; r3 /= size;\n\n  // Approximate distance by straight lines\n  float min_distance = 1000.0;\n\n  vec3 q1, q2;\n  q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n\n  bool OPTIM_LOOP_WITH_SYMMETRY = true;\n  if (OPTIM_LOOP_WITH_SYMMETRY) {\n    // NOTE: It seems this approach is a bit faster.\n    for (float i = 1.0; i < num_segments / num_symmetry + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      for (float j = 0.0; j < num_symmetry; j++) {\n        float s = 2.0 * M_PI * j / num_symmetry;\n        mat2 rot = mat2(cos(s), sin(s), -sin(s), cos(s));\n        vec3 v1 = vec3(rot * q1.xy, q1.z);\n        vec3 v2 = vec3(rot * q2.xy, q2.z);\n        float sd = distance_Point_LineSegment(p, v1, v2) - bebel_width;\n        min_distance = min(min_distance, sd);\n      }\n      q1 = q2;\n    }\n\n  } else {\n    vec3 q1, q2;\n    q1 = knottedTrochoidPoint(0.0, r1, r2, r3, type);\n    for (float i = 1.0; i < num_segments + 1.0; i++) {\n      float t = 2.0 * M_PI * i / num_segments;\n      q2 = knottedTrochoidPoint(t, r1, r2, r3, type);\n      float sd = distance_Point_LineSegment(p, q1, q2) - bebel_width;\n      min_distance = min(min_distance, sd);\n      q1 = q2;\n    }\n  }\n  return min_distance;\n}\n\n\n//\n// Misc\n//\n\nmat2 rot2(float t) {\n  return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nmat3 rot3(vec3 r) {\n  mat2 x = rot2(r.x);\n  mat2 y = rot2(r.y);\n  mat2 z = rot2(r.z);\n  mat3 X = mat3(\n      1.0,     0.0,     0.0,\n      0.0, x[0][0], x[0][1],\n      0.0, x[1][0], x[1][1]);\n  mat3 Y = mat3(\n    y[1][1],   0.0, y[0][1],\n        0.0,   1.0,     0.0,\n    y[1][0],   0.0, y[0][0]);\n  mat3 Z = mat3(\n    z[0][0], z[0][1],   0.0,\n    z[1][0], z[1][1],   0.0,\n        0.0,     0.0,   1.0);\n  return Z * Y * X;\n}\n\nfloat signedDistanceToChecker(vec2 uv, float scale) {\n  uv *= scale;\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float dist = min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n  dist /= scale;\n  bool is_even_spot = mod(uvi.x + uvi.y, 2.0) == 0.0;\n  return is_even_spot ? -dist : dist;\n}\n\nmat3 invViewTransform(vec2 center, float height) {\n  vec2 Res = iResolution.xy;\n  vec2 size = vec2(height * Res.x / Res.y, height);\n  vec2 a = center - size / 2.0;\n  float Sy = height / Res.y;\n  mat3 xform = mat3(\n       Sy,   0,   0,\n        0,  Sy,   0,\n      a.x, a.y, 1.0);\n  return xform;\n}\n\nfloat smoothBoundaryCoverage(float signed_distance, float boundary_width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / boundary_width + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  mat3 inv_view_xform = invViewTransform(UV_CENTER, UV_HEIGHT);\n  float inv_view_scale = inv_view_xform[0][0];\n  vec2 uv =  vec2(inv_view_xform * vec3(frag_coord, 1.0));\n  float t = SCALE_TIME * iTime;\n\n  vec3 color;\n  {\n    // Checker\n    float sd = signedDistanceToChecker(uv, CHECKER_SCALE);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(CHECKER_COLOR0, CHECKER_COLOR1, coverage);\n  }\n  {\n    // Animate transform and coordinate\n    mat4 obj_xform = mat4(rot3(ROT_VELOCITY * t));\n    vec3 p = vec3(uv, 0.0);\n    vec3 p_in_obj = vec3(inverse(obj_xform) * vec4(p, 1.0));\n\n    // Approximate 2d section distance by 3d distance\n    float sd = signedDistanceToKnottedTrochoid(\n        p_in_obj, EPI_OR_HYPER, KNOTNESS, NUM_SYMMETRY, NUM_SEGMENTS, BEBEL_WIDTH);\n    float coverage = smoothBoundaryCoverage(sd / inv_view_scale, AA);\n    color = mix(color, SECTION_COLOR.xyz, SECTION_COLOR.w * coverage);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1577, 1704, 1764, 1827, 2043], [2045, 2045, 2123, 2123, 2678], [2680, 3011, 3154, 3235, 4815], [4818, 4833, 4853, 4853, 4903], [4905, 4905, 4924, 4924, 5327], [5329, 5329, 5382, 5382, 5625], [5627, 5627, 5677, 5677, 5922], [5924, 5924, 5999, 5999, 6078], [6081, 6096, 6150, 6150, 7130]]}
{"id": "Wty3RG", "name": "CircularBoundaryMandelbrot", "author": "antoinefortin", "description": "Allo", "tags": ["rec"], "likes": 1, "viewed": 103, "published": "Public", "date": "1579147277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAYITERATION 64\n\n#define MARCHINGAMOUNT 0.5\n\n#define MARCHINGSMALLESTSTEP 0.01\n\n#define DISTANCE 2.0\n\n#define MAXMANDELBROTDIST 1.5\n#define MANDELBROTSTEPS 5\n\n\nvec3 cosinusCouleur(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\t\n    \n\treturn 0.5 + b*cos( (5.) * (c*t+d));\n    \n}\n\nvec3 palette(float t)\n{\n \t return cosinusCouleur( t, vec3(0.0,0.5,0.5),vec3(0.22,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.00, 0.15, 0.20) );\n}\n\nvec3 distanceEstimation(vec3 pos)\n{\n    \n    float puissance = 0.0 + 4.0 *(iTime / 10.0) + 1.0;\n        vec3 z = pos;\n    float dr = 1.1001;\n    float r = 0.0;\n    \n    for(int i = 0; i < MANDELBROTSTEPS; i++)    \n    {\n    \tr = length(z);\n        if(r > MAXMANDELBROTDIST) break;\n        \n        // Coordone spherique\n        float theta = acos(z.z / r);\n        float phi   = atan(z.y, z.x);\n        dr = pow(r, puissance - 1.0) * puissance * dr + 1.0;\n        \n        \n        float zr = pow(r, puissance);\n        zr += abs(sin(iTime / 5.0));\n        theta = theta * puissance;\n        phi = phi * (puissance / 8.0);\n        \n        //Remap en cartesien\n        \n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n       \n    }\n    \n    \n\treturn vec3(0.5*log(r)*r/dr,75.0*pow(dr,0.128/float(RAYITERATION)), 0.5);\n}\n\nvec3 map(vec3 p)\n{\n\t\n    vec3 d = distanceEstimation(p);\n    return d;\n}\n    \n\nvec3 trace(vec3 origin, vec3 ray)\n{\n\n\tfloat t = 0.0;\n    float c = 0.0;\n    \n    \n    for(int i = 0; i < RAYITERATION; i++)\n    {\n        // r(t) = ro + rd * t // \n    \tvec3 path = origin + ray *t;\n        vec3 dist = map(path);\n        \n        t += MARCHINGAMOUNT * dist.x;\n        c += dist.y;\n        \n        if(dist.y  < MARCHINGSMALLESTSTEP) break;\n        \n    \n    }\n    \n    return vec3(t, c, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n \n    vec3 ray = normalize(vec3 (uv,1.0));\n\n\n    float rotAngle = 0.4+iTime/40.0 + 6.28 * iMouse.x / iResolution.x;\n    \n    ray.yz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n \n    //camera position (rays origin)\n    float camDist = DISTANCE  * iMouse.y / iResolution.y;\n    if (iMouse.xy==vec2(0)) camDist = DISTANCE*0.55;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n\n\tvec3 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 230, 230, 282], [284, 284, 307, 307, 422], [424, 424, 459, 459, 1273], [1275, 1275, 1293, 1293, 1347], [1354, 1354, 1389, 1389, 1764], [1766, 1766, 1823, 1823, 2653]]}
{"id": "Wty3Rw", "name": "Colorful gears", "author": "jschipper", "description": "Rotating gears.", "tags": ["gears", "beginner"], "likes": 7, "viewed": 95, "published": "Public", "date": "1578626504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,c) smoothstep(a,b,c)\n#define M_PI 3.1415926535897932384626433832795\n\nvec2 rot(vec2 xy, float phi) {\n    return vec2(xy.x*cos(phi) - xy.y*sin(phi), xy.y*cos(phi) + xy.x*sin(phi));\n}\n\nfloat gear(vec2 uv, float t) {\n    uv -= 0.5;\n\tfloat phi = atan(uv.y,uv.x) + t;\n    float d = length(uv);\n    \n    float od = 0.495;\n    \n    uv = rot(uv,t);\n    \n    float g = 0.;\n    g -= S(0.17,0.165,length(uv - vec2(0.,0.25)));\n    g -= S(0.17,0.165,length(uv - vec2(0.25,0.)));\n    g -= S(0.17,0.165,length(uv + vec2(0.,0.25)));\n    g -= S(0.17,0.165,length(uv + vec2(0.25,0.)));\n    g += S(od+0.005,od,d + atan(sin(20.*phi)*4.)/40.);\n    \n    g = min(g,1.);\n    \n    return g;\n}\n\nfloat layer(vec2 uv, float t) {\n    float l = 0.;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    for (float i = -1.; i <= 1.; i++)\n        for (float j = -1.; j <= 1.; j++) {\n    \t\tvec2 sn = mod(id + vec2(i,j),2.)*2. - 1.;\n\t\t\tl = mix(l, 1., gear(uv + vec2(i,j), sn.x*sn.y*t));\n        }\n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    uv*=.5;\n\n    float t = iTime/2.;\n    \n    float zoom_pow = 2.;\n    float z = pow(zoom_pow,fract(t));\n    uv/=z;\n    \n    uv = rot(uv,t/2.);\n    \n    vec4 col = vec4(0);\n    \n    float fade = 0.6;\n    float N = 5.;\n    \n    uv*=pow(zoom_pow,N);\n    for (float i = floor(t)+N; i > floor(t); i--) {\n        uv/=zoom_pow;\n        vec2 luv = rot(uv + .2*i, i);\n        float l = layer(luv, t);\n        \n        if (i == floor(t)+1.)\n            l *= 1. - fract(t);\n        \n        if (i == floor(t)+N)\n            l *= fract(t);\n        col = mix(col*fade, vec4(sin(i*5.3)/2. + 0.5,sin(i*8.3)/2. + 0.5,sin(i*2.3)/2. + 0.5,1.), l);\n    }\n    \n    col *= mix(fade, 1., fract(t))/fade;\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 113, 113, 194], [196, 196, 226, 226, 680], [682, 682, 713, 713, 991], [993, 993, 1050, 1100, 1893]]}
{"id": "wty3Wc", "name": "Comet Wars Background", "author": "zovox", "description": "Background of an old video game.", "tags": ["background", "comet", "wars"], "likes": 2, "viewed": 191, "published": "Public API", "date": "1580063516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n        \n        \nfloat PI = 3.14159265359;\n#define GR 1.61803398875\n#define EPS .001\n#define INFINITY 1E32     \n\n\n\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\nfloat jag(float x)\n{\n    return mod(x, 1.0);\n}\nvec2 jag(vec2 x)\n{\n    return vec2(jag(x.x), jag(x.y));\n}\n\nfloat stair(float x)\n{\n    return float(int(x));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2( g, f );\n    float k1 = cross2( e, f ) + cross2( h, g );\n    float k0 = cross2( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n\n    w = sqrt(abs( w ));\n    \n    float v1 = ((-k1 - w)/(2.0*k2));\n    float v2 = ((-k1 + w)/(2.0*k2));\n    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));\n    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));\n    bool  b1a = v1>0.0 && v1<1.0;\n    bool  b1b = u1>0.0 && u1<1.0;\n    bool  b2a = v2>0.0 && v2<1.0;\n    bool  b2b = u2>0.0 && u2<1.0;\n    \n\n    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));\n    return saw(res*1.0*PI);\n}\n\nvec2 SinCos( const in float x )\n{\n\treturn vec2(sin(x), cos(x));\n}\nvec3 RotateZ( const in vec3 vPos, const in vec2 vSinCos )\n{\n\treturn vec3( vSinCos.y * vPos.x + vSinCos.x * vPos.y, -vSinCos.x * vPos.x + vSinCos.y * vPos.y, vPos.z);\n}\n      \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n\treturn RotateZ( vPos, SinCos(fAngle) );\n}\nvec2 RotateZ( const in vec2 vPos, const in float fAngle )\n{\n\treturn RotateZ( vec3(vPos, 0.0), SinCos(fAngle) ).xy;\n}\nmat4 RotateZ( const in mat4 vPos, const in float fAngle )\n{\n\treturn mat4(RotateZ( vec3(vPos[0].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[1].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[2].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0,\n                RotateZ( vec3(vPos[3].xy, 0.0), SinCos(fAngle) ).xy, 0.0, 0.0);\n}\nmat4 translate( const in mat4 vPos, vec2 offset )\n{\n\treturn mat4(vPos[0].xy+offset, 0.0, 0.0,\n                vPos[1].xy+offset, 0.0, 0.0,\n                vPos[2].xy+offset, 0.0, 0.0,\n                vPos[3].xy+offset, 0.0, 0.0);\n} \nmat4 scale( const in mat4 vPos, vec2 factor )\n{\n\treturn mat4(vPos[0].xy*factor, 0.0, 0.0,\n                vPos[1].xy*factor, 0.0, 0.0,\n                vPos[2].xy*factor, 0.0, 0.0,\n                vPos[3].xy*factor, 0.0, 0.0);\n} \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 flux(float x)\n{\n    return vec3(cos(x*1.0)*.5+.5,\n                cos(x*1.0+4.0*PI/3.0)*.5+.5,\n                cos(x*1.0+2.0*PI/3.0)*.5+.5);\n}\nvec4 cometwars(vec2 uv)\n{\n    uv.y = uv.y*3.0-1.5;\n    uv.x = uv.x*2.0-.5;\n    \n    uv.x *= uv.x > 0.0 ? .65 : 1.0;\n    uv.x = uv.x < 0.0 ? uv.x*1.5 : pow(uv.x, .75)*1.25;\n    \n    float turns = 32.0;//uv.x < 0.0 ? 24.0: 32.0;\n    float theta = atan(uv.y, uv.x);\n    float r = length(uv)+sin(theta*turns)*.05;\n    \n    float spikyness = .75;\n    \n    float tailyness = clamp(uv.x+1.0, 0.0, 2.0)/2.5;\n    float shortenyness = clamp(-uv.x, 0.0, 1.0);\n    float bendsign = (theta > PI || theta < 0.0) ? -1.0: 1.0;\n    \n    theta += (tailyness+iTime*1.1375)*bendsign;\n    \n    r += saw(theta*turns)*spikyness+shortenyness;\n    \n    float edgefade = pow(saw(clamp(r/2.0-1.0, -0.5, .5)/.5*PI), .125);\n    float rockyness = pow(clamp(1.0-length(uv)*GR, 0.0, 1.0), .75);\n    float comet = rockyness+edgefade;//*saw(sin(atan(uv.y, uv.x)*turns/2.0-iTime*bendsign*15.6789)+pow(length(uv), 2.75)*turns*2.0-iTime*PI*15.0);\n    \n    vec4 specs = vec4(flux(2.0*PI*snoise(vec3(r*length(uv)-iTime*PI, theta*2.0, 0.0))), 1.0);\n    if(1.0 > r)\n        return vec4(0.3, 0.5, specs.b, specs.b)*comet+rockyness;//vec4(, 1.0)+clamp(.75-comet, 0.0, 1.0);\n    else \n        return vec4(1.0-saw(clamp(r-.85, 0.0, .5)/.5*PI));\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3)));\n    return fract(sin(p)*43458.3453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 persp = uv*2.0-1.0;\n    persp.x *=  iResolution.x/iResolution.y;\n    persp += vec2(cos(iTime*1.123456789)*.35-.35, cos(iTime*1.6789)*.25);\n    \n    vec2 crosshair = vec2(-0.75, 0.0);\n    \n    vec2 duv = persp-crosshair;\n    \n    duv = RotateZ(duv, cos(iTime*.25)*PI);\n    \n    float theta = atan(duv.y, duv.x);\n    float section = mod(theta, PI/2.0)/(PI/2.0);\n    section = section < .15 || section >.85 ? 1.0-(1.0-abs(section-.5)/.5)/.3: 0.0;\n    section = pow(section, .125);\n \tfloat r = length(duv);\n   \t\n    float d = .45;\n    float outerscalar = 1.25;\n    float outerw = .05;\n    \n    float outer = r > d*outerscalar && r < d*outerscalar+outerw ? section*cos(clamp(r-d*outerscalar, 0.0, outerw)/outerw*PI-PI/2.0): 0.0;\n    float grid = r > d ? outer : pow(cos(r/d*PI*9.0)*.5+.5, 2.0);\n    grid += (1.0-clamp(abs(duv.x/outerw*2.0), 0.0, 1.0))*pow(clamp(d*1.75-abs(duv.y), 0.0, 1.0)/d, .125)+\n        \t(1.0-clamp(abs(duv.y/outerw*2.0), 0.0, 1.0))*pow(clamp(d*1.75-abs(duv.x), 0.0, 1.0)/d, .125);\n    grid = pow(grid, 2.0);\n    \n    uv += vec2(cos(iTime*1.234), cos(iTime*1.456))*.05;\n    vec4 c = cometwars(uv);\n    uv -= vec2(iTime*.5, 0.0);\n    float scale = 40.;\n    float radius = 1.5;\n    vec2 gridPosition = floor(uv * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv * scale) - .5;\n    float stars = mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n    \n    fragColor = vec4(0.3, 0.5, 1.0, 1.0)*c.b*(1.0-grid)+vec4(1.0, 0.0, 0.0, 1.0)*grid;\n    fragColor += clamp(1.0-length(fragColor), 0.0, 1.0)*stars;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 183], [185, 185, 205, 205, 237], [238, 238, 256, 256, 288], [289, 289, 309, 309, 335], [336, 336, 354, 354, 393], [395, 395, 417, 417, 445], [446, 446, 521, 521, 1198], [1200, 1200, 1233, 1233, 1265], [1266, 1266, 1325, 1325, 1433], [1441, 1441, 1500, 1500, 1543], [1544, 1544, 1603, 1603, 1660], [1661, 1661, 1720, 1720, 2036], [2037, 2037, 2088, 2088, 2268], [2270, 2270, 2317, 2317, 2497], [2500, 2500, 2521, 2521, 2570], [2572, 2572, 2594, 2594, 2634], [2636, 2636, 2664, 2664, 2716], [2718, 2718, 2739, 2739, 2788], [2790, 2790, 2811, 2811, 2860], [2862, 2862, 2884, 2884, 2921], [2923, 2923, 2947, 2947, 5062], [5064, 5064, 5084, 5084, 5211], [5212, 5212, 5237, 5237, 6413], [6415, 6415, 6436, 6436, 6541], [6543, 6543, 6600, 6600, 8264]]}
{"id": "Wty3Wh", "name": "Infinite circles", "author": "mgejke", "description": "Learning... ", "tags": ["circles", "infinity"], "likes": 5, "viewed": 77, "published": "Public", "date": "1578751058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p, float r, float blur)\n{\n    float d = length(p-vec2(0));\n    float m = smoothstep(-blur, blur, r-d);\n    m *= smoothstep(blur, -blur, r-d - 0.03);\n    return m;\n}\n\nfloat circle_layer(vec2 uv) \n{\n    uv = fract(uv) - 0.5;        \n    float m = circle(uv, 0.1, 0.005);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    uv.x += sin(iTime * 0.6) * 0.4;\n    uv.y += cos(iTime * 0.2) * 0.4;\n    \n\tfloat layers = 42.;\n    float m = 0.;\n    for(float j = 0.; j < layers; j++)\n    {\n        float i = j / layers;\n        \n        float z = fract(i + iTime * 0.1);\n        float size = mix(30. + sin(iTime) * 10. , 1., z);\n        float a = mix(0., 2.*3.14159265, z);\n        \n        float fade = smoothstep(0., 0.99, z) * smoothstep(1.0, .9, z);\n\n        vec2 suv = uv * size;\n        suv.x += sin(z * 3. + iTime) * 0.4;\n        suv.y += cos(z * 7. + iTime) * 0.2;\n        \n        m += circle_layer(suv) * fade * 0.7;\n    }\n    \n    col += m * (sin(vec3(0.23, 0.43, 0.67)*iTime) * 0.4 + 0.6);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 182], [184, 184, 214, 214, 302], [304, 304, 361, 361, 1156]]}
{"id": "wty3z1", "name": "Triangulo-falsov1", "author": "jorge2017a1", "description": "Usar el Mouse!!", "tags": ["triangulofalsov1"], "likes": 1, "viewed": 61, "published": "Public", "date": "1578274490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 =9;\n//------------------------------------\n\n#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.1\n#define CR30 0.3\n#define CR31 1.0\n#define CR32 0.2\n#define CR33 0.1\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    \tvec3 o = min(3.0*p - m, 0.0);\n    \to = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    \treturn length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \t\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    \telse if( 3.0*p.y < m ) q = p.yzx;\n    \telse if( 3.0*p.z < m ) q = p.zxy;\n        \n    else return m*0.57735027;\n        float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n        return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\t\treturn m*0.57735027;\n    #endif\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.1*cb2)*0.8;\n        \n    } \n}\n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\nfloat trianguloFalso(vec3 p, vec3 pos, float alto )\n{\n    float sdh1= sdOctahedron( p-pos,alto);\n\tfloat plane= dot(p-pos,normalize(vec3(0.,1.,0.)));  //plano xz\n    return differenceSDF(sdh1,plane);\n}   \n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,CSky); }\n        else\n         { \n            //res=vec2(res.x, CPlane2);\n             res=vec2(res.x, 11);\n    \n         } \n     } \n    \n    \n    float sdt1= trianguloFalso( p, vec3(5,0.,-3.0), 2.5 );\n    float sdt2= trianguloFalso( p, vec3(-5,0.,-5.0), 5. );\n    float sdt3= trianguloFalso( p, vec3(15,0.,-3.0), 8. );\n    float sdt4= trianguloFalso( p, vec3(5,0.,8.0), 5. );\n    \n    vec3 pr= rotate_y(p, iTime);\n    float sdt5= trianguloFalso( pr, vec3(0.0,4.0,0), 2.5 );\n    \n    res=opU(res, vec2(sdt1,6));\n    res=opU(res, vec2(sdt2,7));\n    res=opU(res, vec2(sdt3,8));\n    res=opU(res, vec2(sdt4,10));\n    res=opU(res, vec2(sdt5,11));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = gres2; //RayMarch(ro,rd);\n    vec3 Ambient= vec3(0.1,0.1,0.1);\n         \n    float t = res.x;\n\tfloat m = res.y;\n    \n    if (mObj.tipo==12.0 )\n     { return  getSphereColor(int( mObj.tipo)) ; }\n    \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    \n    \n    return col;\n}\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    \n    vec3 ro = vec3(-5.,2.5,10.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n  \n    \n    vec3 col = vec3(0);\n  \n    \n    TObj Obj;\n    \n   \n    \n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n    \n    \n    \n    \n    float dif = GetLight(p);\n    \n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n    vec3 colobj;\n    \n    \n    colobj=getSphereColor(int( Obj.tipo));\n   \n    dif=(dif+dif2)/2.5;\n    \n   \n    col =  ( vec3(dif)+colobj)/2.5;\n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1012, 1029, 1062, 1062, 1127], [1128, 1146, 1182, 1182, 1251], [1252, 1267, 1298, 1298, 1448], [1449, 1469, 1505, 1505, 1592], [1593, 1609, 1641, 1669, 1730], [1733, 1743, 1779, 1779, 2052], [2054, 2103, 2140, 2140, 2758], [2760, 2760, 2806, 2806, 2838], [2840, 2840, 2882, 2882, 2914], [2916, 2916, 2963, 2963, 2996], [2999, 2999, 3028, 3028, 3154], [3156, 3156, 3192, 3192, 3309], [3311, 3311, 3347, 3347, 3465], [3517, 3529, 3551, 3551, 3859], [3860, 3886, 3911, 3911, 4101], [4102, 4147, 4164, 4164, 4237], [4240, 4273, 4299, 4299, 4496], [4497, 4544, 4572, 4572, 6158], [6212, 6321, 6358, 6358, 6393], [6396, 6396, 6449, 6449, 6596], [6605, 6605, 6630, 6630, 7731], [7734, 7734, 7768, 7768, 8127], [8129, 8129, 8166, 8166, 8496], [8500, 8500, 8524, 8524, 8756], [8760, 8760, 8784, 8784, 9169], [9172, 9172, 9198, 9198, 9562], [9565, 9565, 9590, 9590, 9618], [9620, 9620, 9672, 9672, 10068], [10131, 10175, 10192, 10192, 10263], [10288, 10380, 10405, 10405, 10668], [10670, 10726, 10798, 10798, 10825], [10827, 10827, 10884, 10884, 12133]]}
{"id": "Wty3zc", "name": "jaula-v1", "author": "jorge2017a1", "description": "Usar el MOUSE para mover!!!", "tags": ["jaulav1"], "likes": 1, "viewed": 49, "published": "Public", "date": "1579450395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdHex(vec2 p, float h) \n{\n    vec3 k = vec3(-0.8660254, 0.57735, 0.5);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xz, p), 0.0) * k.xz;\n    return length(p - vec2(clamp(p.x, -k.y * h, k.y * h), h)) * sign(p.y - h);\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n\n///----------------------------------------------\nfloat barandal(vec3 p)\n{   \n    vec2 res;\n    float numbar;\n    float anchoMat;\n    float numLuz;\n    float total;\n    float Luz;\n    float sdbfin;\n    \n    \n    res= vec2(999.9);\n    \n    numbar=10.0;\n    anchoMat=0.125;\n    numLuz=numbar-1.0;\n    total=13.0;\n    Luz=(total-numbar*anchoMat)/numLuz;\n    \n    sdbfin=999.9;\n    \n    \n    \n    //horizontal\n    float sdbh1sup =sdBox(p-vec3(-total/2.0,6.0,0.0), vec3(total/2.0,0.25,0.25) );\n    float sdbh1inf =sdBox(p-vec3(-total/2.0,1.0,0.0), vec3(total/2.0,0.25,0.25) );\n    \n    //vertical\n    float sdbv1 =sdBox(p-vec3(-total-0.,0.0,0.0), vec3(0.25,6.5,0.25) ); //inicio\n    float sdbv2 =sdBox(p-vec3(total-0.,0.0,0.0), vec3(0.25,6.5,0.25) );  //fin\n    \n    \n    res =opU(res, vec2(sdbh1sup,8.0));\n    res =opU(res, vec2(sdbh1inf,8.0));\n    \n    \n    for(float ii=0.0; ii<numbar; ii++) \n    {\n        float sdbtmp1 =sdBox(p-vec3(-total+ (Luz+anchoMat)*(ii+0.0),3.5,0.0), vec3(anchoMat,3.0,0.25) ); //inicio\n        sdbfin=min(sdbfin,sdbtmp1);\n    }\n   \n    res =opU(res, vec2(sdbfin,8.0));\n    \n    return res.x;\n    \n    \n}\n///----------------------------------------------\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 13);\n             \n         } \n     }\n   \n    \n    \n    float bar1= barandal(p); //frente\n    float bar2= barandal(p.zyx);  //lateral izq\n    float bar3= barandal(p.zyx+ vec3(0.0,0.0,13.0));  //lateral der\n    float bar4= barandal(p+vec3(0.0,0.0,13.0));  //atras\n        \n    res=opU(res, vec2(bar1,9.0));\n    res=opU(res, vec2(bar2,8.0));\n    res=opU(res, vec2(bar3,8.0));\n    res=opU(res, vec2(bar4,8.0));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    //vec3 ta = vec3(5.,0.95,1.+yt);\n    //vec3 ro = vec3(-5.,0.5,-2.+yt);\n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,5.5,20.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3zc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1207, 1289, 1289, 1520], [1523, 1523, 1554, 1554, 1742], [1745, 1799, 1821, 1821, 3081], [3084, 3148, 3184, 3184, 3457], [3459, 3509, 3555, 3555, 3587], [3589, 3589, 3632, 3632, 3664], [3666, 3666, 3714, 3714, 3747], [3750, 3750, 3779, 3779, 3905], [3907, 3907, 3943, 3943, 4060], [4062, 4062, 4098, 4098, 4216], [4268, 4280, 4302, 4302, 4610], [4611, 4637, 4662, 4662, 4852], [4853, 4898, 4915, 4915, 4988], [4991, 5024, 5050, 5050, 5247], [5248, 5294, 5346, 5346, 5501], [5566, 5675, 5712, 5712, 5747], [5749, 5749, 5768, 5768, 5843], [5846, 5896, 5920, 5920, 6974], [6975, 7030, 7055, 7055, 8015], [8018, 8018, 8052, 8052, 8441], [8446, 8446, 8470, 8470, 8702], [8706, 8706, 8730, 8730, 9115], [9118, 9118, 9144, 9144, 9508], [9511, 9511, 9536, 9536, 9564], [9566, 9566, 9618, 9618, 10014], [10117, 10161, 10178, 10178, 10249], [10274, 10366, 10391, 10391, 10654], [10656, 10715, 10743, 10743, 12626], [12630, 12630, 12687, 12687, 14097]]}
{"id": "wty3zh", "name": "original-28550-0", "author": "jorge2017a1", "description": "original-28550-0--Autor: sphinx", "tags": ["original285500"], "likes": 37, "viewed": 436, "published": "Public", "date": "1578256828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// sphinx\n// note: compilation error corrected, but white part is still wrong ???\n\n// ?\n// thank you\n// here is a bunny\n// which white part?\n\n// Bugs fixed ?\n// i fixed it ;) you have to change every pow(x,a) to pow(abs(x),a), because nvidia cards dont allow negative powers ^^\n\n\n\n#define SURFACE_THRESHOLD \t.001\n#define FAR_PLANE\t\t5.\n\n#define VIEW_POSITION\t\tvec3(0., -.15, 1.5)\t\t\n#define VIEW_TARGET\t\tvec3(0., 0., -1.);\n\n#define LIGHT_POSITION\t\tvec3(128., 64., 128.)// * vec3(sin(time*.125), 1., cos(time*.125))\n#define PI \t\t\t(4.*atan(1.))\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tfloat range;\n\tfloat total_range;\n\tfloat edge;\n\tfloat id;\n};\n\n\t\nstruct light\n{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\t\n};\n\n\nstruct material\n{\n\tfloat roughness;\n\tfloat index;\n\tvec3 normal;\n\tvec3 color;\n};\n\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nmat3 rmat(in vec3 r)\n{\n\tvec3 a = vec3(cos(r.x)*cos(r.y),sin(r.y),sin(r.x)*cos(r.y));\n\t\n\tfloat c = cos(r.z);\n\tfloat s = sin(r.z);\n\tvec3 as  = a*s;\n\tvec3 ac  = a*a*(1.- c);\n\tvec3 ad  = a.yzx*a.zxy*(1.-c);\n\tmat3 rot = mat3(\n\t\tc    + ac.x, \n\t\tad.z - as.z, \n        \tad.y + as.y,\n\t\tad.z + as.z, \n\t\tc    + ac.y, \n\t\tad.x - as.x,\n\t\tad.y - as.y, \n\t\tad.x + as.x, \n\t\tc    + ac.z);\n\treturn rot;\t\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\t\n}\n\t\nfloat smoothmax(float a, float b, float k)\n{\n\treturn log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\n\nfloat cube(vec3 p,vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat bunny(vec3 p)\n{\n        float b = FAR_PLANE;\n\tp *= .75;\n\tp.y += .5;\n\tp.z += .5;\n\tp.x = abs(p.x)+.5;\n\t\n\n       \n        vec3 bp01 = p - vec3(.5, 0.14, .16);\n        vec3 bp00 = p - vec3(.5, 0.18, .26);\n        vec3 bp0 = p - vec3(.5, 0.25, .25);\n        vec3 bp2 = p - vec3(.5, 0.25, .35);\n        vec3 bp1 = p - vec3(.5, 0.20, .6);\n        vec3 bp3 = p - vec3(.5, 0.25, .75);\n        vec3 bp4 = p - vec3(.5, 0.2, .84);\n        vec3 bp5 = p - vec3(.58, 0.25, .34)* vec3(1., .8, 1.);\n        vec3 bp6 = (p - vec3(.6, 0.12, .5)) * vec3(2., 1.8, .8);\n        vec3 bp7 = (p - vec3(.6, 0.1, .55)) ;\n        vec3 bp8 = (p - vec3(.56, 0.08, .7)) * vec3(1., 1., .35);\n        vec3 bp9 = (p - vec3(.56, 0.34, .62));\n        vec3 bp10 = (p - vec3(.56, 0.25, .86)) * vec3(1., 1., .35);\n        vec3 bp11 = (p - vec3(.56, 0.25, .82)) * vec3(.8, 1.1, .85);;\n        vec3 bp12 = (p - vec3(.5, 0.16, .9));\n    \n        bp9 \t= rotx(bp9, -1.9) * vec3(.8, .15, .5);;\n        \n        float b01 = sphere(bp01, .015);\n        float b00 = sphere(bp00, .05);\n        float b0  = sphere(bp0, .05);\n        float b1  = sphere(bp1, .07);\n        float b2  = sphere(bp2, .15);\n        float b3  = sphere(bp3, .085);\n        float b4  = sphere(bp4, .055);\n        float b5  = sphere(bp5, .12);\n        float b6  = sphere(bp6, .08);\n        float b7  = sphere(bp7, .03);\n        float b8  = sphere(bp8, .02);\n        float b9  = sphere(bp9, .02);\n        float b10 = sphere(bp10, .01);\n        float b11 = sphere(bp11, .012);\n        float b12 = sphere(bp12, .005);\n    \n        b00  = smoothmin(b00,   b01, 128.);   //torso\n        b0   = smoothmin(b00,   b0, 32.);     //torso\n        b    = smoothmin(b0,    b1, 5.);      //torso\n        b    = smoothmin(b,     b2, 35.);\n        b    = smoothmin(b,     b3, 28.);\n        \n        b    = smoothmin(b,     b4, 27.);    //head\n\n        b6 = smoothmin(b5, b6, 32.0);  //back leg\n        b7 = smoothmin(b6, b7, 96.0);  \n        b  = smoothmin( b, b7, 252.0);  \n    \n        b  = smoothmin(b, b8, 36.0);  //front legs\n    \n        b  = smoothmin(b, b9, 192.0);  //ears\n    \n        b  = smoothmax(b, -b10, 64.0);  //eye\n        b  = smoothmin(b,  b11, 256.0);  \n    \n        b  = smoothmin(b,  b11, 256.0);  //nose\n        b  = smoothmax(b,  -b12, 64.0); \n    \n  \n    return b;\n}\n\n\n\nvec2 map(in vec3 position)\n{\n\tfloat fx \t\t= abs(fract(position.x*2.)-.5);\n\tfloat fy \t\t= abs(fract(position.z*2.)-.5);\n\tfloat f \t\t= position.y + max(max(fx, fy)*.2, .095)+.5;\n\t\n\tposition.xz \t\t*= rmat(iTime*.125);\n\t\n\tfloat b \t\t= bunny(position);\n\n\tfloat id \t\t= b < f ? 1. : 2.;\n\t\n\treturn vec2(min(f,b), id);\n}\n\n\nvec3 derive(const in vec3 position, const in float range)\n{\n\tvec2 offset     = vec2(0., range);\n\tvec3 normal     = vec3(0.);\n\tnormal.x    \t= map(position+offset.yxx).x-map(position-offset.yxx).x;\n\tnormal.y    \t= map(position+offset.xyx).x-map(position-offset.xyx).x;\n\tnormal.z    \t= map(position+offset.xxy).x-map(position-offset.xxy).x;\n\treturn normalize(normal);\n}\n\n\t\nvoid emit(inout ray r)\n{\n\tfloat minimum_range\t= SURFACE_THRESHOLD;\n\tfloat closest_range\t= FAR_PLANE;\n\t\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\tvec2 scene\t= map(r.position);\n\t\tr.range \t= scene.x;\n\t\tr.id\t\t= scene.y;\n\t\tr.range \t= r.range < 0. ? r.range - r.range * .5 : r.range;\n\t\t\t\n\t\tr.range\t \t*= .6;\t\t//slow down ray\n\t\tminimum_range\t*= 1.0125;\t//relax surface\n\t\t\n\t\tr.total_range\t+= r.range;\n\t\t\n\t\tr.position \t= r.origin + r.direction * r.total_range;\t\n\t\t\n\t\tif(closest_range > r.range)\n\t\t{\n\t\t\tr.edge += .001225;\t\n\t\t}\n\t\t\n\t\tclosest_range\t= min(closest_range, abs(r.range));\n\t\t\n\t\tif(r.range < minimum_range || r.total_range > FAR_PLANE)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t}\t\n}\n\n\nfloat fresnel(const in float i, const in float ndl)\n{   \n\treturn i + (1.-i) * pow(abs(1.-ndl), 5.0);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(2./PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\n\nfloat distribution(const in float r, const in float ndh)\n{  \n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(abs(ndh), m)*.5;\n}\n\n\nfloat shadow(const in vec3 position, const in vec3 direction)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= 0.15;\n\tfloat umbra\t= .00125;\n    \tfor(int i = 1; i < 8; ++i)\n    \t{\n\t\tfloat range\t= map(position + direction * penumbra).x;\n\t\t\n\t\tif ( range < umbra) return umbra;\n\t\t\n\t\texposure \t= min( exposure, 5. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t\n\treturn exposure;\n}\n\n\nfloat occlusion(in vec3 p, in vec3 n )\n{\n  \tfloat occlusion = 0.;\n  \tfloat penumbra \t= .125;\n  \tfor ( int i=0; i < 8; i++ )\n  \t{\n  \t\tfloat radius \t= .125 * penumbra * float(i);\n    \t\tfloat range \t= map(n * radius + p).x - radius;\n    \t\tocclusion \t-= penumbra * range;\n  \t}\n  \treturn 1.0 - 3.0 * occlusion;\n}\n\n\n//adapted from this nice sun here: http://glslsandbox.com/e#28403.2\nvec3 sky(in vec3 direction, in vec3 light_direction)\n{ \n\tfloat yd \t= min(-direction.y, 0.);\n\n\tdirection.y \t= max(direction.y, 0.)+.05;\n    \n\tvec3 col \t= vec3(0.);\n    \n\tcol += vec3(.4, .4 - exp( -direction.y * 20.) * .3, .0) * exp(-direction.y * 9.); // Red / Green \n\tcol += vec3(.3, .5, .6) * (1. - exp(-direction.y * 8.)) * exp(-direction.y * .9) ; // Blue\n    \n\tcol = mix(col, vec3(.4),  .45-exp(yd*7.)) * .65; // Fog\n    \n\tvec3 sun_color = vec3(1., .66, .25);\n\tcol += pow(dot(abs(direction), light_direction), 15. ) * sun_color * .35;\n\tcol += pow(dot(abs(direction), light_direction), 150.0) *.05;\n\t\n    \treturn clamp(pow(abs(col), vec3(1.1))*2., 0., 1.);\n}\n\n\nvec4 shade( ray r,  light l,  material m)\n{\n\tvec3 half_direction \t\t= normalize(r.direction-l.direction);\n\tfloat half_normal   \t\t= dot(half_direction, m.normal);\n\t\t\n\tif(r.total_range < FAR_PLANE)\n\t{\t\n\t\t//exposure coefficients\n\t\tfloat light_exposure    \t= dot(m.normal,  l.direction);   \n\t\tfloat view_exposure     \t= dot(m.normal, -r.direction);  \n\t\t\n\t\t//microfacet lighting components\n\t\tfloat d             \t\t= distribution(m.roughness, half_normal);\n\t\tfloat g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n\t\tfloat f             \t\t= fresnel(m.index, light_exposure);\n\t\tfloat n             \t\t= clamp(1. - fresnel(f, view_exposure), 0., 1.);\n\t\t\n\t\t//bidrectional reflective distribution function\n\t\tfloat brdf              \t= n * (g*d*f)/(view_exposure*light_exposure*4.);\t\t\n\t\t\n\t\tfloat shadows\t\t\t= shadow(r.position, l.direction);\n\t\tshadows\t\t\t\t= clamp(shadows, .125, 1.);\n\n\t\tfloat occlusions\t\t= occlusion(r.position, m.normal);\n\t\tocclusions\t\t\t= clamp(occlusions, .05, 1.);\n\t\n\t\tvec3 color\t\t\t= m.color * n + m.color * l.color + brdf * l.color;\n\t\tcolor \t\t\t\t*= shadows * occlusions;\n\t\tcolor \t\t\t\t+= exp(.025 * r.total_range) * l.color * .25;\n\t\treturn vec4(color, occlusions * shadows);\n\t}\n\telse\n\t{\n\t\treturn vec4(sky(r.direction, l.direction), 1.) * 1.5 + vec4(exp(-r.total_range));\t\n\t}\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 facet(vec3 normal, vec3 position, float roughness)\n{\n\troughness *= .05;\n\treturn normal;\n}\n\nvec3 cartesian_to_spherical(vec3 c)\n{\n    vec3 s;\n    s.x = length(c);\n    s.y = atan(c.z / c.x);\n    s.z = asin(c.y / s.x);\n\treturn s;\n}\n\nvoid assign_material(in ray r, out material m)\n{\n\tm=material(0., 0., vec3(0.), vec3(0.));\n\t\n\tif(r.id == 0.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .5 ^^ p.y < .5 ^^ p.z < .5) + .25;\n\t}\n\telse if(r.id == 1.)\n\t{\n\t\tm.roughness \t= .3125;\n\t\tm.index\t\t= .75;\n\t\tm.color\t\t= vec3(.5);\n\t}\n\telse if(r.id == 2.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index \t= .5;\n\t\tvec3 p\t\t= fract(r.position);\n\t\tm.color \t+= float(p.x < .5 ^^ p.y < .5 ^^ p.z < .5) * .5 + .125;\n\t}\n\t\n\tm.normal = derive(r.position, SURFACE_THRESHOLD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t= iResolution.xy/iResolution.yy;\n\t\n\tvec2 uv \t\t= fragCoord.xy/iResolution.xy;\n\tuv     \t\t\t= uv * 2. - 1.;\n    \tuv   \t\t\t*= aspect;\n   \t\n\t//view\n\tray r;\n\tr.range \t\t= 0.;\n\tr.total_range\t\t= 0.;\n\tr.edge\t\t\t= 0.;\n\tr.origin\t\t= VIEW_POSITION;\n\tr.position\t\t= r.origin;\n\t\n\tvec3 target\t\t= VIEW_TARGET;\n\tfloat fov\t\t= 2.5;\n\tvec3 w \t\t\t= normalize(target-r.position);\n    \tvec3 u \t\t\t= normalize(cross(w, vec3(0.,1.,0.)));\n    \tvec3 v \t\t\t= normalize(cross(u,w));\n\t\n    \tmat3 view\t \t= mat3(u.x, v.x, w.x, \n\t\t\t\t       u.y, v.y, w.y, \n\t\t\t\t       u.z, v.z, w.z);\n\n//\tuv.y \t\t\t= (mouse.y-.5+uv.y);\n\tuv.y \t\t\t-= .25;\n\tr.direction  \t\t= normalize(uv.x * u + uv.y * v + fov * w) * view;\n\tr.direction.xz\t\t*= rmat(PI);\n\t//r.direction.xz\t\t*= rmat(.5 * mouse.x * PI + PI * .75);\n\t\n\t//trace\n\temit(r);\n\t\n\t//shade\t\t\n\tmaterial m;\n\tassign_material(r, m);\n\t\t\n\tlight l;\n\tl.position \t\t= LIGHT_POSITION;\n\tvec4 color\t\t= vec4(0.);\t\n\t\n\t//reflections\n\tif(r.total_range < FAR_PLANE)\n\t{\n\t\t//reflection\n\t\tray rr\t\t\t= r;\n\t\trr.position\t\t= rr.position + m.normal * SURFACE_THRESHOLD * 1.5;\n\t\trr.origin\t\t= rr.position;\n\t\trr.direction \t\t= normalize(reflect(r.direction, m.normal));\n\n\t\trr.range\t\t= 0.;\n\t\trr.total_range\t\t= 0.;\n\n\t\temit(rr);\n\n\t\tmaterial rm;\n\t\tassign_material(rr, rm);\n\t\tl.direction\t\t= normalize(l.position - rr.position);\n\t\tvec3 rsky\t\t= sky(reflect(rr.direction, -rm.normal), l.direction);\n\t\tl.color \t\t= rsky;\n\t\tvec4 reflection\t\t= shade(rr, l, rm);\n\n\t\tl.direction\t\t= normalize(l.position - r.position);\n\t\tvec3 skyVec\t\t= sky(reflect(r.direction, m.normal), l.direction);\n\t\tl.color\t\t\t= clamp(mix(skyVec, reflection.xyz*reflection.w, m.index), 0., 1.);\n\t\t\n\t\tcolor \t\t\t= shade(r, l, m);\n\t\tcolor \t\t\t= mix(max(color, reflection), color, clamp(1.-m.index + m.roughness, 0., 1.)) \n\t\t\t                  + vec4(.95 * r.edge * skyVec, 0.) * color.w;\n\t}\n\telse\n\t{\n\t\tr.position \t= r.origin * r.direction * FAR_PLANE;\t\n\t\tl.direction\t= normalize(l.position - r.position);\n\t\tl.color\t\t= sky(r.direction, l.direction);\n\t\tcolor.xyz\t+= l.color*1.25+2.5/(r.position.y+1.35)*.125;\n\t}\n\t\n\tcolor \t= pow(color*.85, vec4(1.6));\n\tcolor.w = 1.;\n\tfragColor \t\t= color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 816, 839, 839, 906], [909, 909, 931, 931, 1294], [1296, 1296, 1327, 1327, 1351], [1354, 1354, 1398, 1398, 1434], [1436, 1436, 1480, 1480, 1521], [1523, 1523, 1551, 1551, 1649], [1652, 1652, 1679, 1679, 1768], [1771, 1771, 1792, 1792, 4075], [4079, 4079, 4107, 4107, 4385], [4388, 4388, 4447, 4447, 4754], [4758, 4758, 4782, 4782, 5408], [5411, 5411, 5464, 5464, 5513], [5516, 5516, 5572, 5572, 5762], [5765, 5765, 5823, 5823, 5892], [5895, 5895, 5958, 5958, 6267], [6270, 6270, 6310, 6310, 6577], [6580, 6648, 6702, 6702, 7309], [7312, 7312, 7355, 7355, 8613], [8615, 8615, 8650, 8650, 8735], [8737, 8737, 8794, 8794, 8831], [8833, 8833, 8870, 8870, 8970], [8972, 8972, 9020, 9020, 9525], [9527, 9527, 9584, 9584, 11693]]}
{"id": "wty3zw", "name": "Linked Twist", "author": "willstall", "description": "Dither-Styled Polar-Coordinate Linked Geometry inspired by the work of @patriciogv on his Spirit Deck Project.\n\nINSTA: instagram.com/willstall/\nWEBSITE: willstall.com\nTWITTER: twitter.com/willstall\n", "tags": ["sdf", "dither", "geometry", "polar", "hex", "hex"], "likes": 4, "viewed": 311, "published": "Public API", "date": "1578505670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Linked Twist\n// by @willstall\n//------------------------------------------------------------------------\n\n#define SIDES 7\n\n#define SECONDS 5.0\n#define COLORS 24.0\n\n#define DITHER_AMOUNT 90.0\n#define DITHER_SIZE 8.0\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\nmat2 rotate(float angle){   return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );    }\n\nvec2 ratio(vec2 st)\n{\n    return  vec2(\n            max(st.x/st.y,1.0),\n            max(st.y/st.x,1.0)\n            );\n}\n\nvec2 center(vec2 st)\n{\n    float offset = iResolution.x/iResolution.y;\n    st.x = st.x * offset - offset * 0.5 + 0.5;\n    return st;\n}\n\nfloat divide(float x,float a){          return floor(x * a)/a;    }\n\n// cos color palette by iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\treturn a + b*cos( 6.28318*(c*t+d) );\t}\n\nvec3 color_gradient(float x){          return texture(iChannel0, vec2(x,0.5),-10.0).rgb;}\nvec3 color_gradient(float x,float a){   return color_gradient(divide(x,a));    }\n\nfloat random(vec2 st){  return fract( sin( dot(st,vec2(3.678,678.90)) )*678910.0 ); }\n\nfloat dither(vec2 st, float x, float amount)\n{\n    float s = 1.0/DITHER_SIZE;\n\n    st *= amount;\n    st.y += 0.5*step(mod(st.x,2.0),1.0);\n\n    float c = length(fract(st)-0.5)*x*0.5;\n    c = smoothstep(0.75,1.0,1.0-c)*(s)*0.5;   \n    return fract(x + c );\n    //return x+c;\n}\n\n\nfloat hex(vec2 pos)\n{\n    pos = abs(pos);\n    float d = dot(pos,normalize(vec2(1.0,1.73)));\n        d = max(d,pos.x);\n    return d;\n}\n\nvec2 hexCoords(vec2 st, out vec2 position)\n{\n    vec2 aspect = vec2(1.00,1.73);\n    vec2 h_aspect = aspect * 0.5;\n\n    vec2 a = mod(st,aspect)-h_aspect;\n    vec2 b = mod(st-h_aspect,aspect)-h_aspect;\n\n    vec2 grid;\n    if(length(a) <length(b))\n        grid = a;\n    else\n        grid = b;    \n\n    position = st-grid;\n    return vec2(grid.x,grid.y);\n}\n\nfloat cutout(float x, float y, float cut)\n{\n    float z = x;\n    z = max(z,-y+cut);\n    z = min(z,y);\n    return z;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime/SECONDS);\n    float interval = floor(mod(iTime,SECONDS));\n\n\tvec2 st = fragCoord/iResolution.xy;\n    st = center(st);\n    st = st * 2.0 - 1.0;  \n    \n    vec2 uv = st;\n    \n    st *= 01.35;\n    st *= 1.0 + 0.025*sin(TWO_PI*time);\n    st *= rotate(TWO_PI*.25);      \n\n    float pixelSmoothing = 2.0;\n    float aa = ratio(iResolution.xy).x/iResolution.x;\n    aa *= pixelSmoothing;\n    \n    float cut_size = 0.1125;\n\n    const int n = SIDES;\n    float a = TWO_PI/float(n);\n\n    vec2 pos;\n    vec2 angle_st = hexCoords(st*1.0,pos);\n    float angle = atan(angle_st.x,angle_st.y)/TWO_PI+0.5;\n\n    float debug;\n    float sdf = 1.0;\n\n    float distance_offset = 0.25;\n    \n    for(int i = 0; i <= n*2; i++)\n    {\n        vec2 pos = (st) * rotate(float(i)*a)-distance_offset;\n        float size = .06*(0.5+0.5*sin(TWO_PI*time+HALF_PI*(pos.x-pos.y*.65)));\n        float d = abs(hex(pos)-0.5)+size;\n        float cut = pos.x-pos.y*.65;\n        cut = smoothstep(-aa,aa,sdf);\n        cut = (mod(float(i),2.0) >= 1.0) ? 1.0-cut :cut;\n\n        float m = cutout(d/cut,sdf/cut,cut_size);\n        sdf = min(sdf,m);\n    }\n\n    float texture = dither(st,sdf+a,DITHER_AMOUNT);\n    float cutoff = sdf-0.025;\n    cutoff = smoothstep(-aa,aa,cutoff);\n    \n    st = hexCoords(st*0.44,pos);\n    a = atan(st.x,st.y)/TWO_PI+0.5;\n\t\n    float grad = fract(texture*1.0-time*1.0+a*1.0);\n    vec3 tex = color_gradient(grad,COLORS);\n\t\n    vec3 p = palette(length(tex),vec3(1.25,0.125,0.025),vec3(0.0,0.95,0.125),vec3(1.0, 0.5, 0.0),vec3(0.5));\n    tex = p;\n    \n    float size = hex(st);\n    float outside_cutoff = max(sdf-0.25,-(sdf-0.23));\n    outside_cutoff = smoothstep(-aa,aa,outside_cutoff);\n\t\n    float bg = length(uv)-0.75-0.25*random(uv);\n    vec3 background = vec3(0.9333, 0.9333, 0.9333);\n    vec3 col = vec3(background);\n    \tcol = mix(vec3(1.0),col,bg);\n        col = mix(tex,col,cutoff);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wty3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 377, 402, 402, 470], [472, 472, 493, 493, 591], [593, 593, 615, 615, 727], [729, 729, 759, 759, 796], [798, 825, 896, 896, 935], [937, 937, 966, 966, 1026], [1027, 1027, 1064, 1064, 1107], [1109, 1109, 1131, 1131, 1194], [1196, 1196, 1242, 1242, 1470], [1473, 1473, 1494, 1494, 1606], [1608, 1608, 1652, 1652, 1960], [1962, 1962, 2005, 2005, 2079], [2081, 2081, 2114, 2114, 2261], [2263, 2263, 2320, 2320, 4249]]}
{"id": "Wty3zz", "name": "Two Orbiting Neon Pulsars", "author": "izutionix", "description": "Following The simplest 3D tutorial by The Art of Code: https://youtu.be/dKA5ZVALOhs", "tags": ["orbit", "pulsars"], "likes": 4, "viewed": 201, "published": "Public", "date": "1578073344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0., .5, -2.);\n    vec3 rd = vec3(uv.x, uv.y, 0.)-ro;\n    \n    float t = iTime*2.;\n    vec3 p =.5*vec3(sin(t), 0., .5+cos(t));\n    vec3 q =.5*vec3(sin(t+3.1416), 0., .5+cos(t+3.1416));\n    float d = DistLine(ro, rd, p);\n    float e = DistLine(ro, rd, q);\n    \n    d = pow(.05/(d+0.), 1.);\n    e = pow(.05/(e+0.), 1.);\n\n    fragColor = vec4(d*vec3(1.,0.,1.)+e*vec3(0.,1.,1.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 88], [90, 90, 147, 147, 642]]}
{"id": "wtyGD1", "name": "3d ray-triangle intersection", "author": "16807", "description": "Distance field to a triangle. Click the screen to rotate.", "tags": ["raycasting", "triangle", "analytic", "minimal"], "likes": 1, "viewed": 50, "published": "Public", "date": "1578798784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\n\nFUNC(float) get_distance_along_3d_line_intersecting_plane(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(vec3) N){\n    return -dot(A0-B0, N) / dot(A,N);\n}\nFUNC(bool) try_distance_along_3d_line_intersecting_triangle(IN(vec3) A0, IN(vec3) A, IN(vec3) B1, IN(vec3) B2, IN(vec3) B3, OUT(float) intersection){\n    // INTUITION: intersect line with plane and find the point of intersection\n    // chen for each leg, make sure the angle between the point and the leg is less\n    // than the angle between that leg and the adjacent leg. \n    vec3  B0 = (B1 + B2 + B3) / 3.;\n    vec3  N  = normalize(cross(B1-B2, B2-B3));\n    float t  = get_distance_along_3d_line_intersecting_plane(A0, A, B0, N);\n    vec3  At = A0+A*t;\n    intersection = t;\n    vec3 B2B1hat = normalize(B2-B1);\n    vec3 B3B2hat = normalize(B3-B2);\n    vec3 B1B3hat = normalize(B1-B3);\n    return dot(normalize(At-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(At-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(At-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction; \n    vec3 B0 = vec3(0,0,0);\n    vec3 B = vec3(1,0,0);\n    float h = 0.5f;\n    float r = 0.5f;\n    \n    float a_in; bool a_hits = try_distance_along_3d_line_intersecting_triangle(A0,A, vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), a_in);\n    \n    \n    \n    vec3  color = vec3(0);\n    if (a_hits)\n    {\n        color = vec3(a_in/4.f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 274, 274, 314], [315, 315, 464, 689, 1208], [1211, 1211, 1261, 1261, 1889], [1891, 1891, 1948, 1948, 3010]]}
{"id": "WtyGDR", "name": "organic look", "author": "omis", "description": "organic look experiments (pt. I)", "tags": ["2d", "noise", "organic", "smoothmin"], "likes": 1, "viewed": 58, "published": "Public", "date": "1578616498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// power smooth min from iq;\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat circle(in vec2 p) \n{\n\tvec2 q = p;\n    float d = 0.0;\n    \n    p*=1.2;\n    p.y -=0.3;\n    d = length(p);\n    \n    // drop\n    p*=2.5;\n    p.x*=5.0;\n    p.x -= 3.5; p.y -= 10.5;\n    p.y += smoothstep(0.0, 0.99, fract(iTime*0.125)) * 20.0;\n    p.x = (mod(p.x, 3.0) / 1.5) * pow(abs(p.x), 5.0);\n    d = smin(d, length(p), 1.85);\n\t    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res.xy;\n    \n\tvec2 p = 2.0*uv-1.0;\n    \n    p.x *= res.x/res.y;\n    p *= 1.5;\n    \n\t// noise\n    p += noise(p*4.63)*0.075;\n    p += noise(0.2*iTime+p*124.0)*0.015;\n   \t\n    // circle\n    float c1 = step(circle(p), 0.95);\n    vec3 col = vec3(c1*0.675, 0.8, 0.9);\n   \t\n    // organic grain\n    float grain = texture(iChannel0, uv+noise(66.0*uv)*0.15).r; \n    grain += 1.5*step(grain*1.75, 0.575)*c1;\n    col = mix(col, col*grain, 0.25*noise(p*120.5));\n    \n    // bg\n    col = mix(1.25*vec3(0.175, 0.2, 0.2), col, c1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 88], [90, 90, 111, 111, 320], [322, 351, 392, 392, 470], [472, 472, 498, 498, 824], [826, 826, 883, 883, 1517]]}
{"id": "wtyGDy", "name": "pastel color pattern", "author": "anedroid", "description": "test", "tags": ["2d"], "likes": 2, "viewed": 63, "published": "Public", "date": "1579732828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.4)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat check(vec2 _st){\n    float ratio = (sin(iTime * PI * 0.5)+1.0) / 2.0;\n    vec2 v_ratio = vec2(cos(iTime* PI)*0.5+0.5, sin(iTime*PI)*0.5 + 0.5);\n    v_ratio = vec2(fract(iTime));\n    float res = step(v_ratio.x, _st.x);\n    float res2 = step(v_ratio.y, _st.y);\n    float res3 = step(_st.x, v_ratio.x);\n    float res4 = step(_st.y, v_ratio.y);\n    return res * res2 + res3 * res4;\n}\n\nvec2 scale(vec2 _st, vec2 _scale)\n{\n\treturn mat2(_scale.x, 0.0,\n               0.0, _scale.y) * _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n\n    uv = tile(uv,3.0);\n    \n    vec2 uv2 = fragCoord/iResolution.xy;\n    uv2 = tile(uv2,4.0);\n\n\tuv = rotate2D(uv, iTime * PI);\n\n    vec3 pink = vec3(1.000,0.604,0.887);\n    vec3 white = vec3(1.0);\n    vec3 waterblue = vec3(0.545,0.933,1.000);\n    \n    vec3 pattern = vec3(box(uv,vec2(0.5),0.01));\n    vec3 rev_pattern = vec3(1.0) - pattern;\n        \n    color += pattern * pink;\n    color += rev_pattern * waterblue;\n    \n    vec3 checkpattern = vec3(check(uv2));\n    vec3 rev_checkpattern = vec3(1.0) - checkpattern;\n    vec3 color2 = checkpattern * pink + rev_checkpattern;\n    \n    vec3 result = color2 * color;\n\n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 213], [215, 215, 248, 248, 291], [293, 293, 345, 345, 538], [540, 540, 562, 562, 925], [927, 927, 962, 962, 1029], [1031, 1031, 1088, 1138, 1864]]}
{"id": "wtyGRD", "name": "Snake Worship", "author": "dr2", "description": "Ancient ceremony...", "tags": ["fire", "light", "kinematics", "weave"], "likes": 8, "viewed": 274, "published": "Public API", "date": "1578385272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Snake Worship\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Mostly from \"Multisegment Floppy Tube\", \"Parthenon 2\" and \"Woven Basket\")\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noiseff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 hxHit;\nvec3 qHit, fCylPos;\nfloat tCur, dstFar, aMin, dLoop, aLoop, hLen, snbRad, fCylRad, fCylLen, flmFlkr;\nint idObj;\nconst int idBask = 1, idEye = 2, idSnk = 3, idAltr = 4, idLogs = 5, idCoal = 6;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float nSeg = 2.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SnakeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b, c;\n  float d, lb;\n  p.z = 0.6 * (abs (p.z) - 1.5);\n  p.xy = Rot2D (p.xy, 0.5 * pi - 0.5 * aLoop);\n  p.x -= - hLen + (dLoop + snbRad) * sin (0.5 * aLoop);\n  p.xy = Rot2D (p.xy, 0.5 * pi - aLoop);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (-0.5, -0.5, 0.5) * snbRad;\n  d = PrSphDf (q, 0.3 * snbRad);\n  DMIN (idEye);\n  d = dMin;\n  for (float k = 0.; k < nSeg; k ++) {\n    q = p;\n    q.xy = vec2 (- q.y, q.x);\n    q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n    b = vec2 (length (q.xy) - dLoop, q.z);\n    lb = length (b);\n    c = atan (vec2 (q.y, b.x), vec2 (- q.x, b.y)) * vec2 (4. * dLoop / pi, 1.) / pi;\n    d = max (lb - snbRad, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi))));\n    if (k == 0.) d = min (d, PrSphDf (p, snbRad));\n    p.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n    p.x *= -1.;\n    if (k == nSeg - 1.) d = min (d, PrSphDf (p, snbRad));\n    if (d < dMin) hxHit = vec4 (c, lb, k);\n    DMIN (idSnk);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 cs;\n  float dMin, d, szFac, rt, rc, h, s;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.5;\n  d = min (max (max (PrSphDf (q, 0.78), -0.01 + q.y), -0.3 - q.y),\n     PrCylDf ((q - vec3 (0., -0.7, 0.)).xzy, 0.15, 0.42));\n  DMINQ (idAltr);\n  qq = p;\n  qq.y -= fCylPos.y - fCylLen + 0.09;\n  d = PrCylDf (qq.xzy, fCylRad, 0.1);\n  if (d < 0.05) {\n    cs = sin (pi * vec2 (1.3, 0.8));\n    for (int j = 0; j < 5; j ++) {\n      qq.xz = Rot2Cs (qq.xz, cs);\n      q = qq;\n      q.x += 0.21;\n      d = PrRoundCylDf (q, 0.05 - 0.01 * sin (10. * pi * q.z), 0.02, 0.666);\n      DMIN (idLogs);\n    }\n    q = p;\n    q.y -= fCylPos.y - fCylLen - 0.02;\n    d = PrCylDf (q.xzy, fCylRad- 0.03, 0.01);\n    DMIN (idCoal);\n  } else dMin = min (dMin, d);\n  szFac = 0.2;\n  dMin /= szFac;\n  p /= szFac;\n  p.xz = Rot2D (abs (p.xz) - 12., -0.25 * pi);\n  qq = p;\n  rt = 0.1;\n  rc = 16. / pi;\n  h = 2.;\n  p.y -= -2.6 + h + 2. * rt;\n  p.xz *= 1.1 - 0.1 * (p.y + h) / h;\n  q = p;\n  q.xz = vec2 (rc * atan (q.z, - q.x), length (q.xz) - rc);\n  d = length (vec2 (abs (q.y) - h, q.z)) - 2. * rt;\n  q.xy = mod (q.xy + 0.5, 1.) - 0.5;\n  s = rt * cos (2. * pi * q.x);\n  d = min (d, max (min (length (vec2 ((mod ((q.x - q.y) + 0.5, 1.) - 0.5) / sqrt (2.), q.z + s)),\n     length (vec2 ((mod ((q.x + q.y) + 0.5, 1.) - 0.5) / sqrt (2.), q.z - s))) - rt, abs (p.y) - h));\n  q = p;\n  q.y -= - h;\n  d = min (d, PrCylDf (q.xzy, rc, 2. * rt));\n  DMIN (idBask);\n  p = qq;\n  dMin = SnakeDf (p, dMin);\n  dMin *= szFac;\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLight)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.1, h);\n    if (sh < 0.05 || d > dLight) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 CylHit (vec3 ro, vec3 rd, float cylRad, float cylHt)\n{\n  vec3 s;\n  float dCylIn, dCylOut, a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - cylRad * cylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = cylHt;\n    if (abs (s.y) > cylHt) {\n      if (srdy * ro.y < - cylHt) {\n        dCylIn = - (srdy * ro.y + cylHt) / abs (rd.y);\n        if (length (ro.xz + dCylIn * rd.xz) > cylRad) dCylIn = dstFar;\n      } else dCylIn = dstFar;\n    }\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = cylHt;\n      if (abs (s.y) > cylHt && srdy * ro.y < cylHt)\n         dCylOut = (- srdy * ro.y + cylHt) / abs (rd.y);\n    }\n  }\n  return vec2 (dCylIn, dCylOut);\n}\n\nfloat FlmAmp (vec3 ro, vec3 rd, vec2 dst)\n{\n  vec3 p, q;\n  float fh, fr, aSum, a, d;\n  const float ns = 24.;\n  p = ro + dst.x * rd;\n  d = dst.x + fCylRad / ns;\n  aSum = 0.;\n  for (float j = 0.; j < ns; j ++) {\n    p = ro + d * rd;\n    fr = 1. - length (p.xz) / fCylRad;\n    fh = 0.5 * (1. - p.y / fCylLen);\n    q = 2. * p;\n    q.xz = Rot2D (q.xz, 0.3 * q.y);\n    a = 1.1 * Fbm3 (q - vec3 (0., 4. * tCur, 0.));\n    q = 5. * p;\n    q.xz = Rot2D (q.xz, -0.4 * q.y);\n    a += 0.9 * Fbm3 (q - vec3 (0., 5. * tCur, 0.));\n    aSum += max (0.3 * fr * fr * fh * (a * a - 0.6), 0.);\n    q = 73. * p;\n    aSum += step (0.85, Fbm3 (q - vec3 (0., 16. * tCur, 0.))) * smoothstep (0.1, 0.2, fr) *\n       smoothstep (0.3, 0.4, fh);\n    d += fCylRad / ns;\n    if (d > dst.y || aSum > 1.) break;\n  }\n  return clamp (aSum, 0., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec4 SnkCol ()\n{\n  vec4 col4;\n  vec2 p, ip;\n  float c, s, sx;\n  sx = sign (hxHit.x);\n  s = sign (2. * mod (hxHit.w, 2.) - 1.);\n  if (hxHit.z < 0.3 * snbRad && hxHit.x < 0.) {\n    col4 = vec4 (0., 0., 1., -1.);\n  } else if (s * sx < 0. && abs (hxHit.y - 0.5 * sx) < 0.03 ||\n     s * sx > 0. && abs (hxHit.y + 0.5 * sx) < 0.03) {\n    col4 = vec4 (1., 0., 0., 0.2);\n  } else {\n    p = 4. * hxHit.xy * vec2 (3. * sqrt3, 3.);\n    ip = PixToHex (p);\n    c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n    col4 = (c == 0.) ? vec4 (0.7, 0.6, 0., 0.2) : ((c == 1.) ? vec4 (0.8, 0.8, 0.4, 0.2) :\n       vec4 (0.4, 0.2, 0., 0.2));\n    col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.07, HexEdgeDist (p - HexToPix (ip)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, foVec;\n  vec2 dstFlm;\n  float dstObj, dstGrnd, tCyc, sLoop, sh, fIntens, f, lDist, grDep;\n  int idObjF;\n  grDep = 0.48;\n  tCyc = 10.;\n  aMin = 0.5;\n  sLoop = aMin + 5. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (tCur / tCyc, 1.)), 4.);\n  aLoop = 0.25 * pi / sLoop;\n  dLoop = 7. * 0.25 * pi * sLoop;\n  hLen = 2. * nSeg * dLoop * sin (aLoop);\n  snbRad = 0.25;\n  fCylPos = vec3 (0., 2.53, 0.);\n  fCylRad = 0.8;\n  fCylLen = 2.;\n  dstFlm = CylHit (ro - fCylPos, rd, fCylRad, fCylLen);\n  fIntens = (dstFlm.x < dstFar) ? FlmAmp (ro - fCylPos, rd, dstFlm) : 0.;\n  flmFlkr = Noiseff (tCur * 64.);\n  dstObj = ObjRay (ro, rd);\n  idObjF = idObj;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBask) {\n      col4 = vec4 (0.4, 0.2, 0., 0.);\n      vn = VaryNf (16. * ro, vn, 2.);\n    } else if (idObj == idEye) {\n      col4 = vec4 (0., 1., 0., -1.);\n    } else if (idObj == idSnk) {\n      col4 = SnkCol ();\n    } else if (idObj == idAltr) {\n      col4 = vec4 (0.1, 0.4, 0.1, 0.2);\n      if (qHit.y < -0.4) col4 = mix (col4, vec4 (0.5, 0., 0., -1.),\n         SmoothBump (0.3, 0.6, 0.05, 0.5 + 0.5 * sin (2. * pi * (4. * qHit.y + 0.5 * tCur))));\n    } else if (idObj == idLogs || idObj == idCoal) {\n       f = clamp (1.2 * Fbm3 ((idObj == idLogs) ? 32. * vec3 (qHit.z,\n          atan (qHit.y, - qHit.x) / (2. * pi), 2. * length (qHit.xy) - 0.03 * tCur) :\n          vec3 (64. * qHit.xz, qHit.y + 0.5 * tCur).xzy) - 0.2, 0.1, 1.);\n       col4.rgb = (idObj == idLogs) ? vec3 (1., 0.7 * f, 0.3 * f * f) * (0.5 +\n          0.5 * max (- dot (rd, VaryNf (4. * qHit, vn, 1.)), 0.)) *\n          (1. - 0.5 * smoothstep (0.5, 0.666, abs (qHit.z))) :\n          f * vec3 (1., 0.2, 0.1) * (1. - 0.5 * pow (length (qHit.xz) / fCylRad, 4.));\n       col4 = vec4 (min (3. * f * col4.rgb * (1. + 0.1 * flmFlkr), 1.), -1.);\n    }\n    if (col4.a >= 0.) {\n      foVec = fCylPos - ro;\n      lDist = length (foVec);\n      foVec /= lDist;\n      sh = ObjSShadow (ro, foVec, lDist);\n      col = col4.rgb * (0.2 + sh * (0.3 + 0.7 * smoothstep (0., 0.05, - dot (rd, vn))) *\n         max (dot (vn, foVec), 0.) * (0.25 + 5. * (0.6 + 0.4 * flmFlkr) *\n         pow (lDist, -1.5) * vec3 (1., 0.3, 0.2)));\n    } else col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n  } else if (rd.y < 0.) {\n    dstGrnd = - (ro.y + grDep) / rd.y;\n    ro += dstGrnd * rd;\n    foVec = fCylPos - ro;\n    lDist = length (foVec);\n    foVec /= lDist;\n    sh = ObjSShadow (ro, foVec, lDist);\n    col = sh * mix (vec3 (0.3, 0.4, 0.3), vec3 (0.4, 0.3, 0.3),\n       smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz))) * pow (lDist, -1.5);\n  } else {\n    col = vec3 (0.03);\n  }\n  if (! (dstObj < dstFar && idObjF == idAltr || dstObj < dstFlm.x))\n     col = mix (col, mix (vec3 (1., 0.2, 0.2), vec3 (0.8, 0.6, 0.2),\n        smoothstep (0.5, 0.8, fIntens)), fIntens);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.1 * pi;\n  az = 0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n  } else {\n    az += 0.3 * pi * sin (0.02 * 2. * pi * tCur);\n    el -= 0.3 * (az - 0.25 * pi) * (az - 0.25 * pi);\n  }\n  zmFac = 4.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -16.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyGRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 1035, 1071, 1071, 2055], [2057, 2057, 2079, 2079, 3580], [3582, 3582, 3615, 3615, 3813], [3815, 3815, 3836, 3836, 4033], [4035, 4035, 4086, 4086, 4332], [4334, 4334, 4393, 4393, 5300], [5302, 5302, 5345, 5345, 6116], [6118, 6118, 6142, 6142, 6372], [6374, 6374, 6398, 6398, 6458], [6460, 6460, 6488, 6488, 6568], [6570, 6570, 6586, 6586, 7307], [7309, 7309, 7344, 7344, 10234], [10236, 10236, 10289, 10289, 11345], [11347, 11347, 11380, 11380, 11407], [11409, 11409, 11451, 11451, 11502], [11504, 11504, 11561, 11561, 11725], [11727, 11727, 11763, 11763, 11969], [11971, 11971, 12001, 12001, 12114], [12116, 12116, 12147, 12147, 12211], [12213, 12213, 12270, 12270, 12353], [12387, 12387, 12411, 12411, 12464], [12466, 12466, 12490, 12490, 12620], [12622, 12622, 12646, 12646, 12866], [12868, 12868, 12893, 12893, 13039], [13041, 13041, 13066, 13066, 13252], [13254, 13254, 13279, 13279, 13504], [13506, 13506, 13527, 13527, 13682], [13684, 13684, 13705, 13705, 13860], [13862, 13862, 13891, 13891, 14103], [14105, 14105, 14144, 14144, 14329]]}
{"id": "WtyGRz", "name": "Simple Smooth Hash", "author": "creikey", "description": "A simple smooth hash for quick and dirty procedural things.", "tags": ["simple", "hash"], "likes": 2, "viewed": 71, "published": "Public", "date": "1578061571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat smoothhash( float x )\n{\n    //float previous = hash11(float(int(x) - 1));\n    //float current = hash11(float(int(x)));\n    //return mix(previous, current, fract(x));\n    return mix(hash11(floor(x)), hash11(ceil(x)), fract(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = iTime*5.0;\n    uv.x *= 50.0; // to simulate real world 3d units\n    vec3 col = vec3(smoothhash(uv.x + time));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 109], [111, 111, 140, 282, 345], [347, 347, 404, 454, 680]]}
{"id": "WtyGz3", "name": "Sound Tribe Sector9", "author": "yasuo", "description": "https://sts9.com/", "tags": ["sts9"], "likes": 5, "viewed": 226, "published": "Public API", "date": "1579434818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat typoS(vec2 p) {\n    vec2 pref = p;\n\tp*= Rot(radians(90.0));\n    float c0 = sdUnevenCapsule(p,0.15,0.15,0.22);\n    float c1 = sdUnevenCapsule(p,0.07,0.07,0.22);\n    p = pref;\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(p.x-0.12,max(-c1,c0)),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    p = pref;\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    float btmC = min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2);\n    \n    return min(topC,btmC);\n}\n\nfloat typoT(vec2 p) {\n    vec2 pref = p;\n\tfloat b0 = dBox2d(p+vec2(-0.33,-0.11),vec2(0.18,0.04));\n    float b1 = dBox2d(p+vec2(-0.405,0.11),vec2(0.105,0.15));\n    float b2 = dBox2d(p+vec2(-0.485,0.19),vec2(0.105,0.15));\n    float b3 = dBox2d(p+vec2(-0.338,0.00),vec2(0.045,0.045));\n    float c0 = length(p+vec2(-0.379,0.04))-0.08;\n    float b = min(min(b0,max(-b3,max(-b2,b1))),max(-b2,c0));\n    return b;\n}\n\nfloat typoNine(vec2 p) {\n    float c0 = sdUnevenCapsule(p*Rot(radians(90.0)),0.15,0.15,0.14);\n    float c1 = sdUnevenCapsule(p*Rot(radians(90.0)),0.07,0.07,0.14);\n    float cut0 = dBox2d((p+vec2(-0.26,-0.04))*Rot(radians(20.0)),vec2(0.08,0.08));\n    float cut1 = dBox2d(p+vec2(-0.32,0.1),vec2(0.2,0.1));\n    float c2 = length(p+vec2(-0.12,0.11))-0.04;\n    float topC = min(max(-cut1,max(-cut0,max(-c1,c0))),c2);\n    \n    vec2 btmP = vec2(0.1,0.11);\n    c0 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.15,0.15,0.22);\n    c1 = sdUnevenCapsule((p+btmP)*Rot(radians(90.0)),0.07,0.07,0.22);\n    c2 = length(p+btmP+vec2(-0.1,-0.11))-0.04;\n    cut0 = dBox2d((p+vec2(-0.05,0.2)),vec2(0.08,0.08));\n    float btmC = max(-cut0,min(max(-p.x-btmP.x+0.1,max(-c1,c0)),c2));\n    \n    return min(topC,btmC);\n}\n\nvec3 animateBg(vec2 p, vec3 col, float s, float t) {\n    p*=Rot(radians(t*20.0));\n    p.x = abs(p.x);\n    p.x -= 0.34;\n    p.y = abs(p.y);\n    p.y -= 0.2;\n    \n    p*= s;\n    float thickness = 0.03;\n    float t0 = sdTriangle(vec2(0.0,0.1), vec2(-0.1,-0.05),vec2(0.1,-0.05),(p+vec2(0.0,0.0))*Rot(radians(t*50.0)));\n    float t0m = sdTriangle(vec2(0.0,0.1-thickness), vec2(-0.1+thickness,-0.05+thickness*0.5),vec2(0.1-thickness,-0.05+thickness*0.5),(p+vec2(0.0,0.0))*Rot(radians(t*50.0)));\n    float t1 = sdTriangle(vec2(0.0,-0.05), vec2(-0.1,0.1),vec2(0.1,0.1),(p+vec2(0.2,0.0))*Rot(radians(t*40.0)));\n    float t1m = sdTriangle(vec2(0.0,-0.05+thickness), vec2(-0.1+thickness,0.1-thickness*0.5),vec2(0.1-thickness,0.1-thickness*0.5),(p+vec2(0.2,0.0))*Rot(radians(t*40.0)));\n    float t2 = sdTriangle(vec2(0.0,-0.1), vec2(-0.1,0.1),vec2(0.1,0.1),(p+vec2(-0.2,0.0))*Rot(radians(t*35.0)));\n    float t2m = sdTriangle(vec2(0.0,-0.1+thickness), vec2(-0.1+thickness,0.1-thickness*0.5),vec2(0.1-thickness,0.1-thickness*0.5),(p+vec2(-0.2,0.0))*Rot(radians(t*35.0)));\n    float res = min(max(-t0m,t0),min(max(-t1m,t1),max(-t2m,t2)));\n\n    float blur = -0.02;\n    col = mix( col,  0.5 + 0.5*sin(t+p.xyx+vec3(1,2,4)), S(res,blur) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p =  (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    p +=(mod(iTime,3.0)<0.3)?sin(floor(p*30.0)*iTime*15.)*0.03:vec2(0.0);\n    vec2 pref = p;\n    \n    // bg color\n    vec3 col = vec3(0.0);\n    \n\tfloat logoY = -0.03;\n    float s0 = typoS(p+vec2(0.62,logoY));\n    float t = typoT(p+vec2(0.62,logoY));\n    float s1 = typoS(p+vec2(-0.07,logoY));\n    float nine = typoNine(p+vec2(-0.49,logoY));\n\n    col = animateBg(p,col,0.7,iTime*1.2);\n    col = animateBg(p,col,0.65,-iTime*1.7);\n    col = animateBg(p,col,0.4,iTime*2.2);\n    col = animateBg(p,col,0.5,-iTime*2.0);\n    vec3 bgCol = col;\n    \n    float blur = 0.0;\n    \n\tcol = mix( col, vec3(1.0)-bgCol, S(s0,blur) );\n    col = mix( col, vec3(1.0), S(t,blur) );\n    col = mix( col, vec3(1.0)-bgCol, S(s1,blur) );\n    \n    col = mix( col, (0.5 + 0.5*sin(iTime+p.xyx+vec3(1,2,3)))-bgCol, S(nine,blur) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 193, 193, 243], [245, 245, 312, 312, 951], [953, 953, 1015, 1015, 1254], [1256, 1256, 1277, 1277, 1866], [1868, 1868, 1889, 1889, 2275], [2277, 2277, 2301, 2301, 3072], [3074, 3074, 3126, 3126, 4312], [4314, 4314, 4371, 4371, 5292]]}
{"id": "XsXcRf", "name": "the third pattern", "author": "jes5199", "description": ":D", "tags": ["2d", "aliasing"], "likes": 3, "viewed": 60, "published": "Public", "date": "1580324212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord.xy - (iResolution.xy / 2.0));\n\n    float x = uv.x;\n    float y = uv.y;\n    float value = (x*x-y*y);\n    \n    float t = iTime / 1000.;\n    float color = sin(value * t) * 6.0;\n        \n\n    float low = abs(color) - 3.0;\n    float med = abs(color) - 4.0;\n    float high = max(0.,abs(color) - 5.0);\n    if(color < 0.0) {\n      fragColor = vec4(low, high, high, 1.);\n    } else {\n\t  fragColor = vec4(high, high, low, 1.);\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXcRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 510]]}
{"id": "XtsyRs", "name": "The Death of Phantom Wood", "author": "TheGrego", "description": "A phantom tree glows and screams when sliced open.", "tags": ["2d", "wood"], "likes": 2, "viewed": 244, "published": "Public API", "date": "1580248168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BANDING 10.0\n#define rot(a)  mat2( cos(a), sin(a),  -sin(a), cos(a) )\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tc = uv;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv *= rot(iTime * 0.1 + length(uv * ( (uv.x - 1.0) * 2.0)));\n    \n    \n    float n = texture(iChannel0, vec2( 0.01, uv.y * 0.4)).r;\n    float b = BANDING;// * length(uv * 100.0);\n    float val = round(fract(n) * b) / b;\n    vec3 col = vec3(val);\n    col.r *= 2.0 - uv.y;\n    col.g *= 0.8 - uv.y;\n    col.b *= 1.2 + uv.x;\n    \n    //vec2 pos = vec2( smoothstep( 0.0, 1.0, fract(iTime * 0.5) ), 0.5);\n    \n    // with noise\n    //float p = texture(iChannel0, (tc * uv) * 0.05).r;\n    //vec2 pos = vec2( sin(iTime * 0.5 + p) * 2.0, cos(iTime - p) * 10.0);\n    \n    float p = texture(iChannel0, (tc * uv) * 0.01).r;\n    vec2 pos = vec2( sin(iTime * 0.5) * 2.0 + cos(iTime*0.5 + length(uv)) * 2.0, \n                    cos(iTime*0.4) * 2.0 + p);\n    //vec3 circ = vec3(length((uv - pos) * 2.0));\n    vec3 circ = vec3(max(-0.75, 1.0 - min (length(uv - pos), 2.5)));\n    circ *= dot(uv, vec2(0.0, 1.0));\n    col += circ;\n   \t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 137, 1180]]}
