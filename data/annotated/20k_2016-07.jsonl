{"id": "4dVSW3", "name": "Oldschool plasma thing", "author": "bwestlin", "description": "Reimplementation of a plasma thing I did previously elsewhere.", "tags": ["2d", "plasma"], "likes": 2, "viewed": 187, "date": "1467393697", "time_retrieved": "2024-06-20T18:38:11.973894", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0, 1)) * vec2(480., -320.);\n    \n    float fx = uv.x;\n    float fy = uv.y;\n    float time = iTime;\n    \n    float c_mul = 16.5 + sin(time / 2.0) * 15.5;\n    \n    float v =\n        sin(distance(vec2(fx + time, fy), vec2(128.0 * sin(time), 128.0 * sin(time))) / 8.0) +\n        sin(distance(vec2(fx, fy), vec2(64.0 * cos(time), 64.0 * cos(time))) / 16.0) +\n        sin(distance(vec2(fx, fy + time / 7.0), vec2(192.0, 64.0)) / 17.0) +\n        sin(distance(vec2(fx, fy), vec2(192.0 + 200.0 + sin(time) * 200.0, 100.0 + 200.0 + sin(time / 2.0) * 200.0)) / 8.0);\n\n    float c = (floor((4.0 + v) * (32.0 / c_mul)) * c_mul);\n    \n\tfragColor = vec4(\n        c / 128.,\n        c / 256.,\n        (255. - c) / 256.,\n    \t1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 824]]}
{"id": "4dVXDt", "name": "smoke rings", "author": "mahalis", "description": "something a little calmer, heavily inspired by the beautiful work Anders Hoff (@inconvergent on Twitter) has been doing lately. happy Friday!", "tags": ["procedural", "2d", "ring", "smoke", "wisp"], "likes": 97, "viewed": 3064, "date": "1467421743", "time_retrieved": "2024-06-20T18:38:11.974891", "image_code": "const float falloffPower = 0.3;\nfloat halfWidth = pow(0.03, falloffPower);\nconst float radius = 0.38;\nconst vec2 noiseSampleDirection = vec2(1.0, 0.319);\n\nfloat waves(vec2 coord, vec2 coordMul1, vec2 coordMul2, vec2 phases, vec2 timeMuls) {\n    return 0.5 * (sin(dot(coord, coordMul1) + timeMuls.x * iTime + phases.x) + cos(dot(coord, coordMul2) + timeMuls.y * iTime + phases.y));\n}\n\nfloat ringMultiplier(vec2 coord, float distortAmount, float phase, float baseXOffset) {\n    vec2 sampleLocation1 = noiseSampleDirection * phase;\n    vec2 sampleLocation2 = vec2(1.0, 0.8) - noiseSampleDirection * phase;\n    vec3 noise1 = texture(iChannel0, sampleLocation1).rgb;\n    vec3 noise2 = texture(iChannel0, sampleLocation2).rgb;\n    \n    float distortX = baseXOffset + 0.6 * waves(coord, vec2(1.9 + 0.4 * noise1.r, 1.9 + 0.4 * noise1.g) * 3.3, vec2(5.7 + 1.4 * noise1.b, 5.7 + 1.4 * noise2.r) * 2.8, vec2(noise1.r - noise2.r, noise1.g + noise2.b) * 5.0, vec2(1.1));\n    float distortY = 0.5 + 0.7 * waves(coord, vec2(-1.7 - 0.9 * noise2.g, 1.7 + 0.9 * noise2.b) * 3.1, vec2(5.9 + 0.8 * noise1.g, -5.9 - 0.8 * noise1.b) * 3.7, vec2(noise1.g + noise2.g, noise1.b - noise2.r) * 5.0, vec2(-0.9));\n    float amount = 0.2 + 0.3 * (abs(distortX) + abs(distortY));\n    vec2 distortedCoord = coord + normalize(vec2(distortX, distortY)) * amount * distortAmount * 0.2;\n    return smoothstep(-halfWidth,halfWidth, pow(abs(length(distortedCoord) - radius), falloffPower));\n}\n\n#define RING_COUNT 30\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(0.5) - fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 accumulatedColor = vec3(1.0);\n    const vec3 tint1 = vec3(0.1, 0.5, 0.4);\n    const vec3 tint2 = vec3(0.4, 0.7, 0.2);\n    \n    float baseXOffset = 0.5 * (0.6 * cos(iTime * 0.3 + 1.1) + 0.4 * cos(iTime * 1.2));\n    for (int i = 0; i < RING_COUNT; i++) {\n        float ringsFraction = float(i) / float(RING_COUNT);\n        float amount = ringMultiplier(uv, 0.1 + pow(ringsFraction, 3.0) * 0.7, pow(1.0 - ringsFraction,0.3) * 0.09 + iTime * 0.0001, baseXOffset);\n        accumulatedColor *= mix(mix(tint1, tint2, pow(ringsFraction, 3.0)), vec3(1.0), pow(amount, 2.0));\n    }\n\tfragColor = vec4(accumulatedColor, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVXDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[155, 155, 240, 240, 382], [384, 384, 471, 471, 1454], [1479, 1479, 1536, 1536, 2258]]}
{"id": "4l33D4", "name": "Spiral Quantization", "author": "AmazingThew", "description": "Draws a spiral for each color channel, with the thickness of the spiral line corresponding to the brightness of the input channel\n\nClick around the image to change parameters:\nX axis: input brightness\nY axis: spiral size\n\nWebcam input looks rad!", "tags": ["2d", "postprocessing", "spiral"], "likes": 7, "viewed": 354, "date": "1469167350", "time_retrieved": "2024-06-20T18:38:12.323141", "image_code": "//Spiral math adapted from https://www.shadertoy.com/view/XsfXR2\n\n#define PI 3.14159265359\n\nconst int samples = 4;\n\nfloat aux;\nfloat aux2;\nfloat tightness;\nvec2 aspect;\nvec2 texAspect;\n\nmat2 spin(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec4 samplePixel(vec2 uv) {\n    float separation = 0.1;\n    vec2 rCenter = (vec2(separation, 0.0)                    * spin(-iTime*0.1)) / aspect + vec2(0.5);\n    vec2 gCenter = (vec2(separation, 0.0) * spin(2.0*PI/3.0) * spin(-iTime*0.1)) / aspect + vec2(0.5);\n    vec2 bCenter = (vec2(separation, 0.0) * spin(4.0*PI/3.0) * spin(-iTime*0.1)) / aspect + vec2(0.5);\n    \n    vec2 rPoint = (uv-rCenter) * aspect;\n    vec2 gPoint = (uv-gCenter) * aspect;\n    vec2 bPoint = (uv-bCenter) * aspect;\n    \n    rPoint = rPoint * spin(-iTime*10.0) * spin(length(rPoint) * tightness);\n    gPoint = gPoint * spin(-iTime*10.0) * spin(length(gPoint) * tightness);\n    bPoint = bPoint * spin(-iTime*10.0) * spin(length(bPoint) * tightness);\n    \n    vec3 image = texture(iChannel0, uv*aspect*texAspect).ggg; //Grayscale input looks cooler. Change to .rgb for color\n    image = pow(image, vec3(mix(0.5, 4.0, aux)));\n    \n    vec3 imageThreshold = mix(vec3(1.0), vec3(-1.0), image) * vec3(length(rPoint), length(gPoint), length(bPoint));\n    imageThreshold = step(imageThreshold, vec3(rPoint.x, gPoint.x, bPoint.x));\n    \n    return vec4(imageThreshold, 1.0);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    vec2 off = 1.0 / float(samples) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    for (int x=0; x<samples; x++) {\n        for (int y=0; y<samples; y++) {\n            sum += samplePixel(pos + vec2(off.x*float(x), off.y*float(y)));\n        }\n    }\n    return sum / float(samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aux  = max(0.1, iMouse.x/iResolution.x);\n    aux2 = max(0.2, iMouse.y/iResolution.y);\n    tightness = aux2 * 3000.0;\n    aspect = vec2(1.0, iResolution.y/iResolution.x);\n    texAspect = vec2(1.0, iChannelResolution[0].x/iChannelResolution[0].y);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = superSamplePixel(uv);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l33D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 186, 210, 210, 278], [280, 280, 307, 307, 1424], [1426, 1426, 1459, 1459, 1752], [1754, 1754, 1811, 1811, 2151]]}
{"id": "4l3GDN", "name": "your brain on drugs", "author": "stduhpf", "description": ".", "tags": ["2d", "rotation"], "likes": 9, "viewed": 304, "date": "1469196220", "time_retrieved": "2024-06-20T18:38:12.323141", "image_code": "const float speed = .05;\nconst float icount = 300.;\nconst float size = .2;\n\nfloat length1(vec2 uv)//manatthan geometry\n{\n    return abs(uv.x)+abs(uv.y);\n}\n\nfloat length2(vec2 uv)//chessboard geometry\n{\n    return max(abs(uv.x),abs(uv.y));\n}\n\nfloat length3(vec2 uv)//not a length function but looks good\n{\n    return min(abs(uv.x),abs(uv.y));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(min(iResolution.x,iResolution.y),max(iResolution.x,iResolution.y));\n\n\tvec2 uv = fragCoord.xy /res.x;\n    uv-=.5;\n    if(res.x==iResolution.x)\n        uv.y-=.5*res.y/res.x-.5;\n    else\n        uv.x-=.5*res.y/res.x-.5;\n    float t = iTime*speed;\n    for( float i =0.;i<2.*icount;i++)\n    {\n        if (i>= floor(icount*length(mod(uv,size)-size/2.)))break;//you can replace length by one of the other length function \n        uv*=mat2(cos(t),sin(t),-sin(t),cos(t));//rotation\n         //uv*=mat2(cos(t),sin(t),sin(t),-cos(t));//rotation+symetry(you should increase the value of speed)\n  }\n\n     float c=0.;\n    if(uv.x*uv.y>0.)\n        c=1.0;\n\tfragColor = vec4(mod(iDate.w+1.-(2.*abs(uv)),1.5),c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3GDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[76, 76, 120, 120, 154], [156, 156, 201, 201, 240], [242, 242, 304, 304, 343], [347, 347, 404, 404, 1124]]}
{"id": "4lc3Wn", "name": "B/W Sunflower Zoom", "author": "roywig", "description": "Found this effect almost by accident!", "tags": ["tunnel", "droste", "sunflower"], "likes": 11, "viewed": 208, "date": "1468549945", "time_retrieved": "2024-06-20T18:38:12.323141", "image_code": "void mainImage( out vec4 fragColor, in vec2 z )\n{\n    z = z/iResolution.xy-.5;\n    z.x *= iResolution.x/iResolution.y;\n    z = vec2(log(length(z)),atan(z.y,z.x)); //complex logarithm  \n    z.x -= fract(iTime)*1.27;\n    z *= mat2(5,-5,5,5); //mat2(0.707,-0.707,0.707,0.707)*2./0.283;\n    fragColor = vec4(9.*sin(z.x)*sin(z.y));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lc3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 49, 49, 329]]}
{"id": "4lc3Wr", "name": "Sand Tubes", "author": "jameswilddev", "description": "This was me debugging a raymarcher, but it came out so colourful I decided to make that the shader instead.", "tags": ["sand"], "likes": 4, "viewed": 593, "date": "1468612701", "time_retrieved": "2024-06-20T18:38:12.323141", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 lens = normalize(vec3((fragCoord.xy - iResolution.xy / 2.0) / iResolution.xy, 0.2));\n    vec3 location = vec3(iTime, 0.0, iTime);\n    float d;\n    for (int i = 0; i  < 16; i++) {\n        \n        vec3 origin1 = vec3(0.5, sin((floor(location.x) + floor(location.z)) * 0.1) - 1.0, 0.5);\n        vec3 origin2 = vec3(0.5, sin((floor(location.z - 0.5) + floor(location.x - 0.5)) * 0.1) - 1.0, 0.5);\n        vec2 local1 = fract(location.xz) - 0.5;\n        vec2 local2 = fract(location.xz - 0.5) - 0.5;\n        \n        float d1 = distance(vec3(local1.x, location.y, local1.y), vec3(0.0, max(location.y, origin1.y), 0.0)) - 0.6;\n        float d2 = distance(vec3(local2.x, location.y, local2.y), vec3(0.0, max(location.y, origin2.y), 0.0)) - 0.6;\n        d = min(d1, d2);\n        location -= lens * d;\n    }\n\tfragColor = vec4(sin(location + location.y), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lc3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 917]]}
{"id": "4lcGW4", "name": "Spheres and Tori", "author": "geoff", "description": "A field of spheres and tori. Experimenting with a more complex map than I've used previously. Rotate the camera with the mouse.", "tags": ["3d"], "likes": 3, "viewed": 508, "date": "1469147533", "time_retrieved": "2024-06-20T18:38:12.329216", "image_code": "mat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    vec3 r = p;\n    if(mod(floor(p / 3.0), 2.0) == vec3(0.0, 0.0, 0.0)){\n        q += vec3(0.5 * sin(iTime), 0.5, 0.5 * cos(iTime));\n    \tr += vec3(-0.5 * sin(iTime), -0.5, -0.5 * cos(iTime));\n    }else{\n        q += vec3(-0.5 * sin(iTime), -0.5, -0.5 * cos(iTime));\n    \tr += vec3(0.5 * sin(iTime), 0.5, 0.5 * cos(iTime));\n    }\n    q = vec3(mod(q.x, 3.0) - 1.5, mod(q.y, 3.0) - 1.5, mod(q.z, 3.0) - 1.5);\n    r = vec3(mod(r.x, 3.0) - 1.5, mod(r.y, 3.0) - 1.5, mod(r.z, 3.0) - 1.5);\n    r *= rotY(iTime / 2.0) * rotX(iTime);\n\t\n    vec2 sph = vec2(length(q) - 0.5, 1.0);\n    vec2 cube = vec2(length(vec2(length(r.xz) - 0.5, r.y)) - 0.25, 2.0);\n    \n    return vecMin(sph, cube);\n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 1000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        t += d;\n        if(t > 30.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 amb(vec3 c, float k){\n    return c * k;\n}\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nvec3 spec(vec3 c, float k, vec3 p, float a){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - camPos);\n    float facing = dot(l, n) > 0.0 ? 1.0 : 0.0;\n    vec3 r = reflect(l, n);\n    return c * k * facing * pow(max(0.0, dot(r, v)), a);\n}\n\nvec3 colour(vec3 p, float id){\n    if(id == 1.0){\n        vec3 col = vec3(0.0, 0.0, 1.0);\n        return amb(col, 0.5) + diff(col, 0.9, p) + spec(vec3(1.0), 0.2, p, 8.0);\n    }\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    return amb(col, 0.5) + diff(col, 0.8, p) + spec(vec3(1.0), 0.9, p, 8.0);\n} \n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.5;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, 0.0);\n    lightPos = vec3(0.0, 0.0, 0.0);\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n    \tcol = colour(c, closeObj);\n        float s = shadow(c, normalize(lightPos - c));\n        col -= vec3(0.5 - 0.5 * s);\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lcGW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 19, 19, 160], [162, 162, 181, 181, 322], [347, 347, 375, 375, 435], [437, 437, 457, 457, 1154], [1156, 1156, 1174, 1174, 1200], [1202, 1202, 1232, 1232, 1615], [1617, 1617, 1637, 1637, 1913], [1989, 1989, 2015, 2015, 2035], [2037, 2037, 2072, 2072, 2176], [2178, 2178, 2222, 2222, 2455], [2457, 2457, 2487, 2487, 2748], [2751, 2751, 2782, 2782, 3138], [3179, 3179, 3235, 3235, 3927]]}
{"id": "4ld3DH", "name": "001 sin", "author": "kakaxizhhgjh", "description": "smoothstep draw sin", "tags": ["sin", "smoothsetp"], "likes": 6, "viewed": 182, "date": "1469106488", "time_retrieved": "2024-06-20T18:38:12.329216", "image_code": "float plot(float a, float b) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, abs(a - b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 bg = vec3(1.0);\n    bg = mix(bg, vec3(1.0, 0.0, 0.0), plot(uv.y, 0.5 * sin(uv.x * 2.0 + iTime)));\n    bg = mix(bg, vec3(0.0, 1.0, 0.0), plot(uv.y, 0.5 * sin(uv.x * 2.0 + iTime + 3.14159 * 0.33)));\n    bg = mix(bg, vec3(0.0, 0.0, 1.0), plot(uv.y, 0.5 * sin(uv.x * 2.0 + iTime + 3.14159 * 0.66)));\n\tfragColor = vec4(bg, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ld3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 30, 30, 90], [92, 92, 149, 149, 550]]}
{"id": "4ld3z7", "name": "OneTorus", "author": "wjbgrafx", "description": "An experiment in creating interesting shapes and textures from a single torus.", "tags": ["3d", "raymarch", "domainrepetition"], "likes": 8, "viewed": 592, "date": "1468459785", "time_retrieved": "2024-06-20T18:38:14.590115", "image_code": "/*\n\tOneTorus by wjbgrafx\n\t\n\tBased on \"Raymarched Reflections\"   Uploaded by Shane in 2015-Nov-17\n\n\thttps://www.shadertoy.com/view/4dt3zn\n\n\t\n\tInspired by \"Playing with symmetries - Torus\" by  PauloFalcao\n\n\thttp://glslsandbox.com/e#29755.0\n\t\n*/\n//==============================================================================\n\n#define PI                      3.1415926535897932384626433832795\n#define PI_16\t\t\t\t\t0.19634954084936207740391521145497\n\n#define FAR                     500.0\n#define MAX_RAY_STEPS           90\n#define MAX_REF_STEPS           50\n#define MAX_SHADOW_STEPS        20\n\n#define CAM_DIST\t\t\t\t100.0\n#define CAM_POS                 vec3( 0.0, 55.0, -CAM_DIST )\n#define CAM_FOV_FACTOR          4.0\n#define LOOK_AT                 vec3( 0.0, 10.0, 0.0 )\n#define LIGHT_POS               vec3( 10.0, 50.0, -30.0 )\n#define LIGHT_ATTEN\t\t\t\t0.0005\n\n// Function declarations\n//----------------------\nmat4 createCamRotMatrix();\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) ;\nvec2 trace( vec3 rayOrig, vec3 rayDir );\nfloat traceRef( vec3 rayOrig, vec3 rayDir );\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k );\nvec3 getNormal( in vec3 p );\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID );\n\n//------------------------------------------------------------------------------\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\n// Horizontal torus lying in xz plane at y = 0; t = vec2( lg. diam, sm. diam )\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//------------------------------------------------------------------------------\n// From http://glslsandbox.com/e#29755.0\n// Playing with symmetries - Torus\n// by @paulofalcao\n\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r){\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s){\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//------------------------------------------------------------------------------\n\n// MAP\n// ---\n\nvec2 map(vec3 p)\n{    \t\n\tfloat objID = 1.0;\n\tvec2 ground = vec2( p.y, objID );\n\t\n\t//------------------------------\n\n\tp.y -= 15.0;\t\n\tp.yz = rot( p.yz, iTime * 0.2 );\n\t\n\t// 1\n\tp.yz = rotsim( p.yz, 3.0 );\n\tp.z -= 2.0;\n\t\n\t// 2\n\tp.xy = rotsim( p.xy, 4.0 ); \n\tp.yz -= 3.5;\n\t\n\t// 3\n\tp.xy = rot( p.xy, PI * 0.5 ); \n\tp.x -= 2.65;\n\t\n\t// 2\n\tp.xy = rotsim( p.xy, 3.0 ); \n\tp.yz -= 3.5;\n\t\n\t// 3\n\tp.xy = rot( p.xy, PI * 0.5 ); \n\tp.x -= 2.65;\n\t\n\t// 1\n\tp.yz = rotsim( p.yz, 3.0 );\n\tp.z -= 2.5;\n\n\t//------------------------------\n\t\n\tp = sim( p, 14.5 + 12.0 * sin( iTime * 0.04 ) );\n\t\n\t// Thinner tori as num copies increases.\n\tfloat dist = sdTorus( p, vec2( 2.0, 0.2 + 0.175 * sin( iTime * 0.04 ) ) );\n\t\n\tobjID = 2.0;\n\tvec2 torFig = vec2( dist, objID );\n\t\n\t//---------------------------------------------------\n\n\tvec2 closest = ground.s < torFig.s ? ground : torFig;\n\treturn closest;\n}\n\n// end map()\n\n//------------------------------------------------------------------------------\n\n// GET OBJECT COLOR\n// ----------------\n\nvec3 getObjectColor( vec3 p, vec2 distID )\n{    \n    vec3 col = vec3( 1.0 );\n\tfloat objNum = distID.t;\n\t\n\tif( objNum == 1.0 )\n    {\n\t\tcol = vec3( abs( sin( iTime * 0.03 ) ), \n\t\t\t\t\tabs( sin( iTime * 0.05 ) ),\n\t\t\t\t\tabs( sin( iTime * 0.07 ) ) );\n\t}\n\telse if ( objNum == 2.0 )\n\t{\n\t\tcol = vec3( 0.7, 0.8, 0.9 );\n\t}\n\t    \n    return col;\n}\n\n// end getObjectColor()\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Adjust aspect ratio, normalize coords, center origin in x-axis.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n \tmat4 cam_mat = createCamRotMatrix();\n\tvec3 camPos = vec3( cam_mat * vec4( 0.0, 0.0, -CAM_DIST, 1.0 ) );\t    \n    vec3 rayDir = getRayDir( camPos, normalize( LOOK_AT - camPos ), uv );   \n    vec3 rayOrig = camPos;   \n    vec3 lightPos = LIGHT_POS;\n\tvec3 sceneColor = vec3( 0.0 );\n\tvec3 skyClr = vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t\t\t    abs( sin( iTime * 0.03 ) ),\n\t\t\t\t\t    abs( sin( iTime * 0.05 ) ) );\t   \n    // FIRST PASS.\n    //------------\n    vec2 distID = trace( rayOrig, rayDir );\n    float totalDist = distID.s;\n    \n\tif ( totalDist >= FAR )\n\t{\n\t\tsceneColor = skyClr;\n\t}\n\telse\n\t{\n\t    // Fog based off of distance from the camera. \n\t    float fog = smoothstep( FAR, 0.0, totalDist ); \n\t    \n\t    // Advancing the ray origin to the new hit point.\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the hit point.\n\t    vec3 surfNorm = getNormal( rayOrig );\n\t    \n\t    // Retrieving the color at the hit point.\n\t    sceneColor = doColor( rayOrig, rayDir, surfNorm, distID );\n\t    \n\t    float k = 24.0;\n\t    float shadow = softShadow( rayOrig, lightPos, k );\n\t   \n\t    // SECOND PASS - REFLECTED RAY\n\t    //----------------------------\n\t    rayDir = reflect( rayDir, surfNorm );\n\t    totalDist = traceRef( rayOrig +  rayDir * 0.01, rayDir );\n\t    rayOrig += rayDir * totalDist;\n\t    \n\t    // Retrieving the normal at the reflected hit point.\n\t    surfNorm = getNormal( rayOrig );\n\t    \n\t    // Coloring the reflected hit point, then adding a portion of it to the \n\t    // final scene color. Factor is percent of reflected color to add.\n\t    sceneColor += doColor( rayOrig, rayDir, surfNorm, distID ) * 0.95;\n\t    \n\t    // APPLYING SHADOWS\n\t    //-----------------\n\t    sceneColor *= shadow;\n\t    //sceneColor *= fog;\n\t    sceneColor = mix( sceneColor, skyClr, 1.0 - fog );\n\t    \n\t} // end else totalDist < FAR\n\t\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n    \n}\n\n//------------------------------------------------------------------------------\n// From\t\"Simple test/port of Mercury's SDF library to WebGL\"\n// https://www.shadertoy.com/view/Xs3GRB    Uploaded by tomkh in 2015-Dec-16\n\n// CREATE CAMERA ROTATION MATRIX\n// -----------------------------\n\nmat4 createCamRotMatrix()\n{\n\tfloat ang = 0.0, \n\t      sinAng = 0.0, \n\t      cosAng = 0.0,\n\t      rotRange = -0.0029;\n\n\tang = iTime * 0.079; // auto rotate\n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 y_Rot_Cam_Mat = mat4( cosAng, 0.0, sinAng, 0.0,\t  \n\t                              0.0, 1.0,    0.0, 0.0,\n\t                          -sinAng, 0.0, cosAng, 0.0,\n\t                              0.0, 0.0,    0.0, 1.0 );\n\t\n\tang = 0.25 * ( sin( iTime * 0.057 ) + 1.0 ) + PI_16; \n\tsinAng = sin(ang); \n\tcosAng = cos(ang);\n\t\n\tmat4 x_Rot_Cam_Mat = mat4( 1.0,     0.0,    0.0, 0.0,\t  \n\t                           0.0,  cosAng, sinAng, 0.0,\n\t                           0.0, -sinAng, cosAng, 0.0,\n\t                           0.0,     0.0,    0.0, 1.0 );\n\t\n\treturn y_Rot_Cam_Mat * x_Rot_Cam_Mat;\n\t\n}\n\n// end createCamRotMatrix()\n\n//------------------------------------------------------------------------------\n\n// TRACE\n// -----\n\n// Standard raymarching routine.\nvec2 trace( vec3 rayOrig, vec3 rayDir )\n{   \n    float totalDist = 0.0;\n    vec2 distID = vec2( 0.0 );\n    \n    for ( int i = 0; i < MAX_RAY_STEPS; i++ )\n    {\n        distID = map( rayOrig + rayDir * totalDist );\n        float dist = distID.s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist * 0.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return vec2( totalDist, distID.t );\n}\n\n// end trace()\n\n//------------------------------------------------------------------------------\n\n// TRACE REFLECTIONS\n// -----------------\n\n// Second pass, which is the first, and only, reflected bounce. Virtually the \n// same as above, but with fewer iterations and less accuracy.\n\n// The reason for a second, virtually identical equation is that raymarching is \n// usually a pretty expensive exercise, so since the reflected ray doesn't \n// require as much detail, you can relax things a bit - in the hope of speeding \n// things up a little.\n\nfloat traceRef( vec3 rayOrig, vec3 rayDir )\n{    \n    float totalDist = 0.0;\n    \n    for ( int i = 0; i < MAX_REF_STEPS; i++ )\n    {\n        float dist = map( rayOrig + rayDir * totalDist ).s;\n        \n        if( abs( dist ) < 0.0025 || totalDist > FAR ) \n        {\n        \tbreak;\n        }\n        \n        totalDist += dist;\n    }\n    \n    return totalDist;\n}\n\n// end traceRef()\n\n//------------------------------------------------------------------------------\n\n// SOFT SHADOW\n// -----------\n\n// The value \"k\" is just a fade-off factor that enables you to control how soft  \n// you want the shadows to be. Smaller values give a softer penumbra, and larger\n// values give a more hard edged shadow.\n\nfloat softShadow( vec3 rayOrig, vec3 lightPos, float k )\n{\n    vec3 rayDir = ( lightPos - rayOrig ); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max( length( rayDir ), 0.001 );\n    float stepDist = end / float( MAX_SHADOW_STEPS );\n    \n    rayDir /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow \n    // things down. Obviously, the lowest number to give a decent shadow is the \n    // best one to choose. \n    for ( int i = 0; i < MAX_SHADOW_STEPS; i++ )\n    {\n        float h = map( rayOrig + rayDir * dist ).s;\n\n        //shade = min( shade, k * h / dist );\n        // Subtle difference. Thanks to IQ for this tidbit.\n        shade = min( shade, smoothstep( 0.0, 1.0, k * h / dist)); \n\n        // So many options here, and none are perfect: dist += min( h, 0.2 ),etc\n        dist += min( h, stepDist * 2.0 ); \n        \n        // Early exits from accumulative distance function calls tend to be a \n        // good thing.\n        if ( h < 0.001 || dist > end ) \n        {\n        \tbreak; \n        }\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. \n    // It's a preference thing. Really dark shadows look too brutal to me.\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n// end softShadow()\n\n//------------------------------------------------------------------------------\n\n// GET NORMAL\n// ----------\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2( 0.005, -0.005 ); \n    return normalize( e.xyy * map( p + e.xyy ).s + \n\t\t\t\t      e.yyx * map( p + e.yyx ).s + \n\t\t\t\t      e.yxy * map( p + e.yxy ).s + \n\t\t\t\t      e.xxx * map( p + e.xxx ).s );\n\n}\n\n// end getNormal()\n\n//------------------------------------------------------------------------------\n\n// DO COLOR\n// --------\n\nvec3 doColor( in vec3 sp, in vec3 rayDir, in vec3 surfNorm, in vec2 distID )\n                                                               \n{    \n    // Light direction vector.\n    vec3 lDir = LIGHT_POS - sp; \n\n    // Light to surface distance.\n    float lDist = max( length( lDir ), 0.001 ); \n\n    // Normalizing the light vector.\n    lDir /= lDist; \n    \n    // Attenuating the light, based on distance.\n    //float atten = 1.0 / ( 1.0 + lDist * 0.25 + lDist * lDist * 0.05 );\n    float atten = 1.0 / ( lDist * lDist * LIGHT_ATTEN );\n    \n    // Standard diffuse term.\n    float diff = max( dot( surfNorm, lDir ), 0.0 );\n    \n    // Standard specular term.\n    float spec = \n            pow( max( dot( reflect( -lDir, surfNorm ), -rayDir ), 0.0 ), 8.0 );\n    \n    vec3 objCol = getObjectColor( sp, distID );\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = ( objCol * ( diff + 0.15 ) + vec3( 1.0, 0.6, 0.2 ) *\n                                                          spec * 2.0 ) * atten;\n   \n    return sceneCol;   \n}\n\n// end doColor()\n\n//------------------------------------------------------------------------------\n\n// GET RAY DIRECTION\n// -----------------\n\nvec3 getRayDir( vec3 camPos, vec3 viewDir, vec2 pixelPos ) \n{\n    vec3 camRight = normalize( cross( viewDir, vec3( 0.0, 1.0, 0.0 ) ) );\n    vec3 camUp = normalize( cross( camRight, viewDir ) );\n    \n    return normalize( pixelPos.x * camRight + pixelPos.y * camUp + \n                                                    CAM_FOV_FACTOR * viewDir );\n}\n\n// end getRayDir()\n\n//------------------------------------------------------------------------------\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ld3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1441, 1520, 1553, 1553, 1606], [1608, 1785, 1810, 1810, 1887], [1889, 2015, 2040, 2040, 2134], [2136, 2293, 2321, 2321, 2432], [2516, 2531, 2549, 2549, 3398], [3496, 3537, 3581, 3581, 3870], [3897, 3979, 4036, 4182, 6157], [6379, 6446, 6473, 6473, 7234], [7366, 7399, 7440, 7440, 7883], [8169, 8431, 8476, 8476, 8795], [8929, 9134, 9192, 9192, 10438], [10572, 10645, 10674, 10789, 11001], [11105, 11130, 11272, 11307, 12195], [12297, 12340, 12401, 12401, 12688]]}
{"id": "4ld3zH", "name": "Shine By Lawliet", "author": "Lawliet", "description": "Shine", "tags": ["shine"], "likes": 5, "viewed": 512, "date": "1467973079", "time_retrieved": "2024-06-20T18:38:14.590115", "image_code": "#define COLOR vec4(1.0,1.0,1.0,0.5)\n#define SPEED 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 back = texture(iChannel0,uv); \n    \n    vec4 light = COLOR;\n    \n    float offset;\n        \n    //offset = iMouse.x / iResolution.x;\n    \n    offset = cos(mod(iTime * SPEED,3.14 * 0.5));\n    \n    float a = uv.x + offset;\n    \n    a = a * offset;\n    \n    a = step(a,1.0) * a;\n    \n    a = max(a,0.0);\n    \n    a *= light.a; \n    \n\tfragColor = back * (1.0 - a) + light * a;\n    \n    //fragColor = vec4(offset,0.0,0.0,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ld3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[55, 55, 112, 112, 592]]}
{"id": "4ldGDM", "name": "hexamaze", "author": "FabriceNeyret2", "description": "lhexagonal version of  https://www.shadertoy.com/view/4scGWf , keeping the strategy \"exactly one wall per cell\".", "tags": ["2tweets", "maze", "hexagonal", "short"], "likes": 8, "viewed": 672, "date": "1469720194", "time_retrieved": "2024-06-20T18:38:14.826392", "image_code": "// inspired from maze: https://www.shadertoy.com/view/4scGWf\n//   hexagonal tiling: https://www.shadertoy.com/view/4dKXR3\n// another strategy (bad): https://www.shadertoy.com/view/ltd3DM\n\n/**/\nvoid mainImage( out vec4 O,  vec2 U )\n{ \n    vec2 R = iResolution.xy;\n         U = (U-R/2.)/R.y -.1*iTime;           // centered coords   \n    U *= mat2(1,-1./1.73, 0,2./1.73) *24.;           // conversion to hexagonal coordinates\n   \n    float r = sin(1e5*length (ceil(U)));             // trick : [-1,-.5], [-.5,.5], [.5,1] have same weight \n    O += 20./R.y/  fract( r >.5  ? U.x : r< -.5 ? U.y : U.x+U.y ) - O; \n    //O += 20./R.y/  fract( r >.5  ? U.x : r< -.5 ? U.y : 1.-U.x-U.y ) - O;  // better math less pretty !\n    //length(fract(1.-U)) < 1./24. ? O+=2. : O;  // fill some holes\n  //O += -4.+5.*cos(3.14*fract r >.5  ? g.x : r< -.5 ? g.y : g.z ))     - O; \n  //O += .1/ abs(cos(3.14*(    r >.5  ? g.x : r< -.5 ? g.y : g.z ) ))   - O; // variants\n  //O += .1/ abs(sin(3.14*(    r >.5  ? g.x : r< -.5 ? g.y : g.z ) ))   - O; \n  //O += .1/ abs ( fract(      r >.5  ? g.x : r< -.5 ? g.y : g.z ) -.5) - O; \n\n  //O += .2*vec4(fract(floor(U)/2.),0,0);            // tile color \n}\n/**/\n\n\n/**   // Shane version:\nvoid mainImage(out vec4 f, vec2 g){ \n    vec2 R = iResolution.xy; \n    g = (g - R/2.)/R.y + iTime*.125; \n    g *= mat2(1.732, -1, 0, 2)/1.732*20.; \n    \n    float id = fract(sin(dot(floor(g), vec2(123, 289)))*43758.5453); \n    vec2 g2 = fract(g - .5) - .5; \n    float cir = smoothstep(0., 40./R.y, length(g2) - .05); \n    float c = fract( id >.66 ? g.x : id> .33 ? g.y : 1.-g.x-g.y ); \n    c = 1.-smoothstep(0., 40./R.y, abs(c - .05)/(1.-.05)); \n    c = max(c, 1. - cir); f = vec4(c); \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[188, 193, 232, 232, 1176]]}
{"id": "4ldGWN", "name": "Oscillatory Nonsense", "author": "imbellis", "description": "Just some nonsense", "tags": ["2d", "pointlessmaths"], "likes": 0, "viewed": 452, "date": "1469309428", "time_retrieved": "2024-06-20T18:38:14.826392", "image_code": "float xOscs = 30.0;\nfloat yOscs = 90.0;\nfloat xPropSpeed = 5.0;\nfloat yPropSpeed = 5.0;\nfloat globalAmplitude = 3.480;\nfloat globalOffset = 0.024;\nfloat decay = 7.936;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec2 r = st - vec2(0.5);\n    vec2 up = vec2(0.0, 1.0);\n    float theta = acos(dot(r, up));\n    float crossDot = dot(vec3(0.0,0.0,-1.0), cross(vec3(r.x,r.y,0.0), vec3(up.x,up.y,0.0)));\n    theta *= crossDot;\n    \n    st.x = length(r) * cos(theta + iTime);\n    st.y = length(r) * sin(theta + iTime);\n    \n    float x = globalOffset +  globalAmplitude * exp(-st.x/decay) * sin(st.x * xOscs - iTime *xPropSpeed);\n    float y = globalOffset +  globalAmplitude * exp(-st.y/decay) * sin(st.y * yOscs - iTime *yPropSpeed);\n\n    vec3 color = vec3(pow(x,0.520) + pow(y,0.520));    \n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[169, 169, 226, 226, 883]]}
{"id": "4ldGWr", "name": "Spinning S#!t", "author": "rwvens", "description": "Based on that other concentric rings shader.\n\nI played with it too long and I must now warn of potential side effects including but not limited to [REDACTED].", "tags": ["2d", "rings", "radial", "concentric"], "likes": 6, "viewed": 194, "date": "1468778329", "time_retrieved": "2024-06-20T18:38:14.826392", "image_code": "mat2 mm2(in float a){float c = abs( cos(a) ), s = sin(a);return mat2(c,-s,s,c);}\n\nconst float pi = 3.14159265;\nconst float halfpi = pi * 0.5;\n\nfloat saturate( float a )\n{\n\treturn clamp( a, 0.0, 1.0 );\n}\n\n//\n// Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f/0.9375;\n}\n\n// Thanks, Inigo!\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//\n\nconst float linesmooth = 0.0333;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 mainuv = ( fragCoord.xy / iResolution.xy );\n\n    float finalval = 0.0;\n    \n    float rings = 55.0;\n\n    float scale = 1.0;\n    vec2 uv = mainuv * scale - scale * 0.5;\n    uv.x *= aspect;\n        \n    float mainval = 5.0;\n  \tfloat inverseLength = saturate( length( uv ) );\n        \n    float core = pow(mod(inverseLength - iTime * 0.1, 1.0),texture(iChannel0, vec2(0.05, 0)).x*2.0+.25) * rings;\n    float coreident = ceil( core );\n    \n    float colorIdent = fbm4( coreident, iTime * 0.3 );\n    float music = texture(iChannel0, vec2(1.0-coreident/rings, 0)).x;\n    music = music * music;\n\n    vec2 rotatedUVs = uv * mm2( halfpi + fbm4( coreident * 0.01 , iTime*.3 + music/10.0) * pi * pi );\n    rotatedUVs *= mm2( halfpi - fbm4( coreident * 2.0 , iTime*.3 + music/10.0 ) * pi * pi );\n    float arc = ( pi + atan( rotatedUVs.y, rotatedUVs.x ) ) / halfpi;\n    arc /= pi;\n    float arcmod = fract(  arc*colorIdent*colorIdent*100.0+music*music*1.0) \n                 * fract( -arc*colorIdent*colorIdent*100.0+music*music*1.0);\n    float arcpos = smoothstep( 0.2, 0.2025 - coreident * 0.0001, arcmod);\n\n    \n    mainval *= colorIdent * arcpos * music;\n        \n    float coresmooth = fract( core ) * fract( -core );\n  \tfloat corewidth  = fwidth( coresmooth );\n   \tfloat edgethreshold = 0.1;\n    mainval *= smoothstep( edgethreshold - corewidth, edgethreshold + corewidth, coresmooth );\n    finalval += mainval;\n    \n    //\n    \n    finalval = max( finalval, 0.0 ) + 0.0025 * coresmooth;\n    finalval = min( finalval, 1.0 );\n\n    vec3 tint = palette(arc+iTime*.03,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\tfragColor = vec4( vec3( pow( finalval, 1.0 / 2.2 ) ) * 1.0-(1.0-tint)*.15, 1.0 );\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ldGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 80], [143, 143, 170, 170, 202], [204, 250, 283, 283, 316], [368, 368, 400, 400, 651], [653, 671, 743, 743, 786], [787, 825, 882, 882, 2663]]}
{"id": "4lt3D4", "name": "The sine swing", "author": "vapoi", "description": "it's time to swing.", "tags": ["2d", "simple"], "likes": 1, "viewed": 109, "date": "1469303742", "time_retrieved": "2024-06-20T18:38:14.826392", "image_code": "const float cfPi = 3.14159;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position im Bild, die HÃ¶he pos.y geht von 0.0 (unten) bis 1.0 (oben)\n    //\t\t\t\t\t die Breite pos.x geht von 0.0 (links) bis 1.0 (rechts)\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    \n    // Unsere Position, aber mit Ursprung in der Mitte des Bildes\n    vec2 posMid = vec2(-1.0, -1.0) + 2.0 * pos; \n    // HÃ¶he und Breite in VerhÃ¤ltnis setzen\n    posMid.x *= iResolution.x / iResolution.y;\n    \n    // die Zeit in Sekunden: 1.0 entspricht einer Sekunde\n    float fTime = iTime * 1.0;\n    \n    float fProgress = smoothstep(0.0, 13.0, fTime);\n    \n// a) Bewegung\n    float fBackMotion = 0.0;\n    fBackMotion += 0.70 * sin(posMid.y * 4.0 + fTime * 02.70) \n         \t \t * sin(posMid.x * 5.0 + fTime * 02.70);\n    \n    fBackMotion += 0.10 * sin(posMid.y * 17.0 - fTime * 01.1) \n        \t  \t  * sin(posMid.x * 19.0 - fTime * 01.3);\n    \n    // Null Bewegung oben\n    fBackMotion *= sqrt(1.0 - pos.y);\n\tfBackMotion *= fProgress;\n    \n// b) Linien  \n    float fValue = 0.0;\n    \n    fValue = cos(cfPi * pos.x * 4.0 \n                 + 0.06 * atan(fBackMotion * 2.5 + (0.5 * sin(fBackMotion * 2.0))));\n             \n\n\t// Schwingung\n    float fMod = 2.20 * sin(cfPi * 0.5 + fTime * 5.0 * (1.0 / cfPi));\n    fMod *= 1.0 - pos.y;\n    fMod *= fProgress;\n\t\n    \n    fValue = 1.0 - smoothstep(0.1, 0.16, abs(fValue - fMod));\n    vec3 col1 = vec3(0.7) + vec3(0.6) * max(-fMod, -0.7);\n        \n    fragColor = vec4(col1 * (fValue), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[30, 30, 87, 233, 1526]]}
{"id": "4lt3D8", "name": "wateer", "author": "liam77", "description": "water", "tags": ["water"], "likes": 1, "viewed": 536, "date": "1469076048", "time_retrieved": "2024-06-20T18:38:14.826392", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n\tO = vec4( U / iResolution.xy,\n              U.y < sin(U.x/160.+iTime*2.) * 50. +200.,\n              1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 38, 38, 145]]}
{"id": "4lt3R7", "name": "Old School Rubber Glenz", "author": "Himred", "description": "Trying to implement the old school effect rubber glenz from amiga 500\nHold LMB to disable transparency", "tags": ["raymarching", "transparency", "oldschool", "glenz"], "likes": 17, "viewed": 810, "date": "1468439472", "time_retrieved": "2024-06-20T18:38:15.711280", "image_code": "/*\nA try of implementation of the old school effect rubber glenz (first seen on Amiga in 1991).\n\nThe code is *NOT* optimized at all\nIt was coded as a proof of concept and a personal challenge (don't laugh).\n\nI borrowed some code (thats the concept of shadertoy isnt'it ?) from:\nLighting stuff: https://www.shadertoy.com/view/MdGXWG by Shane\nOriginal tentative of glenz: https://www.shadertoy.com/view/ldlSW2 by rix\nrgb bars: I was unable to find the shader where i copied the code :(\n\nHold LMB to disable transparency\n\n*/\n\nvec3 cubevec;\n\n// Sinus bars function\nvec3 calcSine(vec2 uv, float frequency, float amplitude, float shift, float offset, vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float d = distance(y, uv.y);\n    float scale = smoothstep(width, 0.0, distance(y, uv.y));\n    return color * scale;\n}\n\n// Render the bars calling 3 CalcSines() and adding rgb componants\nvec3 Bars(vec2 f)\n{\n    vec2 uv = f / iResolution.xy;\n    vec3 color = vec3(0.0);\n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.6, 0.15, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 1.0);\n    color += calcSine(uv, 0.9, 0.35, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 1.0);\n    return color;\n}\n\n// Classic iq twist function\nvec3 Twist(vec3 p)\n{\n    float f = sin(iTime/3.)*1.45;\n    float c = cos(f*p.y);\n    float s = sin(f/2.*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// The distance function which generate a rotating twisted rounded cube \n// and we save its pos into cubevec\nfloat Cube( vec3 p )\n{\n    p=Twist(p);\n    cubevec.x = sin(iTime);\n    cubevec.y = cos(iTime);\n    mat2 m = mat2( cubevec.y, -cubevec.x, cubevec.x, cubevec.y );\n    p.xy *= m;p.xy *= m;p.yz *= m;p.zx *= m;p.zx *= m;p.zx *= m;\n    cubevec = p;\n    return length(max(abs(p)-vec3(0.4),0.0))-0.08;\n}\n\n// Split the face in 4 triangles zones\n// return color index 0 or 1 if color1 or color2\nfloat Face( vec2 uv )\n{\n        uv.y = mod( uv.y, 1.0 );\n        return ( ( uv.y < uv.x ) != ( 1.0 - uv.y < uv.x ) ) ? 1.0 : 0.0;\n}\n\n//Classic iq normal\nvec3 getNormal( in vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    return normalize(\n        e.xyy * Cube(p + e.xyy) +\n        e.yyx * Cube(p + e.yyx) +\n        e.yxy * Cube(p + e.yxy) +\n        e.xxx * Cube(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\t\t\t\t\t\t// Save x for shorter code\n    float pat = iTime*5.0;\t\t\t\t// Precalc 5time for later use\t\t\t\t\n    float Step = 1.0;\t\t\t\t\t\t\t// For raymarching\n    float Distance = 0.0;\t\t\t\t\t\t// For raymarching\n    float Near = -1.0;\t\t\t\t\t\t\t// Near color index\n    float Far = -1.0;\t\t\t\t\t\t\t// Far color index\n    vec3 lightPos = vec3(1.5, 0, 0);\t\t\t// Light position\n    vec2 kp = fragCoord.xy / iResolution.xy;\t// Normalized coords\n    vec2 p = -1.0 + 2.0*kp;\t\t\t\t\t\t// Uv\n    vec4 m = iMouse / iResolution.xxxx;\t\t\t// Mouse status\n    float hd=-1.;\t\t\t\t\t\t\t\t// Hit Distance\n    float ay=max(0.1,0.5-iTime/6.);\t\t// For opening the screen\n     \n    // Non standard Raymarching\n    // When we hit a face, we continue to march, so the ray goes into the cube\n    // But we keep in Near the color index of the first face hit by the ray\n    // We also keep in Far the last color index the ray hit\n    // We break when 256 steps has been done or distance > 4\n    // Finnaly we get in Near and Far vars the coloring values to simulate the transparency\n    \n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 2.1 );\n    vec3 rd = normalize( vec3( p, -2. ) );\n    for( int i = 0; i < 256; i++ )\n        {\n        \tStep = Cube( ro + rd*Distance );\n            Distance += Step*.5;\n\n            if( Distance > 4.0 ) break;\n            if( Step < 0.001 )\n            \t{\n                    // Getting the color index of hit point\n                 \tFar = Face( cubevec.yx ) + Face( -cubevec.yx ) + Face( cubevec.xz ) + Face( -cubevec.xz ) + Face( cubevec.zy ) + Face( -cubevec.zy );\n                    // save in hd the first hit distance for later lighting\n            \t\tif(hd<0.) hd=Distance;\n                    // Save Far as Near on first hit\n                    if( Near < 0.0 ) Near = Far;\n                    // If transparency is not disabled lets keep walking into the cube\n                    // Or maybe outside. Otherwise break\n            \t\tif(m.z<=0.0) Distance += 0.05; else break; // 0.05 is a magic number \n                }\n        }\n\n    // Initialize the background color to the sinus bars\n    vec3 Color=Bars(fragCoord);\n    \n    // if we hit something\n    if( Near > 0.0 )\n    \t{\n          \t// lighting stuff (taken from a Shane shader)\n            vec3 sp = ro + rd*hd;\n        \tvec3 ld = lightPos - sp;\n            float lDist = max(length(ld), 0.001);\n            ld /= lDist;\n            float atten = 1./(1. + lDist*.2 + lDist*.1); \n            float ambience = 0.7;\n            vec3 sn = getNormal( sp);\n            float diff = min(0.3,max( dot(sn, ld), 0.0));\n            float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n            \n            // Simulating transparency with mix() Near and Far\n            if(m.z<=0.) Color = Color/5. + mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            else Color = mix( vec3( 0.2, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ), vec3( ( Near*0.45 + Far*Far*0.04 ) ) );\n            \n            // Applying the lighting to color\n            Color = Color*(diff+ambience)+vec3(0.78,0.5,1.)*spec/1.5;\n        }\n\n    // The bottom and top rainbow lines\n    if (kp.y > ay && kp.y < ay+0.006 || kp.y > (1.-ay) && kp.y < 1.-ay+0.006 ) Color = vec3(0.5 + 0.5 * sin(x/120. + 3.14 + pat), 0.5 + 0.5 * cos (x/120. + pat), 0.5 + 0.5 * sin (x/120. + pat));\n    // The bottom and top purple zones\n    if(kp.y<ay || kp.y>1.-ay+0.006) Color=vec3(0.20,0.17,0.35);\n\n    // Presenting color to the screen\n    fragColor = vec4( Color, 1.0 );\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[538, 561, 687, 687, 883], [885, 952, 971, 971, 1290], [1292, 1321, 1341, 1341, 1491], [1493, 1602, 1624, 1624, 1897], [1899, 1987, 2010, 2010, 2118], [2120, 2140, 2169, 2169, 2363], [2365, 2365, 2422, 2422, 5982]]}
{"id": "4lt3WH", "name": "RayMarchingAttempt-2", "author": "sea", "description": " ", "tags": ["raytracing"], "likes": 0, "viewed": 122, "date": "1469086011", "time_retrieved": "2024-06-20T18:38:15.711280", "image_code": "#define PI 3.1415192\n\nconst float fov = 90.0;\n\nvec3 spherePosition = vec3(0.0, 0.0, 3.0);\nvec3 lightPosition = vec3(-3.0, 3.0, 1.0);\n\nfloat sphereRadius = 1.0;\n\nfloat calculateLight (vec3 intersection, vec3 normal)\n{\n    // Rotate light on y axis around the sphere.\n    float lightX = lightPosition.x * cos(iTime) - lightPosition.z * sin(iTime);\n    float lightZ = lightPosition.z * cos(iTime) + lightPosition.x * sin(iTime);\n    \n    // Set light position.\n    vec3 lPosition = vec3(lightX, lightPosition.y, lightZ);\n    \n    // Calculate intersection between the light and the sphere.\n    vec3 intersectionDirection = normalize(intersection - lPosition);\n    \n    // Compare the light direction to the sphere normal.\n    return dot(intersectionDirection, normal);\n}\n\nvec3 intersectSphere (vec3 rayOrigin, vec3 rayDirection)\n{\n    float distance = 0.0;\n    \n    // Walk forward starting from the ray origin in the ray direction.\n    for (float i = 0.0; i < 4.0; i += 0.01)\n    {\n        // Calculate ray position.\n        vec3 point = rayOrigin + rayDirection * i;\n        \n        float sphereDistance = length(spherePosition - point);\n        \n        if (sphereDistance < sphereRadius)\n        {\n            // Calculate sphere normal by calculating the direction between center and the intersection point.\n            vec3 normal = normalize(spherePosition - point);\n            float v = calculateLight(point, normal);\n            return vec3(v);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 viewSpace = uv * 2.0 - 1.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    viewSpace.y /= aspect;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    \n    // Calculate ray direciton.\n    vec3 rayDirection = normalize(vec3(viewSpace, 1.0));\n    vec3 color = intersectSphere(rayOrigin, rayDirection);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lt3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[161, 161, 216, 265, 767], [769, 769, 827, 827, 1497], [1499, 1499, 1556, 1556, 1960]]}
{"id": "4ltGDn", "name": "[SH16B] tunel", "author": "lovelyH", "description": "some code writen on sundown demoparty.", "tags": ["sh16b"], "likes": 3, "viewed": 201, "date": "1468754634", "time_retrieved": "2024-06-20T18:38:15.717351", "image_code": "/// float iTime;\n/// vec2 iResolution;\n/// sampler2D textures[];\n/// vec3 iCam;\n/// float iCamRZ;\n/// float iCamRX;\n\n#define E 0.01\n\n#define MAT_GRASS\t\t1\n#define MAT_GLASS_RED\t2\n#define MAT_GLASS \t\t3\n#define MAT_ROCK\t\t4\n#define MAT_WATER\t\t5\n\nvec3 rotY(vec3 p, float l ){\n\tfloat sl= sin(l);\n\tfloat cl= cos(l);\n\treturn vec3(\n\t\tp.x*cl - p.z*sl,\n\t\tp.y,\n\t\tp.x*sl + p.z*cl\n\t);\n}\n\nfloat dfBox( vec3 p, vec3 s){\n\tp= abs(p)-s;\n\treturn max( max( p.x, p.y), p.z );\n}\n\nint matId;\nfloat map(vec3 pi){\n\tvec3 p= pi;\n\t/// water floor\n\tfloat r= p.z + 2.0 + sin(iTime*0.1);\n\tmatId= MAT_WATER;\n\tfloat rc;\n\t/// balls\n\tp.y= mod(p.y+mod(8.0*iTime,4.0),4.0) - 2.0;\n\tp.x= abs(p.x);\n\trc= length(p-vec3(2,0,0))-0.5;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_GLASS_RED;\n\t}\n\t/// cubes\n\tp= pi;\n\tp.y= p.y+8.0*iTime;\n\tif( mod( p.y, 200.0 ) < 50.0 ){\n\t\tp= rotY( p, floor((p.y)/4.0) );\n\t\tp.y= mod(p.y,4.0) - 2.0;\n\t\tp.x= abs(p.x);\n\t\trc= dfBox(p-vec3(2,0,0), vec3(0.5,0.2,0.2));\n\t\tif( rc < r ){\n\t\t\tr= rc;\n\t\t\tmatId= MAT_ROCK;\n\t\t}\n\t}\n\t/// columns\n\tp= pi;\n\tp.y= mod(p.y+mod(8.0*iTime,80.0),80.0) - 40.0;\n\tp.xy= abs(p.xy) - vec2(2.0);\n\tp.xy= abs(p.xy) - vec2(1.0);\n\trc= length(p.xy) - 0.3;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_GLASS;\n\t}\n\t/// cave\n\tp= pi;\n\tp.y= p.y+8.0*iTime;\n\trc= -length(p.xz-vec2(0.0,0.9))+3.0;\n\t/// cut tube tunel\n\tif( mod( p.y, 1000.0 ) < 500.0 )rc= max( rc, p.z - 1.0 );\n\t//if( mod( p.y, 100.0 ) < 50.0 )rc= max( rc, -dfBox( p, vec3() ) );\n\t/// cut holes some wholes\n\tif( mod( p.y, 18.0 ) < 9.0 )\n\t\trc= max( rc, -dfBox( mod(p,0.9)-0.45, vec3(0.4) )  );\n\t/// apply\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_ROCK;\n\t}\n\t/// reeturn final \n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\t// vec3 lightDir= normalize( vec3( cos(iTime), sin(iTime), 1 ) );\n\tvec3 lightPos= vec3( cos(iTime)*4.0, sin(iTime)*4.0, 4.0 );\n\n\tvec3 r= vec3(0);\n\tfloat powerLeft= 0.666;\n\n\tfor( int pas=0;pas<3;pas++){\n\n\t\tvec3 p= sp;\n\t\tfloat dis= map(p);\n\t\tbool isHit= false;\n\t\tfor( int a=0;a<0x80;a++){\n\t\t\tp += dis*dir;\n\t\t\tdis= map(p);\n\t\t\tif( dis < E ){\n\t\t\t\tisHit= true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( isHit ){\n\t\t\tvec3 baseColor= vec3( 0.9 );\n\t\t\tfloat reflexPower= 0.0;\n\t\t\tif( matId==MAT_GRASS ){\n\t\t\t\tbaseColor= vec3( 0.5, 0.9, 0.5 );\n\t\t\t}else if( matId==MAT_GLASS_RED ){\n\t\t\t\tbaseColor= vec3( 0.9, 0.2, 0.2 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}else if( matId==MAT_GLASS ){\n\t\t\t\tbaseColor= vec3( 0.9 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}else if( matId==MAT_WATER ){\n\t\t\t\tbaseColor= vec3( 0.5, 0.5, 0.9 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}\n\t\t\tvec3 lightDir= normalize( lightPos - p );\n\t\t\tvec3 nor= normalize( vec3(\n\t\t\t\tmap(p+vec3(E,0,0))-map(p-vec3(E,0,0)),\n\t\t\t\tmap(p+vec3(0,E,0))-map(p-vec3(0,E,0)),\n\t\t\t\tmap(p+vec3(0,0,E))-map(p-vec3(0,0,E))\n\t\t\t) );\n\n\t\t\t/// shadow calculation\n\t\t\tfloat lighting= dot(lightDir,nor);\n\t\t\tfloat disFromLight= length(p-lightPos);\n\t\t\tif( 0.0 < lighting ){\n\t\t\t\tfloat shadowH= 0.1;\n\t\t\t\tfloat shadowDis= 0.0;\n\t\t\t\tvec3 p2=p+shadowH*lightDir;\n\t\t\t\tfloat shadowDisTotal= shadowH;\n\t\t\t\tfor( int i=0;i<0x40;i++){\n\t\t\t\t\tshadowDis= map(p2);\n\t\t\t\t\tshadowDisTotal += shadowDis;\n\t\t\t\t\tif( disFromLight < shadowDisTotal ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp2 += shadowDis * lightDir;\n\t\t\t\t\tif( shadowDis < E ){\n\t\t\t\t\t\tshadowDis= 0.0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlighting = min( lighting, shadowDis/shadowH );\n\t\t\t}\n\n\t\t\tr+= powerLeft * baseColor\n\t\t\t\t*clamp( 2.0-disFromLight/8.0, 0.0, 1.0)\n\t\t\t\t*(0.5+0.5*lighting)\n\t\t\t\t*(0.5+0.5*dot(-dir,nor))\n\t\t\t\t*(lighting<=0.0?1.0:(1.0+pow(max( 0.0, dot( reflect( dir, nor ), lightDir )), 16.0 )))\n\t\t\t;\n\n\t\t\tdir= reflect( dir, nor );\n\t\t\tsp= p + 0.5*dir;\n\t\t\tpowerLeft *= reflexPower;\n\t\t\tif( powerLeft < 0.05 )\n\t\t\t\tbreak;\n\t\t}else{\n\t\t\tr+= powerLeft*vec3(0.0);\n\t\t}\n\t}\n\n\treturn r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\tuv.x *= iResolution.x / iResolution.y;\t\n\tfragColor = vec4( \n\t\trender( \n\t\t\tvec3(0.5*sin(iTime*0.6),-16,0.5*sin(iTime*0.2)), \n\t\t\tnormalize(vec3(uv.x,2.0,uv.y))\n\t\t), 1.0\n\t);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 242, 270, 270, 372], [374, 374, 403, 403, 455], [468, 468, 487, 487, 1620], [1624, 1624, 1657, 1724, 3623], [3626, 3626, 3683, 3683, 3916]]}
{"id": "4ltGR7", "name": "Particle v2", "author": "thecodewarrior", "description": "A spiral swirl shader for a particle", "tags": ["spiral", "particle"], "likes": 2, "viewed": 140, "date": "1468435866", "time_retrieved": "2024-06-20T18:38:15.717351", "image_code": "float speed = 5.;\nint arms = 4;\nfloat centerRadius = 0.1;\nfloat pulseSpeed = 1.;\n\nfloat time() {\n    return iTime;\n}\n\nfloat rotOffset() {\n    return time()*(-speed*45.); \n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvec4 particle( vec2 uv )\n{\n    vec4 color = vec4(0, 0, 0, 0);\n    \n    float len = sqrt( uv.x * uv.x + uv.y * uv.y )*2.;\n    vec2 check = vec2(0, 1);\n    \n    float dotP = check.x*uv.x + check.y*uv.y;\n\tfloat detP = check.x*uv.y - check.y*uv.x;\n    \n    float angle = degrees(atan(detP, dotP));\n    angle += rotOffset();\n    \n    angle += sqrt(len)*360.;\n    \n    float d = 360./float(arms);\n    d = d/2.;\n    \n    float checkAngle = mod(angle, d*2.);\n    \n    float anglePercent = ((checkAngle/(d*2.))-0.5)*2.;\n    \n    color = vec4(0, 1, 0, 1);\n        \n    color.w *= 1.-clamp(pow(anglePercent, 2.)+0.2, 0., 1.);\n    color.w *= 1.-clamp(pow(len, 2.), 0., 1.);\n    \n    float noisePos = (len-pulseSpeed*time())*10.;\n    color.w *= 1.+noise(vec2(noisePos, 0)/2.);\n    \n    noisePos = (centerRadius-pulseSpeed*time())*10.;\n    \n    vec4 center = vec4(1, 0, 0, 1.-clamp(pow(len, 2.)*(1./centerRadius), 0., 1.));\n    center.w *= 1.+noise(vec2(noisePos, 0)/2.);;\n    \n    vec4 color2 = mix(color, center, center.w);\n    color2.w = max(color.w, center.w);\n    color = color2;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = min(iResolution.x, iResolution.y);\n    float maxsize = max(iResolution.x, iResolution.y);\n    \n\tvec2 offset = vec2(0);\n    float offsetAmount = ((maxsize-size)/2. )/size;\n    \n    if(iResolution.x > iResolution.y)\n        offset.x = offsetAmount;\n    if(iResolution.y > iResolution.x)\n        offset.y = offsetAmount;\n    \n    vec2 uv = fragCoord.xy/size;\n    uv -= offset;\n    if(uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.)\n    {\n        fragColor = vec4(1, 0, 1, 1);\n    } else {\n        uv = uv - vec2(0.5);\n        fragColor = particle(uv);\n        fragColor = mix(vec4(0), fragColor, fragColor.w);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[82, 82, 96, 96, 116], [118, 118, 137, 137, 172], [174, 174, 194, 194, 264], [266, 266, 286, 286, 521], [523, 523, 549, 549, 1618], [1620, 1620, 1677, 1677, 2311]]}
{"id": "4ltGRn", "name": "Spiky tunnel", "author": "Blackorange", "description": "Part of demo made for edison 2016,", "tags": ["3d", "tunnel", "triangle", "distort", "spikes"], "likes": 10, "viewed": 425, "date": "1467658361", "time_retrieved": "2024-06-20T18:38:15.717351", "image_code": "\n#define pi 3.1416\n#define time iTime\nfloat fpos; \n\nconst int iterations = 128;\n\nvec3 mid_light;\n \n\nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ) {\n  vec2 i = floor( p );\n  vec2 f = fract( p );\t\n  vec2 u = f*f*(3.0-2.0*f);\n  return -1.0+2.0*mix( mix( rand( i + vec2(0.0,0.0) ), \n\t\t\t    rand( i + vec2(1.0,0.0) ), u.x),\n\t\t       mix( rand( i + vec2(0.0,1.0) ), \n\t\t\t    rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat trianglewave(float t, float a){\n      float q = t / a;\n      return 2. * abs( 2.*(q - floor(q + 0.5))) - 1.;\n}\nfloat mapFunc(vec3 p){\n\n  p.y +=  0.2 * noise(p.xz + time);\n  float amp = 0.2;\n\n  if (time < 20.) {\n    amp *= clamp(20. - time, 0., 1.);\n    p.y = p.y + trianglewave(p.z, 0.7) * amp + trianglewave(p.x, 0.7) * amp ;\n  }\n\n  return 2. + p.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/ k;\n}\nfloat mapSphere(vec3 p, float r){\n  p.z -= time * 3.;\n  p.z = mod(p.z, 20.) - 2.5;\n  mid_light = p;\n  return length(p)-r;\n}\nfloat map(vec3 p){\n  p.z += time;\n  p.xy += 0.5 * sin(p.z + time);\n\n  float s = mapSphere(p,0.7);\n  p.xy = (rotz(p.z * 0.3) * p).xy;\n  float third = 2. * pi / 3.;\n  float f = mapFunc(p);\n  p = rotz(third) * p; \n  float f1 = mapFunc(p);\n  p = rotz(third) * p; \n  float f2 = mapFunc(p);\n\n  float k = 2.;\n  return min(smin(smin(f, f1, k), f2, k), s);\n}\n\nfloat trace(vec3 origin, vec3 ray, vec3 misc){\n    \n  float t = 0.0;\n  for(int i = 0; i < iterations; i++){\n    vec3 point = origin + ray * t;\n    float dist = map(point);\n    t += dist * 0.5;\n  }\n  return t;\n}\n\n\nvec3 nor(vec3 p, float prec){\n  vec2 e = vec2(prec,0.);\n\n  vec3 n;\n  n.x = map(p+e.xyy) - map(p-e.xyy); \n  n.y = map(p+e.yxy) - map(p-e.yxy); \n  n.z = map(p+e.yyx) - map(p-e.yyx);  \n  return normalize(n);\n\n}\n\n\nvec3 Shade(vec3 p, vec3 n,  vec3 o, vec3 color)\n{\n  vec3 lp = vec3(0,0,1);\n  vec3 s = lp - p;\n    \n  float l = .2;  \n  l += .8 * max(dot(n, normalize(s)), 0.);\n  l += .85 * pow(max(dot(normalize(o - p), reflect(-normalize(s), n)), 0.), 7.);\n  return color * l ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 res = \tiResolution.xy / iResolution.y;\n    vec2 fpos = fragCoord / iResolution.xy;\n\tvec3 pos = vec3(fpos.xy, 1.);\n    pos.x *= res.x / res.y;\n     mat3 rotmat = rotx(-pi/12.);\n    \n     pos =  rotmat * pos;\n     vec3 ray = normalize(vec3(pos.xy - res / 2.,0.5));\n   \n     vec3 origin =  vec3(0.0, 0.0, -3.);\n     origin =  rotmat * origin;\n     float t = trace(origin,ray, vec3(0.5,1.,0.) );\n\n     vec3 p = origin + t * ray;\n     float fog = 1.0 / (1.0 + t * t * 0.0025);\n\t\n    vec3 color = vec3(.3,.5,1.);\n    float e = 0.01;\n    \n    vec3 fc = Shade(p,nor(p,e), origin, color);\n    \n    fragColor = vec4(fc,1.) * fog;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[100, 100, 119, 119, 229], [230, 230, 249, 249, 361], [363, 363, 382, 382, 487], [489, 489, 509, 509, 579], [581, 581, 607, 607, 868], [869, 869, 906, 906, 985], [986, 986, 1008, 1008, 1227], [1229, 1229, 1270, 1270, 1342], [1343, 1343, 1376, 1376, 1466], [1467, 1467, 1485, 1485, 1816], [1818, 1818, 1864, 1864, 2028], [2031, 2031, 2060, 2060, 2238], [2241, 2241, 2290, 2290, 2504], [2508, 2508, 2565, 2565, 3199]]}
{"id": "4ltGW4", "name": "black and white hole", "author": "al13n", "description": "An attempt to mimic http://pics-about-space.com/drawing-pencil-black-hole?p=3#img13033063924873539632", "tags": ["hyperbola"], "likes": 14, "viewed": 861, "date": "1469310914", "time_retrieved": "2024-06-20T18:38:16.008270", "image_code": "#define ANTIALIAS\n\nfloat DE(vec3 p0){\n    vec2 p = vec2(length(p0.xz), -p0.y);\n    float a = .5;\n    // 2-dimentional DE for hyperbola y=a/x\n    float d = sqrt((p.x+p.y)*(p.x+p.y)-4.*(p.x*p.y-a))+.5;\n    return (-p.x-p.y+d)/2.;\n}\n\nfloat softmod(float x, float w){\n    x = mod(x, 2.);\n#ifdef ANTIALIAS\n    w /= iResolution.y;\n    return smoothstep(.5-w,.5+w,x)*(1.-smoothstep(1.5-w,1.5+w,x));\n#else\n    return floor(x);\n#endif\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Camera.\n    float fov = 1.8, // it's not really FOV\n    \t  an = -.7 /*+ (iMouse.y / iResolution.y - .5) * 3.*/;\n    vec2 R = iResolution.xy;\n    U = (U - R/2.) / R.y;\n    vec3 p = vec3(0., -.7/* + (iMouse.x / iResolution.x - .5) * 6.*/, -1.),\n         d = vec3(U * fov, 1.),\n         p0 = p;\n    d.yz *= mat2(cos(an),sin(an),\n                -sin(an),cos(an));\n    \n    for (int i = 0; i < 64; ++i) p += d * DE(p);\n    \n    \n    float fh = 3.5, // fog options.\n          fs = 1.,\n          f0 = 1.,\n          gr = .9, // background color\n          l = length(p.xz) /*- 1e5 + iTime*/, // uncomment for cool animation\n          s = length(p-p0);\n    \n    float c1 = softmod(atan(p.z,p.x)/3.14159*32.+iTime*2., 12.*s);\n    float c2 = softmod((l+p.y)*4., 6.*s);\n    float c = l>.95 || l > 1e4 ? 1.\n        : min(c1+c2,2.-c1-c2);\n    O = vec4(c * gr * log((p.y+fh)*fs)/log((fh-f0)*fs));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ltGW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 19, 37, 37, 229], [231, 231, 263, 263, 427], [429, 429, 470, 485, 1361]]}
{"id": "4t33Rn", "name": "Bending Circle", "author": "soma_arc", "description": "Bending 2223 hyperbolic tiling. Most of larger bending parameter don't meet the requirements of the Tiling Theorem.\nFor more details, please refer Bending Hyperbolic Kaleidoscopes and Bending Circle Limits by Vladimir Bulatov\n", "tags": ["2d", "fractal", "tiling"], "likes": 8, "viewed": 321, "date": "1468316603", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n\nvec2 cPos1 = vec2(1.2631, 0);\nvec2 cPos2 = vec2(0, 1.2631);\nfloat cr1 = 0.771643;\nfloat cr2 = 0.771643;\nconst float PI = 3.14159265359;\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nvec2 reverseStereoProject(vec3 pos){\n\treturn vec2(pos.x / (1. - pos.z), pos.y / (1. - pos.z));\n}\n\nvec4 circleIntersection(vec2 cPos1, float r1, vec2 cPos2, float r2){\n\tfloat x = cPos1.x - cPos2.x;\n    float y = cPos1.y - cPos2.y;\n    float x2 = x * x;\n    float y2 = y * y;\n    float x2y2 = x2 + y2;\n    float a = (x2y2 + r2 * r2 - r1 * r1) / 2.;\n    float a2 = a * a;\n    float numR = sqrt(x2y2 * r2 * r2 - a2);\n    return vec4((a * x + y * numR) / x2y2 + cPos2.x, (a * y - x * numR) / x2y2 + cPos2.y,\n                (a * x - y * numR) / x2y2 + cPos2.x, (a * y + x * numR) / x2y2 + cPos2.y);\n}\n\n\nvec3 stereoProject(vec2 pos){\n\tfloat x = pos.x;\n    float y = pos.y;\n    float x2y2 = x * x + y * y;\n    return vec3((2. * x) / (1. + x2y2),\n                (2. * y) / (1. + x2y2),\n                (-1. + x2y2) / (1. + x2y2));\n}\n\nvec3 getCircleFromSphere(vec3 upper, vec3 lower){\n\tvec2 p1 = reverseStereoProject(upper);\n    vec2 p2 = reverseStereoProject(lower);\n   \treturn vec3((p1 + p2) / 2., distance(p1, p2)/ 2.); \n}\n\nbool revCircle = false;\nbool revCircle2 = false;\nconst int ITERATIONS = 50;\nfloat colCount = 0.;\nbool outer = false;\nint IIS(vec2 pos){\n    colCount = 0.;\n    //if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(revCircle){\n            if(distance(pos, cPos1) > cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos1) < cr1 ){\n                pos = circleInverse(pos, cPos1, cr1);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(revCircle2){\n            if(distance(pos, cPos2) > cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }else{\n        \tif(distance(pos, cPos2) < cr2 ){\n                pos = circleInverse(pos, cPos2, cr2);\n                invCount++;\n                colCount++;\n                fund = false;\n            }\n        }\n        \n        if(fund){\n            if(length(pos) > 1.5){\n                outer = true;\n            \treturn 0;\n            }\n        \treturn invCount;\n        }\n    }\n\n\treturn invCount;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 calcCircleFromLine(vec4 line){\n\tfloat a = line.x;\n    float b = line.y;\n    float c = line.z;\n    float d = line.w;\n    \n    float bcad = b * c - a * d;\n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float d2 = d * d;\n    float c2d2 = (1. + c2 + d2);\n    vec2 pos = vec2(((1. + a2) * d + b2 * d - b * c2d2)/(-2. * bcad),\n                     (a2 * c + (1. + b2) * c - a * c2d2)/ (2. * bcad));\n    return vec3(pos, distance(pos, line.xy));\n}\n\nconst float sampleNum = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, 10.);\n    t = abs(t - 5.) / 5.;\n    \n    float ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    float x = 0.57735;\n\n    float bendX = t;// 0. + 1. * abs(sin(iTime));;//PI / 6.;\n    mat3 xRotate = mat3(1, 0, 0,\n                        0, cos(bendX), -sin(bendX),\n                        0, sin(bendX), cos(bendX));\n    float bendY = 0.;//PI/6.5;//-abs(0.8 * sin(iTime));\n    mat3 yRotate = mat3(cos(bendY), 0, sin(bendY),\n                         0, 1, 0,\n                         -sin(bendY), 0, cos(bendY));\n\tfloat y = .57735;\n    vec3 c1 = getCircleFromSphere(vec3(0, y, sqrt(1. - y * y))* xRotate,\n                                  vec3(0, y, -sqrt(1. - y * y))* xRotate);\n    vec3 c2 = getCircleFromSphere(vec3(x, 0, sqrt(1. - x * x)) * yRotate,\n                                  vec3(x, 0, -sqrt(1. - x * x)) * yRotate);\n    \n\tcr1 = c1.z;\n    cr2 = c2.z;\n    cPos1 = c1.xy;\n    cPos2 = c2.xy;\n    \n    if(y > cPos1.y){\n    \trevCircle = true;\n    }\n\tif(x > cPos2.x){\n    \trevCircle2 = true;\n    }\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\n        position *= ( 2.2 + ( t * 8.));\n        //position += vec2(cos(iTime), 0.3 * sin(iTime));\n\n        int d = IIS(position);\n        \n        if(d == 0){\n            sum += vec3(0.,0.,0.);\n        }else{\n            if(mod(float(d), 2.) == 0.){\n                if(outer){\n                \tsum += hsv2rgb(vec3(0.4 + 0.02 * colCount, 1., 1.));\n                }else{\n                    sum += hsv2rgb(vec3(0.02 * colCount, 1., 1.));\n                }\n            }else{\n                if(outer){\n                \tsum += hsv2rgb(vec3(0.8 + 0.02 * colCount, 1., 1.));\n                }else{\n                    sum += hsv2rgb(vec3(0.7 + 0.02 * colCount, 1., 1.));\n                }\n            }\n        }\n    }\n    fragColor = vec4(sum/sampleNum, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t33Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 549], [689, 689, 749, 749, 865], [867, 867, 903, 903, 963], [965, 965, 1033, 1033, 1462], [1465, 1465, 1494, 1494, 1692], [1694, 1694, 1743, 1743, 1884], [2003, 2003, 2021, 2021, 3501], [3503, 3503, 3525, 3525, 3694], [3696, 3696, 3731, 3731, 4164], [4195, 4195, 4251, 4251, 6211]]}
{"id": "4t3GDr", "name": "Function", "author": "Tacoa", "description": "Sine wave function", "tags": ["sinwave"], "likes": 2, "viewed": 95, "date": "1468629533", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "#define N 100.\n#define PI 3.14159265358979\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\t\n    vec2 p = N * (fragCoord * 2.0 - R) / min(R.x, R.y);\t// Normalize\n    \n    R.x = p.x;\t\t\t\t\t\t\t\t\t\t\t\t // x coordinate of function\n    R.y = sin(iTime) * R.x * sin(iTime + R.x);\t\t// y coordinate of function based on x\n\t\n    vec3 destColor = vec3(1. / length(R - p));\n                          \n    fragColor = vec4( destColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3GDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[44, 44, 101, 101, 463]]}
{"id": "4t3GRn", "name": "4colorgradient", "author": "0xec", "description": "A simple pixel shader demonstrating an animated 4 color gradient.", "tags": ["2d"], "likes": 1, "viewed": 204, "date": "1467525016", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "const vec4 TLCOLOR = vec4(1.0, 0.0, 0.0, 0.0);\nconst vec4 TRCOLOR = vec4(0.0, 1.0, 0.0, 0.0);\nconst vec4 BLCOLOR = vec4(0.0, 0.0, 1.0, 0.0);\nconst vec4 BRCOLOR = vec4(1.0, 1.0, 0.0, 0.0);\nconst vec4 CCCOLOR = vec4(-0.01, -0.3, -0.5, 0.0);\n\nconst vec2 TL = vec2(0.0, 1.0);\nconst vec2 TR = vec2(1.0, 1.0);\nconst vec2 BL = vec2(0.0, 0.0);\nconst vec2 BR = vec2(1.0, 0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ccX = abs(sin(iTime/5.0));\n    float ccY = 0.5 + sin(iTime)/2.0;\n    vec2 CC = vec2(ccX, ccY);\n\n    // current secreen coordinates normalized\n    vec2 cord;  \n    cord.xy = fragCoord.xy / iResolution.xy; \n    \n    // normalized distance to screen vertexes\n    float dTL = distance(cord, TL);\n    float dTR = distance(cord, TR);\n    float dBL = distance(cord, BL);\n    float dBR = distance(cord, BR);\n    float dCC = distance(cord, CC);    \n    \n    float iTL = (dTL == 0.0 ? 1.0 : 1.0/dTL);\n    float iTR = (dTR == 0.0 ? 1.0 : 1.0/dTR);\n    float iBL = (dBL == 0.0 ? 1.0 : 1.0/dBL);\n    float iBR = (dBR == 0.0 ? 1.0 : 1.0/dBR);\n    float iCC = (dCC == 0.0 ? 1.0 : 1.0/dCC);\n    \n    float sum = iTL + iTR + iBL + iBR + iCC;\n    float wTL = (iTL / sum);\n    float wTR = (iTR / sum);\n    float wBL = (iBL / sum);\n    float wBR = (iBR / sum);\n    float wCC = (iCC / sum);\n    \n    vec4 finalColor = \n        (iTL * TLCOLOR *wTL) + \n        (iTR * TRCOLOR *wTR) +\n        (iBL * BLCOLOR *wBL) +\n        (iBR * BRCOLOR *wBR) +\n        (iCC * CCCOLOR *wCC);\n      \n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3GRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[370, 370, 427, 427, 1527]]}
{"id": "4t3GzH", "name": "The Fountain of Dreams", "author": "jameswilddev", "description": "huh", "tags": ["kirby"], "likes": 2, "viewed": 125, "date": "1467837635", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "float computeFountain(vec2 aspectNdc, float yRate, float xRate, float gravity) {\n    return ((aspectNdc.y * yRate) / (aspectNdc.x * xRate)) - (aspectNdc.x * gravity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y);\n    aspectNdc.x += sign(aspectNdc.x) * 0.1;\n    aspectNdc.y += 0.2;\n    float loc = computeFountain(aspectNdc, -100.0, 10.0, 100.0);\n    float loc2 = computeFountain(aspectNdc, -10.0, 100.0, -100.0);\n    float loc3 = loc2 - iTime * sign(aspectNdc.x) * 20.0;\n    float intensity = sin(loc) * sin(loc3 + loc * 0.25);\n\tfragColor = vec4(mix(vec3(0.2, 0.5, 1.0), vec3(0.0, 0.2, 0.6), intensity) * abs(10.0 / (1.0 + loc)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t3GzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 80, 80, 168], [170, 170, 227, 227, 750]]}
{"id": "4tcGRn", "name": "Warp Factor", "author": "jameswilddev", "description": "The twinkling wasn't intentional.", "tags": ["star", "warp", "stars", "trek"], "likes": 11, "viewed": 362, "date": "1467538022", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (fragCoord - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    vec3 lens = normalize(vec3(ndc, 0.05));\n\tvec3 location = lens * 15.0 + vec3(0.0, 0.0, iTime);\n\tvec3 cellId = floor(location);\n\tvec3 relativeToCell = fract(location);\n    vec3 locationOfStarInCell = fract(cross(cellId, vec3(2.154, -6.21, 0.42))) * 0.5 + 0.25;\n\tfloat star = max(0.0, 10.0 * (0.1 - distance(relativeToCell, locationOfStarInCell)));\n\tfragColor = vec4(star, star, star, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tcGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 58, 58, 539]]}
{"id": "4td3D4", "name": "Schlicht circles", "author": "DomDomHaas", "description": "Raytraced Black and white circles with sidewise movement", "tags": ["circles"], "likes": 7, "viewed": 195, "date": "1469304596", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "\nvec3 tempFrace;\n\nfloat map(vec3 p){\n     tempFrace = fract(p) * 2.0 - 1.0;\n\n    return length(tempFrace) - 0.25;\n}\n\nfloat tempTrace;\n\nfloat trace(vec3 origin, vec3 ray){\n\n    tempTrace = 0.0;\n\n    for(int i = 0; i < 32; i++){\n        vec3 point = origin + ray * tempTrace;\n        float d = map(point);\n        tempTrace += d * 1.5;\n    }\n\n    return tempTrace;\n}\n\n\n\nvec3 origin;\nvec3 ray;\nvec2 uv;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    uv = fragCoord.xy / max(iResolution.x,iResolution.y);\n\n    uv = uv * 2.0 - 1.0;\n\n    //uv.x *= iResolution.x / iResolution.y;\n\n    ray = normalize(vec3(uv, 1.0));\n\n    float the = iTime * 0.2;\n    //ray.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    origin = vec3(the, 0, 0);\n\n    float t = trace(origin, ray);\n    \n    //float random = cos(iTime);\n\n    float fog = 1.0 / (-1.0 + t * t * 0.1);\n\n    vec3 fc = vec3(fog);\n\n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4td3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[18, 18, 36, 36, 115], [135, 135, 170, 170, 364], [401, 401, 457, 457, 930]]}
{"id": "4td3R8", "name": "voronoi pattern texture", "author": "KukaTails", "description": "use voronoi noise to generate cellular pattern texture", "tags": ["voronoi"], "likes": 3, "viewed": 152, "date": "1467913064", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "float Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return -1.0 + 2.0 * fract(sin(h) * 4358.5453);\n}\n\n\nfloat Noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\n\nfloat Voronoi(vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2  f = fract(x);\n\n    float res = 8.0;\n    for(int j = -1; j <= 1; ++j)\n        for(int i = -1; i <= 1; ++i) {\n        ivec2 b = ivec2(i, j);\n        vec2  r = vec2(b) - f + 0.4 * sin(iTime + 6.2831 * Noise(vec2(p + b)));\n        float d = dot(r, r);\n        res = min(res, d);\n    }\n    return sqrt(res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float val = sin(Voronoi(10.0 * uv));\n\tfragColor = vec4(sin(val), sin(val) * cos(val), sin(val) + 0.4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4td3R8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 114], [117, 117, 138, 138, 429], [432, 432, 455, 455, 801], [804, 804, 860, 860, 1016]]}
{"id": "4td3RN", "name": "inkmixture", "author": "mr5iveThou5and", "description": "Kind of like some suspended inks being mixed\nsin wave layering idea from: WAHa.06x36", "tags": ["2d", "sin", "sine"], "likes": 16, "viewed": 301, "date": "1468197214", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= float(iResolution.x)/iResolution.y;\n    float t = iTime*2.;    \n\tfloat freq = cos(t*.05)/1.825;\n\tfor(float i=1.;i<75.;i++)  {uv.x += freq/i*cos(i*uv.y+t) +0.494*i;\n                                uv.y += freq/i*sin(i*uv.x+t) -0.458*i;}\n\tfloat bias = abs(sin(uv.y/0.5));\n    vec3 col_a = vec3(1.5, .06, .09);\n    vec3 col_b = vec3(.5, 2., 2.4);\n    vec3 col   = ((col_a*col_a)*bias+(col_b*col_b)*(1.-bias))/2.;\n\tfragColor  = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4td3RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 557]]}
{"id": "4td3WM", "name": "A new way to reflect light v0.1", "author": "Imsure1200q_1UWE130", "description": "This Is Not Really 3D, but the background reflects the light in the ceiling. PLZ WATCH! AND SHARE!!\nYou Can Use This Way To Reflect Light! Good Luck!!! (You May Copy The Code And Add Additional Stuff To It.)", "tags": ["light", "easycode", "reflecting", "threedimensional"], "likes": 3, "viewed": 645, "date": "1469628923", "time_retrieved": "2024-06-20T18:38:17.050927", "image_code": "vec3 firePalette(float i){\n\n    float T = 1400. + 1400.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4,5.6,4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(firePalette((uv.x - uv.y) / (uv.y - clamp(tan(uv.x * 1.0),0.5,1.0)) * sin(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4td3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 348], [350, 350, 407, 407, 557]]}
{"id": "4td3z4", "name": "[SH16B] Super Meat Boy", "author": "mlkn", "description": "Entry for https://www.shadertoy.com/events/competition2016 .\nFor extra speed tweak *playbackTime* param :)", "tags": ["game", "videogame", "sh16b", "supermeatboy"], "likes": 20, "viewed": 600, "date": "1468186596", "time_retrieved": "2024-06-20T18:38:17.057001", "image_code": "#define playbackTime 13.0\n#define speedUpAtTheEnd true\n#define drawMouth true\n#define M_PI 3.141592\n\nvec2 p;\nvec3 v0, v1,\n     color = vec3(0),\n\t diskColor = vec3(0.3, 0.2, 0.6),\n     wallColor = vec3(0.2, 0.6, 0.3),\n     meatColor = vec3(1., 0., 0.),\n     girlColor = vec3(0.9, 0.5, 0.5),\n     eyeColor = vec3(0.),\n     mouthColor = vec3(0.9),\n     lavaColor = vec3(0.5, 0.2, 0.2),\n     stickColor = vec3(0.3),\n     greyColor = vec3(0.15);\n\nfloat t,\n\t  mSize = 0.025,\n      mBotGap = 0.01,\n\t  bBotGap = 0.01,\n\t  slidingWallExtraWidth = 0.003;\n\nfloat dist(vec2 a, vec2 b) {\n\treturn sqrt((b.x-a.x)*(b.x-a.x) + (b.y-a.y)*(b.y-a.y));\n}\n\nvoid drawDisk(vec2 center, float radius, float spikeHeight, float spikeCount, float rotSpeed) {\n    float a, d = dist(center, p);\n    \n    a = atan(p.y - center.y, p.x - center.x) + M_PI; // [0, 2*M_PI]\n    a = spikeCount * a / (2. * M_PI) + t * rotSpeed;\n    a = abs(mod(a, 1.) - 0.5) * 2.;\n    \n    if (d < radius - spikeHeight + spikeHeight*a) color = diskColor;\n    if (d < radius / 4.) color = greyColor;\n\n}\n\nvoid drawStick(vec2 a, vec2 b, float w) {\n    v0 = vec3(b - a, 0.);\n    v1 = vec3(p - a, 0.);\n    float stickLength = length(v0);\n    float distToStick = length(cross(v0, v1)) / length(v0);\n    v0.xy = a + v0.xy/2.;\n    \n    if ((distToStick < w && dist(v0.xy, p) < stickLength / 2.) ||\n        dist(p, a) < w || dist(p, b) < w) color = stickColor;\n}\n\nvoid drawMeatBoy(){\n    \n    float keyTimes[40];\n    keyTimes[0] = 0.0;\n    keyTimes[1] = 0.015;\n    keyTimes[2] = 0.02;\n    keyTimes[3] = 0.04;\n    keyTimes[4] = 0.05;\n    keyTimes[5] = 0.075;\n    keyTimes[6] = 0.08;\n    keyTimes[7] = 0.1;\n    keyTimes[8] = 0.105;\n    keyTimes[9] = 0.135;\n    keyTimes[10] = 0.144;\n    keyTimes[11] = 0.157;\n    keyTimes[12] = 0.163;\n    keyTimes[13] = 0.176;\n    keyTimes[14] = 0.207;\n    keyTimes[15] = 0.218;\n    keyTimes[16] = 0.252;\n    keyTimes[17] = 0.260;\n    keyTimes[18] = 0.278;\n    keyTimes[19] = 0.283;\n    keyTimes[20] = 0.302;\n    keyTimes[21] = 0.325;\n    keyTimes[22] = 0.337;\n    keyTimes[23] = 0.344;\n    keyTimes[24] = 0.395;\n    keyTimes[25] = 0.404;\n    keyTimes[26] = 0.44;\n    keyTimes[27] = 0.45;\n    keyTimes[28] = 0.49;\n    keyTimes[29] = 0.505;\n    keyTimes[30] = 0.517;\n    keyTimes[31] = 0.527;\n    keyTimes[32] = 0.54;\n    keyTimes[33] = 0.55;\n    keyTimes[34] = 0.58;\n    keyTimes[35] = 0.588;\n    keyTimes[36] = 0.595;\n    keyTimes[37] = 0.975;\n    keyTimes[38] = 0.985;\n    keyTimes[39] = 0.995;\n    \n    bool mDrawMouth = drawMouth;\n    vec2 mPos = vec2(0.3, 0.085);\n    float mDir = 0.;\n    float angle = 0.;\n    float rt; // anim time piece in [0, 1]\n\n    if (t < keyTimes[1]) { // [0.2, 0.085]\n        \n        rt = t/keyTimes[1];\n        mPos.x = mix(0.09, 0.2, rt*rt*rt);\n        angle = mix(0., -0.25,  1. - abs(0.5 - rt) / 0.5);\n        mDir = 2.;\n        \n    } \n    if (t > keyTimes[1] && t < keyTimes[2]) { // [0.2, 0.085]\n        \n        mPos.x = 0.2;\n        \n    }\n    if (t > keyTimes[2] && t < keyTimes[3]){ // [0.4, 0.275]\n        \n        rt = (t - keyTimes[2])/(keyTimes[3] - keyTimes[2]);\n        rt = pow(rt, 0.8);\n        mPos.x = mix(0.2, 0.4, rt);\n        mPos.y = 0.2*sin(rt*M_PI/2.) + 0.085;\n        angle = mix(0., -0.25, rt);\n        mDir = 2.;\n        \n    }\n    if (t > keyTimes[3] && t < keyTimes[4]) { // [0.4, 0.18]\n        \n        rt = (t - keyTimes[3])/(keyTimes[4] - keyTimes[3]);\n        mPos.x = 0.4;\n        mPos.y = mix(0.275, 0.18, rt);\n        angle = mix(0.1, 0.25, rt);\n        mDir = -1.;\n        \n    } \n    if (t > keyTimes[4] && t < keyTimes[5]) { // [0.075, 0.32]\n        \n        rt = (t - keyTimes[4])/(keyTimes[5] - keyTimes[4]);\n\t\tmPos.x = mix(0.4, 0.075, rt);\n        mPos.y = -3.4358974359 * mPos.x * mPos.x + \n            1.20128205128 * mPos.x + 0.249230769231;\n        angle = mix(0.25, 0.1, rt);\n        mDir = mix(-1., 0., rt);\n        \n    } \n    if (t > keyTimes[5] && t < keyTimes[6]) { // [0.075, 0.3]\n        \n        rt = (t - keyTimes[5])/(keyTimes[6] - keyTimes[5]);\n        mPos.x = 0.075;\n        mPos.y = mix(0.32, 0.3, rt);\n        angle = -0.15;\n        mDir = 1.;\n    \n    }\n    if (t > keyTimes[6] && t < keyTimes[7]) { // [0.075, 0.45]\n    \n        rt = (t - keyTimes[6])/(keyTimes[7] - keyTimes[6]);\n        mPos.y = mix(0.3, 0.45, rt);\n        mPos.x = -12.5 * mPos.y * mPos.y + 9.375 * mPos.y - 1.6125;\n        mPos.y += mix(0., 0.07, 1. - abs(rt*rt-0.5)/ 0.5);\n        angle = mix(-0.15, 0.15, rt);\n        mDir = rt < 0.4 ? 2. : -1.;\n    \n    }\n    if (t > keyTimes[7] && t < keyTimes[8]) { // [0.075, 0.42]\n        \n        rt = (t - keyTimes[7])/(keyTimes[8] - keyTimes[7]);\n        mPos.x = 0.075;\n        mPos.y = mix(0.45, 0.42, rt);\n        angle = -0.15;\n        mDir = 1.;\n        \n    }\n    if (t > keyTimes[8] && t < keyTimes[9]) { // [0.54, 0.625]\n    \n        rt = (t - keyTimes[8])/(keyTimes[9] - keyTimes[8]);\n    \tmPos.x = mix(0.075, 0.54, rt);\n        mPos.y = -3.33099579243 * mPos.x * mPos.x + 2.4894226274 * mPos.x + 0.252030154278;\n        angle = mix(-0.15, 0.0, rt);\n        mBotGap = mix(mBotGap, mBotGap/3., rt);\n        mDir = mix(1., 2., rt);\n        \n    }\n    if (t > keyTimes[9] && t < keyTimes[10]) { // [0.54, 0.625]\n        \n    \tmPos.x = 0.54;\n        mPos.y = 0.625;\n        angle = 0.4;\n        mBotGap /= 3.;\n    \n    } \n    if (t > keyTimes[10] && t < keyTimes[11]){ // [0.46, 0.59]\n        \n        rt = (t - keyTimes[10])/(keyTimes[11] - keyTimes[10]);\n        rt = pow(rt, 0.85);\n        mPos.x = mix(0.54, 0.46, rt);\n        mPos.y = mix(0.625, 0.59, rt);\n        angle = 0.4;\n        mBotGap /= 3.;\n        mDir = -1.;\n        \n    }\n    if (t > keyTimes[11] && t < keyTimes[12]) { // [0.46, 0.59]\n    \t\n        mPos.x = 0.46;\n        mPos.y = 0.59;\n        angle = 0.4;\n        mBotGap /= 3.;\n    \n    }\n    if (t > keyTimes[12] && t < keyTimes[13]) { // [0.54, 0.625]\n        \n        rt = (t - keyTimes[12])/(keyTimes[13] - keyTimes[12]);\n        rt = pow(rt, 0.85);\n    \tmPos.x = mix(0.46, 0.54, rt);\n        mPos.y = mix(0.59, 0.625, rt);\n        angle = 0.4;\n        mBotGap /= 3.;\n        mDir = 1.;\n        \n    }\n    if (t > keyTimes[13] && t < keyTimes[14]) { // [0.95, 0.75]\n    \n    \trt = (t - keyTimes[13])/(keyTimes[14] - keyTimes[13]);\n    \tmPos.x = mix(0.54, 0.95, rt);\n        mPos.y = -3.51849690746 * mPos.x * mPos.x + 5.54743844089 * mPos.x - 1.34462305987;\n        angle = mix(0.0, -0.25, rt);\n        mBotGap = mix(mBotGap/3., mBotGap, rt);\n        mDir = 2.;\n        \n    }\n    if (t > keyTimes[14] && t < keyTimes[15]) { // [1.05, 0.75]\n        \n        rt = (t - keyTimes[14])/(keyTimes[15] - keyTimes[14]);\n        mPos.x = mix(0.95, 1.05, rt);\n        mPos.y = 0.75;\n        mDir = 1.;\n    \n    }\n    if (t > keyTimes[15] && t < keyTimes[16]) { // [1.45, 0.75]\n        \n        rt = (t - keyTimes[15])/(keyTimes[16] - keyTimes[15]);\n        rt = pow(rt, 0.8);\n        mPos.x = mix(1.05, 1.45, rt);\n        mPos.y = -3.00751879699 * mPos.x * mPos.x + 7.51879699248 * mPos.x - 3.82894736842;\n        angle = mix(0., -0.25,  1. - abs(0.5 - rt) / 0.5);\n        mDir = 2.;\n    \n    }\n    if (t > keyTimes[16] && t < keyTimes[17]) { // [1.52, 0.75]\n        \n        rt = (t - keyTimes[16])/(keyTimes[17] - keyTimes[16]);\n        mPos.x = mix(1.45, 1.52, rt);\n        mPos.y = 0.75;\n        mDir = 1.;\n    \n    }\n    if (t >= keyTimes[17] && t <= keyTimes[18]) { // [1.7, 0.67]\n        \n        rt = (t - keyTimes[17])/(keyTimes[18] - keyTimes[17]);\n        mPos.x = mix(1.52, 1.7, rt);\n        mPos.y = -6.34920634921 * mPos.x * mPos.x + 20. * mPos.x - 14.9807936508;\n        angle = mix(0., -0.25, rt);\n        mDir = 2.;\n    \n    }\n    if (t > keyTimes[18] && t < keyTimes[19]) { // [1.7, 0.64]\n        \n        rt = (t - keyTimes[18])/(keyTimes[19] - keyTimes[18]);\n        mPos.x = 1.7;\n        mPos.y = mix(0.67, 0.64, rt);\n        angle = 0.2;\n        mDir = -1.;\n    \n    }\n    if (t > keyTimes[19] && t < keyTimes[20]) { // [1.5, 0.5]\n        \n        rt = (t - keyTimes[19])/(keyTimes[20] - keyTimes[19]);\n        mPos.x = mix(1.7, 1.5, rt);\n        mPos.y = -4.74747474747 * mPos.x * mPos.x + 15.8919191919 * mPos.x - 12.6560606061;\n        angle = mix(0.2, 0., rt);\n        mDir = -1.;\n    \n    }\n\n    if (t > keyTimes[20] && t < keyTimes[21]) { // [1.25, 0.5]\n\n        rt = (t - keyTimes[20])/(keyTimes[21] - keyTimes[20]);\n        mPos.x = mix(1.5, 1.25, rt);\n        mPos.y = -4.48717948718 * mPos.x * mPos.x + 12.3397435897 * mPos.x - 7.91346153846;\n        angle = mix(0., .2, rt);\n        mDir = -2.;\n\n    }\n    if (t > keyTimes[21] && t < keyTimes[22]) { // [1.12, 0.5]\n\n        rt = (t - keyTimes[21])/(keyTimes[22] - keyTimes[21]);\n        mPos.x = mix(1.25, 1.12, rt);\n        mPos.y = 0.5;\n        angle = mix(0., 0.2,  rt);\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[22] &&  t < keyTimes[23]) { // [1.16, 0.5]\n\n        rt = (t - keyTimes[22])/(keyTimes[23] - keyTimes[22]);\n        mPos.x = mix(1.12, 1.16, rt);\n        mPos.y = 0.5;\n        angle = mix(0., -0.2, rt);\n        mDir = 2.;\n\n    }\n    if (t > keyTimes[23] && t < keyTimes[24]) { // [1.16, 0.5]\n\t\t\n        rt = (t - keyTimes[23])/(keyTimes[24] - keyTimes[23]);\n        mPos.x = 1.16;\n        mPos.y = 0.5;\n        mBotGap = mBotGap + 0.005*sin(rt * 2. * M_PI);\n        mDir = rt < 0.3 || (rt > 0.7 && rt < 0.9) ? -1. : rt < 0.7 ? 1. : 0.;\n\n    }\n    if (t > keyTimes[24] && t < keyTimes[25]) { // [1.13, 0.5]\n\n        rt = (t - keyTimes[24])/(keyTimes[25] - keyTimes[24]);\n        mPos.x = mix(1.16, 1.13, rt);\n        mPos.y = 0.5;\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[25] && t < keyTimes[26]) { // [0.6, 0.37]\n\n        rt = (t - keyTimes[25])/(keyTimes[26] - keyTimes[25]);\n        mPos.x = mix(1.13, 0.6, rt);\n        mPos.y = -2.53628447025 * mPos.x * mPos.x + 4.63305515239 * mPos.x - 1.49677068215;\n        angle = mix(0., 0.25,  1. - abs(0.5 - rt) / 0.5);\n        mDir = -2.;\n\n    } \n    \n\n    if (t > keyTimes[26] && t < keyTimes[27]) { // [0.6, 0.3]\n\n        rt = (t - keyTimes[26])/(keyTimes[27] - keyTimes[26]);\n        mPos.x = 0.6;\n        mPos.y = mix(0.37, 0.3, rt);\n        angle = -0.2;\n        mDir = 1.;\n\n    }\n    if (t > keyTimes[27] && t < keyTimes[28]) { // [1.3, 0.085]\n\n        rt = (t - keyTimes[27])/(keyTimes[28] - keyTimes[27]);\n        mPos.x = mix(0.6, 1.3, rt);\n        mPos.y = -1.49215367965 * mPos.x * mPos.x + 2.5279491342 * mPos.x - 0.679594155844;\n        angle = mix(0., -0.25,  1. - abs(0.5 - rt) / 0.5);\n        mDir = 2.;\n\n    }\n    if (t > keyTimes[28] && t < keyTimes[29]) { // [1.5, 0.085]\n\n        rt = (t - keyTimes[28])/(keyTimes[29] - keyTimes[28]);\n        mPos.x = mix(1.3, 1.5, rt);\n        mPos.y = 0.085;\n        angle = mix(0., -0.25,  1. - abs(0.5 - rt) / 0.5);\n        mDir = 2.;\n\n    }\n    if (t > keyTimes[29] && t < keyTimes[30]) { // [1.5, 0.22]\n\n        rt = (t - keyTimes[29])/(keyTimes[30] - keyTimes[29]);\n        rt = pow(rt, 0.6);\n        mPos.x = 1.5;\n        mPos.y = mix(0.085, 0.23, rt);\n        angle = mix(0., 0.2, rt);\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[30] && t < keyTimes[31]) { // [1.5, 0.2]\n\n        rt = (t - keyTimes[30])/(keyTimes[31] - keyTimes[30]);\n        mPos.x = 1.5;\n        mPos.y = mix(0.23, 0.2, rt);\n        angle = 0.2;\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[31] && t < keyTimes[32]) { // [1.425, 0.3]\n\n        rt = (t - keyTimes[31])/(keyTimes[32] - keyTimes[31]);\n        mPos.x = mix(1.5, 1.425, rt);\n        mPos.y = -14.8148148148 * mPos.x * mPos.x + 42.0 * mPos.x - 29.4666666667;\n        angle = mix(0.2, 0.0, rt);\n        mDir = -2.;\n\n    }\n    if (t > keyTimes[32] && t < keyTimes[33]) { // [1.425, 0.27]\n\n        rt = (t - keyTimes[32])/(keyTimes[33] - keyTimes[32]);\n        mPos.x = 1.425;\n        mPos.y = mix(0.3, 0.27, rt);\n        angle = -0.2;\n        mDir = 1.;\n\n    }\n    if (t > keyTimes[33] && t < keyTimes[34]) { // [1.7, 0.15]\n\n        rt = (t - keyTimes[33])/(keyTimes[34] - keyTimes[33]);\n        mPos.x = mix(1.425, 1.7, rt);\n        mPos.y = -5.28925619835 * mPos.x * mPos.x + 16.0925619835 * mPos.x - 11.9214049587;\n        angle = mix(0., -0.2, 1. - abs(0.5 - rt) / 0.5);\n        mDir = 2.;\n\n    }\n    if (t > keyTimes[34] && t < keyTimes[35]) { // [1.7, 0.085]\n\n        rt = (t - keyTimes[34])/(keyTimes[35] - keyTimes[34]);\n        mPos.x = 1.7;\n        mPos.y = mix(0.15, 0.085, rt);\n        angle = 0.2;\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[35] && t < keyTimes[36]) { // [1.675, 0.085]\n\n        rt = (t - keyTimes[35])/(keyTimes[36] - keyTimes[35]);\n        mPos.x = mix(1.7, 1.675, rt);\n        mPos.y = 0.085;\n        mDir = -1.;\n\n    }\n    if (t > keyTimes[36] && t < keyTimes[37]) { // [1.675, 0.085]\n        \n\t\trt = (t - keyTimes[36])/(keyTimes[37] - keyTimes[36]);\n        mPos.x = 1.675;\n        mPos.x = mix(1.675, 1.61 + 2.*mSize, max(1. - abs(rt-0.9)*10., 0.));\n        if (rt > 0.15 && rt < 0.2) mDir = mix(0., -1., 1. - abs(rt - 0.2)*20.);\n        if (rt > 0.2 && rt < 0.45) mDir = -1.;\n        if (rt > 0.45 && rt < 0.5) mDir = mix(0., -1., 1. - abs(rt - 0.45)*20.);\n        if (rt > 0.85 && rt < 0.95) {\n            mDir = -2.; mDrawMouth = false;\n        }\n        \n\n    }\n    if (t > keyTimes[37] && t < keyTimes[38]) { // [1.9, 0.085]\n\n        rt = (t - keyTimes[37])/(keyTimes[38] - keyTimes[37]);\n        mPos.x = mix(1.7, 1.9, rt);\n        mPos.y = 0.085;\n        mDir = 1.;\n\n    }\n    if (t > keyTimes[38] && t < keyTimes[39]) { // [0.09, 0.085]\n        rt = (t - keyTimes[38])/(keyTimes[39] - keyTimes[38]);\n        mPos.x = mix(0.0, 0.09, rt);\n        mPos.y = 0.085;\n        mDir = 1.;\n    }\n    if (t > keyTimes[39]) { // [0.09, 0.085]\n\n        mPos.x = 0.09;\n        mPos.y = 0.085;\n        mDir = 1.;\n\n    }\n    \n    mPos.y += mSize + mBotGap;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 r = rot*(p - mPos) + mPos;\n    \n    if (r.y < mPos.y + mSize && r.y > mPos.y - mSize &&\n        r.x < mPos.x + mSize && r.x > mPos.x - mSize) {\n        color = meatColor;\n        \n        vec2 eye = mPos + vec2(mDir * mSize/2., mSize/3.);\n    \tvec2 mouth = mPos + vec2(mDir * mSize/2., -mSize/2.2);\n    \n\t\tif (r.y < eye.y + mSize/3. && r.y > eye.y - mSize/3. &&\n        \tabs(r.x-eye.x) > mSize/6. && abs(r.x-eye.x) < mSize/1.2 &&\n           \tr.x < mPos.x + mSize) color = eyeColor;\n    \n    \tif (mDrawMouth && r.y < mouth.y + mSize/6. && r.y > mouth.y - mSize/6. &&\n         \tabs(r.x-eye.x) < mSize/1.5) color = mouthColor;\n    }\n}\n\nvoid drawBandageGirl() {\n    vec2 bPos = vec2(1.61, 0.085);\n    bBotGap += 0.002*sin(t*2.*M_PI*10.);\n    bPos.y += mSize + bBotGap;\n    float bDir = 0.;\n\n    if (t > 0.73 && t < 0.95) bDir = -0.5;\n    if (t > 0.96) bDir = 1.;\n    \n    vec2 eye = bPos + vec2(bDir * mSize/2., mSize/3.);\n    vec2 mouth = bPos + vec2(bDir * mSize/2., -mSize/2.2);\n    \n    if (p.y < bPos.y + mSize && p.y > bPos.y - mSize &&\n        p.x < bPos.x + mSize && p.x > bPos.x - mSize) {\n        \n        color = girlColor;\n    \n        if (p.y < eye.y + mSize/3. && p.y > eye.y - mSize/3. &&\n            abs(p.x-eye.x) > mSize/6. && abs(p.x-eye.x) < mSize/1.2 &&\n               p.x < bPos.x + mSize) color = eyeColor;\n\n        if (drawMouth && p.y < mouth.y + mSize/6. && p.y > mouth.y - mSize/6. &&\n             abs(p.x-eye.x) < mSize/1.5) color = mouthColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    float w = iResolution.x/iResolution.y;\n    vec2 sqCoord = fragCoord.xy/R;\n    p = sqCoord;\n\tp.x *= w; // [0, w/h] x [0, 1]\n\n    t = mod(iTime, playbackTime) / playbackTime; // [0, 1]\n    if (speedUpAtTheEnd) {\n        if (t < 0.8) {\n            t = 0.6*t/0.8;\n        } else if (t < 0.9625) {\n            t = 2.1538461538462 * t - 1.1230769230769;\n        } else {\n            t = (4.*t - 1.)/3.;\n        }\n    }\n    // left disks\n    drawDisk(vec2(0.5, 0.18), 0.075, 0.02, 16., 80.);\n    drawDisk(vec2(0.04, 0.225), 0.075, 0.025, 8., -30.);\n    // right middle disks\n    drawDisk(vec2(1.375, 0.5), 0.06, 0.015, 11., -60.);\n\tdrawDisk(vec2(1.025, 0.5), 0.055, 0.015, 11., 60.);\n    // horizontally moving disk\n    vec2 diskHorL = vec2(1.025, 0.725);\n    vec2 diskHorR = vec2(1.375, 0.725);\n    float diskHorSpeed = 6.;\n    float diskTime = t*diskHorSpeed;\n    diskTime = mod(diskTime, 2.) > 1. ? mod(t*diskHorSpeed, 1.) : 1. - mod(t*diskHorSpeed, 1.);\n    vec2 diskHor = mix(diskHorL, diskHorR, 1.-diskTime);\n    drawDisk(diskHor, 0.14, 0.04, 16., -100.);\n    \n\t//\n    drawMeatBoy();\n    drawBandageGirl();\n\n    // walls\n    if (p.x > 0.4 - slidingWallExtraWidth + mSize &&\n        p.x < 0.6 + slidingWallExtraWidth - mSize &&\n        p.y < 0.56 && p.y > 0.175) color = wallColor;\n\n    if (p.x > 0.47 + mSize &&\n        p.x < 0.6 + slidingWallExtraWidth - mSize &&\n        p.y < 0.6 && p.y > 0.175) color = wallColor;\n\n    if (p.x > 0.4 - slidingWallExtraWidth + mSize && p.x < 0.85) {\n        v0 = vec3(vec2(0.6, 0.62) - vec2(0.35, 0.515), 0.);\n        v1 = vec3(p - vec2(0.35, 0.515), 0.);\n        float pDist = length(cross(v0, v1)) / length(v0);\n        if (pDist < 0.023) color = wallColor;\n    }\n    if (p.x > 0.85  && p.x < 1.55 && p.y > 0.7\n        && p.y < 0.75) color = wallColor;\n\n    if (p.x > 0.94  && p.y > 0.446\n        && p.y < 0.5) color = wallColor;\n\n    if (p.x > 1.35 - slidingWallExtraWidth  && p.x < 1.4 + slidingWallExtraWidth && p.y > 0.2\n        && p.y < 0.45) color = wallColor;\n\n    if (p.x > 1.525 - slidingWallExtraWidth  && p.x < 1.575 + slidingWallExtraWidth\n        && p.y > 0.1 - mSize\n        && p.y < 0.3) color = wallColor;\n    if (p.x > 1.525 && p.y < 0.0825) color = wallColor;\n    \n    // right bottom disks\n    drawDisk(vec2(1.735, 0.475), 0.15, 0.04, 10., 40.);\n    drawDisk(vec2(1.375, 0.22), 0.05, 0.015, 11., -80.);\n    // horizontally moving disk details\n    drawStick(diskHorL, diskHorR, 0.012);\n    if (dist(p, diskHor) < 0.02) color = vec3(0.2, 0.1, 0.2);\n    \n    // outer walls\n    if (p.y < .1 - mSize) color = lavaColor;\n    if (p.x < .05 + slidingWallExtraWidth ||\n       p.x > 1.7 - slidingWallExtraWidth + mSize ||\n       p.y > .95) color = wallColor;\n\n    \n    // disk on stick\n    vec2 stickBinding = vec2(0.5, 0.57);\n    float stickAngle = t*18.*M_PI - 0.2*M_PI;\n    vec2 stickEnd = stickBinding + 0.23*vec2(-cos(stickAngle), sin(stickAngle));\n    drawDisk(stickEnd, 0.11, 0.025, 10., 70.);\n    drawStick(stickBinding, stickEnd, 0.01);\n    \n    // platform\n    vec2 platformSize = vec2(0.25, 0.05);\n    vec2 platformPos = vec2(0.175, 0.06);\n    platformPos.x = mix(0.175, 1.4, 1.- abs(t-0.5)/0.5);\n    if (abs(p.x - platformPos.x) < platformSize.x / 2. &&\n        abs(p.y - platformPos.y) < platformSize.y / 2.) color = wallColor;\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4td3z4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[545, 545, 573, 573, 632], [634, 634, 729, 729, 1046], [1048, 1048, 1089, 1089, 1398], [1400, 1400, 1419, 1419, 14457], [14459, 14459, 14483, 14483, 15302], [15304, 15304, 15361, 15361, 18719]]}
{"id": "4tdGR7", "name": "nVortices", "author": "akohdr", "description": "First attempt creating multiple vortices (currently independent with naive blending)\nThree vortices twist the RGB fields and move together over time.\nMouse split screen shows procedural dot field (left) and noise texture lookup (right)", "tags": ["2d", "vortex"], "likes": 4, "viewed": 191, "date": "1468474183", "time_retrieved": "2024-06-20T18:38:17.408484", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define T (iTime/3.)\n#define R iResolution.xy\n\n#define O clamp(99.-15.*T,.1,99.)\n#define V(a) (vec2(-.8, .8)+a)\n#define PI2_3 (6.28/3.)\n\n#define dotGrid(p,g,r) vec4(1.-length(mod(p,g)-1.5*r)/r)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define ROT_VORTICES\n\nfloat twist(vec2 c, vec2 p, float a)\n{\n//\t    p += sin(a*99.*T) *1./T*3.;\t\t\t\t\t// jiggle\n        vec2 q = p+p-R;\t\t\t\t\t\t\t\t// -R..R\n    \tq -= c;\t\t\t\t\t\t\t\t\t\t// center the twist\n    \n\t    q *= rot(2.*a+T*R.y/length(q));\t\t\t\t// twist (radially decreasing rotation)\n//\t    q *= rot(2.*a+T*R.y/pow(length(q),1./T));\t// dynamic rotation    \n//\t    q *= rot(2.*a+T/pow(length(q),1./T));\t\t// variation dynamic rotation    \n    \n    \treturn\n            p.x<iMouse.x || (p.x<R.x/2.&&iMouse.x<1.) ?\t\n            dotGrid(q, vec2(250),78.+T/15.).x :\t\t// procedural texture (left)\n            texture(iChannel0, q/(R*9.)).x;\t\t// texture noise lookup (right)\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    k = vec4(\n#ifdef ROT_VORTICES\n        twist(O*sin(0.*PI2_3 + T+V(.1)), p, .1),\t// vortices centers spiral in\n        twist(O*sin(1.*PI2_3 + T+V(.2)), p, .2),\n        twist(O*sin(2.*PI2_3 + T+V(.3)), p, .3),\n#else\n        twist(vec2( 0, O), p,.1),\t\t\t\t\t// no spiral\n        twist(vec2( O,-O), p,.2),\n        twist(vec2(-O,-O), p,.3),\n#endif\n        1);\n    \n//\tk *= .5+sin(k+2.*T*PI2_3*vec4(0,1,2,0));\t\t// fade through each field\n//\tk = vec4(sin(k*7.));\t\t\t\t\t\t\t// oil like marbling\n//\tk = .8-vec4(dot(k,sin(vec4(.3,.6,.9,0))))/3.;\t// recombines rgb fields to monochrome\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 394, 432, 481, 1032], [1034, 1034, 1075, 1075, 1648]]}
{"id": "4tdGWN", "name": "Morphing Circle / Star", "author": "antonOTI", "description": "Just a morphing circle", "tags": ["2d", "circle", "noob", "morph"], "likes": 3, "viewed": 554, "date": "1469308951", "time_retrieved": "2024-06-20T18:38:17.656897", "image_code": "#define BRANCHES 5.\n#define BIAS_FACTOR .4\n#define MORPH_FORCE .15\n#define RADIUS .5\n#define SMOOTH .02\n\n#define R_SPEED .05\n#define M_SPEED 1.3\n\n#define PI 3.1415\n#define TPI 6.2831\n\n// http://iquilezles.org/www/articles/palettes/palettes.htm\n// cosine based palette, 4 vec4 params\nvec4 palette( in float t, in vec4 a, in vec4 b, in vec4 c, in vec4 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// http://blog.demofox.org/2012/09/24/bias-and-gain-are-your-friend/\nfloat getBias(float x,float bias)\n{\n  return (x / ((((1.0/bias) - 2.0)*(1.0 - x))+1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(.5);\n        \n    float d = length(uv);\n    \n    float a = ((atan(uv.x,uv.y) + PI) / (TPI)) + iTime * R_SPEED;\n    float t = (sin(iTime * M_SPEED) * .5 + .5);\n    d += getBias((sin(a * TPI * BRANCHES) * .5 + .5),BIAS_FACTOR) * (MORPH_FORCE * t);\n    \n    float f = smoothstep(RADIUS - SMOOTH, RADIUS + SMOOTH, d);\n\n    \n\tfragColor = mix(palette(t*.5,vec4(.9,.9,1.5, 1.),vec4(.5,.5,.5, 1.),vec4(1.,1.,.5, 1.),vec4(.8,.9,.3, 1.)),vec4(0.),f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[184, 283, 355, 355, 398], [400, 469, 504, 504, 559], [561, 561, 618, 618, 1108]]}
{"id": "4tdGzr", "name": "Explosion Sample", "author": "qq456cvb", "description": "My implementation on GPU Pro 6's volumetric explosions. Further improvements can be done by adding lighting and anti-aliasing.", "tags": ["3d", "explosion", "particle"], "likes": 10, "viewed": 524, "date": "1467704340", "time_retrieved": "2024-06-20T18:38:17.656897", "image_code": "#define time iTime\n#define OCTAVE 4\n#define EPSILON 0.01\n#define PI 3.1415926\n\n// TODO: add anti-aliasing and lighting\nvec4 colorLookup(in float x)\n{\n\tconst vec4 yellow = vec4(1., 1., 0., 1.);\n    const vec4 red = vec4(1., 0., 0., 1.);\n    const vec4 black = vec4(vec3(0.), 1.);\n    const vec4 white = vec4(1.);\n    const vec3 bound = vec3(0.06, 0.11, 0.15);\n    x /= 5.;\n    if (x < bound.z) {\n        if (x < bound.x) {\n            return mix(white, yellow, x * 1. / bound.x);\n        }\n        if (x < bound.y) {\n            return mix(yellow, red, (x-bound.x) * 1./ (bound.y-bound.x));\n        }\n        return mix(red, black, (x-bound.y) / (bound.z-bound.y));\n    } else {\n        return black;\n    }\n}\n\nfloat noise( in float x ){return texture(iChannel0, vec2(x*.01,1.)).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\n//iq's ubiquitous 3d noise\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat fractalNoise(in vec3 p)\n{\n    const float amplitudeFactor = 0.5;\n  \tconst float frequencyFactor = 2.03;\n  \tfloat amplitude = 0.5;\n    float noiseValue = 0.;\n    for (int i = 0; i < OCTAVE; i++)\n    {\n        noiseValue += amplitude * noise(p / 30.);\n        amplitude *= amplitudeFactor;\n        p *= frequencyFactor;\n    }\n    return noiseValue;\n}\n\nfloat drawExplosion(in vec3 p, \n                    in float displacement, \n                    in vec3 spherePos,\n                    in float radius, \n                    out float displacementOut)\n{\n    displacementOut = fractalNoise(p);\n    \n    // dist to sphere surface\n    float dist = length(p - spherePos) - radius;\n    dist += displacementOut * displacement;\n    return dist;\n}\n\nbool sphereTracing(in vec3 origin, \n                   in float displacement, \n                   in vec3 spherePos,\n                   in float radius, \n                   in vec3 dir,\n                   inout vec3 hitPoint,\n                   inout vec4 color)\n{\n    const int steps = 20;\n    float dist = 0.;\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 p = origin + dist*dir;\n        float displacementOut;\n        float distToSurface = drawExplosion(p, displacement, spherePos, radius, displacementOut);\n        if (distToSurface < EPSILON)\n        {\n            hitPoint = p;\n            color = colorLookup(displacementOut);\n        }\n        dist += distToSurface;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor = vec4(vec3(0.), 1.0);\n    \n    float t = mod(time, 3.) / 3.;\n    t = t*t*(3.-2.*t);\n    float displacement = t * 40.;\n    vec3 spherePos = vec3(0, 0, 200.);\n    \n    vec3 hitPoint = vec3(0.);\n    vec3 origin = vec3(0.);\n    float radius = displacement * 3.;\n    vec3 dir = normalize(vec3(uv, 1.0));\n    sphereTracing(origin, displacement, spherePos, radius, dir, hitPoint, fragColor);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tdGzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[79, 119, 149, 149, 707], [709, 709, 735, 735, 780], [782, 782, 804, 804, 837], [839, 866, 890, 890, 1099], [1101, 1101, 1132, 1132, 1455], [1457, 1457, 1658, 1658, 1844], [1846, 1846, 2110, 2110, 2554], [2556, 2556, 2613, 2613, 3128]]}
{"id": "4tt3D4", "name": "velvet overground", "author": "tomaes", "description": "wanted to do something with chains.", "tags": ["2d", "simple", "style"], "likes": 1, "viewed": 122, "date": "1469302898", "time_retrieved": "2024-06-20T18:38:17.656897", "image_code": "void mainImage( out vec4 c, in vec2 fc )\n{\n    float t = iTime + .99;\n\tvec2 uv = fc.xy / iResolution.y;\n\n    uv *= 1.5 - sin(t + sqrt(uv.y+uv.x))*.15;\n    uv.y -= .25;\n    \n    c = vec4(.3 + mod(tan(uv.x*5.+t)*.1 + cos(uv.y*5.+t)*.1,.1), .0, .2, 1. );\n    c *= length(uv.y+.6);\n    \n    // chains.. unchained. ;)\n    for(float f =.0; f < 3.; f +=.08)\n    {\n        float o = sin(t+f*8.)*.3;\n        \n        if (distance(vec2(f,.5+sin(t*2.5+uv.x*5.8)*.2 ),uv)  > .14+o && \n            distance(vec2(f,.5+sin(t*1.9+uv.x*6.0)*.2 ),uv)  < .17+o) \n            c *= .2*vec4(uv.x*uv.y, uv.x, .1-uv.x, 1.) - mod( sqrt(uv.x+uv.y),7.5)*.8;\n\n        if (distance(vec2(f,.5+sin(t*2.5+uv.x*5.8)*.2 ),uv)  > .38-uv.x*.1 &&\n            distance(vec2(f,.5+sin(t*2.5+uv.x*5.8)*.2 ),uv)  < .40-uv.x*.1)          \n            c.g -= uv.y;\n\t\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 42, 42, 834]]}
{"id": "4tt3D7", "name": "Spiral hypnosis", "author": "kyl3r", "description": "Some fun with sine, distance and angle (of those pixels, relative to the center)", "tags": ["spiral", "color", "rotating"], "likes": 0, "viewed": 91, "date": "1469696337", "time_retrieved": "2024-06-20T18:38:17.656897", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = fragCoord.x - iResolution.x/2.0;\n    float b = fragCoord.y - iResolution.y/2.0;\n    float distance = sqrt(a*a + b*b);\n    float angle = atan(a, b);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(-iTime*6.0+distance/6.0)+sin(iTime)+sin(angle*10.0+iTime+distance/15.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 379]]}
{"id": "4tt3Dn", "name": "Generalized Mandelbrot: distance", "author": "Tup", "description": "Based on inigo quilez's Mandelbrot - distance\nhttps://www.shadertoy.com/view/lsX3W4\nSimilar to coyote's Generalized Mandelbrot, but with smooth distance function.\nhttps://www.shadertoy.com/view/4ddSWf", "tags": ["2d", "fractal", "mandelbrot", "distance"], "likes": 13, "viewed": 5172, "date": "1468762909", "time_retrieved": "2024-06-20T18:38:18.166033", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader computes the distance to the Mandelbrot Set for everypixel, and colorizes\n// it accoringly.\n// \n// Z -> ZÂ²+c, Z0 = 0. \n// therefore Z' -> 2Â·ZÂ·Z' + 1\n//\n// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n// G'(c) = Z'/Z/2^n\n//\n// So the distance is |G(c)|/|G'(c)| = |Z|Â·log|Z|/|Z'|\n//\n// More info here: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\n\n// contribution by Jason Wilkins - Tup/2016 - Generalized Mandelbrot and distance function\n\n\nvec2 cpow(vec2 c, float exponent)\n{\n    if (abs(c.x) < 1e-5 && abs(c.y) < 1e-5) {\n        return vec2(0,0);\n    }\n    else {\n        float cAbs = length(c);\n        vec2  cLog = vec2(log(cAbs), atan(c.y,c.x));\n        vec2  cMul = exponent*cLog;\n        float expReal = exp(cMul.x);\n        return vec2(expReal*cos(cMul.y), expReal*sin(cMul.y));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat n = 4.0 - 2.0*cos(0.225*iTime);\n    float zoo = 1.25;//pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(.0,.0) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) break;\n        \n\t\t// Z' -> nÂ·Z^(n-1)Â·Z' + 1\n        vec2 chain = n*cpow(z,n-1.0);\n        dz = mat2(chain,-chain.y,chain.x) * dz + vec2(1,0);\n        //dz = vec2(chain.x*dz.x-chain.y*dz.y, chain.x*dz.y + chain.y*dz.x) + vec2(1.0,0.0);\n        \n        // Z -> Z^n + c\t\t\t\n        z = cpow(z, n) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(m2/dot(dz,dz))*log(m2);\n\n\t\n    // do some soft coloring based on distance\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    vec3 col = vec3( d );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[540, 633, 668, 668, 986], [988, 988, 1045, 1045, 2025]]}
{"id": "4tt3RH", "name": "Glowing Particles", "author": "Dalton", "description": "Messed around a bit with some audio input as well. To activate it, uncomment the MUSIC #define and select a song for Channel0. Depending on the song, you may have to turn the glow down.", "tags": ["sound", "particles", "glow"], "likes": 19, "viewed": 1527, "date": "1467945337", "time_retrieved": "2024-06-20T18:38:18.166033", "image_code": "#define NUM_PARTICLES 45.0\n#define GLOW 0.5\n#define TIME_SKIP 0.0\n#define SPEED_UP 1.15\n//#define MUSIC\n\nvec3 Orb(vec2 uv, vec3 color, float radius, float offset)\n{        \n    vec2 position = vec2(sin((1.9 + offset * 4.9) * ((iTime * SPEED_UP) + TIME_SKIP)),\n                         cos((2.2 + offset * 4.5) * ((iTime * SPEED_UP) + TIME_SKIP)));\n    \n    position *= ((sin(((iTime * SPEED_UP) + TIME_SKIP) - offset) + 7.0) * 0.1) * sin(offset);\n    \n    radius = ((radius * offset) + 0.005);\n    float dist = radius / distance(uv, position);\n    return color * pow(dist, 1.0 / GLOW);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel = vec3(0.0, 0.0, 0.0);\n   \tvec3 color = vec3(0.0, 0.0, 0.0);\n    \n \tcolor.r = ((sin(((iTime * SPEED_UP) + TIME_SKIP) * 0.25) + 1.5) * 0.4); // 0.2 - 1.0\n    color.g = ((sin(((iTime * SPEED_UP) + TIME_SKIP) * 0.34) + 2.0) * 0.4); // 0.4 - 1.2\n    color.b = ((sin(((iTime * SPEED_UP) + TIME_SKIP) * 0.71) + 4.5) * 0.2); // 0.7 - 1.1\n    \n    float radius = 0.045;\n    \n#ifdef MUSIC\n    float beat[4];\n    beat[0] = texture( iChannel0, vec2(0.10 ,0.25) ).x;\n    beat[1] = texture( iChannel0, vec2(0.25 ,0.25) ).x;\n    beat[2] = texture( iChannel0, vec2(0.40 ,0.25) ).x;\n    beat[3] = texture( iChannel0, vec2(0.55 ,0.25) ).x;\n    \n    beat[0] = (beat[0] + beat[1] + beat[2] + beat[3]) * 0.25;\n    radius += beat[0] / 8.0;    \n#endif\n    \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++)\n        pixel += Orb(uv, color, radius, i / NUM_PARTICLES);\n\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3RH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[88, 105, 164, 164, 587], [589, 589, 646, 646, 1630]]}
{"id": "4tt3Wr", "name": "test-robert-meme001", "author": "kaptenrobert", "description": "test", "tags": ["meme"], "likes": 1, "viewed": 84, "date": "1468779320", "time_retrieved": "2024-06-20T18:38:18.166033", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float wave = 0.5*sin(uv.x*4.0+iTime*2.0)+0.5;\n    vec4 bgColor1 = vec4(uv,0.1+0.5*sin(iTime),1.0);\n    vec4 bgColor2 = vec4(0.1+0.5*sin(iTime),uv,1.0);\n    float smooths = smoothstep(wave+0.01,wave-0.01,uv.y);\n    fragColor = mix(bgColor1, bgColor2, smooths);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tt3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 366]]}
{"id": "4ttGR4", "name": "TestNoise_1", "author": "baldbyte", "description": "noise test", "tags": ["noise"], "likes": 0, "viewed": 131, "date": "1468168328", "time_retrieved": "2024-06-20T18:38:19.669182", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat simplexNoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod289(floor(P));\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod7(floor(p*K))*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\n\nvec2 cellular3d(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    //vec2 uv = p*1.0 ;\n\t\n    float dim = 64.0;\n\tp = ceil(p * 1024.0) / 1024.0;\n    p = p*10.0  + sin(iTime + p.x * 22.0 + p.y  * 2.0);\n    //p.x = p.x * 10.0 + sin(p.x + iTime + p.y);\n    //p.y = p.y * 10.0 + sin(iTime + p.x);\n\n\t//Noise bands\n\tvec2 noiseValue = vec2(p.x + iTime , p.y);\n   \n\tfloat randomValue = simplexNoise(noiseValue); //Value between -1 - 1\n    vec2 randomCellular = cellular(noiseValue);\n    vec2 randomCellular3d = cellular3d(vec3(noiseValue.x, noiseValue.y, iTime / 5.0));\n    /*\n    //randomValue =  (randomValue + 1.0) / 2.0;//Value between 0 - 1\n\trandomValue /= 64.0;\n    \n    \n    if(distance(uv,vec2(0.5,0.5)) < 0.5){\n        uv = vec2(uv.x + randomCellular.x, uv.y + randomCellular.y);\n    }\n    \n    vec3 colA = texture( iChannel0, fragCoord.xy / iResolution.xy ).xyz;\n    */\n    \n    \n    fragColor = vec4(randomCellular3d.x,0.0,0.0 , 1.0 );\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[44, 44, 65, 65, 114], [116, 116, 137, 137, 186], [188, 188, 210, 210, 247], [249, 249, 276, 276, 1782], [1784, 1815, 1834, 1834, 1879], [1882, 1988, 2011, 2011, 3529], [3532, 3532, 3557, 3557, 8364], [8367, 8367, 8424, 8424, 9344]]}
{"id": "4ttGWM", "name": "301's Fire Shader - Remix 3", "author": "mu6k", "description": "Sorry, I couln't resist :P. This is another take on the plasma-fire effect. Original code by CaliCoastReplay and 301.", "tags": ["flame", "fire", "blaze"], "likes": 135, "viewed": 10367, "date": "1469618650", "time_retrieved": "2024-06-20T18:38:20.033006", "image_code": "// I started working a bit on the colors of Remix 2, ended up with something like this. :)\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 258, 278, 278, 352], [354, 354, 375, 375, 581], [583, 583, 602, 602, 787], [789, 789, 846, 846, 2375]]}
{"id": "4ttGzN", "name": "Better UV Mapping", "author": "vox", "description": "Better UV Mapping", "tags": ["betteruvmapping"], "likes": 14, "viewed": 1556, "date": "1468202401", "time_retrieved": "2024-06-20T18:38:21.487662", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0/GR)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n\n//-----------------AUDIO ALGORITHM-----------------\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n\nfloat simplex3d(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n    \n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    \n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    \n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    \n    vec4 w, d;\n    \n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    \n    w = max(0.6 - w, 0.0);\n    \n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    \n    w *= w;\n    w *= w;\n    d *= w;\n    \n    return dot(d, vec4(52.0));\n}\n\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time/GR), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    final *= 2.0;\n    final -= .25;\n    \n\tfinal = sqrt(clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 numerator = cmul(uv, multa) + offa;\n    vec2 denominator = cmul(uv, multb) + offb;\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = (cdiv(numerator, denominator));\n    \n    for(int i = 0 ; i < 4; i++)\n    {\n        numerator = cmul(uv, multa) + offa+sin(vec2(float(i)-time*GR, -float(i)+time));\n        quotient += (cdiv(numerator, quotient));\n    }\n    \n    \n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    seedling = (floor(quotient.x)*3.0+floor(quotient.y));\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    uv += offset;\n    \n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    return final;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = E;\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI*4.0);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI*4.0);\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI*4.0);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI*4.0);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv0, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n        \n        antispeckle = stretch;\n\n        stretch = smoothstep(0.0, 1.0/PI/GR, stretch);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(seedling*PI)*stretch;\n\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        \n        color = clamp(color + galaxy((p.xy)*2.0-1.0)*draw*skip+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n\n    color += stars(uv0*2.0-1.0);\n    \n    fragColor = texture(iChannel0, uv*12.0);\n\n    vec2 o = 0.0*vec2(cos(time), sin(time));\n\n    //fragColor = vec4(everything(uv*2.0-1.0, o).a);\n    //fragColor = everything(uv*2.0-1.0, o);\n\n    fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = vec4(saw(seedling));\n    \n    antispeckle = clamp(pow(antispeckle, 1.0/float(max_iterations))*4.0, 0.0, 1.0);\n    antispeckle = smoothstep(0.0, 10.0/MAX_DIM, antispeckle);\n    \n    fragColor = vec4(length(saw(color*10.0*PI)))*antispeckle;\n    fragColor = vec4(color)*antispeckle;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ttGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1113, 1166, 1186, 1186, 1564], [1566, 1621, 1643, 1643, 1840], [1843, 1843, 1868, 1868, 2599], [2601, 2725, 2746, 2746, 3109], [3111, 3111, 3133, 3133, 4041], [4043, 4106, 4135, 4135, 4205], [4207, 4207, 4236, 4236, 4320], [4322, 4322, 4390, 4390, 5154], [5156, 5218, 5323, 5323, 6015], [6021, 6021, 6078, 6078, 8203]]}
{"id": "ldKSDd", "name": "Weird Tunnel", "author": "aiekick", "description": "ALIVE ! HE IS ALIVE ! (with time :))", "tags": ["tunnel", "sss", "weird"], "likes": 21, "viewed": 2484, "date": "1467506195", "time_retrieved": "2024-06-20T18:38:22.633073", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 m;\n\nmat3 RotX(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 RotY(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat pattern(vec3 p)\n{\n\tp = fract(p) - 0.5;\n\treturn (min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.56);\n}\n\nfloat getTime(float t)\n{\n\treturn sin(iTime*t*0.001) * 0.5 + 0.5;\n}\n\nvec3 effect(vec3 p) \n{\n\tfloat d = min(pattern(p*m), pattern(p*m*m));\n    return vec3(d/0.78); \n}\n\nfloat hash(float n){ return fract(cos(n)*76543.);}\nvec3 hash3(vec3 p){return normalize(vec3(hash(p.x), hash(p.y), hash(p.z)));}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nvec2 df(vec3 p)\n{\n\tvec3 col = 1.-clamp(effect(p*0.24),0.,1.);\n\t\n   \tfloat d0 = dot(col,vec3(2.95));\n\tfloat d1 = dot(col,vec3(2.05));\n\n\tp.xy -= path(p.z);\n\t\n\tfloat l = dot(p.xy,p.xy)*0.1;// main tunnel \n\tfloat y = max(1.743 + l, 3.102 - l) - d0; // wire\n\tfloat y2 = max(-10. + l, 2.2 - l) + d1 + -2.92; // blocs\n\tfloat y3 = length(p.xy)-2.4; // middle tunnel for remove tunnel middle artefact\n\tvec2 res = vec2(max(-y3, y) , 1.);\n\tif ( y2 < y) res = vec2(max(-y3, y2) , 2.);\n\treturn res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.2);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(80.*sb+320.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, p, n, 0.019);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.23; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff + fre + bb * sb * 0.8 + sss * 0.4) * amb * li + spe * 0.6 \t\n    );\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3. + 100.;\n     \n    mat3 mx = RotX(12.74*getTime(0.1));\n    mat3 my = RotY(5.3*getTime(0.4));\n    mat3 mz = RotZ(0.78*getTime(.7));\n    m = mx*my*mz;\n    \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n    \n    vec3 col = vec3(0.);\n    \n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t+0.1),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 20.;\n    float s = 1.;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.002*log(d*d)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * (s>0.1?0.15:0.1);\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\t\t\n\t\tfloat material = df(p).y;\n\t\t\n\t\tif (material == 1.) // wires\n\t\t{\n\t\t\tcol = shade(ro, rd, d, vec3(path(p.z),t+3.2), 0.6).x * vec3(1,0.39,0) * 5.4;\n\t\t}\n\t\telse if (material == 2.) // blocs\n\t\t{\n\t\t\tcol += shade(ro, rd, d, vec3(path(p.z),t+3.2), 1.2).yzw;\n\t\t}\n\t\t\n\t\tcol = mix(col, vec3(0), 1.-exp(-0.02*d*d));\n\t}\n\t\n\tfragColor.rgb = col;\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKSDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 223, 242, 242, 300], [301, 301, 320, 320, 378], [379, 379, 398, 398, 456], [458, 458, 481, 481, 561], [563, 563, 587, 587, 629], [631, 631, 653, 653, 727], [729, 729, 749, 749, 779], [780, 780, 799, 799, 856], [858, 858, 878, 878, 923], [925, 925, 942, 942, 1412], [1414, 1414, 1451, 1451, 1663], [1665, 1886, 1914, 1914, 2239], [2241, 2323, 2380, 2380, 2606], [2608, 2608, 2644, 2644, 2779], [2781, 2957, 3007, 3007, 3192], [3194, 3403, 3465, 3465, 3975], [3977, 3977, 4035, 4035, 4915], [4917, 4917, 4963, 4963, 5132], [5134, 5134, 5191, 5191, 6180]]}
{"id": "ll33R7", "name": "Britney Cartoon Shader", "author": "roopeshkom", "description": "This is my first ever shader... I think I might be addicted to this :D", "tags": ["cartoon", "fun", "britney"], "likes": 5, "viewed": 354, "date": "1468375612", "time_retrieved": "2024-06-20T18:38:22.633073", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n\tvec4 ogColor = texture(iChannel0, uv);\n    vec4 texColor = ogColor;\n    \n    if(texColor.r + texColor.g + texColor.b >= 1.0)\n    {\n\t\ttexColor = vec4(1,1,1,1);\n    }\n    else\n    {\n        texColor = vec4(0,0,0,1);\n    }\n\ttexColor.b = (uv.x+uv.y)/2.0;\n\n    \n    float multiplier = abs(sin(iTime));\n    vec4 blend = (((multiplier)*(texColor)) + (.5*(1.0-multiplier)*(ogColor)))/2.0;\n\t\n    fragColor = blend;\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 537]]}
{"id": "ll33RM", "name": "Science or Die", "author": "vox", "description": "No thanks to shadertoy.", "tags": ["scienceordie"], "likes": 1, "viewed": 460, "date": "1468340570", "time_retrieved": "2024-06-20T18:38:25.203061", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n#define MATRIX_W (floor(MAX_DIM/75.0))\n#define MATRIX_H (floor(MAX_DIM/75.0))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/GR/PI)*iTime+1000.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define zero(x) (smoothstep(-1.0/GR/PI/E, 1.0/GR/PI/E, x))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch;\nvec2 targetResolution = vec2(512.0);\n\n\n//-----------------AUDIO ALGORITHM-----------------\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n//-----------------BASE IMAGE--------------------------\n\n#define R(r)  fract( 4e4 * sin(2e3 * r) )  // random uniform [0,1[\nvec4 stars(vec2 uv)\n{\n    vec4 stars = vec4(0.0);\n    for (float i = 0.; i < 32.0; i ++)\n    {\n        float r = R(i)/ 256.0         // pos = pos(0)  +  velocity   *  t   ( modulo, to fit screen )\n        / length( saw( R(i+vec2(.1,.2)) + (R(i+vec2(.3,.5))-.5) * time ) \n                 - saw(uv) );\n        stars += r*vec4(flux(r*PI+i), 1.0);\n    }\n    \n    return stars-1.0/16.0;\n}\n\nvec4 galaxy(vec2 uv)\n{\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime*PI*2.0;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux((seedling*GR+1.0/GR)*time/GR), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    final *= 2.0;\n    final -= .25;\n    \n\tfinal = sqrt(clamp(final, 0.0, 1.0));\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 numerator = cmul(uv, multa) + offa;\n    vec2 denominator = cmul(uv, multb) + offb;\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = (cdiv(numerator, denominator));\n    \n    for(int i = 0 ; i < 4; i++)\n    {\n        numerator = cmul(uv, multa) + offa+sin(vec2(float(i)-time*GR, -float(i)+time));\n        quotient += (cdiv(numerator, quotient));\n    }\n    \n    \n    \n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    stretch = denom/numer;\n    \n    seedling = (floor(quotient.x)*3.0+floor(quotient.y));\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius(a, multa, offa, multb, offb);\n    vec2 mb = mobius(b, multa, offa, multb, offb);\n    vec2 mc = mobius(c, multa, offa, multb, offb);\n    vec2 md = mobius(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n    magnification = stretch;\n    \n    vec2 final = mobius(uv, multa, offa, multb, offb);\n    \n    return final;\n}\n    \n\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*(7.0+saw(time)))/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))*.25+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return vec3(clamp(eyes+teeth, 0.0, 1.0));\n}\n\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\nvec4 fire(vec2 p)\n{\n    p.x *= 1.0/E/GR;\n    p.y *= PI/GR;\n    float tempX = (p.y+.5)*cos(p.x*4.0*PI+time)*2.0;\n    float tempY = (p.y+.5)*sin(p.x*4.0*PI+time)*2.0;\n\n    p.x = tempX;\n    p.y = tempY;\n\n\n    p.x += .5*snoise(vec2(time*.6+256.0, p.y));\n    p.y += .5*snoise(vec2(time*.6+500.0, p.x));\t\n\n    float x_max = 0.56999993;\n    float y_max = 0.74999976;\n\n    float R = x_max;\n    float r = .1;\n\n    float x = snoise(vec2(time*.6+256.0, p.y))*.25+.875;\n    float y = snoise(vec2(time*.6+256.0, p.x))*.25-.625;\n\n    vec4 c = vec4(x, y, 0.0, 0.0);\n\n    vec2 Z = p*vec2(.85,1.0);\n    int iterations_temp;\n    const float max_iterations =6.0;\n    float depth_trap = 4500.0;\n    for(int iterations=0; iterations < int(max_iterations); iterations++) \n    {\n        Z = c.xy + cmul(Z.xy, vec2(tanh(Z.x), tanh(Z.y)));\n\n        if(dot(Z,Z)>depth_trap) {\n            break;\n        }\n        iterations_temp = iterations;\n    }\n\n    float NIC = (Z.x * Z.x) + (Z.y * Z.y);\n    NIC = float(iterations_temp)/max_iterations-log(sqrt(NIC))/float(iterations_temp);\n    float red = clamp(sin(NIC)+.25, 0.0, 1.0);//red*3.0/4.0);\n    float green = clamp(sin(NIC)*sin(NIC), 0.0, red*3.0/5.0);\n\n    /*\nint temp = int(p.x*64.0);\nfor(int i = 0; i < 64 i++)\nif(i == temp)\ngreen = Frequency[int(i)];\n*/\t\n\n    //if(red -green > 0.79) return texture(Frequency, vec2(p.x, p.y)).rgba;\n    return vec4(red, green , 0.0, 0.0);\n\n    /*\n//3-phase flux of 3 different coloring patterns\nreturn vec4(red, green, blue, 0.0) * clamp(sin(time*5.0+0.0), 0.0, 1.0)\n+ vec4(green, red, green, 0.0) * clamp(sin(time*5.0+4.0*PI/3.0), 0.0, 1.0)\n+ vec4(green, green, red, 0.0) * clamp(sin(time*5.0+2.0*PI/3.0), 0.0, 1.0);\n*/\n}\n\nvec3 scienceordie(vec2 uv)\n{\n    \n    float scale = E/GR;\n    uv = uv*scale-scale/2.0;\n    //uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), sin(time*PI)).xy;\n    //uv += cos(vec2(time*PI, time*GR*PI))/GR/PI;\n    uv.y -= .1/GR;\n    float depth = demon(uv).r;\n    float angle =  depth*PI+time;\n    \n    //uv.xy += depth*vec2(cos(angle), sin(angle))/MATRIX_W;\n    \n    vec2 mymathisbetterthanyours = fract(uv*vec2(MATRIX_W,MATRIX_H));\n    vec2 bitch = floor(uv*vec2(MATRIX_W,MATRIX_H));\n    float number = (mod(time*sin(bitch.x+bitch.y*MATRIX_W), 10.0));\n    float digit = SampleDigit(number, GR*mymathisbetterthanyours);\n    \n    \n    vec3 body = smoothstep(0.0, 1.0/GR, smoothstep(0.0, 1.0/GR*E/PI, sqrt(clamp(1.0-length(uv*vec2(1.0, 1.0/GR)*GR), 0.0, 1.0)))*demon(uv*1.125));\n    \n    vec3 science = vec3(0.0, digit, 0.0)*(1.0-body)+body;\n\tfloat or = zero(-uv.x);\n    \n    vec4 die = clamp(fire(uv), 0.0, 1.0);\n    \n    vec3 scene = science*or+(1.0-body)*(1.0-or)*die.rgb;;//+(1.0-or)*body*flux(time+body.r*PI*2.0);\n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    targetResolution = vec2(512.0);\n    uv = (uv*2.0-1.0);\n    uv.x *= targetResolution.x/targetResolution.y;\n    vec2 uv0 = uv*iResolution.xy/targetResolution.xy*.5+.5;\n    \n    uv = uv0;\n    \n    fragColor.rgb = scienceordie(uv)\n        *smoothstep(0.0, 30.0/MAX_DIM, 1.0-abs(uv.x*2.0-1.0))\n        *smoothstep(0.0, 30.0/MAX_DIM, 1.0-abs(uv.y*2.0-1.0));\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33RM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1175, 1228, 1248, 1248, 1626], [1628, 1683, 1704, 1704, 1755], [1757, 1757, 1778, 1778, 1829], [1831, 1831, 1853, 1853, 1892], [1894, 1894, 1916, 1916, 3522], [3524, 3524, 3545, 3545, 3596], [3598, 3598, 3620, 3620, 3659], [3661, 3661, 3689, 3689, 3743], [3745, 3745, 3767, 3767, 6025], [6026, 6150, 6171, 6171, 6534], [6536, 6536, 6558, 6558, 7466], [7468, 7531, 7560, 7560, 7630], [7632, 7632, 7661, 7661, 7745], [7747, 7747, 7815, 7815, 8579], [8581, 8643, 8748, 8748, 9417], [9424, 9424, 9448, 9448, 9912], [9914, 9914, 9939, 9939, 10241], [10243, 10243, 10264, 10264, 10379], [10482, 10482, 10543, 10543, 12284], [12286, 12286, 12305, 12305, 13970], [13972, 13972, 14000, 14000, 15013], [15015, 15015, 15072, 15072, 15498]]}
{"id": "ll33RN", "name": "Necromurlok - Noise", "author": "Necromurlok", "description": "Noise", "tags": ["noise"], "likes": 12, "viewed": 189, "date": "1468153353", "time_retrieved": "2024-06-20T18:38:25.748464", "image_code": "\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n//    return fract((sin(h)*43758.5453123)  + iTime);\n    return fract((sin(h)*43758.5453123));\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*0.5 + 0.5; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    float r = max(d.y/1.2 - d.x*1., 0.)/1.2;\n    return r;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.xx;\n//    uv *= pow(1.0 - dot(uv, uv), 2.0);\n    float n = pow(1.0 - dot(uv, uv), 2.0); //noise(uv * 200.0);\n//    float i = 1.0;\n\n    fragColor -= fragColor;\n    \n    for (float i = 1.0; i < 5.0; i+=1.0) {\n        float s = sin(iTime * (0.13 * i));\n        float c = cos(iTime * (0.13 * i));\n        mat2 m = mat2(s, c, c, -s);\n        vec2 uv2 = uv * m;\n/*        fragColor += vec4(vec3(step(0.15, noise(uv2 * 140.0)),\n                               step(0.15, noise(uv2 * 141.0)),\n                               step(0.15, noise(uv2 * 142.0))),\n                               1.0);*/\n/*        fragColor += vec4(vec3(step(0.015, Voronoi(uv2 * 20.0)),\n                               step(0.015, Voronoi(uv2 * 21.0)),\n                               step(0.015, Voronoi(uv2 * 22.0))),\n                          1.0);*/\n        vec3 v = vec3(Voronoi(uv2 * 20. * (i * 0.25)), Voronoi(uv2 * 21. * (i * 0.25)), Voronoi(uv2 * 22. * (i * 0.25))) - .0015;\n        fragColor += vec4(smoothstep(vec3(0.01), fwidth(v), v), 1.);        \n    }\n    fragColor /= 5.0;\n    fragColor *= n;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 23, 23, 158], [159, 159, 185, 185, 486], [490, 512, 533, 882, 1086], [1088, 1290, 1315, 1315, 2028], [2032, 2032, 2089, 2089, 3228]]}
{"id": "ll33W8", "name": "Displacement Mapping Test", "author": "geoff", "description": "A displacement mapped double helix.", "tags": ["displacementmapping"], "likes": 5, "viewed": 652, "date": "1469035402", "time_retrieved": "2024-06-20T18:38:25.754572", "image_code": "mat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    p = vec3(p.x + sin(p.z), p.y + cos(p.z), p.z);\n    q = vec3(q.x - sin(q.z), q.y - cos(q.z), q.z);\n    \n    vec2 helixa = vec2(length(p.xy) - 0.5 - (texture(iChannel0, p.xz) * 0.1).y, 2.0);\n    vec2 helixb = vec2(length(q.xy) - 0.5 - (texture(iChannel0, q.xz) * 0.1).y, 3.0);\n\n    return vecMin(helixa, helixb);\n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 1000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        t += d;\n        if(t > 30.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 amb(vec3 c, float k){\n    return c * k;\n}\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nvec3 spec(vec3 c, float k, vec3 p, float a){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - camPos);\n    float facing = dot(l, n) > 0.0 ? 1.0 : 0.0;\n    vec3 r = reflect(l, n);\n    return c * k * facing * pow(max(0.0, dot(r, v)), a);\n}\n\nvec3 colour(vec3 p, float id){\n    if(id == 2.0){\n        vec3 col = vec3(0.0, 0.0, 1.0);\n        return amb(col, 0.5) + diff(col, 0.8, p) + spec(vec3(1.0), 0.9, p, 8.0);\n    }\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    return amb(col, 0.5) + diff(col, 0.8, p) + spec(vec3(1.0), 0.9, p, 8.0);\n} \n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.5;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, iTime / 2.0);\n    lightPos = vec3(0.0, 0.0, -2.0 + iTime / 2.0);\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n    \tcol = colour(c, closeObj);\n        float s = shadow(c, normalize(lightPos - c));\n        col -= vec3(0.5 - 0.5 * s);\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(1.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 19, 19, 160], [162, 162, 181, 181, 322], [347, 347, 375, 375, 435], [437, 437, 457, 457, 790], [792, 792, 810, 810, 836], [838, 838, 868, 868, 1251], [1253, 1253, 1273, 1273, 1549], [1625, 1625, 1651, 1651, 1671], [1673, 1673, 1708, 1708, 1812], [1814, 1814, 1858, 1858, 2091], [2093, 2093, 2123, 2123, 2384], [2387, 2387, 2418, 2418, 2774], [2815, 2815, 2871, 2871, 3586]]}
{"id": "ll33Wn", "name": "Toon Shaded Torus", "author": "Dalton", "description": "Raymarched torus w/ cel shading. Plan on adding AA later.", "tags": ["raymarching", "celshading", "edgedetection"], "likes": 19, "viewed": 2189, "date": "1468710933", "time_retrieved": "2024-06-20T18:38:25.754572", "image_code": "#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.1\n#define EDGE_THICKNESS 0.015\n#define SHADES 4.0\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    return TorusSDF(samplePoint, vec2(1.3, 0.45));\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\nvec3 ComputeLighting(vec3 point, vec3 lightDir, vec3 lightColor)\n{\n    vec3 color = vec3(AMBIENT);\n    float intensity = dot(EstimateNormal(point), normalize(lightDir));\n    intensity = ceil(intensity * SHADES) / SHADES;\n    intensity = max(intensity, AMBIENT);\n    color = lightColor * intensity;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n    vec3 color = vec3(1.0, 0.5, 0.1);\n    \n    color = ComputeLighting(hitPoint, lightDir, color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[158, 158, 209, 209, 299], [301, 301, 335, 335, 388], [390, 390, 481, 481, 998], [1000, 1000, 1057, 1057, 1183], [1185, 1185, 1218, 1218, 1621], [1623, 1623, 1671, 1671, 1886], [1888, 1888, 1954, 1954, 2205], [2207, 2207, 2264, 2264, 3143]]}
{"id": "ll33zN", "name": "Starry Space", "author": "huwb", "description": "Dynamic fractal - treats iterated point as particle with inertia. Can give some really interesting variations in look. Uncomment DYNAMICS_ON_MOUSE to explore!", "tags": ["kaliset", "dynamicfractal"], "likes": 21, "viewed": 898, "date": "1468165744", "time_retrieved": "2024-06-20T18:38:26.468434", "image_code": "// Started as Star Nest by Pablo RomÃ¡n Andrioli\n// AA modifications by Beibei Wang and Huw Bowles (https://www.shadertoy.com/view/XllGzN)\n\n// This shader is an idea i have been meaning to try out for a while which I'll\n// call a \"dynamic fractal\".\n\n// The idea is simple - treat the iteration point as a particle with inertia (non-zero mass).\n// In each iteration compute a new target point for the particle using the fractal formula and\n// then apply a force to the particle to push it towards this position.\n\n// This can change the appearance of the result significantly.\n\n// Uncomment this define to set the sprint constants with the mouse\n//#define DYNAMICS_ON_MOUSE\n\n// This content is under the MIT License.\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 18\n#define stepsize 0.050\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.10 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.760\n#define saturation 0.800\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=(iTime-3308.)*speed;\n\n\t\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\t\n\tvec3 forward = vec3(0.,0.,1.);\n\t\n\t//mouse rotation\n\tfloat a1 = 0.3;//3.1415926 * (iMouse.x/iResolution.x-.5);\n\tmat2 rot1 = mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tfloat a2 = .6;//3.1415926 * (iMouse.y/iResolution.y-.5);\n\tmat2 rot2 = mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tforward.xz *= rot1;\n\tdir.yz*=rot1;\n\tforward.yz *= rot1;\n\n\t// pan (dodgy)\n    float panmul = 1.;\n    #ifdef DYNAMICS_ON_MOUSE\n    panmul = 0.;\n\t#endif\n\tfrom += (panmul * iMouse.x/iResolution.x-.5)*vec3(-forward.z,0.,forward.x);\n    \n\t//zoom\n\tfloat zooom = time;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize; // make from 0 to 1\n\t\n    // dynamics - proportional and differential gains (i.e. spring and damping constants)\n    float kp = 1.36;\n    float kv = .9;\n    #ifdef DYNAMICS_ON_MOUSE\n    kp = 2.*iMouse.x/iResolution.x;\n    kv = 2.*iMouse.y/iResolution.y;\n    #endif\n    \n\t//volumetric rendering\n\tfloat s=0.1;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n        vec3 pv = vec3(0.);\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tvec3 newp=abs(p)/dot(p,p)-formuparam; // the magic formula\n            // update particle vel\n            pv += (newp-p)*kp + (-pv)*kv;\n            // update particle pos\n            p += pv;\n            float D = abs(length(p)-pa); // absolute sum of average change\n            a += i > 7 ? min( 12., D) : D;\n\t\t\tpa=length(p);\n\t\t}\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t// brightens stuff up a bit\n\t\tfloat s1 = s+zoffset;\n\t\t// need closed form expression for this, now that we shift samples\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\t\tv+=fade;\n        \n\t\t// fade out samples as they approach the camera\n\t\tif( r == 0 )\n\t\t\tfade *= 1. - sampleShift;\n\t\t// fade in samples as they approach from the distance\n\t\tif( r == volsteps-1 )\n\t\t\tfade *= sampleShift;\n\t\tv+=vec3(2.*s1,4.*s1*s1,16.*s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.005,1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll33zN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[675, 977, 1034, 1062, 3547]]}
{"id": "ll3GDn", "name": "spheres and softshadow", "author": "pyBlob", "description": "rendering spheres using raymarching ... with some annoying artifacts :(", "tags": ["spheres", "softshadow", "repeating"], "likes": 2, "viewed": 121, "date": "1468670094", "time_retrieved": "2024-06-20T18:38:26.470528", "image_code": "float mapSphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat mapPlane(vec3 p, vec3 normal, float offset)\n{\n    return dot(p, normal) - offset;\n}\n\nvoid mapUnion(inout vec2 a, vec2 b)\n{\n    if (b.x < a.x) a = b;\n}\n\nvec2 map(vec3 p, out vec4 matInfo)\n{\n    vec2 ret = vec2(1e10);\n    \n    float size = 6.0;\n    vec3 offset = floor(vec3(p.x, 0.0, p.z)/size + 0.5)*size;\n    p = p - offset;\n    \n    float angle = dot(offset, vec3(17.16, 0, 2.45));\n    vec3 vx = vec3(cos(angle), 0.0, sin(angle));\n    vec3 vy = vec3(0.0, 1.0, 0.0);\n    vec3 vz = cross(vx, vy);\n    \n    p = mat3(vx, vy, vz) * p;\n    p += 2.0 * (mod(offset * vec3(68.3, 0.0, 150.2), 1.0) - vec3(0.5, 0.0, 0.5));\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0), 1.0),\n            1.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, 1.0, 1.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, 1.0, -1.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, -1.0, 0.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapPlane(p, vec3(0.0, 1.0, 0.0), -1.8 + 0.3 * sin(iTime * 0.5)),\n            3.0\n        )\n    );\n    \n    return ret;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773 * 1e-4;\n    return normalize(\n        e.xyy*map( pos + e.xyy, kk ).x +\n        e.yyx*map( pos + e.yyx, kk ).x +\n        e.yxy*map( pos + e.yxy, kk ).x +\n        e.xxx*map( pos + e.xxx, kk ).x\n    );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat getShadow(vec3 ro, vec3 rd)\n{\n    vec2 dist;\n    vec4 matInfo;\n    \n    float shadow = 1.0;\n    float travel = 0.0;\n    \n    for (int i=0 ; i<50 ; i++)\n    {\n        dist = map(ro, matInfo);\n        vec3 normal = getNormal(ro);\n        float d = 0.3 * (1.0 + dot(normal, rd));\n        \n        dist.x += 0.1 * travel + 0.1;\n        travel += max(0.01, dist.x);\n        ro += rd * max(0.01, dist.x);\n        \n        shadow *= 1.0 - 1.0 / (pow(dist.x, 2.0) + 4.0);\n    }\n    \n    return shadow;\n}\n\nvec3 render(vec3 ro, vec3 rd, out float fog)\n{\n    vec2 dist;\n    vec4 matInfo;\n    \n    for (int i=0 ; i<512 ; i++)\n    {\n        dist = map(ro, matInfo);\n        dist.x *= 0.5;\n        ro += rd * dist.x;\n        \n        float density = 0.001;\n        density *= smoothstep(50.0, 20.0, ro.y);\n        fog += density * dist.x;\n    }\n    \n    if (dist.x < 1e-1)\n    {\n        vec3 normal = getNormal(ro);\n        vec3 light = normalize(vec3(-1.0, 1.0, 0.0));\n        \n        float shadow = getShadow(ro + light*0.1, light);\n        \n        if (dist.y == 1.0)\n        {\n            return\n                0.1 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(1.0, 0.7, 0.1);// * max(0.0, dot(light, normal));\n        }\n        else if (dist.y == 2.0)\n        {\n            return\n                0.1 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(0.7, 1.0, 0.1) +//; * max(0.0, dot(light, normal));\n            \tshadow * vec3(1.0) * pow(max(0.0, dot(light, reflect(rd, normal))), 10.0);\n        }\n        else if (dist.y == 3.0)\n        {\n            return\n                0.05 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(0.2, 1.0, 0.05);// * max(0.0, dot(light, normal));\n        }\n    }\n    \n    return vec3(0.4, 0.5, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n    float height = 0.0;\n    height += iMouse.y / iResolution.y;\n    height *= 100.0;\n    height -= 4.5;\n    \n    float angle = iTime * 0.1;\n    vec3  ta = vec3(-0.1,3.0 + height*0.99,0.0);\n    vec3  ro = vec3(-0.1,3.2 + height,0.0) - 4.0*vec3(cos(angle), 0.0, sin(angle));\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n   \tfloat fog = -0.05;\n    vec3 col = render( ro, rd, fog );\n    \n\tfragColor = vec4(sqrt(mix(col, vec3(1.0), fog)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 42, 42, 74], [76, 76, 127, 127, 165], [167, 167, 204, 204, 232], [234, 234, 270, 270, 1389], [1391, 1391, 1417, 1417, 1666], [1668, 1668, 1723, 1723, 1901], [1903, 1903, 1938, 1938, 2404], [2406, 2406, 2452, 2452, 3668], [3670, 3670, 3727, 3727, 4281]]}
{"id": "ll3GRB", "name": "voronoi points as spheres", "author": "Daedelus", "description": "voronoi points as spheres, because many points without distance discontinuities is awesome!", "tags": ["voronoipointsspheresraymarching"], "likes": 7, "viewed": 749, "date": "1469891427", "time_retrieved": "2024-06-20T18:38:26.470528", "image_code": "/*\nusing https://www.shadertoy.com/view/ldl3W8\nbut raymarching the cell centers\n*/\n\n#define ANIMATE\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\t\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xx;\n\t\n    float td = 0.1;\n    vec3 is, o = vec3(0.0, 2.0, 0.0), d = vec3(0.0, 0.0, 1.0);\n    pR(d.xz, p.x * 0.3);\n    pR(d.yz, p.y * 0.3 - 0.2);\n    \n    for(int i = 0 ; i < 100 ; ++i)\n    {\n        is = o + d * td;\n    \tvec3 c = voronoi(is.xz);\n\t\tfloat dd = length( vec3(c.y, is.y, c.z) ) - 0.1;\n        td += dd;   \n        if(dd < 0.0 || td > 40.0)\n            break;\n    }\n    \n    float fog = min(1.0, td / 40.0);\n\t\n\tfragColor = vec4(fog,fog,fog,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 101, 133, 133, 175], [177, 177, 199, 199, 257], [259, 259, 286, 286, 778], [780, 780, 837, 837, 1334]]}
{"id": "ll3GRr", "name": "greefirefork", "author": "jobjb", "description": "discovered the green fire", "tags": ["fire", "green", "forked"], "likes": 3, "viewed": 604, "date": "1467632909", "time_retrieved": "2024-06-20T18:38:26.954581", "image_code": "//////////////////////\n// Fire Flame shader\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 1.8*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.18 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(18.1) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t//f += 0.2500*noise( uv ); uv = m*uv;\n\t//f += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// no defines, standard redish flames\n//#define BLUE_FLAME\n//#define GREEN_FLAME\nconst float ar_real_size = 1.0;\nconst vec2 ar_scale = vec2(2.,5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv.yx;\n\t\n\tfloat strength = floor(q.x-0.3);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\t//q.x = mod(q.x,1.)-0.5;\n\t//q.y -= 0.25;\n    \n    vec2 size = ar_scale * ar_real_size;\n    q*=size;\n    q.y -= 1.55;\n    //q.x = mod(q.x,1.)-0.5;\n    q.x -=.94;\n    \n\tfloat n = fbm(strength*q.xy - vec2(T3,0));\n\tfloat c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );\n\tfloat c1 = n * c * (1.5-pow(0.05*uv.y,4.));\n\t//float c1 = n * c * (1.5-pow(2.50*uv.y,4.));\n    \n   \n\tc1=clamp(0.68,0.18,0.9);\n\n\tvec3 col = vec3(0.4*c1, 1.9*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n\t\n    \n    col = col.xzy*2.9;\n\n    vec3 rot = vec3(0.);\n\t\n\tfloat a = c * (1.-pow(uv.y,2.));\n    \n    vec4 fire = vec4(mix(vec3(0.),col.zyx,a), 1.0);\n    \n    float ta = step(dot(fire.rgb,vec3(.3,.59,.21)),.9);\n\n\tfloat aa = exp(ta)-1.;\n\tfloat mixer = clamp(aa,0.,1.);\n    \n    vec4 tex = texture(iChannel0, uv);\n    fire.rgb = mix(tex,fire,mixer).rgb;\n    \n\tfragColor = mix(texture(iChannel0, uv),vec4(1),fire);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[45, 73, 94, 94, 213], [215, 215, 241, 241, 700], [702, 702, 722, 722, 956], [958, 1106, 1163, 1163, 2213]]}
{"id": "ll3GW7", "name": "Toon Shader test", "author": "geoff", "description": "Shading using colours from a palette. Light intensity is based on diffuse component of standard phong model. Change the number of shades in the palette using SHADES. The camera can be rotated with the mouse.", "tags": ["spheretracing", "npr"], "likes": 8, "viewed": 1102, "date": "1469580663", "time_retrieved": "2024-06-20T18:38:26.954581", "image_code": "#define AO\n#define SHADOWS\n\n#define SHADES 5.0\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    q -= vec3(0.5 * cos(iTime), 0.0, 0.5 * sin(iTime));\n    vec3 r = p;\n    r -= vec3(-2.5 * cos(iTime), 0.0, -2.5 * sin(iTime));\n    r *= rotY(iTime);\n    vec2 sphere = vec2(length(q) - 1.0, 2.0);\n    vec2 sphereb = vec2(length(r) - 1.0, 3.0);\n    vec2 hplane = vec2(p.y + 1.0, 1.0);\n    vec2 vplane = vec2(-p.z + 4.0, 1.0);\n    \n    return vecMin(sphere, vecMin(sphereb, vecMin(hplane, vplane))); \n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 2000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        t += d;\n        if(t > 50.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.2;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(1.0 * occ, 0.0, 1.0);\n}\n\nvec3 colInterp(vec3 bcol, vec3 ecol, vec3 inCol, float s){\n    float st = 1.0 / SHADES;\n    float avg = inCol.x * SHADES; \n    float band = ceil(avg) / SHADES;\n    if(s != 1.0){\n        band = max(0.0, band - st);\n    }\n    return mix(bcol, ecol, band);\n}\n\nvec3 palette(float id, vec3 inCol, float s){\n    if(id == 1.0){\n        vec3 mcol = vec3(0.95);\n        vec3 bcol = mcol / 4.0;\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    if(id == 2.0){\n        vec3 mcol = vec3(0.874510, 0.490196, 0.376471);\n        vec3 bcol = mcol / 4.0;\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    if(id == 3.0){\n        vec3 mcol = vec3(0.929412, 0.882353, 0.788235);\n        vec3 bcol = mcol / 4.0;\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat s = 1.0;\nfloat ao = 1.0;\n\nvec3 colour(vec3 p, float id){\n    \n    #ifdef SHADOWS\n    float s = shadow(p, normalize(lightPos - p));\n    #endif\n    \n    #ifdef AO\n    float ao = occlusion(p, normal(p));\n    #endif\n    \n    return palette(id, diff(vec3(1.0), 1.0, p) * ao, s);\n} \n\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, -5.0);\n    lightPos = vec3(2.0, 2.0, -6.0);\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n    \tcol = colour(c, closeObj);\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 67, 67, 208], [210, 210, 229, 229, 370], [395, 395, 423, 423, 483], [485, 485, 505, 505, 923], [925, 925, 943, 943, 969], [971, 971, 1001, 1001, 1384], [1386, 1386, 1406, 1406, 1682], [1758, 1758, 1793, 1793, 1897], [1899, 1899, 1930, 1930, 2286], [2288, 2288, 2322, 2322, 2571], [2573, 2573, 2631, 2631, 2828], [2830, 2830, 2874, 2874, 3367], [3401, 3401, 3431, 3431, 3650], [3692, 3692, 3748, 3748, 4352]]}
{"id": "ll3GWM", "name": "Polar Coordinates Motion", "author": "Ark", "description": "Polar Coordinates Motion\n\nreference: \nhttp://foxcodex.html.xdomain.jp/PolarCoordinates.html", "tags": ["coordinates"], "likes": 17, "viewed": 630, "date": "1469629449", "time_retrieved": "2024-06-20T18:38:26.954581", "image_code": "#define PI 3.141592653589793\n\nfloat getT() {\n    float t = mod(iTime/1.5, 2.0);\n    return (t < 1.0) ? t : 2.0-t;\n}\n\nfloat easeInOutQuart(float t) {\n    t *= 2.0;\n    if (t < 1.0) {\n        return 0.5 * t*t*t*t;\n    } else {\n        t -= 2.0;\n        return -0.5 * (t*t*t*t - 2.0);\n    }\n}\n\nvec2 convert(vec2 uv, vec2 origin) {\n    float s = 2.0/PI;\n    float r = length(uv-origin);\n    float theta = mod(atan(uv.y - origin.y, uv.x - origin.x) + PI/2.0 + PI, 2.0*PI) - PI;\n    return vec2(s * theta, -r*3.0) + origin;\n}\n\nfloat calc(vec2 p, vec2 origin, float t) {\n    vec2 q = convert(p, origin);\n    vec2 uv = mix(p, q, t);\n    \n    float diff = 0.2;\n    float a = 0.4;\n    uv += vec2(diff);\n    float d_x = min(mod(uv.x, a), mod(-uv.x, a));\n    float d_y = min(mod(uv.y, a), mod(-uv.y, a));\n    float d = min(d_x, d_y);\n    return 0.02/d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = easeInOutQuart(getT());\n    float col = calc(uv, vec2(0, 0), t);\n    fragColor = vec4(col*vec3(0.2, 0.45, 0.8), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[30, 30, 44, 44, 115], [117, 117, 148, 148, 289], [291, 291, 327, 327, 519], [521, 521, 563, 563, 842], [844, 844, 901, 901, 1117]]}
{"id": "ll3GWn", "name": "[SH16B] Recursive Rocket", "author": "Klems", "description": "A rocket inside a rocket inside a rocket, slowly climbing into space. But where is the payload? Use the mouse to rotate the camera.", "tags": ["procedural", "3d", "space", "sh16b"], "likes": 33, "viewed": 1561, "date": "1468636715", "time_retrieved": "2024-06-20T18:38:29.360959", "image_code": "\n#define DITHER\n\n#define PI 3.14159265359\n#define SCALE 2.5\n#define MARCH_DIST 0.5\n#define MARCH_STEPS 30\n#define sunColor vec3(1.0, 0.9, 0.65)*2.0\n#define nozColor vec3(1.0, 0.3, 0.0)*4.0\n\nfloat fracSequence = 0.0;\nfloat fracFall = 0.0;\nfloat fracTotal = 0.0;\nfloat fracScale = 0.0;\nvec3 nozzlePosition = vec3(0);\nfloat nozzleStrength = 0.0;\nfloat altSpaceFrac = 0.0;\nmat2 altRot = mat2(0);\nmat2 altHeading = mat2(0);\nfloat altAccel = 0.0;\nvec3 sunDir = vec3(0);\nfloat sunStrength = 0.0;\nvec3 backgroundColor = vec3(0);\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\n// 1D noise\nfloat hash( in float n ) { return fract(sin(n)*753.5453123); }\n\n// iq's 3D noise\nfloat noise( in vec3 x ) {\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv + 0.5)/256.0, 0.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\n// iq's fog\nvec3 fog( in vec3 rgb, in float dist, in vec3 rayOri, in vec3 rayDir ) {\n    float c = 0.01;\n    float b = 0.3;\n    rayOri -= 8.0;\n    rayOri += altSpaceFrac*9.0;\n    float fogAmount = c * exp(-rayOri.z*b) * (1.0-exp( -dist*rayDir.z*b ))/rayDir.z;\n    fogAmount = clamp(fogAmount, 0.0, 1.0);\n    vec3 fogColor = backgroundColor;\n    return mix( rgb, fogColor, fogAmount );\n}\n\n// fairing shape, [0, 1] -> [0, 1]\nfloat fairingFunc( in float x ) {\n    #define MI 0.4\n    if (x < MI) {\n        float v = 0.75 + x*1.5;\n        return clamp(v, 0.85, 1.0);\n    } else {\n        float xx = (x - MI) / (1.0 - MI);\n        xx *= xx;\n        return max(0.0, 1.0 - xx);\n    }\n}\n\n// rocket distance estimator, returns the distance to the rocket without fairings\nvoid rocketDE( in vec3 p, out float d, out int id, out vec3 texCoord ) {\n    float lenxy = length(p.xy);\n    vec2 ori = p.xy / lenxy;\n    \n    // main fuel tank\n    float tank = lenxy - 0.3;\n    tank = max( tank, abs(p.z - 0.3) - 0.7 );\n    \n    // spherical combustion chamber\n    float engine = length(p + vec3(0.0, 0.0, +0.35)) - 0.27;\n    // add tubes\n    vec2 tubeOffset = p.xy - sign(p.xy) * 0.07;\n    float tube = length(tubeOffset) - 0.05;\n    tube = max( tube, abs(p.z + 0.6) - 0.1 );\n    engine = min(engine, tube);\n    // engine nozzle\n    float nozzle = dot( vec2(0.9701, 0.2425), vec2(lenxy, p.z) );\n    nozzle += sin(p.z*114.0)*0.007; // add some ridges\n    nozzle = max(nozzle, abs(p.z + 0.85) - 0.15);\n    nozzle = max(nozzle, -(length(p + vec3(0.0, 0.0, 1.1)) - 0.26));\n    engine = min(engine, nozzle);\n    \n    texCoord = p;\n    if (tank < engine) {\n        d = tank;\n        id = 1;\n    } else {\n        d = engine;\n        id = 2;\n    }\n}\n\n// falling rocket + falling fairings distance estimator\nvoid rocketAndFairingDE( in vec3 p, in float frac, in float seed,\n                         out float d, out int id, out vec3 texCoord ) {\n    float gravity = frac*frac;\n    vec3 tp = p;\n    \n    // randomize rotation of each rockets\n    tp.xy *= rot( PI*sin(seed*4125.664) );\n    \n    vec3 rp = tp;\n    if (frac > 0.0) {\n        rp.z += gravity*88.0;\n        float randRot = 1.1 * sin(seed*321.81);\n        rp.xz *= rot(frac*2.0*randRot);\n    }\n        \n    // get the distance to the rocket\n    rocketDE(rp, d, id, texCoord);\n    \n    // for each parts of the fairings\n    for (int i = -1; i <= 1; i += 2) {\n        float ii = float(i);\n        float ss = sign(ii);\n        \n        vec3 origin = vec3(0.0, 0.0, 1.0);\n        // add horizontal velocity\n        origin.y += ii*frac*18.0;\n        // then gravity\n        origin.z -= gravity*72.0;\n        \n        vec3 pp = tp - origin;\n        if (frac > 0.0) {\n            // randomize rotation of each fairing parts\n            float randRot = 1.0 + sin(seed*391.81+ii*122.35+154.42)*0.2;\n            float randRot2 = sin(seed*458.91+ii*138.42+284.66);\n            vec3 delt = vec3(0.0, ss*0.1, -0.5);\n            pp += delt; // change center of gravity\n            pp.yz *= rot(frac*-ss*14.0*randRot);\n            pp.xy *= rot(frac*randRot2*4.0);\n            pp -= delt;\n        }\n        \n        float fairDist = length(pp.xy) - fairingFunc(pp.z/1.5)*0.32;\n        fairDist = abs(fairDist)-0.01;\n        fairDist = max(fairDist, -pp.z);\n        fairDist = max(fairDist, pp.z-1.5);\n        fairDist = max(fairDist, -pp.y*ss);\n        \n        if (fairDist < d) {\n            d = fairDist;\n            id = 3;\n            texCoord = pp;\n        }\n    }\n}\n\n// rocket inside a rocket\nvoid fractalRocketDE( in vec3 p, out float d, out int id, out vec3 texCoord ) {\n    p.yz *= altRot;\n    \n    vec3 bottomP = p/fracScale;\n    bottomP.z += fracTotal * 1.45;\n    float bottomSeed = fracSequence;\n    float bottomDist = 0.0;\n    int bottomID = 0;\n    vec3 bottomTexCoord = vec3(0);\n    rocketAndFairingDE(bottomP, fracFall, bottomSeed, bottomDist, bottomID, bottomTexCoord);\n    bottomID = -bottomID; // invert the sign of the bottom rocket\n    bottomDist *= fracScale;\n    \n    float topScale = fracScale / SCALE;\n    vec3 topP = p;\n    topP.z -= (1.0 - fracTotal) * 1.45;\n    topP /= topScale;\n    float topSeed = fracSequence + 1.0;\n    float topDist = 0.0;\n    int topID = 0;\n    vec3 topTexCoord = vec3(0);\n    rocketAndFairingDE(topP, 0.0, topSeed, topDist, topID, topTexCoord);\n    topDist *= topScale;\n    \n    if (bottomDist < topDist) {\n        d = bottomDist;\n        id = bottomID;\n        texCoord = bottomTexCoord;\n    } else {\n        d = topDist;\n        id = topID;\n        texCoord = topTexCoord;\n    }\n}\n\n// normal function\nvec3 normal(vec3 p, int id, vec3 texCoord) {\n    float dist = 0.0;\n    vec3 distV = vec3(0);\n    \n    int tempID = 0;\n    vec3 tempTexCoord = vec3(0);\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n    fractalRocketDE(p, dist, tempID, tempTexCoord);\n    fractalRocketDE(p-e.xyy, distV.x, tempID, tempTexCoord);\n    fractalRocketDE(p-e.yxy, distV.y, tempID, tempTexCoord);\n    fractalRocketDE(p-e.yyx, distV.z, tempID, tempTexCoord);\n    vec3 n = dist-distV;\n    \n    // do normal mapping on the surface of the tank\n    if (id == 1 || id == -1) {\n        n.x += noise(texCoord*80.12)*0.0002 - 0.0001;\n        n.y += noise(texCoord*79.14)*0.0002 - 0.0001;\n        n.z += noise(texCoord*81.19)*0.0002 - 0.0001;\n    }\n    \n\treturn normalize(n);\n}\n\n// light the scene\nvec3 light( in vec3 p, in vec3 n, in vec3 c, in vec3 dir, in float rough, in bool doNoz ) {\n    vec3 pp = p;\n    p.yz *= altRot;\n    float specScale = (rough+1.0)*0.25;\n    \n    float sun = max(0.0, -dot(n, sunDir));\n    float sunSpec = pow(max(0.0, -dot(dir, reflect(sunDir, n))), rough);\n    sun += sunSpec*specScale;\n    sun *= sunStrength;\n    \n    float noz = 0.0;\n    if (doNoz) {\n        vec3 delt = (nozzlePosition - p) / fracScale;\n        vec3 deltN = normalize(delt);\n        vec3 nn = n;\n        nn.yz *= altRot;\n        noz = max(0.0, dot(nn, deltN));\n        float nozSpe = pow(max(0.0, dot(dir, reflect(deltN, nn))), rough);\n        noz += nozSpe*specScale;\n        noz /= dot(delt, delt);\n        noz *= nozzleStrength;\n    }\n    \n    float ao = 0.0;\n    int id = 0;\n    vec3 texCoord = vec3(0.0);\n    fractalRocketDE(pp+n*0.1, ao, id, texCoord);;\n    ao = clamp(ao / 0.1, 0.0, 1.0);\n    \n    vec3 result = c*ao*backgroundColor*0.2;\n    result += c*sun*sunColor;\n    result += c*noz*nozColor;\n    return result;\n}\n\n// density function for the trail\nvec4 density( in vec3 p ) {\n    p.yz *= altRot;\n    \n    // accelerate the smoke along the rocket trajectory\n    vec3 accel = vec3(0.0, 0.0, iTime*16.0);\n    float grav = (fracTotal*fracTotal)*-32.0;\n    \n    vec3 pp = (p-nozzlePosition) / fracScale;\n    vec3 ppp = pp;\n    pp.x += noise(p*1.2+accel)*0.2-0.1;\n    pp.y += noise(p*1.3+accel)*0.2-0.1;\n    pp.z += noise(p*1.6+accel)*0.2-0.1;\n    \n    vec2 cyl = vec2(length(pp.xy), pp.z);\n    \n    // add smoke around the trail\n    float nozzle = dot( vec2(0.9801, 0.1725), cyl );\n    float alphaNozzle = 1.0 - smoothstep(0.0, 0.1, nozzle);\n    alphaNozzle *= 1.0 - smoothstep(0.0, 0.05, pp.z);\n    alphaNozzle *= smoothstep(grav, grav+1.0, pp.z);;\n    alphaNozzle /= fracScale;\n    alphaNozzle *= nozzleStrength;\n    alphaNozzle = clamp(alphaNozzle, 0.0, 1.0);\n    \n    // add some noise\n    float noiseValue = 1.0;\n    noiseValue += noise(p*1.9+accel)*3.0;\n    noiseValue += noise(p*2.2+accel)*1.0;\n    noiseValue += noise(p*4.4+accel)*0.5;\n    noiseValue *= (1.0-altSpaceFrac);\n    noiseValue *= 0.005;\n    noiseValue = clamp(noiseValue, 0.0, 1.0);\n    \n    // add a fire trail\n    ppp.z += 0.05;\n    float len = length(ppp);\n    float theta = acos(-ppp.z / len) / (PI*0.5);\n    float randV = noise(p*4.0+accel);\n    float radius = 1.0 / (theta + 0.01 + randV*0.05);\n    float fire = 1.0 - smoothstep(0.0, 0.1, len - radius * 0.04);\n    fire /= fracScale;\n    fire *= 2.0;\n    fire *= nozzleStrength;\n    fire *= smoothstep(grav-2.0, grav-1.0, pp.z);\n    fire = clamp(fire, 0.0, 1.0);\n    \n    // base color of the smoke\n    vec3 baseColor = mix(vec3(0.5), vec3(0.8), noise(p*2.0+accel));\n    baseColor *= 1.0 - alphaNozzle*0.9; // lighter outside the trail\n    baseColor *= (sunStrength*0.75+0.25); // darker during night\n    baseColor = mix(baseColor, nozColor, fire); // colored fire\n    \n    return vec4(baseColor, max(noiseValue, max(alphaNozzle, fire)));\n}\n\n// background color\nvec3 getBackground( in vec3 dir ) {\n    // rotate stars\n    vec3 ddir = dir;\n    ddir.yz *= altHeading;\n    \n    // add stars\n    float noiseValue = 1.0;\n    noiseValue *= noise( ddir*161.58 );\n    noiseValue *= noise( ddir*323.94 );\n    float stars = noiseValue*1.08;\n    stars *= stars; stars *= stars;\n    stars *= stars; stars *= stars;\n    vec3 starry = mix(vec3(0), vec3(1), stars);\n    // sun\n    float dsun = max(0.0, -dot(sunDir, dir));\n    float sun = smoothstep(0.9996, 0.999956, dsun);\n    starry = mix(starry, sunColor, sun);\n    float factor = pow(dsun, 2000.0);\n    starry += sunColor*sunStrength*0.4*factor;\n    return starry;\n}\n\n// ground color\nvec3 getGroundColor( in vec3 dir ) {\n    vec3 texCoord = dir/(dir.z/(1.0+altSpaceFrac*5.0));\n    texCoord *= 0.01;\n    texCoord.y += altAccel*altSpaceFrac*0.18;\n    texCoord.xy *= rot(5.0832);\n    float backColor = smoothstep(-1.0+altSpaceFrac*0.75, 0.0, dir.z)*0.4+0.6;\n    vec3 groundColor = texture(iChannel2, texCoord.xy).rgb;\n    groundColor = mix(groundColor, backgroundColor, (1.0-sunStrength)*0.7);\n    return mix(groundColor, backgroundColor, backColor);\n}\n\n// texture for the fairings\nvec3 getFairingColor( in vec3 texCoord ) {\n    if (texCoord.z < 0.1) return vec3(0.95, 0.4, 0.0);\n    vec2 grid = vec2(texCoord.z, atan(texCoord.y, texCoord.x) / PI * 0.5 + 0.5);\n    grid *= vec2(2.5, 6.0);\n    grid = floor(grid);\n    float gridValue = mod(grid.x+grid.y, 2.0);\n    if (grid.x > 1.5) gridValue = 1.0;\n    if (abs(texCoord.y) < 0.01) gridValue = 0.0;\n    return mix(vec3(0.4, 0.4, 0.45), vec3(0.6, 0.6, 0.65), gridValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // initialize global variables once\n    float timeValue = (iTime-10.0) * 0.05;\n    fracSequence = floor(timeValue);\n\tfracFall = fract(timeValue);\n\tfracTotal = smoothstep(0.0, 0.5, fracFall);\n    fracScale = mix(1.0, SCALE, fracTotal);\n    nozzlePosition = vec3(0.0, 0.0, 1.1 - fracTotal*2.1);\n    nozzleStrength = smoothstep(0.0, 0.02, fracTotal);\n    nozzleStrength *= 1.0 - smoothstep(0.8, 1.0, fracFall);\n    altSpaceFrac = 1.0 - pow(4.2, -iTime*0.01);\n    altRot = rot(PI*0.5*altSpaceFrac);\n    altAccel = iTime*0.07;\n    altAccel *= altAccel;\n\taltHeading = rot(-altAccel*0.09*altSpaceFrac);\n    sunDir = normalize(vec3(-1.4, 3.7, 1.1));\n    sunDir.yz *= altHeading;\n    sunDir.z *= -1.0;\n    sunStrength = 1.0 - smoothstep(-0.15, 0.08, sunDir.z);\n    backgroundColor = mix(vec3(0.2, 0.3, 0.4), vec3(0.5, 0.6, 0.7), sunStrength);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(-14.0 + smoothstep(0.0, 20.0, iTime)*4.0, 0.0, 0);\n\tvec3 dir = vec3(uv.x*0.5, 1.0, uv.y*0.5);\n    dir.y += exp(length(uv)) * 0.15;\n    dir = normalize(dir);\n\tdir.xy *= rot(3.1415*.5);\n    \n    vec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n    \n    float shake = smoothstep(0.1, 0.3, fracTotal);\n    shake *= 1.0 - smoothstep(0.7, 0.9, fracFall);\n    vec2 rand = vec2(noise(vec3(iTime*15.4, 0.0, 0.0)),\n                     noise(vec3(iTime*17.2, 9.9, 9.9))) * shake;\n    \n    mat2 rotxz = rot(-0.16-mouse.y*5.0 + sin(iTime*0.0645)*0.07 + rand.x*0.01);\n\tmat2 rotxy = rot(0.2+mouse.x*8.0 + sin(iTime*0.0729)*1.1 + rand.y*0.01);\n\t\n    from.xz *= rotxz;\n\tfrom.xy *= rotxy;\n\tdir.xz  *= rotxz;\n\tdir.xy  *= rotxy;\n\n\tfloat totdist = 0.0;\n\tbool set = false;\n\tvec3 norm = vec3(0);\n    float dist = 0.0;\n    int id = 0;\n    vec3 texCoord = vec3(0);\n    \n    // offset starting distance with a dithered value\n    vec2 randVec = vec2(hash(iTime), hash(iTime*1.61541));\n    float dither = texture(iChannel1, fragCoord.xy / 8.0 + randVec).r;\n    fractalRocketDE(from, dist, id, texCoord);\n    #ifdef DITHER\n    totdist += dist*dither;\n    #endif\n    // run sphere tracing to find the rocket surface\n\tfor (int steps = 0 ; steps < 50 ; steps++) {\n\t\tif (set) continue;\n\t\tvec3 p = from + totdist * dir;\n        fractalRocketDE(p, dist, id, texCoord);\n        dist *= 0.75;\n\t\ttotdist += max(0.0, dist);\n\t\tif (dist < 0.01) {\n\t\t\tset = true;\n\t\t\tnorm = normal(p, id, texCoord);\n\t\t}\n\t}\n    \n    // do surface texture/light when an object is found\n    if (set) {\n        vec3 emiss = vec3(0);\n        vec3 color = vec3(0);\n        float rough = 0.0;\n        \n        bool bot = id < 0;\n        int iid = bot ? -id : id;\n        if (iid == 1) {\n            color = vec3(0.5, 0.3, 0.1);\n            rough = 8.0;\n        } else if (iid == 2) {\n            color = vec3(0.05);\n            float nozz = smoothstep(0.6, 1.3, -texCoord.z);\n            if (id > 0) nozz *= smoothstep(0.0, 0.7, fracTotal);\n            emiss = vec3(nozColor) * nozz * 0.4;\n            rough = 16.0;\n        } else if (iid == 3) {\n            color = getFairingColor(texCoord);\n            rough = 3.0;\n        }\n        \n        fragColor.a = 1.0;\n        fragColor.rgb = light( from+dir*totdist, norm, color, dir, rough, bot );\n        fragColor.rgb += emiss;\n    } else {\n        // pass some landscape on the ground\n    \tbackgroundColor = getGroundColor(dir);\n        // get the background otherwise\n        fragColor.rgb = getBackground(dir);\n        totdist = 99999.9;\n    }\n    \n    // modify the background color when looking at the sun\n    float sunLook = max(0.0, dot(dir, -sunDir))*sunStrength;\n    sunLook *= sunLook; sunLook *= sunLook;\n    backgroundColor = mix(backgroundColor, sunColor, sunLook);\n    \n    // apply fog\n    fragColor.rgb = fog( fragColor.rgb, totdist, from, dir);\n    \n    // do volumetric rendering back to front\n    float totdistmarch = MARCH_DIST*float(MARCH_STEPS);\n    totdistmarch = min(totdist, totdistmarch);\n    #ifdef DITHER\n    totdistmarch -= dither*MARCH_DIST;\n    #endif\n    for (int steps = 0 ; steps < MARCH_STEPS ; steps++) {\n        if (totdistmarch < 0.0) continue;\n        \n        vec3 p = from + totdistmarch * dir;\n        vec4 col = density(p);\n        col.a *= MARCH_DIST;\n        \n       \t// apply fog to the color\n        col.rgb = fog( col.rgb, totdistmarch, from, dir );\n        // accumulate opacity\n        fragColor.rgb = fragColor.rgb*(1.0-col.a)+col.rgb*col.a;\n        \n        totdistmarch -= MARCH_DIST;\n\t}\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.a = 1.0;\n    \n    // vignette\n    fragColor.rgb -= dot(uv, uv)*0.1;\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3GWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[522, 522, 546, 546, 617], [619, 631, 657, 657, 693], [695, 712, 738, 738, 960], [962, 974, 1046, 1046, 1348], [1350, 1385, 1418, 1418, 1639], [1641, 1723, 1795, 1795, 2682], [2684, 2740, 2877, 2877, 4447], [4449, 4475, 4554, 4554, 5509], [5511, 5530, 5574, 5574, 6258], [6260, 6279, 6370, 6370, 7308], [7310, 7344, 7371, 7371, 9257], [9259, 9279, 9314, 9334, 9923], [9925, 9941, 9977, 9977, 10406], [10408, 10436, 10478, 10478, 10874], [10876, 10876, 10933, 10974, 15609]]}
{"id": "ll3Gz8", "name": "Red Glowing Ring", "author": "jota", "description": "Red glowing ring that grows and shrinks.", "tags": ["2d", "ring"], "likes": 7, "viewed": 646, "date": "1467854404", "time_retrieved": "2024-06-20T18:38:29.366918", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    float circDist = abs(sin(iTime)/2.0);\n    float distFromCenter = distance(pos, vec2(0.5, 0.5));\n    float distFromCirc = pow(0.001, distance(distFromCenter, circDist)*2.0);\n    if(distFromCirc < 0.0) distFromCirc = 0.0;\n    float color = 1.0 * distFromCirc;\n\tfragColor = vec4(color, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Gz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 405]]}
{"id": "llc3DM", "name": "301's Fire Shader - Remix 1", "author": "CaliCoastReplay", "description": "A remix of 301's deleted fire shader, taken from here:\n\nhttps://www.shadertoy.com/view/XsXXRN\n\nGotten it to nicely billow and smoke by using some subtractive passes.  But why can't I get a white highlight in the center of the flame no matter what?", "tags": ["flame", "fire", "blaze"], "likes": 15, "viewed": 1286, "date": "1469572697", "time_retrieved": "2024-06-20T18:38:29.366918", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.5;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(1.3, 0.1);\n    float shift = 1.77+sin(iTime*2.0)/10.0;\n    float alpha = 1.0;\n\tfloat dist = 6.0+sin(iTime*0.4)/.6;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.01+1.0*sin(iTime)/10.0);\n    float qb = fbm(p - iTime * 0.002+0.1*cos(iTime)/5.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/7.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/30.0)-4.0;\n    float q4 = fbm(p - iTime * 2.0 - 20.0*sin(iTime)/20.0)+2.0;\n    q = (q + qb - q2 -q3  + q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(c * cos(shift * fragCoord.y / iResolution.y));\n    color -= .25;\n    color.r *= 1.02;\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= hsv.z  * 0.8;\n    hsv.z *= hsv.y * 1.3;\n    color = hsv2rgb(hsv);\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llc3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 568, 568, 642], [644, 644, 665, 665, 871], [873, 873, 892, 892, 1077], [1079, 1079, 1136, 1136, 2367]]}
{"id": "llc3zH", "name": "Minimalist iteration", "author": "josemorval", "description": "An illustrative example of the fixed point algorithm used, among other things, to find the zero of a function. Furthermore, the color point in the x-axis have the x value (such that f(x)=x) coded in his color. ", "tags": ["mathsfixedpointminimalistblackandwhiteiteration"], "likes": 5, "viewed": 647, "date": "1467897800", "time_retrieved": "2024-06-20T18:38:29.366918", "image_code": "#define WHITECOL vec4(1.0,1.0,1.0,1.0)\n#define WIDTH 0.01\n#define NUM_ITER 10\n\n//Draw line function\nfloat drawLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n  \tvec2 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    float d = length(pa-ba*h);\n    return  smoothstep(0.0,WIDTH,d-0.001);  \n}\n\n//Draw circle function\nfloat drawCircle(vec2 p, float radii){\n  return smoothstep(0.00,0.0005,p.x*p.x+p.y*p.y-radii*radii);\n}\n\n//[-res.x/res.y,res.x/res.y]x[-1,1] to [0,1]x[0,1] coordinates\nvec2 getOriginalCoord(vec2 p){\n    p.x*=iResolution.y/iResolution.x;\n    return (p+1.0)/2.0;\n}\n\n\n//Fixed point function\nfloat fun(float x){\n\treturn 0.6*sin(3.0*x); \n}\n\nvec4 mainColor(vec2 p){\n   \n  //Initial point\n  float x = 1.0*sin(0.3*iTime);\n  \n  float res = 1.0;\n  \n  //First evaluation x_{1} = f(x_0)\n  vec2 current = vec2(x,fun(x));\n  res=min(res,drawLine(p,vec2(x,0.0),current));\n  vec2 next;\n  \n  //Iteration prrocess x_{n+1} = f(x_n)\n  for(int i=0;i<NUM_ITER;i++){\n  \t\n  \tnext = vec2(current.y,current.y);  \n   \tres=min(res,drawLine(p,current,next));\n    current = next;\n    \n    //Main evaluation\n    next = vec2(current.x,fun(current.x));\n    \n    res = min(res,drawLine(p,current,next));\n    current = next;\n  }\n\n\n  res = min(res,smoothstep(0.0,2.0*WIDTH,abs(p.y-fun(p.x))));\n  res = min(res,smoothstep(0.0,0.5*WIDTH,abs(p.y-p.x)));\n  \n  //Circle with the fixed point coded in its color\n  //In case of non convergence, the color is still showed\n  //with the information of the last iteration point\n  float cir = 1.0-drawCircle(p-vec2(x,0.0),0.01);\n  vec4 colorCir = vec4(getOriginalCoord(current),0.0,1.0);\n  return mix(res*WHITECOL,cir*colorCir,cir);\n  \n}\t\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0+2.0*fragCoord.xy / iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    fragColor = mainColor(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llc3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[79, 100, 139, 139, 310], [312, 335, 373, 373, 437], [439, 502, 532, 532, 596], [599, 622, 641, 641, 668], [670, 670, 693, 715, 1671], [1675, 1675, 1732, 1732, 1849]]}
{"id": "llcGzN", "name": "Oil", "author": "huwb", "description": "Some experimental prepro from a few years ago that I never got around to posting. Uses noise to distort domain of a simple shape, define NO_DISTORT to see the input shape.", "tags": ["line", "distortion", "warp"], "likes": 17, "viewed": 572, "date": "1468160079", "time_retrieved": "2024-06-20T18:38:29.888367", "image_code": "\n//#define NO_DISTORT\n\n//iq's\nfloat noise( in vec3 x )\n{\n    x.xyz += iTime*.05;\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat turb( in vec3 p )\n{\n\tp -= vec3(31.3);\n\tfloat res = 0.;\n\tvec3 q = m*p*3.6;\n\tres +=  0.5*noise(q); q = m*q*5.1;\n\tres +=  0.02*noise(q); q = m*q*2.3;\n\t//res += 0.1*noise(q/2.); q = m*q*2.2;\n\t//res += 0.125*noise(q);\n\t\n\treturn res;\n}\n\nvec3 turbN( in vec3 p )\n{\n    #ifdef NO_DISTORT\n    return vec3(0.);\n    #endif\n    \n\tvec2 eps = vec2(0.01,0.);\n\tfloat c = turb(p);\n\treturn -vec3(\n\t\tturb(p+eps.xyy) - c,\n\t\tturb(p+eps.yxy) - c,\n\t\tturb(p+eps.yyx) - c\n\t\t) / eps.x;\n}\n\n#define MOUSEX iMouse.x / iResolution.x\n#define MOUSEY iMouse.y / iResolution.y\n\n#define UV_SCALE 8.\n#define STEP_SIZE 0.1\n\nfloat image( vec2 uv )\n{\n    if( uv.y < .5 )\n\t    uv.x = fract(uv.x);\n    else\n\t    uv.x = fract(uv.x/1.3);\n    \n\tfloat ssStart = 0.015;\n\tfloat ssEnd = 0.04;//0.03;\n    \n    float wi = max(1. - abs(uv.y-.5)*2.5,0.);\n    float crack = smoothstep( ssStart*wi, ssEnd*wi, pow(abs(uv.x-.5)*5.,1.1) );\n    crack += smoothstep(.9,1.,abs(uv.y-.5)*4.);\n    crack = clamp(crack,0.,1.);\n\treturn smoothstep( ssStart, ssEnd, abs(uv.y-0.5) ) * crack;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat offset = 13.3 + .07*iTime;\n\tfloat amp = 0.3;\n\tif( iMouse.z > 0. )\n\t{\n\t\toffset = 4.*MOUSEX;\n\t\tamp = MOUSEY;\n\t}\n\t\n\tvec2 advect = uv  + vec2(offset,0.);\n\t\n\tfragColor.xy += clamp(0.3-length(uv-advect),0.,1.);\n\t\n\tfloat l = 0.;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\tvec2 N = turbN( vec3(advect,1.0) ).xy;\n\t\tl += length( N );\n\t\tadvect += 0.025 * amp * N;\n\t}\n\t\n\tfragColor.xyz = vec3( image( advect ) );\n\t\n    fragColor.xyz *= pow(smoothstep(.25,.9,1.-length(uv-.5)),.3);\n    fragColor.xyz = mix(vec3(0.,.0,.0), vec3(1.,1.,1.)*1., fragColor.x );\n    fragColor.xyz = pow(fragColor.xyz,vec3(1./2.2));\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llcGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[23, 30, 56, 56, 295], [423, 423, 448, 448, 658], [660, 660, 685, 685, 889], [1015, 1015, 1039, 1039, 1453], [1455, 1455, 1512, 1512, 2153]]}
{"id": "lldGRM", "name": "Orthonormal basis via H", "author": "MBR", "description": "normal to orthonormal basis using quaternion similarity", "tags": ["tangent", "orthonormal", "basis", "binormal"], "likes": 23, "viewed": 3841, "date": "1468470504", "time_retrieved": "2024-06-20T18:38:30.955106", "image_code": "\n// HACK OF: https://www.shadertoy.com/view/4sSSW3\n\n// Create an orthonormal basis from a normal:\n//   http://marc-b-reynolds.github.io/quaternions/2016/07/06/Orthonormal.html\n// TL;DR version\n//   1) The method of Frisvad can be reduced to 2 products\n//   2) The math generalizes.  Second example (method 2) uses\n//      two instead of one reference directions.  Instead of a\n//      cowlick at -z there's a part at z=0\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\n\n//------ below here is original\n\n\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\n\n//I doubt this is needed on gpu, let me know if you need this for it to work.\n//#define HANDLE_SINGULARITY\n\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n  p.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n  return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n  float h=precis*2.0;\n  float d = 0.;\n  for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n#if 0\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\n#endif\n\n\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    basis(nor,f,r);\n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[422, 442, 491, 491, 1101], [1372, 1532, 1553, 1553, 1605], [1607, 1607, 1626, 1626, 1695], [1697, 1697, 1734, 1734, 1958], [1960, 1960, 1990, 1990, 2152], [2772, 2822, 2880, 2880, 3254], [3257, 3257, 3314, 3314, 5356]]}
{"id": "lldGW8", "name": "Omas Kueche", "author": "vapoi", "description": "just playing around without using common random functions", "tags": ["2d", "glow", "heat"], "likes": 5, "viewed": 236, "date": "1469110325", "time_retrieved": "2024-06-20T18:38:30.955106", "image_code": "// ein paar Farben\nconst vec3 col1 = vec3(0.1, 0.15, 0.72);\nconst vec3 col2 = vec3(0.3, 0.15, 0.1);\nconst vec3 colSepia = vec3(1.15, 1.0, 0.9);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position im Bild, die HÃ¶he pos.y geht von 0.0 (unten) bis 1.0 (oben)\n    //\t\t\t\t\t die Breite pos.x geht von 0.0 (links) bis 1.0 (rechts)\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    \n    // Unsere Position, aber mit Ursprung in der Mitte des Bildes\n    vec2 posMid = vec2(-1.0, -1.0) + 2.0 * pos; \n    // HÃ¶he und Breite in VerhÃ¤ltnis setzen\n    posMid.x *= iResolution.x / iResolution.y;\n    \n    // die Zeit in Sekunden: 1.0 entspricht einer Sekunde\n    float fTime = iTime * .30;\n    \n    // Abstand der Position zum Mittelpunkt\n    float fDistanceMid = length(posMid);\n    \n    // Die Farbe des Punktes fÃ¤ngt bei schwarz an\n    vec3 colMix = vec3(0.0, 0.0, 0.0);\n    \n    \n    // Hintergrundmuster \"irgendwas mit sinus\" \n    // Achtung, Sinus liefert auch negative Werte\n    float vBack = 0.0;\n    vBack += 1.5 * sin(posMid.y * 7.0 + fTime * .70) \n         \t \t * sin(posMid.x * 10.0);\n    \n    vBack += 1.5 * sin(posMid.y * 31.0) \n        \t  \t * sin(posMid.x * 39.0 + fTime * .5);\n    \n    // Vordergrund Tests\n    float fValue = 0.0;\n\tfloat fLoop = 0.0;\n    float fExtra = 7.0;\n    \n    for (int j = 0; j < 3; j++)\n    {\n        fLoop = float(j) * 0.17;\n        \n        fValue = fValue * 0.1 + sqrt(fract(pos.x * 0.30 * vBack * 0.13 + fLoop + abs(sin(fTime * 01.1 - fLoop))))\n            \t + 1.0 + 01.1 * -abs(sin(fDistanceMid * fExtra + fLoop * fValue * vBack + fTime * 0.03))\n                 ;\n    }\n    \n    fValue = pow(max(0.0, fValue), 5.0) * 0.15;\n    \n    \n    // Endfarbe zusammenmischen\n    colMix = mix(fValue * col2 * 1.5 + fValue * col1 * smoothstep(0.5, 0.8, fDistanceMid) \n                 , colSepia * abs(vBack) * 0.2 \n                 , smoothstep(0.1, 0.8, fDistanceMid) * smoothstep(-0.2, 0.3, abs(posMid.y)));\n    \n    fragColor = vec4(colMix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 146, 203, 349, 2003]]}
{"id": "lldGz7", "name": "MorphingSporeThing", "author": "wjbgrafx", "description": "Varying the shape of an object by manipulating the domain repetitions at multiple stages in the object definition.", "tags": ["3d", "raymarch", "domainrepetition"], "likes": 12, "viewed": 515, "date": "1468546156", "time_retrieved": "2024-06-20T18:38:32.276443", "image_code": "/*\n\t\"MorphingSporeThing\" by wjbgrafx\n\t\n\tBased on \"Playing with Symmetries - Torus\" by PauloFalcao\n\t\n\thttp://glslsandbox.com/e#29755.0\n\t\n*/\n//==============================================================================\n\n// From \"Raymarching Primitives\" - // Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//------------------------------------------------------------------------------\n//Util Start\n\nfloat PI=3.14159265;\n\nvec3 sim(vec3 p,float s)\n{\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\n// Rotation around z-axis when vec2 p.xy;\n// Rotation around y-axis when vec2 p.xz;\n// Rotation around x-axis when vec2 p.yz.\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n\n// When vec2 p.xy, rotational symmetry about z-axis;\n// when vec2 p.xz, rotational symmetry about y-axis\n// when vec2 p.yz, rotational symmetry about x-axis\nvec2 rotsim(vec2 p,float s)\n{\n   vec2 ret=p;\n   ret=rot(p,-PI/(s*2.0));\n   ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n   return ret;\n}\n\n//Util End\n//------------------------------------------------------------------------------\n\n//Scene Start\n//------------------------------------------------------------------------------\n\nvec2 obj0Def( in vec3 p )\n{\n\treturn vec2( sdEllipsoid( p, vec3( 0.1 ) ), 0.0 );\t\n}\nvec2 obj1Def( in vec3 p )\n{\n\treturn vec2( sdBox( p, vec3( 1.0, 0.02, 0.02 ) ), 1.0 );\t\n}\nvec2 obj2Def( in vec3 p )\n{\n\treturn vec2( sdBox( p, vec3( 0.02, 1.25, 0.02 ) ), 2.0 );\t\n}\n\n//------------------------------------------------------------------------------\n\nvec3 obj0_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.03 ) ), \n\t\t\t\t abs( sin( iTime * 0.05 ) ),\n\t\t\t\t abs( sin( iTime * 0.07 ) ) );\n}\nvec3 obj1_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.07 ) ), \n\t\t\t\t abs( sin( iTime * 0.03 ) ),\n\t\t\t\t abs( sin( iTime * 0.05 ) ) );\n}\nvec3 obj2_c(in vec3 p)\n{\n\treturn vec3( abs( sin( iTime * 0.05 ) ), \n\t\t\t\t abs( sin( iTime * 0.07 ) ),\n\t\t\t\t abs( sin( iTime * 0.03 ) ) );\n}\n//------------------------------------------------------------------------------\n\nvec2 map(in vec3 p) // orange\n{\t\n\t// Rotate space around the z-axis.\n\t//-------------------------------------------- \n\t// x-axis is now up-down, y-axis is right-left\n\tp.xy = rot( p.xy, PI * 0.5 );\n\t//-------------------------------------------- \n\n\t// Animation\n\t//---------------------------------------\n\t// Animate object rotating around x-axis:\n\tp.yz = rot( p.yz, iTime * 0.23 );\n\n\t// Animate object rotating around y-axis:\n\tp.xz = rot( p.xz, iTime * 0.17 );\n\n\t// Animate object rotating around z-axis:\n\tp.xy = rot( p.xy, iTime * 0.13 );\n\t//---------------------------------------\n\n\t// Domain repetitions\n\t// ---------------------------------------------------\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.11 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.35;\n\n\t// Copy sphere in yz plane via symmetry around x-axis.\n\t// numCopies = 6.0\n\t//p.yz = rotsim( p.yz, 8.0 );\t\n\tp.yz = rotsim( p.yz, 8.0 + 6.0 * sin( iTime * 0.05 ) );\t\n\t// Offset sphere along z-axis to separate the copies wider apart.\n\tp.z -= 2.0;\t\n\t\n\t// Copy sphere in the xz-plane via symmetry around the y-axis.\n\t//p.xz = rotsim( p.xz, 8.0 );\n\tp.xz = rotsim( p.xz, 8.0 + 6.0 * sin( iTime * 0.07 ) );\n\t// Offset sphere along the z-axis to separate copies.\n\tp.z -= 3.0;\n\n\t// Adding this provides a background for the object.\n\tp = sim( p, 6.0 );\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\t//p.xy = rotsim( p.xy, 3.0 );\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.09 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.55;\n\n\t// Copy sphere in the xy-plane via symmetry around the z-axis.\n\tp.xy = rotsim( p.xy, 8.0 + 6.0 * sin( iTime * 0.03 ) );\n\t// Offset sphere along the y-axis by a small amount.\n\tp.y -= 0.35;\n\n\t// ---------------------------------------------------\n\n\t// Objects\n\t//----------------------------------\n\t\n\t// spheres\t\n\tvec2 obj0 = obj0Def( p );\n\t\n\t// vertical box connectors in xz-plane\n\tvec2 obj1 = obj1Def( p );\n\t\n\t// horizontal box connectors in xy-plane\n\tvec2 obj2 = obj2Def( p );\n\t//----------------------------------\n\t\n\t// Distance comparisons to find closest object\n\t//--------------------------------------------\n\tvec2 closest = obj0.s < obj1.s ? obj0 : obj1;\n\tclosest = closest.s < obj2.s ? closest : obj2;\n\t\n\treturn closest;\t\n}\n\n//Scene End\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Note that original code does not perform aspect ratio adjustment here,\n\t// but below in the \"vec3 scrnCoord =\" equation.\n\t// vec2 vPos=-1.0+2.0*fragCoord.xy/scrnRes.xy;\n\t\n\t// wjb modified to include aspect ratio adjustment here.\n\t// Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t// xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 vPos = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n\t\n\t//----------------\n\t//Camera animation\n\tvec3 vuv=vec3(0,1,0);//Change camere up vector here\n\tvec3 vrp=vec3(0,0,0); //Change camere view here\n\t\n\t// camera rotate around y-axis in xz plane\n\t//vec3 prp=vec3(cos(iTime * 0.5),0.1,sin(iTime* 0.5))*8.0; //camera pos\n\t//vec3 prp=vec3(cos(iTime * 0.37),-sin( iTime * 0.41 ),sin(iTime* 0.43))*12.0; \n\t// camera rotate around x-axis in yz plane\n\t//vec3 prp=vec3(0.1,cos(iTime * 0.5),sin(iTime* 0.5))*8.0; //camera pos\n\t// camera rotate around z-axis in xy plane\n\t//vec3 prp=vec3(cos(iTime * 0.5),sin(iTime* 0.5),0.1)*8.0; //camera pos\n\t// Still camera from x units out of screen\n\tvec3 prp=vec3(0.0,0.0,-10.0); //For viewing individual components from front\n\t//-----------------\n\t\n\tfloat vpd=1.5;  // fov\n\t\n\t//Camera setup\n\tvec3 vpn=normalize(vrp-prp);\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\t\n\t// Original code does aspect ratio adjustment here.\n\t//vec3 scrCoord=prp+vpn*vpd+vPos.x*u*scrnRes.x/scrnRes.y+vPos.y*v;\n\t\n\t// wjb modified, since asp rat is done in vPos equation above.\n\tvec3 scrCoord=prp+vpn*vpd+vPos.x*u+vPos.y*v;\n\t\n\tvec3 scp=normalize(scrCoord-prp);\n\t\n\t//Raymarching\n\tconst vec3 e=vec3(0.1,0,0);\n\tconst float maxd=60.0; //Max depth\n\t\n\tvec2 s=vec2(0.1,0.0);\n\tvec3 c,p,n;\n\t\n\tfloat f=1.0;\n\tfor(int i=0;i<256;i++)\n\t{\n\t\tif (abs(s.x)<.001||f>maxd) break;\n\t\tf+=s.x;\n\t\tp=prp+scp*f;\n\t\t//s=inObj(p);\n\t\ts=map(p);\n\t}\n\t\n\tif (f<maxd)\n\t{\n\t\t// Determine color of object\n\t\t//--------------------------\n\t\tif (s.y==0.0)\t\n\t\t  \tc = obj0_c( p );\n\t\telse if ( s.y == 1.0 )\n\t\t    c = obj1_c( p );\n\t\telse\n\t\t\tc = obj2_c( p );\n\t\t\t\n\t\t//--------------------------\n\t\t\n\t\t//tetrahedron normal\n\t\tconst float n_er=0.01;\n\t\tfloat v1=map(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;\n\t\tfloat v2=map(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;\n\t\tfloat v3=map(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;\n\t\tfloat v4=map(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;\n\t\tn=normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n\t\t\n\t\tfloat b=dot(n,normalize(prp-p));\n\t\t//simple phong LightPosition=CameraPosition\n\t\tfragColor=vec4((b*c+pow(b,8.0))*(1.0-f*.01),1.0);\n\t}\n\telse fragColor=vec4(0,0,0.1,1); //background color\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[221, 335, 378, 378, 438], [440, 440, 471, 471, 558], [560, 677, 703, 703, 780], [782, 908, 934, 934, 1028], [1030, 1187, 1216, 1216, 1327], [1422, 1518, 1545, 1545, 1600], [1601, 1601, 1628, 1628, 1689], [1690, 1690, 1717, 1717, 1779], [1781, 1863, 1887, 1887, 2000], [2001, 2001, 2025, 2025, 2138], [2139, 2139, 2163, 2163, 2276], [2277, 2359, 2390, 2524, 4710], [4712, 4806, 4863, 5244, 7434]]}
{"id": "lldGz8", "name": "Twister++", "author": "Kastor", "description": "Based on https://www.shadertoy.com/view/lsX3WM ... just improved it a bit", "tags": ["twister", "oldshkool"], "likes": 1, "viewed": 116, "date": "1468014675", "time_retrieved": "2024-06-20T18:38:32.276443", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#define M_PI 3.1415926535897932384626433832795\n\t#define thick 0.003\n\t#define twister_thick 0.20\n    #define glow_strength 0.5\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 white = vec4(1.0,1.0,1.0,1.0);\n\t\n\tfloat twist = (M_PI / 360.0 * (iTime * 150.0 + \n\t\t\t\t(uv.y * 240.0) * sin((((iTime * 150.0 / 2.0) + \n\t\t\t\t(uv.y * 240.0)) * 3.0 / 4.0) * M_PI / 220.0) ));\n\t\n\tfloat x0 = 0.5 + (cos(twist) * twister_thick);\n\tfloat x1 = 0.5 + (cos(0.5 * M_PI + twist) * twister_thick);\n\tfloat x2 = 0.5 + (cos(1.0 * M_PI + twist) * twister_thick);\n\tfloat x3 = 0.5 + (cos(1.5 * M_PI + twist) * twister_thick);\n\t\n\tfragColor = vec4(0.0,0.0,0.0,1.0);\n\n\tif (x0 < x1) {\n\t\tif ((abs(uv.x - x0) < thick) || (abs(uv.x - x1) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x0) && (uv.x < x1)) {\n            \tfragColor =  vec4(1.0,0.0,0.0,1.0) * glow_strength + (x1 - x0);\n \t\t\t}\n\t\t}\n\t}\n\tif (x1 < x2) {\n\t\tif ((abs(uv.x - x1) < thick) || (abs(uv.x - x2) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x1) && (uv.x < x2)) {\n              fragColor =  vec4(0.0,1.0,1.0,1.0) * glow_strength + (x2 - x1);\n\t\t\t}\n\t\t}\n\t}\n\tif (x2 < x3) {\n\t\tif ((abs(uv.x - x2) < thick) || (abs(uv.x - x3) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x2) && (uv.x < x3)) {\n              fragColor =  vec4(0.5,0.5,0.0,1.0) * glow_strength + (x3 - x2);\n\t\t\t}\n\t\t}\n\t}\n\tif (x3 < x0) {\n\t\tif ((abs(uv.x - x3) < thick) || (abs(uv.x - x0) < thick)) {\n\t\t\tfragColor = white;\n\t\t} else {\n\t\t\tif ((uv.x > x3) && (uv.x < x0)) {\n              fragColor =  vec4(0.5,0.0,0.5,1.0) * glow_strength + (x0 - x3);\n\t\t\t}\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1647]]}
{"id": "lldGzn", "name": "[Tutorial & Trans] Blobby", "author": "Imsure1200q_1UWE130", "description": "this is a translated version of vgs's \"[Tutorial] Blobby\".", "tags": ["raymarching", "constantic", "translated"], "likes": 2, "viewed": 512, "date": "1467729801", "time_retrieved": "2024-06-20T18:38:32.646001", "image_code": "// http://demosceneacademy.wordpress.com/\n// live coding: https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Tutorial bÃ¡sico sobre raymarching.\n// por Vinicius Graciano Santos (vgs).\n\n// Constants.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n// Distance Function.\nfloat map(vec3 p) {\n    float v = 2.5*iTime;\n    float r = 1.35 + 0.15*cos(10.0*p.y + v) + 0.15*cos(10.0*p.x + v);\n    return length(p) - r;\n}\n\n// The Gradient (number) in the distance function.\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n\tvec3 n = normalize(grad(ro + t*rd));\n    return vec3(0.3, 0.5, 0.7)*pow(1.0-dot(-rd, n), 1.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Prepare the ratio.\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.5); // something? of the radius.\n    vec3 rd = normalize(vec3(uv, -1.0)); // direction of the radius.\n    \n    // Loop of the raymarcher.\n    float t = 0.0, d = EPS;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (d < EPS || t > FAR) break;\n        t += d;\n    }\n\n    // Shading.\n    vec3 col = d < EPS ? shade(ro, rd, t) : mix(vec3(0.0), vec3(0.3, 0.5, 0.7), 2.0-length(uv)) ;\n    \n    // proccessor. \n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[275, 297, 316, 316, 439], [441, 492, 511, 511, 690], [692, 692, 731, 731, 829], [831, 831, 888, 914, 1552]]}
{"id": "lldGzr", "name": "Pixel Explosion", "author": "Leukbaars", "description": "improved version of my fireworks. Better spread, added gravity and flicker\nTo be used as retro effect shader.\n", "tags": ["explosion", "pixel", "fireworks"], "likes": 52, "viewed": 2041, "date": "1467779949", "time_retrieved": "2024-06-20T18:38:32.864345", "image_code": "float seed = 0.32; //----------------------------------------------------------starting seed\nconst float particles = 32.0; //----------------------------------------------change particle count\nfloat res = 32.0; //-----------------------------------------------------------pixel resolution\nfloat gravity = 0.72; //-------------------------------------------------------set gravity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \tfloat clr = 0.0;  \n    float timecycle = iTime-floor(iTime);  \n    seed = (seed+floor(iTime));\n    \n    //testing\n    float invres=1.0/res;\n    float invparticles = 1.0/particles;\n\n    \n    for( float i=0.0; i<particles; i+=1.0 )\n    {\n\t\tseed+=i+tan(seed);\n        vec2 tPos = (vec2(cos(seed),sin(seed)))*i*invparticles;\n        \n        vec2 pPos = vec2(0.0,0.0);\n        pPos.x=((tPos.x) * timecycle);\n\t\tpPos.y = -gravity*(timecycle*timecycle)+tPos.y*timecycle+pPos.y;\n        \n        pPos = floor(pPos*res)*invres; //-----------------------------------------comment this out for smooth version \n\n    \tvec2 p1 = pPos;\n    \tvec4 r1 = vec4(vec2(step(p1,uv)),1.0-vec2(step(p1+invres,uv)));\n    \tfloat px1 = r1.x*r1.y*r1.z*r1.w;\n        float px2 = smoothstep(0.0,200.0,(1.0/distance(uv, pPos+.015)));//added glow\n        px1=max(px1,px2);\n        \n\t    clr += px1*(sin(iTime*20.0+i)+1.0);\n    }\n    \n\tfragColor = vec4(clr*(1.0-timecycle))*vec4(4, 0.5, 0.1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lldGzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 381, 438, 438, 1471]]}
{"id": "llt3DN", "name": "011 soft min", "author": "kakaxizhhgjh", "description": "soft min, original: https://www.shadertoy.com/view/Ml3Gz8\nreference: http://homepages.dcc.ufmg.br/~vgs/blog/smin/", "tags": ["softmin"], "likes": 3, "viewed": 133, "date": "1469447488", "time_retrieved": "2024-06-20T18:38:32.864345", "image_code": "float plot(float a, float b, float k) {\n\treturn smoothstep(3.0 / iResolution.y * sqrt(1.0 + k * k), 0.0, abs(a - b));\n}\n\nfloat fsin(float x) {\n\treturn sin(x * 4.0) * 0.5;\n}\n\nfloat dfsin(float x) {\n\treturn cos(x * 4.0) * 2.0;\n}\n\nfloat fexp(float x) {\n\treturn exp(-x) * 0.3 - 0.5;\n}\n\nfloat dfexp(float x) {\n\treturn exp(-x) * -0.3;\n}\n\nfloat smin(float x, float k) {\n    float a = fsin(x);\n    float b = fexp(x);\n\tfloat h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nfloat dsmin(float x, float k) {\n\treturn (smin(x + 0.001, k) - smin(x, k)) / 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float k = 0.1 * (cos(iTime) + 1.0) + 0.01;\n    vec3 bg = mix(vec3(1.0), vec3(1.0, 0.0, 0.0), plot(uv.y, fsin(uv.x), dfsin(uv.x)));\n    bg = mix(bg, vec3(0.0, 1.0, 0.0), plot(uv.y, fexp(uv.x), dfexp(uv.x)));\n    bg = mix(bg, vec3(0.0, 0.0, 1.0), plot(uv.y, smin(uv.x, k), dsmin(uv.x, k)));\n\tfragColor = vec4(bg,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llt3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 119], [121, 121, 142, 142, 172], [174, 174, 196, 196, 226], [228, 228, 249, 249, 280], [282, 282, 304, 304, 330], [332, 332, 362, 362, 508], [510, 510, 541, 541, 594], [596, 596, 653, 653, 1038]]}
{"id": "llt3RN", "name": "Gabor illusion 1e", "author": "FabriceNeyret2", "description": "inspired from https://www.youtube.com/watch?v=Jri0del_6t4", "tags": ["illusion", "gabor", "short"], "likes": 8, "viewed": 663, "date": "1468246207", "time_retrieved": "2024-06-20T18:38:33.058234", "image_code": "// color + const rotation version of  https://www.shadertoy.com/view/XdVXWd\n// inspired from https://www.youtube.com/watch?v=Jri0del_6t4\n\n\n// Gabor kernel\n#define G(U,a,v,r) exp(-.5*dot(U,U)*1e3/r/r) * sin( 100.*dot(U,sin(a+vec2(1.57,0)))-4.*(v)*iTime ) \n//#define G(U,a,v) exp(-.5*dot(U,U)*1e3) * sin( 100.*dot(U,sin(a+vec2(1.57,0)))-20.*(v)*sin(.5*iDate.w) ) \n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU = (U+U - (O.xy=iResolution.xy) ) / O.y;\n    O -= O;\n    \n    for (float i=-3.; i<4.; i++)    // 4 lines of 7 splats\n        for (float k=1.; k<1.1; k+=.2)  // variant: k=.2, ...\n        O +=   G( U-k*vec2(i/5.,  .7), 1.57, i*k,k)\n             + G( U-k*vec2(i/5., -.7), 1.57, i*k,k)\n             + G( U-k*vec2(-.7, i/5.), 0.  ,-i*k,k)\n             + G( U-k*vec2( .7, i/5.), 0.  ,-i*k,k);\n \n    float s = smoothstep(-.04,.04,max(abs(U.x),abs(U.y)) - .7);    // solid square\n  //float s = smoothstep(0.,.1,abs(max(abs(U.x),abs(U.y))-.7));    // frame\n\n    //s = 2.*(s-.5)*(O.x-.5)+.5; O = sqrt(vec4(cos(1.57*s + vec2(0,-1.57)), 0,1)); return;\n\tO = (.5 + .5*O) \n          * sqrt(vec4(cos(1.57*s + vec2(0,-1.57)), 0,1));          // colorization. (sqrt ~ tone mapping)\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llt3RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[255, 364, 402, 402, 1171]]}
{"id": "llt3Wr", "name": "Hypnotize 1", "author": "takkasila", "description": "Hypnotize distance field", "tags": ["distancefield"], "likes": 1, "viewed": 127, "date": "1468861546", "time_retrieved": "2024-06-20T18:38:33.058234", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv*2.0 - 1.0; // Map coordinate to -1, 1\n    uv.x *= iResolution.x/iResolution.y; // Stretch to aspect ration \n    \n    vec3 val = vec3(uv.x, uv.y, uv.x*uv.y) * length(abs(uv) - 0.7) * (sin(iTime/1.0)*3.0+4.0);\n    fragColor = vec4(fract(val*5.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llt3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 364]]}
{"id": "lltGRN", "name": "perlin + advection + flownoise", "author": "FabriceNeyret2", "description": "( mouse.x : show the trick .  see FLAGS & comments )\nCombining 3 phased regenerated texture maintains a constant contrats.\nIn the case of deformation, this also allows to keep the pattern unstretched.\nHere, texture is flownoise version of Perlin noise.", "tags": ["procedural", "texture", "perlin", "advection", "flownoise", "smartblend"], "likes": 34, "viewed": 1388, "date": "1468239868", "time_retrieved": "2024-06-20T18:38:33.846152", "image_code": "#define FLOWNOISE 1  // 0: regular Perlin   1: flownoise\n#define MODE 1       // 0: bozo   1: fire   2: cloud\n#define DISP 0       // 0: noise = value    1: noise = displacement (better with bozo)  \n#define SCALE 1.     // noise wavelength\n#define ROT  1       // 1: center fastest   2: center slowest  \n\n// --- texture advection: \n// from https://www.shadertoy.com/view/XsdXWn\n// cf https://hal.inria.fr/inria-00537472  ( also exist in Lagrangian form )\n// here, we only do the simple 3-phase version, each fading-in/out before too much distortion.\n\n// --- flow noise:  \n// from https://www.shadertoy.com/view/MstXWn\n// cf publi http://evasion.imag.fr/~Fabrice.Neyret/flownoise/index.gb.html\n//          http://mrl.nyu.edu/~perlin/flownoise-talk/\n// The raw principle is trivial: rotate the gradients in Perlin noise.\n// Complication: checkboard-signed direction, hierarchical rotation speed (many possibilities).\n// Not implemented here: pseudo-advection of one scale by the other.\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\n}\n\n// noise with flownoise extension (rotation of gradients)\nfloat level=1.;\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.-2.*f);\n#if FLOWNOISE\n    float t = exp2(level)* .4*iTime;\n    mat2  R = rot(t);\n#else\n    mat2  R = mat2(1,0,0,1);\n#endif\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    return 2.*mix( mix( dot( hash( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                        dot( hash( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                   mix( dot( hash( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                        dot( hash( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n}\n\n// --- turbulence: non-advected version ( for reference )\n\nfloat Mnoise( vec2 uv ) {\n#  if MODE==0\n    return noise(uv);                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(noise(uv)));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(noise(uv)));     // cloud like\n#endif\n}\n\nmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat turb( vec2 uv )\n{ \tfloat f;\n\t\n level=1.;\n    f  = 0.5000*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.2500*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.1250*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.0625*Mnoise( uv ); uv = m*uv; level++;\n\treturn f/.9375; \n}\n\n// --- turbulence: advected version \n\nvec4 early_turb( vec2 uv ) // sample a multiscale vector of linear noise to be interpolated\n{\n    vec4 N;\n    level = 1.;\n    N[0] = noise(uv); uv = m*uv; level++;\n    N[1] = noise(uv); uv = m*uv; level++;\n    N[2] = noise(uv); uv = m*uv; level++;\n    N[3] = noise(uv); uv = m*uv; level++;\n    return N;\n}\n\nvec4 Mnoise( vec4 N ) {   // apply non-linearity 1 (per scale) after blending\n#  if MODE==0\n    return N;                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(N));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(N));     // cloud like\n#endif\n}\n    \nfloat deferred_turb( vec4 N ) // apply cascade + optional non-linearity 2 (LUT) after blending\n{\n    N = Mnoise(N);   \n    float f;\t\n    f  = 0.5000*N[0]; \n\tf += 0.2500*N[1];\n\tf += 0.1250*N[2];\n\tf += 0.0625*N[3];\n\treturn f/.9375;     \n}\n\n\n// --- custom texture fetch\n//#define T(u)  texture(iChannel0, u )     // fetch noise texture\n  #define T(u)    early_turb((u)*3./(SCALE)) // fetch flownoise\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = mod(iTime,6.283)*(MODE==1 ? 2. : 1.);\n\tvec2  R = iResolution.xy,\n         uv = U / R - .5,\n          m = iMouse.xy / R.x; if (length(m)<.01) m = vec2(.5);\n    m-=.5;\n    \n    O-=O;\n    // --- 3-phased advection --------------------------------------\n    for (float i=0.; i<3.; i++) { \n        float ti = t+ 6.283/3.*i,\n              wi = (.5-.5*cos(ti))/1.5,\n#if ROT==1\n              v = 3./(.01+length(uv));\n#else        \n              v = 30.*length(uv);\n#endif\n        vec2 uvi = uv*rot(.3*(-.5+fract(ti/6.283))*v);\n        //if (i>0.) break; else wi=1.; // uncomment to show smearing if naive advection\n        //if (i>0.) break;             // uncomment to show advection trick with 1 layer\n        if (uv.x < m.x)                // left: result\n\t        O += T (.5 + uvi )  * wi;\n\t    else                           // right: grid showing the trick\n            O[int(i)] += texture(iChannel1, .5 + uvi ).x  * wi;  // show each phase in colors\n    }\n\n// --- only with procedural advection: deferred noise. \n  \n    if (uv.x < m.x)\n#if DISP\n        uv.x += .9*deferred_turb(O),\n        O = .5+.5*vec4 (sin(30.*(uv.x-uv.y)) ); \n#else\n#  if   MODE==0\n        O = vec4(.5 + deferred_turb(O));\n#  elif MODE==1\n        O = vec4(1,.6,.3,0)* 2.* pow(max(0.,deferred_turb(O)), 2.); \n#  elif MODE==2\n        O = mix(vec4(0,0,.3,1),vec4(2),.5 + .5*deferred_turb(O)); \n#  endif\n#endif\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lltGRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1036, 1122, 1143, 1143, 1262], [1264, 1338, 1361, 1361, 1903], [1905, 1964, 1989, 1989, 2216], [2259, 2259, 2282, 2282, 2516], [2518, 2556, 2649, 2649, 2861], [2863, 2863, 2886, 2940, 3143], [3149, 3149, 3245, 3245, 3385], [3388, 3548, 3589, 3589, 4982]]}
{"id": "lsGSWd", "name": "Crazed Coding", "author": "vox", "description": "Youtube:\nhttps://www.youtube.com/channel/UCDAkHLa83yN5dNWXjokGeEA\nLinkedin:\nhttps://www.linkedin.com/in/ian-wesson-65112592?trk=nav_responsive_tab_profile", "tags": ["crazedcoding"], "likes": 6, "viewed": 481, "date": "1467338681", "time_retrieved": "2024-06-20T18:38:35.179541", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*8.0)/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return flux(eyes+seedling)*eyes+teeth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        hit.rgb += demon(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n    float stars = mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n\n    float map2 = (length(randomOffset))*PI*2.0;\n\n    float twinkle = saw(time+map2);\n\n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = GR*(hit+vec4(flux(border+seedling+time)*(border-length(hit.rgb)/sqrt(3.0)), 1.0)*smoothstep(0.0, 1.0/GR/PI/GR, 1.0-border))*(antispeckle);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsGSWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[128, 1214, 1236, 1236, 1410], [1412, 1412, 1441, 1441, 1511], [1513, 1513, 1542, 1542, 1626], [1628, 1628, 1696, 1696, 1779], [1781, 1781, 1807, 1807, 2014], [2016, 2016, 2082, 2082, 2690], [2691, 2691, 2763, 2763, 2814], [2816, 2816, 2928, 2928, 3666], [3667, 3667, 3690, 3690, 3793], [3795, 3795, 3815, 3815, 4193], [4220, 4220, 4244, 4244, 4696], [4698, 4698, 4723, 4723, 5021], [5023, 5023, 5044, 5044, 5156], [5158, 5158, 5215, 5215, 8295]]}
{"id": "lsKXWd", "name": "Galactic Corridors", "author": "vox", "description": "My god... it's full of stars.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoes anyone know what movie that^s from?!\nShout out to NASA. YEH YEH YEAAAAH!", "tags": ["galacticcorridors"], "likes": 9, "viewed": 727, "date": "1467556713", "time_retrieved": "2024-06-20T18:38:36.549348", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\nvec3 hash3( vec2 p)\n\n{\n\n    vec3 q = vec3( dot(p,vec2(123.4,234.5)),\n\n    dot(p,vec2(456.7,321.0)),\n\n    dot(p,vec2(432.1,543.2)) );\n\n    return fract(sin(q)*12345.678);\n\n}\n\nvec4 galaxy(vec2 uv)\n{\n\tuv *= 5.0;\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux(time+seedling), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n    final *= 2.0;\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i != 0)\n        {\n\t\t\thit += galaxy(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n            \n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n\n        }\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n    float stars = mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n\n    float map2 = (stars+length(randomOffset))*PI*2.0;\n\n    float twinkle = saw(time+map2);\n\n    hit = hit+clamp(vec4(flux(map2+time)*PI+twinkle, 1.0)*stars*twinkle*PI, 0.0, 1.0)*clamp(1.0-(border), 0.0, 1.0);\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = hit;\n}\n", "image_inputs": [{"id": "4sf3Wl", "previewfilepath": "https://soundcloud.com/majorleaguewobs/space-odyssey-2001-theme-trap-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/majorleaguewobs/space-odyssey-2001-theme-trap-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKXWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[128, 1215, 1237, 1237, 1411], [1413, 1413, 1442, 1442, 1512], [1514, 1514, 1543, 1543, 1627], [1629, 1629, 1697, 1697, 1780], [1782, 1782, 1808, 1808, 2015], [2017, 2017, 2083, 2083, 2691], [2692, 2692, 2764, 2764, 2815], [2817, 2817, 2929, 2929, 3667], [3668, 3668, 3691, 3691, 3794], [3796, 3796, 3816, 3816, 4194], [4221, 4221, 4243, 4243, 4393], [4395, 4395, 4417, 4417, 5159], [5160, 5160, 5217, 5217, 8701]]}
{"id": "lt33RH", "name": "Pixel Contract/Expand", "author": "Leukbaars", "description": "useful for teleporter or charging weapon type effects in games", "tags": ["pixel", "contract"], "likes": 12, "viewed": 520, "date": "1467881053", "time_retrieved": "2024-06-20T18:38:36.810005", "image_code": "float seed = 0.69; //----------------------------------------------------------starting seed - change for different looks\nconst float particles = 100.0; //----------------------------------------------change particle count\nfloat res = 50.0; //-----------------------------------------------------------pixel resolution (higher is smaller)\nfloat direction =1.0; //-------------------------------------------------------0.0 for expand, 1.0 for contract\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \tfloat clr = 0.0;  \n     \n    //seed = (seed+floor(iTime));\n    \n    float iSphere = 1.05-length(uv);\n    if(iSphere>0.0)\t//remove tests outside of influence sphere\n    {\n    \n    \tfor( float i=0.0; i<particles; i+=1.0 )\n        {\n\t\t\tseed+=i+tan(seed);\n      \t  \tvec2 tPos = (vec2(cos(seed),sin(seed)));\n        \n            vec2 pPos = vec2(0.0,0.0);\n       \t \tfloat speed=i/particles+.4713*(cos(seed)+1.5)/1.5;\n        \tfloat timeOffset = iTime*speed+(speed);\n        \tfloat timecycle = timeOffset-floor(timeOffset); \n        \n       \t \tpPos=mix(tPos,pPos,1.0+direction-timecycle);\n        \n      \t  \tpPos = floor(pPos*res)/res; //-----------------------------------------comment this out for smooth version \n\n    \t\tvec2 p1 = pPos;\n    \t\tvec4 r1 = vec4(vec2(step(p1,uv)),1.0-vec2(step(p1+1.0/res+i/particles/res,uv)));\n    \t\tfloat px1 = r1.x*r1.y*r1.z*r1.w*speed;\n        \n\t   \t \tclr += px1;\n    \t}\n    }\n\tfragColor = (vec4(clr)*vec4(0.1, 2.5, 0.5,1.0))*(1.0-length(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt33RH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 452, 509, 509, 1553]]}
{"id": "lt33z7", "name": "Ray Marching: Part 2", "author": "jlfwong", "description": "Part 2 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching"], "likes": 112, "viewed": 179278, "date": "1468393135", "time_retrieved": "2024-06-20T18:38:37.767655", "image_code": "/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specual color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt33z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[375, 464, 499, 499, 539], [541, 781, 815, 815, 852], [854, 1275, 1366, 1366, 1672], [1687, 1941, 2006, 2006, 2138], [2140, 2229, 2258, 2258, 2568], [2570, 3062, 3202, 3202, 3792], [3794, 4164, 4249, 4249, 5049], [5052, 5052, 5109, 5109, 5781]]}
{"id": "lt33zM", "name": "Rain Generator", "author": "TheBinaryCodeX", "description": "A procedural rain generator.", "tags": ["procedural"], "likes": 19, "viewed": 839, "date": "1468347367", "time_retrieved": "2024-06-20T18:38:37.767655", "image_code": "\nconst int LAYERS = 6;             // number of layers of drops\n\nconst float SCALE = 128.0;        // overall scale of the drops\nconst float LENGTH = 16.0;        // length of the drops\nconst float LENGTH_SCALE = 0.8;   // how much the drop length changes every layer\nconst float FADE = 0.6;           // how much the drops fade every layer\n\nconst float SPEED = 8.0;          // how fast the drops fall\n\nconst vec3 DROP_COLOR = vec3(0.54, 0.8, 0.94);\nconst vec3 BG_COLOR = vec3(0.23, 0.38, 0.6);\n\nhighp float rand(vec2 co)\n{\n\thighp float a = 12.9898;\n\thighp float b = 78.233;\n\thighp float c = 43758.5453;\n\thighp float dt = dot(co.xy, vec2(a, b));\n\thighp float sn = mod(dt, 3.14);\n\n\treturn fract(sin(sn) * c);\n}\n\nfloat rainFactor(vec2 uv, float scale, float dripLength, vec2 offset, float cutoff)\n{\n    vec2 pos = uv * vec2(scale, scale / dripLength) + offset;\n    vec2 dripOffset = vec2(0, floor(rand(floor(pos * vec2(1, 0))) * (dripLength - 0.0001)) / dripLength);\n    float f = rand(floor(pos + dripOffset));\n    \n    return step(cutoff, f);\n}\n\nvec4 over(vec4 a, vec4 b)\n{\n    return vec4(mix(b, a, a.a).rgb, max(a.a, b.a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec4 finalColor = vec4(0);\n    \n    float dropLength = LENGTH;\n    float alpha = 1.0;\n    \n    for (int i = 0; i < LAYERS; i++)\n    {\n        float f = rainFactor(uv, SCALE, dropLength, vec2(SCALE * float(i), iTime * SPEED), 0.95);\n        \n        vec4 color = vec4(DROP_COLOR, f * alpha);\n        \n        finalColor = over(finalColor, color);\n        \n        dropLength *= LENGTH_SCALE;\n        alpha *= FADE;\n    }\n    \n    finalColor = over(finalColor, vec4(BG_COLOR, 1.0));\n    \n\tfragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt33zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[376, 712, 797, 797, 1045], [1047, 1047, 1074, 1074, 1128], [1130, 1130, 1185, 1185, 1819]]}
{"id": "lt3GW8", "name": "testttttttttttttt", "author": "liam77", "description": "test", "tags": ["test"], "likes": 0, "viewed": 623, "date": "1468973993", "time_retrieved": "2024-06-20T18:38:37.767655", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0.5+sin(((uv[0])*(sin(iTime)*30.0-200.0))*(uv[0]*(iTime*.1))),\n                     0.5+cos(((uv[1])*(sin(iTime)*30.0-200.0))*fragCoord[0]),\n                     0.5+0.5*sin(((uv[1]*.9)*(tan(iTime)/.1)/(uv[0]*.00006))),\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3GW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 370]]}
{"id": "lt3GWn", "name": "Colour Perlin", "author": "akohdr", "description": "Playing around with colour transforms on Perlin field.", "tags": ["noise", "perlin", "color"], "likes": 5, "viewed": 302, "date": "1468690805", "time_retrieved": "2024-06-20T18:38:38.107267", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution\n#define T iTime\n\nvoid mainImage( out vec4 k, vec2 p )\n{\n\t#define rot(p,a) vec2 sc=sin(vec2(a,a+1.6)); p*=mat2(sc.y,-sc.x,sc);\n\n    #define A vec3(0,1,157)\n    #define B {vec2 m=fract(p),l=dot(p-m,A.yz)+A.xz,r=mix(fract(57.*sin(l++)),fract(57.*sin(l)),(m*=m*(3.-m-m)).x);k+=mix(r.x,r.y,m.y)/(s+=s);p*=mat2(1,1,1,-1);}\n\n\tp+= 2e2*sin(5.*(T/9.+vec2(.8,-.8)));\t\t\t\t\t// circular movement\n\tp = 5.*(p+2.*R.xy)/R.y;\t\t\t\t\t\t\t\t\t// scaling\n\trot(p,T/22.);\t\t\t\t\t\t\t\t\t\t\t// slow field rotation\n\n    float s = 1.; k = vec4(0);\t\t\t\t\t\t\t\t// init\n\t// Perlin noise (expansion of iteration #define B for readability)\n    // (based on refactoring of https://www.shadertoy.com/view/MlsXDr)\n\t{ vec2 m = fract(p),\n           l = dot(p-m, A.yz) + A.xz,\n           r = mix(fract(57.*sin(l++)), fract(57.*sin(l)), (m*= m*(3.-m-m)).x);\n           k+= mix(r.x, r.y, m.y) / (s+=s);\n           p*= mat2(1,1,1,-1); }\n\n    B B B // remaining unrolled loop iterations\n\n// cycles through plain noise then couple temporal colour transforms\nif(mod(T,12.)>8.)\n\tk = sin(2.*sin(k*22.+T*4.)+p.yxyy-p.yyxy*.5);\t\t\t// colour transform\nelse if(mod(T,12.)>4.)\n\tk = sin(length(p)/2.*sin(k*22.+T*4.)+p.yxyy-p.yyxy*.5);\t// colour rings on noise\n\n// options for recombining rgb\n//\tk = vec4(vec3(dot(k.rgb,vec3(1))),1);\t\t\t\t\t// B/W\n//\tk = vec4(dot(k,k/.9)/4.);\t\t\t\t\t\t\t\t// gray\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3GWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 167, 205, 205, 1466]]}
{"id": "lt3Gz8", "name": "Flower Hive", "author": "zackpudil", "description": "A kaliset fractal with no mirroring offsets.", "tags": ["raymarching", "fractal", "distancefields"], "likes": 23, "viewed": 383, "date": "1467864712", "time_retrieved": "2024-06-20T18:38:38.107267", "image_code": "// basic 2d rotation.\nvoid rotate(inout vec2 p, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\n\tp = mat2(c, s, -s, c)*p;\n}\n\nvec4 orb;\nfloat de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n\tvec4 c = vec4(p, 0);\n\n\trotate(q.xy, iTime*step(-0.5, -length(p)));\n\trotate(q.xz, 2.*iTime*step(-0.5, -length(p)));\n\torb = vec4(10000.0);\n\n\tfor(int i = 0; i < 10; i++) { //kaliset fractal with no mirroring offset\n\t\tq.xyz = abs(q.xyz);\n\t\tfloat r = dot(q.xyz, q.xyz);\n\t\tq /= clamp(r, 0.0, 1.7);\n\t\t\n\t\tq = 2.0*q - vec4(2, 1, 2, 0); // julia offset.\n\t\t\n\t\torb = min(orb, vec4(abs(q.xyz), sqrt(r)));\n\t}\n\t\n\treturn (length(q.xy)/q.w - 0.003); // cylinder primative instead of a sphere primative.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // pixel coords\n\tvec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3(0);\n\t\n    // ray origin and ray direction.\n\tvec3 ro = 1.3*vec3(cos(iTime), (1.0/1.3)*sin(iTime*0.3), -sin(iTime));\n\tvec3 ww = normalize(vec3(0, 0.5*sin(iTime*0.3), 0) - ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 1.97*ww);\n\t\n    // ray marching.\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(abs(d) < 0.001*t || t >= 1000.0) break;\n\t\tt += d*0.75; // fudge factor = 1/4.\n\t}\n\t\n\tif(t < 1000.0) {\n        // position and normal.\n\t\tvec3 pos = ro + rd*t;\n\t\tvec2 eps = vec2(0.001, 0.0);\n\t\tvec3 nor = normalize(vec3(\n\t\t\tde(pos + eps.xyy) - de(pos - eps.xyy),\n\t\t\tde(pos + eps.yxy) - de(pos - eps.yxy),\n\t\t\tde(pos + eps.yyx) - de(pos - eps.yyx)\n\t\t));\n\t\t\n        // ambient occlusion.\n\t\tfloat o = 0.0, w = 1.0, s = 0.003;\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfloat d = de(pos + nor*s);\n\t\t\to += (s - d)*w;\n\t\t\ts += s/(float(i) + 1.0);\n\t\t}\n\t\t\n        // color by orbit trap.\n\t\tvec3 oc = vec3(0.3, 0.3, 1.0)*orb.x\n\t\t\t+ vec3(0.1, 0.5, 0.6)*orb.y\n\t\t\t+ vec3(0.3, 0.3, 1.0)*orb.z\n\t\t\t+ vec3(0.9, 0.3, 0.5)*orb.w;\n\t\t\n        // mix color with base color.\n\t\tcol = mix(vec3(1), 3.0*oc, 0.4);\n\t\t\n        // apply ambient occlusion.\n\t\tcol *= vec3(1.0 - clamp(o, 0.0, 1.0));\n\t}\n\t\n    // mix with black fog...good fake for attenuation.\n\tcol = mix(col, vec3(0), 1.0 - exp(-0.5*t));\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt3Gz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 22, 58, 58, 125], [137, 137, 155, 155, 666], [668, 668, 725, 745, 2252]]}
{"id": "ltc3DM", "name": "Colorful mandelbrot", "author": "Flai", "description": "It's a new mandelbrot-shader, derived from https://www.shadertoy.com/view/lsX3W4. \n\nI made sure you can see which points are actually part of the mandelbrot-set, and also reworked the coloring to not only be black / white. ", "tags": ["2d", "fractal"], "likes": 3, "viewed": 99, "date": "1469571922", "time_retrieved": "2024-06-20T18:38:38.695034", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This shader computes the distance to the Mandelbrot Set for everypixel, and colorizes\n// it accoringly.\n// \n// Z -> ZÂ²+c, Z0 = 0. \n// therefore Z' -> 2Â·ZÂ·Z' + 1\n//\n// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n// G'(c) = Z'/Z/2^n\n//\n// So the distance is |G(c)|/|G'(c)| = |Z|Â·log|Z|/|Z'|\n//\n// More info here: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = .7 - .5 * cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i < 1024; i++ )\n    {\n        if( m2>8192.0 ) {\n            break;\n        }\n\n        \n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n    \n    \n    if( m2 < 8192.0 ) {\n        fragColor = vec4 ( 0 );\n        return;\n    }\n\n\tfloat d = 0.5 * sqrt(dot(z,z)/dot(dz,dz)) * log(dot(z,z));\n\n\t\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    vec3 col = vec3( 0 );\n    \n    fragColor = hsv_to_rgb( d * d , .95 - .3 * d, .25 + .75 * d, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltc3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[126, 540, 593, 593, 1168], [1171, 1171, 1228, 1228, 2190]]}
{"id": "ltc3R7", "name": "Gas Explosion", "author": "TimoKinnunen", "description": "After much trial and error a supernova explosion has become a more earthly gasoline/gas explosion. You can zoom in with 1,2,3 keys and mouse left-right axis orbits the camera. Now with more substance and better fade-in/fade-outs!", "tags": ["explosion", "fire", "volumetric", "smoke", "looping", "gas"], "likes": 67, "viewed": 4745, "date": "1468376822", "time_retrieved": "2024-06-20T18:38:42.143793", "image_code": "// Based on https://www.shadertoy.com/view/lsySzd\n//\n// \"Volumetric explosion\" by Duke\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc) \n// and other previous shaders \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n//\n// And based on https://www.shadertoy.com/view/XlcGRn\n//\n// \"Space Elevator\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// And based on https://www.shadertoy.com/view/4djSRW\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n//\n// With varous small tweaks to have the effect play nice against a colorful background,\n// keeping the black smoky look.\n//\n// Explosion colors\nconst vec3 veDensityBeg  = vec3(0.22,0.16,0.046);\nconst vec3 veDensityEnd  = vec3(0.403,0.291,0.216);\nconst vec3 veMediaCenter = vec3(0.305,0.49,0.616);\nconst vec3 veMediaEdge   = vec3(0.918,0.796,0.495);\n// Sky colors\nconst vec3 veColSkyHigh = vec3(0.0, 0.1, 0.3);\nconst vec3 veColSkyLow  = vec3(0.2, 0.4, 0.6);\nconst vec3 veColStars   = vec3(0.8, 0.9, 1.0);\nconst float accuscale = -0.005;\nconst float scalestar = 18.1  ;\nconst float subdiv    = 11.714;\nconst float variable  = 0.612 ;\nconst float variable2 = 1.171 ;\n// Default\nconst bool veBOTH         = !false;\nconst bool veLEFT         = !true ;\nconst bool veLOW_QUALITY  = false;\nconst bool veDITHERING    = !true ;\nconst bool veTONEMAPPING  = false;\nconst bool veBackground   = true ;\nconst float veBackgroundCutoff      = 0.891;\nconst float veBackgroundCutoffStart = 0.387;\n\nvec4 iiMouse;\n#define iMouse iiMouse\n//-------------------\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define pi 3.14159265\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n    return (x < 0.) ? -1. : 1.;\n}\nvec2 sgn(vec2 v) {\n    return vec2(sgn(v.x),sgn(v.y));\n}\nvec3 sgn(vec3 v) {\n    return vec3(sgn(v.x),sgn(v.y),sgn(v.z));\n}\n\nvoid veR( inout vec2 p, in float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// iq's noise\nfloat veNoise( in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn 1. - 0.82 * mix(rg.x, rg.y, f.z);\n}\n\nfloat veFBM(vec3 p) {\n\treturn veNoise(p * .06125) * .5 + veNoise(p * .125) * .25\n\t\t\t+ veNoise(p * .25) * .125 + veNoise(p * .4) * .2;\n}\n\nfloat veSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat veExplosionRadius(float maxRadius, float veProgress) {\n    return mix(1.0/8.0,1.0, sqrt(veProgress))*maxRadius;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float veNudge = 100.3 * 4.;\t// size of perpendicular vector\nfloat veNormalizer = 1.0 / sqrt(1.0 + veNudge * veNudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat veSpiralNoiseC(vec3 p) {\n\tfloat n = 0.0; // noise amount\n\tfloat iter = 2.0;\n\tfor (int i = 0; i < 8; i++) {\n\t\t// add sin and cos scaled inverse with the frequency\n\t\tn += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter; // abs for a ridged look\n\t\t// rotate by adding perpendicular and scaling down\n\t\tp.xy += vec2(p.y, -p.x) * veNudge;\n\t\tp.xy *= veNormalizer;\n\t\t// rotate on other axis\n\t\tp.xz += vec2(p.z, -p.x) * veNudge;\n\t\tp.xz *= veNormalizer;\n\t\t// increase the frequency\n\t\titer *= 1.733733;\n\t}\n\treturn n;\n}\n\nfloat veVolumetricExplosion(vec3 p, float radius, float maxRadius, float veProgress) {\n    float sdSphere = veSphere(p, radius)*(4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(8.0,1.0)/maxRadius);\n    float noise1 = (veLOW_QUALITY) ? veNoise(p * 12.5) * .2 : veFBM(p * 50.);\n    float age = mix(2.0, -7.5, 1.-pow(1.-veProgress,2.5));\n    float noise2 = veSpiralNoiseC(p.zxy * 0.4132 + 0.333*vec3(0,0,1) * (25.*veProgress+max(0.,iMouse.x-15.0) * 0.1));\n    float result = min(0.,sdSphere)*.999 +\n        (0.25+1.75*veProgress+3.*veProgress*veProgress+4.*veProgress*veProgress*veProgress)*max(0.,sdSphere) +\n        0.999*noise1 +\n        0.999*age +\n        0.999*(noise2+1.0/1.25) * 1.25;\n\treturn result;\n}\n\nfloat veMap(vec3 p, float maxRadius, float count, float veProgress) {\n\tveR(p.yz, -6. * (1.-sqrt(veProgress)));\n\tveR(p.zx, count + iMouse.x * 0.008 * pi + 0.0*4. * veProgress);\n    //p += so;\n    //p -= so;\n    if(maxRadius == 1.0) {\n    return veVolumetricExplosion(p * 1.*8.0, \n                                               4. * 1.92 *.25/1.92 * veProgress* veExplosionRadius(8.0,veProgress),\n                                               4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(8.0,1.0),\n                                               veProgress)/ 1.;\n    }\n    float VolExplosion = veVolumetricExplosion(p * 1.5, \n                                               4. * 1.92 *.25/1.92 * veProgress* veExplosionRadius(maxRadius,veProgress),\n                                               4. * 1.92 *.25/1.92 * 1.0*        veExplosionRadius(maxRadius,1.0),\n                                               veProgress)/ 1.5;\n\treturn VolExplosion;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 veComputeColor(float density, float radius, float maxRadius) {\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix(veDensityBeg, veDensityEnd, 1. - density);\n\n\t// color added to the media\n\tvec3 colCenter = 7. * veMediaCenter;\n\tvec3 colEdge = 1.5 * veMediaEdge;\n\tresult *= mix(colCenter, colEdge, min((radius + .05) / .9, 1.15));\n\n\treturn result;\n}\n\nvec3 veSphereIntersect(vec3 ro, vec3 rd, vec3 so, float radius) {\n    vec3 sr = ro - so;\n    float tsr = dot(sr, rd);\n    float delta = radius * radius - dot(sr, sr) + tsr * tsr;\n    float deltasqrt = (delta < 0.0) ? 0.0f : sqrt(delta);\n    float t0 = -tsr - deltasqrt;\n    float t1 = -tsr + deltasqrt;\n    return vec3(t0, t1, -tsr);\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 veToneMapFilmicALU(vec3 _color) {\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2 * _color + vec3(0.5)))\n\t\t\t/ (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvec3 veAddZoom(vec3 rd, vec3 ro) {\n\tconst float KEY_1 = 49.5 / 256.0;\n\tconst float KEY_2 = 50.5 / 256.0;\n\tconst float KEY_3 = 51.5 / 256.0;\n\tfloat key = 0.0;\n\tkey += 0.7 * texture(iChannel1, vec2(KEY_1, 0.25)).x;\n\tkey += 1.4 * texture(iChannel1, vec2(KEY_2, 0.25)).x;\n\tkey += 2.1 * texture(iChannel1, vec2(KEY_3, 0.25)).x;\n\treturn ro - (ro - rd) * key * 1.6 / 6.;\n}\n\nconst vec4 vecHashA4 = vec4(0., 1., 57., 58.);\nconst vec3 vecHashA3 = vec3(1., 57., 113.);\nconst float vecHashM = 43758.54;\n\nvec4 veHashv4f(float p) {\n\treturn fract(sin(p + vecHashA4) * vecHashM);\n}\n\nfloat veNoisefv2(vec2 p) {\n\tvec4 t;\n\tvec2 ip, fp;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tt = veHashv4f(dot(ip, vecHashA3.xy));\n\treturn mix(mix(t.x, t.y, fp.x), mix(t.z, t.w, fp.x), fp.y);\n}\n\nfloat veNoisefv3(vec3 p) {\n\tvec4 t1, t2;\n\tvec3 ip, fp;\n\tfloat q;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tq = dot(ip, vecHashA3);\n\tt1 = veHashv4f(q);\n\tt2 = veHashv4f(q + vecHashA3.z);\n\treturn mix(mix(mix(t1.x, t1.y, fp.x), mix(t1.z, t1.w, fp.x), fp.y),\n\t\t\tmix(mix(t2.x, t2.y, fp.x), mix(t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat veFbm3(vec3 p) {\n\tfloat f, a;\n\tf = 0.;\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\tf += a * veNoisefv3(p);\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn f;\n}\n\nfloat veFbmn(vec3 p, vec3 n) {\n\tvec3 s;\n\tfloat a;\n\ts = vec3(0.);\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\ts += a * vec3(veNoisefv2(p.yz), veNoisefv2(p.zx), veNoisefv2(p.xy));\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn dot(s, abs(n));\n}\n\nvec3 veSpaceCol(vec3 ro, vec3 rd) {\n\tvec3 rds, col;\n\trds = floor(2000. * rd);\n\trds = 0.00015 * rds + 0.1 * veNoisefv3(0.0005 * rds.yzx);\n\tfor (int j = 0; j < 19; j++)\n\t\trds = abs(rds) / dot(rds, rds) - 0.9;\n\tcol = veColStars * min(1., 0.5e-3 * pow(min(6., length(rds)), 5.));\n\tfloat s = pow(max(0., abs(dot(rd, vec3(0.0, 1.0, 0.0)))), 1.60);\n\tcol = veColSkyLow + col * (1. - smoothstep(0.9, 1., s));\n\ts = pow(s, 128.);\n\tcol += veColSkyHigh * (0.2 * s + 0.9 * pow(s, 8.));\n\treturn col;\n}\n//----------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n// From iq's website\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat parabola(float x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), k);\n}\nvec4 parabola(vec4 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec4(k));\n}\nvec3 parabola(vec3 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec3(k));\n}\nfloat pcurve(float x, float a, float b) {\n\tfloat k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));\n\treturn k * pow(x, a) * pow(1.0 - x, b);\n}\nvec3 veStars(vec3 ro, vec3 rd) {\n\tvec3 bs[8];\n\tvec3 srd = rd;\n\tfloat size = floor(subdiv);\n\trd *= length(rd) / max(abs(rd.x), max(abs(rd.y), abs(rd.z)));\n\trd *= size;\n\tvec3 lower = floor(rd + 0.5);\n\tvec3 point = rd - lower;\n\tvec3 ba = rd - ro;\n\tvec3 nba = normalize(ba);\n\tfloat ilba = 1.0 / dot(ba, ba);\n\tvec3 nbatilba = nba * ilba;\n\tfloat d = 99999999.0;\n    \n\tfor (int xi = -1; xi <= 1; xi++) {\n\t\tfor (int yi = -1; yi <= 1; yi++) {\n\t\t\tfor (int zi = -1; zi <= 1; zi++) {\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tvec3 box = lower + vec3(float(xi), float(yi), float(zi));\n\t\t\t\t\tvec4 a = vec4(0.0);\n\t\t\t\t\tfor (int t = 0; t < 4; t++) {\n\t\t\t\t\t\tfloat v = float(t + 1) * .152;\n\t\t\t\t\t\tvec3 pos = (box * v + float(5 * i));\n\t\t\t\t\t\ta += hash43(pos);\n\t\t\t\t\t}\n\t\t\t\t\tvec3 local = a.xyz / 4.0 - 0.5;\n\t\t\t\t\tfloat dist = sdCapsule(ro + srd, ro, ro + box + local,\n\t\t\t\t\t\t\ta.w * accuscale);\n\t\t\t\t\td = min(d, dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvec3 result = pow(\n\t\t\tclamp(pcurve(d * scalestar, 0.0, 1.0 + 31.0 * variable), 0.0, 1.0),\n\t\t\tvariable2) * veColStars;\n\treturn result;\n}\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1)*step(t1.zxy,t1);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 oiMouse=clamp(iMouse,vec4(0.),iResolution.xyxy-1.);\n    iMouse=vec4(0);\n\tvec2 uv = fragCoord / iResolution.xy;\n    float veProgress = mod(iTime * 0.1, 1.);\n    float count = floor(iTime * 0.1);\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y-vec2(0,0.5), 1.));\n\tvec3 ro = vec3(0., 8., -16.);\n\tro = veAddZoom(rd, ro);\n    if(iMouse.z>0.) {\n        veR(rd.yz, max(0.,iMouse.y-50.) / iResolution.y * 2.508 * pi);\n    } else {\n        float a = pi*sin(iTime*.5)*.375*0.0;\n        veR(rd.yz, a);\n    }\n    float tmin=-1.0;\n    vec3 nor;\n    vec3 pos;\n    vec3 colb;\n\n    float nearest = 1e9;\n    vec3 nearestOrigin = vec3(-1);\n    float nearestProgress = 0.0;\n\n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld = 0., td = 0., w = 0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat density = 1., t = 0.;\n\tconst float h = 0.1;\n\tvec4 sum = vec4(0.0);\n    //veProgress = fract(veProgress*1.+0.5+0.0*((gl_FragCoord.x>=.5*iResolution.x)?.3:.7));\n    vec3 so = 0.0*((uv.x>=0.5)?vec3(7.0+2.0*veProgress,-11.+17.*veProgress,5):vec3(-7.0-2.0*veProgress,-12.+18.*veProgress,5))+0.5;\n    float maxRadius = 16.0;\n    vec4 fix = vec4(39,59,759,420);//oiMouse;\n    vec4 fix1 = exp2((  mod(fix,(2.*vec4(20,15,20,15)))/(2.*vec4(20,15,20,15)-1.))*2.0-1.);\n    vec4 fix2 = exp2((floor(fix/(2.*vec4(20,15,20,15)))/(1.*vec4(20,15,20,15)-1.))*2.0-1.);\n    fix1=mix(fix1,vec4(0.5),smoothstep(0.5,0.75,veProgress));\n    fix2=mix(fix2,vec4(0.5),smoothstep(0.5,0.75,veProgress));\n    //fix2.x=1.0;\n    vec3 intersect = veSphereIntersect(ro, rd, so, veExplosionRadius(maxRadius,veProgress));\n\tfloat min_dist = intersect.x, max_dist = intersect.y;\n    const bool veDev = true;\n\tif (min_dist != max_dist && max_dist > 0.0) {\n\t\tt = min_dist;\n\t\t// raymarch loop\n\t\tfor (int i = 0; i < 86; i++) {\n\t\t\tif (veLOW_QUALITY && i >= 56) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec3 pos = ro + t * rd;\n            //pos= (pos-0.5)*pow(vec3(1.+abs(0.5-uv.x)*2.),vec3(0,-0.75,0))+0.5;\n\t\t\t// Loop break conditions.\n\t\t\tif (td > 0.99 || t > max_dist)\n\t\t\t\tbreak;\n\t\t\t// evaluate distance function\n\t\t\tfloat d = veMap(pos-so, maxRadius, count, veProgress);\n\t\t\tif (!veBOTH && veLEFT || veBOTH && uv.y < 0.5) {\n                d = (abs(d) + 0.07/fix1.x);\n            } else {\n                float v = 1.-(1.-veProgress)*sqrt(1.-veProgress);\n                v = sqrt(veProgress);\n                v = smoothstep(0.03125,0.5,1.0-v);\n                v = pcurve(veProgress,0.25,4.5);\n                d = mix(abs(d) + 0.07/fix1.x, d, v);\n            }\n\t\t\t// change this string to control density\n\t\t\td = max(mix(d, 10.0, 0.*smoothstep(0.75,1.0,veProgress)), 0.00000003); //0.03 less detail\n\t\t\t// point light calculations\n\t\t\tvec3 ldst = so - pos;\n            \n\t\t\tfloat lDist = max(length(ldst)*fix2.x, 0.01);//0.1, 0.000000000000001 it's all the same\n\t\t\t// the color of light\n\t\t\tvec3 lightColor = vec3(1.0, 0.5, 0.25);\n\t\t\t// bloom\n\t\t\tvec3 halo = lightColor / exp(pow(lDist, 3.) * 0.108/fix1.z);\n\t\t\tsum.rgb += halo * (0.0333*fix2.z * smoothstep(0.5, 0.1, veProgress) + smoothstep(.125, .0, veProgress));\n            if(!veDev && h >= d) {\n\t\t\t    td += 1. / 70. + (sin(7.*d+ veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7));\n\n//\t\t\t\tld = (d < h*fix) ? h*fix - d : max(0.,0.2*fix - d);\n\t\t\t\t// compute weighting factor\n//\t\t\t\tw = (1. - td) * ld;\n\t\t\t\t// accumulate density\n//\t\t\t\ttd += w/fix;\n//\t\t\t\ttd += (d < h*fix) ? 1. / 200000. : 1. / 70.*fix + (sin(7.*d + veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7));\n\n            } else {\n\t\t\t\t// compute local density\n                float choice = smoothstep(-0.5*h,0.5*h, d - h);\n\t\t\t\tld = mix(h - d, max(0.2*fix1.w - d,0.), choice);\n\t\t\t\t// compute weighting factor\n\t\t\t\tw = (1. - td) * ld;\n\t\t\t\t// accumulate density\n\t\t\t\ttd += w/fix2.w;\n\t\t\t\ttd += mix(1./((fix1.y-0.5)/1.5*199930.+70.), fix2.y*1. / 70. + (sin(7.*d + veProgress)+1.-veProgress)/128.*smoothstep(.3, .125, abs(veProgress-0.7)),choice);\n\t\t\t\tvec4 col = vec4(veComputeColor(td, lDist, maxRadius), mix(td, td * w, choice));\n\t\t\t\t// emission\n\t\t\t\tsum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\n\t\t\t\t// uniform scale density\n\t\t\t\tcol.a *= 0.2;\n\t\t\t\t// colour by alpha\n\t\t\t\tcol.rgb *= col.a;\n\t\t\t\t// alpha blend in contribution\n\t\t\t\tsum = sum + col * (1.0 - sum.a);\n            }\n            float dither;\n\t\t\tif (veDITHERING) {\n\t\t\t\t// idea from https://www.shadertoy.com/view/lsj3Dw\n\t\t\t\tdither = texture(iChannel2, vec2(120.0* uv.y, -280.0* uv.x+ 0.5* sin(4.* veProgress+ 480.0* uv.y))).r;\n            } else {\n\t\t\t\tdither = 0.5;\n            }\n            d *= .8 + 0.08 * dither;\n\t\t\t// trying to optimize step size\n            float stepMult = (veLOW_QUALITY) ? 0.25 : max(0.08 * min(length(ldst), d), 0.16);\n            t += max(d * stepMult, 0.01);\n\t\t}\n\t\t// simple scattering\n        sum *= 1. / exp(ld * 0.2) * ((veLOW_QUALITY) ? 0.9 : 0.8);\n\t\tsum = clamp(sum, 0.0, 1.0);\n\t\tsum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\n\t}\n\n    float pass = smoothstep(veBackgroundCutoff, veBackgroundCutoffStart, td);\n    sum.xyz += colb * pass * (1.0 - sum.a);\n    if(tmin>0.0){sum.a=1.0;}\n\tif (veBackground) {\n\t\t// stars background\n\t\t//vec3 stars = vec3(veNoise(rd * 200.0) * 0.5 + 0.5);\n\t\tvec3 stars = veStars(ro, rd);\n\t\tvec3 starbg = mix(veColSkyHigh, veColSkyLow,\n\t\t\t\tabs(1.5 * dot(normalize(rd), vec3(0., 1., 0.))));\n\t\t//vec3 starbg = mix(veColSkyHigh, veColSkyLow, uv.y);\n\t\t//vec3 brightness = smoothstep(0.95, 1.0, stars);\n\t\t//float limits = dot(vec3(0.0), rd) + 0.75;\n\t\t//starbg += veColStars * brightness * limits;\n//\t\tif (td < veBackgroundCutoff) {\n//\t\t}\n\t\t//starbg *= pass;\n\t\tsum.xyz += (starbg + stars) * pass * (1.0 - sum.a);\n\t\t//sum.xyz += (veSpaceCol(ro, rd) * pass + starbg) * (1.0 - sum.a);\n\t\t//sum.xyz += veSpaceCol(ro, rd) * (1 - sum.a);\n\t}\n\n\tif (veTONEMAPPING) {\n\t\tsum.xyz = veToneMapFilmicALU(sum.xyz * 2.2);\n\t}\n    fragColor = vec4(sum.xyz, 1.0);\n    //gl_FragColor = fragColor;\n}\n#undef iMouse\nvoid mainImage(out vec4 O, in vec2 U){iiMouse=iMouse;mainImage1(O,U);}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltc3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2269, 2308, 2328, 2328, 2362], [2363, 2363, 2381, 2381, 2419], [2420, 2420, 2438, 2438, 2485], [2487, 2487, 2524, 2524, 2570], [2572, 2586, 2613, 2613, 2834], [2836, 2836, 2857, 2857, 2971], [2973, 2973, 3006, 3006, 3031], [3032, 3032, 3092, 3092, 3151], [3153, 3831, 3861, 3861, 4343], [4345, 4345, 4431, 4431, 5056], [5058, 5058, 5127, 5127, 6014], [6081, 6110, 6177, 6262, 6514], [6516, 6516, 6581, 6581, 6851], [6853, 6968, 7006, 7006, 7175], [7177, 7177, 7211, 7211, 7542], [7669, 7669, 7694, 7694, 7742], [7744, 7744, 7770, 7770, 7959], [7961, 7961, 7987, 7987, 8306], [8308, 8308, 8330, 8330, 8457], [8459, 8459, 8489, 8489, 8686], [8688, 8688, 8723, 8723, 9174], [9267, 9377, 9400, 9400, 9511], [9513, 9623, 9645, 9645, 9760], [9762, 9872, 9895, 9895, 9996], [9998, 10108, 10130, 10130, 10269], [10271, 10382, 10403, 10403, 10546], [10548, 10659, 10681, 10681, 10810], [10812, 10922, 10944, 10944, 11109], [11111, 11222, 11243, 11243, 11412], [11414, 11525, 11547, 11547, 11702], [11704, 11813, 11835, 11835, 12029], [12031, 12140, 12161, 12161, 12359], [12361, 12470, 12491, 12491, 12689], [12691, 12800, 12822, 12822, 13005], [13006, 13027, 13077, 13077, 13197], [13198, 13198, 13232, 13232, 13271], [13272, 13272, 13304, 13304, 13349], [13350, 13350, 13382, 13382, 13427], [13428, 13428, 13469, 13469, 13568], [13569, 13569, 13601, 13601, 14608], [14609, 14706, 14779, 14779, 15065], [15067, 15135, 15212, 15249, 15759], [15762, 15830, 15895, 15932, 16300], [16303, 16396, 16443, 16443, 16847], [16849, 16849, 16894, 16894, 17010], [17011, 17011, 17068, 17068, 23037], [23052, 23052, 23090, 23090, 23122]]}
{"id": "ltcGRH", "name": "Falling Squares", "author": "Peetu", "description": "Transparent squares falling from the sky", "tags": ["2dsquare"], "likes": 1, "viewed": 212, "date": "1467876249", "time_retrieved": "2024-06-20T18:38:42.143793", "image_code": "bool square(vec2 p, float w){\n\treturn (abs(p.x) < w && abs(p.y) < w);\n}\n\n//returns seemingly random float between 0.0 and 1.0\nfloat randomNumber(float seed){\n\tfloat number = seed * seed * 16070.;\n    float final = mod(number, 100.);\n    return 0.01 * final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec4 col = vec4(sin(iTime + uv.y) + 0.5) * .6;\n    \n    //SQUARES\n    for(int i = 0; i < 9; i++){\n        for(int j = 0; j < 6; j++){\n            \n            vec2 moveduv = uv - vec2(.25 * float(i - 1), -.2 + mod(.25 * float(j - 1) - iTime * .25, 1.5));\n\n            //ROTATION\n            vec2 rotateduv = vec2(0.0);\n            \n            float rot = iTime * 5.8 * (.5 - randomNumber(float(i + j + 185))); \n\n            vec2 newuv = mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * moveduv;\n\n            if(square(newuv, mod(iTime / 15. + float(i) / 7. + float(j) /  13., .2)) == true){\n                col += vec4(1. - mod(iTime / 15. + float(i) / 7. + float(j) /  13., .2) * 5.); \n            }\n        }\n    }\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcGRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 29, 29, 71], [73, 126, 157, 157, 259], [261, 261, 318, 318, 1106]]}
{"id": "ltcGzN", "name": "Glossy Tunnel", "author": "aiekick", "description": "Glossy Tunnel", "tags": ["tunnel", "glossy"], "likes": 10, "viewed": 598, "date": "1468159965", "time_retrieved": "2024-06-20T18:38:42.992337", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2), sin(t*0.2)) * 2.;\n}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tp *= RotZ(p.z*0.3);\n\tp += sin(p.zxy*1.2) + sin(p.xzy * 1.2);\n    p *= RotZ(p.z*-0.3);\n\tfloat tri = .5 * (max(abs(p.x) + p.y, -p.y) + max(abs(p.x) - p.y, p.y));\n\treturn vec2(tri - 4.8 , 2.);\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.076);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(40.*sb+0.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t// normal at surface point\n    \n    // derived from bumpmap func from shane\n    const vec2 e = vec2(0.1, 0);\n    mat3 m = mat3( tex3D(iChannel0, e.xyy, n), tex3D(iChannel0, e.yxy, n), tex3D(iChannel0, e.yyx, n));\n   \tvec3 g = vec3(1) * m * 20.;\n    g -= n * dot(n, g);\n    n =  normalize( n + g );\n    \n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.1242; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff + fre + bb * sb * 0.608 + sss * 0.352) * amb * li + spe * 0.612 \t\n    );\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = -iTime*2.;\n\n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord.xy-si)/si.y;\n    \n    vec3 col = vec3(0.);\n    \n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 20.;\n    float s = 1.;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (0.<0.05*log(d*d/s/1e5)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s *0.3;\n    }\n    \n\tif (d<md)\n\t{\n\t\tvec3 p = ro+rd*d;\n\n\t\tcol += shade(ro, rd, d, ro, 1.2).yzw;\n\t\t\n\t\tcol = mix(col, vec3(0), 1.-exp(-0.01*d*d));\n\t}\n\n\tfragColor.rgb = col;\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltcGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 214, 233, 233, 291], [293, 293, 313, 313, 358], [360, 360, 377, 377, 590], [592, 592, 629, 629, 841], [843, 1064, 1092, 1092, 1417], [1419, 1501, 1558, 1558, 1784], [1786, 1786, 1822, 1822, 1957], [1959, 2135, 2186, 2186, 2357], [2359, 2359, 2417, 2417, 3531], [3533, 3533, 3579, 3579, 3748], [3750, 3750, 3807, 3807, 4418]]}
{"id": "ltd3R4", "name": "Wooden Sculpture", "author": "Nesvi7", "description": "I wanted to create a math sculpture inspired by Inigo's sculptures. This is my first published shader in shadertoy and one of my first raymarching shaders, so I will be glad to learn from all your feedback and improvements.", "tags": ["procedural", "raymarching", "sculpture"], "likes": 4, "viewed": 239, "date": "1468323120", "time_retrieved": "2024-06-20T18:38:42.998389", "image_code": "//By Nestor Vina\n//Thanks to Inigo Quilez for his work and articles.\n//Thanks to https://www.shadertoy.com/view/XsB3Rm by gltracy.\n\n// ray marching\nconst int max_iterations = 10000;\nconst float stop_threshold = 0.00001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lerp( float a, float b, float t){\n return a+(b-a)*t;   \n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(1.0*p.y);\n    float s = sin(1.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*(p).xz,(p).y);\n    return q;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat coolThing( vec3 pos, float r ) {\n    float lerpValue = (sin(iTime) +1.0)/2.0;\n\tfloat lerpValueSlow = (sin(iTime/10.0) +1.0)/2.0;\n    pos = opTwist(pos);\n    pos += vec3(0,sin(pos.y*10.0*lerpValue),0);\n    float sphere = sdSphere(pos,3.0);\n    float torus = sdTorus(pos, vec2(2.0,1.0));\n    float outputDist = torus + (sphere - torus) * lerpValueSlow ;\n    return outputDist;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n    \n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 map( vec3 pos ) {\n\tfloat s = 2.0;\n\tfloat ct = coolThing( pos/s, 1.7)*s;\n    float peana = sdCappedCylinder(pos+vec3(0.0,8.0,0.0),vec2(10.0,1.0));\n    if( peana > ct)\n        return vec2(ct,0.0);\n    else\n    \treturn vec2(peana,1.0);\n}\n\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n        dist -= dist*0.95;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\nfloat reflections_ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {        \n\t\tfloat dist = coolThing( ( origin + dir * depth )/2.0, 1.7)*2.0;\n        dist -= dist*0.95;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 shadingWood( vec3 v, vec3 n, vec3 eye ) {\n    //return vec3(0,0,1.0);\n    vec3 sunDir = normalize(vec3(-1.0,1.0,0));\n    \n    //Texturing \n    vec2 uv = v.xy;\n    vec3 albedo = texture(iChannel0, uv, 1.0).xyz;\t   \n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.7,0.3,0.1) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+fresnelColor+ambient;\n}\n\nvec3 shadingMarble( vec3 v, vec3 n, vec3 eye ) {\n    \n    vec3 sunDir = normalize(vec3(-1.0,1.0,0));\n\n    vec3 albedo = vec3(0.5,0.5,0.5);\n\t    \n    vec3 viewDir = normalize(eye-v);\n    \n    vec3 reflectionVector = reflect(n+texture(iChannel1, v.xz).xyz/2.0,viewDir);\n    float reflectionRayDist = reflections_ray_marching( v, reflectionVector, 0.0, clip_far );\n    vec3 reflectionColor = vec3(0.0); \n    \n    if( reflectionRayDist < clip_far )\n    {\n    \tvec3 rpos = v + reflectionVector * reflectionRayDist;\n\t\tvec3 n = normal( rpos );\n    \treflectionColor = shadingWood( rpos, n, v ) * 0.3;\n    }\n    \n    vec3 fresnelColor = vec3(0.7,0.3,0.1) * fresnel(n,viewDir,2.0);\n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient+reflectionColor/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 45.0 + sin(iTime)*5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(shadingWood( pos, n, eye ), 1);\n    else\n    \tfragColor = vec4(shadingMarble( pos, n, eye ),1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltd3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[281, 359, 392, 392, 457], [459, 459, 494, 494, 518], [520, 520, 559, 559, 583], [585, 585, 609, 609, 747], [749, 749, 791, 791, 890], [892, 892, 930, 930, 1274], [1276, 1276, 1315, 1315, 1371], [1373, 1373, 1418, 1418, 1554], [1556, 1556, 1578, 1578, 1795], [1797, 1813, 1881, 1881, 2237], [2239, 2239, 2320, 2320, 2625], [2627, 2648, 2696, 2696, 2871], [2873, 2873, 2898, 2898, 3202], [3204, 3236, 3267, 3267, 3423], [3425, 3425, 3467, 3467, 3503], [3505, 3505, 3551, 3579, 3981], [3983, 3983, 4031, 4031, 4801], [4803, 4803, 4860, 4880, 5567]]}
{"id": "ltd3R7", "name": "Sphere Tracer with Refraction", "author": "geoff", "description": "Added refraction to one of my previous scenes. Worked out the method off the top of my head - so it may not be correct - but looks quite good to me. Move the light with the mouse. ", "tags": ["refraction", "spheretracing"], "likes": 1, "viewed": 596, "date": "1468516570", "time_retrieved": "2024-06-20T18:38:42.998389", "image_code": "#define MAX_DIST 25.0\n#define MAX_ITER 1000\n#define MAX_REF_ITER 1500\n#define EPSILON 0.00001\n#define CAM_POS vec3(0.0, 0.0, -5.0)\n#define LIGHT_POS vec3(12.0 * iMouse.x / iResolution.x - 6.0, 2.0, 6.0 * iMouse.y / iResolution.y - 9.0)\n#define T_MIN 0.01\n#define AO_SAMPLES 15\n#define AO_STRENGTH 3.0\n\n#define REFRACTIVE_INDEX 1.52\n\nmat3 rotY(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c);\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    q -= vec3(2.5 * cos(iTime), 0.0, 2.5 * sin(iTime));\n    vec3 r = p;\n    r -= vec3(-0.5 * cos(iTime), 0.0, -0.5 * sin(iTime));\n    r *= rotY(iTime);\n    vec2 sphere = vec2(length(q) - 1.0, 4.0);\n    vec2 cube = vec2(length(max(abs(r)-1.0,0.0)), 1.0);\n    vec2 hplane = vec2(p.y + 1.0, 2.0);\n    vec2 vplane = vec2(-p.z + 4.0, 3.0);\n    \n    float m = min(cube.x, min(sphere.x, min(hplane.x, vplane.x)));\n    return m == cube.x ? cube : m == sphere.x ? sphere : (m == hplane.x ? hplane : vplane); \n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nvec2 trace(vec3 ro, vec3 rd){\n \tfloat t = 0.0;\n    float d = 0.0;\n    vec2 coll;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        coll = mapMat(ro + rd * t);\n        d = coll.x;\n        if(d < EPSILON){\n            break;\n        }\n        if(t > MAX_DIST){\n        \tt = 0.0;\n            break;\n    \t}\n        t += d;\n    }\n    return vec2(t, coll.y);\n}\n\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = T_MIN;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        d = map(ro + rd * t);\n        if(d < EPSILON){\n            return 0.0;\n        }\n        if(t > MAX_DIST){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nvec3 normal(vec3 p){\n    return vec3(map(vec3(p.x + EPSILON, p.yz)) - map(vec3(p.x - EPSILON, p.yz)),\n                map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n                map(vec3(p.xy, p.z + EPSILON)) - map(vec3(p.xy, p.z - EPSILON)));\n}\n\nvec3 refHit;\n\nvec2 refraction(vec3 ro, vec3 rd){\n \tfloat t = 0.0;\n    float d = 0.0;\n    vec2 coll;\n    for(int iter = 0; iter < MAX_REF_ITER; iter++){\n        coll = mapMat(ro + rd * t);\n        d = coll.x;\n        //Inside Material\n        if(d > EPSILON){\n            break;\n        }\n        if(t > MAX_DIST){\n        \tt = 0.0;\n            break;\n    \t}\n        t += 0.05;\n    }\n    if(t != 0.0){\n        vec3 nro = ro + rd * t;\n        vec3 nrd = refract(normalize(nro - ro), normalize(-normal(nro)), REFRACTIVE_INDEX);\n        coll = trace(nro, nrd);\n        refHit = nro + nrd * coll.x;\n    }\n    return vec2(t, coll.y);\n}\n\n\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(AO_STRENGTH * occ, 0.0, 1.0);\n}\n\n//Material colours\nvec3 matCol(float id, vec3 p){\n    if(id == 1.0){\n        return vec3(1.0, 1.0, 0.0);\n    }\n    if(id == 2.0){\n        return (mod(floor(p.z), 2.0) == 0.0 && mod(floor(p.x), 2.0) != 0.0) \n            \t|| (mod(floor(p.z), 2.0) != 0.0 && mod(floor(p.x), 2.0) == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    }\n    if(id == 4.0){\n        return vec3(1.0);\n    }\n    return vec3(0.0, 0.0, 1.0);\n}\n\n//Material properties AMB DIFF SPEC ALPHA\nvec4 matProp(float id){ \n    if(id == 1.0){\t\t\n        return vec4(0.25, 0.8, 0.5, 64.0);\n    }\n    if(id == 2.0){\n        return vec4(0.25, 0.5, 0.5, 2.0);\n    }\n    if(id == 4.0){\n        return vec4(0.25, 0.0, 0.8, 128.0);\n    }\n    return vec4(0.25, 0.9, 0.2, 2.0);\n}\n\nint refractive(float id){\n    return id == 4.0 ? 1 : 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = CAM_POS;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec2 coll = trace(ro, rd);\n    float d = coll.x;\n    float matID = coll.y;\n    vec3 col;\n    if(d == 0.0){\n        col = vec3(0.0);\n    }else{\n        vec3 x = ro + (rd * d);\n    \tvec3 l = normalize(LIGHT_POS - x);\n        vec3 n = normalize(normal(x));\n    \tfloat nl = dot(n, l);\n    \tfloat s = shadow(x, l);\n        \n        //Get material properties\n        vec4 consts = matProp(matID);\n        vec3 matC = matCol(matID, x);\n        int ref = refractive(matID);\n        \n        if(ref == 1){\n            coll = refraction(x, refract(l, n, 1.0 / REFRACTIVE_INDEX));\n            x = refHit;\n            l = normalize(LIGHT_POS - x);\n            n = normalize(normal(x));\n            nl = dot(n, l);\n            s = shadow(x, l);\n            consts = matProp(coll.y);\n        \tmatC = matCol(coll.y, x);\n        }\n        \n        //Calculate ambient light\n    \tvec3 amb = consts.x * matC * occlusion(x, n);\n    \t\n        //Calculate diffuse\n        vec3 diff = consts.y * matC * max(nl, 0.0);\n    \t\n        //Calculate specular\n        vec3 spec = vec3(0.0);\n        //If in shadow, no specular highlight\n        if(s == 1.0){\n    \t\tfloat facing = nl > 0.0 ? 1.0 : 0.0;\n    \t\tvec3 h = 2.0 * nl * n - l;\n    \t\tspec = facing * consts.z * matC * pow(max(dot(n, h), 0.0), consts.w);\n        }\n    \t\n    \tcol = amb + diff + spec;\n        \n        //Shadows\n        if(ref == 1){\n            col -= vec3(0.1 - 0.1 * s);\n        }else{\n    \t\tcol -= vec3(0.5 - 0.5 * s);\n        }\n        \n        //Fog\n        col *= vec3(1.0 / exp(d * 0.08));\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltd3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[333, 333, 352, 352, 492], [494, 494, 514, 514, 1032], [1034, 1034, 1052, 1052, 1078], [1080, 1080, 1109, 1109, 1440], [1443, 1443, 1474, 1474, 1818], [1820, 1820, 1840, 1840, 2094], [2110, 2110, 2144, 2144, 2725], [2729, 2729, 2763, 2763, 3028], [3030, 3049, 3079, 3079, 3449], [3451, 3493, 3516, 3516, 3763], [3765, 3765, 3790, 3790, 3822], [3824, 3824, 3881, 3881, 5634]]}
{"id": "ltd3WM", "name": "Toon Shader Test 2", "author": "geoff", "description": "Same as my first toon shader but with outlines added. Rotate the camera with the mouse and change SHADES to set the number of shades in each palette.", "tags": ["npr"], "likes": 12, "viewed": 1164, "date": "1469710987", "time_retrieved": "2024-06-20T18:38:42.998389", "image_code": "#define AO\n#define SHADOWS\n\n#define SHADES 6.0\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    q -= vec3(0.5 * cos(iTime), 0.0, 0.5 * sin(iTime));\n    vec3 r = p;\n    r -= vec3(-2.5 * cos(iTime), 0.25, -2.5 * sin(iTime));\n    r *= rotY(iTime);\n    vec2 sphere = vec2(length(q) - 1.0, 3.0);\n    vec2 torus = vec2(length(vec2(length(r.yz) - 0.75, r.x)) - 0.5, 3.0);\n    vec2 hplane = vec2(p.y + 1.0, 3.0);\n    vec2 vplane = vec2(-p.z + 4.0, 3.0);\n    \n    return vecMin(sphere, vecMin(torus, vecMin(hplane, vplane))); \n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 2000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        if(d <= 0.01 && map(ro + rd * (t + 0.2)) > 0.0001){\n            inter = 1;\n            c.y = 4.0;\n            break;\n        }\n        t += d;\n        if(t > 50.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.2;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(1.0 * occ, 0.0, 1.0);\n}\n\nvec3 colInterp(vec3 bcol, vec3 ecol, vec3 inCol, float s){\n    float st = 1.0 / SHADES;\n    float avg = inCol.x * SHADES; \n    float band = ceil(avg) / SHADES;\n    if(s != 1.0){\n        band = max(0.0, band - st);\n    }\n    return mix(bcol, ecol, band);\n}\n\nvec3 palette(float id, vec3 inCol, float s){\n    if(id == 1.0){\n        vec3 mcol = vec3(0.95);\n        vec3 bcol = mcol / 4.0;\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    if(id == 2.0){\n        vec3 mcol = vec3(0.874510, 0.490196, 0.376471);\n        mcol = vec3(1.0, 1.0, 0.0);\n        vec3 bcol = mcol / 4.0;\n        bcol = vec3(0.0, 0.0, 1.0);\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    if(id == 3.0){\n        vec3 mcol = vec3(0.929412, 0.882353, 0.788235);\n        mcol = vec3(1.0, 0.0, 0.0);\n        vec3 bcol = mcol / 4.0;\n        bcol = vec3(0.0, 0.0, 1.0);\n        return colInterp(bcol, mcol, inCol, s);\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat s = 1.0;\nfloat ao = 1.0;\n\nvec3 colour(vec3 p, float id){\n    \n    #ifdef SHADOWS\n    float s = shadow(p, normalize(lightPos - p));\n    #endif\n    \n    #ifdef AO\n    float ao = occlusion(p, normal(p));\n    #endif\n    \n    if(id == 4.0){\n        return vec3(0.0);\n    }\n    \n    return palette(id, diff(vec3(1.0), 1.0, p) * ao, s);\n} \n\nfloat lastx = 0.0;\nfloat lasty = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0 , 0.0, -5.0);\n    lightPos = vec3(2.0, 2.0, -6.0);\n    lastx += iMouse.x - 0.5;\n    lasty += iMouse.y - 0.5;\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotY(radians(lastx)) * rotX(radians(lasty)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n    \tcol = colour(c, closeObj);\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltd3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 48, 67, 67, 208], [210, 210, 229, 229, 370], [395, 395, 423, 423, 483], [485, 485, 505, 505, 949], [951, 951, 969, 969, 995], [997, 997, 1027, 1027, 1545], [1547, 1547, 1567, 1567, 1843], [1919, 1919, 1954, 1954, 2058], [2060, 2060, 2091, 2091, 2447], [2449, 2449, 2483, 2483, 2732], [2734, 2734, 2792, 2792, 2989], [2991, 2991, 3035, 3035, 3672], [3706, 3706, 3736, 3736, 4011], [4053, 4053, 4109, 4109, 4713]]}
{"id": "ltdGD7", "name": "Trapped!", "author": "vapoi", "description": "how to get out?", "tags": ["2d", "simple"], "likes": 1, "viewed": 140, "date": "1469734583", "time_retrieved": "2024-06-20T18:38:43.725692", "image_code": "const float fPi = 3.14159;\n\n\n// Noise part:\n    //\n    // GLSL textureless classic 2D noise \"cnoise\",\n    // with an RSL-style periodic variant \"pnoise\".\n    // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n    // Version: 2011-08-22\n    //\n    // Many thanks to Ian McEwan of Ashima Arts for the\n    // ideas for permutation and gradient selection.\n    //\n    // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n    // Distributed under the MIT license. See LICENSE file.\n    // https://github.com/ashima/webgl-noise\n    //\n\n    vec4 mod289(vec4 x)\n    {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x)\n    {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    vec2 fade(vec2 t) {\n      return t*t*t*(t*(t*6.0-15.0)+10.0);\n    }\n\n    // Classic Perlin noise\n    float cnoise(vec2 P)\n    {\n      vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n      vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n      Pi = mod289(Pi); // To avoid truncation effects in permutation\n      vec4 ix = Pi.xzxz;\n      vec4 iy = Pi.yyww;\n      vec4 fx = Pf.xzxz;\n      vec4 fy = Pf.yyww;\n\n      vec4 i = permute(permute(ix) + iy);\n\n      vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n      vec4 gy = abs(gx) - 0.5 ;\n      vec4 tx = floor(gx + 0.5);\n      gx = gx - tx;\n\n      vec2 g00 = vec2(gx.x,gy.x);\n      vec2 g10 = vec2(gx.y,gy.y);\n      vec2 g01 = vec2(gx.z,gy.z);\n      vec2 g11 = vec2(gx.w,gy.w);\n\n      vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n      g00 *= norm.x;  \n      g01 *= norm.y;  \n      g10 *= norm.z;  \n      g11 *= norm.w;  \n\n      float n00 = dot(g00, vec2(fx.x, fy.x));\n      float n10 = dot(g10, vec2(fx.y, fy.y));\n      float n01 = dot(g01, vec2(fx.z, fy.z));\n      float n11 = dot(g11, vec2(fx.w, fy.w));\n\n      vec2 fade_xy = fade(Pf.xy);\n      vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n      float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n      return 2.3 * n_xy;\n    }\n\n\n// Shader part\nconst float headFuture = 0.7;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    \n    vec2 posMid = vec2(-1.0, -1.0) + 2.0 * pos; \n    float fakX = iResolution.x / iResolution.y;\n    posMid.x *= fakX;\n    \n    \n    float distMid = length(posMid);\n    float fTime = iTime * 01.3;\n    vec2 vPos = posMid * 5.0;\n    \n    // some Noise\n    float fNN1 = cnoise(posMid * 4.0 + fTime * vec2(0.5, 0.5));\n    \n    \n// the thing\n    vec2 posThing = vec2(fakX * sin(fTime * .3 + sin(fTime * 0.8)),\n                       \t\t  cos(fTime * 0.7 - sin(fTime * 0.5)));\n    \n    float fTimeFuture = fTime + headFuture;\n    vec2 posHead = posThing + 0.2 * vec2(1.2 * sin(fTimeFuture * .3 + sin(fTimeFuture * 0.8)),\n                                         cos(fTimeFuture * 0.7 - sin(fTimeFuture * 0.5)));\n    \n    float fThing = length(vPos - posThing * 3.0);\n    float fHead = length(vPos - posHead * 3.0);\n    \n    fThing = (1.0 - smoothstep(0.75, 0.8, fThing + fNN1 * 0.2));\n    fHead = (1.0 - smoothstep(0.33, 0.4, fHead + fNN1 * 0.07));\n    \n    vec3 colThing = vec3(1.0, 0.8, 0.2) * 0.6 * fThing;\n    colThing = max(colThing, vec3(1.0, 0.8, 0.2) * 0.8 * fHead); \n        \t\t\n    \n// the wall\n    float fWall = max(smoothstep(fakX - 0.3, fakX - 0.1, abs(posMid.x + fNN1 * 0.05)),\n    \t\t\t\t  smoothstep(0.7, 0.9, abs(posMid.y + fNN1 * 0.05)));\n    \n    vec3 colWall = vec3(0.30, .60, .90) * fWall * 0.5;\n    \n    \n    \n    \n    vec3 colMixed = colThing + colWall;\n\tfragColor = vec4(colMixed,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 545, 570, 570, 627], [633, 633, 659, 659, 704], [710, 710, 742, 742, 802], [808, 808, 827, 827, 875], [881, 909, 935, 935, 2097], [2100, 2146, 2203, 2203, 3652]]}
{"id": "ltdGDn", "name": "SlowMo Fluid", "author": "zguerrero", "description": "Experimenting with 2d metaballs, ended up with that strange looking fluid...", "tags": ["2d", "fluid", "metaball", "motion", "slow"], "likes": 49, "viewed": 1771, "date": "1469016009", "time_retrieved": "2024-06-20T18:38:43.731885", "image_code": "float smoothing = 0.1;\nfloat ballradius = 0.0;\nfloat metaPow = 1.0;\nfloat densityMin = 4.0;\nfloat densityMax= 7.0;\nfloat densityEvolution = 0.4;\nfloat rotationSpeed = 0.005;\nvec2 moveSpeed = vec2(0.1,0.0);\nfloat distortion = 0.05;\nfloat nstrenght = 1.0;\nfloat nsize = 1.0;\nvec3 lightColor = vec3(7.0,8.0,10.0);\n\nfloat saturate1(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{    \n   \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (uv - center) + center;\n}\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n}  \n\nfloat metaBall(vec2 uv)\n{\n\treturn length(fract(uv) - vec2(0.5));\n}\n\nfloat metaNoiseRaw(vec2 uv, float density)\n{\n    float v = 0.99;\n    float r0 = hash(2015.3548);\n    float s0 = iTime*(r0-0.5)*rotationSpeed;\n    vec2 f0 = iTime*moveSpeed*r0;\n    vec2 c0 = vec2(hash(31.2), hash(90.2)) + s0;   \n    vec2 uv0 = rotuv(uv*(1.0+r0*v), r0*360.0 + s0, c0) + f0;    \n    float metaball0 = saturate1(metaBall(uv0)*density);\n    \n    for(int i = 0; i < 25; i++)\n    {\n        float inc = float(i) + 1.0;\n    \tfloat r1 = hash(2015.3548*inc);\n        float s1 = iTime*(r1-0.5)*rotationSpeed;\n        vec2 f1 = iTime*moveSpeed*r1;\n    \tvec2 c1 = vec2(hash(31.2*inc), hash(90.2*inc))*100.0 + s1;   \n    \tvec2 uv1 = rotuv(uv*(1.0+r1*v), r1*360.0 + s1, c1) + f1 - metaball0*distortion;    \n    \tfloat metaball1 = saturate1(metaBall(uv1)*density);\n        \n        metaball0 *= metaball1;\n    }\n    \n    return pow(metaball0, metaPow);\n}\n\nfloat metaNoise(vec2 uv)\n{ \n    float density = mix(densityMin,densityMax,sin(iTime*densityEvolution)*0.5+0.5);\n    return 1.0 - smoothstep(ballradius, ballradius+smoothing, metaNoiseRaw(uv, density));\n}\n\nvec4 calculateNormals(vec2 uv, float s)\n{\n    float offsetX = nsize*s/iResolution.x;\n    float offsetY = nsize*s/iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (metaNoise(uv - ovX.yx) - metaNoise(uv + ovX.yx)) * nstrenght;\n    float Y = (metaNoise(uv - ovY.xy) - metaNoise(uv + ovY.xy)) * nstrenght;\n    float Z = sqrt(1.0 - saturate1(dot(vec2(X,Y), vec2(X,Y))));\n    \n    float c = abs(X+Y);\n\treturn normalize(vec4(X,Y,Z,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv2 = uv;\n    uv2.x *= iResolution.x/iResolution.y;\n    uv2 *= vec2(1.0,0.75);\n    uv2.y += sin(uv.x*0.5);\n    uv2 += iTime*moveSpeed;\n\n    vec2 sphereUvs = uv - vec2(0.5);\n    float vign = length(sphereUvs);\n    sphereUvs = (sphereUvs / (1.0 + vign))*1.5;\n    \n    float noise = metaNoise(uv2);\n    \n    vec4 n = calculateNormals(uv2, smoothstep(0.0, 0.5, 1.0 - vign));\n    vec3 lDir = normalize(vec3(1.0,1.0,0.0));\n    float l = max(0.0, dot(n.xyz, lDir));\n      \n    vec4 tex = texture(iChannel0, sphereUvs + n.xy + iTime*moveSpeed*-0.2).xxxx*0.75;\n    tex *= 1.0 - vign;\n    \n    vec3 col = mix(tex.xyz*0.75, tex.xyz+l*lightColor, noise);\n    \n\tfragColor = vec4(n.w*col*5.0 + col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltdGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[312, 312, 338, 338, 371], [372, 372, 419, 419, 516], [517, 517, 538, 538, 615], [619, 619, 644, 644, 685], [687, 687, 731, 731, 1541], [1543, 1543, 1569, 1569, 1746], [1748, 1748, 1789, 1789, 2224], [2226, 2226, 2283, 2283, 3032]]}
{"id": "ltt3WM", "name": "3d voronoi WIP", "author": "jura", "description": "Fork of the awesome https://www.shadertoy.com/view/lsXGzH\nJust to do super simple voronoi diagram", "tags": ["voronoi"], "likes": 0, "viewed": 85, "date": "1469708781", "time_retrieved": "2024-06-20T18:38:47.326147", "image_code": "// Spout - @P_Malin\n\n//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define kRaymarchMaxIter 16\n#else\n    #define kRaymarchMaxIter 32\n    \n    #define ENABLE_AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n#define ENABLE_TRANSPARENCY\n#define ENABLE_SHADOWS\n#define ENABLE_FOG\n\n#define ENABLE_DIRECTIONAL_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_POINT_LIGHT_FLARE\n\nconst float kPipeRadius = 0.4;\nconst float kPipeThickness = 0.5;\nconst float kPipeHeight = 1.0;\n//float kPipeHeight = 2.0 + sin(iTime);\n\nconst float kWaterNoiseScale = 0.1;\n\nconst float kWaterVelocity = 1.0;\n\nconst float kWaterAccel = -1.0;\n\nconst float kWaterAnimSpeed = 80.0;\nconst float kTrenchWaterAnimSpeed = 20.0;\n\n\n\nfloat kRipplePos = sqrt(abs(2.0 * kPipeHeight / kWaterAccel)) * kWaterVelocity;\n\nconst float kPI = 3.141592654;\nconst float kTwoPI = kPI * 2.0;\n\nconst float kNoTransparency = -1.0;\nconst float kTransparency = 1.0;\nconst float kInverseTransparency = 0.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal;\n    vec3 cReflection;\n    vec3 cTransmission;    \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n\n    float fTransparency;\n    float fRefractiveIndex;\n};\n\nstruct C_Shading\n{\n    vec3 cDiffuse;\n    vec3 cSpecular;\n};\n\nstruct C_PointLight\n{\n    vec3 vPos;\n    vec3 cColour;\n};\n\nstruct C_DirectionalLight\n{\n    vec3 vDir;\n    vec3 cColour;\n};\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n/////////////////////////////////////\n// Distance Field CSG\n// These carry with them the material parameters in yzw\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineUnionTransparent( const in vec4 v1, const in vec4 v2, const in float fTransparentScale )\n{    \n\t//if( fCondition < 0.0 )\n\t//            return v1;\n\t\n\t// Negate the distance to the transparency object if transparent scale is 0.0     \n\t// This allows us to ratrace \"out\" of transparency\n\t\n\tvec4 vScaled = vec4(v2.x * (fTransparentScale * 2.0 - 1.0), v2.yzw);\n                \n\t// The condition allows us to ignore transparency for secondary rays\n    return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, fTransparentScale));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\n/////////////////////////////////////\n// Scene Description \n\nconst float kMaterialIdWall = 1.0;\nconst float kMaterialIdPipe = 2.0;\nconst float kMaterialIdWater = 3.0;\n\nfloat Noise(vec2 p)\n{\n    vec2 s = sin(p * 0.6345) + sin(p * 1.62423);\n    return dot(s, vec2(0.125)) + 0.5;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos, const in float fTransparentScale )\n{          \n    vec4 vResult = vec4(1000.0, -1.0, 0.0, 0.0);\n            \n\tfloat fDistFloor = vPos.y;\n\tfloat fDistBrick = fDistFloor;\n\t\n\t\n    vec4 vDistFloor = vec4(fDistBrick, kMaterialIdWall, vPos.xz + vec2(vPos.y, 0.0));\n    vResult = DistCombineUnion(vResult, vDistFloor);    \n\n    vec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);\n\n    float t= max(vWaterDomain.x / kWaterVelocity, 0.0);\n\t\n\t// Equations of motion\n\tfloat s = 0.0;\n\tfloat v = -kWaterAccel * t;\n\t\n\tvWaterDomain.y -= s;    \n                \n    float fDistWater = (length(vWaterDomain.yz) - kPipeRadius);\n                \n    \n\t// compensate for domain distortion of water, otherwise ray sometimes misses\n\tfDistWater /= (1.0 + v * 0.5);\n\t\n    vec2 vNoiseDomain = vPos.xz;\n                \n\t// modify noise for water in trench\n\tfloat fInTrench = step(vPos.y, (-0.1 + 0.05));        \n\tvec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);\n\tvNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);\n\tfloat fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;\n\tfloat fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);\n\t\n\tvNoiseDomain *= 30.0; \n\tvNoiseDomain.x += -iTime * fWaterSpeed;\n\t\n\tfloat fTrenchWaterDist = vPos.y + 0.1;\n\tfDistWater = min(fDistWater, fTrenchWaterDist);\n\t\n\tfDistWater += Noise(vNoiseDomain) * fNoiseScale;\n\t\n\tvec4 vDistWater = vec4(fDistWater, kMaterialIdWater, vPos.xy);        \n\tvResult = DistCombineUnionTransparent(vResult, vDistWater, fTransparentScale);\n              \n    return vResult;\n}\n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n    return ray.fStartDistance;  \n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n    C_Material mat;\n              \n    if(hitInfo.vObjectId.x == kMaterialIdWall)\n    {\n        // floor\n        mat.fR0 = 0.02;\n                                \n\t\t// Textureless version\n\t\t//vec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectId.yz));\n\t\t//float fTile = vTile.x * vTile.y;\n        //mat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n        //mat.fSmoothness = 1.0;\n        \n        vec3 cTexture = texture(iChannel0, hitInfo.vObjectId.yz * 0.25).rgb;\n        mat.cAlbedo = cTexture * cTexture;\n        mat.fSmoothness = mat.cAlbedo.r;\n        mat.fTransparency = 0.0;\n    }\n    else\n    if(hitInfo.vObjectId.x == kMaterialIdPipe)\n    {\n        // pipe\n        mat.fR0 = 0.8;\n        mat.fSmoothness = 1.0;\n        mat.cAlbedo = vec3(0.5);\n        mat.fTransparency = 0.0;\n    }\n    else\n    {\n        // water\n        mat.fR0 = 0.01;\n        mat.fSmoothness = 1.0;\n        mat.fTransparency = 1.0;\n        mat.fRefractiveIndex = 1.0;// / 1.3330;\n        const float fExtinctionScale = 2.0;\n\t\tconst vec3 vExtinction = vec3(0.3, 0.7, 0.9);\n        mat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; // becomes extinction for transparency\n    }\n    \n    return mat;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n    const vec3 cColourTop = vec3(0.7, 0.8, 1.0);\n    const vec3 cColourHorizon = cColourTop * 0.5;\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n    return mix(cColourHorizon, cColourTop, fBlend);\n}\n\nC_PointLight GetPointLight()\n{\n    C_PointLight result;\n\n    result.vPos = vec3(0.5, 1.0, -2.0);\n    result.cColour = vec3(32.0, 6.0, 1.0) * 10.0;\n\n    return result;\n}\n\nC_DirectionalLight GetDirectionalLight()\n{\n    C_DirectionalLight result;\n\n    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n    result.cColour = vec3(8.0, 7.5, 7.0);\n\n    return result;\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n\n/////////////////////////////////////\n// Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )\n{\n    // tetrahedron normal\n    const float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.01\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const float fTransparentScale )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.vObjectId.x = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos, fTransparentScale );\n        result.vObjectId = vSceneDist.yzw;\n        \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n    }\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )\n{\n    #ifdef ENABLE_SHADOWS\n\t\tC_Ray shadowRay;\n\t\tshadowRay.vDir = vLightDir;\n\t\tshadowRay.vOrigin = vPos;\n\t\tconst float fShadowBias = 0.05;\n\t\tshadowRay.fStartDistance = fShadowBias / abs(dot(vLightDir, vNormal));\n\t\tshadowRay.fLength = fLightDistance - shadowRay.fStartDistance;\n\t\n\t\tC_HitInfo shadowIntersect;\n\t\tRaymarch(shadowRay, shadowIntersect, 32, kNoTransparency);\n\t\t\n\t\tfloat fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );\n\t\t\n\t\treturn fShadow;          \n    #else\n    \treturn 1.0;\n    #endif\n}\n\n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_HitInfo intersection, const in C_Surface surface)\n{\n    #ifdef ENABLE_AMBIENT_OCCLUSION    \n\t\tvec3 vPos = intersection.vPos;\n\t\tvec3 vNormal = surface.vNormal;\n\t\n\t\tfloat fAmbientOcclusion = 1.0;\n\t\n\t\tfloat fDist = 0.0;\n\t\tfor(int i=0; i<=5; i++)\n\t\t{\n\t\t\tfDist += 0.1;\n\t\n\t\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kNoTransparency);\n\t\n\t\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                  \n\t\t}\n\t\n\t\treturn fAmbientOcclusion;\n    #else\n\t    return 1.0;\n    #endif    \n}\n\n/////////////////////////////////////\n// Lighting and Shading\n\n#define kFogDensity 0.05\n\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)\n{\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n    C_DirectionalLight directionalLight = GetDirectionalLight();\n    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);\n    cFog += directionalLight.cColour * pow(fDirDot, 10.0);\n    #endif \n\n    col = mix(cFog, col, fFogAmount);\n    #endif\n\n    // glare from light (a bit hacky - use length of closest approach from ray to light)\n    #ifdef ENABLE_POINT_LIGHT_FLARE\n    C_PointLight pointLight = GetPointLight();\n\n    vec3 vToLight = pointLight.vPos - ray.vOrigin;\n    float fPointDot = dot(vToLight, ray.vDir);\n    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);\n\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n    float fDist = length(vClosestPoint - pointLight.vPos);\n    col += pointLight.cColour * 0.01/ (fDist * fDist);\n    #endif    \n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vHalf, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vHalf, -vView);\n    fDot = clamp((1.0 - fDot), 0.0, 1.0);\n    float fDotPow = pow(fDot, 5.0);\n    return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;\n}\n\nvec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in C_Material material)\n{\n\tvec3 vReflect = reflect(vView, vNormal);\n\tvec3 vHalf = normalize(vReflect + -vView);\n    float fFresnel = Schlick(vHalf, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    return mix(vDiffuse, vSpecular, fFresnel);    \n}\n\nfloat GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)\n{          \n    vec3 vHalf = normalize(vLightDir - vIncidentDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n\n    float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n\nC_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n    \n    vec3 vToLight = light.vPos - vSurfacePos;\n    vec3 vLightDir = normalize(vToLight);\n    float fLightDistance = length(vToLight);\n    \n    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n    \n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\nC_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n\n    const float kShadowRayLength = 10.0;      \n    vec3 vLightDir = -light.vDir;\n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)\n{\n    vec3 cScene;\n    \n    C_Shading shading;\n\n    shading.cDiffuse = vec3(0.0);\n    shading.cSpecular = vec3(0.0);\n    \n    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;\n    \n    shading.cDiffuse += vAmbientLight;\n    shading.cSpecular += surface.cReflection;\n              \n    #ifdef ENABLE_POINT_LIGHT\n    C_PointLight pointLight = GetPointLight(); \n    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += pointLighting.cDiffuse;\n    shading.cSpecular += pointLighting.cSpecular;\n    #endif\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT\n\tC_DirectionalLight directionalLight = GetDirectionalLight();\n    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += directionLighting.cDiffuse;\n    shading.cSpecular += directionLighting.cSpecular;\n    #endif\n\n    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;              \n\n    // swap diffuse for transmission\n    vDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);    \n\n    #ifdef ENABLE_SPECULAR\n    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n    \n    return cScene;\n}\n\nvec3 GetSceneColourSecondary( const in C_Ray ray );\n\nvec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )\n{\n    #ifdef ENABLE_REFLECTIONS    \n    {\n        // get colour from reflected ray\n        const float fSeparation    = 0.1;\n\n        C_Ray reflectRay;\n        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n        reflectRay.vOrigin = hitInfo.vPos;\n        reflectRay.fLength = 16.0;\n        reflectRay.fStartDistance = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));\n        \n        return GetSceneColourSecondary(reflectRay);      \n    }\n    #else\n        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              \n    #endif\n}\n\nvec3 GetTransmission( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material )\n{\n    #ifdef ENABLE_TRANSPARENCY  \n    {\n        const float fSeparation = 0.05;\n\n        // Trace until outside transparent object\n        C_Ray refractRay;\n        // we dont handle total internal reflection (in that case refract returns a zero length vector)\n        refractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractiveIndex);\n        refractRay.vOrigin = hitInfo.vPos;\n        refractRay.fLength = 16.0;\n        refractRay.fStartDistance = fSeparation / abs(dot(refractRay.vDir, surface.vNormal));\n\n        vec3 vSceneColour = GetSceneColourSecondary(refractRay);                                                                        \n\t\tfloat fExtinctionDist = 0.5;\n                                \n        vec3 cMaterialExtinction = material.cAlbedo;\n        // extinction should really be exp(-) but this is a nice hack to get RGB\n        vec3 cExtinction = (1.0 / (1.0 + (cMaterialExtinction * fExtinctionDist)));\t\t\n\t\t\n\t\t//vec3 cExtinction = exp2(-cMaterialExtinction * fExtinctionDist);\n        return vSceneColour * cExtinction;\n    }\n    #else\n        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              \n    #endif\n}\n\nvec3 ClosestColor(const in vec3 p)\n{\n    vec3 points[8];\n    points[0] = vec3( 0.0, 0.0, 0.0 );\n    points[1] = vec3( 0.5, 0.5, 0.5 );\n    points[2] = vec3( 1.0, 0.5, 0.5 );\n    points[3] = vec3( 0.5, 1.0, 0.5 );\n    points[4] = vec3( 0.5, 0.5, 1.0 );\n    points[5] = vec3( 0.5, 1.0, 1.0 );\n    points[6] = vec3( 1.0, 0.5, 1.0 );\n    points[7] = vec3( 1.0, 1.0, 0.5 );\n    \n    vec3 points_off[8];\n    points_off[0] = vec3( 0.0, 0.0, 0.0 );\n    points_off[1] = vec3( -0.1, 0.1, 0.1 );\n    points_off[2] = vec3( 0.2, -0.2, 0.2 );\n    points_off[3] = vec3( 0.1, 0.3, -0.2 );\n    points_off[4] = vec3( -0.2, 0.2, 0.1 );\n    points_off[5] = vec3( -0.1, -0.1, 0.1 );\n    points_off[6] = vec3( 0.2, -0.2, 0.2 );\n    points_off[7] = vec3( -0.1, 0.1, 0.1 );\n    \n    vec3 colors[8];\n    colors[0] = vec3( 0.0, 0.0, 0.0 );\n    colors[1] = vec3( 0.5, 0.5, 0.5 );\n    colors[2] = vec3( 1.0, 0.5, 0.5 );\n    colors[3] = vec3( 0.5, 1.0, 0.5 );\n    colors[4] = vec3( 0.5, 0.5, 1.0 );\n    colors[5] = vec3( 0.5, 1.0, 1.0 );\n    colors[6] = vec3( 1.0, 0.5, 1.0 );\n    colors[7] = vec3( 1.0, 1.0, 0.5 );\n    \n    int closestIndx = 0;\n    float closestDistSqr = 10000.0;\n    for (int i = 1; i < 8; ++i)\n    {\n        vec3 cp = 0.5 * cos(iTime) * points[i] + points_off[i] * sin(iTime);\n        cp.y += kPipeHeight;\n        cp.x += cos(iTime * 0.5) * 2.0 - 1.5;\n        vec3 d = p - cp;\n        float currentDistSqr = dot(d, d);\n        if (closestDistSqr > currentDistSqr)\n        {\n            closestDistSqr = currentDistSqr;\n            closestIndx = i;\n        }\n    }\n    vec3 result = colors[0];\n    \n    // workaround for non-static indx for array\n    for (int i = 0; i < 8; ++i)\n        if (i == closestIndx)\n    \t\tresult = colors[i];\n    \n    // highlight control point\n    result.r *= 1.0/sqrt(closestDistSqr);\n\n    return result;\n}\n\n// no reflections, no transparency, used for secondary rays\nvec3 GetSceneColourSecondary( const in C_Ray ray )\n{\n    return ClosestColor(ray.vOrigin);\n}\n\nvec3 GetSceneColourPrimary( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256, kTransparency);\n                \n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos, kTransparency);\n\n        C_Material material = GetObjectMaterial(intersection);\n\n        surface.cReflection = GetReflection(ray, intersection, surface);\n\n        if(material.fTransparency > 0.0)\n        {    \n            surface.cTransmission = GetTransmission(ray, intersection, surface, material);\n        }\n\n        // apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material);\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n}\n\nfloat kFarClip = 30.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\n    float fRatio = iResolution.x / iResolution.y;\n    vViewCoord.y /= fRatio;                          \n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n\nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n\nvec3 Tonemap( const in vec3 cCol )\n{ \n    vec3 vResult = 1.0 -exp2(-cCol);\n\n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    C_Ray ray;\n\n    vec2 vMouseUV = iMouse.xy / iResolution.xy;    \n    \n    if(iMouse.z < 0.5)\n    {\n        vMouseUV = vec2(0.2, 0.8);\n    }\n\n    float fHeading = mix(-0.5, kPI + 0.5, vMouseUV.x);\n    float fElevation = mix(1.5, -0.25, vMouseUV.y);\n    float fCameraDist = mix(4.0, 2.5, vMouseUV.y);\n    \n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCameraDist;\n    vec3 vCameraIntrest = vec3(1.0, 0.9, 0.0);\n\n    GetCameraRayLookat( vCameraIntrest + vCameraPos, vCameraIntrest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColourPrimary( ray );  \n\n    const float fExposure = 1.5;    \n    fragColor = vec4( Tonemap(cScene * fExposure), 1.0 );\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltt3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[577, 1667, 1726, 1726, 1897], [1899, 1899, 1958, 1958, 2129], [2131, 2131, 2190, 2190, 2361], [2363, 2480, 2541, 2590, 2634], [2636, 2636, 2742, 2936, 3180], [3182, 3182, 3247, 3247, 3290], [3292, 3292, 3356, 3356, 3416], [3418, 3586, 3607, 3607, 3696], [3698, 3813, 3892, 3892, 5464], [5466, 5466, 5511, 5511, 5546], [5548, 5548, 5608, 5608, 6795], [6797, 6797, 6840, 6840, 7038], [7040, 7040, 7070, 7070, 7208], [7210, 7210, 7252, 7252, 7400], [7402, 7402, 7447, 7447, 7485], [7487, 7542, 7619, 7645, 8302], [8334, 8457, 8566, 8566, 9445], [9447, 9447, 9565, 9565, 10113], [10115, 10167, 10255, 10255, 10742], [10744, 10833, 10919, 10919, 11884], [11886, 11942, 12050, 12050, 12223], [12225, 12225, 12367, 12367, 12598], [12600, 12600, 12734, 12734, 13014], [13016, 13016, 13182, 13182, 13843], [13847, 13847, 14025, 14025, 14541], [14546, 14546, 14671, 14671, 16115], [16170, 16170, 16268, 16268, 16845], [16847, 16847, 16977, 16977, 18161], [18163, 18163, 18199, 18199, 19987], [19989, 20049, 20101, 20101, 20141], [20143, 20143, 20193, 20193, 21056], [21082, 21082, 21211, 21211, 21688], [21690, 21690, 21801, 21801, 21946], [21948, 21948, 22019, 22019, 22121], [22123, 22123, 22159, 22159, 22220], [22222, 22222, 22279, 22279, 22939]]}
{"id": "Md3SWr", "name": "Morphing Orb and Cube", "author": "piratehurrdurr", "description": "Morphing two shapes into each other.\nUploading some older shaders I made for a school assignment.\nclick to move the camera", "tags": ["raymarching", "example", "morphingobjects"], "likes": 3, "viewed": 153, "date": "1467575327", "time_retrieved": "2024-06-20T18:38:47.326147", "image_code": "#define IT 64\n#define MAX 32.0\n#define EP 1e-3\n#define EPN 1e-3\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n#define PI 3.14159254\n\n//#define MS\n\nvec3 amb(vec3 dir, vec3 sun) {\n    vec3 c = vec3(0.3,0.54,0.75);\n    c+=vec3(0.06,0.12,0.07)*dot(dir, vec3(0.0,0.0,1.0));\n    c+=vec3(0.10,0.02,0.17)*dot(dir, vec3(0.0,1.0,0.0));\n    c+=vec3(0.04,0.05,0.03)*dot(dir, vec3(1.0,0.0,0.0));\n    return c;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\nfloat dist(vec3 pos) {\n    return mix(sphere(pos, 0.5), box(pos, vec3(0.3)), (1.0+sin(iTime))/2.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir, out float totalDistance) {\n    totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<EP) {\n           return pos;\n        }\n        if (totalDistance>=MAX) {\n            totalDistance = MAX;\n            return pos;\n        }\n        pos+=dir*(rayDist);\n    }\n    \n    totalDistance = MAX;\n    return pos;\n}\n\nvec3 render(vec3 pos, vec3 dir) {\n    float d;\n    vec3 sp = scan(pos, dir, d);\n    \n\tvec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n    \n    if (d>=MAX) {\n        return amb(dir, sunVector);\n    }\n    \n    vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(sp + eps.yxx) - dist(sp - eps.yxx),\n    \t\tdist(sp + eps.xyx) - dist(sp - eps.xyx),\n    \t\tdist(sp + eps.xxy) - dist(sp - eps.xxy)));\n    \n    \n    \n    float sunAtten = dot(sunVector,normal);\n    if (sunAtten>0.0) {\n            } else {\n                sunAtten = 0.0;\n            }\n    \n    \n    \n        vec3 value = amb(normal, sunVector)*vec3(0.96,0.67,0.60);\n    value+= amb(reflect(dir, normal), sunVector)/4.0;\n    \n    \n    return value;\n    \n    /*\n    #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            if (pos.z<0.0) {\n            //return amb(reflect(dir, vec3(0.0,0.0,1.0)));\n            }\n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            \n            \n            vec3 ambientColor = vec3(0.6,0.8,1.0);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.9,1.0-1.0/pow(E,totalDistance*0.05));\n            \n            vec3 light = sunColor*sunAtten + ambientColor*ambientAtten;\n            vec3 world = mix(texture(iChannel1, pos.xy/7.0).rgb,texture(iChannel1,pos.xy).rgb,0.5)*light;\n            \n            vec3 finalColor = mix(world, fog.rgb,fog.a);\n            \n            finalColor\n            \n            return finalColor ;//*texture(iChannel2, normal).rgb;\n    */\n    \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    \n    vec2 mouse;\n    mouse.x = iMouse.x/64.0;\n    mouse.y = iMouse.y/iResolution.y + 0.00001;\n    \n    vec3 pos = vec3(cos(mouse.x),sin(mouse.x),1.0);\n    pos*=sin(mouse.y);\n    pos.z = cos(mouse.y);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = pos;\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n    vec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n    #ifdef MS\n    vec2 fragSize = vec2(1.0/iResolution.x, 1.0/iResolution.y)/4.0;\n    \n\tn = pos*0.5 + crossRight*(uv.x-fragSize.x) + crossUp*(uv.y-fragSize.y);\n    fragColor.rgb = render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x+fragSize.x) + crossUp*(uv.y-fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x-fragSize.x) + crossUp*(uv.y+fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x+fragSize.x) + crossUp*(uv.y+fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*uv.x+ crossUp*uv.y;\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    fragColor/=5.0;\n    \n    #else\n    n = n*0.5 + crossRight*uv.x + crossUp*uv.y;\n    fragColor.rgb = render(pos,-normalize(n)).rgb;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md3SWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[167, 181, 211, 211, 432], [434, 434, 472, 472, 507], [509, 509, 541, 541, 589], [592, 592, 614, 614, 693], [695, 695, 751, 751, 1119], [1121, 1121, 1154, 1154, 3110], [3112, 3112, 3158, 3158, 4622]]}
{"id": "MdVSWt", "name": "LavaPlanet", "author": "glkt", "description": "An evolving lava ball using ray marching.\nUse mouse to rotate.\nFeel free to share any idea to improve.", "tags": ["noise", "sphere", "marching", "lava"], "likes": 47, "viewed": 1221, "date": "1467471619", "time_retrieved": "2024-06-20T18:38:48.356567", "image_code": "// lava ball / GLkitty / Ben Vedrenne\n// licensed under WTFPL license : http://www.wtfpl.net/about/\n\nconst float dispValue = .7;\nconst float dispOffset = .5;\nconst float sphereBaseRadius = .6;\nconst vec3 ld = vec3(1,1,.5);\n\n\nfloat hash( vec3 p ) {\n    float h = dot(p,vec3(127.1,311.7,79.1));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nvec3 rotateX(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\n\nfloat noise( in vec3 p ) { // base noise\n\n    // iq 3d noise\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    float v = mix( mix( mix( hash( i + vec3(0.,0.,0.) ), \n                             hash( i + vec3(1.,0.,0.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,0.) ), \n                             hash( i + vec3(1.,1.,0.) ), u.x), u.y),\n                   mix( mix( hash( i + vec3(0.,0.,1.) ), \n                             hash( i + vec3(1.,0.,1.) ), u.x),\n                        mix( hash( i + vec3(0.,1.,1.) ), \n                             hash( i + vec3(1.,1.,1.) ), u.x), u.y),u.z); \n    \n    // bubble style\n    v = v * 2. - .5;    \n    float cv = abs(cos(v));    \n    float sv = abs(sin(v));    \n    v = mix(sv,cv,sv);\n    \n    return v;\n}\n\nfloat noiseLayer(vec3 p) { // layered noise\n        \n    float freq = 1.2; // base frequency / size\n    const int iter = 11; // iteration / depth\n    float lacunarity = 1.; // lacunarity: relative \"importance\" of smaller octaves\n    float v = 0.;\n    float sum = 0.;\n    for(int i = 0; i < iter; i++) {\n        float layerUp = 1. / pow(freq,lacunarity);\n        v += noise(p*freq) * layerUp;\n        sum += layerUp;\n        freq *= 1.8;\n    }\n    v /= sum;\n    return v;\n}\n\nfloat map(vec3 p){\n    \n    //rotate ball\n    p = rotateX(p,iMouse.y/100. + iTime/7.);\n    p = rotateY(p,iMouse.x/100. + iTime/7.); \n\n    // animate noise\n    float timeOffset = iTime/70.;\n    \n  \treturn noiseLayer(p+timeOffset) - dispOffset;  \n}\n\nvec3 calcNormal( in vec3 pos, float t ) // iq get normal\n{\n    vec2 eps = vec2( 0.005*t, 0.0 );\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat shadowRay(vec3 startP, vec3 lightDir){ // iq soft shadows \n    \n    float t = 0.0;\n    float shadowHardness = 10.;\n    float minD = 1.; // close-by distance \n    \n    for (int r = 0; r < 8; ++r){\n        \n        vec3 p = startP + vec3(t*lightDir.x,t*lightDir.y,t*lightDir.z) + normalize(startP)/shadowHardness; // safe offset\n        \n        vec3 pp = normalize(p) * sphereBaseRadius;                 \n        float sp = sphereBaseRadius + map(pp) * dispValue;\n        float d = length(p) - sp;\n        \n        minD = min(minD,d);        \n        if ( d < 0.0){  \n       \t\tbreak;   \n        }        \n        t += 0.08;\n    }    \n    return smoothstep(0.,1.0,minD*shadowHardness);\n}\n\nvec3 skyColor(vec2 uv, float minD){\n \n    float stars = ((1.-noiseLayer(vec3(uv*100.+iTime/40.,0.)))*10.-8. ) ;\n    \n    float stars2 = ((1.-noiseLayer(vec3(uv*30.+iTime/120.,3.)))*10.-8.8 ) ;\n    \n    vec3 sky = max(0.,stars) * vec3(0.2,0.5,.6);\n    sky += max(0.,stars2*10.) * vec3(1.,.8,.5);\n    \n    float halo = (1.-length(uv*0.7)) * 2.;\n        \n    sky *= halo;\n    \n    minD = 1.-minD;\n    minD = pow(minD,3.)*.3;\n    \n    sky += minD * vec3 (1.,.25,.2);\n    \n    return sky;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(skyColor(uv,0.));\n    float minD = 1.; // store minimum distance to make halo ;)\n    \n    float t = 0.0; // travelled distance\n    for (int r = 0; r < 16; ++r)\n    {\n        // current pos    \n        vec3 p = vec3(uv.x,uv.y,-2.+t) ;\n        \n        // sphere distance\n        vec3 pp = normalize(p) * sphereBaseRadius;                 \n        float sp = sphereBaseRadius + map(pp) * dispValue;\n        float d = length(p) - sp;\n\n        minD = min(minD,d);\n        \n        if ( d < 0.01) // if intersect\n        {   \n                        \n            float rayCount = float(r);\n            rayCount /= 16.;\n           \t// color = vec3(rayCount);\n                                    \n            // get normals\n            vec3 n = mix ( calcNormal(pp,0.1), calcNormal(pp,10.), .5);\n            \n            // main light / sun\n            float light1 = max(dot(n,-ld),.0) * 1.2;\n            if (light1 > 0.1){\n            \tlight1 *= shadowRay(p,ld);\n            }\n           \tlight1 += pow(light1,15.)/500.; // fake specular\n            \n            color = vec3(0.4,0.5,0.6) * light1;\n            \n            // secondary light / kick\n           \tcolor += max(dot(n,vec3(0,.5,1)),.0) * .15 * vec3 (.4,.5,.7);\n            \n            // lava incandescence\n            color += vec3(2.0,.35,0.15) * pow(max(.0,-map(pp)+.2),3.) * 8. * max(.0,1.-n.z);\n            \n            // inverse ambient occ\n            color += pow(rayCount,3.) * vec3(1.,.25,.2);  \n            \n            break;\n            \n            \n        }else if( t > 4.){  // if gone too far\n            \n            color = skyColor(uv,minD);\n            break;\n            \n        }\n        \n        t +=d;\n    }\n        \n    fragColor = vec4(color, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/MdVSWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 225, 247, 247, 335], [337, 337, 367, 367, 488], [490, 490, 520, 520, 640], [643, 643, 669, 703, 1455], [1457, 1457, 1483, 1500, 1929], [1931, 1931, 1949, 1972, 2177], [2179, 2179, 2237, 2237, 2449], [2451, 2451, 2495, 2515, 3142], [3144, 3144, 3179, 3179, 3634], [3636, 3636, 3693, 3712, 5580]]}
{"id": "MdyXWt", "name": "Lighted Sphere Field", "author": "VoidChicken", "description": "A simple raymarching test so try out a new way of rendering.", "tags": ["3d", "raymarching", "light", "spheres"], "likes": 1, "viewed": 112, "date": "1467326770", "time_retrieved": "2024-06-20T18:38:48.356567", "image_code": "vec3 Light;\nfloat Map(vec3 P, out bool WHITE) {\n    float outt;\n    WHITE = (outt=min(length(mod(P,20.)-10.)-2.,length(P-Light)-1.))==length(P-Light)-1.;\n    return outt;\n}\nvec3 Normal( vec3 x )\n{\n    bool b;\n    vec2 e = vec2( 0.001, 0.0 );\n    return normalize( vec3( Map(x+e.xyy,b) - Map(x-e.xyy,b),\n                            Map(x+e.yxy,b) - Map(x-e.yxy,b),\n                            Map(x+e.yyx,b) - Map(x-e.yyx,b) ) );\n}\nstruct Ray {\n    vec3 Origin, Direction;\n};\nstruct Intersection {\n    float Distance;\n    bool Collision;\n    bool Light;\n};\nvec3 RayDirection(vec2 D) {\n    return vec3((D*2.-1.)*vec2(1., iResolution.y/iResolution.x), 1);\n}\nRay CreateRay(vec3 O, vec3 D) {\n    Ray r;\n    r.Origin = O;\n    r.Direction = D;\n    return r;\n}\nvec3 RayPoint(Ray R,float T) {\n    return R.Origin+R.Direction*T;\n}\nIntersection ComputeRayIntersection(Ray r) {\n    Intersection it;\n    for (int i = 0; i < 64; i++) {\n        float df = Map(RayPoint(r,it.Distance),it.Light);\n        if (df<.01) {\n            it.Collision = true;\n        }\n        it.Distance+=df;\n    }\n    return it; \n}\nvec3 Shade(float T, Ray ray){\n    vec3 p = RayPoint(ray,T);\n    return vec3(1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 COLOR;\n    vec3 Camera = vec3(0,0,iTime*10.);\n    Light = Camera + vec3(mod(iTime*5.,100.)-50.,sin(iTime)*10.,50);\n    Ray ray = CreateRay(Camera, RayDirection(uv));\n    Intersection T = ComputeRayIntersection(ray);\n    float d = .1;\n    float e = 2.71828;\n  \tfloat fog = 1./(e*(0.125*T.Distance)*d);\n    vec3 p = RayPoint(ray,T.Distance);\n    float light = max(0.,dot(Normal(p),Light-p))/max(distance(Light,p),1.);\n    if (T.Collision)  \n        if (T.Light) COLOR = vec3(1);\n        else COLOR = vec3(1)*light;\n\tfragColor = vec4(COLOR,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyXWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[12, 12, 47, 47, 172], [173, 173, 196, 196, 430], [556, 556, 583, 583, 654], [655, 655, 686, 686, 752], [753, 753, 783, 783, 820], [821, 821, 865, 865, 1093], [1094, 1094, 1123, 1123, 1175], [1176, 1176, 1233, 1233, 1829]]}
{"id": "Ml33RM", "name": "ScienceOrDie", "author": "vox", "description": "ScienceOrDie", "tags": ["scienceordie"], "likes": 13, "viewed": 562, "date": "1468342423", "time_retrieved": "2024-06-20T18:38:51.271781", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)/GR/PI/E+GR*1.0/E/PI/2.0)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n#define quordinitate(uv) (vec2((zero(uv).x)+fract(uv.x/2.0), (zero(uv).y)+fract(uv.y/2.0)))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n#define MATRIX_W (floor(MAX_DIM/50.0))\n#define MATRIX_H (floor(MAX_DIM/50.0))\n\n\n//-----------------SIMPLEX ALGORITHM-----------------\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy) );\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy) );\n    vec3 x0 = v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    // x0 = x0 - 0.0 + 0.0 * C.xxx;\n    // x1 = x0 - i1 + 1.0 * C.xxx;\n    // x2 = x0 - i2 + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\n//-----------------HYPERBOLIC TANGENT-------------\nfloat tanh1(float val)\n{\n    float tmp = exp(val);\n    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n    return tanH;\n}\n\n//-----------------SEEDLLINGS---------------------\n\nfloat seedling = 0.0;\n\n//-----------------ITERATED FUNCTION SYSTEM-------\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat getEyes(vec2 uv)\n{\n    vec2 p = uv;\n\n    p.y += 1.0/PI;\n\n    p.x *= GR;\n\n    vec4 a = vec4(-1.0/GR, 1.0/GR, 0, 0);\n    vec4 b = vec4(1.0/GR, 1.0/GR, 0, 0);\n\n    p.y += cos(uv.x*(7.0+saw(time)))/PI;\n\n    float distA = length(p.xy-a.xy);\n    float distB = length(p.xy-b.xy);\n\n    float fade_lengthA = .20;\n    float fade_lengthB = .20;\n\n    float color = clamp((1.0-distA/fade_lengthA)*distB, 0.0, 1.0)\n        \t\t  +clamp((1.0-distB/fade_lengthB)*distA, 0.0, 1.0);\n    return color;\n}\n\nfloat getTeeth(vec2 uv)\n{\n    vec2 p = uv;\n    p.x *= PI;\n    p.y *= PI*(cos(p.x/PI/PI));\n    p.y += 1.5*cos(p.x)+1.0;\n    p.y *= (sin(time*PI*20.0+seedling))*.25+2.0;\n\n    float r = p.x*p.x+p.y*p.y;\n    \n    float xy = sin(p.x*PI*10.0)+cos(p.y*3.0+PI);\n\n    return clamp(clamp((3.0/(r*r*r)-p.y*p.y), 0.0, 1.0)*xy, 0.0, 1.0);\n}\n\nvec3 demon(vec2 uv)\n{\n    float eyes = getEyes(uv);\n    float teeth = getTeeth(uv);\n    \n    return vec3(clamp(eyes+teeth, 0.0, 1.0));\n}\n\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\nvec4 fire(vec2 p)\n{\n    p.x *= 1.0/E/GR/PI;\n    p.y *= PI/GR;\n    float tempX = (p.y+.5)*cos(p.x*4.0*PI+time*4.0*PI)*2.0;\n    float tempY = (p.y+.5)*sin(p.x*4.0*PI+time*4.0*PI)*2.0;\n\n    p.x = tempX;\n    p.y = tempY;\n\n\n    p.x += .5*snoise(vec2(time*.6*12.0*PI+256.0+seedling, p.y));\n    p.y += .5*snoise(vec2(time*.6*12.0*PI+500.0+seedling, p.x));\t\n\n    float x_max = 0.56999993;\n    float y_max = 0.74999976;\n\n    float R = x_max;\n    float r = .1;\n\n    float x = snoise(vec2(time*.6*2.0+256.0+seedling, p.y))*.25+.875;\n    float y = snoise(vec2(time*.6*2.0+256.0+seedling, p.x))*.25-.625;\n\n    vec4 c = vec4(x, y, 0.0, 0.0);\n\n    vec2 Z = p*vec2(.85,1.0);\n    int iterations_temp;\n    const float max_iterations =6.0;\n    float depth_trap = 4500.0;\n    for(int iterations=0; iterations < int(max_iterations); iterations++) \n    {\n        Z = c.xy + cmul(Z.xy, vec2(tanh(Z.x), tanh(Z.y)));\n\n        if(dot(Z,Z)>depth_trap) {\n            break;\n        }\n        iterations_temp = iterations;\n    }\n\n    float NIC = (Z.x * Z.x) + (Z.y * Z.y);\n    NIC = float(iterations_temp)/max_iterations-log(sqrt(NIC)+E)/float(iterations_temp);\n    float red = clamp(sin(NIC), 0.0, 1.0);//red*3.0/4.0);\n    float green = clamp(sin(NIC)*sin(NIC), 0.0, red*3.0/5.0);\n\n    /*\nint temp = int(p.x*64.0);\nfor(int i = 0; i < 64 i++)\nif(i == temp)\ngreen = Frequency[int(i)];\n*/\t\n\n    //if(red -green > 0.79) return texture(Frequency, vec2(p.x, p.y)).rgba;\n    return vec4(red, green , 0.0, 0.0);\n\n    /*\n//3-phase flux of 3 different coloring patterns\nreturn vec4(red, green, blue, 0.0) * clamp(sin(time*5.0+0.0), 0.0, 1.0)\n+ vec4(green, red, green, 0.0) * clamp(sin(time*5.0+4.0*PI/3.0), 0.0, 1.0)\n+ vec4(green, green, red, 0.0) * clamp(sin(time*5.0+2.0*PI/3.0), 0.0, 1.0);\n*/\n}\n\nvec3 scienceordie(vec2 uv)\n{\n    \n    uv = uv*2.0-1.0;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), sin(time*PI+seedling)).xy;\n    uv += cos(vec2(time*PI-seedling, time*GR*PI+seedling))/GR/PI;\n    \n    float depth = demon(uv).r;\n    float angle =  depth*PI+time;\n    \n    //uv.xy += depth*vec2(cos(angle), sin(angle))/MATRIX_W;\n    \n    vec2 mymathisbetterthanyours = fract(uv*vec2(MATRIX_W,MATRIX_H));\n    vec2 bitch = floor(uv*vec2(MATRIX_W,MATRIX_H));\n    float number = (mod(iTime*PI*sin(bitch.x+bitch.y*MATRIX_W), 10.0));\n    float digit = SampleDigit(number, GR*mymathisbetterthanyours);\n    \n    \n    vec3 body = smoothstep(0.0, 1.0/GR, smoothstep(0.0, 1.0/GR*E/PI, sqrt(clamp(1.0-length(uv*vec2(1.0, 1.0/GR)*GR), 0.0, 1.0)))*demon(uv*1.125));\n    \n    vec3 science = vec3(0.0, digit, 0.0)*(1.0-body)+body;\n\tfloat or = zero(-uv.x);\n    \n    vec4 die = clamp(fire(uv), 0.0, 1.0);\n    \n    vec3 scene = science*or+(1.0-body)*(1.0-or)*die.rgb;;//+(1.0-or)*body*flux(time+body.r*PI*2.0);\n    return scene;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n    vec4 sample1 = texture(iChannel1, uv);\n    float scale = (exp(sin(time))+1.0/GR/PI/E)*GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n\n        float sydy = saw(seedling*PI);\n        vec3 final = vec3(0.0*sydy);//flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        /*\n        if(i == max_iterations-2)\n        {\n            \n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n\n        }\n        else \n\t\t*/\n        //if(i == max_iterations-1)\n        if(sydy > .5)\n        {\n            /*\n            vec2 mymathisbetterthanyours = fract(quordinitate(uv)*vec2(MATRIX_W,MATRIX_H));\n            vec2 bitch = floor(quordinitate(uv)*vec2(MATRIX_W,MATRIX_H));\n            vec3 face = demon((saw(uv*PI/2.0)*2.0-1.0)*GR);\n        \thit.rgb += (1.0-border)*(1.0-scienceordie)*face;\n            float number = (mod(iTime*sin(bitch.x+bitch.y*MATRIX_W)+(bitch.x)*10.0+(bitch.y)*10.0+(face.r+face.g+face.b)*10.0, 10.0));\n            float digit = SampleDigit(number, GR*mymathisbetterthanyours);\n            hit.rgb += clamp(vec3(0.0, 1.0, 0.0)*scienceordie*digit*(1.0-face), 0.0, 1.0);\n        \t*/\n            vec2 mymathisbetterthanyours = fract(quordinitate(uv));\n            hit.rgb += clamp(sydy*scienceordie(mymathisbetterthanyours), 0.0, 1.0)*smoothstep(0.0, 1.0/GR/E, antispeckle);\n            break;\n        }\n    }\n    \n\n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor = vec4(uv, 0.0, 1.0)*(1.0-border);\n    fragColor = vec4(saw(quordinitate(uv)*PI), 0.0, 1.0)*(1.0-border);\n    fragColor.rgb = GR*(color+hit.rgb)*(1.0-border)+border*smoothstep(0.0, 1.0/GR/PI/GR, 1.0-border);\n    fragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml33RM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1371, 1426, 1447, 1447, 1498], [1500, 1500, 1521, 1521, 1572], [1574, 1574, 1596, 1596, 1635], [1637, 1637, 1659, 1659, 3265], [3267, 3267, 3288, 3288, 3339], [3341, 3341, 3363, 3363, 3402], [3404, 3404, 3432, 3432, 3486], [3488, 3488, 3510, 3510, 5768], [5770, 5821, 5845, 5845, 5946], [6023, 6075, 6097, 6097, 6271], [6273, 6273, 6302, 6302, 6372], [6374, 6374, 6403, 6403, 6487], [6489, 6489, 6557, 6557, 6640], [6642, 6642, 6668, 6668, 6847], [6849, 6849, 6915, 6915, 7523], [7524, 7524, 7596, 7596, 7647], [7649, 7649, 7761, 7761, 8499], [8500, 8500, 8523, 8523, 8626], [8628, 8628, 8648, 8648, 9026], [9028, 9028, 9052, 9052, 9516], [9518, 9518, 9543, 9543, 9845], [9847, 9847, 9868, 9868, 9983], [10086, 10086, 10147, 10147, 11888], [11890, 11890, 11909, 11909, 13649], [13651, 13651, 13679, 13679, 14673], [14676, 14676, 14733, 14733, 18791]]}
{"id": "Ml3GDM", "name": "Mu6k's MetaHexaballs, Remix 1", "author": "CaliCoastReplay", "description": "Just experimenting with Mu6k's amazing MetaHexaBalls with a little Peter Max sensibility.\n\nNo infringement is intended.  Just having fun!\n\nOriginal at:  \n\n\nhttps://www.shadertoy.com/view/Mss3WN", "tags": ["raymarching", "lighting", "occlusion"], "likes": 17, "viewed": 373, "date": "1469567311", "time_retrieved": "2024-06-20T18:38:52.587059", "image_code": "/*\nSimple remix by CaliCoastReplay\n\n--Just coloring/positional experimentations of...\n\nMetaHexaBalls  by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nOriginal at:\nhttps://www.shadertoy.com/view/Mss3WN\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_quality 4\n//#define occlusion_preview\n\n#define noise_use_smoothstep\n\n#define light_color vec3(0.1,0.4,0.6)\n#define light_direction normalize(vec3(.2,1.0,-0.2))\n#define light_speed_modifier 1.0\n\n#define object_color vec3(0.9,0.1,0.1)\n#define object_count 16\n#define object_speed_modifier 1.0\n\n#define render_steps 33\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nvec3 cc(vec3 color, float factor,float factor2) //a wierd color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat noise(float p) // 1D noise\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat max3(float a, float b, float c)//returns the maximum of 3 values\n{\n\treturn max(a,max(b,c));\n}\n\nvec3 bpos[object_count];//position for each metaball\n\nfloat dist(vec3 p)//distance function\n{\n\tfloat d=256.0;\n\tfloat nd;\n\tfor (int i=0 ;i<object_count; i++)\n\t{\n\t\tvec3 np = p+bpos[i];\n\t\tfloat shape0 = max3(abs(np.x),abs(np.y),abs(np.z))-1.0;\n\t\tfloat shape1 = length(np)-1.0;\n\t\tnd = shape0+(shape1-shape0)*2.0;\n\t\td = mix(d,nd,smoothstep(-1.0,+1.0,d-nd));\n\t}\n\treturn d;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 light = light_direction; //global variable that holds light direction\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 background(vec3 d)//render background\n{\n\tfloat t=iTime*0.5*light_speed_modifier;\n\tfloat qq = dot(d,light)*.5+.5;\n\tfloat bgl = qq;\n\tfloat q = (bgl+noise(bgl*6.0+t)*.85+noise(bgl*12.0+t)*.85);\n\tq+= pow(qq,32.0)*2.0;\n\tvec3 sky = vec3(0.1,0.4,0.6)*q;\n    vec3 hsv_sky = rgb2hsv(sky);\n    hsv_sky.x += t/10.0;\n    hsv_sky.z += 0.1;\n    sky = hsv2rgb(hsv_sky);\n\treturn sky;\n}\n\nfloat occlusion(vec3 p, vec3 d)//returns how much a point is visible from a given direction\n{\n\tfloat occ = 1.0;\n\tp=p+d;\n\tfor (int i=0; i<occlusion_quality; i++)\n\t{\n\t\tfloat dd = dist(p);\n\t\tp+=d*dd;\n\t\tocc = min(occ,dd);\n\t}\n\treturn max(.0,occ);\n}\n\nvec3 object_material(vec3 p, vec3 d)\n{\n\tvec3 color = normalize(object_color*light_color);\n\tvec3 n = normal(p,0.1);\n\tvec3 r = reflect(d,n);\t\n\t\n\tfloat reflectance = dot(d,r)*.5+.5;reflectance=pow(reflectance,2.0);\n\tfloat diffuse = dot(light,n)*.5+.5; diffuse = max(.0,diffuse);\n\t\n\t#ifdef occlusion_enabled\n\t\tfloat oa = occlusion(p,n)*.4+.6;\n\t\tfloat od = occlusion(p,light)*.95+.05;\n\t\tfloat os = occlusion(p,r)*.95+.05;\n\t#else\n\t\tfloat oa=1.0;\n\t\tfloat ob=1.0;\n\t\tfloat oc=1.0;\n\t#endif\n\t\n\t#ifndef occlusion_preview\n\t\tcolor = \n\t\tcolor*oa*.2 + //ambient\n\t\tcolor*diffuse*od*.7 + //diffuse\n\t\tbackground(r)*os*reflectance*.7; //reflection\n\t#else\n\t\tcolor=vec3((oa+od+os)*.3);\n\t#endif\n\t\n\treturn color;\n}\n\n#define offset1 4.7\n#define offset2 4.6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iTime*.5*object_speed_modifier + 2.0;\n\t\n\tfor (int i=0 ;i<object_count; i++) //position for each metaball\n\t{\n        float wave_movement = sin(t + float(i));\n\t\tbpos[i] = 3.0*wave_movement*wave_movement*vec3(\n\t\t\tsin(t*0.967+float(i)*42.0),\n\t\t\tsin(t*.423+float(i)*152.0),\n\t\t\tsin(t*.76321+float(i)));\n\t}\n\t\n\t//setup the camera\n\tvec3 p = vec3(.0,0.0,-4.0);\n\tp = rotate_x(p,mouse.y*9.0+offset1);\n\tp = rotate_y(p,mouse.x*9.0+offset2);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.5; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offset1);\n\td = rotate_y(d,mouse.x*9.0+offset2);\n\t\n\t//and action!\n\tfloat dd;\n\tvec3 color;\n\tfor (int i=0; i<render_steps; i++) //raymarch\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd*.7;\n\t\tif (dd<.04 || dd>4.0) break;\n\t}\n\t\n\tif (dd<0.5) //close enough\n    {\n\t\tcolor = object_material(p,d);\n        color.r += .3 + sin(iTime)/10.0;\n        color.b += .2 + uv.y + cos(iTime)/10.0;\n        color.g += .1 + uv.x - uv.y/2.0 + sin(iTime)/10.0;\n        color *= (.7 + background(d)/2.0);\n    }\n\telse\n\t\tcolor = background(d);\n\t\n\t//post procesing\n\tcolor *=.85;\n\tcolor = mix(color,color*color,0.3);\n\tcolor -= hash(color.xy+uv.xy)*.015;\n\tcolor -= length(uv)*.1;\n\tcolor =cc(color,.5,.6);\n    \n    //HSV post processing\n    vec3 hsv_color = rgb2hsv(color);\n    hsv_color.y += 0.05;\n    hsv_color.z += 0.05;\n    color = hsv2rgb(hsv_color);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3GDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[335, 642, 663, 663, 707], [709, 709, 729, 729, 794], [796, 796, 870, 870, 953], [955, 955, 1004, 1004, 1140], [1142, 1142, 1176, 1176, 1251], [1253, 1253, 1289, 1289, 1406], [1408, 1408, 1444, 1444, 1562], [1564, 1564, 1636, 1636, 1663], [1689, 1719, 1758, 1758, 2033], [2035, 2035, 2113, 2113, 2225], [2257, 2303, 2325, 2325, 2656], [2658, 2658, 2680, 2680, 2849], [2851, 2851, 2895, 2895, 3225], [3227, 3227, 3320, 3320, 3470], [3472, 3472, 3510, 3510, 4162], [4205, 4205, 4262, 4262, 5818]]}
{"id": "Ml3GR8", "name": "Box - fog density", "author": "iq", "description": "Analytically integrating quadratically decaying participating media within a box. No raymarching involved.", "tags": ["3d", "fog", "box", "media", "analytical"], "likes": 17, "viewed": 2060, "date": "1467880702", "time_retrieved": "2024-06-20T18:38:53.938718", "image_code": "// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytically integrating quadratically decaying participating media within a box. \n//\n// Similar to https://www.shadertoy.com/view/XljGDy\n//\n// Density is of the form\n//\n// d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n//\n// this can be analytically integrable (it's a degree 6 polynomial)\n\n\n// Other Box functions (http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm)\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n\n//-------------------------------------------------------------------------------------------\n\nvec2 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 resNor ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tresNor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec2( tN, tF );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n//======================================================================================\n\nfloat boxDensity( vec3 wro, vec3 wrd,   // ray origin, ray direction\n                  mat4 txx, vec3 r,     // box center and orientation, box radius\n                  float dbuffer )       // depth buffer\n{\n    vec3 d = (txx*vec4(wrd,0.0)).xyz;\n\tvec3 o = (txx*vec4(wro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/d;\n    vec3 n = m*o;\n    vec3 k = abs(m)*r;\n    vec3 ta = -n - k;\n    vec3 tb = -n + k;\n\tfloat tN = max( max( ta.x, ta.y ), ta.z );\n\tfloat tF = min( min( tb.x, tb.y ), tb.z );\n\tif( tN > tF || tF < 0.0) return 0.0;\n\n    // not visible (behind camera or behind dbuffer)\n    if( tF<0.0 || tN>dbuffer ) return 0.0;\n\n    // clip integration segment from camera to dbuffer\n    tN = max( tN, 0.0 );\n    tF = min( tF, dbuffer );\n    \n    // move ray to the intersection point\n    o += tN*d; tF=tF-tN; tN=0.0;\n\n    // density calculation. density is of the form\n    //\n    // d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n    //\n    // this can be analytically integrable (it's a degree 6 polynomial):\n    \n    vec3 a = 1.0 -     (o*o)/(r*r);\n    vec3 b =     - 2.0*(o*d)/(r*r);\n    vec3 c =     -     (d*d)/(r*r);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t3*t3;\n    float t7 = t3*t4;\n\n    float f = (t1/1.0) *(a.x*a.y*a.z) + \n              (t2/2.0) *(a.x*a.y*b.z + a.x*b.y*a.z + b.x*a.y*a.z) + \n              (t3/3.0) *(a.x*a.y*c.z + a.x*b.y*b.z + a.x*c.y*a.z + b.x*a.y*b.z + b.x*b.y*a.z + c.x*a.y*a.z) +\n              (t4/4.0) *(a.x*b.y*c.z + a.x*c.y*b.z + b.x*a.y*c.z + b.x*b.y*b.z + b.x*c.y*a.z + c.x*a.y*b.z + c.x*b.y*a.z) + \n              (t5/5.0) *(a.x*c.y*c.z + b.x*b.y*c.z + b.x*c.y*b.z + c.x*a.y*c.z + c.x*b.y*b.z + c.x*c.y*a.z) + \n              (t6/6.0) *(b.x*c.y*c.z + c.x*b.y*c.z + c.x*c.y*b.z) + \n              (t7/7.0) *(c.x*c.y*c.z);\n      \n    return f;\n    \n}\n\n\nfloat plnIntersect( in vec3 ro, in vec3 rd, vec4 pln )\n{\n    return (pln.w - dot(ro,pln.xyz))/dot(rd,pln.xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.2, 3.0 );\n\tvec3 rd = normalize( vec3(p,-3.0) );\n\t\n    // box\n    vec3 cen = cos( iTime*vec3(1.0,1.1,1.3) + vec3(2.0,1.5,1.5) + 0.0 )*vec3(1.2,0.3,0.7) + vec3(0.0,0.2,0.5);\n    vec3 rad = vec3(0.4,0.6,0.8);\n    // planes\n    vec4 pl1 = vec4(  0.0, 1.0, 0.0, 0.0 );\n    vec4 pl2 = vec4(  1.0, 0.0, 0.0, 1.0 );\n    vec4 pl3 = vec4( -1.0, 0.0, 0.0, 1.0 );\n    vec4 pl4 = vec4(  0.0, 0.0,-1.0, 1.0 );\n    \n    float th = (-1.0+2.0*smoothstep( 0.8, 0.9, sin( iTime*1.0 )));\n    th *= iResolution.x/iResolution.y;\n    //th = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    \n    vec3 lig = normalize( vec3(0.6,0.3,0.8) );\n\n\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( cen.x, cen.y, cen.z );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n        \n    //float t1 = sphIntersect( ro, rd, sph );\n    vec3 bnor;\n    vec2 br = iBox( ro, rd, txx, txi, rad, bnor ) ;\n    float t1 = br.x;\n    \n    float t2 = plnIntersect( ro, rd, pl1 );\n    float t3 = plnIntersect( ro, rd, pl2 );\n    float t4 = plnIntersect( ro, rd, pl3 );\n    float t5 = plnIntersect( ro, rd, pl4 );\n    \n    float tmin = 1000.0;\n    vec4  omin = vec4(0.0);\n    if( t2>0.0 && t2<tmin ) { tmin=t2; omin=pl1; }\n    if( t3>0.0 && t3<tmin ) { tmin=t3; omin=pl2; }\n    if( t4>0.0 && t4<tmin ) { tmin=t4; omin=pl3; }\n    if( t5>0.0 && t5<tmin ) { tmin=t5; omin=pl4; }\n\n    vec3 col = vec3(0.0);\n    \n    if( tmin<999.0 )\n    {    \n        vec3 pos = ro + tmin*rd;\n\n        col = vec3(0.1,0.15,0.2);\n        col *= 0.8 + 0.4*dot(omin.xyz,lig);\n        \n        vec3 w = abs(omin.xyz);\n        col = (texture( iChannel0, 0.5*pos.zx ).xyz*w.y+\n               texture( iChannel0, 0.5*pos.xy ).xyz*w.z+\n               texture( iChannel0, 0.5*pos.yz ).xyz*w.x)/(w.x+w.y+w.z);\n        col *= 0.3;\n        float occ = 1.0;\n        occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2( 1.0, 0.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2(-1.0, 0.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.yz-vec2( 0.0,-1.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2( 1.0,-1.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2(-1.0,-1.0)));\n        col *= vec3(0.4,0.3,0.2) + vec3(0.6,0.7,0.8)*occ;\n        \n        \n    }\n\n    if( p.x<th && t1>0.0 && t1<tmin )\n    {\n        vec3 pos = ro + t1*rd;\n        \n        col = vec3(0.3);\n                \n        float occ = 1.0;\n        occ = 0.5 + 0.5*bnor.y;\n        occ *= clamp( ( pos.x+1.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( (-pos.x+1.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( ( pos.y-0.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( ( pos.z+1.0)*3.0, 0.0, 1.0 );\n        col *= 0.5 + 0.5*occ;\n    }\n\n   //col *= 0.0;\n   if( p.x>th )\n    {\n        float h = boxDensity(ro, rd, txx, rad, tmin );\n        if( h>0.0 )\n        {\n            col += h;\n            //col += smoothstep( 0.1,1.2,h);\n            //col = mix( col, vec3(1.0,1.0,1.0), clamp(h,0.0,1.0) );\n            //if( h>1.0 ) col=vec3(1.0,0.0,0.0);\n        }\n    }\n    \n    col = sqrt( col );\n    \n    col *= smoothstep( 0.010,0.011,abs(p.x-th));\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3GR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1834, 1929, 2023, 2060, 2580], [2582, 2582, 2629, 2629, 3033], [3035, 3035, 3080, 3080, 3196], [3198, 3288, 3496, 3496, 5189], [5192, 5192, 5248, 5248, 5304], [5306, 5306, 5363, 5363, 8585]]}
{"id": "Ml3Gz8", "name": "Smooth Min Explained", "author": "vgs", "description": "A tutorial explaining the derivation of the polynomial smooth minimum commonly used in Shadertoy.\nSee http://viniciusgraciano.com/blog/smin/ for a full explanation.", "tags": ["tutorial", "smooth", "min", "smoothmin"], "likes": 32, "viewed": 1976, "date": "1467997379", "time_retrieved": "2024-06-20T18:38:54.502498", "image_code": "/* Created by Vinicius Graciano Santos - vgs/2015 \n * This is a tutorial that explains the polynomial smooth minimum.\n *\n * Read my blog post at http://viniciusgraciano.com/blog/smin/ \n * for a complete description including all the maths!\n * \n * This function is a polynomial approximation to the min function,\n * and it is widely used by \"shadertoyers\" to do smooth unions of \n * distance functions that represent objects in raymarchers.\n * There are some nice, simple, and beautiful mathematical ideas in it!\n *\n * Polynomial smin was introduced by iq in the following article:\n * http://iquilezles.org/www/articles/smin/smin.htm\n */\n\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n// Polynomial smooth min (commented version)\n// @input a: first value\n// @input b: second value\n// @float k: 'Smoothness value', usually in the range (0,1].\n//           Values close to zero makes smin converge to min.\n//           Warning: the function is NOT defined at k = 0!\n//           Tip: negative values turn the funtion into smooth max!\nfloat sminExplained(float a, float b, float k) {\n    \n    // Compute the difference between the two values.\n    // This is used to interpolate both values inside the range (-k, k).\n    // Smaller ranges give a better approximation of the min function.\n    float h = a - b;\n    \n    // The interval [-k, k] is mapped to [0, 1],\n    // and clamping takes place only after this transformation.\n    \n    // Map [-k, k] to [0, 1] and clamp if outside the latter.\n    h = clamp(0.5 + 0.5*h/k, 0.0, 1.0);    \n    \n    // Linearly interpolate the input values using h inside (0, 1).\n    // The second term ensures continuous derivatives at the boundaries of [0,1],\n    // but this is not completely obvious! See my blog post for details.\n    return mix(a, b, h) - k*h*(1.0-h);    \n}\n\n// Only rendering functions below this line...\nvec2 gradsmin(vec2 p, float k);\nvec3 plot(vec2 uv, vec2 st) {     \n    float a = cos(uv.x), b = exp(-uv.x);\n    \n    // Distance estimate to f(x) = sin(x)\n    float d1 = abs(uv.y - a) / length(vec2(1.0, sin(uv.x)));\n    \n    // Distance estimate to g(x) = exp(-x)\n    float d2 = abs(uv.y - b) / length(vec2(1.0, -b));\n    \n    // Distance estimate to h(x) = smin(f(x), g(x))    \n    float k = 0.5*(cos(iTime)+1.0)+0.01;\n    float d3 = abs(uv.y - smin(a, b, k)) / length(gradsmin(uv, k));        \n    \n    // Background    \n    vec3 col = vec3(1.0);\n    col *= 0.1 + 0.9*pow(st.x*st.y*(1.0-st.x)*(1.0-st.y), 0.85);\n    \n    // Mix graphs with background\n    const vec3 blue = vec3(29. , 115., 170.)/255.;\n\tconst vec3 yellow = vec3(140., 188., 79.)/255.;\n    const vec3 red = vec3(196., 68., 65.)/255.;    \n    float eps = 8.0/min(iResolution.x, iResolution.y) + 0.008;\n    col = mix(blue, col, smoothstep(0.0, eps, d1));\n    col = mix(yellow, col, smoothstep(0.0, eps, d2));\n    col = mix(red, col, smoothstep(0.0, 1.25*eps, d3));\n        \n    return col;\n}\n\nvec2 gradsmin(vec2 p, float k) {\n    const float eps = 0.01;\n    float dy = smin(cos(p.x+eps), exp(-(p.x+eps)), k)\n    \t\t - smin(cos(p.x-eps), exp(-(p.x-eps)), k);\n    return vec2(1.0, 0.5*dy/eps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;    \n    vec2 uv = vec2(-1.07, -0.75) + vec2(10.0, 1.5)*st;\n    uv.y *= iResolution.x / iResolution.y;\n    \n    vec3 col = plot(uv, st);\n    col = pow(col, vec3(0.45));\n    col = smoothstep(0.0, 1.0, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3Gz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[638, 707, 746, 746, 837], [839, 1186, 1234, 1437, 1960], [1962, 2041, 2070, 2070, 3065], [3067, 3067, 3099, 3099, 3266], [3268, 3268, 3325, 3325, 3607]]}
{"id": "Mlc3D7", "name": "Another Maze", "author": "aiekick", "description": "based on [url=https://www.shadertoy.com/view/4scGWf]Maze 4 (90c)[/url]\n\nclick for fullscreen", "tags": ["maze", "onetweet"], "likes": 13, "viewed": 847, "date": "1469618150", "time_retrieved": "2024-06-20T18:38:54.514509", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define t iDate.w/1e3\n#define t 1e3\n\nconst vec2 gridSize = vec2(5.,4.);//grid size (columns, rows)\n    \nvec2 si;\nfloat ti;\nvec3 m;\n\n// framework ////////////////////////////////////////////\nfloat EncID(vec2 s, vec2 h, vec2 sz) // encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\n{\n    vec2 c = floor(h/s*sz);\n    return c.y*sz.x+c.x;\n}\nvec3 getCell(vec2 s, vec2 h, vec2 sz) // return id / uv\n{\n    vec2 si = s/sz;\n    vec2 c = floor(h/si);\n    float id = c.y*sz.x+c.x;\n    vec2 uv = (h+h-c-c-si)/si.y-0.2;\n    return vec3(id, uv);\n}\n\n//// versions /// same func prototype as mainImage //////\nvoid partImage0( out vec4 f, vec2 g ) // FabriceNeyret2 version\n{\n\tg /= 25.;\n\tf = 1. - vec4(.34,1,1,1)/25.\n                  / abs( fract( g.y + g.x * sign( cos( t * length(floor(g)) )   )\n                              ) - .5);\n}\n\nvoid partImage1( out vec4 f, vec2 g ) // FabriceNeyret2 version\n{\n\tg /= 25.;\n\tg *= mat2(1,-1,1,1)/1.99;\n\tf = 1. - vec4(.34,1,1,1)/25.\n                  / ( fract( cos( t * length(floor(g)) ) <0. ? g.x : g.y\n                              ) - .5);\n}\n\nvoid partImage2( out vec4 f, vec2 g ) // FabriceNeyret2 version\n{\n\tg /= 25.;\n\tfloat s = sign( cos( t * length(floor(g)) ) );\n\tf = 1. - vec4(.34,1,1,1)/25. / cos(3.14*(g.y + g.x * s )) \n                   * (1. - .9 / cos(5.*3.14*(g.x - g.y * s )));\n}\n\nvoid partImage3( out vec4 f, vec2 g ) // FabriceNeyret2 version\n{\n\tg /= 25.;\n\tf = 1. - vec4(.34,1,1,1)/25.\n              / cos(3.14*( g.y + g.x * sign( cos( t * length(floor(g)) ))));\n}\n\nvoid partImage4( out vec4 f, vec2 g ) // FabriceNeyret2 version\n{\n\tg /= 25.;\n\tf = 1. - vec4(.34,1,1,1)/25.\n                  / ( fract( g.y + g.x * sign( cos( t * length(floor(g)) )   )\n                              ) - .5);\n}\n\nvoid partImage5( out vec4 f, vec2 g ) \n{\n\tvec2 h = (g+g-si.xy)/si.y;\n\tg /= 35.;\n    f = cos(h.x)*cos(h.y)*.8 - vec4(.34,1,1,1)/25.\n              / cos(3.14*( g.y + g.x * sign( cos( t * length(floor(g)) ))));\n}\n\nvoid partImage6( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n    float rep = cos(3.14*( g.y + g.x * sign( cos( t * length(floor(g)) ))));\n    f = vec4(rep) * float(abs(rep)>0.1);\n}\n\nvoid partImage7( out vec4 f, vec2 g ) \n{\n\tvec2 h = (g+g-si.xy)/si.y * 0.6;\n\tg /= 25.;\n\tfloat r = cos(h.x)*cos(h.y)*.9;\n\tvec4 col = vec4(.34,1,1,1)/25.;\n\tfloat hash = cos( t * length(floor(g)));\n\tfloat branch = g.y + g.x * sign(  hash );\n\tfloat rep = cos(3.14 * (branch + 1.));\n\tfloat rep_ero =  step(-1., rep);\n\tfloat rep_ero2 =  step(0.01, rep);\n\tvec4 maze = col + r - rep - rep_ero + rep_ero2;\n\tf = maze;\n}\n\nvoid partImage8( out vec4 f, vec2 g ) \n{\n\tvec2 h = (g+g-si.xy)/si.y * 0.6;\n\tvec4 tex = texture(iChannel0, g/si);\n\tg /= 25.;\n\tfloat r = cos(h.x)*cos(h.y)*.7;\n\tvec4 col = vec4(.34,1,1,1)/25.;\n\tfloat hash =cos( t * length(floor(g)));\n\tfloat branch = g.y + g.x * sign(  hash );\n\tfloat rep = cos(3.14 * branch);\n\tfloat tt = sin(ti)*.5 +.5;\n    f = (r - col / rep) * 0.9 + (r - col / step(tex, vec4(rep + tt*2.16))) * 0.1;\n}\n\nvoid partImage9( out vec4 f, vec2 g ) \n{\n\tvec2 h = (g+g-si.xy)/si.y * 0.6;\n\tg /= 25.;\n\tfloat r = cos(h.x)*cos(h.y)*.7;\n\tvec4 col = vec4(.34,1,1,1)/25.;\n\tfloat hash = cos( t * length(floor(g)));\n\tfloat branch = g.y + g.x * sign(  hash );\n\tfloat rep = cos(3.14 * (branch + floor(0.956))) *0.35;\n    f = r - col / rep;\n}\n\nvoid partImage10( out vec4 f, vec2 g ) \n{\n\tvec2 h = (g+g-si.xy)/si.y * 0.6;\n    g /= 25.;\n    float rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ));\n\tf.r = abs(rep) - 0.1;\n\tf.g = abs(rep + 0.2) - 0.2;\n\tf.b = abs(rep - 0.1) - 0.4;\n}\n\nvoid partImage11( out vec4 f, vec2 g ) // nice correction by FabriceNeyret2\n{\n\tvec2 h = cos((g+g-si.xy)/si.y * 0.6 - .3*cos(iTime+vec2(0,1.6)));\n    g /= 25.;\n    float rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ));\n    float x = abs(rep) - h.x*h.y*0.9;\n\tf = 1.-vec4(.34,1,1,1)/25./x*smoothstep(0.,.07,x);\n}\n\nvoid partImage12(out vec4 f, vec2 g ) \n{\n\tvec2 uv = 4.*(2. * g - iResolution.xy)/iResolution.y;\n    g /= 25.;\n    float rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ));\n\tfloat a = atan(uv.x, uv.y) / 3.14159 * 1.5;\n\tfloat r = length(uv) - iTime*0.5;\n\ta+=r+rep;\n\tuv = abs(fract(vec2(a+r,a-r))-0.5);\n\tfloat x = uv.x*1.248;\n\tfloat y = uv.y*6.;\n\tfloat z = uv.y*1.8;\n\tfloat hex = abs(max(x+y,x) - 1.386);\n\tvec3 col = hex * 0.6 * vec3(0.15,0.24,0.37)/length(uv);\n    f.rgb =  col;\n    if (abs(rep) > 0.9)\n        f.rgb = col+.5-vec3(.34,1,1)/25./rep;\n}\n\nvoid partImage13( out vec4 f, vec2 g ) \n{\n\tvec2 uv = 4.*(2. * g - iResolution.xy)/iResolution.y;\n    g /= 25.;\n    float rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ));\n\tfloat a = atan(uv.x, uv.y) / 3.14159 * 1.5;\n\tfloat r = length(uv) - iTime*0.5 + rep;\n\ta+=r * 1.1 ;\n\tuv = abs(fract(vec2(a+r,a-r))-0.5);\n\tfloat x = uv.x*1.248;\n\tfloat y = uv.y*6.;\n\tfloat z = uv.y*1.8;\n\tfloat hex = abs(max(x+y,x) - 1.386);\n\tvec3 col = hex * 0.6 * vec3(0.15,0.24,0.37)/length(uv);\n    f.rgb =  col;\n    if (abs(rep) > 0.9)\n        f.rgb = col+.5-vec3(.34,1,1)/25./rep;\n}\n\nvoid partImage14( out vec4 f, vec2 g ) \n{\n    g /= 25.;\n\tfloat rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ))*.6;\n    g*=1.3;\n    rep += cos(3.14 *( g.x* sign(cos( t * length(floor(g)))) ))*.2;\n    g*=1.3;\n    rep += cos(3.14 *( g.y* sign(cos( t * length(floor(g)))) ))*.2;\n    f = 0.5-vec4(.34,1,1,1)/25./rep;\n}\n\nvoid partImage15( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n\tfloat rep = \n        cos(g.x)*sin(g.y)*0.4 + \n        cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ))*.6;\n    f = 0.5-vec4(.34,1,1,1)/25./(abs(rep)*1.3-(sin(iTime)*.25+.5));\n}\n\n\nvoid partImage16( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n\tfloat rep = cos(3.14 *( g.y + g.x* sign(cos( t * length(floor(g)))) ))*.6;\n\tf = rep-vec4(.34,1,1,1)/25./(abs(rep)-0.5);\n}\n\n\nvoid partImage17( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n\tfloat rep = \n        cos(g.y) * cos(g.y) * tan(sin(ti)*1.1) * 0.4 + \n        cos(3.14 *( g.y + g.x * sign(cos( t * length(floor(g)))) ))*.6;\n\tf = abs(rep)*1.5-vec4(.34,1,1,1)/25./(abs(rep)-0.5);\n}\n\nvoid partImage18( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n\tfloat rep = \n        cos(3.14 *(g.x + g.y * sign(sin( t * length(floor(g))))))*.4 + \n        cos(3.14 *(g.y + g.x * sign(cos( t * length(floor(g))))))*.6;\n\tf = 0.5-vec4(.34,1,1,1)/25./(rep+sin(ti)*0.5);\n}\n\nvoid partImage19( out vec4 f, vec2 g ) \n{\n\tg /= 25.;\n\tfloat rep = \n        mix(cos(g.x), cos(g.y), sin(ti)*.5+.5) * 0.4 + \n        cos(3.14 *( g.y + g.x * sign(cos( t * length(floor(g)))) ))*.6;\n\tf = abs(rep)*1.5-vec4(.34,1,1,1)/25./(abs(rep)-0.5);\n}\n\n//// main ///////////////////////////////////////////////\nvoid mainImage( out vec4 f, vec2 l )\n{\n    si = iResolution.xy;\n    ti = iTime;\n    m = iMouse.xyz;\n    \n    vec2 \n        h = l,\n        g = (h+h-si)/si.y;\n    \n    vec3 cell = getCell(si,h,gridSize);\n    \n    if(m.z>0.) \n        cell = vec3(EncID(si,m.xy,gridSize), g); // cell.x => cell id, cell.yz => central uv of the cell\n    \n    l += vec2(cos(ti*0.2), sin(ti*0.2))*200.;; // circular cell slding\n    \n    if (cell.x == 0.) partImage0(f, l);\n    else if (cell.x == 1.) partImage1(f, l);\n   \telse if (cell.x == 2.) partImage2(f, l);\n   \telse if (cell.x == 3.) partImage3(f, l);\n    else if (cell.x == 4.) partImage4(f, l);\n    else if (cell.x == 5.) partImage5(f, l);\n\telse if (cell.x == 6.) partImage6(f, l);\n\telse if (cell.x == 7.) partImage7(f, l);\n\telse if (cell.x == 8.) partImage8(f, l);\n\telse if (cell.x == 9.) partImage9(f, l);\n\telse if (cell.x == 10.) partImage10(f, l);\n\telse if (cell.x == 11.) partImage11(f, l);\n    else if (cell.x == 12.) partImage12(f, l);\n    else if (cell.x == 13.) partImage13(f, l);\n    else if (cell.x == 14.) partImage14(f, l);\n    else if (cell.x == 15.) partImage15(f, l);\n    else if (cell.x == 16.) partImage16(f, l);\n    else if (cell.x == 17.) partImage17(f, l);\n    else if (cell.x == 18.) partImage18(f, l);\n    else if (cell.x == 19.) partImage19(f, l);\n}\n\n/* original\nvoid mainImage( out vec4 f, vec2 g )\n{\n\tg /= 35.;\n\tf = 1. - vec4(.34,1,1,1)/25.\n                  / abs( fract( g.y + g.x * sign( cos( iDate.w/1e3 * length(floor(g)) )   )\n                              ) - .5);\n}/**/\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlc3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[272, 330, 437, 437, 492], [493, 493, 550, 550, 689], [691, 749, 814, 814, 978], [980, 980, 1045, 1045, 1227], [1229, 1229, 1294, 1294, 1479], [1481, 1481, 1546, 1546, 1666], [1668, 1668, 1733, 1733, 1894], [1896, 1896, 1936, 1936, 2105], [2107, 2107, 2147, 2147, 2278], [2280, 2280, 2320, 2320, 2688], [2690, 2690, 2730, 2730, 3108], [3110, 3110, 3150, 3150, 3427], [3429, 3429, 3470, 3470, 3677], [3679, 3679, 3756, 3756, 4005], [4007, 4007, 4047, 4047, 4569], [4571, 4571, 4612, 4612, 5143], [5145, 5145, 5186, 5186, 5475], [5477, 5477, 5518, 5518, 5717], [5720, 5720, 5761, 5761, 5895], [5898, 5898, 5939, 5939, 6148], [6150, 6150, 6191, 6191, 6408], [6410, 6410, 6451, 6451, 6660], [6662, 6720, 6758, 6758, 8027]]}
{"id": "Mlc3Dn", "name": "Leaf roller", "author": "rohtie", "description": "...", "tags": ["music"], "likes": 1, "viewed": 107, "date": "1468680278", "time_retrieved": "2024-06-20T18:38:54.514509", "image_code": "float smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvoid mainImage( out vec4 o, in vec2 p ) {\n    p /= iResolution.xy;\n    p -= 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    \n    p.y += 0.5;\n    \n    \n    p.x /= 1.0 + abs(texture(iChannel0, vec2(0.0, p.x)).r - 0.5);\n    \n    float result = 1.0 - length(p);\n    p.y += cos(p.x * 10.0 + iTime * 5.0) * 0.25;\n    \n    result = smin(result, p.y, 0.25);\n    result -= abs(p.x) * 2.5;\n    result = smoothstep(0.0, 0.01, result);\n    \n    \n    o.rgb = vec3(0.0);\n    o.rgb += result * vec3(p.y + 0.1, 0.35, 0.25);\n    o.rgb += result * vec3(mod(p.x, 0.5) * vec3(0.0, 1.0, 0.0));\n    o.rgb += (1.0 - result) * vec3(abs(p.x * 2.0 + sin(iTime) * 0.25), abs(p.x * 1.25), 0.25);\n\to.rgb += (1.0 - result) * vec3(0.0, abs(mod(p.y, 0.25)), 0.0);\n    o.rgb += (1.0 - result) * vec3(abs(mod(p.x * 2.0 + iTime, 0.05))) * 3.0;\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlc3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 134], [136, 136, 177, 177, 949]]}
{"id": "Mlc3zn", "name": "GridWhiteBackgroundNi", "author": "jobjb", "description": "related: \nhttps://www.shadertoy.com/view/lsKXzy\nhttps://www.shadertoy.com/view/MdKXDD\n", "tags": ["grid", "layer", "fractorial"], "likes": 3, "viewed": 449, "date": "1467629881", "time_retrieved": "2024-06-20T18:38:54.514509", "image_code": "float f(vec2 p, float t)\n{\n\tp = fract(p/70.+vec2(cos(t), sin(t)))-0.500001;\n\treturn  min(abs(p.x), abs(p.y)) + 0.49999;\n}\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p /= 3.; \n    \n    o -= o;\n    \n    mat2 m = mat2(10., -5.4, 5.4, 10.) * 0.09;\n    \n\tfloat t = iTime * 0.0051;\n\n\tconst float iter = 3.;\n\tfloat lay = 0., olay;\n\tfor (float i = 0.; i < iter; i++)\n\t{\n\t\tlay = f(p, t * 10. * i / iter);\n\t\tif (i > 0.)\tlay = min(olay, lay); olay = lay;\n\t\tp *= m;\n\t}\n    o += lay;\n\t\n\to /= 0.53;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlc3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 121], [123, 123, 164, 164, 490]]}
{"id": "MlcGR8", "name": "Diagonal Gradient _ jr97", "author": "jorovipe97", "description": "Ejercicio de un fragment shader que produce un gradiente diagonal ", "tags": ["diagonalgradient"], "likes": 1, "viewed": 333, "date": "1467844027", "time_retrieved": "2024-06-20T18:38:54.514509", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = vec2(0, 0);\n    \n    xy.x = fragCoord.x / iResolution.x;\n    xy.y = fragCoord.y / iResolution.y;\n    \n\t/*vec4 blackToGreenGradient = vec4(0, xy.x, 0, 1);\n    vec4 verticalGradient = vec4(0, xy.y, 0, 1);\n    vec4 multiColorGradient = vec4(xy.x, xy.y, 0, 1);*/\n    \n    float r, g, b, a;\n    r = (xy.x + xy.y)/2.;\n    g = 0.;\n    b = (xy.x - xy.y)*sin(iTime);\n    a = 1.;\n       \n    vec4 diagonalGradient = vec4(r, g, b, a);\n    fragColor = diagonalGradient;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 531]]}
{"id": "MlcGWr", "name": "Oil Sheen", "author": "akohdr", "description": "Iridescent oil like colour transform on perlin noise.", "tags": ["noise", "perlin", "color", "oil", "iridescence"], "likes": 23, "viewed": 1184, "date": "1468692923", "time_retrieved": "2024-06-20T18:38:54.757001", "image_code": "// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution\n#define T (iTime/3.+5.)\n\nvoid mainImage( out vec4 k, vec2 p )\n{\n\t#define rot(p,a) vec2 sc=sin(vec2(a,a+1.6)); p*=mat2(sc.y,-sc.x,sc);\n\n    #define A vec3(0,1,157)\n    #define B {vec2 m=fract(p),l=dot(p-m,A.yz)+A.xz,r=mix(fract(57.*sin(l++)),fract(57.*sin(l)),(m*=m*(3.-m-m)).x);k+=mix(r.x,r.y,m.y)/(s+=s);p*=mat2(1,1,1,-1);}\n\n    p *= log(T)/R.y;\t\t\t\t// scaling (slow zoom out)\n    p.x += T;\t\t\t\t\t\t// translation\n\trot(p,T/22.);\t\t\t\t\t// slow field rotation\n\n    float s = 1.; k = vec4(0);\t\t// init\n    B B B B // unrolled perlin noise see https://www.shadertoy.com/view/lt3GWn\n\n\tk += sin(2.*sin(k*22.+T*2.)+p.yxyy-p.yyxy*.5)/12.;\t\t// colour transform\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlcGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 175, 213, 213, 798]]}
{"id": "Mld3Rn", "name": "Perspex Web Lattice", "author": "Shane", "description": "Yet another Voronoi variation.", "tags": ["voronoi", "raymarch", "lattice", "web"], "likes": 457, "viewed": 27137, "date": "1467780648", "time_retrieved": "2024-06-20T18:38:56.738903", "image_code": "/*\n\tPerspex Web Lattice\n\t-------------------\n\t\n\tI felt that Shadertoy didn't have enough Voronoi examples, so I made another one. :) I'm\n\tnot exactly sure what it's supposed to be... My best guess is that an Alien race with no \n\tcommon sense designed a monitor system with physics defying materials. :)\n\n\tTechnically speaking, there's not much to it. It's just some raymarched 2nd order Voronoi.\n\tThe dark perspex-looking web lattice is created by manipulating the Voronoi value slightly \n\tand giving the effected region an ID value so as to color it differently, but that's about\n\tit. The details are contained in the \"heightMap\" function.\n\n\tThere's also some subtle edge detection in order to give the example a slight comic look. \n\t3D geometric edge detection doesn't really differ a great deal in concept from 2D pixel \n\tedge detection, but it obviously involves more processing power. However, it's possible to \n\tcombine the edge detection with the normal calculation and virtually get it for free. Kali \n\tuses it to great effect in his \"Fractal Land\" example. It's also possible to do a\n\ttetrahedral version... I think Nimitz and some others may have done it already. Anyway, \n\tyou can see how it's done in the \"nr\" (normal) function.\n\n\tGeometric edge related examples:\n\n\tFractal Land - Kali\n\thttps://www.shadertoy.com/view/XsBXWt\n\n\tRotating Cubes - Shau\n\thttps://www.shadertoy.com/view/4sGSRc\n\n\tVoronoi mesh related:\n\n    // I haven't really looked into this, but it's interesting.\n\tWeaved Voronoi - FabriceNeyret2 \n    https://www.shadertoy.com/view/ltsXRM\n\n*/\n\n#define FAR 2.\n\nint id = 0; // Object ID - Red perspex: 0; Black lattice: 1.\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2), .001);\n    n /= (n.x + n.y + n.z ); // Roughly normalized.\n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    // Loose sRGB to RGB conversion to counter final value gamma correction...\n    // in case you're wondering.\n    return p*p;\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime )*.45 + .5; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    return max(d.y/1.2 - d.x*1., 0.)/1.2;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n// The height map values. In this case, it's just a Voronoi variation. By the way, I could\n// optimize this a lot further, but it's not a particularly taxing distance function, so\n// I've left it in a more readable state.\nfloat heightMap(vec3 p){\n    \n    id =0;\n    float c = Voronoi(p.xy*4.); // The fiery bit.\n    \n    // For lower values, reverse the surface direction, smooth, then\n    // give it an ID value of one. Ie: this is the black web-like\n    // portion of the surface.\n    if (c<.07) {c = smoothstep(0.7, 1., 1.-c)*.2; id = 1; }\n\n    return c;\n}\n\n// Standard back plane height map. Put the plane at vec3(0, 0, 1), then add some height values.\n// Obviously, you don't want the values to be too large. The one's here account for about 10%\n// of the distance between the plane and the camera.\nfloat m(vec3 p){\n   \n    float h = heightMap(p); // texture(iChannel0, p.xy/2.).x; // Texture work too.\n    \n    return 1. - p.z - h*.1;\n    \n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 nr(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function - for comparison with the one below.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.005, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n/*\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n*/\n\n/*\n// Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n*/\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    // Unit direction ray, camera origin and light position.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         o = vec3(0), l = o + vec3(0, 0, -1);\n   \n    // Rotate the canvas. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(1.570796, 0) + iTime/8.); // Fabrice's observation.\n    r.xy = mat2(a, -a.y, a.x) * r.xy;\n\n    \n    // Standard raymarching routine. Raymarching a slightly perturbed back plane front-on\n    // doesn't usually require many iterations. Unless you rely on your GPU for warmth,\n    // this is a good thing. :)\n    float d, t = 0.;\n    \n    for(int i=0; i<32;i++){\n        \n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<0.001 || t>FAR) break;\n        t += d*.7;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Set the initial scene color to black.\n    c = vec4(0);\n    \n    float edge = 0.; // Edge value - to be passed into the normal.\n    \n    if(t<FAR){\n    \n        vec3 p = o + r*t, n = nr(p, edge);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n \n        // Obtain the height map (destorted Voronoi) value, and use it to slightly\n        // shade the surface. Gives a more shadowy appearance.\n        float hm = heightMap(p);\n        \n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        vec3 tx = tex3D(iChannel0, (p*2. + hm*.2), n);\n        //tx = floor(tx*15.999)/15.; // Quantized cartoony colors, if you get bored enough.\n\n        c.xyz = vec3(1.)*(hm*.8 + .2); // Applying the shading to the final color.\n        \n        c.xyz *= vec3(1.5)*tx; // Multiplying by the texture value and lightening.\n        \n        \n        // Color the cell part with a fiery (I incorrectly spell it firey all the time) \n        // palette and the latticey web thing a very dark color.\n        //\n        c.x = dot(c.xyz, vec3(.299, .587, .114)); // Grayscale.\n        if (id==0) c.xyz *= vec3(min(c.x*1.5, 1.), pow(c.x, 5.), pow(c.x, 24.))*2.;\n        else c.xyz *= .1;\n        \n        // Hue rotation, for anyone who's interested.\n        //c.xyz = rotHue(c.xyz, mod(iTime/16., 6.283));\n       \n        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 32.); // Specular.\n        \n        if(id == 1) sp *= sp; // Increase specularity on the dark lattice.\n        \n\t\t// Applying some diffuse and specular lighting to the surface.\n        c.xyz = c.xyz*(df + .75) + vec3(1, .97, .92)*sp + vec3(.5, .7, 1)*pow(sp, 32.);\n        \n        // Add the fake environmapping. Give the dark surface less reflectivity.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        if(id == 1) em *= .5;\n        c.xyz += em;\n        \n        // Edges.\n        //if(id == 0)c.xyz += edge*.1; // Lighter edges.\n        c.xyz *= 1. - edge*.8; // Darker edges.\n        \n        // Attenuation, based on light to surface distance.    \n        c.xyz *= 1./(1. + d*d*.125);\n        \n        // AO - The effect is probably too subtle, in this case, so we may as well\n        // save some cycles.\n        //c.xyz *= cAO(p, n);\n        \n    }\n    \n    \n    // Vignette.\n    //vec2 uv = u/iResolution.xy;\n    //c.xyz = mix(c.xyz, vec3(0, 0, .5), .1 -pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)*.1);\n    \n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    c = vec4(sqrt(clamp(c.xyz, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mld3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1649, 1807, 1857, 1857, 2172], [2175, 2318, 2336, 2336, 2682], [2684, 2706, 2727, 3076, 3579], [3581, 3783, 3808, 3808, 4504], [4506, 4728, 4752, 4752, 5066], [5068, 5311, 5327, 5327, 5454], [6053, 6117, 6152, 6152, 7423], [8322, 8699, 8727, 8727, 9451], [9453, 9453, 9488, 9550, 13165]]}
{"id": "Mlt3D7", "name": "Disturbing Maze 2", "author": "aiekick", "description": "better in fullscreen", "tags": ["maze", "disturbing"], "likes": 2, "viewed": 574, "date": "1469739442", "time_retrieved": "2024-06-20T18:38:56.738903", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    vec2 uv = 4.*(2. * g - iResolution.xy)/iResolution.y;\n\t\n    g /= 45.;\n    \n    float rep = cos(3.14 *( g.y + g.x* sign(sin( 6e3 * length(floor(g)) )) ));\n    \n\tfloat a = atan(uv.x, uv.y) / 3.14159 * 1.5;\n\tfloat r = length(uv) - iTime*0.5 + rep;\n\ta+=r * 1.1 ;\n\tuv = abs(fract(vec2(a+r,a-r))-0.5);\n\t\n\tfloat x = uv.x*1.248;\n\tfloat y = uv.y*6.;\n\tfloat z = uv.y*1.8;\n\tfloat hex = abs(max(x+y,x) - 1.386);\n\tvec3 col = hex * 0.6 * vec3(0.15,0.24,0.37)/length(uv);\n\t\n    \n    f.rgb =  col;\n    if (abs(rep) > 0.9)\n        f.rgb = col+.5-vec3(.34,1,1)/25./rep;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlt3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 599]]}
{"id": "Mlt3R4", "name": "Neighbors", "author": "AmazingThew", "description": "Lots of ways this could be made more efficient but whatever dude computers are fast", "tags": ["2d", "generative"], "likes": 19, "viewed": 330, "date": "1468222592", "time_retrieved": "2024-06-20T18:38:57.720802", "image_code": "//Inspired by a diagram in this article on Build Engine's software rendering: http://fabiensanglard.net/duke3d/build_engine_internals.php\n//Initial circle grid adapted from here: http://webstaff.itn.liu.se/~stegu/webglshadertutorial/shadertutorial.html\n//Uses Brian Sharpe's Wombat code for simplex noise: https://github.com/BrianSharpe/Wombat\n\nconst float samples = 4.0; //Square this number to get supersample level\nconst float cells = 50.0;\nconst float noiseScale = 15.0;\nconst float angle = -1.0;\nconst mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\nconst float hRange = 0.5;\nconst float vRange = 1.0 - hRange;\nconst float radius = 0.6;\nconst float shift = 0.47;\nconst float speed = 0.2;\n\nconst vec4 bgColor = vec4(0.04, 0.07, 0.12, 1.0);\nconst vec4 hColor = vec4(0.43, 0.15, 0.24, 1.0);\nconst vec4 vColor = vec4(0.18, 0.29, 0.37, 1.0);\n\nfloat SimplexPerlin3D( vec3 P );\n\nfloat getNoise(vec2 pos) {\n    float noiseZ = iTime * speed;\n    float noise = SimplexPerlin3D(vec3(pos, noiseZ)) * 0.5 + 0.5;\n    float gradient = (pos * rot).y / noiseScale + shift; //set to 0 to visualize noise\n    \n    return clamp(noise+gradient, 0.0, 1.0);\n}\n\nvec4 samplePixel(vec2 uv) {\n    vec2 nearest = 2.0*fract(cells * uv) - 1.0;\n    float dist = length(nearest);\n    \n    float circle = 1.0 - step(radius, dist);\n    float left   = mix(step(0.0, -nearest.x), 0.0, step(radius, abs(nearest.y)));\n    float right  = mix(step(0.0,  nearest.x), 0.0, step(radius, abs(nearest.y)));\n    float top    = mix(step(0.0,  nearest.y), 0.0, step(radius, abs(nearest.x)));\n    float bottom = mix(step(0.0, -nearest.y), 0.0, step(radius, abs(nearest.x)));\n    \n    \n    vec2 point = floor(uv * cells) / cells;\n    vec2 lPoint = point - vec2(1.0/cells, 0.0);\n    vec2 rPoint = point + vec2(1.0/cells, 0.0);\n    vec2 tPoint = point + vec2(0.0, 1.0/cells);\n    vec2 bPoint = point - vec2(0.0, 1.0/cells);\n    point  *= noiseScale;\n    lPoint *= noiseScale;\n    rPoint *= noiseScale;\n    tPoint *= noiseScale;\n    bPoint *= noiseScale;\n    \n    float noise  = getNoise(point);\n    float lNoise = getNoise(lPoint);\n    float rNoise = getNoise(rPoint);\n    float tNoise = getNoise(tPoint);\n    float bNoise = getNoise(bPoint);\n    \n    float hShape = clamp(\n        circle +\n        mix(left,  0.0, step(hRange, 1.0 - lNoise)) +\n        mix(right, 0.0, step(hRange, 1.0 - rNoise)),\n        0.0, 1.0);\n    \n    float vShape = clamp(\n        circle +\n        mix(top,    0.0, step(vRange, tNoise)) +\n        mix(bottom, 0.0, step(vRange, bNoise)),\n        0.0, 1.0);\n    \n    float vMap = mix(vShape, 0.0, step(vRange, noise));\n    float hMap = mix(hShape, 0.0, step(hRange, 1.0 - noise));\n    \n    return mix(mix(bgColor, hColor, hMap), vColor, vMap);\n}\n\nvec4 superSamplePixel(vec2 pos) {\n    float off = 1.0 / samples / iResolution.x;\n    vec4 sum = vec4(0.0);\n    for (float x=0.0; x<samples-0.01; x+=1.0) {\n        for (float y=0.0; y<samples-0.01; y+=1.0) {\n            sum += samplePixel(pos + vec2(off*x, off*y));\n        }\n    }\n    return sum / (samples * samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    uv *= rot;\n    fragColor = vec4(vec3(superSamplePixel(uv)), 1.0);\n}\n\n\n\n\n\n\n\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I'm not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson's and Ian McEwan's work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlt3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[372, 895, 921, 921, 1159], [1161, 1161, 1188, 1188, 2739], [2741, 2741, 2774, 2774, 3061], [3063, 3063, 3120, 3120, 3234], [4205, 4275, 4308, 4419, 7370]]}
{"id": "Mlt3W4", "name": "007 contour line fun", "author": "kakaxizhhgjh", "description": "original: https://www.shadertoy.com/view/llt3W4\naccording to aiekick's suggestion, i do some change, fantastic!!!!!", "tags": ["contourline"], "likes": 4, "viewed": 158, "date": "1469377396", "time_retrieved": "2024-06-20T18:38:57.720802", "image_code": "float plot_edge(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, abs(d));\n}\n\nfloat plot_solid(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, max(0.0, d));\n}\n\nfloat plot_solid_with_blooming(float d) {\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\nfloat box(vec2 p) {\n\treturn length(max(abs(p.x),abs(p.y))) - 0.5 * sin(iTime - length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = box(uv);\n    vec3 bg = mix(vec3(0.3, 0.8, 1.0), vec3(1.0, 0.8, 0.6), plot_solid_with_blooming(d));\n    bg = mix(bg, vec3(1.0, 0.0, 0.0), plot_solid(d));\n    bg = mix(bg, vec3(0.0), plot_edge(d));\n    bg -= vec3(0.1) * plot_edge(mod(d + 0.025, 0.05) - 0.025);\n    bg -= vec3(0.3) * plot_edge(mod(d + 0.1, 0.2) - 0.1);\n    fragColor = vec4(bg, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlt3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 82], [84, 84, 111, 111, 172], [174, 174, 215, 215, 251], [253, 253, 272, 272, 345], [347, 347, 404, 404, 834]]}
{"id": "MltGzM", "name": "perlin + advection + flownoise 2", "author": "FabriceNeyret2", "description": "( mouse.x : show the trick > see FLAGS & comments )\nMix of simple procedural advection shader + smart blending shader.\n4 procedural layers : 3 vortex splats + background.\nEach done by combining 3 phased regenerated texture.\nMaintains constant contrat.", "tags": ["procedural", "texture", "perlin", "sprite", "blend", "advection", "variance", "flownoise", "lagrangian", "smartblend"], "likes": 53, "viewed": 2400, "date": "1468485061", "time_retrieved": "2024-06-20T18:38:58.690678", "image_code": "// variant of advection of procedural flownoise https://www.shadertoy.com/view/lltGRN\n// with smart blendind of multiple splats https://www.shadertoy.com/view/4dcSDr\n\n#define FLOWNOISE 1  // 0: regular Perlin   1: flownoise\n#define MODE 1       // 0: bozo   1: fire   2: cloud\n#define DISP 0       // 0: noise = value    1: noise = displacement (better with bozo)  \n#define SCALE 1.     // noise wavelength\n#define ROT  1       // 1: center fastest   2: center slowest  \n#define radius .3    // radius of the vortices orbit\n#define MORPH 1      // 1: advection 0: final blend (fire only)\n\n// --- texture advection: \n// from https://www.shadertoy.com/view/XsdXWn\n// cf https://hal.inria.fr/inria-00537472  ( also exist in Lagrangian form )\n// here, we only do the simple 3-phase version, each fading-in/out before too much distortion.\n\n// --- flow noise:  \n// from https://www.shadertoy.com/view/MstXWn\n// cf publi http://evasion.imag.fr/~Fabrice.Neyret/flownoise/index.gb.html\n//          http://mrl.nyu.edu/~perlin/flownoise-talk/\n// The raw principle is trivial: rotate the gradients in Perlin noise.\n// Complication: checkboard-signed direction, hierarchical rotation speed (many possibilities).\n// Not implemented here: pseudo-advection of one scale by the other.\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define CS(a)  vec2(cos(a),sin(a))\n\n// --- Perlin noise by inigo quilez - iq/2013   https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\n}\n\n// noise with flownoise extension (rotation of gradients)\nfloat level=1.;\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.-2.*f);\n#if FLOWNOISE\n    float t = exp2(level)* .4*iTime;\n    mat2  R = rot(t);\n#else\n    mat2  R = mat2(1,0,0,1);\n#endif\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    return 2.*mix( mix( dot( hash( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                        dot( hash( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                   mix( dot( hash( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                        dot( hash( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n}\n\n// --- turbulence: non-advected version ( for reference )\n\nfloat Mnoise( vec2 uv ) {\n#  if MODE==0\n    return noise(uv);                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(noise(uv)));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(noise(uv)));     // cloud like\n#endif\n}\n\nmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat turb( vec2 uv )\n{ \tfloat f;\n\t\n level=1.;\n    f  = 0.5000*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.2500*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.1250*Mnoise( uv ); uv = m*uv; level++;\n\tf += 0.0625*Mnoise( uv ); uv = m*uv; level++;\n\treturn f/.9375; \n}\n\n// --- turbulence: advected version \n\nvec4 early_turb( vec2 uv ) // sample a multiscale vector of linear noise to be interpolated\n{\n    vec4 N;\n    level = 1.;\n    N[0] = noise(uv); uv = m*uv; level++;\n    N[1] = noise(uv); uv = m*uv; level++;\n    N[2] = noise(uv); uv = m*uv; level++;\n    N[3] = noise(uv); uv = m*uv; level++;\n    return N;\n}\n\nvec4 Mnoise( vec4 N ) {   // apply non-linearity 1 (per scale) after blending\n#  if MODE==0\n    return N;                      // base turbulence\n#elif MODE==1\n    return -1. + 2.* (1.-abs(N));  // flame like\n#elif MODE==2\n    return -1. + 2.* (abs(N));     // cloud like\n#endif\n}\n    \nfloat deferred_turb( vec4 N ) // apply cascade + optional non-linearity 2 (LUT) after blending\n{\n    N = Mnoise(N);   \n    float f;\t\n    f  = 0.5000*N[0]; \n\tf += 0.2500*N[1];\n\tf += 0.1250*N[2];\n\tf += 0.0625*N[3];\n\treturn f/.9375;     \n}\n\n\n// --- custom texture fetch\n//#define T(u)  texture(iChannel0, u )     // fetch noise texture\n  #define T(u)    early_turb((u)*3./(SCALE)) // fetch flownoise\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = mod(iTime,6.283)*(MODE==1 ? 2. : 1.), Kt=0.;\n\tvec2  R = iResolution.xy,\n         uv = (U -.5*R ) / R.y, uvl,Pl,\n          m = (iMouse.xy -.5*R ) / R.y; if (length(iMouse.xy/R)<.01) m = vec2(0);\n    \n    O-=O;\n    \n    // --- smart blending of splats --------------------------------------\n    for (float k=-1.; k<3.; k++) {   // 4 layers: background (k=-1) + 3 vortices\n    float l,K,v;\n    if (k<0.) { uvl = uv; Pl=vec2(0); K=.3; v=0.;}// k=-1: background motion\n    else {                                        // 3 vortices\n       Pl  = radius*CS(2.1*k - .5*iTime),   // splat center\n       uvl = uv-Pl;                               // local coords in the splat\n       l = length(uvl),\n       K = exp(-.5*l*l/radius/radius),            // kernel of the splat\n   //  K = smoothstep(1.,0.,.7*l/radius),\n#if ROT==1\n       v = 3./(.01+l);                            // rotation(r) within the splat\n#else        \n       v = 30.*l;\n#endif\n    }\n      Kt += K*K;\n       // --- 3-phased advection --------------------------------------\n      for (float i=0.; i<3.; i++) {       // the 3 phases per layer for advection illusion\n        float ti = t+ 6.283/3.*i,\n              wi = K* (.5-.5*cos(ti))/1.5;\n\n        vec2 uvi = uvl*rot(.3*(-.5+fract(ti/6.283))*v); // NB: we should add an offset per splat\n        //if (i>0.) break; else wi=K;  // uncomment to show smearing if naive advection\n        //if (i>0.) break;             // uncomment to show advection trick with 1 layer\n        if (uv.x < m.x)                // left: result\n#if MORPH\n            O += T (.5 + uvi )  * wi;\n#else\n            O += wi * vec4(1,.6,.3,0)* 2.* pow(max(0.,deferred_turb(T (.5 + uvi ))), 2.);\n#endif          \n\t    else                           // right: grid showing the trick\n            O[int(i)] += texture(iChannel1, .5 + uvi ).x  * wi;  // show each phase in colors\n    }\n  }\n  O /= sqrt(Kt); // normalisation by the cumulated std-dev, for constant contrast\n    \n    \n// --- only with procedural advection: deferred noise.    \n    if (uv.x < m.x && MORPH==1) // rendered side\n#if DISP\n        uv.x += .9*deferred_turb(O),\n        O = .5+.5*vec4 (sin(30.*(uv.x-uv.y)) ); \n#else\n#  if   MODE==0\n        O = vec4(.5 + deferred_turb(O));\n#  elif MODE==1\n        O = vec4(1,.6,.3,0)* 2.* pow(max(0.,deferred_turb(O)), 2.); \n#  elif MODE==2\n        O = mix(vec4(0,0,.3,1),vec4(2),.5 + .5*deferred_turb(O)); \n#  endif\n#endif\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MltGzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1355, 1441, 1462, 1462, 1581], [1583, 1657, 1680, 1680, 2222], [2224, 2283, 2308, 2308, 2535], [2578, 2578, 2601, 2601, 2835], [2837, 2875, 2968, 2968, 3180], [3182, 3182, 3205, 3259, 3462], [3468, 3468, 3564, 3564, 3704], [3707, 3867, 3908, 3908, 6331]]}
{"id": "MsS3D1", "name": "Simple material system ", "author": "kig", "description": "Added a simple material system to the spectral dispersion shader.", "tags": ["raytrace", "materials", "dispersion"], "likes": 29, "viewed": 535, "date": "1469776008", "time_retrieved": "2024-06-20T18:39:00.169484", "image_code": "struct ray\n{\n\tvec3 p;\n\tvec3 d;\n\tvec3 light;\n\tvec3 transmit;\n};\n\nstruct material\n{\n\tvec3 transmit;\n\tfloat ior;\n    float diffuse;\n    float roughness;\n};\n\nstruct sphere\n{\n\tvec3 p;\n\tfloat r;\n\tmaterial m;\n};\n    \nstruct hit\n{\n    float distance;\n    vec3 normal;\n    material m;\n};\n\nfloat raySphereDet(ray r, sphere s, inout float b)\n{\n\tvec3 rc = r.p-s.p;\n\tfloat c = dot(rc, rc);\n\tc -= s.r*s.r;\n\tb = dot(r.d, rc);\n\treturn b*b - c;\n}\n\nfloat rayIntersectsSphere(ray r, sphere s, inout vec3 nml, inout sphere dst, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(r, s, b);\n\tif (d < 0.0) {\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d);\n\tfloat nd = sign(t);\n\tif (t < 0.0) {\n\t\tt += 2.0*sqrt(d);\n\t}\n\tif (t < 0.0 || t > closestHit) {\n\t\treturn closestHit;\n\t}\n\tnml = nd * normalize(s.p - (r.p + r.d*t));\n\tdst = s;\n\treturn t;\n}\n\nfloat rayIntersectsPlane(ray r, vec3 p, vec3 pnml, inout vec3 nml, float closestHit)\n{\n\tfloat pd = dot(pnml, r.d);\n\tfloat dist = dot(pnml, p-r.p) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\treturn dist;\n\t}\n\treturn closestHit;\n}\n\nfloat rayIntersectsDisk(ray r, vec3 p, vec3 pnml, float r1, float r2, material m, inout vec3 nml, inout material dst, float closestHit)\n{\n\tvec3 tmp;\n\tfloat dist = rayIntersectsPlane(r, p, pnml, tmp, closestHit);\n\tfloat len = length(r.p + dist*r.d - p);\n\tif (dist != closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tdst = m;\n\t\treturn dist;\n\t}\n\treturn closestHit;\n}\n\nfloat rayIntersectsAABB(ray r, vec3 p, vec3 dims, material m, inout vec3 nml, inout material dst, float closestHit)\n{\n    vec3 invRay = 1.0 / r.d;\n    vec3 aabbMin = p - dims;\n    vec3 aabbMax = p + dims;\n    vec3 v1 = (aabbMin - r.p) * invRay;\n    vec3 v2 = (aabbMax - r.p) * invRay;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n    float enter = max(n.x, max(n.y, n.z));\n    float exit = min(f.x, min(f.y, f.z));\n    \n    float t = enter <= 0.0 ? exit : enter;\n\n    if (exit > 0.0 && enter < exit && t > 0.0 && t < closestHit)\n    {\n        vec3 np = ((r.p + r.d * t) - p);\n        nml = -normalize(np/dims * step(dims-0.0001, abs(np)));\n        dst = m;\n        return t;\n    }\n    return closestHit;\n}\n\nvec3 shadeBg(vec3 nml)\n{\n    vec3 lightPos_ = vec3(\n        -cos(iTime)*-12.0, \n        3.5+sin(iTime*2.05)*8.0, \n        (sin(iTime)*12.0-5.4)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 4.0, 2.0);\n\tvec3 bgCol = vec3(0.2, 0.2, 0.2);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tfloat isp = max(-sunPow, 0.0);\n\tbgCol += max(-0.5, bgDiff)*vec3(0.25, 0.5, 0.75);\n\tbgCol += bgCol*(2.0*pow(isp, 2.0) + pow(sp, 128.0));\n\tbgCol += sun*(pow(sp, 256.0) + 0.1*pow(sp, 2.0));\n\treturn max(vec3(0.0), bgCol);\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nbool getBit(float n, float i)\n{\n\treturn (mod(n / pow(2.0, i), 2.0) < 1.0);\n}\n\nfloat scene(inout ray r, inout vec3 nml, inout material m) {\n\tfloat dist;\n\tsphere s, dst;\n\ts.m.transmit = vec3(1.0);\n\ts.m.ior = 1.15;\n\tdst = s;\n\t\n\t// Test a bunch of spheres for ray-sphere intersection.\n\tdist = 10000.0;\n\ts.p = vec3(0.0);\n\ts.r = 0.5;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(1.0, 1.0, -1.0);\n\ts.r = 0.95;\n\ts.m.transmit = vec3(0.8, 0.8, 0.9);\n\ts.m.ior = 1.3;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(1.0, -1.0, 1.0);\n\ts.m.transmit = vec3(0.5, 0.6, 0.5);\n\ts.m.ior = 3.0;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(-1.0, -1.0, -1.0);\n\ts.m.transmit = vec3(1.0, 0.6, 0.4);\n\ts.m.ior = 1.13;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.p = vec3(-1.0, 1.0, 1.0);\n\ts.m.transmit = vec3(0.3, 0.3, 0.3);\n\ts.m.ior = 1.9;\n\tdist = rayIntersectsSphere(r, s, nml, dst, dist);\n\ts.m.transmit = vec3(0.95);\n\ts.m.ior = 1.5;\n    dist = rayIntersectsAABB(r, vec3(0.0), vec3(0.2, 1.0, 0.2), s.m, nml, dst.m, dist);\n\ts.m.transmit = vec3(0.8,0.5,0.4);\n\ts.m.ior = 3.2;\n\tdist = rayIntersectsDisk(r, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 0.9, s.m, nml, dst.m, dist);\n\tm = dst.m;\n\treturn dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 uv = (1.0 - 2.0 * (fragCoord.xy / iResolution.xy)) * aspect;\n\n\tmat3 rot = rotationXY( vec2( iTime, iTime*0.32 ) );\n\n\tray r;\n\tr.p = vec3(uv*0.2, -3.0);\n\tr.d = normalize(vec3(uv, 1.0));\n\tr.d *= rot;\n\tr.p *= rot;\n\tr.transmit = vec3(1.0);\n\tr.light = vec3(0.0);\n\n\tfloat epsilon = 0.015;\n\tfloat rayCount=0.0, rayBounceCount=0.0;\n\tbool rayComplete = false;\n\n\tvec3 rgb = vec3(0.0);\n\t\n\t// Max number of paths shot out of camera.\n\t// Double to add a recursion level.\n\tfloat maxRays = 32.0;\n\tfloat maxBounceCount = 5.0;\n\t\n\t// Evaluate a bunch of ray segments.\n\t// Bump maxRays to 64.0, maxBounceCount to 7.0 and the ray segments to 64*7 \n\t// for some more flares.\n\tfor (int i=0; i<32*5*3; i++) {\n\t\t\n\t\tvec3 nml;\n\t\tmaterial m;\n\t\tfloat dist = scene(r, nml, m);\n\t\t\n\t\tif (dist != 10000.0) {\n\t\t\t// Move ray to surface.\n\t\t\tr.p += r.d*dist;\n\t\t\t\n\t\t\t// Fresnel term, increase reflectivity on surfaces parallel to ray.\n\t\t\tfloat f = pow(1.0 - clamp(0.0, 1.0, dot(nml, r.d)), 5.0);\n\t\t\t\n\t\t\t// Whether to reflect or refract on this step.\n\t\t\t// The idea is to generate all permutations of a reflect/refract\n\t\t\t// path by using an N-bit number where each bit determines whether\n\t\t\t// the bounce at this step reflects or refracts.\n\t\t\t//\n\t\t\t// (rayCount >> rayBounceCount) & 1\n\t\t\tif (!getBit(floor(rayCount / 3.0), rayBounceCount)) {\n\t\t\t\tr.d = reflect(r.d, nml);\n\t\t\t\t// Fade the ray by the surface's absorption.\n\t\t\t\t// Use the Fresnel term to boost reflection strength.\n\t\t\t\tr.transmit *= (1.0+f)*m.transmit;\n\t\t\t} else {\n\t\t\t\t// Figure out which wavelength we're tracing.\n\t\t\t\t// 0 = red, 1 = green, 2 = blue\n\t\t\t\tfloat c = mod(rayCount, 3.0);\n\t\t\t\t// Simulate air -> diamond refraction.\n\t\t\t\t// Change index of refraction by the wavelength.\n\t\t\t\tfloat eta = 1.000239 / pow(m.ior, (c*0.07)+1.0);\n                if (dot(r.d, nml) > 0.0) {\n                    nml = -nml;\n                    eta = 1.0 / eta;\n                }\n\t\t\t\tr.d = refract(r.d, -nml, eta);\n\t\t\t\t// Fade the ray by the volume's transmission.\n\t\t\t\t// Use the Fresnel term to reduce transmission.\n\t\t\t\tr.transmit *= (1.0-f)*m.transmit;\n\t\t\t}\n\t\t\t\n\t\t\trayBounceCount++;\n\t\t\tif (rayBounceCount > maxBounceCount) {\n\t\t\t\trayComplete = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Offset ray to avoid double-colliding with same surface.\n\t\t\tr.p += r.d*epsilon;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// Add background light to the ray.\n\t\t\tr.light = r.transmit * shadeBg(-r.d);\n\t\t\t// Use only the wanted wavelength.\n\t\t\tfloat c = mod(rayCount, 3.0);\n\t\t\tif (c == 0.0) {\n\t\t\t\trgb.r += r.light.r; \n\t\t\t} else if (c == 1.0) {\n\t\t\t\trgb.g += r.light.g;\n\t\t\t} else {\n\t\t\t\trgb.b += r.light.b;\n\t\t\t}\n\t\t\trayComplete = true;\n\t\t\t\n\t\t}\n\t\t\n\t\tif (rayComplete) {\n\t\t\t\n\t\t\trayComplete = false;\n\t\t\trayCount++;\n\t\t\t\n\t\t\t// If the ray didn't hit anything or\n\t\t\t// if we've done enough rays, quit.\n\t\t\tif ((rayBounceCount == 0.0 && rayCount == 3.0) || rayCount == maxRays) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// Reset bounce count.\n\t\t\trayBounceCount = 0.0;\n\t\t\t\n\t\t\t// Reset ray back to camera.\n\t\t\tr.p = vec3(uv*0.2, -3.0);\n\t\t\tr.d = normalize(vec3(uv, 1.0));\n\t\t\tr.d *= rot;\n\t\t\tr.p *= rot;\n\t\t\t\n\t\t\t// Make ray transparent again.\n\t\t\tr.transmit = vec3(1.0);\n\t\t}\n\t}\n\t\n\t// Gamma curve the average ray light.\n\tfragColor = vec4(1.0 - exp(-rgb*3.0/rayCount * 2.5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsS3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[280, 280, 332, 332, 429], [431, 431, 527, 527, 821], [823, 823, 909, 909, 1117], [1119, 1119, 1256, 1256, 1488], [1490, 1490, 1607, 1607, 2202], [2204, 2204, 2228, 2228, 2837], [2839, 2839, 2870, 2870, 3075], [3077, 3077, 3108, 3108, 3153], [3155, 3155, 3215, 3215, 4319], [4321, 4321, 4378, 4378, 7633]]}
{"id": "MsVSWd", "name": "Fractal Plates 8", "author": "vox", "description": "Fractal Plates 8", "tags": ["fractalplates8"], "likes": 7, "viewed": 493, "date": "1467495278", "time_retrieved": "2024-06-20T18:39:01.308993", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__))*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI)*(1.0-saw(x*PI))))\n\n#define GRID_COUNT (50.0)\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n//-----------------BETTER WAY?-----------------\n\nvec3 pow2(vec3 x, float y){ return vec3(pow(x.x, y), pow(x.y, y), pow(x.z, y)); }\n\nfloat seedling = 0.0;\n\n//-----------------IFS TRANSFORMATIONS-----------------\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sample1 = texture(iChannel1, uv);\n    float height = max(lowAverage(), last_height)-1.0/30.0;\n    float beat = clip(height);\n    float scale = exp(sin(time))*PI;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    uv += cos(vec2(time, time/GR))/PI/E;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 5;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n        border *= GUASS(antispeckle);\n        \n\n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i > 0)\n        {\n            uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n            border_color += (border+float(i))*GUASS(antispeckle);\n\n        \tborder *= GUASS(antispeckle);\n        }\n    }\n    \n    color = pow2(color, 1.0/float(max_iterations));\n    \n    antispeckle = pow(antispeckle, .5/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsVSWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1077, 1126, 1153, 1153, 1207], [1232, 1289, 1311, 1311, 1485], [1487, 1487, 1516, 1516, 1586], [1588, 1588, 1617, 1617, 1701], [1703, 1703, 1771, 1771, 1854], [1856, 1856, 1882, 1882, 2089], [2091, 2091, 2157, 2157, 2765], [2766, 2766, 2838, 2838, 2889], [2891, 2891, 3003, 3003, 3741], [3742, 3742, 3765, 3765, 3868], [3870, 3870, 3890, 3890, 4268], [4296, 4296, 4353, 4353, 7436]]}
{"id": "MsVXDt", "name": "Elemental Ring", "author": "otaviogood", "description": "This shader was inspired by https://www.shadertoy.com/view/MtBSWR. I wanted to do a 3d version.", "tags": ["raymarch"], "likes": 67, "viewed": 1842, "date": "1468997481", "time_retrieved": "2024-06-20T18:39:03.212194", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 11.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n// This is the function that makes the geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material number\nvec2 DistanceToObject(vec3 p)\n{\n    float time = localTime*2.0;\n    float cylRadBig = 1.0;\n    float cylRadSmall = 0.05;\n    float freq = 4.0;\n    float braidRad = 0.15;\n    float angle = atan(p.z, p.x);\n    float cylDist = length(p.xz) - cylRadBig;\n    vec3 cylWarp = vec3(cylDist, p.y, angle);\n    float amp = sin(angle + time) * 0.5 + 0.5;\n\n    float theta = angle*freq;\n    vec2 wave1 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave1 *= amp;\n    //float d = length(cylWarp.xy + wave1) - cylRadSmall;\n    float d = sdBox(vec3(cylWarp.xy + wave1, 0.0), vec3(cylRadSmall));\n    float final = d;\n\n    theta = angle*freq + TAU / 3.0;\n    vec2 wave2 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave2 *= amp;\n    //d = length(cylWarp.xy + wave2) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave2, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    theta = angle*freq - TAU / 3.0;\n    vec2 wave3 = vec2(sin(theta), cos(theta)) * braidRad;\n    wave3 *= amp;\n    //d = length(cylWarp.xy + wave3) - cylRadSmall;\n    d = sdBox(vec3(cylWarp.xy + wave3, 0.0), vec3(cylRadSmall));\n    final = smin(final, d, 0.1);\n\n    vec2 matd = vec2(final, fract((angle+time) / TAU+0.5));\n    float sliver = cyl(cylWarp.xy, 0.03);\n    glow += 1.0 / (sliver * sliver * sliver * sliver + 1.0);\n    //sliver = max(sliver, abs(fract(cylWarp.z*freq-2.0*localTime)-0.5)-0.3);\n    matd = matMin(matd, vec2(sliver, -1.0));\n    return matd;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.2;\n    uv /= zoom;\n\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;\n\tfloat my=-iMouse.y/iResolution.y*10.0;\n#ifndef MANUAL_CAMERA\n    camPos = vec3(0.0);\n    camPos.y = sin(localTime*0.125)*3.0;\n    camPos.z = cos(localTime*0.125)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#else\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distMat = vec2(1.0, 0.0);\n\tfloat t = 0.0 + Hash2d(uv)*1.6;\t// random dither glow by moving march count start position\n\tconst float maxDepth = 6.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n    float marchCount = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 80; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = camPos + rayVec * t;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distMat = DistanceToObject(pos);\n\n        // Move along the ray.\n        // Leave room for error by multiplying in case distance function isn't exact.\n        t += distMat.x * 0.8;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distMat.x) < smallVal)) break;\n\n        // Glow if we're close to the part of the ring with the braid.\n        float cyc = (-sin(distMat.y * TAU))*0.5+0.7;\n        // This function is similar to a gaussian fall-off of glow when you're close\n        // to an object.\n        // http://thetamath.com/app/y=(1)/((x*x+1))\n        marchCount += cyc / (distMat.x * distMat.x + 1.0);\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n    // Save off ray-march glows so they don't get messed up when we call the distance\n    // function again to get the normal\n\tfloat glowSave = glow;\n    float marchSave = marchCount;\n    marchCount = 0.0;\n    glow = 0.0;\n\n    // default to blueish background color.\n\tvec3 finalColor = vec3(0.09, 0.15, 0.35);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(distMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 texColor = vec3(0.0, 0.0, 0.1);\n        if (distMat.y < 0.0) texColor = vec3(0.6, 0.3, 0.1)*110.0;\n\n        finalColor = texColor;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    // add the ray marching glows\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*0.00625;\n    finalColor += vec3(1.0, 0.5, 0.3) * marchSave*0.05;\n\n    // vignette\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(saturate(finalColor));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsVXDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1174, 1203, 1222, 1222, 1267], [1268, 1268, 1287, 1287, 1318], [1319, 1319, 1342, 1342, 1378], [1379, 1379, 1402, 1402, 1473], [1474, 1474, 1496, 1496, 1583], [1584, 1584, 1606, 1606, 1659], [1660, 1660, 1683, 1683, 1756], [1757, 1757, 1780, 1780, 1851], [1852, 1852, 1875, 1875, 1961], [1991, 1991, 2014, 2014, 2043], [2044, 2044, 2067, 2067, 2096], [2097, 2097, 2122, 2122, 2151], [2153, 2189, 2230, 2230, 2323], [2325, 2325, 2354, 2354, 2398], [2400, 2602, 2636, 2636, 2747], [2749, 2783, 2811, 2811, 2839], [2888, 3049, 3080, 3080, 4480], [4482, 4552, 4587, 4587, 9140], [10472, 10472, 10529, 10529, 11888]]}
{"id": "MsyXDt", "name": "Cosines, everywhere", "author": "jumpy89", "description": "Haven't learned how to do raymarching yet, so made this from a bunch of superimposed cosine waves instead. Has a cool sort of almost-symmetry to it.", "tags": ["2d"], "likes": 14, "viewed": 213, "date": "1467754250", "time_retrieved": "2024-06-20T18:39:03.212194", "image_code": "#define TWOPI 6.28318530718\n\n#define N1 7\n#define WL1 10.\n#define SPEED1 .2\n#define AMP1 .2\n#define POW1 .6\n\n#define N2 7\n#define WL2 75.\n#define SPEED2 .05\n#define AMP2 1.\n#define POW2 1.5\n\n\n/*\n * From iq's \"cosine based palettes\" shadertoy here: https://www.shadertoy.com/view/ll2GD3\n * http://iquilezles.org/www/articles/palettes/palettes.htm\n */\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( TWOPI * (c * t + d) );\n}\n\n\nfloat wave(vec2 p, float lambda, float theta, float t)\n{\n    float dp = p.x * cos(theta) + p.y * sin(theta);\n    return (cos( (dp / lambda + t) * TWOPI ) + 1. ) * .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + iResolution.xy * iTime * .02;\n    \n    float x = .0;\n    \n    for(int i = 0; i < N1; i++)\n        x += pow( wave( p, WL1, float(i) / float(N1) * TWOPI, iTime * SPEED1 ), POW1 ) * AMP1;\n    \n    for(int i = 0; i < N2; i++)\n        x += pow( wave( p, WL2, float(i) / float(N2) * TWOPI, iTime * SPEED2 ), POW2 ) * AMP2;\n    \n    vec3 col = pal(x * .3,\n                   vec3(0.5,0.5,0.5),\n                   vec3(0.5,0.5,0.5),\n                   vec3(1.0,1.0,1.0),\n                   vec3(0.0,0.10,0.20));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsyXDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[192, 350, 418, 418, 465], [468, 468, 524, 524, 636], [639, 639, 696, 696, 1263]]}
{"id": "Mt3GzB", "name": "Radar malfunction", "author": "LukeRissacher", "description": "Evolving colorful spiral thing", "tags": ["procedural", "2d", "plane"], "likes": 3, "viewed": 206, "date": "1469932645", "time_retrieved": "2024-06-20T18:39:03.478982", "image_code": "vec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\nvec2 Rotate(vec2 vec, float angle) {\n    return vec2(\n        vec.x * cos(angle) - vec.y * sin(angle), \n        vec.x * sin(angle) + vec.y * cos(angle) \n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalize to [-1..1], aspect correct, slowly rotate\n    float t = iTime + 7.0;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv = Rotate(uv, 0.1477 * t);\n\n    // Get pixel distance and angle, modulate with time\n    float dist = length(uv);\n    dist += 0.5 * sin(0.5 * t) + 0.5;\n    float angle = -atan(uv.y, uv.x);\n\n    // Evolve colors over time\n    float baseHue = fract(0.036 * t + 0.2 * dist);\n    float hueOffset = fract(0.03 * t);\n    float value = clamp(dist, 0.0, 1.0); // darken noisy center\n    vec3 color1 = HsvToRgb(vec3(baseHue, 1.0, value)); \n    vec3 color2 = HsvToRgb(vec3(fract(baseHue + hueOffset), 1.0, value));\n\n    // Do inverse-polar warping thing\n    dist *= mix(10.5, 0.5, 0.5 * sin(0.0773 * t) + 0.5);\n    uv = vec2(cos(angle), sin(angle)) / dist + 0.1 * t;\n\n    // Use the warped coordinates to sample a colored grid\n    vec2 gridSize = vec2(0.038, 0.067);\n    uv = fract(uv / gridSize);\n    float gridValue = (uv.x + uv.y) / 2.0;\n    vec3 gridColor = mix(color1, color2, gridValue);\n    fragColor = vec4(gridColor, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3GzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 135], [137, 137, 162, 162, 244], [246, 246, 282, 282, 407], [409, 409, 464, 528, 1550]]}
{"id": "Mtc3zn", "name": "Curve Fractals? v.0.0.1", "author": "Imsure1200q_1UWE130", "description": "This Is A Shader That Makes Display Screens With Black Curves. This Doesn't Need RTWBase. This Is My FIrst Sense-Shader. Thnx For Viewing! Feel Free To Like And Comment!!!", "tags": ["fractal", "experimental"], "likes": 0, "viewed": 102, "date": "1467629150", "time_retrieved": "2024-06-20T18:39:04.012389", "image_code": "// Curve Fractals? || v.0.0.1 / version 1!\n/*\n\n\n\nChangeLog:\n â€¢ Added Reference-To-English Translation.\n â€¢ Fractal Window Updated IN Beta 1.\n\n\n\n         \\\n          \\\n==========)>============-------------------------\n          /\n         /\n\n\n\n           \"Youtube\": Kino Bacaltos,\n           \"Gmail\": My Name ( ^ ) + @gmail.com,\n           \"Minecraft: Pocket - Edition\" Xbox Live: Imsure1200q,\n           (\"@xawgamer If YOU, xawgamer, Are Visiting This Site, Read My Email\"),\n\n\n\n\n          \n*/\n//Function mainImage: Display The Shader Around The Function's Parrenthesis On The Screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Declare A 3-component vector.\n    vec3 p = vec3(1.0,2.0,1.5);\n    //Declare The Position ( Instead Of A Vertex, Vertices Will Act With This Like gl_Position.)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Add Noise Background To vec3 UV.\n\tvec4 fragColorpart = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //Add Colors To Front, Light, And Back ( of the noise editors )\n    vec4 light = vec4(1.0,1.0,1.0,1.0);\n    vec4 glasscolor = vec4(1.0,1.0,1.0,0.5);\n    vec4 fragGlassRefract = refract(glasscolor,fragColorpart,2.0);\n    vec4 fragGlassReflect = reflect(glasscolor,light);\n    //Make Our First New Color By Mixing Our Reflect & Refract Vectors.\n    vec4 newCol = mix(fragGlassReflect,fragGlassRefract,2.0);\n    //Add A Vector That Displays More Than One Screen Of The Main Shader.\n    vec4 fragColSeg = fract(newCol/10.0);\n    \n    //Adjustment:\n    \n    //Start Making Curve Shave Using A Float.\n    float fragColorSphere = dot(fragColSeg.yyx,fragColSeg.yyx);\n    //Make A Vector To Blend It,\n    float blend = float(fragColorpart.yyxy)/(iTime*(360.0/36.0)*10.0);\n    //To Stretch It,\n    float stretch = blend/pow(blend,blend);\n    //And To Combine When Stretched!\n    float combine = normalize(dot(p,p));\n    //Add A Mixing 4-component Vector That Then Mixes The Adjustment Tools.\n    vec4 spherex = vec4(\n        //First Mix Input\n        mix(\n            //Put Second Mix Input. Add fragColorSphere And Stretch It By 3.1 secs.\n            mix(fragColorSphere, stretch, 3.1),\n            //Add Another Second Mix Input. Make It Blend The Stretch Function So That Combine Will Repeat\n            //It.\n            mix(blend, mix(\n                combine, stretch, 2.0\n            ),\n                //Make Durability TO 2.0.\n                2.0),\n            //And 3.0.\n            3.0)\n        );\n    //You May Not Expect Why I Put \"vec4(spherex * spherex);\" In Vector Sphere, But, As You Can See,\n    //If You Take Out \" * spherex\" In The Vector \"sphere\", Then A Curve Won't Slightly Appear.\n    //It Will Possibly Look Like A Piece Of Circle. So I Added The \" * spherex\" To The Vector \"sphere\".\n    vec4 sphere = vec4(spherex * spherex);\n    //Finally, Make The Color Of Our Fragment Equal TO The 4-component vector \"sphere\".\n    fragColor = sphere;\n    //End The Void.\n}\n//THE END\n//X   X    DDDD    ||\n// X X     D   D  ||||\n//  X      D   D   ||\n// X X     D   D\n//X   X    DDDD    ()", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtc3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 594, 651, 687, 2932]]}
{"id": "MtcGD7", "name": "301's Fire Shader - Remix 2", "author": "CaliCoastReplay", "description": "A big thank you to \tFabriceNeyret2  who told me how to achieve this more vivid look!  Positively conflagarative!  Try it in fire rain config!\n\nRemix 1 here:  https://www.shadertoy.com/view/llc3DM\nOriginal here:  \nhttps://www.shadertoy.com/view/XsXXRN", "tags": ["flame", "fire", "blaze"], "likes": 54, "viewed": 2742, "date": "1469604082", "time_retrieved": "2024-06-20T18:39:04.424310", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(1.2, 0.1);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n    //change the constant term for all kinds of cool distance versions,\n    //make plus/minus to switch between \n    //ground fire and fire rain!\n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.01+1.0*sin(iTime)/10.0);\n    float qb = fbm(p - iTime * 0.002+0.1*cos(iTime)/5.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/7.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/30.0)-4.0;\n    float q4 = fbm(p - iTime * 2.0 - 20.0*sin(iTime)/20.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(c * cos(shift * fragCoord.y / iResolution.y));\n    color += .05;\n    color.r *= .8;\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= hsv.z  * 1.1;\n    hsv.z *= hsv.y * 1.13;\n    hsv.y = (2.2-hsv.z*.9)*1.20;\n    color = hsv2rgb(hsv);\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 568, 568, 642], [644, 644, 665, 665, 871], [873, 873, 892, 892, 1077], [1079, 1079, 1136, 1136, 2569]]}
{"id": "Mtd3D4", "name": "Pl4n3 Test0", "author": "Pl4n3", "description": "testtt", "tags": ["test"], "likes": 0, "viewed": 72, "date": "1469400465", "time_retrieved": "2024-06-20T18:39:04.424310", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime*20.0)*random(fragCoord.x*fragCoord.y),1.0);\n\tfragColor = vec4(uv,1.0*random(fragCoord.x*fragCoord.y+iTime*20.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 59], [61, 61, 118, 118, 321]]}
{"id": "Mtd3D7", "name": "Low-Rent Action Film", "author": "CaliCoastReplay", "description": "I'm cracking up over here.  More improvements to come on this concept.", "tags": ["chroma", "fire", "screen", "greenscreen", "green", "action", "movie"], "likes": 7, "viewed": 309, "date": "1469741768", "time_retrieved": "2024-06-20T18:39:04.976081", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.3;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\n#define threshold 0.50\n\nvoid video_overlay( inout vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 greenScreen = vec4(0.,1.,0.,1.);\n    vec4 color = texture(iChannel0, uv);\n    \n    vec3 diff = color.xyz - greenScreen.xyz;\n    \n    if(dot(diff, diff) < threshold) {\n     \n        \n    }\n    else \n    {   color += 0.2;\n        fragColor = (fragColor + 19.0*color)/20.0;\n\t\tfragColor *= color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(.3, 0.1);\n    float shift = .927+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n    //change the constant term for all kinds of cool distance versions,\n    //make plus/minus to switch between \n    //ground fire and fire rain!\n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.01+1.0*sin(iTime)/10.0);\n    float qb = fbm(p - iTime * 0.002+0.1*cos(iTime)/5.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/7.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/30.0)-4.0;\n    float q4 = fbm(p - iTime * 2.0 - 20.0*sin(iTime)/20.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(c * cos(shift * fragCoord.y / iResolution.y));\n    color += .05;\n    color.r *= .8;\n    vec3 hsv = rgb2hsv(color);\n    hsv.y *= hsv.z  * 1.1;\n    hsv.z *= hsv.y * 1.13;\n    hsv.y = (2.2-hsv.z*.9)*1.20;\n    color = hsv2rgb(hsv);\n   fragColor = vec4(color.x, color.y, color.z, alpha);\n    video_overlay(fragColor, fragCoord);\n   // hsv = rgb2hsv(vec3(fragColor.x, fragColor.y, fragColor.z));\n   // hsv.z *= (hsv.z+.2)/0.95;\n  //  hsv.y += 0.03;\n   // fragColor =vec4( hsv2rgb(hsv), 1.0);\n    \n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}, {"id": "XdS3z1", "previewfilepath": "https://soundcloud.com/humanbeings/work-zone-feat-mr-frick", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/humanbeings/work-zone-feat-mr-frick", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 568, 568, 642], [644, 644, 665, 665, 871], [873, 873, 892, 892, 1077], [1103, 1103, 1166, 1166, 1533], [1535, 1535, 1592, 1592, 3230]]}
{"id": "Mtd3RN", "name": "Mandelbrot multicolor", "author": "nathsou", "description": "Simple mandelbrot set shader.", "tags": ["fractal", "mandelbrot", "color"], "likes": 0, "viewed": 97, "date": "1468249932", "time_retrieved": "2024-06-20T18:39:04.976081", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 col = vec3(0.0);\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 c = vec2(-0.4, 0.0) + p;\n    float nb_iter = 0.0;\n    vec2 z  = vec2(0.0);\n    const float max_iter = 50.0;\n    const float speed = 0.5;\n\n    for(int i = 0; i < int(max_iter); i++) {\t\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(dot(z,z) > 4.0) break;\n        nb_iter += 1.0;\n    }\n    \n    float t1 = 3.0 * abs(cos(speed * iTime)) * (nb_iter / max_iter);\n    float t2 = 3.0 * abs(sin(speed * iTime)) * (nb_iter / max_iter);\n    float t3 = max(t1, t2);\n\n    if (nb_iter != max_iter) col = vec3(t1, t2, t3);   \n    else col = vec3(0.0);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 55, 55, 755]]}
{"id": "Mtd3W7", "name": "Overcast Skies 2D v2", "author": "CaliCoastReplay", "description": "Betterized version of :  https://www.shadertoy.com/view/MttGW7  \n\n(I'd just have saved it there, but I'm losing the fight with Shadertoy's save functionality.)", "tags": ["fractal", "noise", "clouds", "fbm", "perlin", "sky", "brownian", "motion"], "likes": 11, "viewed": 1566, "date": "1469728716", "time_retrieved": "2024-06-20T18:39:04.976081", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat rand(vec2 n) {\n    float value = fract(sin(cos(dot(n, vec2(12.9898,8.1414)))) * 42758.5453);\n    return sqrt(value)/1.25;\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <4; i++) {\n        total += noise(n) * amplitude;\n        n += n*2.1;\n        amplitude *= 0.377 + sin(iTime)/500.0;\n    }\n    return total;\n}\n\nfloat fbm_readded(vec2 uv)\n{\n    float i = fbm(uv);\n    uv.x = uv.x * 1.5;    \n    uv.y += 0.5f;\n    float i2 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    uv.x -= 0.3f;\n    float i3 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    uv.y += 0.7f;\n    float i4 = fbm(uv);\n    uv.y = uv.y * 1.5;\n    uv.x += .4f;\n    float i5 = fbm(uv);\n    return (i + i2 + i3 - i4 + i5)/3.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 1.5;\n    //uv.x -= iTime/8.0 + 1.8;\n    uv.y -= iTime/12.4 + .89;\n    uv.x -= iTime/9.0 + 1.9;\n    //uv.y -= iTime/9.4 + 0.9817;\n    vec2 uv2 = uv;\n    uv2.x +=  (iTime+10.0)/15.0;\n    uv2.y +=  (iTime-8.0)/12.0;\n    vec2 uv3 = uv2;\n    uv3.x += (iTime-7.0)/102.0;\n    uv3.y += (iTime+9.0)/96.0;\n    float main_cloudiness = fbm_readded(uv);\n    float intensity = max(main_cloudiness, \n                          1.3*fbm_readded(uv2))+ .9*main_cloudiness * fbm(uv2) * fbm(uv3);\n    intensity *= .64;\n    intensity += cos(sin(iTime/10.0))/7.0 - .3;\n    if (intensity < 0.5)\n        intensity *= intensity;\n    \n    vec3 color = vec3(1.0, 1.0, 1.0);\n    color *= intensity; \n    vec3 hsv = rgb2hsv(color);\n    hsv.z *= hsv.z ;\n    float overflow = 0.0;\n    if (hsv.z > 1.0)\n    {\n        overflow = hsv.z - 1.0;\n        hsv.y -= 0.01;\n    }\n    else if (hsv.z > 0.6)\n    {\n        hsv.y -= 0.05;\n        hsv.z -= 0.096;\n        hsv.z *= .93;\n        hsv.z *= sqrt(hsv.z)* 1.29;        \n    }\n    else\n    {\n        hsv.z -= 0.1;\n        hsv.z *= .9;\n     \n    }\n    hsv.z -= 0.02;\n    hsv.y -= 0.02;\n    color = hsv2rgb(hsv);  \n    color.b = 1.0;\n    color = color * sqrt(color);\n    color.r -= 2.0*overflow; \n    color.g -= 2.0*overflow;\n\tfragColor = vec4(color,1.0);\n    fragColor *= fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 352], [354, 354, 376, 376, 545], [548, 548, 568, 568, 677], [679, 679, 700, 700, 906], [908, 908, 927, 927, 1132], [1134, 1134, 1162, 1162, 1495], [1497, 1497, 1554, 1554, 2892]]}
{"id": "Mtd3z4", "name": "Desert sunset", "author": "zguerrero", "description": "I was messing around with noise function and ended up with a landscape and a day/night cycle, was fun to make ! :)", "tags": ["noise", "ray", "lighting", "light", "cycle", "marching", "landscape", "distance", "night", "field", "day"], "likes": 19, "viewed": 471, "date": "1468772988", "time_retrieved": "2024-06-20T18:39:04.982038", "image_code": "const float eps = 0.001;\nconst float daySpeed = 0.3;\nconst float season = -1.0;\nconst float followSun = 0.25;\n\nvec3 rotationX(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = pos.x;\n    rotPos.y = c * pos.y - s * pos.z;\n\trotPos.z = s * pos.y + c * pos.z;\n    \n    return rotPos;\n}\n\n/*\nvec3 rotationY(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x + s * pos.z;\n    rotPos.y = pos.y;\n\trotPos.z = -s * pos.x + c * pos.z;\n    \n    return rotPos;\n}\n\nvec3 rotationZ(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x - s * pos.y;\n    rotPos.y = c * pos.x + s * pos.y;\n\trotPos.z = pos.z;\n    \n    return rotPos;\n}\n*/\n\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{    \n   \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (uv - center) + center;\n}\n\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n} \n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cell0(vec2 uv)\n{    \n    vec2 uv2 = sin(uv);\n    return uv2.x * uv2.y;\n}\n\nfloat cellCombine0(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell0(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 3;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell0(rotuv(uv*(1.0 + r*v) + c, angle, vec2(r, hash(r))*10.0));\n        c = mix(c, nc, 0.5);\n    }\n    \n    return c;\n}\n\nfloat cell1(vec2 uv)\n{    \n    vec2 uv2 = abs(sin(uv));\n    return uv2.x * uv2.y;\n}\n\nfloat cellCombine1(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell1(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 5;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell1(rotuv(uv*(1.0 + r*v) + c, angle, vec2(r, hash(r))*10.0));\n        c = max(c, nc);\n    }\n    \n    return c;\n}\n\nfloat cell2(vec2 uv)\n{   \n    vec2 uv2 = abs(fract(uv) - vec2(0.5));\n    return smoothstep(0.98, 1.0, (uv2.x+uv2.y));\n}\n\nfloat cellCombine2(vec2 uv, float randSeed, float v, float s)\n{\n    float r1 = hash(randSeed);\n    float angle1 = r1*360.0 + (r1*2.0-1.0)*iTime*s;\n    float c = cell2(rotuv(uv*(1.0 + r1*v), angle1, vec2(r1, hash(r1))));\n    \n    const int itterations = 7;\n    \n    for(int i = 0; i < itterations; i++)\n    {\n        float r = hash(float(i)*randSeed);\n        float angle = r*360.0 + (r*2.0-1.0)*iTime*s;\n        float nc = cell2(rotuv(uv*(1.0 + r*v), angle, vec2(r, hash(r))*10.0));\n        c += nc*(0.5 + r);\n    }\n    \n    return c;\n}\n\nfloat infinitePlane(vec3 pos, float height)\n{\n    return pos.y - height;\n}\n\nfloat distfunc(vec3 pos)\n{  \n    float n0 = cellCombine0(pos.xz*0.3, 10.98765, 0.5, 0.0);\n    float n1 = 1.0 - cellCombine1(pos.xz*0.2, 5.5678, 0.5, 0.0);\n\tfloat n2 = 1.0 - cellCombine1(pos.xz*vec2(1.5,3.0), 8.5548, 0.5, 0.0);\n    return pos.y - n0*2.0 - n1*2.0 - n2*0.1;\n}\n\nvec2 rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int MAX_ITER = 100;\n\tconst float MAX_DIST = 40.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = eps;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist += dist;\n\t\tpos += dist*rayDir;\n        \n        if(dist < eps || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    return vec2(dist, totalDist);\n}\n\nvec3 skyBox(vec3 rayDir, vec3 sunDir, vec3 sunColor, float dayCycle1, float dayCycle2, float blur)\n{\n    vec3 rotDir = rotationX(rayDir, -iTime*daySpeed);\n    vec2 starUvs = vec2(atan(rotDir.x, rotDir.z), rotDir.y*4.0)*2.0;\n    float stars = clamp(clamp(cellCombine2(starUvs, 3259.5741, 0.5, 0.0),0.0,1.0) + (1.0 - blur),0.0,1.0); \n    vec3 skyColor1 = mix(vec3(0.05,0.05,0.2)+stars, mix(vec3(0.5,0.2,0.5),vec3(0.25,0.25,1.0), dayCycle1), dayCycle2);\n    vec3 skyColor2 = mix(vec3(0.25,0.25,0.35), mix(vec3(0.8,0.4,0.2), vec3(1.0,1.0,1.0), dayCycle1), dayCycle2);\n    vec3 groundColor1 = mix(vec3(0.25,0.22,0.3), mix(vec3(0.5,0.3,0.2), vec3(1.0,0.9,0.75), dayCycle1), dayCycle2);\n       \n    float sunPos = length(rayDir - sunDir);\n    float sunBall = 1.0 - smoothstep(0.04, 0.05*blur, sunPos);\n    float sunGlow = 1.0 - smoothstep(0.03, 0.5*blur, sunPos);\n    float sunInnerGlow = 1.0 - smoothstep(0.0, 0.05*blur, sunPos);\n    vec3 sun = ((sunBall + sunGlow)/blur)*sunColor + vec3(sunInnerGlow);\n    \n    vec3 skyColor = mix(skyColor2, skyColor1, clamp(rayDir.y*1.5,0.0,1.0));\n    float m = smoothstep(0.0, 0.05, (rayDir.y+0.1)*blur);\n    return mix(groundColor1, skyColor+sun, m);\n}\n\nvec3 lensFlare(vec3 rayDir, vec3 sunDir, vec3 sunColor, float dayCycle1)\n{    \n    vec3 l = vec3(0.0);\n    for(int i = 0; i < 4; i++)\n    {  \n        float d = 0.22;\n        float lensDistance = d + float(i)*d;\n        vec3 rvec = vec3(0.0,0.0,1.0);\n        vec3 sunvec = vec3(sunDir.x,-sunDir.y,sunDir.z);\n    \tfloat lPos = length(rayDir - normalize(mix(sunDir, reflect(sunvec, rvec), lensDistance)));\n        float growFactor = (1.0 + float(i)*float(i));\n        float lGlow = 1.0 - smoothstep(0.01*growFactor, 0.05*growFactor, lPos);\n        \n        l += mix(vec3(1.0), vec3(0.5,0.5,2.0), lensDistance)*lensDistance*lGlow;\n    }\n\n    float lPosv = 1.0 - clamp(length(rayDir.xz - sunDir.xz),0.0,1.0);\n    float lGlowv = pow(lPosv, 50.0);\n\n    vec3 lens = (l + lGlowv)*sunColor*dayCycle1;\n    \n    return lens;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos)\n{\n\tvec2 eps = vec2(0.0, 0.02);\n    float X = distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx);\n    float Y = distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx);\n    float Z = distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy);\n\tvec3 n = normalize(vec3(X,Y,Z));\n\treturn n;\n}\n\nvec3 lighting(vec3 pos, vec3 rayDir, vec3 light, vec3 sunColor, float dayCycle1, float dayCycle2, vec3 n)\n{   \n    vec3 ambSkyBox = skyBox(n, light, sunColor, dayCycle1, dayCycle2, 5.0);\n    vec3 ambientColor = mix(ambSkyBox, clamp(ambSkyBox + 0.5, 0.0, 1.0), dayCycle1);\n    vec3 diffuseColor = mix(vec3(1.0,0.7,0.5), vec3(1.0,0.9,0.6), pos.y*0.65);\n    vec3 specColor = vec3(1.0,1.0,1.0);\n   \n\tfloat diff = dot(normalize(light), n);\n\tfloat fresnel = (1.0 - 0.0, dot(n, -rayDir));\n\tvec3 r = reflect(normalize(rayDir), n);\n\tfloat spec = pow(max (0.0, dot (r, light)), 50.0);\n\tfloat specMap = cellCombine1(pos.xz*3.0, 12458.5125, 1.0, 0.0);\n    \n\tvec3 res = diffuseColor*ambientColor;\n\n\tres += diffuseColor*max(0.0, diff)*sunColor;\n    res += specColor*spec*sunColor*fresnel*smoothstep(0.95,1.0,specMap)*5.0;\n    res += sunColor * max(0.0, -diff) * 0.35;\n\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(season,cos(daySpeed*iTime),sin(daySpeed*iTime)));\n    \n    vec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraOrigin = vec3(iTime, 4.0, iTime);\n\tvec3 cameraTarget = cameraOrigin + mix(vec3(-1.0,0.0,0.0), light, followSun);\n       \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos, 0.75) );\n    vec2 dist = rayMarch(rayDir, cameraOrigin);\n    \n    float dayCycle = dot(light, vec3(0.0, 1.0, 0.0));\n    float dayCycle1 = smoothstep(0.0, 0.5, max(0.0, dayCycle));\n    float dayCycle2 = smoothstep(0.5, 1.0, min(dayCycle + 1.0, 1.0));\n    vec3 sunColor = mix(vec3(0.5,0.2,0.0), vec3(0.4,0.4,0.2), dayCycle1);\n    vec3 dayLight = mix(vec3(0.2, 0.2, 0.4), sunColor, dayCycle2);\n    \n    vec3 sky = skyBox(rayDir, light, dayLight, dayCycle1, dayCycle2, 1.0);\n    vec3 lens = lensFlare(rayDir, light, dayLight, dayCycle1);\n    vec3 res;\n     \n\tif(dist.x < eps)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec3 n = calculateNormals(pos);\n        float fog = clamp((dist.y - 18.0)*0.05, 0.0, 1.0);\n        float fogY = (1.0 - clamp((pos.y+0.5)*0.5, 0.0, 1.0))*0.8;\n        res = mix(lighting(pos, rayDir, light, dayLight, dayCycle1, dayCycle2, n), sky, clamp(fog+fogY, 0.0, 1.0));\n    }\n    else\n    {\n        res = sky;       \n    }\n\n    float vign = 1.0 - smoothstep(0.5, 1.0, length(screenPos - vec2(0.0))*0.5);\n    \n\tfragColor = vec4(res + vec3(lens), 1.0) * (0.75+vign*0.25);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3z4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[111, 111, 150, 150, 334], [336, 793, 840, 840, 937], [939, 939, 960, 960, 1037], [1040, 1040, 1081, 1081, 1174], [1176, 1176, 1198, 1198, 1254], [1256, 1256, 1319, 1319, 1798], [1800, 1800, 1822, 1822, 1883], [1885, 1885, 1948, 1948, 2422], [2424, 2424, 2446, 2446, 2543], [2545, 2545, 2608, 2608, 3081], [3083, 3083, 3128, 3128, 3157], [3159, 3159, 3185, 3185, 3432], [3434, 3434, 3481, 3481, 3844], [3846, 3846, 3946, 3946, 5030], [5032, 5032, 5106, 5106, 5846], [5848, 5848, 5900, 5900, 6077], [6079, 6079, 6112, 6112, 6383], [6385, 6385, 6492, 6492, 7254], [7256, 7256, 7313, 7313, 8869]]}
{"id": "Mtd3z8", "name": "Smooth SymeSyme", "author": "Dude", "description": "you know about SymeSyme? He REeee333EEEAAAAAAAL GOOD!", "tags": ["symesyme"], "likes": 1, "viewed": 99, "date": "1468013888", "time_retrieved": "2024-06-20T18:39:04.982038", "image_code": "#define PI 3.14159265359\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.03, pct, st.y) - \n          smoothstep( pct, pct+0.03, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = fragCoord.xy - iResolution.xy*0.5;\n    \n    vec2 uv = R/iResolution.xy; \n    \n    uv -= uv*0.5;\n\n    vec3 color = vec3(1.0, 1., 1.);\n    \n    mat2 rot = mat2(cos(iTime+uv.x*2.*PI*3.0), -sin(iTime+uv.y*2.*PI*15.0), \n                    sin(iTime+uv.x*2.*PI*3.0), cos(iTime+uv.y*2.*PI*16.0)); \n    \n    float v = 0.;\n    \n    float pct = plot(uv*rot ,v);\n    \n    color = pct * color;\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtd3z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 57, 57, 149], [151, 151, 208, 208, 637]]}
{"id": "MtdGW7", "name": "Alien radar", "author": "runekill", "description": "My first experiments with shader based on &quot;The Book of Shaders by Patricio Gonzalez Vivo &amp; Jen Lowe&quot; and some community examples. Probably my imlementation of digits is siliest among represented.", "tags": ["simple", "mouse", "tutorial", "line", "circle", "radar", "digit"], "likes": 12, "viewed": 416, "date": "1469723878", "time_retrieved": "2024-06-20T18:39:05.964077", "image_code": "//Alien detector v 0.2\n//alien meter added.\n// Based on works:\n//https://www.shadertoy.com/view/4s2SRt by ndel\n//https://www.shadertoy.com/view/Xsy3zG by Andre\n//http://patriciogonzalezvivo.com/2015/thebookofshaders/08/ by patricio gonzalez\n//welcome to use\n#define outerRadius 0.24\n#define outerDottedRadius 0.23\n#define innerDottedRadius 0.11\n#define innerRadius 0.1\n#define cirleWidth 0.01\n#define PI 3.1415926535897932384626433832795\n#define red   vec3(1.00,0.38,0.227)\n#define blue vec3(0.09,0.45,0.76)\n//one segment for alien meter\nfloat segment(vec2 uv)\n{\n    uv = abs(uv.yx);\n\treturn (1.0-smoothstep(0.08,0.10,uv.x))\n         * (1.0-smoothstep(0.46,0.49,uv.y+uv.x))\n         * (1.3 - length(uv*vec2(2.8,2.0)));\n}\n//convert one segment to digit\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    //two left segment of the digit\n    float twoLeft = segment(vec2(abs(uv.y),uv.x-0.5))+segment(vec2(abs(uv.y-1.),uv.x-0.5));\n    //three horizontal segement\n    float threeHorizontal=segment(vec2((uv.x),abs(uv.y-1.5)))+segment(vec2((uv.x),abs(uv.y-0.5)))\n        +segment(vec2((uv.x),abs(uv.y+0.5)));\n    //one left down and one right up\n    float downUpVertical = segment(vec2(abs(uv.y),uv.x+0.5)) \n        + segment(vec2(abs(uv.y-1.),uv.x-0.5));\n    //opposite to previous\n    float upDownVertical = segment(vec2(abs(uv.y),uv.x-0.5)) \n        + segment(vec2(abs(uv.y-1.),uv.x+0.5));\n       \n    if (num==1) seg = twoLeft;\n    if (num==2) seg = downUpVertical + threeHorizontal;\n    if (num==3) seg = twoLeft + threeHorizontal;\n    if (num==4) seg = twoLeft+segment(vec2(abs(uv.y-1.),uv.x+0.5))+segment(vec2((uv.x),abs(uv.y-0.5)));\n    if (num==5) seg = upDownVertical + threeHorizontal;\n    if (num==6) seg = upDownVertical + threeHorizontal+segment(vec2(abs(uv.y),uv.x+0.5));\n    if (num==7) seg = twoLeft+segment(vec2((uv.x),abs(uv.y-1.5)));\n\tif (num==8) seg = upDownVertical+ downUpVertical + threeHorizontal;\n    if (num==9) seg = upDownVertical+ twoLeft + threeHorizontal;\n    if (num==0) seg = upDownVertical+ downUpVertical+segment(vec2((uv.x),abs(uv.y-1.5)))+segment(vec2((uv.x),abs(uv.y+0.5)));\n    \n    seg += (upDownVertical+ downUpVertical+threeHorizontal)*0.15;\n    \n\treturn seg;\n}\n//make value out of digit\nfloat printValue(vec2 uv,float num){\n\t\n\tfloat v=0.; \n\n    for(float i=0. ; i<2. ; i++){\n        //convert float to two figures\n\t\tfloat d=num/pow(10.,i)*10.;\n        d = mod(floor(d+0.000001),10.0);\n\t\tv+=sevenSegment(uv+vec2(i*1.3,0.),int(d));\n\t}\n\n    return v;\n}\n//rotate radar\nvec2 rotate(vec2 uv, float angle)\n{\n    float a = angle*PI/180.0; \n    vec2 c = vec2(uv.x*cos(a)-uv.y*sin(a), //rotate\n                    uv.x*sin(a)+uv.y*cos(a));\n    return c;\n}\nfloat line(vec2 center, vec2 uv, float radius, float theta,float start,float finish)\n{\n\tvec2 d = uv - center;\n\n    vec2 p = vec2(cos(theta*PI/180.0),\n                        -sin(theta*PI/180.0));\n    float l = length( d - p*clamp( dot(d,p)/dot(p,p), radius*start, radius*finish) );\n    l = smoothstep(cirleWidth,cirleWidth-0.02,l);\n    return l;\n}\nvec3 bip(vec2 uv, vec2 center, float width)\n{\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float scale = mod(iTime,2.);\n    float angle = 0.5 * abs(cos(center.x));\n    float circle = smoothstep(min(0.0,scale), scale+width, r)\n       * smoothstep(scale+width, min(0.0,scale), r);\n    circle += smoothstep(scale, scale+width/4., r)\n       * smoothstep(scale+width/4.,scale, r)*2.*PI;\n\n    return vec3(circle);\n}\n\nfloat circle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\treturn smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle);\n}\nfloat outerDottedCircle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\tfloat c = smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle)\n        *(step(0.39,abs(uv.y))*step(0.39,abs(uv.x)));\n    \n    return c;\n   \n    \n}\nfloat innerDottedCircle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\tfloat c = smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle)\n        *(step(0.39,abs(uv.x))+step(0.39,abs(uv.y)));\n    \n    return c;\n   \n    \n}\nfloat alien (vec2 coord, vec2 uv)\n{\n    float distanceToCenter = distance(coord,uv);\n    return abs(sin(5.*iTime)) * smoothstep(cirleWidth*2.,cirleWidth,distanceToCenter);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 color;\n    vec2 alienCoord = vec2(-0.2,-0.25); //coordinates of alien\n    vec2 uv = fragCoord.xy / iResolution.xy; //move coordinates to 0..1\n    vec2 center = uv/2.; //find center\n    //distance meter\n    float digit = length(alienCoord*10.);\n    float digitSize = 40.;\n    float l = printValue(uv*digitSize-vec2(19.8,2.),digit);\n    color.r+=l;\n    //bottom frontier\n    float bottom = step(0.9,1.-uv.y);\n    float bottom2 = step(0.975,1.-uv.y);\n    float r=step(.2, length(center.xy)); //left side cut\n    float r2=step(.2, length(center.xy-vec2(0.49,0.0))); //right side cut\n    color+=clamp(bottom-r,0.0,1.0)*blue;\n    color+=clamp(bottom-r2,0.0,1.0)*blue;\n    color+=clamp(bottom2*r2*r,0.0,1.0)*blue;\n\n    //coordinates for radar\n    uv = uv*2.; // scale coordinates to 0..+2\n    uv.x *= iResolution.x/iResolution.y; //correct x coordinate\n    uv.x-=1.7; //translate x to center\n    vec2 mouse = vec2(iMouse.xy);\n    uv = rotate(uv,mouse.x);\n\tcenter = uv/2.; //find center\n    \n\n\t//circles\n    color += vec3(outerDottedCircle(center,uv,outerDottedRadius))*2.*blue;\n    color += vec3(innerDottedCircle(center,uv,innerDottedRadius))*2.*blue;\n    color += vec3(circle(center,uv,outerRadius))*2.*blue;\n    color += vec3(circle(center,uv,innerRadius))*2.*blue;\n    //bip\n    color += bip(uv,center,0.1)*blue;\n    //aim big lines\n    color += line (center,uv,outerRadius,45.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,90.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,135.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,180.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,225.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,270.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,315.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,0.,0.7,2.1)*blue;\n    //small lines\n    color += line (center,uv,outerRadius,25.,1.9,2.1);\n    color += line (center,uv,outerRadius,65.,1.9,2.1);\n    color += line (center,uv,outerRadius,115.,1.9,2.1);\n    color += line (center,uv,outerRadius,155.,1.9,2.1);\n    color += line (center,uv,outerRadius,205.,1.9,2.1);\n    color += line (center,uv,outerRadius,245.,1.9,2.1);\n    color += line (center,uv,outerRadius,295.,1.9,2.1);\n    color += line (center,uv,outerRadius,335.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,30.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,60.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,120.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,150.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,210.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,240.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,300.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,330.,1.9,2.1);\n    //alien\n\tcolor += alien(center+alienCoord,uv);\n\n    //final color\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[508, 538, 562, 562, 720], [721, 752, 789, 789, 2206], [2207, 2233, 2269, 2269, 2495], [2496, 2511, 2546, 2546, 2691], [2692, 2692, 2778, 2778, 3040], [3041, 3041, 3086, 3086, 3464], [3466, 3466, 3512, 3512, 3741], [3742, 3742, 3799, 3799, 4112], [4113, 4113, 4170, 4170, 4483], [4484, 4484, 4519, 4519, 4657], [4658, 4658, 4715, 4715, 7600]]}
{"id": "MtdGW8", "name": "Gooey, pure WebGL", "author": "caesarsol", "description": "Click to move the blue balloon", "tags": ["2d", "gooey"], "likes": 2, "viewed": 318, "date": "1469109961", "time_retrieved": "2024-06-20T18:39:06.751771", "image_code": "vec3 red = vec3(1, 0, 0);\nvec3 blue = vec3(0, 0, 1);\nvec3 green = vec3(0, 1, 0);\n\nfloat limit(float x) {\n  return clamp(x, 0.0, 1.0);\n}\n\nvec4 buildCircleLinearBlur(vec2 center, float radius, vec3 color, float blurRadius, vec2 xy) {\n  float r = length(xy - center);\n  float alpha = 1.0 - clamp(r / (radius + blurRadius), 0.0, 1.0);\n  return vec4(color, alpha);\n}\n\nvec4 buildCircleHermiteBlur(vec2 center, float radius, vec3 color, float blur, vec2 xy) {\n  float r = length(xy - center);\n  float inner = radius - blur;\n  float outer = radius + blur;\n  float alpha = 1.0 - smoothstep(inner, outer, r);\n  return vec4(color, alpha);\n}\n\nfloat rstep(float a, float v) {\n  return step(v, a);\n}\n\nfloat stepBetween(float a, float b, float v) {\n  return step(a, v) * step(v, b);\n}\nvec2 stepBetween(vec2 a, vec2 b, vec2 v) {\n  return step(a, v) * step(v, b);\n}\n\nfloat smoothstepBetween(float a, float b, float s, float v) {\n  return smoothstep(a, a+s, v) * (1.0 - smoothstep(b-s, b, v));\n}\n  \n\nvec4 buildRect(vec2 a, vec2 b, vec3 color, vec2 xy) {\n  vec2 hv = stepBetween(a.xy, b.xy, xy);\n  float alpha = hv.x * hv.y;\n  return vec4(color.rgb, alpha);\n}\n\nfloat m(vec2 a, vec2 b) { return (a.y - b.y)/(a.x - b.x); }\nfloat q(vec2 a, vec2 b) { return (a.y - a.x * m(a, b)); }\n\nfloat semiplane(vec2 a, vec2 b, vec2 xy) {\n  float m = m(a, b);\n  return step(xy.y, m * xy.x + q(a, b));\n  //float right = step(xy.y, m * xy.x + q(a, b)) * rstep(m, 0.0);\n  //float left = step(xy.y, m * xy.x + q(a, b)) * step(m, 0.0);\n  //return max(right, left);\n}\n\nvec4 buildPoly(vec2 a, vec2 b, vec2 c, vec2 d, vec3 color, vec2 xy) {\n  float ab = semiplane(a, b, xy);\n  float bc = semiplane(b, c, xy);\n  float cd = semiplane(c, d, xy);\n  float da = 1.0 - semiplane(d, a, xy);\n  float alpha = ab * bc * cd * da;\n  return vec4(color.rgb, alpha);\n}\n\nvec2 project(vec2 v, vec2 dir) {\n  vec2 normDir = normalize(dir);\n  return dot(v, normDir) * normDir;\n}\n\nvec2 reject(vec2 v, vec2 dir) {\n  return v - project(v, dir);\n}\n\nfloat projectionLength(vec2 v, vec2 dir) {\n  vec2 normDir = normalize(dir);\n  return dot(v, normDir);\n}\n\nvec4 buildLineBlurColor(vec2 p1, vec2 p2, vec3 color1, vec3 color2, float blur, vec2 xy) {\n  float a = distance(p1, xy);\n  float b = distance(p2, xy);\n  float c = distance(p1, p2);\n    \n  vec2 para = project(xy - p1, p2 - p1);\n  vec2 perp = reject(xy - p1, p2 - p1); \n    \n  float l = projectionLength(xy - p1, p2 - p1);\n  float s = l / c;  // Measures the point at which we are in the segment\n  float q = length(perp);\n\n  float lineEndMask = smoothstepBetween(0.0, c, 15.0, l);\n  float width = 1.0;\n  blur *= mix(20.0, 50.0, s) / 20.0;\n  float lineWidthMask = smoothstep(width + blur/2.0, width - blur/2.0, q);\n\n  vec3 color = mix(color1, color2, s);\n  float alpha = lineEndMask * lineWidthMask;\n  return vec4(color, alpha);\n}\n\nfloat delta(float x, float width) {\n  //return step(-width/2.0, x) - step(width/2.0, x);\n  return clamp(smoothstep(-width, 0.0, x) - smoothstep(0.0, width, x), 0.0, 1.0);\n}\n\nfloat delta(float x) {\n  return delta(x, 1.0);\n}\n\nvec4 blend(vec4 bg, vec4 fg){\n  vec3 bgm = bg.rgb * bg.a;\n  vec3 fgm = fg.rgb * fg.a;\n  float ia = 1.0 - fg.a;\n  float a = (fg.a + bg.a * ia);\n  if (a == 0.0) return vec4(0.0, 0.0, 0.0, a);\n  vec4 rgba;\n  rgba.rgb = (fgm + bgm * ia) / a;\n  rgba.a = a;\n  return rgba;\n}\n\nvec4 alphaContrast(vec4 color, float mult, float sub) {\n  float a = limit(color.a * mult - sub);\n  //a = color.a;\n  return vec4(color.rgb, a);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 xy = fragCoord.xy;\n  vec2 center = iResolution.xy * 0.5;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  float r1 = 20.0;\n  float r2 = 50.0;\n  float b = 50.0;\n  vec2 c1 = iMouse.xy;\n  vec2 c2 = center + vec2(200.0, 0.0);\n    \n  if (iMouse.x == 0.0) {\n    float ang = iTime;\n    c1.x = center.x + sin(ang) * 250.0;\n    c1.y = center.y + cos(ang) * 100.0;\n  }\n\n  //vec4 circleOutline = vec4(0.5, 0.5, 0.0, delta(radius - length(xy - center + 40.0)));\n  \n  vec4 bg = vec4(0.5, 0.5, 0.5, 1.0);\n\n  vec4 fg = vec4(0.0, 0.0, 0.0, 0.0);\n  fg = blend(fg, buildLineBlurColor(c1, c2, blue, green, b, xy));\n  fg = blend(fg, buildCircleHermiteBlur(c1, r1, blue, b, xy));\n  fg = blend(fg, buildCircleHermiteBlur(c2, r2, green, b, xy));\n  fg = alphaContrast(fg , 40.0, 16.0);\n\n  fragColor = blend(bg, fg);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[82, 82, 104, 104, 135], [137, 137, 231, 231, 361], [363, 363, 452, 452, 629], [631, 631, 662, 662, 685], [687, 687, 733, 733, 769], [770, 770, 812, 812, 848], [850, 850, 911, 911, 977], [982, 982, 1035, 1035, 1140], [1142, 1142, 1167, 1167, 1201], [1202, 1202, 1227, 1227, 1259], [1261, 1261, 1303, 1303, 1526], [1528, 1528, 1597, 1597, 1809], [1811, 1811, 1843, 1843, 1914], [1916, 1916, 1947, 1947, 1979], [1981, 1981, 2023, 2023, 2084], [2086, 2086, 2176, 2176, 2813], [2815, 2815, 2850, 2903, 2987], [2989, 2989, 3011, 3011, 3037], [3039, 3039, 3068, 3068, 3307], [3309, 3309, 3364, 3364, 3453], [3456, 3456, 3508, 3508, 4309]]}
{"id": "MtdGzH", "name": "Anglesine", "author": "Imsure1200q_1UWE130", "description": "Raymarcha'!!!", "tags": ["raymarching", "mathematical", "vrotex"], "likes": 9, "viewed": 718, "date": "1468043171", "time_retrieved": "2024-06-20T18:39:06.751771", "image_code": "float map( vec3 p )\n{\n    \n    vec3 q = fract(p) * max(2.0,float(p)) - 1.0;\n    return length(q) - 0.5;\n    \n}\nfloat trace( vec3 ro, vec3 rd )\n{\n    \n    float t = 0.0;\n    \n    for( int i = 0; i < 24; ++i ) {\n        \n        vec3 p = ro + t*rd;\n        \n        float d = map( p );\n        \n        t += d * 0.5;\n    }\n    \n    return t;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    r.xz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    r.yz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    r.zx *= mat2(-cos(iTime), sin(iTime), sin(iTime), cos(iTime));\n    r.zy *= mat2(cos(iTime), sin(iTime), sin(iTime), -cos(iTime));\n    r.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    r.xyz *= vec3(r.yzx);\n    \n    vec3 o = vec3( 0.0, iTime, iTime );\n    \n    float t = trace(o, r);\n    \n    \n    //vec3 h: This Vector Is Used For Custom Colors.\n    //Component 1: Render Background.\n    //Component 2: Render Sphere Color (Blends Background)\n    //Component 3: Render Sky Color ( Blends Background And Sphere );\n    vec3 h = vec3(0.9,0.5,0.1);\n    float fogx = 2.0 / (1.0 + t * float(h) * 1.0);\n    \n    vec3 fog = mix(vec3(fogx),h,2.0);\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n    vec2 uvr = fragCoord.xy / iResolution.xy;\n    uvr = -1.0+2.0*uvr;\n    fragColor -= max(dot(uvr,uvr)-0.9,0.)/2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtdGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 110], [111, 111, 144, 144, 346], [347, 347, 404, 404, 1545]]}
{"id": "Mtt3W8", "name": "Random voronoi 1 kino", "author": "Imsure1200q_1UWE130", "description": "afgafg", "tags": ["afga"], "likes": 0, "viewed": 506, "date": "1469111654", "time_retrieved": "2024-06-20T18:39:06.757942", "image_code": "float map( vec3 p )\n{\n    return length(p) - 1.0;\n}\nfloat formPos(float s, vec2 canvas, float maxx)\n{\n    return s / (canvas.x / canvas.y) * maxx;\n}\nfloat formray(float m, float s, float x)\n{\n    return m * s / x * mod(length(s),m*x/fract(s/m));\n}\nfloat formHike(float hike)\n{\n    return fract(hike*sin(hike / hike));\n}\nfloat trace(vec3 shape, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = rd / shape;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\nvec3 formRelev(float s, vec2 canvas, float minimum, vec3 td, float time)\n{\n    float p = formPos(s, canvas, float(dot(td,td)));\n    float x = p / formray(minimum, smoothstep(0.0,1.0,float(sin(td*vec3(p)))),0.1);\n    float vx = x / p * (canvas.x / canvas.y) + max(x,minimum);\n    float rx = vx * x / p * sin(time);\n    float mixed = p / x * (rx - mod(x, vx) * minimum);\n    vec3 arc = vec3(p / fract(cos(formHike(1.1 * 2.0 * sin(float(iTimeDelta)+iTime)/(canvas.x/canvas.y)*2.0))));\n    return vec3(arc[1] * 2.0, arc[0] / length(s), arc[2] + sin(time));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 shape = formRelev(1.0, uv, 3.1, normalize(vec3(uv,1.0)), iTime / length(fragCoord.x));\n    float t = trace(shape, normalize(vec3(uv, 1.0)));\n    float fog = 1.0 / (1.0 * t * t * 0.1);\n    fragColor = vec4(vec3(fog),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtt3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 51], [52, 52, 101, 101, 148], [149, 149, 191, 191, 247], [248, 248, 276, 276, 319], [320, 320, 354, 354, 510], [511, 511, 585, 585, 1065], [1066, 1066, 1123, 1123, 1397]]}
{"id": "Mtt3WN", "name": "008 sphere marching schematic", "author": "kakaxizhhgjh", "description": "original: https://www.shadertoy.com/view/XsyGRW\nlearn a lot from hughsk's work", "tags": ["sdf", "spheremarching"], "likes": 7, "viewed": 167, "date": "1469423814", "time_retrieved": "2024-06-20T18:39:06.757942", "image_code": "float line_segment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b - a, ap = p - a;\n    return length(ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0));\n}\n\nfloat circle(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdf(vec2 p) {\n\treturn min(circle(p - vec2(cos(iTime)), 0.5), circle(p + vec2(sin(iTime), 0.0), 0.5));\n}\n\nfloat plot_edge(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, abs(d));\n}\n\nfloat plot_solid(float d) {\n\treturn smoothstep(3.0 / iResolution.y, 0.0, max(0.0, d));\n}\n\nfloat plot_solid_with_blooming(float d) {\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\nvec3 plot_contour(float d) {\n\tvec3 bg = mix(vec3(0.3, 0.8, 1.0), vec3(1.0, 0.8, 0.6), plot_solid_with_blooming(d));\n    bg = mix(bg, vec3(1.0, 0.44, 0.33), plot_solid(d));\n    bg = mix(bg, vec3(0.0), plot_edge(d));\n    bg -= vec3(0.1) * plot_edge(mod(d + 0.025, 0.05) - 0.025);\n    bg -= vec3(0.3) * plot_edge(mod(d + 0.1, 0.2) - 0.1);\n    return bg;\n}\n\nvec3 plot_trace(vec2 p) {\n\tvec2 ro = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 rd = normalize(-ro);\n    vec2 o = ro;\n    float bg = 0.0;\n    for(int i = 0; i < 20; ++i) {\n    \tfloat t = sdf(ro);\n        bg += pow(1.0 - bg, 3.0) * 0.8 * plot_solid(circle(p - ro, 0.015));\n        bg += pow(1.0 - bg, 3.0) * 0.2 * plot_solid(circle(p - ro, abs(t)));\n        bg += pow(1.0 - bg, 3.0) * 0.8 * plot_edge(circle(p - ro,abs(t)));\n        ro += rd * t;\n        if(abs(t) < 0.01) break;\n    }\n    bg += pow(1.0 - bg, 2.2) * 0.4 * plot_edge(line_segment(p, o, ro));\n    return vec3(bg);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(plot_contour(sdf(uv)) - plot_trace(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtt3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 44, 44, 149], [151, 151, 182, 182, 207], [209, 209, 228, 228, 318], [320, 320, 346, 346, 402], [404, 404, 431, 431, 492], [494, 494, 535, 535, 571], [573, 573, 601, 601, 925], [927, 927, 952, 952, 1524], [1526, 1526, 1583, 1583, 1718]]}
{"id": "MttGW7", "name": "Overcast Skies 2D", "author": "CaliCoastReplay", "description": "Playing with noise.  Nowhere near ready yet, but worth showing off for the &amp;amp;amp;quot;undercloud&amp;amp;amp;quot; effect - on heavy cloud patches, any density value that goes over 1 tips back under white for a simulated &amp;amp;amp;quot;shadow&am", "tags": ["fractal", "noise", "clouds", "fbm", "perlin", "sky", "brownian", "motion"], "likes": 2, "viewed": 462, "date": "1469721383", "time_retrieved": "2024-06-20T18:39:06.757942", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat rand(vec2 n) {\n    float value = fract(sin(cos(dot(n, vec2(12.9898,8.1414)))) * 42758.5453);\n    return sqrt(value)/1.15;\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*2.1;\n        amplitude *= 0.37;\n    }\n    return total;\n}\n\nfloat fbm_readded(vec2 uv)\n{\n    float i = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i2 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i3 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i4 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i5 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    float i6 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    float i7 = fbm(uv);\n    return (i + i2 + i3 + i4 + i5 + i6 + i7)/7.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= iTime/9.0 + .9;\n    uv.y -= iTime/14.0 + .9;\n    vec2 uv2 = uv;\n    uv2.x +=  iTime/18.0;\n    uv2.y +=  iTime/26.0;\n    vec2 uv3 = uv2;\n    uv3.x += iTime/72.0;\n    uv3.y += iTime/96.0;\n    float intensity = max(fbm_readded(uv), 1.3*fbm(uv2))+ .9*fbm_readded(uv) * fbm(uv2) * fbm(uv3);\n    intensity *= .7;\n    intensity += cos(sin(iTime/10.0))/10.0 - .3;\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    color *= intensity; \n    vec3 hsv = rgb2hsv(color);\n    hsv.z *= hsv.z  / 1.25;\n    bool subtractive = false;\n    float overflow = 0.0;\n    if (hsv.z > 1.0)\n    {\n        subtractive = true;\n        overflow = hsv.z - 1.0;\n    }\n    color = hsv2rgb(hsv);  \n    color.b = 1.0;\n    color = color * sqrt(color);\n    color.r -= 2.0*overflow; \n    color.g -= 2.0*overflow;\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 352], [354, 354, 376, 376, 545], [548, 548, 568, 568, 677], [679, 679, 700, 700, 906], [908, 908, 927, 927, 1112], [1114, 1114, 1142, 1142, 1504], [1506, 1506, 1563, 1563, 2415]]}
{"id": "MttGWr", "name": "string theory variant", "author": "visy", "description": "string theory variant", "tags": ["stringtheory"], "likes": 1, "viewed": 156, "date": "1468851392", "time_retrieved": "2024-06-20T18:39:06.757942", "image_code": "//String Theory by nimitz (twitter: @stormoid)\n\n#define BASE_ANGLE 3.5\n#define ANGLE_DELTA 0.02\n#define XOFF .7\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat aspect = iResolution.x/iResolution.y;\nfloat featureSize = 120./((iResolution.x*aspect+iResolution.y));\n\nfloat f(vec2 p)\n{\n\tp.x = sin(p.x*1.+time*1.2)*sin(time+p.x*0.1)*3.;\t\n    p += sin(p.x*1.5)*.1;\n    return smoothstep(-0.0,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy*7.5-3.25;\n \n    if (p.x >= 0.5) p.x = 1.0-p.x;\n    if (p.y >= 0.5) p.y = 1.0-p.y;\n\n    p.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(0.0);\n\tfor(float i=0.;i<36.;i++)\n\t{\n\t\tvec3 col2 = (sin(vec3(iTime*0.01,2.5,2.2)+i*0.15)*0.5+0.54)*(1.-f(p));\n\t\tcol += max(col,col2)*0.005*i;\n\t\t\n        p.x -= XOFF*p.y;\n        p.y -= sin(time*0.051+1.5)*cos(time*0.1)+1.5;\n\t\tp*= mm2(i*ANGLE_DELTA+BASE_ANGLE+time*i*0.00001);\n\t\t\n        vec2 pa = vec2(abs(p.x-.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-0.07,0.07,sin(time*0.002)+.1));\n\t}\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 132, 153, 153, 205], [317, 317, 334, 334, 463], [465, 465, 522, 522, 1170]]}
{"id": "MttGz7", "name": "Ray Marching: Part 4", "author": "jlfwong", "description": "Part 4 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching"], "likes": 24, "viewed": 172747, "date": "1468522689", "time_retrieved": "2024-06-20T18:39:08.061136", "image_code": "/**\n * Part 4 Challenges:\n * - Show the union instead of the intersection\n * - Show cube - sphere\n * - Show sphere - cube\n * - Subtract a new sphere from the cube/sphere intersection to make the top face into a \"bowl\"\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint);\n    return intersectSDF(cubeDist, sphereDist);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[348, 439, 485, 485, 517], [519, 603, 645, 645, 677], [679, 768, 815, 815, 848], [850, 958, 981, 1132, 1569], [1571, 1660, 1685, 1685, 1715], [1717, 1957, 1991, 1991, 2142], [2144, 2565, 2656, 2656, 2962], [2977, 3231, 3296, 3296, 3428], [3430, 3519, 3548, 3548, 3858], [3860, 4352, 4492, 4492, 5082], [5084, 5454, 5539, 5539, 6339], [6341, 6668, 6717, 6752, 6978], [6980, 6980, 7037, 7037, 7880]]}
{"id": "MttGzN", "name": "Test Cube Field", "author": "geoff", "description": "Sphere traced cube field. Wanted to try moving the camera around.", "tags": ["spheretracing"], "likes": 2, "viewed": 597, "date": "1468253603", "time_retrieved": "2024-06-20T18:39:08.061136", "image_code": "#define MAX_ITER 1000\n#define MAX_DIST 100.0\n#define EPSILON 0.001\n\nvec3 camPos = vec3(2.0 * sin(iTime), 4.0 * cos(iTime), iTime * 2.0);\nvec3 lightPos = camPos + vec3(0.0, 0.0, 1.0);\n\nfloat map(vec3 p){\n    vec3 q = mod(p, 8.0) - 4.0;\n    return length(max(abs(q)-1.5,0.0));;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n \tfloat t = 0.0;\n    float d = 0.0;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        d = map(ro + rd * t);\n        if(d < EPSILON){\n            break;\n        }\n        if(t > MAX_DIST){\n        \tt = 0.0;\n            break;\n    \t}\n        t += d;\n    }\n    return t;\n}\n\nmat3 rotY(float d){\n    float c = cos(d);\n    float s = sin(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c);\n}\nvec3 normal(vec3 p){\n    return vec3(map(vec3(p.x + EPSILON, p.yz)) - map(vec3(p.x - EPSILON, p.yz)),\n                map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n                map(vec3(p.xy, p.z + EPSILON)) - map(vec3(p.xy, p.z - EPSILON)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd *= rotY(iTime / 2.0);\n    float d = trace(ro, rd);\n    vec3 col;\n    if(d == 0.0){\n        col = vec3(0.0);\n    }else{\n        vec3 x = ro + (rd * d);\n    \tvec3 l = normalize(lightPos - x);\n        vec3 n = normalize(normal(x));\n    \tfloat nl = dot(n, l);\n    \n    \tvec3 amb = 0.25 * vec3(1.0);\n    \t\n        vec3 diff = 0.8 * vec3(0.0, 1.0, 1.0) * max(nl, 0.0);\n        \n        col = amb + diff;\n        \n        col *= vec3(1.0 / exp(d * 0.08));\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MttGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[184, 184, 202, 202, 277], [279, 279, 309, 309, 585], [587, 587, 606, 606, 746], [747, 747, 767, 767, 1021], [1024, 1024, 1081, 1081, 1748]]}
{"id": "Xl33D7", "name": "chasers", "author": "mahalis", "description": "just trailing around. had a lightbulb moment of sorts re: drawing motion trails by just sampling the movement function back in time. obvious in retrospect. ends up looking kinda neat though.", "tags": ["ink", "parametric", "trails"], "likes": 18, "viewed": 1357, "date": "1469581991", "time_retrieved": "2024-06-20T18:39:08.061136", "image_code": "vec2 thingPosition(float t, float aspect) {\n    float tx = t / aspect;\n    vec2 p = vec2(sin(2.2 * tx) - cos(1.4 * tx), cos(1.3 * t) + sin(-1.9 * t));\n    p.y *= 0.2;\n    p.x *= 0.4;\n \treturn p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(0.5) - fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 cFinal = vec3(0.0);\n    \n    vec3 color1 = vec3(0.9, 0.2, 0.4);\n    //vec3 color2 = vec3(0.8, 0.3, 0.2);\n    const float radius = 0.035;\n    const float tailLength = 0.7;\n    const float edgeWidth = 0.03;\n    for (int j = 0; j < 11; j++) {\n        float thisRadius = radius + sin(float(j) * 0.7 + iTime * 1.2) * 0.02;\n        float dMin = 1.0;\n        const int iMax = 12;\n        for (int i = 0; i < iMax; i++) {\n            float iPct = float(i) / float(iMax);\n            float segmentDistance = length(thingPosition(iTime * 2.0 + float(j) * 1.5 - iPct * tailLength, aspect) - uv);\n            dMin = min(dMin, segmentDistance + pow(iPct, 0.8) * (thisRadius + edgeWidth));\n        }\n        cFinal += 5.0 * (1.0 - smoothstep(thisRadius, thisRadius + edgeWidth, dMin)) * color1; //mix(color1, color2, mod(float(j), 2.0));\n    }\n    \n\tfragColor = vec4(vec3(1.0) - cFinal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl33D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 43, 43, 196], [198, 198, 255, 255, 1269]]}
{"id": "Xl33Wn", "name": "Worley Algorithm (Cell Noise )", "author": "Yeis", "description": "Application of Worley Cell Noise Algorithm, basic immplementation", "tags": ["noise", "worley", "yeis"], "likes": 18, "viewed": 639, "date": "1468620741", "time_retrieved": "2024-06-20T18:39:08.309452", "image_code": "float length2(vec2 p){\n    //producto punto entre los 2 vectore vx*vx + vY*vY\n    return dot(p,p);\n}\nfloat noise(vec2 p )\n{\n    //funcion de ruido pseudo-aleatoria basada en la funcio seno \n    return fract(cos(fract(sin(p.x)*(41.13311))+ p.y)*31.0011);\n}\n\nfloat worley(vec2 p) {\n    //ponemos un numero grandote \n float d = 1e30;\n    //checamos todos los puntos vecinos en 9 direcciones \n for (int xo = -1; xo <= 1; ++xo) {\n  for (int yo = -1; yo <= 1; ++yo) {\n   vec2 tp = floor(p) + vec2(xo, yo);\n   d = min(d, length2(p - tp - noise(tp)));\n  }\n }\n    //funcion exponencial mamona 3.0*exp(-4.0*abs(2.0*d - 1.0)).\n  return 3.0*exp(-4.0*abs((2.5*d)-1.0));\n}\n\nfloat fworley(vec2 p)\n{\n    return sqrt(sqrt(sqrt(worley(p * 5.0 + 0.05 * iTime) * \n                          sqrt(worley(p*50.0+ 0.12+ -0.1*iTime)) *\n                         sqrt(sqrt(worley(p*-10.0+00.03*iTime))))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n    float wolo = fworley(uv*iResolution.xy / 1500.0);\n    //Repeat the grid pattern 5 times by multiplying by uv.\n \twolo *= exp(-length2(abs(0.7*uv-1.0)));\n    fragColor = vec4(wolo * vec3(.1, 0.5*wolo, pow(wolo, 0.50-wolo)), 1.0);\n}\n\n//link http://ibreakdownshaders.blogspot.mx/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl33Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 77, 100], [101, 101, 123, 189, 255], [257, 257, 279, 313, 658], [660, 660, 683, 683, 881], [882, 882, 939, 939, 1215]]}
{"id": "Xl3GD8", "name": "Ray marching snakes", "author": "run", "description": "Messing with ray marching", "tags": ["raymarching"], "likes": 3, "viewed": 228, "date": "1469433740", "time_retrieved": "2024-06-20T18:39:08.309690", "image_code": "// ray marching\nconst float max_iterations = 55.;\nconst float stop_threshold = 0.001;\nconst float grad_step = .1;\nconst float clip_far = 250.0;\nconst float p = 2.;\nconst float q = 5.;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nfloat steps;\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\nvec3 torus_knot_pos(float time) {\n    float r = 6. + cos(time * q);\n    return vec3(r * cos(p * time),\n                r * sin(p * time),\n                -sin(q * time));\n}\n\nvec3 torus_knot_pos_x(float time) {\n    float r = 6. + cos(time * q);\n    return vec3(-sin(q * time),\n                r * cos(p * time),\n                r * sin(p * time));\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    vec3 pos01 = torus_knot_pos(mod(iTime, 2.*PI));\n    // object 0 : sphere\n\tfloat d0 = dist_sphere( pos  + pos01, 2. );\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos  + pos01, vec3( 1.4 + 0.3*sin(iTime) ) );\n    float final_value = max( d0, -d1 );\n    for (float i=0.; i<6.; i++) {\n        vec3 pos23 = torus_knot_pos(mod(iTime+i/4., 2.*PI));\n        // object 0 : sphere\n        float d2 = dist_sphere( pos  + pos23, 2. );\n        // object 1 : cube\n        float d3 = dist_box( pos  + pos23, vec3( 1.4 + 0.3*sin(iTime) ) );\n        final_value = smin(final_value, max(d2, -d3), 6.4);\n    }\n    \n    pos.x += 4.;\n    pos.y -= 4.;\n    \n    vec3 pos01_x = torus_knot_pos_x(mod(iTime-PI/2., 2.*PI));\n    // object 0 : sphere\n\tfloat d0_x = dist_sphere( pos  + pos01_x, 2. );\n\t// object 1 : cube\n\tfloat d1_x = dist_box( pos  + pos01_x, vec3( 1.4 + 0.3*sin(iTime) ) );\n    float final_value_x = max( d0_x, -d1_x );\n    for (float i=0.; i<6.; i++) {\n        vec3 pos23_x = torus_knot_pos_x(mod(iTime+i/4.-PI/2., 2.*PI));\n        // object 0 : sphere\n        float d2_x = dist_sphere( pos  + pos23_x, 2. );\n        // object 1 : cube\n        float d3_x = dist_box( pos  + pos23_x, vec3( 1.4 + 0.3*sin(iTime) ) );\n        final_value_x = smin(final_value_x, max(d2_x, -d3_x), 6.4);\n    }\n    \n    /*vec3 pos45 = torus_knot_pos(mod(iTime+2., 2.*PI));\n    // object 0 : sphere\n\tfloat d4 = dist_sphere( pos  + pos45, 2. );\n\t// object 1 : cube\n\tfloat d5 = dist_box( pos  + pos45, vec3( 1.4 + 0.3*sin(iTime) ) );*/\n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn smin(final_value, final_value_x, 4.);\n    //return max(d2, -d3);\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end) {\n\tfloat depth = start;\n\tfor ( float i = 0.; i < max_iterations; i++ ) {\n        steps = i * 1.;\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background\n    vec2 uv = fragCoord/iResolution.xy;\n    float intensity = min(1., max(0.,1. * sin(uv.y * 100.) + (2. + sin(iTime * 4.) * 2.) * sin(uv.x * 100.)));\n    \n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 15.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime * 0.1) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far);\n\tif ( depth >= clip_far ) {\n        float glow = min(max(0., (steps - 15.) * 0.08), 1.);\n\t\tfragColor = vec4( vec3(glow) + vec3(0.8, 0.8, 0.3) * intensity, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3GD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[185, 276, 317, 317, 391], [393, 414, 454, 454, 483], [485, 485, 524, 524, 575], [577, 577, 610, 610, 749], [751, 751, 786, 786, 925], [927, 956, 986, 1013, 2693], [2695, 2712, 2754, 2780, 3613], [3615, 3644, 3671, 3671, 4005], [4007, 4023, 4091, 4091, 4368], [4370, 4391, 4439, 4439, 4615], [4617, 4649, 4680, 4680, 4836], [4838, 4838, 4895, 4913, 5689]]}
{"id": "Xl3GDn", "name": "Fan", "author": "takkasila", "description": "Trying math functions and attempt ssaa", "tags": ["math", "graph", "ssaa"], "likes": 1, "viewed": 128, "date": "1468557154", "time_retrieved": "2024-06-20T18:39:08.309690", "image_code": "float func1(float x)\n{\n    return abs(fract(x) * sin(x));\n}\nfloat calVal(vec2 pos)\n{\n    return func1(iTime*pos.y/pos.x*fract(sin(pos.y/pos.x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rtio = vec2(iResolution.x/iResolution.y, 1);\n    vec2 p1 = ((fragCoord.xy + vec2(0.25,0.0))/iResolution.xy - vec2(0.5, 0.5))*rtio;\n    vec2 p2 = ((fragCoord.xy + vec2(0.75,0.0))/iResolution.xy - vec2(0.5, 0.5))*rtio;\n    vec2 p3 = ((fragCoord.xy + vec2(0.25,0.25))/iResolution.xy - vec2(0.5, 0.5))*rtio;\n    vec2 p4 = ((fragCoord.xy + vec2(0.75,0.75))/iResolution.xy - vec2(0.5, 0.5))*rtio;\n    float val = (calVal(p1) + calVal(p2) + calVal(p3) + calVal(p4))/4.0;\n    fragColor = vec4(val-0.2, val+0.2, 0.1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3GDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 59], [60, 60, 84, 84, 147], [149, 149, 206, 206, 731]]}
{"id": "Xlc3zH", "name": "Box Density", "author": "richardlee", "description": "Box fog test", "tags": ["3d"], "likes": 0, "viewed": 89, "date": "1467840778", "time_retrieved": "2024-06-20T18:39:09.346044", "image_code": "\n\nfloat plnIntersect( in vec3 ro, in vec3 rd, vec4 pln )\n{\n    return (pln.w - dot(ro,pln.xyz))/dot(rd,pln.xyz);\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nvec2 boxIntersect( vec3 ro, vec3 rd, mat4 txx, vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0, -1.0);\n\t\n\treturn vec2(tN, tF);\n}\n\nfloat boxDensity(vec3 ro, vec3 rd, mat4 txx, vec3 rad, float dbuffer)\n{\t\n    // ray and ray-box intersection in box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 tA = -n - k;\n    vec3 tB = -n + k;\n\tfloat tN = max( max( tA.x, tA.y ), tA.z );\n\tfloat tF = min( min( tB.x, tB.y ), tB.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    \n    // box behind camera or past dbuffer\n    if( tN > dbuffer || tF < 0.0) return -1.0;\n    \n    // clip integration segment from camera to dbuffer\n    tN = max( tN, 0.0 );\n    tF = min( tF, dbuffer );\n    \n    // move ray to start from tN\n    roo += tN*rdd;\n    tF -= tN;\n    tN = 0.0;\n    \n#if 1\n    // density calculation. density is of the form\n    //\n    // d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n    //\n    // this can be analytically integrable (it's a degree 6 polynomial):\n    vec3 a = rad * rad - roo * roo;;\n    vec3 b = -2.0 * roo * rdd;\n    vec3 c = -(rdd * rdd);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t3*t3;\n    float t7 = t3*t4;\n    \n    float i2 = (t1/1.0) *(a.x*a.y*a.z) + \n              (t2/2.0) *(a.x*a.y*b.z + a.x*b.y*a.z + b.x*a.y*a.z) + \n              (t3/3.0) *(a.x*a.y*c.z + a.x*b.y*b.z + a.x*c.y*a.z + b.x*a.y*b.z + b.x*b.y*a.z + c.x*a.y*a.z) +\n              (t4/4.0) *(a.x*b.y*c.z + a.x*c.y*b.z + b.x*a.y*c.z + b.x*b.y*b.z + b.x*c.y*a.z + c.x*a.y*b.z + c.x*b.y*a.z) + \n              (t5/5.0) *(a.x*c.y*c.z + b.x*b.y*c.z + b.x*c.y*b.z + c.x*a.y*c.z + c.x*b.y*b.z + c.x*c.y*a.z) + \n              (t6/6.0) *(b.x*c.y*c.z + c.x*b.y*c.z + c.x*c.y*b.z) + \n              (t7/7.0) *(c.x*c.y*c.z);\n    float fog = i2 / (rad.x * rad.x * rad.y * rad.y * rad.z * rad.z);\n    \n\treturn fog / (length(rad));\n#else\n    vec3 a = rad * rad - roo * roo;;\n    vec3 b = -2.0 * roo * rdd;\n    vec3 c = -(rdd * rdd);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    \n    float i2 = a.x * t1 + b.x * t2/2.0 + c.x * t3/3.0;\n    float fog = i2 / (rad.x * rad.x);\n    \n\t// return tF - tN;\n\t//return roo.x; \n\treturn fog / (2.0 * rad.x) ;\n#endif\n}\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y; //-1 to 1\n    \n\tvec3 ro = vec3(0.0, 1.0, 3.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n    // sphere\n    vec4 sph = vec4( cos( iTime*vec3(1.0,1.1,1.3) + vec3(2.0,1.5,1.5) + 0.0 )*vec3(1.5,0.3,0.7) + vec3(0.0,0.2,0.5), 1.0 );\n    // planes\n    vec4 pl1 = vec4(  0.0, 1.0, 0.0, 0.0 );\n    vec4 pl2 = vec4(  1.0, 0.0, 0.0, 1.0 );\n    vec4 pl3 = vec4( -1.0, 0.0, 0.0, 1.0 );\n    vec4 pl4 = vec4(  0.0, 0.0,-1.0, 1.0 );\n    \n    \n    vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n\n\t\n    \n    float t2 = plnIntersect( ro, rd, pl1 );\n    float t3 = plnIntersect( ro, rd, pl2 );\n    float t4 = plnIntersect( ro, rd, pl3 );\n    float t5 = plnIntersect( ro, rd, pl4 );\n    \n    float tmin = 1000.0;\n    vec4  omin = vec4(0.0);\n    if( t2>0.0 && t2<tmin ) { tmin=t2; omin=pl1; }\n    if( t3>0.0 && t3<tmin ) { tmin=t3; omin=pl2; }\n    if( t4>0.0 && t4<tmin ) { tmin=t4; omin=pl3; }\n    if( t5>0.0 && t5<tmin ) { tmin=t5; omin=pl4; }\n\n    vec3 col = vec3(0.0);\n    \n    //Draw walls\n    vec3 pos = ro + tmin*rd;\n    col = vec3(0.1,0.15,0.2);\n    col *= 0.8 + 0.4*dot(omin.xyz,lig);\n    vec3 w = abs(omin.xyz);\n    col = (texture( iChannel0, 0.5*pos.zx ).xyz*w.y+\n           texture( iChannel0, 0.5*pos.xy ).xyz*w.z+\n           texture( iChannel0, 0.5*pos.yz ).xyz*w.x)/(w.x+w.y+w.z);\n    col *= 0.3;\n    float occ = 1.0;\n    occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2( 1.0, 0.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2(-1.0, 0.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.yz-vec2( 0.0,-1.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2( 1.0,-1.0)));\n    occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2(-1.0,-1.0)));\n    col *= vec3(0.4,0.3,0.2) + vec3(0.6,0.7,0.8)*occ;\n    \n    /*float h = sphDensity(ro, rd, sph.xyz, sph.w, tmin );\n    if( h>0.0 )\n    {\n        //col = mix( col, vec3(0.2,0.5,1.0), h );\n        col = vec3(1.0, 0.5, 0.4);\n    }*/\n    \n    // rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n    vec3 box = vec3(1.2 , 1.2, 0.8) ;\n    //vec3 box = vec3(1.0, 0.4, 0.4) ;\n    vec2 res = boxIntersect( ro, rd, txx, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\t//col = vec3(0.5, 1.0, 0.4);\n        float hBox = boxDensity( ro, rd, txx, box, tmin);\n    //if (hBox > 0.0) {\n        \n        col = mix( col, vec3(0.2,0.5,1.0), hBox );\n        if (hBox > 1.0) {\n         \tcol = vec3(1.0, 0.0, 0.0);   \n        }\n    //}\n\t}\n    \n    col = sqrt( col );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2, 2, 58, 58, 114], [116, 116, 163, 163, 567], [569, 569, 614, 614, 730], [732, 732, 759, 759, 1009], [1011, 1011, 1071, 1071, 1423], [1425, 1425, 1496, 1546, 3637], [3638, 3695, 3752, 3752, 6375]]}
{"id": "XlcGRn", "name": "Space Elevator", "author": "dr2", "description": "An unlikely mode of transportation", "tags": ["raymarch", "space"], "likes": 8, "viewed": 561, "date": "1467538966", "time_retrieved": "2024-06-20T18:39:09.366970", "image_code": "// \"Space Elevator\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Noisefv3 (vec3 p);\nfloat Fbm3 (vec3 p);vec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 SSBump (float w, float s, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrHexp2Df (vec2 p, float r);\n\nint idObj;\nvec3 qHit, sunDir, wPos, cgPos;\nfloat dstFar, tCur, cbLen, cbRad, cgRad, cgLen, wRad, wGap, wtRad, wcRad;\nbool showElev;\nconst int idHub = 1, idSph = 2, idTor = 3, idCbl = 4, idCage = 5;\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nfloat CageDf (vec3 p, float pAng, float dMin)\n{\n  vec3 q;\n  vec2 qs;\n  float d;\n  q = p;\n  qs = vec2 (mod (vec2 (16. * pAng, 0.25 * q.z) + 0.5, 1.) - 0.5);\n  d = max (PrCylAnDf (p, cgRad, 0.1, cgLen), - PrBox2Df (qs, vec2 (0.45)));\n  if (d < dMin) { dMin = d;  idObj = idCage;  qHit = q; }\n  q.z = abs (q.z) - cgLen;\n  d = max (max (PrSphDf (q, cgRad + 0.1), cbRad + 0.1 - length (q.xy)), - q.z);\n  if (d < dMin) { dMin = d;  idObj = idCage;  qHit = q; }\n  return dMin;\n}\n\nfloat CablDf (vec3 p, float pAng, float dMin)\n{\n  vec3 q;\n  vec2 vg, qs;\n  float d, wd;\n  q = p;\n  wd = 1./3.;\n  vg = 1.15 * wd * vec2 (sqrt3, 1.);\n  q.z += mod (0.8 * tCur, 4.);\n  qs = vec2 ((32. / 3.) * pAng, sqrt3 * q.z);\n  d = min (PrHexp2Df (mod (qs + vg, 2. * vg) - vg, wd),\n           PrHexp2Df (mod (qs, 2. * vg) - vg, wd));\n  d = 0.7 * max (PrCylAnDf (q, cbRad, 0.02 * cbRad, cbLen), - d);\n  if (d < dMin) { dMin = d;  idObj = idCbl;  qHit = p; }\n  return dMin;\n}\n\nfloat WhlDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, a, s;\n  p.xy = Rot2D (p.xy, 0.19 * tCur);\n  q = p;\n  d = PrCylDf (q, 2. * wcRad, 2. * wGap + wcRad);\n  if (d < dMin) { dMin = d;  idObj = idHub;  qHit = q; }\n  q.z = abs (q.z) - wGap;\n  d = PrRCylDf (q, 4. * wcRad, 2. * wcRad, 1.5 * wtRad);\n  if (d < dMin) { dMin = d;  idObj = idHub;  qHit = q; }\n  q.z -= wGap + 4. * wcRad;\n  d = PrSphDf (q, 4. * wcRad);\n  qq = q;\n  qq.z -= 4. * wcRad;\n  d = max (d, - PrCylDf (qq, 1.5 * wcRad, wcRad));\n  if (d < dMin) { dMin = d;  idObj = idSph;  qHit = q; }\n  q.z += wGap + 4. * wcRad;\n  d = PrTorusDf (q, wtRad, wRad);\n  if (d < dMin) { dMin = d;  idObj = idTor;  qHit = q; }\n  q = p;\n  a = atan (q.y, - q.x) / (2. * pi);\n  q.xy = Rot2D (q.xy, (0.5 + floor (7. * a)) * (2. * pi / 7.));\n  q.x -= - wRad;\n  d = PrCylDf (q, wcRad, wGap);\n  if (d < dMin) { dMin = d;  idObj = idHub;  qHit = q; }\n  q.z = abs (q.z) - wGap;\n  d = PrSphDf (q, 1.3 * wtRad);\n  if (d < dMin) { dMin = d;  idObj = idHub;  qHit = q; }\n  s = 1. + 0.2 * SmoothBump (0.45, 0.55, 0.02, mod (4. * q.x / wRad + 0.5, 1.));\n  q.x -= 0.5 * wRad;\n  d = PrCylDf (q.yzx, wcRad * s, 0.5 * wRad);\n  if (d < dMin) { dMin = d;  idObj = idHub;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, pAng;\n  pAng = 0.5 * (atan (p.y, - p.x) / pi + 1.);\n  dMin = dstFar;\n  dMin = WhlDf (p - wPos, dMin);\n  if (showElev) {\n    dMin = CablDf (p - cgPos, pAng, dMin);\n    dMin = CageDf (p - cgPos, pAng, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 qs;\n  float a, d;\n  q = p;\n  a = 0.5 * (atan (q.y, - q.x) / pi + 1.);\n  qs = vec2 (mod (vec2 (16. * a, 0.25 * q.z) + 0.5, 1.) - 0.5);\n  d = max (PrCylAnDf (q, cgRad - 0.05, 0.05, cgLen), PrBox2Df (qs, vec2 (0.45)));\n  return d;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col;\n  float a, aa, f;\n  if (idObj == idTor) {\n    col = vec4 (0.9, 0.9, 1., 0.3);\n    a = (atan (qHit.y, - qHit.x) / (2. * pi));\n    aa = atan (qHit.z, length (qHit.xy) - wRad) / (2. * pi);\n    f = max (SmoothBump (0.3, 0.7, 0.02, mod (0.5 + 63. * a, 1.)),\n       SmoothBump (0.3, 0.7, 0.02, mod (4. * aa, 1.)));\n    col = mix (vec4 (0.7, 0.7, 0.2, 1.), col, f);\n  } else if (idObj == idSph) {\n    col = vec4 (0.9, 0.9, 1., 0.3);\n    a = (atan (qHit.y, - qHit.x) / (2. * pi));\n    aa = atan (qHit.z, length (qHit.xy)) / (2. * pi);\n    f = max (SmoothBump (0.3, 0.7, 0.02, mod (0.5 + 14. * a, 1.)),\n       1. - SmoothBump (-0.05, 0.05, 0.01, aa));\n    col = mix (vec4 (0.7, 0.7, 0.2, 1.), col, f);\n    if (length (qHit.xy) < 1.5 * wcRad) col = vec4 (0.1, 0.1, 0., -1.);\n  } else if (idObj == idCbl) {\n    col = vec4 (0.9, 1., 0.9, 0.3);\n  } else if (idObj == idCage) {\n    col = vec4 (0.9, 0.9, 1., 0.3);\n  } else if (idObj == idHub) {\n    col = vec4 (0.9, 0.9, 1., 0.3);\n  }\n  return col;\n}\n\nvec3 PlCol (vec3 rd, vec3 vn)\n{\n  vec4 gCol, cCol;\n  vec3 col, sn, vc;\n  float spec, s;\n  sn = vn;\n  sn.xz = Rot2D (sn.xz, 0.1 * tCur);\n  s = min ((0.5 + 0.5 * sn.y * sn.y) *\n     Fbm3 (3. * normalize (vec3 (sn.xz, 0.8 * sn.y))), 1.);\n  col = vec3 (0.5, 0.5, 1.);\n  col = mix (col, vec3 (0.1, 0.2, 0.1), step (0.6, s));\n  col = mix (col, vec3 (0.3, 0.25, 0.1), step (0.7, s));\n  col = mix (col, vec3 (0.7), step (0.9, s));\n  spec = mix (0.8, 0.1, step (0.6, s));\n  gCol = vec4 (col, spec);\n  sn = vn;\n  sn.xz = Rot2D (sn.xz, 0.12 * tCur);\n  vc = normalize (vec3 (0.7 * sn.xz, sn.y));\n  cCol = vec4 (1., 1., 1., 0.2) * (1. - 0.2 * Fbm3 (27. * vc));\n  gCol = mix (gCol, cCol, smoothstep (0.5, 0.9, 0.7 * Fbm3 (7. * vc)));\n  if (s > 0.6) vn = VaryNf (20. * sn, vn, 1.);\n  col = gCol.rgb * (0.1 +\n     0.1 * max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.) +\n     max (0., max (dot (vn, sunDir), 0.)) + gCol.a *\n     pow (max (0., dot (sunDir, reflect (rd, vn))), 16.));\n  return col;\n}\n\nvec3 HvnCol (vec3 ro, vec3 rd)\n{\n  vec3 rds, col;\n  float a, s, plAng;\n  plAng = 0.06;\n  a = atan (length (rd.xy), - rd.z);\n  if (a < plAng) {\n    s = sin (a);\n    s *= cos (a) / plAng - sqrt (1. - s * s / (plAng * plAng));\n    col = PlCol (rd, vec3 (s * normalize (rd.xy), sqrt (1. - s * s)));\n  } else {\n    rds = floor (2000. * rd);\n    rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n    for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n    col = vec3 (0.8, 0.8, 0.6) *\n       min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n    s = pow (max (0., dot (rd, sunDir)), 16.);\n    col = vec3 (0., 0., 0.03) + col * (1. - smoothstep (0.9, 1., s));\n    s = pow (s, 128.);\n    col += vec3 (1., 0.95, 0.8) * (0.2 * s + 0.9 * pow (s, 8.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, rCol, vn, roo, rdo;\n  vec4 objCol;\n  vec2 ss;\n  float dstHit, dstWin, sh, spec, a;\n  int idObjT;\n  roo = ro;\n  rdo = rd;\n  if (showElev) dstWin = TransObjRay (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol ();\n    if (idObj == idCage) {\n      a = mod (16. * atan (qHit.y, - qHit.x) / (2. * pi), 1.) - 0.5;\n      if (abs (a) < 0.1) {\n        ss = SSBump (0.02, 0.03, a);\n        if (ss.x + ss.y != 0.) {\n          vn.xy *= 1. + 0.5 * (ss.y - ss.x);\n          vn = normalize (vn);\n        }\n      }\n    }\n    vn = VaryNf (50. * ro, vn, 0.1);\n    rCol = (objCol.a >= 0.) ? HvnCol (ro, reflect (rd, vn)) : vec3 (0.);\n    sh = ObjSShadow (ro, sunDir);\n    col = objCol.rgb * (0.1 +\n       0.2 * max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.) +\n       0.7 * sh * max (0., max (dot (vn, sunDir), 0.)));\n    col = sh * mix (col, rCol, 0.2);\n    col += objCol.a * sh * vec3 (1., 1., 0.95) *\n       pow (max (0., dot (sunDir, reflect (rd, vn))), 16.);\n  } else col = HvnCol (ro, rd);\n  if (idObj == idCbl && abs (qHit.z) > 0.9 * cbLen)\n     col = mix (col, HvnCol (roo, rdo), smoothstep (0.9, 1., abs (qHit.z) / cbLen));\n  if (showElev && dstWin < min (dstHit, dstFar)) {\n    vn = vec3 (normalize (roo.xy), 0.);\n    rCol = vec3 (0.05, 0.05, 0.) + HvnCol (roo, reflect (rdo, vn));\n    col = mix (col * vec3 (1., 1., 0.5), rCol,\n       1. - pow (max (- dot (rdo, vn), 0.), 5.));\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  vec2 uv;\n  float f, t, tm, tCyc;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  dstFar = 1000.;\n  cbLen = 150.;\n  wRad = 20.;\n  wGap = wRad / 8.;\n  wtRad = wRad / 20.;\n  wcRad = wRad / 40.;\n  cbRad = 1.;\n  cgRad = 4.;\n  cgLen = 5.;\n  wPos = vec3 (0., 0., 400.);\n  cgPos = vec3 (0.);\n  tCyc = 80.;\n  showElev = (mod (tCur, 0.5 * tCyc) < 0.25 * tCyc);\n  if (showElev) {\n    t = 0.05 * mod (tCur, 0.25 * tCyc);\n    f = SmoothBump (0.25, 0.75, 0.15, mod (2. * t, 1.)) *\n       (2. * step (0.5 * tCyc, mod (tCur, tCyc)) - 1.);\n    tm = 2. * step (0.5, mod (t + 0.25, 1.)) - 1.;\n    ro = vec3 (- (50. + 50. * abs (f)) * tm, 10. * f, 0.);\n    ro.xz = Rot2D (ro.xz, 0.5 * pi * f * (2. * step (0.5, t) - 1.));\n    ro.z *= tm;\n    ro.z += cgPos.z;\n    vd = normalize (cgPos - ro);\n  } else {\n    ro = vec3 (150., 0., 0.);\n    ro.xz = Rot2D (ro.xz, 0.1 * tCur);\n    ro.xy = Rot2D (ro.xy, 0.032 * tCur);\n    ro.z += wPos.z;\n    vd = normalize (wPos - ro);\n  }\n  u = - vd.y * vd;\n  f = 1. / max (0.001, sqrt (1. - vd.y * vd.y));\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 6.));\n  sunDir = vec3 (1., 0., 0.);\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrHexp2Df (vec2 p, float r)\n{\n  vec2 pa;\n  pa = abs (p);\n  return max (0.5 * (pa.x * sqrt3 + pa.y), pa.y) - r;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  const vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 SSBump (float w, float s, float x)\n{\n  return vec2 (step (x + s, w) * step (- w, x + s),\n     step (x - s, w) * step (- w, x - s));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 884, 931, 931, 1355], [1357, 1357, 1404, 1404, 1829], [1831, 1831, 1865, 1865, 3059], [3061, 3061, 3083, 3083, 3324], [3326, 3326, 3359, 3359, 3568], [3570, 3570, 3597, 3597, 3844], [3846, 3846, 3884, 3884, 4098], [4100, 4100, 4121, 4121, 4328], [4330, 4330, 4367, 4367, 4605], [4607, 4607, 4623, 4623, 5622], [5624, 5624, 5655, 5655, 6621], [6623, 6623, 6655, 6655, 7411], [7413, 7413, 7448, 7448, 9030], [9032, 9032, 9088, 9088, 10402], [10404, 10404, 10437, 10437, 10526], [10528, 10528, 10561, 10561, 10588], [10590, 10590, 10632, 10632, 10683], [10685, 10685, 10738, 10738, 10799], [10801, 10801, 10854, 10854, 11033], [11035, 11035, 11081, 11081, 11138], [11140, 11140, 11175, 11175, 11258], [11381, 11381, 11405, 11405, 11452], [11454, 11454, 11479, 11479, 11678], [11680, 11680, 11705, 11705, 12049], [12051, 12051, 12072, 12072, 12211], [12213, 12213, 12242, 12242, 12454], [12456, 12456, 12495, 12495, 12718], [12720, 12720, 12777, 12777, 12860], [12862, 12862, 12903, 12903, 13000], [13002, 13002, 13032, 13032, 13090]]}
{"id": "XlcGzn", "name": "SSS Light Study 3", "author": "aiekick", "description": "SSS Light Study 3", "tags": ["sss", "light", "study", "3"], "likes": 14, "viewed": 682, "date": "1467570767", "time_retrieved": "2024-06-20T18:39:10.303668", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2016 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// link : https://www.shadertoy.com/view/XlcGzn\n\nfloat pattern(vec3 p)\n{\n\tp = fract(p) - 0.5;\n\treturn (min(min(abs(p.x), abs(p.y)), abs(p.z)) + 0.56);\n}\n\nvec3 effect(vec3 p) \n{\n\tfloat d = pattern(p);\n    return vec3(d/0.78); \n}\n\nvec2 df(vec3 p)\n{\n\tp += sin(p.zxy) + sin(p.xzy); // iq shape tech\n    vec3 col = 1.-clamp(effect(p*0.15),0.,1.);\n\treturn vec2(length(p) - dot(col,vec3(2.8)) - 1.64 , 2.);\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.01, 0.04);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(80.*sb+320.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, p, n, 0.019);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.23; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p, 7.8); \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb * li + spe, \n        (diff + fre + bb * sb * 0.8 + sss * 0.4) * amb * li + spe * 0.6 \t\n    );\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    float t = iTime;\n    \n    float ca = t;\n    float cd = 7.3;\n    float ce = 0.52;\n    \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n\n\tvec3 ro = vec3(cos(ca),sin(ce),sin(ca)) * cd;\n  \tvec3 cv = vec3(0);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 15., s = 1., d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.2*log(d*d/s/500.)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s *0.2;\n    }\n\t\n    if (d<md)\n\t\tfragColor.rgb = mix(\n            shade(ro, rd, d, ro, 1.2).yzw, \n            vec3(0), \n            1.-exp(-0.02*d*d));\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlcGzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 262, 285, 285, 365], [367, 367, 389, 389, 440], [442, 442, 459, 459, 614], [616, 616, 653, 653, 865], [867, 1088, 1116, 1116, 1441], [1443, 1525, 1582, 1582, 1806], [1808, 1808, 1844, 1844, 1979], [1981, 2157, 2208, 2208, 2382], [2384, 2593, 2656, 2656, 3018], [3020, 3020, 3078, 3078, 3959], [3961, 3961, 4007, 4007, 4176], [4178, 4178, 4235, 4235, 4871]]}
{"id": "Xld3z7", "name": "Sphere Tracer with Materials", "author": "geoff", "description": "My first attempt at different materials in the same scene. Probably not that well laid out, but it works on this simple scene. Move the light source with the mouse.", "tags": ["3d", "csg", "spheretracing"], "likes": 1, "viewed": 430, "date": "1468457537", "time_retrieved": "2024-06-20T18:39:10.303668", "image_code": "#define MAX_DIST 25.0\n#define MAX_ITER 1000\n#define EPSILON 0.00001\n#define CAM_POS vec3(0.0, 0.0, -5.0)\n#define LIGHT_POS vec3(12.0 * iMouse.x / iResolution.x - 6.0, 2.0, 6.0 * iMouse.y / iResolution.y - 9.0)\n#define T_MIN 0.01\n#define AO_SAMPLES 15\n#define AO_STRENGTH 3.0\n\nmat3 rotY(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c);\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = p;\n    q -= vec3(0.5 * cos(iTime), 0.0, 0.5 * sin(iTime));\n    vec3 r = p;\n    r -= vec3(-2.5 * cos(iTime), 0.0, -2.5 * sin(iTime));\n    r *= rotY(iTime);\n    vec2 sphere = vec2(max(-(length(p) - 1.0), length(q) - 1.0), 1.0);\n    vec2 cube = vec2(length(max(abs(r)-1.0,0.0)), 1.0);\n    vec2 hplane = vec2(p.y + 1.0, 2.0);\n    vec2 vplane = vec2(-p.z + 4.0, 3.0);\n    \n    float m = min(cube.x, min(sphere.x, min(hplane.x, vplane.x)));\n    return m == cube.x ? cube : m == sphere.x ? sphere : (m == hplane.x ? hplane : vplane); \n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nvec2 trace(vec3 ro, vec3 rd){\n \tfloat t = 0.0;\n    float d = 0.0;\n    vec2 coll;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        coll = mapMat(ro + rd * t);\n        d = coll.x;\n        if(d < EPSILON){\n            break;\n        }\n        if(t > MAX_DIST){\n        \tt = 0.0;\n            break;\n    \t}\n        t += d;\n    }\n    return vec2(t, coll.y);\n}\n\n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = T_MIN;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        d = map(ro + rd * t);\n        if(d < EPSILON){\n            return 0.0;\n        }\n        if(t > MAX_DIST){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nvec3 normal(vec3 p){\n    return vec3(map(vec3(p.x + EPSILON, p.yz)) - map(vec3(p.x - EPSILON, p.yz)),\n                map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n                map(vec3(p.xy, p.z + EPSILON)) - map(vec3(p.xy, p.z - EPSILON)));\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(AO_STRENGTH * occ, 0.0, 1.0);\n}\n\n//Material colours\nvec3 matCol(float id, vec3 p){\n    if(id == 1.0){\n        return vec3(1.0, 1.0, 0.0);\n    }\n    if(id == 2.0){\n        return (mod(floor(p.z), 2.0) == 0.0 && mod(floor(p.x), 2.0) != 0.0) \n            \t|| (mod(floor(p.z), 2.0) != 0.0 && mod(floor(p.x), 2.0) == 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    }\n    return vec3(0.0, 0.0, 1.0);\n}\n\n//Material properties AMB DIFF SPEC ALPHA\nvec4 matProp(float id){ \n    if(id == 1.0){\t\t\n        return vec4(0.25, 0.8, 0.5, 64.0);\n    }\n    if(id == 2.0){\n        return vec4(0.25, 0.5, 0.5, 2.0);\n    }\n    return vec4(0.25, 0.9, 0.2, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = CAM_POS;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec2 coll = trace(ro, rd);\n    float d = coll.x;\n    float matID = coll.y;\n    vec3 col;\n    if(d == 0.0){\n        col = vec3(0.0);\n    }else{\n        vec3 x = ro + (rd * d);\n    \tvec3 l = normalize(LIGHT_POS - x);\n        vec3 n = normalize(normal(x));\n    \tfloat nl = dot(n, l);\n    \tfloat s = shadow(x, l);\n        \n        //Get material properties\n        vec4 consts = matProp(matID);\n        vec3 matC = matCol(matID, x);\n        \n        //Calculate ambient light\n    \tvec3 amb = consts.x * matC * occlusion(x, n);\n    \t\n        //Calculate diffuse\n        vec3 diff = consts.y * matC * max(nl, 0.0);\n    \t\n        //Calculate specular\n        vec3 spec = vec3(0.0);\n        //If in shadow, no specular highlight\n        if(s == 1.0){\n    \t\tfloat facing = nl > 0.0 ? 1.0 : 0.0;\n    \t\tvec3 h = 2.0 * nl * n - l;\n    \t\tspec = facing * consts.z * matC * pow(max(dot(n, h), 0.0), consts.w);\n        }\n    \t\n    \tcol = amb + diff + spec;\n        \n        //Shadows\n    \tcol -= vec3(0.5 - 0.5 * s);\n        \n        //Fog\n        col *= vec3(1.0 / exp(d * 0.08));\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xld3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[276, 276, 295, 295, 435], [437, 437, 457, 457, 1000], [1002, 1002, 1020, 1020, 1046], [1048, 1048, 1077, 1077, 1408], [1411, 1411, 1442, 1442, 1786], [1788, 1788, 1808, 1808, 2062], [2064, 2064, 2098, 2098, 2363], [2365, 2384, 2414, 2414, 2733], [2735, 2777, 2800, 2800, 2978], [2980, 2980, 3037, 3037, 4316]]}
{"id": "Xld3zM", "name": "Stereo Boxes", "author": "zproxy", "description": "// based upon\n// https://www.shadertoy.com/view/XsdXW2\n//  by Marqin", "tags": ["anaglyph", "stereo"], "likes": 5, "viewed": 227, "date": "1468429082", "time_retrieved": "2024-06-20T18:39:10.303668", "image_code": "// based upon\n// https://www.shadertoy.com/view/XsdXW2\n//  by Marqin\n\n\nconst int MaximumRaySteps = 128;\nconst float MinimumDistance = 0.00001;\n\n\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdBox( vec3 boxpos, vec3 p, vec3 b ) {\n    p -= boxpos;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat boxLine( vec3 point, float z ) {\n    \n    float bsize = 0.9;\n    \n    vec3 box = vec3(0., bsize, z);\n    \n    float dist = sdBox(box, point, vec3(bsize));\n    \n    for( float i = 1.; i < 3.; i++ ) {\n        vec3 npos = vec3(box.x + i*2.*(bsize+0.35), box.y, box.z);\n        float newBox = sdBox(npos, point, vec3(bsize));\n        dist = min(dist, newBox);\n    }\n    \n    return dist;\n}\n\nfloat DistanceEstimator( vec3 point ) {\n    \n    float dist = min(boxLine(point, 0.), boxLine(point, 2.5));\n\n    return min(dist, sdPlane(point));\n}\n\n\nmat3 lookAt( vec3 origin, vec3 direction, float roll ) {\n    vec3 ww = normalize(direction);\n\tvec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll),0.0)));\n\tvec3 vv = normalize(cross(uu, ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getNormal( in vec3 pos ) {\n// from iq\n\tvec3 eps = vec3( MinimumDistance, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    DistanceEstimator(pos+eps.xyy) - DistanceEstimator(pos-eps.xyy),\n\t    DistanceEstimator(pos+eps.yxy) - DistanceEstimator(pos-eps.yxy),\n\t    DistanceEstimator(pos+eps.yyx) - DistanceEstimator(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nconst float k = 32.;\n\nfloat shadow( Ray r ) {\n    float dist = 2.*MinimumDistance;\n    float sh = 1.0;\n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n        vec3 newLocation = r.origin + dist * r.direction;\n\t\tfloat h = DistanceEstimator(newLocation);\n        if( h < MinimumDistance || dist > 10.)\n            return sh;\n        sh = min( sh, 32.*h/dist );\n        dist += h;\n    }\n    return sh;\n}\n\nvec3 shade(vec3 p) {\n    vec3 lightColor = vec3(0.9, 0.99, 0.99);\n\n    vec3 lightDir = normalize(vec3(sin(iTime/1.0), 0.6, -0.3));\n\n    \n    vec3 normal = getNormal(p);\n    vec3 light = lightColor * dot(normal, lightDir);\n   \n    return light* shadow(Ray(p, normalize(lightDir)));\n}\n\n\nvec3 trace( Ray r ) {\n\tfloat totalDistance = 0.0;\n    \n    float colour = 0.8;\n    \n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n\t\tvec3 newLocation = r.origin + totalDistance * r.direction;\n\t\tfloat distance = DistanceEstimator(newLocation);\n\t\ttotalDistance += distance;\n        if( distance < MinimumDistance ) {\n            if( newLocation.y <= MinimumDistance )\n            \tcolour = 1.0;\n        \tbreak;\n        }\n\t}\n   \n    return colour*shade(r.origin + totalDistance* r.direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 uv = 2.*gl_FragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 camL = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n    vec3 dirL = vec3(1.,0.,0.) - camL;\n    mat3 cameraMatrixL = lookAt( camL, dirL, 0.0 );\n\n    vec3 camR = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n    vec3 dirR = vec3(1.,0.,0.) - camR;\n    mat3 cameraMatrixR = lookAt( camR, dirR, 0.0 );\n\n    \n    \n    vec2 uvDiff = vec2(1);\n\n    float IPD = 0.02 * (1. + cos(iTime/1.5));\n    \n    // should be moving camera instead!\n    vec3 rd5L = normalize(cameraMatrixL * vec3(uv+ vec2(-IPD * uvDiff.x, 0.0 * uvDiff.y),1.0));\n    vec3 rd5R = normalize(cameraMatrixR * vec3(uv+ vec2(IPD * uvDiff.x, 0.0 * uvDiff.y),1.0));\n    \n   \n    vec3 t5L = trace(Ray(camL, rd5L));\n\tvec3 t5R = trace(Ray(camR, rd5R));\n\n    \n    fragColor = vec4(sqrt(t5L.r),  t5R.gb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xld3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 201, 226, 226, 241], [243, 243, 287, 287, 389], [392, 392, 430, 430, 783], [785, 785, 824, 824, 933], [936, 936, 992, 992, 1163], [1165, 1165, 1196, 1207, 1510], [1535, 1535, 1558, 1558, 1911], [1913, 1913, 1933, 1933, 2195], [2198, 2198, 2219, 2219, 2688], [2691, 2691, 2748, 2748, 3657]]}
{"id": "XldGD7", "name": "sams checkers", "author": "goatpucci", "description": "boxes", "tags": ["boxes"], "likes": 1, "viewed": 105, "date": "1469687275", "time_retrieved": "2024-06-20T18:39:10.303668", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x + 30.0;\n    float red = time * sin(uv.x * time) * cos(uv.y * time);\n    fragColor = vec4(red, cos(time * 0.5), sin(time * 0.5), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 275]]}
{"id": "XldGzr", "name": "Virtigo", "author": "BigotedSJW", "description": "[insert tired Flippy from Starfox meme here]", "tags": ["2d", "projection", "checker"], "likes": 2, "viewed": 151, "date": "1467704479", "time_retrieved": "2024-06-20T18:39:10.552302", "image_code": "float checker( in vec2 p, in float s );\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x / iResolution.y; //square cooridinated, 0,0 at center\n\t\n    \n    float ang = 1.5*iTime;\n    vec2 rot=vec2(sin(ang),cos(ang));\n    mat2 rm =mat2(rot.x,rot.y,-rot.y,rot.x);\n    uv=rm*uv; //rotate input coordinates\n\n    //projection\n    vec3 project_in =  vec3(uv.x,  0.5, abs(uv.y));\n\tvec2 project_out = project_in.xy/ project_in.z + (vec2(0.0,4.0*iTime));\n    \n    //sample (procedural) texture (poorly, hence artifacting at the 'horizon')\n    float tex = checker(project_out,4.0);\n    \n\tfragColor = vec4(vec3(tex),1.0); \n}\n\nfloat checker( in vec2 p, in float s )\n{\n\t//ivec2 state = ivec2(p * s); //interger binary operations not supported :(\n   \tvec2 state=floor(s*p);\n    \n    //float xodd = mod(state.x,2.0);\n    //float yeve = mod(state.y + 1.0,2.0);\n    return mod(state.x+state.y,2.0); //per IQ, may try FN2's ideas some other day\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XldGzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[40, 40, 97, 97, 694], [696, 696, 736, 813, 1014]]}
{"id": "Xlt3Dn", "name": "[SH16B] Speed tracer", "author": "reinder", "description": "Because there is no character limit anymore, a lot more spheres can be rendered.\nThis shader uses code of the [url=https://www.shadertoy.com/view/MdB3Dw]Analytical Motionblur 3D[/url] shader by Inigo and a grid to trace a lot of spheres.", "tags": ["ray", "blur", "spheres", "motion", "analytic", "trace"], "likes": 75, "viewed": 4006, "date": "1468788417", "time_retrieved": "2024-06-20T18:39:12.176551", "image_code": "// [SH16B] Speed tracer. Created by Reinder Nijhoff 2016\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/Xlt3Dn\n//\n// This shader uses code of the Analytical Motionblur 3D shader by Inego and a grid to trace a lot of spheres.\n//\n\n#define RAYCASTSTEPS 30\n\n#define GRIDSIZE 10.\n#define GRIDSIZESMALL 7.\n#define MAXHEIGHT 30.\n#define SPEED 20.\n#define FPS 30.\n#define MAXDISTANCE 260.\n#define MAXSHADOWDISTANCE 20.\n\n#define time iTime\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//\n// intersection functions\n//\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//\n// intersect a MOVING sphere\n//\n// see: Analytical Motionblur 3D\n//      https://www.shadertoy.com/view/MdB3Dw\n//\n// Created by inigo quilez - iq/2014\n//\nvec2 iSphere( const in vec3 ro, const in vec3 rd, const in vec4 sp, const in vec3 ve, out vec3 nor )\n{\n    float t = -1.0;\n\tfloat s = 0.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat A = dot(rc,rd);\n\tfloat B = dot(rc,rc) - sp.w*sp.w;\n\tfloat C = dot(ve,ve);\n\tfloat D = dot(rc,ve);\n\tfloat E = dot(rd,ve);\n\tfloat aab = A*A - B;\n\tfloat eec = E*E - C;\n\tfloat aed = A*E - D;\n\tfloat k = aed*aed - eec*aab;\n\t\t\n\tif( k>0.0 )\n\t{\n\t\tk = sqrt(k);\n\t\tfloat hb = (aed - k)/eec;\n\t\tfloat ha = (aed + k)/eec;\n\t\t\n\t\tfloat ta = max( 0.0, ha );\n\t\tfloat tb = min( 1.0, hb );\n\t\t\n\t\tif( ta < tb )\n\t\t{\n            ta = 0.5*(ta+tb);\t\t\t\n            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );\n            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );\n            s = 2.0*(tb - ta);\n\t\t}\n\t}\n\n\treturn vec2(t,s);\n}\n\n//\n// Shade\n//\n\nvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\nvec3 shade( const in float d, in vec3 col, const in float shadow, const in vec3 nor, const in vec3 ref, const in vec3 sky) {\n    float amb = max(0., 0.5+0.5*nor.y);\n    float dif = max(0., dot( normalize(nor), lig ) );\n    float spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);\n\n    dif *= shadow;\n\n    vec3 lin = 1.20*dif*vec3(1.00,0.85,0.55);\n    lin += 0.50*amb*vec3(0.50,0.70,1.00);\n    col = col*lin;\n    col += spe*dif;\n    \n    // fog\n    col = mix( col, sky, smoothstep( MAXDISTANCE * .8, MAXDISTANCE, d ) );\n    \n\treturn col;\n}\n\n//\n// Scene\n//\n\nvoid getSphereOffset( const in vec2 grid, inout vec2 center ) {\n\tcenter = (hash22( grid ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\n\nvoid getMovingSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center, inout vec3 speed ) {\n\t// falling?\n\tfloat s = 0.1+hash12( grid );\n    \n\tfloat t = fract(14.*s + time/s*.3);\t\n\tfloat y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\n    \n    speed = vec3(0, s * MAXHEIGHT * ( 8.*t - 4. ), 0 ) * (1./FPS);\n    \n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec4(  offset.x + 0.5*GRIDSIZE, 1. + y, offset.y + 0.5*GRIDSIZE, 1. );\n}\n\nvoid getSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec4( offset.x + 0.5*GRIDSIZE, 1., offset.y + 0.5*GRIDSIZE, 1. );\n}\n\nvec3 getSphereColor( vec2 grid ) {\n\tfloat m = hash12( grid.yx ) * 12.;\n    return vec3(1.-m*0.08, m*0.03, m*0.06);\n}\n\nvec3 render(const in vec3 ro, const in vec3 rd, const in vec3 cameraSpeed, const in mat3 rot ) {\n    vec3 nor, ref, speed;\n    \n\tfloat dist = MAXDISTANCE;\n\t\n\tvec3 sky = clamp( vec3(1,1.5,2.5)*(1.0-0.8*rd.y), vec3(0.), vec3(1.));\n\tvec3 colBackground, sphereSpeed, col = vec3(0.);\n    \n    vec4 sphereCenter;    \n\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n\tvec2 offset;\n    \n\tif( intersectPlane( ro,  rd, 0., dist) ) {\n        vec3 interSectionPoint = ro + rd * dist;\n        \n        \n        // HMMMMM this is totaly fake. Hopefully I have enough time to find the analytic\n        // solution to get a motion blurred checkerboard\n        speed = rot * (interSectionPoint.xyz - ro) + cameraSpeed;   \n        \n        vec2 c1 = mod(interSectionPoint.xz * .25, vec2(2.));\n\t\t\n        float w = (abs( fract(c1.x*abs(rd.x)) -.5 ) + abs( fract(c1.y*abs(rd.y)) -.5 ));        \n\n        colBackground = mix(\n            mod(floor(c1.x) + floor(c1.y), 2.) < 1. ? vec3( 0.4 ) : vec3( .6 ),\n            vec3(.5), clamp( (w + .8) * .007 * length(speed.xz) * FPS , 0., 1.));\n            \n        // calculate shadow\n        float shadow = 0.;\n                \n        vec3 shadowStartPos = interSectionPoint - lig;\n        vec2 shadowGridPos = floor((ro + rd * dist).xz/GRIDSIZE);\n        \n        for( float x=-1.; x<=1.; x++) {\n            for( float y=-1.; y<=1.; y++) {\n                vec2 gridpos = (shadowGridPos+vec2(x,y))*GRIDSIZE;\n                getSphereOffset( gridpos, offset );\n\n                getMovingSpherePosition( gridpos, -offset, sphereCenter, sphereSpeed );\n\n                vec2 res = iSphere( shadowStartPos, lig, sphereCenter, sphereSpeed + cameraSpeed, nor );\n                if( res.x>0.0 )\n                {            \n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\n                }\n\n                getSpherePosition( gridpos, offset, sphereCenter );\n\n                res = iSphere( shadowStartPos, lig, sphereCenter, cameraSpeed, nor );\n                if( res.x>0.0 )\n                {            \n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\n                }\n            }\n        }\n                \n        ref = reflect( rd, vec3( 0., 1., 0. ) );\n        colBackground = shade( dist, colBackground, 1.-shadow, vec3( 0., 1., 0. ), ref, sky );            \n\t} else {\n\t\tcolBackground = sky;\n\t}\t\n\t\t\n\t// trace grid\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\t\t\n    float alpha = 1.;\n    \n\tfor( int i=0; i<RAYCASTSTEPS; i++ )\t{  \n        if( alpha < .01 ) break;\n        \n\t\tgetSphereOffset( pos.xz, offset );\n\t\t\n\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter, sphereSpeed );\n\t\t        \n        speed = rot * (sphereCenter.xyz - ro) + sphereSpeed + cameraSpeed;\n        vec2 res = iSphere( ro, rd, sphereCenter, speed, nor );\n        if( res.x>0.0 )\n        {            \n       \t\tref = reflect( rd, nor );\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\n            col += lcol * res.y * alpha;\n            alpha *= (1.-res.y);\n        }        \n                \n\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n        \n        speed = rot * (sphereCenter.xyz - ro) + cameraSpeed;        \n\t\tres = iSphere( ro, rd, sphereCenter, speed, nor );\n        if( res.x>0.0 )\n        {            \n       \t\tref = reflect( rd, nor );\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\n            col += lcol * res.y * alpha;\n            alpha *= (1.-res.y);\n        }\n        \n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n\t\tpos += mm * rs;\t\t\n\t}\t\n    \n    col += colBackground * alpha;\n    \n\treturn col;\n}\n\nvoid path( in float time, out vec3 ro, out vec3 ta ) {\n\tro = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, 5.6+3.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\n    time += 1.6;\n\tta = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, -.1 + 2.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\n}\n\nmat3 setCamera(in float time, out vec3 ro )\n{\n    vec3 ta;\n    \n    path(time, ro, ta);\n\tfloat roll = -0.15*sin(.732*time);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll), 0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// camera\t\n\tvec3 ro0, ro1, ta;\n    \n    mat3 ca0 = setCamera( time - 1./FPS, ro0 );\n\tvec3 rd0 = ca0 * normalize( vec3(p.xy,2.0) );\n\n    mat3 ca1 = setCamera( time, ro1 );\n\tvec3 rd1 = ca1 * normalize( vec3(p.xy,2.0) );\n\t        \n    mat3 rot = ca1 * mat3( ca0[0].x, ca0[1].x, ca0[2].x,\n                           ca0[0].y, ca0[1].y, ca0[2].y,\n                           ca0[0].z, ca0[1].z, ca0[2].z);\n    \n    rot -= mat3( 1,0,0, 0,1,0, 0,0,1);\n    \n\t// raytrace\t\n\tvec3 col = render(ro0, rd0, ro1-ro0, rot );\n\t\n\tcol = pow( col, vec3(0.5) );\n\t\n\tfragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlt3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[648, 758, 780, 780, 902], [905, 1016, 1037, 1037, 1178], [1180, 1213, 1309, 1309, 1469], [1471, 1628, 1730, 1730, 2439], [2441, 2506, 2630, 2630, 3055], [3057, 3073, 3136, 3136, 3195], [3197, 3197, 3314, 3327, 3647], [3649, 3649, 3742, 3742, 3856], [3858, 3858, 3892, 3892, 3974], [3976, 3976, 4072, 4072, 7755], [7757, 7757, 7811, 7811, 8054], [8056, 8056, 8101, 8101, 8365], [8367, 8367, 8424, 8424, 9098]]}
{"id": "Xlt3R8", "name": "Point Tunnel", "author": "Flyguy", "description": " A 3d point based tunnel effect based off the scene from Second Reality.", "tags": ["3d", "tunnel", "dots", "points", "secondreality"], "likes": 61, "viewed": 2278, "date": "1467931921", "time_retrieved": "2024-06-20T18:39:12.709930", "image_code": "//Constants\n#define TAU 6.2831853071795865\n\n//Parameters\n#define TUNNEL_LAYERS 96\n#define RING_POINTS 128\n#define POINT_SIZE 1.8\n#define POINT_COLOR_A vec3(1.0)\n#define POINT_COLOR_B vec3(0.7)\n#define SPEED 0.7\n\n//Square of x\nfloat sq(float x)\n{\n\treturn x*x;   \n}\n\n//Angular repeat\nvec2 AngRep(vec2 uv, float angle)\n{\n    vec2 polar = vec2(atan(uv.y, uv.x), length(uv));\n    polar.x = mod(polar.x + angle / 2.0, angle) - angle / 2.0; \n\n    return polar.y * vec2(cos(polar.x), sin(polar.x));\n}\n\n//Signed distance to circle\nfloat sdCircle(vec2 uv, float r)\n{\n    return length(uv) - r;\n}\n\n//Mix a shape defined by a distance field 'sd' with a 'target' color using the 'fill' color.\nvec3 MixShape(float sd, vec3 fill, vec3 target)\n{\n    float blend = smoothstep(0.0,1.0/iResolution.y, sd);\n    return mix(fill, target, blend);\n}\n\n//Tunnel/Camera path\nvec2 TunnelPath(float x)\n{\n    vec2 offs = vec2(0, 0);\n    \n    offs.x = 0.2 * sin(TAU * x * 0.5) + 0.4 * sin(TAU * x * 0.2 + 0.3);\n    offs.y = 0.3 * cos(TAU * x * 0.3) + 0.2 * cos(TAU * x * 0.1);\n    \n    offs *= smoothstep(1.0,4.0, x);\n    \n    return offs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= res/2.0;\n    \n    vec3 color = vec3(0);\n    \n    float repAngle = TAU / float(RING_POINTS);\n    float pointSize = POINT_SIZE/2.0/iResolution.y;\n    \n    float camZ = iTime * SPEED;\n    vec2 camOffs = TunnelPath(camZ);\n    \n    for(int i = 1;i <= TUNNEL_LAYERS;i++)\n    {\n        float pz = 1.0 - (float(i) / float(TUNNEL_LAYERS));\n        \n        //Scroll the points towards the screen\n        pz -= mod(camZ, 4.0 / float(TUNNEL_LAYERS));\n        \n        //Layer x/y offset\n        vec2 offs = TunnelPath(camZ + pz) - camOffs;\n        \n        //Radius of the current ring\n        float ringRad = 0.15 * (1.0 / sq(pz * 0.8 + 0.4));\n        \n        //Only draw points when uv is close to the ring.\n        if(abs(length(uv + offs) - ringRad) < pointSize * 1.5) \n        {\n            //Angular repeated uv coords\n            vec2 aruv = AngRep(uv + offs, repAngle);\n\n            //Distance to the nearest point\n            float pdist = sdCircle(aruv - vec2(ringRad, 0), pointSize);\n\n            //Stripes\n            vec3 ptColor = (mod(float(i / 2), 2.0) == 0.0) ? POINT_COLOR_A : POINT_COLOR_B;\n            \n            //Distance fade\n            float shade = (1.0-pz);\n\n            color = MixShape(pdist, ptColor * shade, color);\n        }\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlt3R8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[212, 226, 245, 245, 263], [265, 282, 317, 317, 492], [494, 522, 556, 556, 585], [587, 680, 729, 729, 825], [827, 848, 874, 874, 1110], [1112, 1112, 1169, 1169, 2565]]}
{"id": "XltGRM", "name": "[SH16B] Aerobatics", "author": "dr2", "description": "Gut-wrenching - only for the brave", "tags": ["speed", "flight", "sh16b"], "likes": 14, "viewed": 787, "date": "1468521281", "time_retrieved": "2024-06-20T18:39:12.728172", "image_code": "// \"[SH16B] Aerobatics\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nvec2 Rot2D (vec2 q, float a);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\n\n#define N_FLYER 2\n#define N_PSEG 12\n\nint idObj, idFlmGrp;\nmat3 flyerMat[N_FLYER], flMat;\nvec3 flyerPos[N_FLYER], cPt[N_PSEG], cPtOrg, cUpCirc, cDnCirc, flPos, qHit, qHitFlm,\n   sunDir, flmCylPos;\nfloat tLen[N_PSEG], hTop, rLoop, sHzRamp, rCirc, sDnRamp, sUpRamp, sHzStr, vfLoop,\n   dstFar, tCur, fusLen, flmCylRad, flmCylLen, vFly, ptFac;\nconst float pi = 3.14159;\nconst int npSeg = N_PSEG;\nconst int idCkp = 11, idFus = 12, idEngO = 13, idEngI = 14, idWngI = 15,\n   idWngO = 16, idTlf = 17, idRng = 18;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float f;\n  if (rd.y >= 0.) {\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - rd.y, 8.) +\n       0.35 * pow (max (dot (rd, sunDir), 0.), 6.);\n    col = mix (col, vec3 (0.9), clamp (0.1 + 0.8 * rd.y *\n       Fbm2 (5. * rd.xz / max (rd.y, 0.001)), 0., 1.));\n  } else {\n    ro -= rd * ro.y / rd.y;\n    w = 0.5 * ro.xz;\n    f = Fbm2 (w);\n    e = vec2 (0.01, 0.);\n    vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.1, f - Fbm2 (w + e.yx)));\n    col = mix (vec3 (0.4, 0.5, 0.2), vec3 (0.35, 0.3, 0.1), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  }\n  return col;\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin, r;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) - flmCylPos;\n    r = flmCylRad * (0.6 + 0.4 * q.z / flmCylLen);\n    d = PrCylDf (q, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = q;  idFlmGrp = k; }\n    q.x += 2. * flmCylPos.x;\n    d = PrCylDf (q, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = q;  idFlmGrp = k; }\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = FlmDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 pp, q;\n  float d, wr, ws;\n  q = p;\n  q.yz = Rot2D (q.yz, 0.07 * pi);\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.05, 0.), 0.11 * fusLen, 0.1 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idCkp;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0., -0.12);\n  wr = -0.05 + q.z / fusLen;\n  q.xz *= 0.8;\n  d = PrCapsDf (q, (0.14 - 0.14 * wr * wr) * fusLen, fusLen);\n  if (d < dMin + 0.01 * fusLen) {\n    dMin = SmoothMin (dMin, d, 0.01 * fusLen);  idObj = idFus;  qHit = q;\n  }\n  pp = p;\n  pp.x = abs (pp.x);\n  q = pp - fusLen * vec3 (0.5, 0., -0.25);\n  ws = q.z / (0.4 * fusLen);\n  wr = ws - 0.1;\n  d = max (PrCylDf (q, (0.09 - 0.05 * wr * wr) * fusLen, 0.35 * fusLen),\n     - PrCylDf (q, 0.05 * fusLen, 0.36 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngO;  qHit = q; }\n  d = min (PrCylDf (q, (0.04 - 0.038 * ws * ws) * fusLen, 0.38 * fusLen),\n     PrCylDf (q - vec3 (0., 0., 0.03 * fusLen), 0.05 * fusLen, 0.28 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngI;  qHit = q; }\n  q = pp - fusLen * vec3 (0.1, 0., -0.15);\n  q.xz = Rot2D (q.xz, 0.12 * pi);\n  wr = 1. - 0.6 * q.x / (0.4 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.25 * wr * fusLen, 0.02 * wr * fusLen, 0.4 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idWngI;  qHit = q; }\n  q = pp - fusLen * vec3 (0.6, 0., -0.37);\n  q.xy = Rot2D (q.xy, -0.1 * pi);\n  q -= fusLen * vec3 (0.07, 0.01, 0.);\n  q.xz = Rot2D (q.xz, 0.14 * pi);\n  wr = 1. - 0.8 * q.x / (0.2 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.06 * wr * fusLen, 0.005 * wr * fusLen, 0.2 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idWngO;  qHit = q; }\n  q = pp - fusLen * vec3 (0.03, 0., -0.85);\n  q.xy = Rot2D (q.xy, -0.24 * pi);\n  q -= fusLen * vec3 (0.2, 0.02, 0.);\n  wr = 1. - 0.5 * q.x / (0.17 * fusLen);\n  q.xz = Rot2D (q.xz, 0.1 * pi);\n  d = PrFlatCylDf (q.zyx, 0.1 * wr * fusLen, 0.007 * wr * fusLen, 0.17 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idTlf;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++)\n     dMin = FlyerDf (flyerMat[k] * (p - flyerPos[k]), dMin);\n  dMin *= 0.8;\n  q = p - ptFac * 0.5 * (cPt[0] + cPt[1]);\n  q.y -= 1.5;\n  d = max (PrTorusDf (q, 0.2, 3.), - p.y);\n  if (d < dMin) { dMin = d;  idObj = idRng; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  if (d >= 0.0002) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 FlyerCol ()\n{\n  vec3 qq, qqr, col;\n  float spec, br;\n  spec = 1.;\n  qq = qHit / fusLen;\n  br = 0.4 + 0.6 * abs (cos (3. * tCur));\n  col = vec3 (0.7, 0.7, 1.);\n  if (qq.y > 0.) col *= 0.5;\n  else col *= 1.2;\n  if (idObj == idTlf) {\n    qqr.xz = Rot2D (qq.xz, -0.1 * pi);\n    if (abs (qqr.x) < 0.08)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qqr.z + 0.06);\n    if (qqr.z < - 0.06)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001, abs (qqr.x) - 0.08);\n  } else if (idObj == idWngI) {\n    qqr.xz = Rot2D (qq.xz, -0.12 * pi);\n    if (abs (qqr.x) > 0.1 && abs (qqr.x) < 0.28)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qqr.z + 0.19);\n    if (qqr.z < - 0.19)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001, abs (abs (qqr.x) - 0.19) - 0.09);\n  } else if (idObj == idCkp && qq.z > 0.05) {\n    col = vec3 (0.4, 0.2, 0.1);\n  } else if (idObj == idEngO) {\n    if (qq.z > 0.34) {\n      col = vec3 (0.8, 0.8, 1.);\n    } else if (qq.z < -0.2 && length (qq.xy) < 0.05) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    }\n  } else if (idObj == idEngI) {\n    if (qq.z > 0.36) col = vec3 (1., 0., 0.);\n    else if (qq.z < 0.) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    } else {\n      col = vec3 (0.01);\n    }\n  }\n  if (idObj == idWngO && qq.x > 0.17 ||\n     idObj == idTlf && qq.x > 0.15 && qq.z < -0.03) {\n    col = vec3 (1., 0., 0.) * br;\n    spec = -1.;\n  } else if (idObj == idFus && qq.z > 0.81) {\n    col = vec3 (0., 1., 0.) * br;\n    spec = -1.;\n  }\n  return vec4 (col, spec);\n}\n\nfloat FlmAmp (vec3 p, vec3 rd)\n{\n  vec3 dp, q;\n  float g, s, fr, fz;\n  dp = (2. * flmCylRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    s = length (p.xy);\n    if (s > flmCylRad || g > 10.) break;\n    fr = max (1. - s / flmCylRad, 0.);\n    fz = 0.6 + 0.4 * p.z / flmCylLen;\n    q = 5. * p / fusLen;\n    g += fr * fz * Noisefv3 (vec3 (q.xy, q.z +\n       50. * (1. - 0.5 * fr) * (100. + tCur)));\n  }\n  return min (0.15 * g, 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn;\n  float dstHit, dstFlm, aFlm;\n  int idObjT;\n  flmCylRad = 0.051 * fusLen;\n  flmCylLen = 0.25 * fusLen;\n  flmCylPos = vec3 (0.5 * fusLen, 0., -0.55 * fusLen - flmCylLen);\n  dstFlm = FlmRay (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj != idRng) objCol = FlyerCol ();\n    else objCol = vec4 (1., 0.2, 0.2, 1.);\n    if (objCol.a >= 0.) {\n      col = objCol.rgb * (0.2 + 0.8 * (max (dot (vn, sunDir), 0.) +\n         objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n      if (idObj != idRng) col = 0.8 * col + 0.2 * BgCol (ro, reflect (rd, vn));\n    } else col = objCol.rgb;\n  } else col = BgCol (ro, rd);\n  if (dstFlm < min (dstFar, dstHit)) {\n    aFlm = FlmAmp (qHitFlm, ((idFlmGrp == 0) ? flyerMat[0] : flyerMat[1]) * rd);\n    col = mix (col, mix (vec3 (1., 0.2, 0.2),\n       vec3 (1., 1., 0.7), 0.8 * aFlm), aFlm);\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid PathSetup ()\n{\n  vec4 uVec = vec4 (1., 1., 1., 0.);\n  ptFac = 20.;\n  cPtOrg = vec3 (2., 0., -3.);\n  hTop = 1.5;\n  rLoop = 2.2;\n  sHzRamp = 1.;\n  rCirc = 2.;\n  sDnRamp = 1.5;\n  sUpRamp = 1.3 * sDnRamp;\n  sHzStr = sDnRamp - sUpRamp + 3. * sHzRamp;\n  vfLoop = 0.3;\n  cDnCirc = cPtOrg + vec3 (- rCirc, 0., -2. * sHzRamp);\n  cUpCirc = cPtOrg + vec3 (- rCirc, 2. * hTop, 2. * sDnRamp + 6. * sHzRamp);\n  cPt[0] = cDnCirc + vec3 (- rCirc, 0., sHzStr);\n  cPt[1] = cPt[0] + sHzStr * uVec.wwz;\n  cPt[3] = cUpCirc - rCirc * uVec.xww;\n  cPt[4] = cUpCirc + rCirc * uVec.xww;\n  cPt[2] = cPt[3] - 2. * sHzRamp * uVec.wwz;\n  cPt[5] = cPt[4] - 2. * sHzRamp * uVec.wwz;\n  cPt[7] = cPtOrg;\n  cPt[8] = cPtOrg;\n  cPt[6] = cPt[7] + 4. * sHzRamp * uVec.wwz;\n  cPt[9] = cDnCirc + rCirc * uVec.xww;\n  cPt[10] = cDnCirc - rCirc * uVec.xww;\n  cPt[11] = cPt[0];\n  tLen[0] = 0.;\n  for (int k = 1; k < npSeg; k ++) tLen[k] = length (cPt[k] - cPt[k - 1]);\n  tLen[4] = pi * rCirc;\n  tLen[8] = length (vec2 (2. * pi * rLoop, 0.)) * (1. + vfLoop);\n  tLen[10] = pi * rCirc;\n  for (int k = 1; k < npSeg; k ++) tLen[k] += tLen[k - 1];\n}\n\nvec3 PathLoc (float t, out vec3 oDir, out vec3 oNorm, out float oRl)\n{\n  vec3 p, p1, p2, u;\n  float w, ft, s, h;\n  int ik;\n  h = 2. * sin (0.43 * pi * t) + sin (0.79 * pi * t);\n  oRl = 0.01 * pi * h;\n  t = mod (t, tLen[npSeg - 1]);\n  for (int k = 1; k < npSeg; k ++) {\n    if (t < tLen[k]) {\n      t -= tLen[k - 1];\n      p1 = cPt[k - 1];\n      p2 = cPt[k];\n      w = tLen[k] - tLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  oNorm = vec3 (0., 1., 0.);\n  ft = t / w;\n  if (ik == 4 || ik == 10) oRl += -0.25 * pi * SmoothBump (0.05, 0.95, 0.05, ft);\n  if (ik == 4) oRl += 2. * pi * smoothstep (0.4, 0.6, ft);\n  if (ik == 2 || ik == 6) {\n    oDir = p2 - p1;\n    p.xz = p1.xz + oDir.xz * ft;\n    p.y = p1.y + oDir.y * smoothstep (0., 1., ft);\n    oDir.y *= 6. * ft * (1. - ft);\n    oDir = normalize (oDir);\n  } else if (ik == 4) {\n    ft *= pi;\n    p = cUpCirc;\n    u = vec3 (- cos (ft), 0., sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n  } else if (ik == 8) {\n    ft = (ft < 0.5) ? ft * (1. + vfLoop * (1. - 2. * ft)) :\n       ft * (1. + 2. * vfLoop * (ft - 1.5)) + vfLoop;\n    p = 0.5 * (cPt[7] + cPt[8]);\n    ft *= 2. * pi;\n    u = vec3 (0., cos (ft), sin (ft));\n    p.yz += rLoop * (vec2 (1., 0.) - u.yz);\n    oNorm = u;\n    oDir = normalize (vec3 (0., 2. * pi * rLoop * vec2 (sin (ft), - cos (ft))));\n  } else if (ik == 10) {\n    ft *= pi;\n    p = cDnCirc;\n    u = vec3 (cos (ft), 0., - sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n  } else {\n    oDir = p2 - p1;\n    p = p1 + oDir * ft;\n    oDir = normalize (oDir);\n  }\n  p *= ptFac;\n  p.y += 2. + 0.1 * h;\n  return p;\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 oDir, oNorm;\n  float oRl, c, s;\n  flPos = PathLoc (t, oDir, oNorm, oRl);\n  if (vu > 0.) {\n    oDir *= -1.;\n    oRl *= -1.;\n  }\n  flMat = AxToRMat (oDir, oNorm);\n  c = cos (oRl);\n  s = sin (oRl);\n  flMat = mat3 (c, - s, 0., s, c, 0., 0., 0., 1.) * AxToRMat (oDir, oNorm);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  vec2 canvas, uv, ut, mMid, mSize;\n  float dVu, f, pDist;\n  bool sWin;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 5.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  PathSetup ();\n  fusLen = 1.;\n  vFly = 1.;\n  FlyerPM (vFly * tCur, 0.);        flyerPos[0] = flPos;  flyerMat[0] = flMat;\n  FlyerPM (vFly * tCur + 0.5, 0.);  flyerPos[1] = flPos;  flyerMat[1] = flMat;\n  mMid = vec2 (-0.67, 0.65) * vec2 (canvas.x / canvas.y, 1.);\n  mSize = 0.3 * vec2 (canvas.x / canvas.y, 1.);\n  ut = abs (uv - mMid) - mSize;\n  sWin = (max (ut.x, ut.y) < 0.);\n  if (sWin) {\n    ro = vec3 (0., 5., 0.);\n    vd = 0.5 * (flyerPos[0] + flyerPos[1]) - ro;\n    pDist = length (vd);\n    vd = normalize (vd);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (vec3 ((uv - mMid) / mSize.x, 2. + 5. * pDist / 50.));\n    dstFar = 200.;\n  } else {\n    dVu = - 1.;\n    if (false) dVu += 2. * SmoothBump (0.25, 0.75, 0.05, mod (tCur / 30., 1.));\n    FlyerPM (vFly * tCur + (0.25 + 0.6 * dVu), dVu);\n    ro = flPos + flMat * vec3 (0., 0.8 * fusLen, 0.);\n    rd = normalize (vec3 (uv, 3.)) * flMat;\n    dstFar = 100.;\n  }\n  ut = abs (ut);\n  fragColor = vec4 (((sWin && min (ut.x, ut.y) * canvas.y < 2.) ?\n     vec3 (0.3, 0.5, 0.2) : ShowScene (ro, rd)), 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vz = normalize (vz);\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y),\n     vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltGRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1098, 1129, 1129, 1842], [1844, 1844, 1866, 1866, 2298], [2300, 2300, 2333, 2333, 2542], [2544, 2544, 2580, 2580, 4499], [4501, 4501, 4523, 4523, 4843], [4845, 4845, 4878, 4878, 5089], [5091, 5091, 5112, 5112, 5325], [5327, 5327, 5345, 5345, 6849], [6851, 6851, 6883, 6883, 7308], [7310, 7310, 7345, 7345, 8389], [8391, 8391, 8410, 8410, 9494], [9496, 9496, 9566, 9566, 11114], [11116, 11116, 11150, 11150, 11430], [11432, 11432, 11488, 11488, 12949], [12951, 12951, 12994, 12994, 13067], [13069, 13069, 13111, 13111, 13162], [13164, 13164, 13223, 13223, 13327], [13329, 13329, 13375, 13375, 13432], [13434, 13434, 13468, 13468, 13658], [13660, 13660, 13690, 13690, 13748], [13750, 13750, 13795, 13795, 13898], [13900, 13900, 13957, 13957, 14040], [14163, 14163, 14187, 14187, 14234], [14236, 14236, 14261, 14261, 14460], [14462, 14462, 14487, 14487, 14831], [14833, 14833, 14854, 14854, 14993], [14995, 14995, 15024, 15024, 15236], [15238, 15238, 15277, 15277, 15500]]}
{"id": "XltGz7", "name": "Particle v3", "author": "thecodewarrior", "description": "A magic sparkle", "tags": ["particle"], "likes": 1, "viewed": 142, "date": "1468446203", "time_retrieved": "2024-06-20T18:39:12.728172", "image_code": "#define COUNT 15\n\nvec4 glColor = vec4(1, 0.5, 0, 0.75);\nvec4 foreground = vec4(1, 1, 1, 1);\nvec4 centerColor = vec4(0, 1, 1, 1);\n\nfloat backgroundFade = 5.;\nfloat lengthRandomness = 0.4;\nfloat centerRadius = 0.05;\n\nfloat rand(int n){return fract(sin(float(n)) * 43758.5453123);}\n\nvec4 godSparkleSimple( vec2 uv )\n{\n    vec4 color = vec4(0, 0, 0, 0);\n    \n    float len = sqrt( uv.x * uv.x + uv.y * uv.y );\n    vec2 check = vec2(0, 1);\n    \n    float dotP = check.x*uv.x + check.y*uv.y;\n\tfloat detP = check.x*uv.y - check.y*uv.x;\n    \n    float angle = degrees(atan(detP, dotP));\n    angle += 180.;\n    \n    int randID = 0;\n    \n    for(int i = 0; i < COUNT; i++) {\n        float startAngle = 360. * rand(randID++);\n        float angleWidth = 360. / float( int( 3. + rand(randID++) * 5. )*2);\n        float speed = 200. * ( rand(randID++) - 0.5 );\n        \n        startAngle += speed * iTime;\n        \n        float checkAngle = angle - startAngle;\n        \n        checkAngle = mod(checkAngle, angleWidth*2.);\n        float anglePercent = (checkAngle/angleWidth - 0.5)*2.;\n        \n        float dist = 0.6-lengthRandomness\n            +( lengthRandomness * rand(randID++)    );\n        float distPercent = len/dist;\n        \n        float w = glColor.w\n            *( 1.-( distPercent+0.1*rand(int(checkAngle)))    /**/)\n            *( 1.-clamp(pow(anglePercent, backgroundFade*2.), 0., 1.)    /**/)\n        ;\n        float centerW = clamp(10.*centerRadius-len*10., 0., 1.);\n        \n        float foreW = foreground.w\n            *clamp(1.-len*2., 0., 1.)\n        ;\n        \n        vec4 ourColor = mix(glColor, foreground, clamp(foreW, 0., 1.));\n        ourColor = mix(ourColor, centerColor, centerW);\n        \n        ourColor.w = max( centerW, w );\n        color = mix(color, ourColor, ourColor.w);\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = min(iResolution.x, iResolution.y);\n    float maxsize = max(iResolution.x, iResolution.y);\n    \n    vec2 offset = vec2(0);\n    float offsetAmount = ((maxsize-size)/2. )/size;\n    \n    if(iResolution.x > iResolution.y)\n        offset.x = offsetAmount;\n    if(iResolution.y > iResolution.x)\n        offset.y = offsetAmount;\n    \n    vec2 uv = fragCoord.xy/size;\n    uv -= offset;\n    \n    if(uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.)\n    {\n        fragColor = vec4(1, 0, 1, 1);\n    } else {\n        uv = uv - vec2(0.5);\n        fragColor = godSparkleSimple(uv);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XltGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[215, 215, 233, 233, 278], [280, 280, 314, 314, 1835], [1839, 1839, 1896, 1896, 2488]]}
{"id": "Xt33DH", "name": "Mirror Ball in Hallway", "author": "geoff", "description": "Mirror ball in a hall of other spheres. ", "tags": ["spheretracing"], "likes": 3, "viewed": 582, "date": "1468962857", "time_retrieved": "2024-06-20T18:39:12.735117", "image_code": "#define MAX_BOUNCE 1\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nfloat closeObj = 0.0;\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\nvec2 mapMat(vec3 p){\n    vec3 q = vec3(p.x, p.y, mod(p.z, 3.0) - 1.5);\n    vec3 r = vec3(q.x - 1.5, q.y, q.z);\n    vec3 s = vec3(q.x + 1.5, q.y, q.z);\n    \n    vec2 spha = vec2(length(r) - 1.0, 1.0);\n    vec2 sphb = vec2(length(s) - 1.0, 1.0);\n    vec2 sphm = vec2(length(p - vec3(0.0, 1.75, iTime + 3.0)) - 1.0, 3.0);\n    vec2 bPlane = vec2(p.y + 1.0, 2.0);\n    vec2 rPlane = vec2(p.x + 3.0, 4.0);\n    vec2 lPlane = vec2(-p.x + 3.0, 4.0);\n    vec2 tPlane = vec2(-p.y + 4.0, 2.0);\n    \n    return vecMin(tPlane, vecMin(lPlane, vecMin(rPlane, vecMin(bPlane, vecMin(sphm, vecMin(spha, sphb))))));\n}\n\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    float d = 0.0;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 1000; i++){\n        c = mapMat(ro + rd * t);\n        d = c.x;\n        if(d < 0.0001){\n            inter = 1;\n            break;\n        }\n        t += d;\n        if(t > 25.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        t = -1.0;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(0.0, 1.0, 0.0);\nvec3 lightPos = vec3(0.0, 1.0, -1.0);\n\nvec3 amb(vec3 c, float k){\n    return c * k;\n}\n\nvec3 diff(vec3 c, float k, vec3 p){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    return c * k * max(0.0, dot(n, l));\n}\n\nvec3 spec(vec3 c, float k, vec3 p, float a){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(p - camPos);\n    float facing = dot(l, n) > 0.0 ? 1.0 : 0.0;\n    vec3 r = reflect(l, n);\n    return c * k * facing * pow(max(0.0, dot(r, v)), a);\n}\n\nvec3 colour(vec3 p, float id){\n    if(id == 1.0){\n        vec3 col = vec3(1.0, 0.0, 0.0);\n        return amb(col, 0.5) + diff(col, 0.7, p) + spec(vec3(1.0), 0.75, p, 16.0);\n    }\n    if(id == 2.0){\n        vec3 col = vec3(mod(ceil(p.xz), 2.0) == vec2(0.0) || mod(ceil(p.xz), 2.0) == vec2(1.0) ? 0.8 : 0.4);\n        return amb(col, 0.5) + diff(col, 0.8, p) + spec(vec3(1.0), 0.25, p, 8.0);\n    }\n    vec3 col = vec3(mod(ceil(p.zy), 2.0) == vec2(0.0) || mod(ceil(p.zy), 2.0) == vec2(1.0) ? 0.8 : 0.4);\n    return amb(col, 0.5) + diff(col, 0.8, p) + spec(vec3(1.0), 0.25, p, 8.0);\n} \n\nfloat shadow(vec3 ro, vec3 rd){\n    float t = 0.005;\n    float d = 0.0;\n    float shadow = 1.0;\n    for(int iter = 0; iter < 1000; iter++){\n        d = map(ro + rd * t);\n        if(d < 0.0001){\n            return 0.0;\n        }\n        if(t > length(ro - lightPos) - 0.5){\n            break;\n        }\n        shadow = min(shadow, 128.0 * d / t);\n        t += d;\n    }\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    camPos = vec3(0.0, 1.0, iTime);\n    lightPos = vec3(0.5 * sin(iTime), 1.0, iTime + 0.5);\n    vec3 ro = camPos;\n    vec3 rd = normalize(rotX(radians(-10.0)) * vec3(uv, 1.0));\n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(1.0);\n    //If intersected\n    if(d > 0.0){\n        //If mirror\n        if(closeObj == 3.0){\n            //Reflect ray\n            for(int i = 0; i < MAX_BOUNCE; i++){\n                vec3 n = normal(c);\n                vec3 l = c - lightPos;\n                vec3 rr = reflect(l, n);\n                d = trace(c + rr * 0.0005, rr);\n                if(d == -1.0){\n                    break;\n                }\n                c = c + rr * d;\n                if(closeObj == 3.0){\n                    continue;\n                }\n                break;\n            }\n            //If reflection did not intersect\n            if(d == -1.0){\n                col = vec3(0.0);\n            }else if(closeObj == 3.0){\n                col = vec3(1.0);\n                vec3 n = normal(c);\n                vec3 l = normalize(c - lightPos);\n                col *= max(0.0, dot(n, l));\n                col += vec3(0.25);\n      \t\t//Colour objects in mirror\n            }else{\n                col = colour(c, closeObj);\n                //float s = shadow(c, normalize(lightPos - c)); //Enable shadows in mirrored world\n            \tcol -= vec3(0.15);\n            }\n        //Colour ray\n        }else{\n            col = colour(c, closeObj);\n            float s = shadow(c, normalize(lightPos - c));\n            col -= vec3(0.5 - 0.5 * s);\n        }\n        //Fog\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt33DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[22, 22, 41, 41, 182], [184, 184, 203, 203, 344], [369, 369, 397, 397, 457], [459, 459, 479, 479, 1055], [1057, 1057, 1075, 1075, 1101], [1103, 1103, 1133, 1133, 1516], [1518, 1518, 1538, 1538, 1814], [1890, 1890, 1916, 1916, 1936], [1938, 1938, 1973, 1973, 2077], [2079, 2079, 2123, 2123, 2356], [2358, 2358, 2388, 2388, 2937], [2940, 2940, 2971, 2971, 3329], [3331, 3331, 3387, 3387, 5198]]}
{"id": "Xt3GD8", "name": "MappingFunctionTestShader", "author": "Jwebb4191", "description": "Shader to demonstrate some wave functions", "tags": ["sin"], "likes": 0, "viewed": 78, "date": "1468955997", "time_retrieved": "2024-06-20T18:39:12.736114", "image_code": "// !!!! Don't change this, bad !!!!\n#define PI 3.14159\n\n\n\n\n// Change this to increase frequency of function\n#define FREQUENCY 2.0\n\n// Change this to increase how quickly we scroll\n#define TIME_SCALE 2.0\n\n// Change this to incease how broad the stroke is\n#define RANGE 0.5\n\n// Set which function you want to use to 1\n#define USE_COS 1\n#define USE_SIN 0\n#define USE_TAN 0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * TIME_SCALE;\n    \n   \tfloat x = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float y = (fragCoord.y / iResolution.y) * 2.0 - 1.0;\n    \n#if USE_COS == 1\n    float val = cos(x * PI * FREQUENCY + time);\n#elif USE_SIN == 1\n    float val = sin(x * PI * FREQUENCY + time);\n#elif USE_TAN == 1\n    float val = tan(x * PI * FREQUENCY + time);\n#endif\n    \n    vec2 idealPosition = vec2(x, val);\n    vec2 currentPosition = vec2(x, y);\n    \n    float dist = distance(idealPosition, currentPosition);\n    \n    float color = mix(0.0, 1.0, max(0.0, RANGE - dist) / RANGE);\n\n    fragColor = vec4(color, 0, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3GD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[273, 373, 430, 430, 1055]]}
{"id": "Xt3GRM", "name": "Hall of CSG and AO", "author": "geoff", "description": "A field of cube - spheres. Only shading is ambient occlusion and an exponential fog.", "tags": ["csg", "spheretracing"], "likes": 6, "viewed": 737, "date": "1468274845", "time_retrieved": "2024-06-20T18:39:12.736114", "image_code": "#define MAX_ITER 1000\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define AO_SAMPLES 25\n#define AO_STRENGTH 1.0\n\nvec3 camPos = vec3(0.0, 0.5, iTime * 2.0);\n\nfloat map(vec3 p){\n    vec3 q = vec3(mod(p.x, 8.0) - 4.0, p.y, mod(p.z, 8.0) - 4.0);\n    float cube = length(max(abs(q) - 2.0,0.0));\n    float sphere = length(q) - 2.5;\n    return min(-p.y + 2.0, min(p.y + 2.0, max(-sphere, cube)));\n}\n\nfloat trace(vec3 ro, vec3 rd){\n \tfloat t = 0.0;\n    float d = 0.0;\n    for(int iter = 0; iter < MAX_ITER; iter++){\n        d = map(ro + rd * t);\n        if(d < EPSILON){\n            break;\n        }\n        if(t > MAX_DIST){\n        \tt = 0.0;\n            break;\n    \t}\n        t += d;\n    }\n    return t;\n}\n\n\nmat3 rotY(float d){\n    float c = cos(d);\n    float s = sin(d);\n    \n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c);\n}\n\nvec3 normal(vec3 p){\n    return vec3(map(vec3(p.x + EPSILON, p.yz)) - map(vec3(p.x - EPSILON, p.yz)),\n                map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n                map(vec3(p.xy, p.z + EPSILON)) - map(vec3(p.xy, p.z - EPSILON)));\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(AO_STRENGTH * occ, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd *= rotY(iTime / 3.0);\n    float d = trace(ro, rd);\n    vec3 col;\n    if(d == 0.0){\n        col = vec3(0.0);\n    }else{\n        vec3 x = ro + (rd * d);\n        vec3 n = normalize(normal(x)); \n        col = vec3(occlusion(x, n));\n        col *= vec3(1.0 / exp(d * 0.08));\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3GRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[159, 159, 177, 177, 393], [395, 395, 425, 425, 701], [704, 704, 723, 723, 868], [870, 870, 890, 890, 1144], [1146, 1146, 1180, 1180, 1445], [1447, 1447, 1504, 1504, 1992]]}
{"id": "Xt3GzS", "name": "World Sphere", "author": "kig", "description": "Visual prototyping for a VR demo", "tags": ["raytracing", "raymarching", "csg", "prototyping"], "likes": 5, "viewed": 259, "date": "1469866863", "time_retrieved": "2024-06-20T18:39:15.516194", "image_code": "const float AA_SIZE = 2.0;\n\nconst int RAY_STEPS = 60;\nconst float THRESHOLD = 0.001;\nconst float MAX_DISTANCE = 100.0;\n\n\nstruct material {\n    vec3 transmit;\n    vec3 emission;\n};\n    \nstruct csgHit {\n    float closest;\n    vec3 closestNormal;\n    float furthest;\n    vec3 furthestNormal;\n    material mat;\n};\n\nvec2 phaseVec(float t){\n    float phase = t*0.7/3.14159;\n    float pt = fract(phase);\n    phase = mod(floor(phase), 3.0);\n    return vec2(phase, pt);\n}\n\nfloat lightPhase(float t) {\n    vec2 phase = phaseVec(t);\n    float f = 0.0;\n    if (phase.x == 2.0 && phase.y > 0.5) {\n        f = pow(2.0 * (phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        f = pow(2.0*(0.5-phase.y), 1.5);\n    }\n    return f;\n}\n\nvec3 bgLight() {\n    return normalize(vec3(\n        0.0,\n        -lightPhase(iTime)-0.1, \n        1.0\n    ));\n}\n\n#define TEXTURE_NOISE 1\n#ifdef TEXTURE_NOISE\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Old map\nfloat map( in vec3 p )\n{\n\tvec3 q = p + 0.2*vec3(-1.0, 1.0, 2.2)*iTime;\n\tfloat f;\n    f = 0.500*noise( q ); q = q*2.0;\n    f += 0.25*noise( q ); q = q*2.0;\n    f += 0.125*noise( q ); q = q*2.0;\n    //f += 0.0625*noise( q ); q = q*2.0;\n    //f += 0.03125*noise( q ); q = q*2.0;\n    //f += 0.015625*noise( q );\n\treturn f;\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = lightPhase(iTime) * vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight());\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += lightPhase(iTime) * vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight().y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\n    vec2 phase = phaseVec(iTime);\n    float cloudF = max(0.0, phase.x - 1.0);\n    if (phase.x == 1.0 && phase.y > 0.5) {\n        cloudF = pow(2.0*(phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        cloudF = pow(2.0*(0.5-phase.y), 2.0);\n    }\n\n    float cloudFac = pow(max(0.0, bgDiff), 0.8)*1.0;\n    float ufCloudCover = cloudF * 0.5;\n    float cc = pow(ufCloudCover, 1.25) * 1.5;\n    float cloud = 0.0;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n    \n\n\n// Old scene, keep this!\nfloat scene(vec3 p, float phase, float pt)\n{\n    float f = min(1.0, phase + pow(2.0 * abs(pt - 0.5), 3.0));\n\treturn pow(map(p/20.0), 3.0)*-min(pow(0.05*length(p.xz), 7.0), f*120.0)+7.0+p.y*p.y;\n}\n\n#else \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\n// By NIMITZ  (twitter: @stormoid)\n// good god that dudes a genius...\n\nfloat tri( float x ){ \n  return abs( fract(x) - .5 );\n}\n\nvec3 tri3( vec3 p ){\n \n  return vec3( \n      tri( p.z + tri( p.y * 1. ) ), \n      tri( p.z + tri( p.x * 1. ) ), \n      tri( p.y + tri( p.x * 1. ) )\n  );\n\n}\n                                 \nfloat triNoise3D( vec3 p, float spd, float time){\n  \n\tfloat z  = 1.4;\n\tfloat rz =  0.;\n\tvec3  bp =   p;\n\n\tfor( float i = 0.; i <= 3.; i++ ){\n   \n    vec3 dg = tri3( bp * 2. );\n    p += ( dg + time * .1 * spd );\n\n    bp *= 1.8;\n\t\tz  *= 1.5;\n\t\tp  *= 1.2; \n      \n    float t = tri( p.z + tri( p.x + tri( p.y )));\n    rz += t / z;\n    bp += 0.14;\n\n\t}\n\n\treturn rz;\n\n}\n\nfloat map( in vec3 p, in vec3 offset )\n{\n\tfloat f;\n    vec3 q = (p + offset);\n    f = 1.75 * triNoise3D( 0.05 * q, 1.0, 0. );\n\treturn f;\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = lightPhase(iTime) * vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight());\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += lightPhase(iTime) * vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight().y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\n    vec2 phase = phaseVec(iTime);\n    float cloudF = max(0.0, phase.x - 1.0);\n    if (phase.x == 1.0 && phase.y > 0.5) {\n        cloudF = pow(2.0*(phase.y - 0.5), 2.5);\n    }\n    if (phase.x == 0.0 && phase.y < 0.5) {\n        cloudF = pow(2.0*(0.5-phase.y), 2.0);\n    }\n\n    float cloudFac = pow(max(0.0, bgDiff), 0.8)*1.0;\n\n    float ufCloudCover = cloudF * 0.5;\n    float cc = pow(ufCloudCover, 1.25) * 1.5;\n\n    float cloud = 0.0;\n    vec3 offset = 0.2*vec3(-1.0, 1.0, 2.2)*iTime;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y, offset)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y, offset)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y, offset)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat scene(vec3 p, float phase, float pt)\n{\n    float f = min(1.0, phase + pow(2.0 * abs(pt - 0.5), 3.0));\n    p.x = abs(p.x);\n\treturn pow(map(p/20.0, vec3(9.5)), 3.0)*-f*19.0+9.0+p.y*p.y;\n}\n\n#endif\n    \nfloat sphereDet(vec3 ray, vec3 dir, vec3 center, float radius, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\ncsgHit sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, material m)\n{\n\tfloat b;\n\tfloat d = sphereDet(ray, dir, center, radius, b); // 7\n\tif (d < 0.0) { // 1\n        return csgHit(closestHit, vec3(0.0), closestHit, vec3(0.0), m);\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\n    vec3 nmlNear = center - (ray+dir*t);\n    vec3 nmlFar = (ray+dir*(t+2.0*sqrt(d))) - center;\n    return csgHit(t, nmlNear, t + 2.0*sqrt(d), nmlFar, m);\n}\n\n\nfloat triangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, float closestHit, material m, inout vec3 nml, inout material dst, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn closestHit;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\t\n    if (t > closestHit || t <= 0.00001 || (a > -0.00001 && a < 0.00001)) {\n        return closestHit;\n    }\n    \n    nml = normalize(cross(e1, e2));\n    if (dot(nml, d) < 0.0) {\n        nml = -nml;\n    }\n    dst = m;\n\tuv = vec2(u,v);\n\n    return t;\n}\n\n\nfloat plane(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat pd = dot(pnml, rd);\n\tfloat dist = dot(pnml, p-rp) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat disk(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float r1, float r2, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tvec3 tmp;\n    material tmpMat;\n\tfloat dist = plane(rp, rd, p, pnml, closestHit, m, tmp, tmpMat);\n\tfloat len = length(rp + dist*rd - p);\n\tif (dist < closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\n// from http://stackoverflow.com/questions/4078401/trying-to-optimize-line-vs-cylinder-intersection\nfloat cylinder(vec3 ro, vec3 rd, vec3 cp, vec3 cd, float r, float h, float closestHit, material m, inout vec3 nml, inout material dst) {\n\n    vec3 rc = ro - cp;\n    vec3 n = cross(rd, cd);\n\n    float len = length(n);\n\n    // Parallel? (?)\n    if(len < 0.00001 && len > -0.00001) {\n        return closestHit;\n    }\n\n    n = normalize(n);\n\n    float d = abs(dot(rc, n));\n\n    if (d > r) return closestHit;\n\n    vec3 o = cross(rc, cd);\n    float t = -dot(o, n) / len;\n    o = normalize(cross(n, cd));\n    float s = abs( sqrt(r*r-d*d) / dot(rd, o) );\n    float inD = t-s;\n    float outD = t+s;\n    float lambda = outD;\n\n    if (inD < -0.00001) {\n        if(outD < -0.00001) {\n            return closestHit;\n        }\n    } else if (outD < -0.00001 || inD < outD) {\n        lambda = inD;\n    }\n\n    vec3 hbF = (ro + rd*max(inD, outD)) - cp;\n    vec3 hb = (ro + rd*lambda) - cp;\n\tfloat md = h*h+r*r;\n\n    closestHit = disk(ro, rd, cp + cd * h, cd, 0.0, r, closestHit, m, nml, dst);\n    closestHit = disk(ro, rd, cp - cd * h, cd, 0.0, r, closestHit, m, nml, dst);\n\n\tif (\n        (dot(hb, hb) < md || dot(hbF, hbF) < md) &&\n\t\t(dot(hb, hb) < md && lambda < closestHit)\n    ) \n   \t{\n        float scale = dot(hb, cd);\n        nml = -normalize(hb - cd*scale);\n        dst = m;\n\n        closestHit = lambda;\n    }\n\n    return closestHit;\n}\n\n\n// iq's box ray tracing function\n// returns t and normal\nfloat iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, float closestHit, material mat, inout vec3 nml, inout material dst) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0 || tN > closestHit) return closestHit;\n\n\tnml = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnml = (txi * vec4(nml,0.0)).xyz;\n    dst = mat;\n\n\treturn tN;\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( vec3 v )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t v.x, v.y, v.z, 1.0 );\n}\n\nmat4 inv( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nvec3 normal(vec3 p, float phase, float pt, float d)\n{\n\tfloat e = 0.3;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p, phase, pt) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p, phase, pt) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p, phase, pt) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat raymarchScene(in vec3 ro, in vec3 rd, vec2 phase, float closestHit, inout vec3 nml, inout material m) {\n    vec3 p = ro;\n    for (int i=0; i<RAY_STEPS; i++) {\n        float dist = scene(p, phase.x, phase.y);\n        if (dist < THRESHOLD) {\n            nml = normal(p, phase.x, phase.y, dist);\n            m = material(vec3(1.0), vec3(0.0));\n            return length(ro - p);\n        }\n        if (dist > MAX_DISTANCE) {\n            return closestHit;\n        }\n        p += dist * rd;\n    }\n    return closestHit;\n}\n\nfloat rtScene(inout vec3 ro, inout vec3 rd, inout vec3 nml, inout material m) {\n    float closestHit = 1e5;\n    float t = iTime * 1.12346;\n    material red, blue, white;\n\n    vec2 phase = phaseVec(iTime);\n\n    red.transmit = vec3(0.9, 0.7, 0.6);\n    red.emission = vec3(0.0);\n\n    blue.transmit = vec3(0.9);\n    blue.emission = 1.5*vec3(0.8, 0.3, 0.1);\n\n    white.transmit = vec3(0.95);\n    white.emission = vec3(0.0);\n    \n    vec2 uv = vec2(0);\n    \n    float f = 0.5 - 0.5*cos(phase.y * 3.14159 * 2.0 + 3.14159);\n\n    vec3 spherePos = mix(vec3(0.0, 3.0, -4.0), vec3(0.0), f);\n    spherePos.y = 3.0 * pow(1.0-f, 2.0);\n    spherePos.x = 3.0 * sin(iTime)*pow(abs(0.25-f)-0.25, 1.0);\n\n    float r = clamp(0.0, 1.0, 1.0 - 0.5*abs(length(spherePos) - 3.0));\n    \n    csgHit bigSphere = sphere(ro, rd, vec3(0.0, 0.0, 0.0), 3.0, closestHit, red);\n    csgHit smallSphere = sphere(ro, rd, spherePos, 1.0, closestHit, red);\n\n    if (bigSphere.closest < smallSphere.closest || bigSphere.closest > smallSphere.furthest) {\n        if (bigSphere.closest > 0.0 && bigSphere.closest < closestHit) {\n\t        closestHit = bigSphere.closest;\n            m = bigSphere.mat;\n            nml = bigSphere.closestNormal;\n        }\n    } else if (smallSphere.furthest < bigSphere.furthest) {\n        if (smallSphere.furthest > 0.0 && smallSphere.furthest < closestHit) {\n\t        closestHit = smallSphere.furthest;\n            m = smallSphere.mat;\n            nml = smallSphere.furthestNormal;\n        }\n    }\n    \n    closestHit = disk(ro, rd, normalize(spherePos)*(3.15+2.0*(abs(r-0.5))), normalize(spherePos), r*1.3, r*1.6, closestHit, blue, nml, m);\n    closestHit = disk(ro, rd, normalize(spherePos)*3.0, normalize(spherePos), r*2.85, r*3.5, closestHit, blue, nml, m);\n\n    closestHit = cylinder(ro, rd, vec3(0.0, 7.0, -4.0), vec3(0.0, 1.0, 0.0), 1.0, 3.0, closestHit, red, nml, m); \n\n    if (phase.x == 0.0) {\n        mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime*4.0 );\n        mat4 tra = translate( spherePos );\n        mat4 txi = tra * rot; \n        mat4 txx = inverse( txi );\n        vec3 rad = vec3(0.5, 0.5, 0.5);\n\n        closestHit = iBox(ro, rd, txx, txi, rad, closestHit, red, nml, m);\n    } else {\n\t\n        csgHit smallSphere2 = sphere(ro, rd, spherePos, 0.5, closestHit, red);\n\n        if (smallSphere2.closest > 0.0 && smallSphere2.closest < closestHit) {\n            closestHit = 0.0;\n            if (phase.x == 1.0) {\n                float d = (dot(rd, smallSphere2.closestNormal));\n                m.transmit = vec3(1.0 - pow(d,0.5));\n                m.emission = vec3(pow(d,0.5));\n\n                ro += (smallSphere2.closest) * rd;\n                rd = normalize(refract(rd, smallSphere.closestNormal, 1.5));\n                ro += ((smallSphere2.furthest-smallSphere2.closest)*1.201) * rd;\n            } else {\n                float d = (dot(rd, smallSphere2.closestNormal));\n                m.transmit = max(vec3(0.0), vec3(1.0 - pow(d*1.82,2.0)));\n                m.emission = vec3(2.0,1.3,1.0) * (1.0-m.transmit);\n\n                ro += (smallSphere2.furthest) * rd;\n                rd = normalize(d*d * -(ro-spherePos) + rd);\n            }\n            nml = vec3(0.0);\n        }\n    }\n\n    if (closestHit >= 1e5) {\n        closestHit = raymarchScene(ro, rd, phase, closestHit, nml, m);\n        if (closestHit < 1e5) {\n            ro += closestHit * rd;\n            rd = normalize(reflect(rd, nml));\n            ro += rd * THRESHOLD * 600.0;\n\t        nml = cross(vec3(1.0), rd);\n        }\n    }\n\n    \n    return closestHit;\n}\n\n\nvec3 trace(vec2 xy) {\n    vec2 uv = 1.0 - 2.0 * xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 1.6, -8.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float xAngle = iMouse.x > 0.0 ? 8.0*(iMouse.x/iResolution.x - 0.5) : 0.0;\n    float yAngle = iMouse.y > 0.0 ? -2.0*(iMouse.y/iResolution.y - 0.5) : 0.0;\n    mat4 rotX = rotationAxisAngle(vec3(0.0, 1.0, 0.0), xAngle);\n    mat4 rotY = rotationAxisAngle(vec3(1.0, 0.0, 0.0), yAngle);\n    ro = (rotX * rotY * vec4(ro, 1.0)).xyz;\n    rd = (rotX * rotY * vec4(rd, 0.0)).xyz;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 nml = vec3(1.0);\n    material m;\n    vec3 transmit = vec3(1.0);\n    float fog = 0.0;\n    vec3 fogColor = vec3(0.25, 0.3, 0.4);\n\n    for (int i = 0; i < 6; i++) {\n\t    float closestHit = rtScene(ro, rd, nml, m);\n\t    if (closestHit < 1e5) {\n            fog += closestHit;\n            ro += rd * closestHit;\n            if (length(nml) > 0.0) {\n                nml = normalize(nml);\n                rd = reflect(rd, nml);\n            }\n            col += transmit * m.emission;\n            transmit *= m.transmit;\n            ro += rd * 0.001;\n        } else {\n            fog = i == 0 ? 0.0 : fog;\n            col += transmit * 0.2 * shadeBg(rd, xy);\n            break;\n        }\n    }\n    return mix(col, fogColor, min(1.0, pow(fog * 0.002, 0.6)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n    for (float x=0.0; x<AA_SIZE; x++) {\n        for (float y=0.0; y<AA_SIZE; y++) {\n\t\t    col += trace(fragCoord.xy + vec2(x/AA_SIZE, y/AA_SIZE));\n        }\n    }\n\tfragColor = vec4(col / (AA_SIZE*AA_SIZE), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3GzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[311, 311, 334, 334, 462], [464, 464, 491, 491, 740], [742, 742, 758, 758, 853], [5897, 5897, 5976, 5976, 6125], [6127, 6127, 6219, 6219, 6568], [6571, 6571, 6711, 6711, 7338], [7341, 7341, 7457, 7457, 7686], [7688, 7688, 7823, 7823, 8088], [8090, 8190, 8326, 8326, 9517], [9520, 9577, 9722, 9759, 10293], [10295, 10295, 10342, 10342, 10746], [10748, 10748, 10774, 10774, 10890], [10892, 10892, 10915, 10915, 11165], [11167, 11167, 11220, 11220, 11446], [11448, 11448, 11557, 11557, 11970], [11972, 11972, 12051, 12051, 15523], [15526, 15526, 15547, 15547, 16882], [16884, 16884, 16941, 16941, 17178]]}
{"id": "Xtc3DN", "name": "Disturbing Maze", "author": "aiekick", "description": "Disturbing Maze", "tags": ["maze", "disturbing"], "likes": 5, "viewed": 541, "date": "1469731912", "time_retrieved": "2024-06-20T18:39:15.516194", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n    vec2 uv = 4.*(2. * g - iResolution.xy)/iResolution.y;\n\t\n    g /= 45.;\n    \n    float rep = cos(3.14 *( g.y + g.x* sign(sin( 6e3 * length(floor(g)) )) ));\n    \n\tfloat a = atan(uv.x, uv.y) / 3.14159 * 1.5;\n\tfloat r = length(uv) - iTime*0.5;\n\ta+=r+rep;\n\tuv = abs(fract(vec2(a+r,a-r))-0.5);\n\t\n\tfloat x = uv.x*1.248;\n\tfloat y = uv.y*6.;\n\tfloat z = uv.y*1.8;\n\tfloat hex = abs(max(x+y,x) - 1.386);\n\tvec3 col = hex * 0.6 * vec3(0.15,0.24,0.37)/length(uv);\n\t\n    \n    f.rgb =  col;\n    if (abs(rep) > 0.9)\n        f.rgb = col+.5-vec3(.34,1,1)/25./rep;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 590]]}
{"id": "Xtc3RB", "name": "Another Noise", "author": "aiekick", "description": "Another Noise", "tags": ["noise", "another"], "likes": 6, "viewed": 614, "date": "1469802131", "time_retrieved": "2024-06-20T18:39:15.516194", "image_code": "// inpired by Box-Muller Method\n\n#define A 1e5\n#define B 1e5\n\nfloat noise( float a, float b, vec2 c )\n{\n    float k = c.x * c.y;\n    \n\tc.x = 2. * cos(a * k * c.y) - 1.;\n\tc.y = 2. * sin(b * k * c.x) - 1.;\n\n    c *= (1e3 + iTime) * 0.002;\n    \n\tk = fract(dot(c,c));\n\n\treturn 1. - sqrt(-2. * log(k) / k);\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    g /= iResolution.y;\n    \n    f += -f + noise(A,B,g);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 62, 103, 103, 303], [305, 305, 343, 343, 402]]}
{"id": "Xtc3Rn", "name": "Galactic Corridors 2", "author": "vox", "description": "Galactic Corridors 2", "tags": ["galacticcorridors2"], "likes": 13, "viewed": 694, "date": "1467561883", "time_retrieved": "2024-06-20T18:39:16.892108", "image_code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time (sin(((sin(float(__LINE__)*100.0)*GR/PI+GR/PI/E)*iTime+100.0)/100.0)*100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x*PI/2.0)*(1.0-saw(x*PI/2.0))))\n\n#define GRID_COUNT (50.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\n\n\nfloat seedling = 0.0;\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb)*PI)*2.0-1.0;\n}\n\nvec2 square_map(vec2 uv)\n{\n    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(1.0+sin(time+seedling)/PI/E/GR)\n            +vec2(cos(time+seedling)+sin(time+seedling)));\n}\n\nvec2 iterate_square(vec2 uv, vec2 dxdy, out float magnification)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = square_map(a);\n    vec2 mb = square_map(b);\n    vec2 mc = square_map(c);\n    vec2 md = square_map(d);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return square_map(uv);\n}\nvec2 mobius_map(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return mobius(uv, multa, offa, multb, offb);\n}\n\nvec2 iterate_mobius(vec2 uv, vec2 dxdy, out float magnification, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    vec2 a = uv+vec2(0.0, \t\t0.0);\n    vec2 b = uv+vec2(dxdy.x, \t0.0);\n    vec2 c = uv+vec2(dxdy.x, \tdxdy.y);\n    vec2 d = uv+vec2(0.0, \t\tdxdy.y);//((fragCoord.xy + vec2(0.0, 1.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n    vec2 ma = mobius_map(a, multa, offa, multb, offb);\n    vec2 mb = mobius_map(b, multa, offa, multb, offb);\n    vec2 mc = mobius_map(c, multa, offa, multb, offb);\n    vec2 md = mobius_map(d, multa, offa, multb, offb);\n    \n    float da = length(mb-ma);\n    float db = length(mc-mb);\n    float dc = length(md-mc);\n    float dd = length(ma-md);\n    \n\tfloat stretch = max(max(max(da/dxdy.x,db/dxdy.y),dc/dxdy.x),dd/dxdy.y);\n    \n    magnification = stretch;\n    \n    return mobius_map(uv, multa, offa, multb, offb);\n}\nvec3 phase(float map)\n{\n    return vec3(saw(map),\n                saw(4.0*PI/3.0+map),\n                saw(2.0*PI/3.0+map));\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    float smallest = 0.0;\n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.5)).r;\n        smallest = \n        \n        product *= sound;\n        sum += sound;\n    }\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nfloat last_height = 0.0;\nvec3 hash3( vec2 p)\n\n{\n\n    vec3 q = vec3( dot(p,vec2(123.4,234.5)),\n\n    dot(p,vec2(456.7,321.0)),\n\n    dot(p,vec2(432.1,543.2)) );\n\n    return fract(sin(q)*12345.678);\n\n}\n\nvec4 galaxy(vec2 uv)\n{\n\tuv *= 5.0;\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = time;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    vec4 color = vec4(flux(time+seedling), 1.0);\n    \n    vec4 final = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)*(1.0-log(r1+1.))*color\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0)*(1.25-log(r2+1.))*color;\n         \n    final.rgba += color;\n    \n    final /= r1;\n    \n    final *= 2.0;\n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return final;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(sin(time))*E+GR;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    vec2 uv0 = uv;\n    uv += cos(vec2(time, time/GR));\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 6;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border_color = 0.0;\n    float border = 0.0;\n    \n    vec4 hit = vec4(0.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        \n        uv = iterate_square(uv, .5/iResolution.xy, magnification);\n        float weight = smoothstep(0.0, 0.25, magnification);\n        antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*antispeckle;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n        \n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift+float(i))*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n        anticolor *= white;\n\n        if(i != 0)\n        {\n\t\t\thit += galaxy(saw(uv*PI/2.0)*2.0-1.0)*clamp(1.0-length(hit.rgb), 0.0, 1.0)*(1.0-border);\n            \n            //uv = iterate_mobius(uv, .5/iResolution.xy, magnification, multa, offa, multb, offb);\n            antispeckle *= smoothstep(0.0, 1.0/TIMES_DETAILED, sqrt(1.0/(1.0+magnification)));\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.y*PI)))));\n\n            border = max(border, (smoothstep(1.0-1.0/GR/E/PI, 1.0, (cos(uv.x*PI)))));\n\n        }\n    }\n    \n\n    scale = 32.;\n    vec2 gridPosition = floor(uv0 * scale) / scale;\n    vec2 randomOffset = hash(gridPosition) * 2. - 1.;\n    vec2 localGridPositionCenter = fract(uv0 * scale) - .5;\n    float stars = 0.*mix(0., 1., step(length(localGridPositionCenter + randomOffset * .5), .1));\n\n    float map2 = (stars+length(randomOffset))*PI*2.0;\n\n    float twinkle = saw(time+map2);\n\n    hit = hit+clamp(vec4(flux(map2+time)*PI+twinkle, 1.0)*stars*twinkle*PI, 0.0, 1.0)*clamp(1.0-(border), 0.0, 1.0);\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    \n    fragColor.rgb = (color+accum/sum)*(1.0-border);\n    fragColor.a = 1.0;\n    \n    fragColor = hit;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtc3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[128, 1215, 1237, 1237, 1411], [1413, 1413, 1442, 1442, 1512], [1514, 1514, 1543, 1543, 1627], [1629, 1629, 1697, 1697, 1780], [1782, 1782, 1808, 1808, 2015], [2017, 2017, 2083, 2083, 2691], [2692, 2692, 2764, 2764, 2815], [2817, 2817, 2929, 2929, 3667], [3668, 3668, 3691, 3691, 3794], [3796, 3796, 3816, 3816, 4194], [4221, 4221, 4243, 4243, 4393], [4395, 4395, 4417, 4417, 5159], [5160, 5160, 5217, 5217, 8663]]}
{"id": "Xtd3z7", "name": "Ray Marching: Part 3", "author": "jlfwong", "description": "Part 3 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching"], "likes": 61, "viewed": 176915, "date": "1468453826", "time_retrieved": "2024-06-20T18:39:18.080065", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return cubeSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtd3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[348, 456, 479, 630, 1067], [1069, 1158, 1183, 1183, 1213], [1215, 1455, 1489, 1489, 1524], [1526, 1947, 2038, 2038, 2344], [2359, 2613, 2678, 2678, 2810], [2812, 2901, 2930, 2930, 3240], [3242, 3734, 3874, 3874, 4464], [4466, 4836, 4921, 4921, 5721], [5723, 6050, 6099, 6134, 6360], [6362, 6362, 6419, 6419, 7262]]}
{"id": "XtdGR7", "name": "[SH16B] WIP: Warp Tunnel", "author": "stubbe", "description": "Music: https://soundcloud.com/rrlewis2/ott-hello-my-name-is", "tags": ["sh16b"], "likes": 193, "viewed": 24931, "date": "1468734524", "time_retrieved": "2024-06-20T18:39:19.698412", "image_code": "const float PI = 3.1415926535;\nconst float SPEED = 10.0;\nconst float ARMS = 3.0;\nconst vec2 EPSILON = vec2(0, .005);\n\nconst vec3 sunDir = vec3(-0.363696,0.581914,0.727393);//normalize(vec3(-.5,.8,1));\nconst vec3 sunColor = vec3(3,2,1);\n\nfloat time;\nfloat z_offset;\nfloat tunnelShake;\n\nvec2 rotate(vec2 p, float a)\n{\n    return vec2(cos(a)*p.x + sin(a)*p.y, -sin(a)*p.x + cos(a)*p.y);\n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat Map3( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    f  = 0.50000*Noise( q ); q = q*2.02;\n    f += 0.25000*Noise( q ); q = q*2.03;\n    f += 0.12500*Noise( q ); q = q*2.01;\n    return f;\n}\n\nfloat Map5( in vec3 p )\n{\n    vec3 q = p;\n    float f;\n    f  = 0.50000*Noise( q ); q = q*2.02;\n    f += 0.25000*Noise( q ); q = q*2.03;\n    f += 0.12500*Noise( q ); q = q*2.01;\n    f += 0.06250*Noise( q ); q = q*2.02;\n    f += 0.03125*Noise( q );\n    return f;\n}\n\nmat4 LookAt(vec3 pos, vec3 target, vec3 up)\n{\n    vec3 dir = normalize(target - pos);\n    vec3 x = normalize(cross(dir, up));\n    vec3 y = cross(x, dir);\n    return mat4(vec4(x, 0), vec4(y, 0), vec4(dir, 0), vec4(pos, 1));\n}\n\nvec2 TunnelCenter(float z)\n{\n    return vec2(sin(z*.17)*.4,sin(z*.1+4.))*3. * tunnelShake;\n}\n\nfloat GetAngle(vec3 pos)\n{\n    return atan(pos.y,pos.x) - pos.z*.25 + time*3.7 + sin(time)*.2;\n}\n\n\nvec3 Fresnel(vec3 R0, vec3 normal, vec3 viewDir)\n{\n    float NdotV = max(0., dot(normal, viewDir));\n    return R0 + (vec3(1.0) - R0) * pow(1.0 - NdotV, 5.0);\n}\n\nfloat Map(vec3 pos)\n{\n    pos.z -= z_offset;\n    pos.xy -= TunnelCenter(pos.z);\n    float fft = textureLod( iChannel3, vec2(0.5,0.15), 0.0).x;\n    float angle = GetAngle(pos);\n    float r = sin(pos.z*.1)*0.5 + 3. + Map5(pos)*.3 + fft * 2.0 + sin(angle*ARMS)*.3;\n    //r += texture( iChannel3, vec2(fract(pos.z*.1),0.0) ).x;\n    return length(pos.xy) - r;\n}\n\nvec3 Normal(vec3 pos)\n{\n    vec2 e = vec2(0, .05);\n    return normalize(vec3(Map(pos + e.yxx), Map(pos + e.xyx), Map(pos + e.xxy)) - Map(pos));\n}\n\nfloat IntersectPlanets(vec3 pos, vec3 dir, out vec3 normal, out float max_d, out int type)\n{\n    const float PLANET_CYCLE = 25.0;\n    const int PLANET_PASSES = 3;\n    float best_dist = 1e10;\n    bool hit = false;\n    max_d = -1e10;\n    for(int i = 0; i < PLANET_PASSES; i++)\n    {\n        int tp = i;\n        if(tp >= 3) tp-=3;\n        float time2 = time + 15.5*float(i);\n        float planetRound = floor(time2 / PLANET_CYCLE);\n        float planetPos = time2 - planetRound * PLANET_CYCLE;\n        float planetAngle = planetRound * 23.1;\n        float planetDistance =  (tp==0) ? 20. :\n        \t\t\t\t\t\t(tp==1) ? 13. :\n        \t\t\t\t\t\t13.;\n        vec3 sphereCenter = vec3(cos(planetAngle)*planetDistance,sin(planetAngle)*planetDistance,(PLANET_CYCLE- planetPos)*10.);\n        vec3 delta = pos - sphereCenter;\n        float sphereRadius = \t(tp==0) ? 13. :\n        \t\t\t\t\t\t(tp==1) ? 7. :\n        \t\t\t\t\t\t7.;\n    \n        float B = dot(dir, delta);\n        float C = dot(delta, delta) - sphereRadius * sphereRadius;\n        float D = B*B - C;\n        \n        if(D >= 0.0)\n        {\n            float t = -B - sqrt(D);\n            if(t >= 0. && t < best_dist)\n            {\n                vec3 spherePos = pos + t * dir;\n                normal = normalize(spherePos - sphereCenter);\n                best_dist = t;\n                type = tp;\n                hit = true;\n            }\n        }\n        max_d = max(max_d, D);\n    }\n    return hit ? best_dist : -1.;\n}\n\nfloat EarthHeight(vec3 pos)\n{\n    vec2 coord = vec2(acos(pos.y)/(2.0*PI), atan(pos.x, pos.z)/(2.0*PI));\n    vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n    float landLerp = smoothstep( 0.45, 0.5, te.x);\n    vec3 albedo = mix( vec3(0.1, 0.2, 0.45), (vec3(0.055, 0.275, 0.0275) + 0.45*te + te*te*0.5*texture( iChannel2, 2.0*coord.xy ).xyz)*0.4, landLerp );\n    return length(pos) - albedo.x*.015;\n}\n\nvec3 BackgroundInner(vec3 pos, vec3 dir, bool enableSun, out bool sphereHit, out vec3 spherePos, out vec3 sphereNormal, out vec3 reflectivity)\n{\n    vec3 nebulaPos = dir.yxz;\n    float v = Map5(nebulaPos*1.3 + Map5(nebulaPos*0.5)*3.0) + .1;\n    v = max(v, 0.);\n    \n    vec3 color = v*mix(vec3(1.,.2,2), vec3(2,.2,10), clamp(Map3(dir*1.3),0.,1.)) + 0.1;\n    \n    vec2 uv = vec2(acos(dir.x), atan(dir.y,dir.z));\n    \n    vec3 a = texture( iChannel1, uv*1.5).rgb;\n    \n    vec3 b = texture( iChannel1, uv*0.4).rgb;\n    \n    color *= (a * b) * 4.;\n    color += pow(texture(iChannel1, uv*1.0).rgb, vec3(4.0)) * 0.5;\n    if(enableSun)\n    {\n        float sunDot = max(0., dot(dir, sunDir));\n        color += (pow(sunDot, 8.0)*.03 + pow(sunDot, 512.0)) * 5. * sunColor;\n    }\n\n    sphereHit = false;\n    reflectivity = vec3(0);\n    float max_d;\n    int type;\n    float t = IntersectPlanets(pos, dir, sphereNormal, max_d, type);\n    if(t >= 0.0)\n    {\n        spherePos = pos + t * dir;\n        vec2 coord = vec2(acos(sphereNormal.y)/(2.0*PI), atan(sphereNormal.x, sphereNormal.z)/(2.0*PI));\n        float time_offset = time*.04;\n        coord.y += time_offset;\n\n        if(type == 0)\n        {\n            float offset = texture( iChannel2, coord ).r * .005;\n            vec3 lookup = sphereNormal;\n            lookup.xy = rotate(lookup.xy, time_offset*2.0*PI);\n            float height = Map5(lookup*4.)*.5+.8;//texture( iChannel2, coord + vec2(offset)).r;\n            height = pow(min(height, 1.),8.);\n            vec3 fire = (texture( iChannel2, coord*5. + time*.02).rgb +\n                         texture( iChannel2, coord*1. + time*.006).rgb\n\n                        ) * vec3(3,1,1) * .5;\n\n            vec3 albedo = texture( iChannel2, coord + vec2(offset)).rgb * .25 -\n                          texture( iChannel2, coord*7.0).rgb * .1;\n            color = albedo * max(0., dot(sphereNormal, sunDir)) * sunColor + fire * pow(1.0-height,16.);\n        }\n        else if(type == 2)\n        {\n            vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n        \n            float offset = 0.0 + texture( iChannel2, coord).x*.003;\n            vec3 albedo = (texture( iChannel2, coord*vec2(.4,0)+vec2(offset,0) ).rgb-.5)*.7 + .4;\n            albedo += texture( iChannel2, coord*1.0).rgb * .2;\n            albedo += texture( iChannel2, coord*16.0).rgb * .075;\n            color = albedo * max(0., dot(sphereNormal, sunDir)) * sunColor;\n        }\n        else if(type == 1)\n        {\n            vec3 te = texture( iChannel2, coord ).rgb + texture( iChannel2, coord*3.0 ).rgb * .3;\n\n            vec3 bumpedNormal = normalize(vec3(EarthHeight(sphereNormal + EPSILON.yxx), EarthHeight(sphereNormal + EPSILON.xyx), EarthHeight(sphereNormal + EPSILON.xxy)) - EarthHeight(sphereNormal));\n            sphereNormal = bumpedNormal;\n            float landLerp = smoothstep( 0.45, 0.5, te.x);\n            vec3 albedo = mix( vec3(0.1, 0.2, 0.45), (vec3(0.055, 0.275, 0.0275) + 0.45*te + te*te*0.5*texture( iChannel2, 2.0*coord.xy ).xyz)*0.4, landLerp );\n            float specPower = mix(2048., 32., landLerp);\n            float q = (  texture( iChannel2, coord+vec2(0,time*.02) ).x +\n                            texture( iChannel2, coord*2.0+vec2(0,time*.013) ).x) * .5;\n\n            float skyLerp = smoothstep( 0.4, 0.8, q);\n            reflectivity = mix(vec3(0.1), vec3(0.0), skyLerp);\n\n            float NdotL = max(0., dot(sphereNormal, sunDir));\n            vec3 opaque = albedo * NdotL * sunColor;\n            color = opaque + pow(max(0., dot(bumpedNormal, normalize(-dir + sunDir))), specPower) * (specPower + 8.0) / (8.0 * PI) * sunColor * reflectivity;\n\n            vec3 sky = vec3(0.9) * NdotL * sunColor;\n            color = mix( color, sky, skyLerp);        \n        }\n\n        sphereHit = true;\n    }\n    \n    return color;\n}\n    \nvec3 Background(vec3 pos, vec3 dir)\n{\n    dir = normalize(dir);\n    \n    bool sphereHit;\n    vec3 spherePos;\n    vec3 sphereNormal;\n    vec3 reflectivity;\n    vec3 color = BackgroundInner(pos, dir, true, sphereHit, spherePos, sphereNormal, reflectivity);\n    if(sphereHit)\n    {\n        vec3 R = Fresnel(reflectivity, sphereNormal, -dir);\n\n        vec3 reflectionDir = reflect(dir,sphereNormal);\n        bool dummyHit;\n        vec3 dummyPos;\n        vec3 dummyNormal;\n        color += (BackgroundInner(spherePos + sphereNormal*.01, reflectionDir, false, dummyHit, dummyPos, dummyNormal, reflectivity)*(1.0-R)+vec3(1,2,3)*.075)*R*sunColor;\n    }\n    \n    return color;\n}\n\n\nvec3 LensFlare(vec2 x)\n{\n    x = abs(x);\n    float e = 1.5;\n    float d = pow(pow(x.x*.5, e) + pow(x.y*3., e), 1./e);\n    \n    vec3 c = vec3(exp(-2.5*d))*sunColor*(.3+sin(x.y*iResolution.y*2.)*.01) * .5;\n    c += vec3(exp(-dot(d,d)))*sunColor*.05;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    time = iTime;\n    vec3 camPos = vec3(0);\n    z_offset = time*SPEED;\n \n    float introFade = min(time*.05, 1.0);\n    \n    float camZoom = 3.0 - introFade*2.0;\n    \n    tunnelShake = introFade;\n    camPos.xy += TunnelCenter(camPos.z-z_offset)*.5;\n    vec3 camTarget = vec3(0,0,5);\n    camTarget.xy += TunnelCenter(camTarget.z-z_offset)*.5;\n    //camTarget = vec3(3,0,5);\n    camTarget = mix(vec3(3,0,5), camTarget, introFade);\n    \n    float camAngle = sin(time*.3) + time*.1;\n    vec3 camUp = vec3(sin(camAngle),cos(camAngle),0);\n\n    mat4 viewToWorld = LookAt(camPos, camTarget, camUp);\n    vec2 uv2 = (fragCoord - .5*iResolution.xy) / (iResolution.y * camZoom);\n    vec3 eyeDir = (viewToWorld * normalize(vec4(uv2, 1, 0))).xyz;\n    \n    float t = 0.0;\n    vec3 p = camPos;\n    float iterationCount = 0.0;\n    for(int i = 0; i < 70; i++)\n    {\n        float dist = Map(p);\n        \n        t += dist;\n        p += dist*eyeDir;\n        iterationCount++;\n        if(abs(dist) < .001) break;\n    }\n    \n    \n    vec3 normal = Normal(p);\n    vec3 refraction = refract(normalize(eyeDir), normal, 1.012);\n    vec3 reflection = reflect(-normalize(eyeDir), normal);\n    vec3 halfDir = normalize(sunDir - eyeDir);\n    vec2 circlePos = p.xy - TunnelCenter(p.z - z_offset);\n    float angle = atan(circlePos.y,circlePos.x);\n    \n    float z = p.z - z_offset;\n    \n    vec3 R = Fresnel(vec3(0.0), normal, -eyeDir);\n    //vec3 c = mix(vec3(2,1,1),vec3(1,1,2),sin(p.z*.1)*.5+.5);\n    vec3 c = vec3(1);\n    vec3 outColor = Background(p, refraction)*(vec3(1.0) - R)*c + Background(p, -reflection)*R;\n    \n    float fft = texture( iChannel3, vec2(0.2,0.25) ).x;\n    fft = max(.0, fft - .5);\n    \n    float tunnelDist = length(p - camPos);\n    outColor = outColor * exp(-tunnelDist*.05) + (1.0-exp(-tunnelDist*.05))*vec3(2,1,3)*(.1+fft*.6);\n    \n    outColor += sqrt(iterationCount)*.005;\n    \n    vec3 sunPos = (vec4(sunDir, 0) * viewToWorld).xyz;\n    vec2 sunUV = sunPos.xy / sunPos.z;\n\n    float vignette = uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y) * 32. * 0.75 + 0.25;\n    outColor *= vignette;\n    \n    vec3 sphereNormal;\n    float max_d;\n    int type;\n    float planet_t = IntersectPlanets(camPos, sunDir, sphereNormal, max_d, type);\n    float lensIntensity = clamp(1.0 - max_d*.02, 0.0, 1.0);\n    \n    outColor += LensFlare(uv2 - sunUV) * lensIntensity;\n    outColor += LensFlare(uv2 + sunUV) * .4 * lensIntensity;\n\n    outColor = clamp(outColor, 0.0, 1.0);\n    outColor *= vec3(sqrt(min(time*.2, 1.0)));\n    fragColor = vec4( outColor, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4ssGDs", "previewfilepath": "https://soundcloud.com/rrlewis2/ott-hello-my-name-is", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/rrlewis2/ott-hello-my-name-is", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[172, 285, 315, 315, 385], [387, 387, 413, 413, 643], [645, 645, 670, 670, 838], [840, 840, 865, 865, 1103], [1105, 1105, 1150, 1150, 1329], [1331, 1331, 1359, 1359, 1423], [1425, 1425, 1451, 1451, 1521], [1524, 1524, 1574, 1574, 1683], [1685, 1685, 1706, 1706, 2041], [2043, 2043, 2066, 2066, 2188], [2190, 2190, 2282, 2282, 3646], [3648, 3648, 3677, 3677, 4086], [4088, 4088, 4232, 4232, 7946], [7952, 7952, 7989, 7989, 8621], [8624, 8624, 8648, 8648, 8892], [8894, 8894, 8951, 8951, 11532]]}
{"id": "XtdGRN", "name": "Random connections", "author": "dche", "description": "For more 2D SDF functions, see https://www.shadertoy.com/view/XdGSWd.", "tags": ["2d", "random"], "likes": 15, "viewed": 230, "date": "1468194553", "time_retrieved": "2024-06-20T18:39:20.413587", "image_code": "\n#define goCount 10.\n#define goSize 1.\n\n// Anti-alias step function\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2( dFdx(value), dFdy(value)));\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}\n\nfloat opU(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat opI(float d0, float d1) {\n    return max(d0, d1);\n}\n\nfloat opS(float d0, float d1) {\n    return max(d0, -d1);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n    return mod(p, c) - c * 0.5;\n}\n\n// circle: (center.x, center.y, radius)\nfloat sdCircle(vec2 p, vec3 circle) {\n    return length(p - circle.xy) - circle.z;\n}\n\nfloat sdHalfPlane(vec2 p, vec2 plane) {\n    return dot(p, normalize(plane));\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 np = p - a;\n    vec2 ns = b - a;\n    float proj = dot(np, ns) / length(ns);\n    float d = sdHalfPlane(np, vec2(ns.y, -ns.x));\n    float s = sign(d);\n    if (proj < 0.) return s * length(np);\n    if (proj > length(ns)) return s * length(np - ns);\n    else return d;\n}\n\nvec4 fill(float shape, vec4 color) {\n    return vec4(color.rgb, color.a * (1. - smoothstep(0., 1.5, shape)));\n}\n\nvec4 stroke(float shape, vec4 color, float width) {\n    float w = 1. - aastep(width * 0.5, abs(shape));\n    // float w = 1. - step(width * 0.5, abs(shape));\n    // float b = 1. - smoothstep(0., 1., abs(abs(shape) - width * 0.5));\n    float a = min(w, 1.);\n    return vec4(color.rgb, color.a * a);\n}\n\nvec3 blend(vec4 fg, vec3 bg) {\n    return mix(bg, fg.rgb, fg.a);\n}\n\nfloat rand( vec2 co ) {\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return fract(sin(p)*43758.5453123) + 0.5;\n}\n\nfloat noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p-pi;\n\n    vec2 w = pf*pf*(3.-2.*pf);\n\n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n\n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n\n    float ym = mix(xm1,xm2,w.y);\n    return ym + 0.5;\n}\n\nvec3 alpha_go(vec2 p) {\n    // moving slowly. NOTE: artifacts appear.\n    p -= iTime * 2.;\n    vec3 col = vec3(.1, .2, .5);\n    float r2 = iResolution.x / goCount;\n    vec2 c = floor(p / r2);\n    // circle\n    p = opRep(p, vec2(r2));\n    float r = r2 * 0.5 - 2.;\n    r *= 0.2 + goSize * 0.8;\n    float d = sdCircle(p, vec3(0., 0., r));\n    float cd = rand(c) * 0.5;\n    // ring\n    float t = 2. + r * 0.15 * (0.5 + 0.5 * sin(iTime * cd * 2.));\n    d = opS(d, sdCircle(p, vec3(0., 0., r - t)));\n    // fill\n    vec3 clr = vec3(.9, .9, .89);\n    float a = 0.5 + 0.3 * sin(iTime * cd);\n    col = blend(fill(d, vec4(clr, a)), col);\n    // center.\n    d = sdCircle(p, vec3(0., 0., 3.));\n    col = blend(fill(d, vec4(.9, .9, .89, 1.)), col);\n    // links.\n    // ml = left middle point.\n    vec2 ml = vec2(c.x - 0.5, c.y) + iTime * 0.1;\n    vec2 mr = vec2(c.x + 0.5, c.y) + iTime * 0.1;\n    vec2 mu = vec2(c.x, c.y + 0.5) + iTime * 0.1;\n    vec2 md = vec2(c.x, c.y - 0.5) + iTime * 0.1;\n    float f = noise(ml);\n    float hl = r2 * 0.5;\n    d = sdSegment(p, vec2(0., 0.), vec2(-hl, 0.));\n    f = (clamp(f, 0.6, 0.65) - 0.6) * 20.;\n    col = blend(stroke(d, vec4(vec3(1.), f), 2.), col);\n    f = noise(mr);\n    d = sdSegment(p, vec2(0., 0.), vec2(hl, 0.));\n    f = (clamp(f, 0.6, 0.65) - 0.6) * 20.;\n    col = blend(stroke(d, vec4(vec3(1.), f), 2.), col);\n    f = noise(mu);\n    d = sdSegment(p, vec2(0., 0.), vec2(0., hl));\n    f = (clamp(f, 0.6, 0.65) - 0.6) * 20.;\n    col = blend(stroke(d, vec4(vec3(1.), f), 2.), col);\n    f = noise(md);\n    d = sdSegment(p, vec2(0., 0.), vec2(0., -hl));\n    f = (clamp(f, 0.6, 0.65) - 0.6) * 20.;\n    col = blend(stroke(d, vec4(vec3(1.), f), 2.), col);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy - iResolution.xy * 0.5;\n    fragColor = vec4(alpha_go(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtdGRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[40, 68, 112, 112, 253], [255, 255, 286, 286, 312], [314, 314, 345, 345, 371], [373, 373, 404, 404, 431], [433, 433, 461, 461, 495], [497, 537, 574, 574, 621], [623, 623, 662, 662, 701], [703, 703, 744, 744, 1020], [1022, 1022, 1058, 1058, 1133], [1135, 1135, 1186, 1186, 1433], [1435, 1435, 1465, 1465, 1501], [1503, 1503, 1526, 1526, 1607], [1609, 1609, 1630, 1630, 1760], [1762, 1762, 1783, 1783, 2230], [2232, 2232, 2255, 2301, 3936], [3938, 3938, 3995, 3995, 4087]]}
{"id": "Xtt3D4", "name": "Simple Ray Tracer", "author": "polkm", "description": "A simple ray tracer using distance field marching for the sake of example.", "tags": ["example", "simple", "ray", "distance", "field", "march", "trace"], "likes": 4, "viewed": 433, "date": "1469310403", "time_retrieved": "2024-06-20T18:39:20.413587", "image_code": "float plane(vec3 p) { return p.y; }\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nvec4 add(vec4 a, vec4 b) { return a.w < b.w ? a : b; }\n\nvec4 map(vec3 p) {\n    return add(vec4(.3,.3,.2, plane(p)), vec4(.95,.2,.4, sphere(p-vec3(0,1,0), .5)));\n}\n\nconst vec3 e = vec3(.001, 0., 0.);\nfloat nax(vec3 p, vec3 e) { return map(p+e).w - map(p-e).w; }\nvec3 normal(vec3 p) { return normalize(vec3(nax(p,e.xyy), nax(p,e.yxy), nax(p,e.yyx))); }\nconst float tmax = 20.0;\n\nvec4 trace(vec3 ro, vec3 rd, float t, vec4 result) {\n    for (int i=0; i<256; i++)\n        if ((result = map(ro + rd*t)).w < 0.001 || (t += result.w) > tmax) break;\n    return vec4(result.rgb, t);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float t, float d, float res) {\n    for (int i=0; i<11; i++)\n        res = min(res, 8. * (d=map(ro + rd*t).w) / (t += clamp(d,.02,.1)));\n    return clamp(res, 0., 1.);\n}\n\nconst vec3 light = normalize(vec3(.3, .8, -.5));\nvec4 lighting(vec3 ro, vec3 rd, vec3 pos, vec4 res) {\n    res.rgb *= max(dot(normal(ro + rd*res.w), light) * shadow(pos,light,.1,0.,1.), .1);\n    return res = mix(res, vec4(.9,.9,1,1), pow(res.w/tmax,2.));\n}\n\nvec4 render(float time, vec2 uv, vec2 screen) {\n    vec3 ro = vec3(1.5*cos(0.5*(time+3.0)), 1.0 + 0.5*cos((time+3.0)), -4.5);\n    vec3 rd = normalize(vec3(uv * vec2(screen.x/screen.y,1), 3.0));\n    vec4 res = trace(ro, rd, 1.0, vec4(0)); //trace\n    if (res.w < tmax) res = lighting(ro, rd, ro + rd*res.w, res); //apply lighting\n    else res = vec4(mix(vec3(.9,.9,1),vec3(.7,.9,1), rd.y), tmax); //sky\n    res.rgb *= 0.5 + 0.5 * pow((uv.x+1.0)*(uv.y+1.0)*(uv.x-1.0)*(uv.y-1.0), 0.2); //vignett\n    return vec4(pow(res.rgb, vec3(0.4545)), 1); //gamma correction\n}\n\nvec4 renderAA(float time, vec2 uv, vec2 screen) {\n    vec3 pixel = vec3(0.5, 0.5, 0.0) / vec3(screen, 1.0);\n    vec4 sum = vec4(0., 0., 0., 0.);\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            sum += render(time, uv - pixel.xy * vec2(x, y), screen);\n    return (sum) / 9.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = renderAA(iTime, (fragCoord/vec2(iResolution)*2.-1.), vec2(iResolution));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 35], [37, 37, 68, 68, 92], [94, 94, 120, 120, 148], [150, 150, 168, 168, 256], [293, 293, 320, 320, 354], [355, 355, 376, 376, 444], [471, 471, 523, 523, 669], [671, 671, 732, 732, 870], [921, 921, 974, 974, 1128], [1130, 1130, 1177, 1177, 1692], [1694, 1694, 1743, 1743, 2005], [2007, 2007, 2062, 2062, 2153]]}
{"id": "Xtt3DN", "name": "The Inverse World", "author": "soma_arc", "description": "Inverse 3D kissing Schottky Orbit-spheres\nhttps://www.shadertoy.com/view/MtjXDh", "tags": ["3d", "fractal", "kleiniangroup"], "likes": 6, "viewed": 207, "date": "1469347576", "time_retrieved": "2024-06-20T18:39:20.419820", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n\nvec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));\nvec3 rotate(vec3 p, float angle){\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,\n                ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,\n                ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,\n                ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,\n                ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,\n                ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);\n  return m * p;\n}\n\nconst vec3 SPHERE_POS1 = vec3(300, 300, 0);\nconst vec3 SPHERE_POS2 = vec3(300, -300, 0);\nconst vec3 SPHERE_POS3 = vec3(-300, 300, 0);\nconst vec3 SPHERE_POS4 = vec3(-300, -300, 0);\nconst vec3 SPHERE_POS5 = vec3(0, 0, 424.26);\nconst vec3 SPHERE_POS6 = vec3(0, 0, -424.26);\nconst float SPHERE_R = 300.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nvec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nfloat loopNum = 0.;\nfloat kleinSphereR = 125.;\n//float kleinSphereR = 300.;\n//float kleinSphereR = 400.;\nconst int MAX_KLEIN_ITARATION = 30;\nfloat distKlein(vec3 pos){\n  pos = rotate(pos, radians(iTime * 30.));\n  loopNum = 0.;\n  float dr = 1.;\n  bool loopEnd = true;\n  for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n    loopEnd = true;\n    if(distance(pos, SPHERE_POS1) < SPHERE_R){\n      vec3 diff = (pos - SPHERE_POS1);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS2) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS2);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS3) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS3);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS4) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS4);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS5) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS5);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS6) < SPHERE_R){\n      vec3 diff = (pos- SPHERE_POS6);\n      dr *= SPHERE_R2 / dot(diff, diff);\n      pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }\n    if(loopEnd == true) break;\n  }\n  \n  float f = (length(pos) - 80. ) / abs(dr) * 0.08;\n  dr *= (300. * 300.) / dot(pos, pos);\n  pos = sphereInvert(pos, vec3(0), 300.);\n  return min(f,(length(pos) - kleinSphereR) / abs(dr) * 0.08);\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n  return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n  return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                        distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                        distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.01);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  vec3 v = lightPos - p;\n  float dot = dot(n, normalize(v));\n  float r = length(v);\n  return (dot > 0.) ?\n    (lightPower * (dot / (PI_4 * r * r))) * diffuseColor\n    : LIGHTING_FACT * diffuseColor;\n}\n\nconst vec3 lightPos = vec3(150, -250, 400);\nconst vec3 lightPos2 = vec3(0., -300., 0);\nconst vec3 lightPower = vec3(400000.);\n\nconst int MAX_MARCHING_LOOP = 1000;\nvec2 march(const vec3 origin, const  vec3 ray, const float threshold){\n  vec3 rayPos = origin;\n  float dist;\n  float rayLength = 0.;\n  for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n    dist = distFunc(rayPos);\n    rayLength += dist;\n    rayPos = origin + ray * rayLength ;\n    if(dist < threshold) break;\n  }\n  return vec2(dist, rayLength);\n}\n\nconst vec3 BLACK = vec3(0);\nvec3 calcColor(vec3 eye, vec3 ray){\n  vec3 l = BLACK;\n  float coeff = 1.;\n  vec2 result = march(eye, ray, 0.03);\n  vec3 intersection = eye + ray * result.y;\n  vec3 matColor = vec3(0);\n  vec3 normal = getNormal(intersection);\n  if(result.x < 0.03){\n    matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));\n    l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);\n  }\n  return l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 eye = vec3(150 , -250., 400 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  const vec2 coordOffset = vec2(0.5);\n  vec3 ray = calcRay(eye, target, up, fov,\n                     iResolution.x, iResolution.y,\n                     gl_FragCoord.xy + coordOffset);\n\n  fragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 182, 215, 215, 942], [1290, 1290, 1349, 1349, 1468], [1517, 1611, 1637, 1637, 3398], [3400, 3400, 3552, 3552, 3912], [3963, 3963, 3990, 3990, 4104], [4106, 4106, 4129, 4129, 4154], [4187, 4187, 4216, 4216, 4421], [4492, 4492, 4631, 4631, 4832], [4997, 4997, 5067, 5067, 5339], [5369, 5369, 5404, 5404, 5855], [5901, 5901, 5930, 5930, 6107], [6244, 6244, 6300, 6300, 6547]]}
{"id": "Xtt3WM", "name": "Hod ANd COld", "author": "Imsure1200q_1UWE130", "description": "Hot And Cold", "tags": ["hotandcold"], "likes": 1, "viewed": 454, "date": "1469627345", "time_retrieved": "2024-06-20T18:39:20.419820", "image_code": "float wave( vec2 s, vec3 color, vec3 shad, float k, float rdef )\n{\n    vec4 p = vec4(s.x / s.y, shad/color);\n    vec4 eyeX = normalize(vec4(rdef, (p.x / p.y - k) * color.x, rdef*(shad.r/shad.g/shad.b), 100.0));\n    vec3 compared = dot(shad,color)/eyeX.stp;\n    vec4 x = vec4(float(shad),float(color),k/rdef,float(vec2(dot(s,eyeX.xy))));\n    return float(x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 x = normalize(vec2(wave(uv, normalize(vec3(uv, 1.0)), normalize(vec3(uv, -1.0)), 1.0, sin(iTime)),1.0));\n\tfragColor = mix(smoothstep(0.0,-0.3,vec4(sin(iTimeDelta * 3.0)*1.0)*tan(vec4(x.y/x.x,0.5+0.5*sin(iTime),x.x/x.y, 1.0))),\n                    vec4(0.9,0.5,0.1,1.0),sin(iTime)*(uv.x/uv.y)*4.0*tan(sin(iTime)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 66, 66, 359], [360, 360, 417, 417, 784]]}
{"id": "Xtt3zH", "name": "circleyey", "author": "akx", "description": "somewhat inspired by http://i0.wp.com/www.feelmybicep.com/wp-content/uploads/2016/06/tumblr_o6fj5tZ6Vb1u6a2xso1_1280.jpg?resize=500%2C495", "tags": ["2d", "mono"], "likes": 1, "viewed": 92, "date": "1468169016", "time_retrieved": "2024-06-20T18:39:20.419820", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 120. / 60. * iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cenuv = uv * 2.0 - vec2(1.0);\n    cenuv.x *= iResolution.x / iResolution.y;\n    float ymod1 = texture(iChannel0, vec2(uv.x, t * 0.02)).x;\n    float ymod2 = texture(iChannel0, vec2(uv.x - 0.05, ymod1 * 0.05 - t * -0.02)).x;\n    float ymod3 = texture(iChannel0, vec2(uv.x + 0.05, ymod2 * 0.05 + t * 0.03)).x;   \n    float ymod = (ymod1 + ymod2 + ymod3) / 3.0 * 0.1;\n    float bgy = uv.y + ymod;\n    vec4 bg = vec4(step(mod(t + bgy * 30.0, 1.0), 0.2));\n\tfloat dsc = sqrt(cenuv.x * cenuv.x + cenuv.y * cenuv.y);\n    vec4 fg = vec4(step(mod(t - dsc * 20.0, 1.0), 0.2));\n    fragColor = mix(bg, fg, step(dsc, 0.6));\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtt3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 754]]}
{"id": "XttGW8", "name": "Julia Practice", "author": "Milk", "description": "just trying to figure out fractals ", "tags": ["fractal", "julia", "set"], "likes": 1, "viewed": 286, "date": "1469052436", "time_retrieved": "2024-06-20T18:39:20.425806", "image_code": "const float maxSteps = 200.0;\n\nvec2 complexSquare( vec2 v ) {\n\treturn vec2(\n\t\tv.x * v.x - v.y * v.y,\n\t\tv.x * v.y * 2.0\n\t);\n}\n\n//steps coloring\nfloat calc(vec2 z, vec2 c) {\n    for(float i = 0.0; i < maxSteps; i++){\n    \tz = complexSquare(z) + c;\n        if (dot(z,z) > 40.0) {\n            return i;\n            break;\n        }\n    }\n    return 0.0;\n}\n\n//orbit trap point coloring\nfloat orbitTrap(vec2 z, vec2 c, vec2 point) {\n\tfloat dist = 1000.0;\n    float prevDist;\n    float nextDist;\n    for(float i = 1.0; i < maxSteps; i++){\n        \n    \tz = complexSquare(z) + c;\n        \n        prevDist = dist;\n        nextDist = abs(sqrt(z.x-point.x/z.y-point.y));\n        dist = min(prevDist, nextDist);\n    }\n    return dist;\n}\n\nfloat saturation(vec4 color) {\n    float Radj = color.r/255.0;\n    float Gadj = color.g/255.0;\n    float Badj = color.b/255.0;\n    \n    float PCmax = max(Radj, Gadj);\n    float Cmax = max(PCmax, Badj);\n    \n    float PCmin = min(Radj, Gadj);\n    float Cmin = min(PCmax, Badj);\n    \n    float saturation;\n    \n    if (Cmax == 0.0) {\n        saturation = 0.0;\n    } else {\n    \tsaturation = (Cmax-Cmin)/Cmax;\n    }\n    return saturation;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n\tuv *= 2.5 / min( iResolution.x, iResolution.y );\n    float xPre = uv.x+(iTime/10.0);\n    \n    float pi = 3.1415;\n\n    \n    vec2 driftUV = vec2(uv.x, (.1*sin(20.0 * xPre))+uv.y);\n    vec2 driftUV2 = vec2(uv.x, (.1*sin((20.0 * xPre) + pi/8.0))+uv.y);\n    vec2 driftUV3 = vec2(uv.x, (.1*sin((20.0 * xPre) + 2.0*pi/8.0))+uv.y);\n\n    vec2 texCoord = vec2(iTime/60.0,(iTime/60.0)/iResolution.x);\n    vec4 texColor = texture(iChannel0,texCoord);\n\n    float fft  = texture( iChannel1, vec2(uv.x,0.75) ).x; \n    \n    //vec2 c = vec2(saturation(texColor), sin(iTime/10.0));\n    vec2 c = vec2(sin(iTime/10.0), sin(iTime/10.0));\n    //vec2 c = vec2(fft, sin(iTime/10.0));\n    //vec2 c = vec2(.25,.5);\n    \n    vec2 redPoint = vec2(3.0*iResolution.x/4.0*sin(iTime),3.0*iResolution.y/4.0*sin(iTime));\n    vec2 bluePoint = vec2(iResolution.x/4.0*sin(iTime),iResolution.y/2.0*sin(iTime));\n    vec2 greenPoint = vec2(iResolution.x/4.0*sin(iTime),3.0*iResolution.y/4.0*sin(iTime));\n    \n    float dim = 0.04;\n    \n    float red = (orbitTrap(uv,c,redPoint)*dim);\n    float green = (orbitTrap(uv,c,greenPoint)*dim);\n    float blue = (orbitTrap(uv,c,bluePoint)*dim);\n    \n    fragColor = vec4(red,green,blue,1);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XttGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[31, 31, 61, 61, 124], [126, 143, 171, 171, 351], [353, 381, 426, 426, 725], [727, 727, 757, 757, 1164], [1166, 1166, 1223, 1223, 2465]]}
