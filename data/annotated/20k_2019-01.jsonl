{"id": "3d23D1", "name": "voronoi distance field vis", "author": "memo", "description": "exploring pyramid illusion / Vasarely's 'nested squares'\n\nmouseclick left / right of image to invert\n\nhttps://twitter.com/kcimc/status/1089979094505271296\nhttps://michaelbach.de/ot/lum-pyramid/index.html\nhttps://journals.sagepub.com/doi/10.1068/p5383", "tags": ["voronoi", "illusion", "perception"], "likes": 4, "viewed": 168, "published": "Public", "date": "1548761520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n//\n// mouseclick left / right of image to invert\n//\n// exploring pyramid illusion / Vasarely's 'nested squares'\n// https://twitter.com/kcimc/status/1089979094505271296\n// https://michaelbach.de/ot/lum-pyramid/index.html\n// https://journals.sagepub.com/doi/10.1068/p5383\n//\n// based on IQ's https://www.shadertoy.com/view/ldl3W8\n\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 10.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n\n    vec3 c = voronoi( 8.0*p );\n\n\t// isolines\n    vec3 col = vec3(c.x*1.3+0.2);//c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    if (iMouse.x > iResolution.x/2.0) col = vec3(1.0) - col;\n    // borders\t\n    //col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    // feature points\n\t//float dd = length( c.yz );\n\t//col = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.08, dd) );\n\t//col += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23D1.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 366, 388, 418, 599], [601, 601, 628, 628, 1728], [1730, 1730, 1787, 1787, 2312]]}
{"id": "3d23zh", "name": "Escalator", "author": "dr2", "description": "Circular escalators (they do exist); mouseable.", "tags": ["stairs"], "likes": 9, "viewed": 340, "published": "Public API", "date": "1548151818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Escalator\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, qHit, vnBall;\nfloat tCur, dstFar, stSpd, rdDome;\nint idObj;\nconst int idStr = 1, idStrBd = 2, idStrWl = 3, idPil = 4, idPilB = 5, idBBase = 6,\n   idFnc = 7, idDome = 8;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, stRad, stHt, stWid, wThk, d, s, a, az;\n  dMin = dstFar;\n  stRad = 12.;\n  stHt = 5.;\n  stWid = 2.5;\n  wThk = 0.1;\n  az = atan (p.z, - p.x);\n  q = p;\n  s = rdDome;\n  qq.xz = mod (64. * vec2 (az, asin (q.y / length (q))) / (2. * pi) +\n     vec2 (0., 0.5), vec2 (1.));\n  if (q.y < 0.99 * rdDome) s -= 0.5 * max (SmoothBump (0.45, 0.55, 0.05, qq.x),\n     SmoothBump (0.45, 0.55, 0.05, qq.z));\n  d = - 0.8 * PrSphDf (q, s);\n  DMINQ (idDome);\n  p.y -= stHt;\n  qq = p;\n  qq.z = abs (qq.z) - 3.;\n  qq.xz = Rot2D (qq.xz, 0.25 * pi);\n  a = atan (qq.z, - qq.x) / pi;\n  qq = vec3 (25. * a, p.y, length (qq.xz) - stRad);\n  q = qq;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  d = max (max (q.y - 0.5 + abs (mod (q.x + stSpd * sign (p.z) * tCur, 1.) - 0.5), -1. - q.y),\n     abs (q.z) - stWid);\n  d = 0.7 * max (d, abs (p.y) - stHt);\n  DMINQ (idStr);\n  q = qq;\n  q.xy -= vec2 (-0.5 * stRad, stHt - wThk);\n  d = PrBoxDf (q, vec3 (1., wThk, stWid));\n  DMINQ (idStr);\n  q = qq;\n  q.xy -= vec2 (0.5 * stRad, - stHt + wThk);\n  d = PrBoxDf (q, vec3 (1., wThk, stWid));\n  DMINQ (idStr);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (- stRad, stHt - wThk, 1.5);\n  d = PrRoundBoxDf (q, vec3 (stWid + 0.05, 0.07, 1.5), 0.05);\n  DMINQ (idStrBd);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0.7, - stHt + 0.05, stRad + 3.);\n  d = PrRoundBoxDf (q, vec3 (0.7, wThk, stWid), 0.05);\n  DMINQ (idStrBd);\n  q = qq;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  q.z = abs (q.z);\n  q.yz -= vec2 (0.6, stWid + 0.1);\n  d = PrRoundBox2Df (q.yz, vec2 (1.6, 0.05), 0.05);\n  d = max (max (d, p.x), 3. - abs (p.z));\n  q.xy = Rot2D (qq.xy, 0.25 * pi);\n  d = max (d, - max (PrBox2Df (vec2 (mod (24. * a + 0.25, 0.5) - 0.25, q.y - 1.2),\n     vec2 (0.125, 0.7)), 0.89 - dot (normalize (vec2 (p.x, abs (p.z))), vec2 (-0.527, 0.85))));\n  d = max (max (d, abs (p.y) - stHt - 2.6), - p.y - stHt);\n  DMINQ (idStrWl);\n  q = p;\n  q.x = abs (q.x + stRad);\n  q.xy -= vec2 (stWid + 0.1, stHt + 1.2);\n  d = PrBoxDf (q, vec3 (0.1, 1.4, 3.));\n  d = max (d, - PrBox2Df (vec2 (q.y - 0.1, mod (p.z + 0.4, 0.8) - 0.4), vec2 (1., 0.2)));\n  DMINQ (idStrWl);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0.7, - stHt + 0.955, stRad + 3.);\n  q.z = abs (q.z) - stWid - 0.1;\n  d = PrBoxDf (q, vec3 (0.7, 0.955, 0.1));\n  DMINQ (idStrWl);\n  q = p;\n  q.x -= - stRad;\n  q.xz = abs (q.xz) - vec2 (1.5, 2.3);\n  d = PrCylDf (q.xzy, 0.4, stHt);\n  DMINQ (idPil);\n  q.y -= - stHt + 0.2;\n  d = PrCylDf (q.xzy, 0.6, 0.2);\n  DMINQ (idPilB);\n  q = p;\n  q.y -= - stHt + 0.1;\n  d = PrCylDf (q.xzy, 0.5 * stRad, 0.1);\n  DMINQ (idBBase);\n  q = p;\n  q.y -= - stHt + 1.5;\n  q.y = abs (q.y) - 0.5;\n  d = PrTorusDf (q.xzy, 0.08, 22.);\n  q = p;\n  q.y -= - stHt + 1.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (32. * az / (2. * pi)) + 0.5) / 32.);\n  q.x += 22.;\n  d = min (d, PrCylDf (q.xzy, 0.08, 1.));\n  DMINQ (idFnc);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, d, w;\n  d = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dstFar) vnBall = (ro + d * rd) / rad;\n    else d = dstFar;\n  }\n  return d;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 FloorCol (vec2 p)\n{\n  vec4 col4;\n  vec3 qh;\n  float f;\n  qh = HexGrid (p);\n  f = Hashfv2 (17.3 * PixToHex (p));\n  col4 = mix (vec4 (0.4, 0.1, 0.2, 0.2), vec4 (0.25, 0.1, 0., 0.1),\n     Fbm2 (vec2 (3., 1.) * Rot2D (qh.xy, 2. * pi * floor (6. * f) / 6.) + 37.3 * f)) *\n     (1. - 0.2 * smoothstep (0.03, 0.06, qh.z));\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ror, ltDir;\n  vec2 b;\n  float dstObj, dstBall, vdl, s, sh, att;\n  bool isRefl;\n  dstBall = BallHit (ro + vec3 (0., 10.4, 0.), rd, 12.);\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  ror = ro + dstBall * rd;\n  if (dstBall < min (dstObj, dstFar) && ror.y > 0.) {\n    isRefl = true;\n    ro = ror;\n    rd = reflect (rd, vnBall);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idDome) {\n      col4 = (qHit.y < 0.99 * rdDome && length (qHit) > rdDome - 0.1) ?\n         vec4 (0., 0., 0.4, -1.) : vec4 (0.1, 0.7, 0.1, 0.1);\n    } else if (idObj == idStr) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.4);\n      s = 1.;\n      if (vn.y > 0.99) {\n        b = ro.xz - vec2 (0., 3. * sign (ro.z));\n        s = mod (4. * length (b), 1.);\n        col4 *= 0.4 + 0.6 * SmoothBump (0.2, 0.8, 0.05, s);\n        vn.xz = 0.3 * normalize (b) * (SmoothBump (0.75, 0.95, 0.05, s) -\n           SmoothBump (0.05, 0.25, 0.05, s));\n        vn.y = sqrt (1. - dot (vn.xz, vn.xz));\n        col4 = mix (vec4 (0., 0.1, 0., 0.), col4, step (0.007,\n           abs (mod (25. * sqrt (2.) * atan (ro.z - 3. * sign (ro.z), - ro.x) / pi +\n           0.15 * sign (ro.z), 1.) - mod (- stSpd * tCur, 1.))));\n      } else if (abs (vn.y) < 0.1) {\n        col4 = mix (0.9 * col4, vec4 (0.1, 0.8, 0.1, 0.5), SmoothBump (0.3, 0.7, 0.05,\n           mod (2. * qHit.z, 1.)));\n      } else {\n        col4 *= 0.7;\n      }\n    } else if (idObj == idStrBd) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.4);\n      if (qHit.y > 0.) {\n        if (ro.y < 5. || abs (ro.z) > 1.5) {\n          col4 *= 0.4 + 0.6 * SmoothBump (0.2, 0.8, 0.05, (mod (4. * \n             ((ro.y < 5.) ? qHit.z : qHit.x), 1.)));\n          col4 = mix (col4, vec4 (0.8, 0.1, 0.1, 0.3), step (0.,\n             (-1.05 + ((ro.y < 5.) ? 0.4 - qHit.x : qHit.z - 0.4))));\n        }\n      } else col4 *= 0.7;\n    } else if (idObj == idStrWl) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.5);\n      if (qHit.y > 2.2) col4 = mix (vec4 (0.1, 0.1, 0.2, 0.1), col4,\n         smoothstep (0.04, 0.06, abs (qHit.z)));\n      else if (abs (vn.y) < 0.01) vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.5);\n      s = mod (2. * qHit.y + ((length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / pi : 0.), 1.);\n      vn.y = 0.3 * (1. - SmoothBump (0.2, 0.8, 0.1, s)) * sign (s - 0.5);\n      vn.xz *= sqrt (1. - vn.y * vn.y);\n    } else if (idObj == idPilB) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.5);\n    } else if (idObj == idBBase) {\n      col4 = vec4 (0.5, 0.2, 0.1, 0.1);\n      vn = VaryNf (4. * qHit, vn, 1.);\n    } else if (idObj == idFnc) {\n      col4 = vec4 (0.6, 0.5, 0.1, 0.1);\n    }\n  } else {\n    ro += (- ro.y / rd.y) * rd;\n    s = length (ro.xz) - 15.1;\n    if (abs (s) < 2.55 && ro.x > 0.) col4 = vec4 (0.8, 0.8, 0.85, 0.4) *\n       (0.4 + 0.6 * SmoothBump (0.05, 0.95, 0.02, mod (s + 0.5, 1.)));\n    else col4 = FloorCol (ro.xz);\n    vn = vec3 (0., 1., 0.);\n  }\n  ltDir = normalize (ltPos);\n  att = 0.4 + 0.6 * smoothstep (0.5, 0.8, dot (normalize (ltPos - ro), ltDir));\n  if (col4.a >= 0.) {\n    sh = min (ObjSShadow (ro, ltDir), att);\n    vdl = dot (vn, ltDir);\n    col = col4.rgb * (0.2 + 0.1 * max (- vdl, 0.) +  step (0., vdl) * 0.8 * sh * vdl * vdl) +\n       col4.a * smoothstep (0.8, 0.9, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = col4.rgb;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, ltEl, ltAz, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.7 * pi * mPtr.y;\n  } else {\n    az += 0.4 * (floor (0.3 * tCur) + smoothstep (0., 0.1, mod (0.3 * tCur, 1.)));\n  }\n  el = clamp (el, -0.4 * pi, 0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rdDome = 80.;\n  stSpd = 1.5;\n  ro = rdDome * vuMat * vec3 (0., 0.1, -0.95);\n  ro.y = max (ro.y, 0.1);\n  zmFac = 4. / (1. - 0.5 * SmoothBump (0.25, 0.75, 0.25, mod ((az + 0.5 * pi) / (2. * pi), 1.)));\n  dstFar = 2. * rdDome;\n  ltEl = -0.3 * pi * (1. + 0.3 * sin (0.2 * pi * tCur));\n  ltAz = 0.5 * pi * cos (0.3 * pi * tCur);\n  ltPos = vec3 (0., 0., 0.95 * rdDome);\n  ltPos.yz = Rot2D (ltPos.yz, ltEl);\n  ltPos.xz = Rot2D (ltPos.xz, ltAz);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23zh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 977, 999, 999, 3836], [3838, 3838, 3871, 3871, 4112], [4114, 4114, 4135, 4135, 4327], [4329, 4329, 4374, 4374, 4604], [4606, 4606, 4643, 4643, 4884], [4886, 4886, 4910, 4910, 5223], [5225, 5225, 5260, 5260, 8733], [8735, 8735, 8791, 8791, 10407], [10409, 10409, 10441, 10441, 10541], [10543, 10543, 10589, 10589, 10636], [10638, 10638, 10671, 10671, 10760], [10762, 10762, 10809, 10809, 10856], [10858, 10858, 10891, 10891, 10918], [10920, 10920, 10962, 10962, 11013], [11015, 11015, 11061, 11061, 11118], [11120, 11120, 11144, 11144, 11374], [11376, 11376, 11400, 11400, 11460], [11462, 11462, 11485, 11485, 11618], [11620, 11620, 11677, 11677, 11760], [11762, 11762, 11792, 11792, 11905], [11939, 11939, 11963, 11963, 12023], [12025, 12025, 12049, 12049, 12179], [12181, 12181, 12206, 12206, 12392], [12394, 12394, 12415, 12415, 12570], [12572, 12572, 12601, 12601, 12813], [12815, 12815, 12854, 12854, 13034]]}
{"id": "3d23zw", "name": "Moving Quadrangle", "author": "karolina_obszynska", "description": "Shader tworzy czworokąt, który ograniczony jest przez funkcje wyznaczane między sąsiednimi wierzchołkami w ruchu. Każdy z wierzchołków czworokąta porusza się po torze, który jest okręgiem. Wierzchołki poruszają się z różną prędkością.", "tags": ["circles", "time", "function", "motion", "move", "quadrangle"], "likes": 2, "viewed": 86, "published": "Public", "date": "1548447786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Definiowanie stałej wartości, stała pkts jako stała, ciągła ilość wierzchołków, która wynosi 4, która będzie używana do definiowania tablic\nconst int pkts = 4;\nfloat r = 50.0;\n\n//Tworzenie fukcji zawierającej informacje czy dany piksel o przekazanych koordynatach zawiera się między bokami powstałymi na wierzchołkach\nbool zawiera(vec2 pixelcoord, vec2 polot[pkts]){\n    int is = 1;\n    float distx[pkts];\n    float disty[pkts];\n    //prawy bok i lewostronne ograniczenie koordynaty x\n    distx[0] = polot[0].x-polot[1].x;\n    disty[0] = polot[0].y-polot[1].y;\n    if (pixelcoord.x > (pixelcoord.y - polot[0].y)/disty[0]*distx[0]+polot[0].x) is=0;\n    //lewy bok i prawostronne ograniczenie koordynaty x\n    distx[2] = polot[2].x-polot[3].x;\n    disty[2] = polot[2].y-polot[3].y;\n    if (pixelcoord.x < (pixelcoord.y - polot[2].y)/disty[2]*distx[2]+polot[2].x) is=0;\n    //dolny bok i odgórne ograniczenie koordynaty y\n    distx[1] = polot[1].x-polot[2].x;\n    disty[1] = polot[1].y-polot[2].y;\n    if (pixelcoord.y < (pixelcoord.x - polot[1].x)/distx[1]*disty[1]+polot[1].y) is=0;\n    //górny bok i oddolne ograniczenie koordynaty y\n    distx[3] = polot[3].x-polot[0].x;\n    disty[3] = polot[3].y-polot[0].y;\n    if (pixelcoord.y > (pixelcoord.x - polot[3].x)/distx[3]*disty[3]+polot[3].y) is=0;\n    \n    //Zwracanie logicznej wartości całkowitej zmiennej\n    return bool(is);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Przeniesienie punktu (0,0) na środek ekranu\n    vec2 zero = iResolution.xy/2.0;\n    //Definicja środków okręgów\n    vec2 punkt[pkts];\n     punkt[0] = zero + vec2(100.0, 100.0);\n     punkt[1] = zero + vec2(100.0, -100.0);\n     punkt[2] = zero + vec2(-100.0, -100.0);\n     punkt[3] = zero + vec2(-100.0, 100.0);\n    //polot jest to zmienna zawierająca pozycje wierzchołków\n    vec2 polot[pkts];\n    //Definiowanie kolorów\n    vec3 col1 = vec3(0.1, 0.2, 0.9);\n    vec3 col2 = vec3(0.0, 1.0, 0.0);\n    vec3 col3 = vec3(0.0, 0.0, 0.0);\n    vec3 col4 = vec3(0.8, 0.1, 0.1);\n    vec3 col5 = vec3(0.6, 0.6, 0.6);\n    vec3 pixel;\n    //Domyślne zamalowanie tła\n    pixel = col1;\n    \n    \n    //Wyrysowanie torór ruchu wierzchołków\n    for (int i=1; i<=pkts; i++)\n    {\n        float len = length(fragCoord - punkt[i-1]);\n        if (len < 5.0 ){\n            pixel=col2;\n        }\n        if (len > (r-1.0) && len < (r+1.0)) {pixel = col3;}\n    }\n    \n    //Wyrysowanie wierzchołków\n    for (int i=1; i<=pkts; i++)\n    {\n        polot[i-1].x = punkt[i-1].x-sin(iTime/float(i)*2.0)*r;\n        polot[i-1].y = punkt[i-1].y-cos(iTime/float(i)*2.0)*r;\n        float len=length(fragCoord - polot[i-1]);\n        if (len < 5.0) {pixel = col4;}\n    }\n    \n    //Sprawdzenie, czy piksel należy do czworokąta\n    if (zawiera(fragCoord, polot)) {pixel = col5;}\n    \n    //Rysowanie\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d23zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 339, 387, 387, 1404], [1406, 1406, 1463, 1514, 2884]]}
{"id": "3d2GRh", "name": "Noise - Value - 2D - Periodic", "author": "iq", "description": "Surprisingly many people have been asking me about this, so here's the simplest example of a periodic (value) noise. Note the polar deformation doesn't have the typical atan2() mapping discontinuity.", "tags": ["2d", "noise", "periodic"], "likes": 17, "viewed": 768, "published": "Public API", "date": "1548241713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// random hash\nfloat hash( in ivec2 q )\n{\n    // You SHOULD replace this by something better. Again, Do Not Use in production.\n    int n = q.x*131 + q.y*57;\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float((n>>8)&0x007fffff)/float(0x007fffff);\n}\n\n// basic value noise\nfloat noise( in vec2 x, in int p )\n{\n    ivec2 i = ivec2(floor(x));\n     vec2 f =       fract(x);\n    \n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash((i+ivec2(0,0))&(p-1)), \n                    hash((i+ivec2(1,0))&(p-1)),f.x),\n               mix( hash((i+ivec2(0,1))&(p-1)), \n                    hash((i+ivec2(1,1))&(p-1)),f.x),f.y);\n}\n\n// fractal noise\nfloat fbm( in vec2 x, in int p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        f += s*noise( x, p );\n        s *= 0.5;\n        x *= 2.0;\n        p *= 2;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    bool polar = fract(iTime/6.0)>0.5;\n\n    // coords\n    vec2 q = (polar) ? vec2( 4.0+4.0*atan(p.y,p.x)/3.1415927, length(p) ) :  p*8.0;\n    q += 0.5*iTime;\n\n    // fbm\n    const int pe = 8; // Period. Make it a power of 2\n    float f = fbm( q, pe );\n\tvec3 col = vec3(f);\n\n    // grid\n    if( !polar )\n    {\n        vec2 w = smoothstep(0.0,0.01,abs(mod(8.0*p+float(pe/2),float(pe))/float(pe)-0.5));\n        col = mix( col, vec3(1.0,0.7,0.0), (1.0-w.x*w.y)*smoothstep( 0.8,0.9,sin(iTime) ) );\n    }\n    \n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2GRh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1079, 1094, 1120, 1205, 1366], [1368, 1389, 1425, 1425, 1732], [1734, 1751, 1785, 1785, 1962], [1964, 1964, 2021, 2021, 2627]]}
{"id": "3dB3RD", "name": "啥是佩奇？What's Peppa?", "author": "ixulin", "description": ":D    2333333333333333", "tags": ["cartoon", "china", "pig"], "likes": 10, "viewed": 302, "published": "Public", "date": "1548238536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 ixulin \n// Site  www.ixulin.com\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives, and an example on how to\n// do some interesting boolean operations, repetition and displacement.\n//\n\n#define AA 1 // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) // approximated\n{\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n#if 1\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n    vec2 d = vec2(\n        length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n        p.z - h.y);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n#endif\n#if 0    \n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#endif\n}\n\n// vertical\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n#if 0    \n    float ibal = inversesqrt(baba);\n    float x = length(pa-ba*paba*ibal*ibal) - r;\n    float y = (abs(paba-baba*0.5)-baba*0.5)*ibal;\n    return min(max(x,y),0.0) + length(max(vec2(x,y),0.0));\n#else\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n#endif\n}\n\n//------------------------------------------------------------------\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat opSubtraction(float d1, float d2) { return max(-d1, d2); }\n\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nvec3 opTwist(vec3 p)\n{\n    float c = cos(10.0 * p.y + 10.0);\n    float s = sin(10.0 * p.y + 10.0);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\nvec3 opRot(vec3 p, float angle)\n{\n    angle = angle * 3.1415 / 180.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.zy, p.x);\n}\nvec3 opCheapBend(vec3 p)\n{\n    float angle = -180.0 * 3.1415 / 180.0;\n    float c = cos(angle * p.y);\n    float s = sin(angle * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame, 0))\n\n//------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n    float body = sdEllipsoid(pos - vec3(0, 0.5, 0), vec3(0.18, 0.5, 0.5));\n    float box = sdBox(pos, vec3(0.13, 1, 1));\n    body = opSmoothIntersection(box, body, 0.01);\n\n    float nose1 = sdCappedCylinder((pos - vec3(0, 0.89, 0.3)).xzy, vec2(0.125, 0.3));\n    float nose2 = sdCappedCylinder((pos - vec3(0, 0.89, 0.46)).xzy, vec2(0.132, 0.005));\n    nose1 = opSmoothUnion(nose1, nose2, 0.01);\n    body = opSmoothUnion(body, nose1, 0.03);\n\n    float nares = 9999.0;\n    float nares1 = sdHexPrism((pos - vec3(-0.1, 0.9, 0.4)).zyx, vec2(0.03, 0.06));\n    float nares1_1 = sdCylinder((pos - vec3(-0.1, 0.9, 0.4)).yxz, vec2(0.015, 0.1));\n    nares1 = opSubtraction(nares1_1, nares1);\n    nares = opSmoothUnion(nares, nares1, 0.0);\n    float nares2 = sdHexPrism((pos - vec3(-0.1, 0.9, 0.5)).zyx, vec2(0.03, 0.06));\n    float nares2_1 = sdCylinder((pos - vec3(-0.1, 0.9, 0.5)).yxz, vec2(0.015, 0.1));\n    nares2 = opSubtraction(nares2_1, nares2);\n    nares = opSmoothUnion(nares, nares2, 0.0);\n\n    float ear1 = sdBox(pos - vec3(0, 0.9, -0.28), vec3(0.05, 0.18, 0.09));\n    float ear2 = sdBox(pos - vec3(0, 0.9, 0.28), vec3(0.05, 0.18, 0.09));\n    float ear3 = sdBox(pos - vec3(0, 0.885, 0), vec3(0.05, 0.1, 0.3));\n    body = opSmoothUnion(body, ear1, 0.0);\n    body = opSmoothUnion(body, ear2, 0.0);\n    body = opSmoothUnion(body, ear3, 0.0);\n\n    float eyes = 9999.0;\n    float eye1 = sdHexPrism((pos - vec3(-0.1, 0.86, 0.13)).zyx, vec2(0.08, 0.06));\n    float eyeball1 = sdCylinder((pos - vec3(-0.1, 0.86, 0.13)).yxz, vec2(0.055, 0.1));\n    eye1 = opSubtraction(eyeball1, eye1);\n    eyes = opSmoothUnion(eyes, eye1, 0.0);\n    float eye2 = sdHexPrism((pos - vec3(-0.1, 0.76, -0.11)).zyx, vec2(0.06, 0.06));\n    float eyeball2 = sdCylinder((pos - vec3(-0.1, 0.76, -0.11)).yxz, vec2(0.045, 0.1));\n    eye2 = opSubtraction(eyeball2, eye2);\n    eyes = opSmoothUnion(eyes, eye2, 0.0);\n\n    float face1 = sdCappedCylinder((pos - vec3(-0.1, 0.5, 0)).yxz, vec2(0.19, 0.045));\n    body = opSmoothUnion(body, face1, 0.0);\n\n    float face2 = sdCappedCylinder((pos - vec3(-0.1, 0.6, -0.26)).yxz, vec2(0.08, 0.045));\n    body = opSmoothUnion(body, face2, 0.0);\n\n    float mouth = sdCappedCylinder((opCheapBend(opRot(pos - vec3(-0.14, 0.24, 0.12), 105.0))).xyz, vec2(0.01, 0.24));\n    // body = opSmoothUnion(body, mouth, 0.0);\n\n    vec2 res = opU(vec2(sdPlane(pos), 1.0), vec2(body, 2.0));\n    res = opU(res, vec2(eyes, 3.0));\n    res = opU(res, vec2(mouth, 3.0));\n    res = opU(res, vec2(nares, 3.0));\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n#if 1\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y;\n    if (tp1 > 0.0)\n        tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y;\n    if (tp2 > 0.0)\n    {\n        if (ro.y > 1.6)\n            tmin = max(tmin, tp2);\n        else\n            tmax = min(tmax, tp2);\n    }\n#endif\n\n    float t = tmin;\n    float m = -1.0;\n    for (int i = 0; i < 64; i++)\n    {\n        float precis = 0.0004 * t;\n        vec2 res = map(ro + rd * t);\n        if (res.x < precis || t > tmax)\n            break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if (t > tmax)\n        m = -1.0;\n    return vec2(t, m);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i = ZERO; i < 16; i++)\n    {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < 4; i++)\n    {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(pos + 0.0005 * e).x;\n    }\n    return normalize(n);\n#endif\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = ZERO; i < 5; i++)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox(in vec2 p)\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n    // xor pattern\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float m = res.y;\n    if (m > -0.5)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        // material\n        col = vec3(247.0 / 255.0, 100.0 / 255.0, 100.0 / 255.0); //0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n        if (m < 1.5)\n        {\n            float f = checkersGradBox(5.0 * pos.xz);\n            col = 0.3 + f * vec3(0.1);\n        }\n        if (m > 2.5)\n        {\n            col = vec3(72.0 / 255.0, 59.0 / 255.0, 53.0 / 255.0);\n        }\n\n        // lighitng\n        float occ = calcAO(pos, nor);\n        vec3 lig = normalize(vec3(-0.4, 0.7, -0.6));\n        vec3 hal = normalize(lig - rd);\n        float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.2, 0.2, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n        dif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n        dom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n                    dif *\n                    (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n        vec3 lin = vec3(0.0);\n        lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n        lin += 0.30 * amb * vec3(0.40, 0.60, 1.00) * occ;\n        lin += 0.40 * dom * vec3(0.40, 0.60, 1.00) * occ;\n        lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n        lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n        col = col * lin;\n        col += 9.00 * spe * vec3(1.00, 0.90, 0.70);\n\n        col = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.0002 * t * t * t));\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 30.0 + iTime * 0.1;\n\n    vec3 tot = vec3(0.0);\n#if AA > 1\n    for (int m = ZERO; m < AA; m++)\n        for (int n = ZERO; n < AA; n++)\n        {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n#else\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n#endif\n\n            // camera\n            vec3 ro = vec3(2.3 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 2.3 * sin(0.1 * time + 6.0 * mo.x));\n            vec3 ta = vec3(0.0, 0.4, 0.0);\n            // camera-to-world transformation\n            mat3 ca = setCamera(ro, ta, 0.0);\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\n            vec3 col = render(ro, rd);\n\n            // gamma\n            col = pow(col, vec3(0.4545));\n\n            tot += col;\n#if AA > 1\n        }\n    tot /= float(AA * AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dB3RD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1315, 1385, 1408, 1408, 1426], [1428, 1428, 1457, 1457, 1552], [1554, 1554, 1611, 1611, 1712], [1714, 1714, 1748, 1748, 2317], [2319, 2331, 2365, 2365, 2472], [2474, 2474, 2514, 2514, 2621], [2623, 2648, 2699, 2699, 3319], [3321, 3391, 3419, 3419, 3457], [3459, 3459, 3494, 3494, 3516], [3518, 3518, 3559, 3559, 3582], [3584, 3584, 3626, 3626, 3648], [3650, 3650, 3700, 3700, 3807], [3809, 3809, 3865, 3865, 3973], [3975, 3975, 4032, 4032, 4139], [4141, 4141, 4163, 4163, 4305], [4306, 4306, 4339, 4339, 4493], [4494, 4494, 4520, 4520, 4693], [4796, 4866, 4889, 4889, 7393], [7395, 7395, 7433, 7433, 8095], [8097, 8159, 8235, 8235, 8525], [8527, 8591, 8621, 8621, 9177], [9179, 9179, 9219, 9219, 9528], [9530, 9606, 9640, 9661, 9892], [9894, 9894, 9931, 9931, 11856], [11858, 11858, 11908, 11908, 12096], [12098, 12098, 12153, 12153, 13220]]}
{"id": "3dfGR2", "name": "Yet another Cornell Box", "author": "reinder", "description": "Yet another Cornell Box. I have optimised the code of [url=https://www.shadertoy.com/view/XlGcWD]RIOW 2.07: Instances[/url] for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian solid materials and cubes are supported. ", "tags": ["ray", "cornellbox", "pathtracer", "box", "cornell", "tracer", "path"], "likes": 32, "viewed": 3437, "published": "Public API", "date": "1547043986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Yet another Cornell Box. Created by Reinder Nijhoff 2019\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/3dfGR2\n// \n// Yet another Cornell Box. I have optimised the code of my shader \"RIOW 2.07: Instances\"\n// for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian \n// solid materials and cubes are supported. \n//\n// These shaders are my implementation of the raytracer described in the (excellent) \n// book \"Ray tracing in one weekend\" and \"Ray tracing: the next week\"[1] by Peter Shirley \n// (@Peter_shirley).\n//\n// = Ray tracing in one week =\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\n//\n// = Ray tracing: the next week =\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\n//\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n//\n\n#define MOVE_CAMERA\n\n#define MAX_FLOAT 1e5\n#define EPSILON 0.01\n#define MAX_RECURSION 3\n#define SAMPLES (12+min(0,iFrame))\n\n#define LAMBERTIAN 0\n#define DIFFUSE_LIGHT 1\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Ray trace helper functions\n//\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 rotate_y(const in vec3 p, const in float t) {\n    float co = cos(t);\n    float si = sin(t);\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\n//\n// Ray\n//\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nray ray_translate(const in ray r, const in vec3 t) {\n    ray rt = r;\n    rt.origin -= t;\n    return rt;\n}\n\nray ray_rotate_y(const in ray r, const in float t) {\n    ray rt = r;\n    rt.origin = rotate_y(rt.origin, t);\n    rt.direction = rotate_y(rt.direction, t);\n    return rt;\n}\n\n//\n// Material\n//\n\nstruct material {\n    int type;\n    vec3 color;\n};\n\n//\n// Hit record\n//\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n};\n\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\n    hit_record ht = h;\n    ht.p -= t;\n    return ht;\n}\n   \nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\n    hit_record ht = h;\n    ht.p = rotate_y(ht.p, t);\n    ht.normal = rotate_y(ht.normal, t);\n    return ht;\n}\n\nvoid material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \n                      out ray scattered) {\n    scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed));\n    attenuation = rec.mat.color;\n}\n\nvec3 material_emitted(const in hit_record rec) {\n    if (rec.mat.type == DIFFUSE_LIGHT) {\n        return rec.mat.color;\n    } else {\n        return vec3(0);\n    }\n}\n\n//\n// Hitable\n//\n\nstruct hitable { // always a box\n    vec3 center, dimension; \n};\n    \nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\n    vec3 m = 1./r.direction;\n    vec3 n = m*(r.origin - center);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return false;\n    \n    float t = tN < t_min ? tF : tN;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) {\n    float dist;\n    vec3 normal;\n    if (box_intersect(r, t_min, t_max, hb.center, hb.dimension, normal, dist)) {\n        rec.t = dist;\n        rec.p = r.origin + dist*r.direction;\n        rec.normal = normal;\n        return true;\n    } else {\n        return false;\n    }\n}\n\n//\n// Camera\n//\n\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    return cam;\n}\n    \nray camera_get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\n}\n\n//\n// Color & Scene\n//\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n    const material red = material(LAMBERTIAN, vec3(.65,.05,.05));\n    const material white = material(LAMBERTIAN, vec3(.73));\n    const material green = material(LAMBERTIAN, vec3(.12,.45,.15));\n\n    const material light = material(DIFFUSE_LIGHT, vec3(15));\n    \n    if (hitable_hit(hitable(vec3(278,555,279.5), vec3(65,1,52.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;   \n   \n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);\n    hit_record rec_ = rec;    \n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec_)) \n        hit=true, \n        rec=hit_record_translate(hit_record_rotate_y(rec_, 18./180.*3.14159265359),-vec3(130,0,65.)), \n        rec.mat=white;\n    \n\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);\n    rec_ = rec;    \n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec_)) \n        hit=true, \n        rec=hit_record_translate(hit_record_rotate_y(rec_, -15./180.*3.14159265359),-vec3(265,0,295)), \n        rec.mat=white;\n\n  \tif (hitable_hit(hitable(vec3(556,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=red;\n    if (hitable_hit(hitable(vec3(-1,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=green;\n   \n    if (hitable_hit(hitable(vec3(277.5,556,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    if (hitable_hit(hitable(vec3(277.5,-1,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    if (hitable_hit(hitable(vec3(277.5,277.5,556), vec3(277.5,277.5,1)),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n    \n    return hit;\n}\n\n\nbool shadow_hit(const in ray r, const in float t_min, const in float t_max) {\n    hit_record rec;\n    rec.t = t_max;\n   \n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);  \n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec)) \n        return true;\n    \n\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);  \n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec)) \n        return true;\n  \n    return false;\n}\n\nvec3 color(in ray r) {\n    vec3 col = vec3(0);\n    vec3 emitted = vec3(0);\n\thit_record rec;\n    \n    for (int i=0; i<MAX_RECURSION && world_hit(r, EPSILON, MAX_FLOAT, rec); i++) {\n        if (rec.mat.type == DIFFUSE_LIGHT) { // direct light sampling code\n            return i == 0 ? rec.mat.color : emitted;\n        }\n\n        vec3 attenuation;\n        material_scatter(r, rec, attenuation, r);\n        col = i == 0 ? attenuation : col * attenuation;\n\n        // direct light sampling\n        vec3 pointInSource = (2.*hash3(g_seed)-1.) * vec3(65,1,52.5) + vec3(278,555,279.5);\n        vec3 L = pointInSource - rec.p;\n        float rr = dot(L, L);\n        L = normalize(L);\n\n        ray shadowRay = ray(rec.p, L);\n        if (L.y > 0.01 && dot(rec.normal, L) > 0. && !shadow_hit(shadowRay, .01, 1000.)) {\n\t        const float area = (65.*52.5*4.);\n            float weight = area * L.y * dot(rec.normal, L) / (3.14 * rr);\n            emitted += col * 15. * weight;\n        }\n    }\n    return emitted;\n}\n\n//\n// Main\n//\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n    float aspect = iResolution.x/iResolution.y;\n#ifdef MOVE_CAMERA\n    vec3 lookfrom = vec3(278. + sin(iTime * .7)*200., 278, -800. + sin(iTime)*100.);\n#else\n    vec3 lookfrom = vec3(278. , 278, -800.);\n#endif\n    vec3 lookat = vec3(278,278,0);\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n\n    vec3 tcol = vec3(0);\n    \n    for (int i=0, l = SAMPLES; i<l; i++) {\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\n\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, .0, 10.);\n        ray r = camera_get_ray(cam, uv);\n        tcol += color(r);\n    }\n    \n    frag_color = vec4(sqrt(tcol / float(SAMPLES)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfGR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[1658, 1735, 1760, 1760, 1876], [1898, 1898, 1928, 1928, 2094], [2096, 2096, 2126, 2126, 2299], [2301, 2338, 2419, 2419, 2748], [2750, 2750, 2794, 2794, 2930], [2932, 2932, 2982, 2982, 3103], [3105, 3164, 3216, 3216, 3269], [3271, 3271, 3323, 3323, 3442], [3515, 3611, 3684, 3684, 3739], [3744, 3744, 3817, 3817, 3927], [3929, 3929, 4060, 4060, 4185], [4187, 4187, 4235, 4235, 4351], [4353, 4441, 4616, 4616, 5107], [5109, 5109, 5248, 5248, 5522], [5524, 5651, 5875, 5875, 6446], [6452, 6452, 6491, 6491, 6734], [6736, 6760, 6872, 6872, 8636], [8639, 8639, 8716, 8716, 9164], [9166, 9166, 9188, 9188, 10167], [10169, 10184, 10243, 10243, 10935]]}
{"id": "3djGRm", "name": "Random Glows", "author": "KAJAJJJ", "description": "Random bokeh/glow circles", "tags": ["bokeh", "glow"], "likes": 23, "viewed": 632, "published": "Public", "date": "1548450246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA_SIZE 0.0015\n\n// Sampling\nint g_seed;\n\nint Hash(int x)\n{\n    x = (x ^ 61) ^ (x >> 16);\n    x = x + (x << 3);\n    x = x ^ (x >> 4);\n    x = x * 0x27d4eb2d;\n    x = x ^ (x >> 15);\n    x = 1103515245 * x + 12345;\n    return x;\n}\n\n// Time\nfloat GetTime()\n{\n\treturn iTime;   \n}\n\nvoid Rand_Init(int seed)\n{\n    g_seed = seed;\n}\n\nfloat Rand_GetFloat01()\n{\n    g_seed = Hash(g_seed);\n    return float(g_seed) * 2.3283064365386963e-10 * 0.5 + 0.5;\n}\n\nfloat Rand_Range(float min, float max)\n{\n    return Rand_GetFloat01() * (max - min) + min;\n}\n\nvec2 Rand_Sample2D()\n{\n    return vec2(Rand_GetFloat01(), Rand_GetFloat01());\n}\n\nvec3 Rand_Sample3D()\n{\n    return vec3(Rand_GetFloat01(), Rand_GetFloat01(), Rand_GetFloat01());\n}\n\nfloat Circle(vec2 point, float radius, float slope, vec2 uv)\n{\n    return smoothstep(radius + slope, radius - slope, length(uv - point));\n}\n\nfloat Rectangle(vec2 point, vec2 size, vec2 uv)\n{\n    return smoothstep(size.x + AA_SIZE, size.x - AA_SIZE, length(uv.x - point.x))\n        * smoothstep(size.y + AA_SIZE, size.y - AA_SIZE, length(uv.y - point.y));\n}\n\nfloat Sin01(float x)\n{\n    return sin(x) * 0.5 + 0.5;\n}\n\nfloat Cos01(float x)\n{\n    return cos(x) * 0.5 + 0.5;\n}\n\nvec3 DrawZero(vec2 point, vec2 uv)\n{\n    vec3 result = vec3(0.0);\n    for (int i = 0; i < 50; ++i)\n    {\n        float start = Rand_GetFloat01();\n        float t = GetTime();\n        float r1 = Rand_GetFloat01();\n        float r2 = Rand_GetFloat01();\n        float r3 = Rand_GetFloat01();\n        float r4 = Rand_GetFloat01();\n        float x = cos(t * r1 + start) * r3;\n        float y = sin(t * r2 + start) * r4;\n        vec3 color = vec3(Sin01(Rand_GetFloat01() * GetTime() + Rand_GetFloat01()), Cos01(Rand_GetFloat01() * GetTime()),Sin01(Rand_GetFloat01() * GetTime())) * Rand_Range(0.25, 0.5);\n        float radius = Rand_GetFloat01() * 0.2 + 0.01;\n        float slope = Rand_Range(0.001, 0.5) * radius;\n        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);\n    }\n    \n    for (int i = 0; i < 10; ++i)\n    {\n        float start = Rand_GetFloat01();\n        float t = GetTime();\n        float r1 = Rand_GetFloat01();\n        float r2 = Rand_GetFloat01();\n        float r3 = Rand_GetFloat01() * 1.5;\n        float r4 = Rand_GetFloat01() * 1.5;\n        float x = cos(t * r1 + start) * r3;\n        float y = sin(t * r2 + start) * r4;\n        vec3 color = Rand_Sample3D() * Rand_Range(0.1, 0.25);\n        float radius = 0.3;//Rand_GetFloat01() * 0.2 + 0.01;\n        float slope = Rand_Range(0.001, 0.5);\n        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);\n    }\n    \n    for (int i = 0; i < 10; ++i)\n    {\n        float start = Rand_GetFloat01();\n        float t = GetTime();\n        float r1 = Rand_GetFloat01();\n        float r2 = Rand_GetFloat01();\n        float r3 = Rand_GetFloat01() * 1.5;\n        float r4 = Rand_GetFloat01() * 1.5;\n        float x = cos(t * r1 + start) * r3;\n        float y = sin(t * r2 + start) * r4;\n        vec3 color = Rand_Sample3D() * Rand_Range(0.1, 0.25);\n        float radius = 0.7;//Rand_GetFloat01() * 0.2 + 0.01;\n        float slope = Rand_Range(0.001, 0.5);\n        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);\n    }\n    \n    return max(result, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Rand_Init(int(32));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = DrawZero(vec2(0.0, 0.0), uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 49, 66, 66, 235], [237, 245, 262, 262, 282], [284, 284, 310, 310, 331], [333, 333, 358, 358, 450], [452, 452, 492, 492, 544], [546, 546, 568, 568, 625], [627, 627, 649, 649, 725], [727, 727, 789, 789, 866], [868, 868, 917, 917, 1083], [1085, 1085, 1107, 1107, 1140], [1142, 1142, 1164, 1164, 1197], [1199, 1199, 1235, 1235, 3346], [3348, 3348, 3405, 3405, 3719]]}
{"id": "3djGRw", "name": "TriangleRasterizer", "author": "uynet", "description": "rasterizer", "tags": ["graphics"], "likes": 14, "viewed": 226, "published": "Public", "date": "1548437480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 c2 = vec3(.8,0.9,1.);//points\nvec3 c1 = vec3(1.,0.9,.7);//tradict\nvec3 c0 = vec3(.7,0.7,1.);//barycenterCircle\nvec3 c3 = vec3(1,1,1);//background\nvec3 c4 = vec3(1.,0.2,.6);//barycenter\nvec3 c5 = vec3(.6,1.,.2);//barycenter\nvec3 c6 = vec3(0.2,.6,1.);//barycenter\n\nfloat time;\nfloat R;\nconst int samples = 50;\nvec2 g;\nvec4 color;\n\nconst float PI = 3.14159265;\n\nfloat cLength(vec2 p){\n  if(abs(p.x)>abs(p.y))return abs(p.x);\n  return abs(p.y);\n}\n\nvoid rasterize(vec2 uv){\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y *= asp;\n    uv *= 0.4;\n    color = vec4(c3,1.0);\n\n    \n    time = iTime*0.6;\n    \n    float r = 0.1;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy-0.5;\n    \n    float t0 = time+sin(time*2.);\n    float t1 = time+cos(time*2.);\n    float t2 = time-sin(time*2.);\n\n    vec2 p0 = vec2(r*sin(t0-2.*PI/3.),r*cos(t0-2.*PI/3.));\n    vec2 p1 = vec2(r*sin(t1),r*cos(t1));\n    vec2 p2 = vec2(r*sin(t2-4.*PI/3.),r*cos(t2-4.*PI/3.));\n   \n      \n    float m0 = (p1.y-p0.y)/(p1.x-p0.x);\n    float m1 = (p2.y-p1.y)/(p2.x-p1.x);\n    float m2 = (p0.y-p2.y)/(p0.x-p2.x);\n    \n    //ax + by + c = 0\n    //y = m(x-p.x) + p.y ;\n    //mx + (-1)y + ( -mp.x + p.y ) = 0;\n\n    float d0 = abs(m0*uv.x + (-1.)*uv.y+ (-m0*p0.x+p0.y))\n                     /length(vec2(m0,-1));\n    float d1 = abs(m1*uv.x + (-1.)*uv.y+ (-m1*p1.x+p1.y))\n                     /length(vec2(m1,-1));\n    float d2 = abs(m2*uv.x + (-1.)*uv.y+ (-m2*p2.x+p2.y))\n                     /length(vec2(m2,-1));\n\n\n    float po = 100.;\n    vec2 grid = fract(uv*po);\n    vec2 st = uv-(grid-0.5)/po ;\n    //α＝{(By-Cy)(Px-Cx)+(Cx-Bx)(Py-Cy)}/{(By-Cy)(Ax-Cx)+(Cx-Bx)(Ay-Cy)}\n    //β＝{(Cy-Ay)(Px-Cx)+(Ax-Cx)(Py-Cy)}/{(By-Cy)(Ax-Cx)+(Cx-Bx)(Ay-Cy)}\n    //γ＝１−αーβ\n      float Ax = p0.x;\n      float Ay = p0.y;\n      float Bx = p1.x;\n      float By = p1.y;\n      float Cx = p2.x;\n      float Cy = p2.y;\n      float Px = st.x;\n       float Py = st.y;\n    float alpha = ((By-Cy)*(Px-Cx)+(Cx-Bx)*(Py-Cy))/((By-Cy)*(Ax-Cx)+(Cx-Bx)*(Ay-Cy));\n     float beta =  ((Cy-Ay)*(Px-Cx)+(Ax-Cx)*(Py-Cy))/((By-Cy)*(Ax-Cx)+(Cx-Bx)*(Ay-Cy));\n    float gamma = 1.-alpha-beta;\n\n    if(grid.x<0.05)color=vec4(c0,1);\n    if(grid.y<0.05)color=vec4(c0,1);\n    if(cross(vec3(p1-p0,0),vec3(st-p0,0)).z < 0. &&\n        cross(vec3(p2-p1,0),vec3(st-p1,0)).z < 0. &&\n       cross(vec3(p0-p2,0),vec3(st-p2,0)).z < 0. ){\n        color = vec4(c4*alpha + c6*beta + c0 * gamma,1.);\n         if(grid.x<0.05)color=vec4(c3,1);\n         if(grid.y<0.05)color=vec4(c3,1);\n    }\n        \n    //edges\n    float w = 0.001;\n    if((abs(d0)<w ||\n         abs(d1)<w||\n        abs(d2)<w)\n      &&length(uv)<0.1){\n        color = vec4(c4*alpha + c6*beta + c0 * gamma,1.);\n        //color = mix(color,vec4(c4,1),max(sin(time)+0.3,0.));\n    }\n    //vertices\n  \n      if(length(uv-p0)<0.006) color = vec4(c4,1);\n      if(length(uv-p1)<0.006) color = vec4(c6,1);\n      if(length(uv-p2)<0.006) color = vec4(c0,1);\n\n\n\n\n\n    // Output to screen\n    //if(abs(length(uv)-r)<0.007)fragColor=vec4(c1,1);\n    if(length(uv-g)<R)color*=vec4(c2,1);\n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 364, 386, 386, 447], [449, 449, 473, 473, 476], [477, 477, 534, 584, 3252]]}
{"id": "3dl3DS", "name": "boing2", "author": "bpaf", "description": "rrrrrrrreeeeeeaaaaaarrrrrrrrreeeearrrrrrr", "tags": ["pulse"], "likes": 3, "viewed": 42, "published": "Public", "date": "1547391873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589;\nfloat mmod(float a, float b) { return a - floor(a/b); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c1 = vec2(0.5,0.5);\n    float n = 2.0 + 4.0*sin(pi*mmod(iTime,1.0));\n    float a = cos(length(uv - c1) * 2.0 * (n + 2.0) * 1.0 * pi) * sin(length(uv - c1) * 2.0 * n * 1.0 * pi);\n    vec3 col = vec3(0,1,0) * a;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dl3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 88], [89, 89, 146, 146, 435]]}
{"id": "3dl3WX", "name": "grids on grids 2d animation", "author": "public_int_i", "description": "grids on grids a quick 2d animation", "tags": ["2d", "animation", "on", "grids"], "likes": 5, "viewed": 378, "published": "Public API", "date": "1547656154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\nfloat triwave(float x) {\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\n#define time iTime\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.x;\n\n\tfloat t1 = fract(time*.2)*10.,\n\tt2 = fract(time*.2+0.5)*10.;\n\tfloat g1 = length(max(abs(mod(abs(uv)*t1*t1,2.)-1.)-.8,0.)),\n\t\tg2 = length(max(abs(mod(abs(uv)*t2*t2,2.)-1.)-.8,0.)),\n\t\ts1 = max(.4,(1.0-t1*.1*.6)-g1*10./t1),\n\t\ts2 = max(.4,(1.0-t2*.1*.6)-g2*10./t2);\n\to = vec4(mix(s1,s2,clamp((triwave(fract(time*.2+0.5))*2.-1.)*2.,-1.,1.)*.5+.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dl3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 102, 102, 134], [156, 156, 196, 196, 595]]}
{"id": "3dlGDM", "name": "Motion Vectors Visualization", "author": "boksajak", "description": "A quick way for visualizing motion vectors as a post-processing pass (a full-screen quad).\n1. For each pixel within a n x n block, load motion vector in its center\n2. Draw black or white based on distance of current pixel to line denoting a motion vector ", "tags": ["motion", "debug", "vectors"], "likes": 2, "viewed": 424, "published": "Public", "date": "1546520305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INVALID_UVS vec2(-10.0f, -10.0f)\n\nfloat distanceFromLineSegment(vec2 p, vec2 start, vec2 end) {\n    float len = length(start - end);\n\tfloat l2 = len * len; \n\tif (l2 == 0.0f) return length(p - start);   \n\tfloat t = max(0.0f, min(1.0f, dot(p - start, end - start) / l2));\n\tvec2 projection = start + t * (end - start);\n\treturn length(p - projection);\n}\n\nvec2 getPreviousFrameUVs(vec2 pos) {\n    \n    // TODO: Load your motion vector here and figure\n    // out the screen coordinates (UV) of this pixel\n    // in previous frame (in <0, 1> range).\n    // Often, just add motion vector to the \"pos\" variable \n    \n    // We just return some random time varying numbers for this example\n    return 0.5 + 0.5*cos(iTime+pos/iResolution.xy);\n}\n\nvec3 visualizeMotionVectors(vec2 pos)\n{\n\tfloat lineThickness = 1.0f;\n\tfloat blockSize = 32.0f;\n\n\t// Divide the frame into blocks of \"blockSize x blockSize\" pixels\n    // and get the screen coordinates of the pixel in the center of closest block\n\tvec2 currentCenterPos = floor(pos / blockSize) * blockSize + (blockSize * 0.5f);\n\n\t// Load motion vector for pixel in the center of the block\n    vec2 previousCenterPos01 = getPreviousFrameUVs(currentCenterPos);\n    vec2 previousCenterPos = previousCenterPos01 * iResolution.xy;\n\n\t// Reject invalid motion vector (e.g. for failed reprojection, indicated by INVALID_UVS value)\n    bool rejectReprojection = (previousCenterPos01.x == INVALID_UVS.x && previousCenterPos01.y == INVALID_UVS.y);\n    if (rejectReprojection) previousCenterPos = currentCenterPos;\n\n\t// Get distance of this pixel from motion vector line on the screen\n\tfloat lineDistance = distanceFromLineSegment(pos, currentCenterPos, previousCenterPos);\n\n\t// Draw line based on distance\n\treturn (lineDistance < lineThickness) \n        ? vec3(1.0f, 1.0f, 1.0f) \n        : vec3(0.0f, 0.0f, 0.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: depth is not needed for motion vectors vizualization, but I recommend \n    // adding a linearized depth in <0;1> range to the result to show the geometry currently in frame\n\tfloat depth = 0.0f;\n    \n    fragColor = vec4(depth + visualizeMotionVectors(fragCoord), 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 103, 103, 357], [359, 359, 395, 687, 741], [743, 743, 782, 782, 1846], [1848, 1848, 1905, 2091, 2190]]}
{"id": "3dlGDS", "name": "bpafs pulse", "author": "theinventor13", "description": "variable wavelength", "tags": ["prettygud"], "likes": 1, "viewed": 64, "published": "Public", "date": "1547389718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589; float mmod(float a, float b) { return a - floor(a/b); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord/iResolution.xy; vec2 c1 = vec2(0.5,0.5); float n = 2.0*mmod(iTime,1.0); float a = cos(length(uv - c1) * 6.0 * n * 2.0 * pi) * sin(length(uv - c1) * 4.0 * (n+1.0) * 2.0 * pi); vec3 col = vec3(0,1,0) * a; fragColor = vec4(col,1.0); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 88], [89, 89, 146, 146, 398]]}
{"id": "3dlGRB", "name": "Coherent Diffraction", "author": "damart3d", "description": "diffraction of coherent oscillators placed in line", "tags": ["light", "physics", "electrodynamics"], "likes": 1, "viewed": 119, "published": "Public", "date": "1546717875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float G_PI = 3.1415926;\n\nconst float frequency = 60.0; //times per screen width\n\nfloat oscillator(vec2 uv, vec2 offset)\n{\n   \tvec2 coord = uv - vec2(0.5,0.5) - offset;\n    coord *= 2.0 * G_PI * vec2(1.0,iResolution.y/iResolution.x);\n    \n    return  cos(length(coord*frequency)- 5.0*iTime);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     int oscillatorsNum =  int(floor((cos(iTime)*0.5+0.5)*21.0));\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float acc = 0.0;\n    \n    for(int i = 0; i<= oscillatorsNum; i++ )\n    {\n        \n       vec2 offsetA = vec2(float(i) * 0.25/frequency,0.0);\n        \n      \n        if( i % 2 == 0 && i != 0)// even odd check to stay in the center\n         \toffsetA = +vec2(float(i/2) * 0.5/frequency,0.0);\n        else           \n       \t\toffsetA = -vec2(ceil(float(i)/2.0) * 0.5/frequency,0.0);\n               \n       acc += oscillator(uv,offsetA); \n    }    \n  \tacc /= float(oscillatorsNum+1);\n    acc = acc * 0.5 + 0.5;\n\n    \n    // Output to screen\n    vec3 resC = (vec3(1,0,0.0)*(1.0 - acc) + vec3(0,0,1)*acc - vec3(0.5,0,0.5))*2.0; \n    fragColor = vec4(resC,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 88, 128, 128, 299], [302, 302, 359, 359, 1186]]}
{"id": "3dlGzX", "name": "circular puzzle box (251 chars)", "author": "FabriceNeyret2", "description": "reproducing [url] https://www.instagram.com/boredpanda/p/BpNIxRCgqre/ [/url]\nSee ref image + video at bottom below.\n\ninteractive variant: [url] https://www.shadertoy.com/view/3ssGRf [/url]", "tags": ["2d", "pattern", "2tweets", "short", "golf", "reproduction"], "likes": 4, "viewed": 393, "published": "Public API", "date": "1547045217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see interactive variant: https://www.shadertoy.com/view/3ssGRf\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = u+u - R;\n    U = vec2( 2.5*length(U/=R.y), .9*atan(U.y,U.x) );\n    float c = ceil(4.28*(U.x-.48));\n    O = ( c > 0. && c < 9.\n            ? U.y += c * .03*iTime,\n              U = abs(fract( U * mat2(1,1,-1,1)*.707 ) - .5),\n              1. + .6* min(0.,cos(38.*max(U.x,U.y)))\n            : .4\n        ) * vec4(1,.9,.7,1); } /*\n\n\n\n\n\n\n// --- 272 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = ( U+U - R ) / R.y;\n    U = vec2( 2.5*length(U), .9*atan(U.y,U.x) );\n    //float a=.48, b=2.35, c = ceil(8.*(U.x-a)/(b-a));\n    float c = ceil(4.28*(U.x-.48));\n    O = ( c > 0. && c < 9.\n            ? U.y += c * .03*iTime, //iMouse.x/R.x,\n              U *= mat2(1,1,-1,1)/sqrt(2.),\n              U = abs(fract(U)-.5),\n              1. + .6* min(0.,cos(38.*max(U.x,U.y)))\n            : .4 \n        ) * vec4(1,.9,.7,1);\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 103, 103, 470]]}
{"id": "3ds3Df", "name": "Cinema", "author": "KaiBowers", "description": "just started - feedback welcome!", "tags": ["cinema", "kino"], "likes": 5, "viewed": 120, "published": "Public", "date": "1547686593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV MAP\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //CURTAIN MOVEMENT\n\tfloat p = (sin((iTime * 1.3f) + ((uv.x + uv.y))) + 1.f) / 2.f; \n    \n    //DRAW SIDE CURTAINS\n    if(uv.x - (p * 0.08f) < 0.15f || uv.x + (p * 0.08f) > 0.85)\n    {\n        //CURTAIN COLOR\n        float w = 0.f;   \n        \n        //CHECK DIRECTION/SIDE\n        if(uv.x > 0.5f)\n    \t{\n            //RIGHT\n    \t\tuv.x = ((uv.x) + (p * 0.08f));\n    \t\tuv.y = ((uv.y) + (p * 0.03f));\n        \tw = mod(1.f - uv.x, 0.05f) * 20.f;\n    \t}\n    \telse      \n    \t{\n            //LEFT\n    \t\tuv.x = ((uv.x) - (p * 0.08f));\n    \t\tuv.y = ((uv.y) - (p * 0.03f));\n        \tw = mod(uv.x , 0.05f) * 20.f;\n    \t}\n        \n        //SET COLOR\n        vec3 col = vec3(w, 0, 0);  \n    \tfragColor = vec4(col, 1.0);\n       \treturn;\n    }\n    \n    //ADD MOVIE OFFSET\n    uv.y += sin(24.1f * iTime) * 0.001f;\n    \n    //DRAW SCREEN\n    if(uv.y > 0.2f && uv.y < 0.8f)\n    {    \n      \n        //SCREEN FLICKER\n        float v = ((sin(iTime * 20.f) * 0.175f + 1.f) / 2.f) + 0.2f;     \n        float d = 2.4f * pow(abs(uv.x - 0.5f), 2.f) + pow(abs(uv.y - 0.5f), 2.f);     \n        v = (v * 0.5f) - (v * sqrt(d) * 0.5f);         \n\t\tfragColor = vec4(vec3(v, v, v), 1.0);\n        \n        //TRIANGLE \n        float tx = (sin(iTime * 5.f) * 0.2f);\n        float ty = (sin(iTime * 2.1f) * 0.2f);\n        if(0.5f - uv.y - ty > 2.25f * abs(uv.x + tx - 0.5) && (uv.y + ty) > 0.45)\n        {\n            fragColor += fragColor;\n        }      \n        \n        //LIGHT\n        float md = pow(abs(uv.x + tx - 0.5f), 2.f) + pow(abs(uv.y + ty - 0.5f), 2.f);\n        float ti = iTime * 4.f;\n        if(md > sin(ti) && md < sin(ti + 0.5f))\n        {\n            fragColor += (fragColor * 1.f);\n        }\n        \n        return;\n    }\n    \n    //BACKGROUND\n    fragColor = vec4(vec3(pow(abs(0.5f - uv.y), 3.f) * 0.5f, 0, 0), 1.0);       \n    return;           \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 72, 1959]]}
{"id": "3ds3DX", "name": "Wallpaper (Full Screen!)", "author": "KaiBowers", "description": "My First Shader!", "tags": ["wallpaper", "hypnotising"], "likes": 0, "viewed": 258, "published": "Public", "date": "1547665688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float stp = iTime * 1.f;    \n    float px = (uv.x / 2.f) + (fragCoord.x * 0.1f * 0.00155f * stp);\n    float py = (uv.y / 2.f) + (fragCoord.y * 0.1f * 0.00155f * stp); \n    float k = mod(sin(px) + sin(py) + 2.f, (1.f + pow(stp, 2.f)));  \n    vec3 col = vec3(\n        1.f - mod((k + iTime) * ((1.f) * 0.1f) , 1.f),\n        mod(k, 0.5f),\n    \t1.f - mod(k , (0.25f + (iTime / 3.141f))));  \n    fragColor = vec4(col, 1.0);    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 525]]}
{"id": "3ds3R2", "name": "semi realistic point reflection", "author": "public_int_i", "description": "semi realistic point light reflection, click to compare realistic(left) to phong(right)", "tags": ["reflection", "phong", "light", "point", "realistic"], "likes": 3, "viewed": 403, "published": "Public API", "date": "1546898841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019\n\n#define point vec3(sin(iTime*.6)*3.,cos(iTime*.7)*2.+2.,0.)\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    //ray position & direction\n    vec3 rp = vec3(0.,0.,-10.),\n        rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.x,1.)),\n        l = vec3(0.);\n    \n    //planar reflections on x and y plane\n    vec3 reflPos, nrm;\n    float reflDst = (rp.y-.5)/rd.y,\n        reflDst2 = (rp.x+3.*sign(rd.x))/rd.x;\n    if (reflDst < 0.) reflDst = 1e8;\n    if (reflDst2 < 0.) reflDst2 = 1e8;\n    \n    if (reflDst < reflDst2) {\n        nrm = vec3(0,-1,0);\n    }\n    if (reflDst2 < reflDst) {\n     \treflDst = reflDst2;\n        nrm = vec3(sign(-rd.x),0.,0.);\n    }\n    reflPos = rp+rd*reflDst;\n  \n    if (reflDst < 1e8) {\n        //realistic reflection vs phong\n        vec3 reflDir = reflect(rd,nrm),\n                lightDiff = point-reflPos,\n                lightDir = normalize(lightDiff);\n        if (iMouse.w > 0. && iMouse.x < u.x) {\n            l += pow(max(0.,dot(lightDir,reflDir)),16.);//phong\n        } else {\n\t\t\t//goal is cheap realistic reflection that properly handles roughness and scattering, this is just a test\n            l += pow(max(0.,1.-length(lightDir-reflDir*(1.-abs(nrm)))),4.);\n        }\n    }\n    \n    l += max(0.,dot(normalize(point-rp),rd)-.999)*3e3;//point light\n    o = vec4(l,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 132, 163, 1337]]}
{"id": "3dS3Rh", "name": "Heart Beyond", "author": "theepicsnail", "description": "<3", "tags": ["heart"], "likes": 0, "viewed": 66, "published": "Public", "date": "1548062101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cossin(float a) { return vec2(cos(a), sin(a)); }\nconst int[] beyond = int[](\n    0,\t4064,\t2336,\t2336,\t1728,\n    0,\t448,\t672,\t672,\t288,\n    0,\t448,\t32,\t\t36,\t\t504,\n    0,\t192,\t288,\t288,\t192,\n    0,\t480,\t256,\t256,\t224,\n    0,\t192,\t288,\t288,\t4080,\t16,\n    0\n);\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(vec2 uv, float a) {\n    vec2 cs = cossin(a);\n    return uv * mat2x2(cs.x, -cs.y, cs.y, cs.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 getColor(vec2 uv, int id) {\n    float rnd = rand(uv);\n    id = int(rand(vec2(id, id))*30.0);\n    switch(id%6) {\n        case 0: break;\n        case 1: uv.x = abs(uv.x); break;\n        case 2: uv.y = abs(uv.y); break;\n        case 3: uv   = abs(uv);   break;\n        case 4: uv.x *= -1.0; break;\n        case 5: uv.y *= -1.0; break;\n    }\n    float t = iTime;\n    switch(id%5) {\n        \n    \tcase 0: return hsv2rgb(vec3(uv.y*.05-t, 1, 1));\n    \tcase 1: return hsv2rgb(vec3(uv.x*.05-t, 1, 1));\n    \tcase 2: return hsv2rgb(vec3(rand(uv), 1, 1));\n        case 3: return hsv2rgb(vec3(-iTime*.1616, 1, 1));\n        case 4: return hsv2rgb(vec3((abs(uv.x)+abs(uv.y))*.01 - t, 1, 1));\n    }\n    return vec3(1,0,1);\n}\n\nbool heart(vec2 pixel_uv) {\n    pixel_uv.x = abs(pixel_uv.x); // left = right side.\n    pixel_uv.y += 1.0;\n    float arm_length=\t\t5.0;\n    float heart_diameter=\t3.0;\n    float heart_thickness=\t1.0;\n    // rotate 45 degrees so that y-axis is pointed up/right /\n    pixel_uv = rotate(pixel_uv, 3.14159/4.0);\n    float rect_dist = sdBox(pixel_uv, vec2(0.0,arm_length));\n    float mask = abs(rect_dist-heart_diameter);\n    return mask < heart_thickness;\n}\n\nbool renderText(vec2 pixel_uv) {\n    return ((beyond[int(pixel_uv.x)]>>int(pixel_uv.y))&1)>0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    bool boolean_mask = true;\n    vec3 color = vec3(1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv*=41.0; // cells tall.\n    uv.x += .5;\n    uv.y += .5;\n    \n    vec2 pixel_uv = floor(uv);\n    \n    if(abs(pixel_uv.y) > 10.0) {\n        // borders\n        boolean_mask = (abs(pixel_uv.y) <= 15.0) && (rand(pixel_uv) < clamp(0.0, 1.0, .5+sin(iTime*.5)));\n        \n    } else {\n        \n        // Scroll the banner\n        pixel_uv.x += floor(iTime*10.0);\n\n        // [ 0-19] is heart\n        // [20-49] is text\n        pixel_uv.x = mod(pixel_uv.x, 50.0);\n        pixel_uv.y += floor(sin(pixel_uv.x*6.28318/50.0)*0.0);\n        \n        if(pixel_uv.x < 20.0)\n            // shift heart [-10,9]\n            boolean_mask = heart(pixel_uv-vec2(10,0));\n        else {\n            // shift text so that it fits nicely.\n            boolean_mask = renderText(pixel_uv+vec2(-20,7));\n        }\n    }\n    \n    pixel_uv = rotate(pixel_uv, -3.14159/4.0);\n    float t = iTime*.5;\n    int id = int(t);\n    color = mix(\n        getColor(floor(uv), id),\n        getColor(floor(uv), id+1),\n        smoothstep(0.0,1.0, fract(t)));\n    \n    vec2 subpixel_uv = fract(uv);\n    float led = 1.0-length(subpixel_uv-.5)*2.0;\n    fragColor = vec4(1);\n    fragColor *= boolean_mask?1.0:0.05;\n    fragColor *= led*2.0;\n    fragColor.rgb *= color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dS3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 53], [262, 262, 299, 299, 383], [385, 385, 416, 416, 492], [494, 494, 516, 516, 685], [687, 687, 707, 707, 779], [781, 781, 813, 813, 1494], [1496, 1496, 1523, 1523, 1947], [1949, 1949, 1981, 1981, 2044], [2046, 2046, 2103, 2103, 3510]]}
{"id": "3ds3Rj", "name": "HeartCurve", "author": "EvilRyu", "description": "Saw this formula on TikTok...", "tags": ["heart", "1d", "function"], "likes": 6, "viewed": 435, "published": "Public API", "date": "1546873676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n\nfloat love_curve(in float x, in float a)\n{\n    // abs(x) to avoid the result being complex number\n    // but seems some systems handle it well without the abs()\n    return pow(abs(x),2./3.)+0.9*sqrt(3.3-x*x)*sin(a*PI*x);\n}\n\nfloat grad_love_curve(float x, float a)\n{\n\t// abs(x) in the pow\n\treturn -0.9*x*sin(a*PI*x)/sqrt(3.3-x*x)+\n        \t0.9*a*PI*sqrt(3.3-x*x)*cos(a*PI*x)+\n        \t0.666667/pow(abs(x),1./3.);\n\n}\nvec2 getsubpixel(int id,vec2 fragCoord)\n{\n\tvec2 aa=vec2(floor((float(id)+0.1)*0.5),mod(float(id),2.0));\n\treturn vec2((2.0*fragCoord.xy+aa-iResolution.xy)/iResolution.y);\n}\n\n\nvec2 barrel(vec2 p)\n{   \n    float k=.03;\n    float r=p.x*p.x+p.y*p.y;\n    p*=1.6+k*r+k*r*r;\n    return p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n     \n    vec3 tot=vec3(0.);\n    for(int i=0;i<4;++i)\n    {\n        vec2 p=getsubpixel(i,fragCoord);\n        \n        if(abs(p.x)-0.72>0.)\n            continue;\n        \n        p.x-=0.001;\n        p.y+=0.2;\n \n        p*=2.5;\n        float eps = 0.00001;\n\n        float f, df, d;\n\n        float t=1.0/iResolution.y;\n\n        f=love_curve(p.x, (sin(iTime*0.5)*0.5+0.5)*16.);\n        //df=(f-love_curve(p.x+eps, (sin(iTime)*0.5+0.5)*16.))/eps;\n        df=grad_love_curve(p.x,(sin(iTime*0.5)*0.5+0.5)*16.);\n        d=abs(p.y-f)/sqrt(1.0+df*df);\n\n        vec3 col=vec3(0.0);\n        col=mix(col, vec3(0.,0.7,0.), 1.-smoothstep(0., t*2., d/2.5));\n        tot+=col;\n    }\n    tot/=4.0;\n    \n    vec2 p=2.*q-1.;\n    p=barrel(p);\n    p.x*=iResolution.x/iResolution.y;\n    \n    p=mod(p,0.5)-.25;\n    tot=mix(tot,vec3(0.,0.1,0.0),smoothstep(0.,0.01,p.x)-smoothstep(0.01,0.02,p.x));\n    tot=mix(tot,vec3(0.,0.1,0.0),smoothstep(0.,0.01,p.y)-smoothstep(0.01,0.02,p.y));\n    \n    \n    tot=pow(clamp(tot,0.0,1.0),vec3(0.45)); \n    tot*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.8);  // vigneting\n    fragColor.xyz=tot;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3Rj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 133, 175, 293, 355], [357, 357, 398, 420, 547], [548, 548, 589, 589, 719], [722, 722, 743, 743, 830], [834, 834, 891, 891, 2039]]}
{"id": "3ds3zl", "name": "something something voronoi", "author": "public_int_i", "description": "something something voronoi", "tags": ["2d", "voronoi", "lighting", "something"], "likes": 2, "viewed": 318, "published": "Public API", "date": "1547217309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define time iTime\n\nfloat voronoi(vec2 u, float i) {\n\t#define l(i) length(fract(abs(u)*.01+fract(i*vec2(1,8))+cos(u.yx*fract(time*.02)*.07+i*8.))-.5)\n\treturn l(i);\n}\n\n#define NORMAL_PRECISION 1e-1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)*2./iResolution.x;\n    \n\tvec2 u = uv.xy*300.0;\n\tvec3 o = vec3(0.),\n\t\tlpos = vec3(sin(time*.2), 0.01, cos(time*.3)),\n\t\twpos = vec3(uv.x, 0., uv.y),\n\t\trpos = lpos-wpos,\n\t\trdir = normalize(rpos);\n\tfor (int i = 0; i < 10; i++) {\n\t\tfloat mo = float(i + 1) / 4.0,\n\t\t\tdst = voronoi(u, mo);\n\t\tvec3 nrm = normalize(vec3(voronoi(u + vec2(NORMAL_PRECISION, 0), mo) - dst, NORMAL_PRECISION*.01, voronoi(u + vec2(0, NORMAL_PRECISION), mo) - dst));\n\t\to += vec3(max(0.,1.-dst*2.)*(.2+max(0., dot(rdir, nrm))) / (1.+length(rpos)*10.));\n\t}\n\tfragColor = vec4(o+max(0.,2.-length(wpos.xz-lpos.xz)*50.), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ds3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 130, 130, 243], [276, 276, 333, 333, 965]]}
{"id": "3dsGRf", "name": "csg", "author": "caudya", "description": "csg", "tags": ["csg"], "likes": 4, "viewed": 124, "published": "Public", "date": "1547226225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient, indice de réfraction\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 90.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\nvec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = vec3(8, 10, -12);\n\nconst float eps = 0.01;\n\n//CSG objects parameters\nconst vec3     csgSphere1Pos \t= cameraTarget + vec3(-1.125, 2, 0);\nconst float    csgSphere1Radius = 1.4;\nconst vec3\t   csgSphere2Pos \t= cameraTarget + vec3(1.125, 2, 0);\nconst float\t   csgSphere2Radius = 1.4;\nconst vec3\t   csgSphere3Pos \t= cameraTarget + vec3(0, 2.5, 0);\nconst float\t   csgSphere3Radius = 0.5;\nconst vec3\t   csgSphere4Pos \t= cameraTarget + vec3(0, 2.4, -0.5);\nconst float\t   csgSphere4Radius = 0.5;\nconst vec3\t   csgCol1 \t\t\t= vec3(1.0, 0.5, 0.0); //orange\nconst vec3\t   csgCol2 \t\t\t= vec3(0.4, 1.0, 1.0); //light cyan\nconst vec3     csgCol3\t\t\t= vec3(1.0, 0.0, 1.0); //magenta\nconst vec3     csgCol4\t\t\t= vec3(5.0, 5.0, 0.0); //hyper yellow\nconst Material csgMat \t\t\t= Material(0.2, 1.0, 0.1, 90.0);\nconst int \t   csgId\t\t\t= 3;\n\n//value for grid\n\n//boo est vraie alors on prend PIXEL_SAMPLING_GRID_SIZE sinon on choisit PIXEL_SAMPLING_RANDOM \nbool boo = true;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_RANDOM = 20;\n\nstruct ShadeInfo\n{\n    vec3 shadedcol;\n    float Ks;\n};\n    \nint subObjectIdC;\n\nconst int MAX_NB_BOUNCES = 3;\n//##############################################################################################\n   \nvoid animateScene(in float time) {\n    //animate the sphere position\n\tconst float pi = 3.1415926535;\n\tconst float rs = 2.0;\n\tconst float spr = 5.0;\n\tfloat as = 2.0*pi * time /spr;\n\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0, 1, 0);\n    \n    lightPos += vec3(0.0, 10.5 + 9.5 * cos(time) - 10.0, 0.0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist * vec3(sin(time), max(sin(time*0.5), 0.0), cos(time));\n    \n}\n\n//##############################################################################################\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n \n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n\n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//##############################################################################################\n\n//cette fonction similaire à reySphere est utilisé pour la sphere 4, \n//laquelle nous souhaitons l'intersection la plus éloignée (non visible par la caméra)\nfloat raySphere4(vec3 rayPos ,vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t2  = (-b + sdi) * den;\n \n        float dir = 1.0;\n\n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t2 * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        //on prend l'intersection la plus éloignée\n        return t2;\n    }\n    \n    return 0.0;\n}\n//##############################################################################################\n\n//calcul point d'intersection entre deux sphère\nfloat raySphereIntersec(vec3 rayPos, vec3 rayDir, vec3 spos1, vec3 spos2, float srad1, float srad2, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{ \n    vec3 intersecPt1;\n\tvec3 normal1;\n    vec3 intersecPt2;\n\tvec3 normal2;\n    \n    float dist1 = raySphere(rayPos, rayDir, spos1, srad1, intersecPt1, normal1);\n    \n    float dist2 = raySphere(rayPos, rayDir, spos2, srad2, intersecPt2, normal2);\n    \n     //le rayon passe par les deux sphères (condition nécessaire d'intersection)\n    if ((dist1 > 0.0) && (dist2 > 0.0)) {\n        \n        float disS1 = distance(intersecPt1,csgSphere2Pos);\n        \n        //le point de la sphère 1 est inclu dans la sphère 2\n        if (disS1 <= csgSphere2Radius) {\n            \n            intersecPt = intersecPt1;\n            subObjectId = 1;\n            normal = normal1; \n            return dist1;\n        }\n        \n        float disS2 = distance(intersecPt2,csgSphere1Pos);\n        \n        //le point de la sphère 2 est inclu dans la sphère 1\n        if (disS2 <= csgSphere1Radius) {\n          \tintersecPt = intersecPt2;\n            subObjectId = 2;\n            normal = normal2; \t\n            return dist2;\n         } \n    }\n    \n    return -1.0;\n}\n\n//##############################################################################################\n\n\nfloat rayCSG( vec3 rayPos, vec3 rayDir, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{\n    vec3 intersecPt1;\n\tvec3 normal1;\n    vec3 intersecPt3;\n\tvec3 normal3;\n    vec3 intersecPt4;\n\tvec3 normal4;\n    int subid;\n    float dist;\n    \n \n    //on cherche si le rayon traverse l'intersection entre la sphère 1 et 2\n    float distintersec = raySphereIntersec(rayPos, rayDir, csgSphere1Pos, csgSphere2Pos, csgSphere1Radius, csgSphere2Radius, intersecPt1, normal1, subid);\n   \n    //on cherche si le rayon traverse la sphère 3\n\tfloat dist3 = raySphere(rayPos, rayDir, csgSphere3Pos, csgSphere3Radius, intersecPt3, normal3);\n    \n\n    //Si il y a une intersection avec la sphère 3 OU entre la sphère 1 et 2\n    if ((dist3 > 0.0)) {\n        //intersection avec la sphère 3\n        intersecPt = intersecPt3;\n        subObjectId = 3;\n        normal = normal3; \n        dist = dist3;\n        \n        //intersection aussi avec la sphère 1  et 2\n        if (distintersec > 0.0) {\n            float discam1 = distance(cameraPos, intersecPt1);\n       \t\tfloat discam3 = distance(cameraPos, intersecPt3);\n        \n            //on prend le point d'intersection le plus proche de la caméra\n            if ((discam3 > discam1)) {\n            \tintersecPt = intersecPt1;\n            \tsubObjectId = subid;\n            \tnormal = normal1; \n            \tdist = distintersec;\n        \t}\n        }\n    } else { \n        // intersection avec la sphère 1 et 2 uniquement\n   \t\tif (distintersec > 0.0) {     \n                intersecPt = intersecPt1;\n            \tsubObjectId = subid;\n            \tnormal = normal1; \n            \tdist = distintersec;\n        } else {\n        \treturn -1.0;\n        }\n     }\n        \n     //distance entre le point d'intersection et l'origine de la sphere4\n     float disS34 = distance(intersecPt,csgSphere4Pos);\n        \n        \n     //le point d'intersection de la sphere n'appartient pas à la sphere 4\n     if (disS34 > csgSphere4Radius) {\n            \n        // on retourne la distance\n        return dist;\n     }  \n    \n    //on calcule le point d'intersection avec la sphere 4 le plus loin\n    float dist4 = raySphere4(rayPos, rayDir, csgSphere4Pos, csgSphere4Radius, intersecPt4, normal4);\n        \n     //on calcule la distance entre le point d'intersection de la sphère 4 et les centres des autres sphères\n     float dis43 = distance(intersecPt4,csgSphere3Pos);\n     float disS41 = distance(intersecPt4,csgSphere1Pos);\n     float disS42 = distance(intersecPt4,csgSphere2Pos);\n        \n     //le point d'intersection de la sphère 4 doit être inclu dans la sphère 3 OU la sphère 1 et 2 \n     if ((dist4 > 0.0) && ((dis43 <= csgSphere3Radius) || ((disS41 <= csgSphere1Radius) && (disS42 <= csgSphere2Radius))) ) {\n          intersecPt = intersecPt4;\n          subObjectId = 4;\n          normal = normal4; \n          return dist4;\n     }\n    \n    return -1.0;\n    \n}\n\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n\n    //origine du rayon, la caméra\n    rayPos = cameraPos;\n    \n    //direction du rayon\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// trouve l'intersection la plus proche qu'à le rayon avec les objets\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, in int incId,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test la sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    //float distS = raySphere(rayPos, rayDir, csgSphere1Pos, csgSphere1Radius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n        normalI   =   normalS;\n    }\n    \n    // Test intersection avec l'objet CSG\n    vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,intersecC, normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =   distC;\n\t    intersecI =   intersecC;\n    \tnormalI   =   normalC;\n    }\n    \n   \t // Test le plan\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n       \tobjectId  =   planeId;\n       \tminDist   =     distP;\n\t   \tintersecI = intersecP;\n    \tnormalI   =   normalP;\n    }\n    \n\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\nvec3 getCSGColorAtPoint(vec3 pt)\n{\n    if (subObjectIdC == 1)\n        return csgCol1;\n    if (subObjectIdC == 2)\n        return csgCol2;\n    if (subObjectIdC == 3)\n        return csgCol3;\n    if (subObjectIdC == 4)\n        return csgCol4;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    } \n    else if (objectId == csgId) \n    {\n        objectMat = csgMat;\n        return getCSGColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowAtPoint(in vec3 I, in vec3 normalI, in Material objectMat, in vec3 L, in float Ldist)\n{\n    int object;\n    vec3 vec1, vec;\n    float dist = computeNearestIntersection(I, L, -1, object, vec1, vec);\n    if (dist<Ldist && dist>0.0) {\n        return 0.5;\n    } else {\n        return 1.0;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V, float shadowFactor)\n{    \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *  lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + shadowFactor*diffuse + shadowFactor*specular;\n\n    return phongCol;\n}\n\n//##############################################################################################\n\nvec4 RaycastAtPixelCoord(vec2 pixCoord) \n{\n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir); \n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    \n    int nbBounces = 0;\n    \n    // Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 col;\n    vec3 spec;\n        \n    do\n    {\t\n        \n    \tfloat distI = computeNearestIntersection(rayPos, rayDir, -1, objectId, intersecI, normalI);\n    \n    \t// Apply the shading to the points that are on the sphere surface and seen by the camera\n    \tif (distI <= 0.0)\n    \t{\n            \n            infos[nbBounces].shadedcol = skyCol;\n        \tinfos[nbBounces].Ks = 0.0;\n        \tbreak;\n            \n        }\n        \n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos - intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        vec3 RayRefr = 2.0 * normalI * dot(normalI, V) - V;\n        \n        \n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n        vec3 I = intersecI + normalI*eps;\n        \n        float Ldist = length(lightPos-I);\n        \n        float shadowfactor = getShadowAtPoint(I, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n       \n        col = computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor);\n        \n        infos[nbBounces].shadedcol = col;\n        infos[nbBounces].Ks = objectMat.Ks;\n        \n        //bounce from the surface towards the reflect direction of the ray\n        \n        rayDir = RayRefr;\n        \n        rayPos = I;\n        \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces-i].Ks*resCol + infos[nbBounces-i].shadedcol;\n    }\n    \n    //resCol = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor), 1);\n    \n    return vec4(resCol, 1);\n \n    //return vec4(computePhongShading(resCol, objectMat, normalI, L, R, V, shadowfactor), 1);; \n}\n\n\n//##############################################################################################\n\nvec2 noise2(vec2 location, vec2 delta) \n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        \n\t);\n}\n\n//##############################################################################################\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float time = iTime;\n    \n    animateScene(time);\n    \n    vec4 moy = vec4(0);\n    \n    if (boo == true) {\n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        \n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++)\n        {    \n            moy += RaycastAtPixelCoord(fragCoord+vec2(float(i)/float(PIXEL_SAMPLING_GRID_SIZE), float(j)/float(PIXEL_SAMPLING_GRID_SIZE))); \n    \t\t\n        }\n    }\n        \n    } else {\n        for (int i=0; i<PIXEL_SAMPLING_RANDOM ; i++)\n            moy += RaycastAtPixelCoord(fragCoord+noise2(vec2(i),vec2(10000))); \n    }\n    \n    if (boo == true) {\n        fragColor = moy/float(PIXEL_SAMPLING_GRID_SIZE*PIXEL_SAMPLING_GRID_SIZE);\n    } else {\n    \tfragColor = moy/float(PIXEL_SAMPLING_RANDOM);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2682, 2783, 2817, 2851, 3306], [3308, 3406, 3551, 3551, 4336], [4436, 4598, 4732, 4732, 5509], [5608, 5657, 5817, 5817, 6869], [6871, 6970, 7070, 7070, 9874], [9975, 10019, 10159, 10159, 11038], [11040, 11138, 11223, 11223, 12087], [12187, 12258, 12421, 12498, 13709], [13711, 13809, 13846, 13846, 13870], [13970, 14014, 14050, 14164, 14806], [14808, 14905, 14939, 14939, 15145], [15148, 15246, 15321, 15321, 15696], [15698, 15796, 15898, 15898, 16103], [16105, 16203, 16317, 16317, 16640], [16642, 16740, 16782, 16854, 19410], [19413, 19511, 19552, 19552, 19774], [19776, 19879, 19936, 19936, 20690]]}
{"id": "3dSGRh", "name": "Obsidian", "author": "bitnenfer", "description": "inspired by yx's shader (https://www.shadertoy.com/view/wsB3Rz)", "tags": ["raymarcher"], "likes": 15, "viewed": 227, "published": "Public", "date": "1548053920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 uLightDir = vec3(0.0, 1.0, 0.0);\nconst vec3 uLightColor = vec3(5.0,6.0,12.0);\nconst float uScale = 4.;\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Scene {\n    int type;\n    float dist;\n    Material material;\n};\n\nstruct DirLight {\n    vec3 dir;\n    vec3 color;\n};\n\nconst Material kNoMaterial = Material(vec3(0.0), 0.0, 0.0);\n\nmat2 Rotate(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\nvec3 Repeate(vec3 p, vec3 r) {\n//    r*=uScale;\n    return mod(p, r) - 0.5 * r;\n}\n\nMaterial MixMaterial(Material a, Material b, float m) {\n    return Material(\n        mix(a.albedo, b.albedo, m),\n        mix(a.roughness, b.roughness, m),\n        mix(a.metallic, b.metallic, m)\n    );\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 Shade(vec3 n, vec3 v, DirLight l, in Material material)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01);\n    \n    return (material.albedo * 0.3) + ((Kd * material.albedo / 3.14 + specularBRDF) * radiance * NdotL);\n}\n\nScene SceneUnion(Scene a, Scene b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nfloat Box(vec3 p, vec3 s) {\n    vec3 d = abs(p) - (s * uScale);\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// iq's\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - (h * uScale);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Ring(vec3 p, float radius) {\n    float outer = sdCappedCylinder(p, vec2(radius, 0.025));\n    float inner = sdCappedCylinder(p, vec2(radius-0.05, 1.0));\n    return max(outer, -inner);\n}\n\nScene GetOuterBox(vec3 p) {\n    p.xz *= Rotate(-iTime * .4);\n    p.xy *= Rotate(0.615472907);\n    p.yz *= Rotate(0.785398);\n    float border = 0.95;\n    float scene = Box(p, vec3(1.0));\n    float boxOut = scene;\n    float remove = Box(p, vec3(2.0, border, border));\n    remove = min(remove, Box(p, vec3(border, 2.0, border)));\n    remove = min(remove, Box(p, vec3(border, border, 2.0)));\n    scene = max(scene, -remove);\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p2.xy *= Rotate(3.14 / 2.0);\n    p3.yz *= Rotate(3.14 / 2.0);\n    float rings = 100.;\n    float ringRadius = 1.1;\n    rings = min(rings, Ring(Repeate(p, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = min(rings, Ring(Repeate(p2, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = min(rings, Ring(Repeate(p3, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = max(rings, boxOut);\n    return Scene(2, min(scene, rings), Material(vec3(3.0), 0.8, 0.0));\n}\n\nScene GetInnerContent(vec3 p) {\n    vec3 pmin = p;\n    vec3 pmax = p;\n    pmin.xz *= Rotate(-iTime * .4);\n    pmin.xy *= Rotate(0.615472907);\n    pmin.yz *= Rotate(0.785398);\n    pmax.xz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.yz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.xy *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    float clip = Box(pmin, vec3(0.85));\n    vec3 pmod = Repeate(pmax + vec3(0, iTime * 0.5, 0), vec3(0.4) * 2.0);\n    float dispSize = ((sin(p.y) + sin(p.z) + sin(p.x) + iTime * 5.0) * 0.15);\n    float scene = Box(pmod, vec3(0.1 + 0.2 * sin(dispSize + p.y * 0.19)));\n\n    scene = max(scene, clip);\n\n    return Scene(1, scene, Material(vec3(0.0, 0.0, 0.01), 0.1, 1.0));\n}\n\nScene GetInnerContent2(vec3 p) {\n    vec3 pmin = p;\n    vec3 pmax = p;\n    pmin.xz *= Rotate(-iTime * .4);\n    pmin.xy *= Rotate(0.615472907);\n    pmin.yz *= Rotate(0.785398);\n    pmax.xz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.yz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.xy *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    float clip = length(pmin)-1.1*uScale;\n    vec3 pmod = Repeate(pmax + vec3(0, iTime * 0.5, 0), vec3(0.4) * 2.0);\n    float dispSize = ((sin(p.y) + sin(p.z) + sin(p.x) - iTime * 5.0) * 0.15);\n    float scene = Box(pmod, vec3(0.2 + 0.8 * sin(dispSize - p.y * 0.19)));\n\n    scene = max(scene, clip);\n\n    return Scene(1, scene, Material(vec3(0.0, 0.01, 0.0), 0.1, 1.0));\n}\n\nScene GetFloor(vec3 p) {\n    return Scene(1, Box(p + vec3(0.0, 2.75, 0.0) * uScale, vec3(1, 1.0,1)) - 0.1, Material(vec3(.2,0,0.0), 0.3, 0.));\n}\n\nScene MixScene(Scene a, Scene b, float m) {\n    return Scene(\n        int(mix(float(a.type), float(b.type), m)),\n        mix(a.dist, b.dist, m),\n        MixMaterial(a.material, b.material, pow(m, 5.0))\n    );    \n}\n\nuniform float uFactor;\n\nScene GetScene(vec3 p) {\n    Scene scene = Scene(0, 100., kNoMaterial);\n\n    scene = SceneUnion(scene, Scene(3, 9.0 - p.y, Material(vec3(1), 1.0, 0.0)));\n    scene = SceneUnion(scene, GetOuterBox(p));\n    scene = SceneUnion(scene, MixScene(GetInnerContent2(p), GetInnerContent(p), abs(sin(0.2*iTime + p.y * 0.01))));\n    scene = SceneUnion(scene, GetFloor(p));\n\n    return scene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0,.01);\n    return normalize(GetScene(p).dist - vec3(\n            GetScene(p - e.yxx).dist,\n            GetScene(p - e.xyx).dist,\n            GetScene(p - e.xxy).dist\n        ));\n}\n\nScene RayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 80; ++i) {\n        vec3 p = (ro + rd * t);\n        Scene scene = GetScene(p);\n        if (scene.dist < .01) {\n            return Scene(scene.type, t, scene.material);\n        }\n        t += scene.dist * 0.9;\n        if (t > 200.) break;\n    }\n\n    return Scene(0, 100., kNoMaterial);\n}\n\nvec3 Trace(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.0);\n    vec3 skyColor = vec3(0.0);\n    float atten = 1.0;\n    vec3 point = ro + rd;\n    for (int i = 0; i < 2; ++i) {\n        Scene scene = RayMarch(ro, rd);\n        if (scene.type == 1) {\n            vec3 p = ro + rd * scene.dist;\n            vec3 n = GetNormal(p);\n            vec3 v = normalize(-rd);\n            DirLight l = DirLight(uLightDir, uLightColor);\n            color += vec3(1.0, 0.2, 0.2) * atten * Shade(n, v, l, scene.material);\n            rd = normalize(reflect(rd, n));\n            ro = p + rd * 0.1;\n            atten *= 0.2;\n        } else if (scene.type == 2) {\n            vec3 p = ro + rd * scene.dist;\n            vec3 n = GetNormal(p);\n            vec3 v = normalize(-rd);\n            DirLight l = DirLight(uLightDir, uLightColor);\n            color += atten * Shade(n, v, l, scene.material);\n            if (i == 0) {\n               scene = RayMarch(p + n * 0.03, n);\n                if (scene.type != 0) {\n                    color = mix(color, color * clamp(scene.dist * 10.0 / (uScale * uScale), 0.0, 1.0), 0.7);\n                }\n            }\n            break;\n        } else {\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy/iResolution.xy-.5) * ar;\n    vec3 ro = vec3(0,-0.2,-5) * uScale;\n    vec3 rd = normalize(vec3(uv, 1.2) * uScale);\n    vec3 color = vec3(0.0);\n    float mx = (iMouse.x/iResolution.x * 2.0 - 1.0) * 3.14;\n    \n    ro.xz *= Rotate(mx);\n    rd.xz *= Rotate(mx);\n\n    float offset = 0.005;\n\n    color = Trace(ro, rd);\n\n    color = mix(color, color * 0.35, max(0.0, length(2. * uv/ar)));\n\n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 380, 402, 402, 450], [451, 451, 481, 498, 532], [534, 534, 589, 589, 736], [738, 738, 802, 802, 1004], [1006, 1006, 1047, 1047, 1136], [1138, 1138, 1194, 1194, 1292], [1294, 1294, 1340, 1340, 1433], [1435, 1435, 1497, 1497, 2206], [2208, 2208, 2244, 2244, 2295], [2297, 2297, 2324, 2324, 2430], [2432, 2440, 2482, 2482, 2592], [2594, 2594, 2628, 2628, 2784], [2786, 2786, 2813, 2813, 3714], [3716, 3716, 3747, 3747, 4462], [4464, 4464, 4496, 4496, 5213], [5215, 5215, 5239, 5239, 5359], [5361, 5361, 5404, 5404, 5575], [5601, 5601, 5625, 5625, 5982], [5984, 5984, 6008, 6008, 6207], [6209, 6209, 6243, 6243, 6572], [6574, 6574, 6604, 6604, 7795], [7797, 7797, 7854, 7854, 8477]]}
{"id": "3dsGWN", "name": "Alien Cathedral", "author": "Alkama", "description": "Made live shading style :D\n(and a happy new year 2019 to you all!)", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 2, "viewed": 410, "published": "Public API", "date": "1546297460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime*.5\n#define sat(s) clamp(s, 0., 1.)\n#define spow(v, p) sat(pow(v, p))\n\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 40.;\n\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat vmin(vec3 v) { return min(min(v.x, v.y), v.z); }\n\nfloat sphere(vec3 p, float s) { return length(p) - s; }\nfloat box(vec3 p, vec3 s) { return vmax(abs(p)-s); }\n\nvec2 repeat(vec2 p, float n) { return mod(p, n) - .5*n; }\nvec3 scale(vec3 p, vec3 n) { return (p/n) * n; }\n\nstruct ray {\n  vec3 o, d;\n};\nstruct material {\n  vec3 d, s;\n  float sh;\n};\n\nfloat dist(vec3 p) {\n  vec3 sp = p;\n\n  sp.xz = repeat(p.xz, 1.5);\n  sp.y *= .25 + .05*sin(4.*cos(t)+p.z);\n\n  vec3 sp2 = sp;\n  sp2 *= 1. + .1*sin(3.*t+fract(10.*p.y+20.*p.z));\n\n  float b = box(sp, vec3(.8, 1.9,.8));\n  float ss = sphere(sp, .996+.025*sin(p.x+p.y+t*3.));\n  float ss2 = sphere(sp, .1);\n  float s = min(max(-ss, b), ss2);\n\n  float pl = p.y + 2.;\n  return min(s, pl);\n}\n\nvec2 march(ray r) {\n  float d = 0.;\n  for(int i = 0; i<MAX_ITER; i++) {\n    float h = dist(r.o+r.d*d);\n    if(h<0.0001*d || d>MAX_DIST) return vec2(d, i);\n    d+=h;\n  }\n  return vec2(d, MAX_ITER);\n}\n\nvec3 normal(vec3 p) {\n  vec2 e=vec2(0,0.01);\n  return normalize(dist(p) - vec3(dist(p-e.yxx), dist(p-e.xyx), dist(p-e.xxy)));\n}\n\nvec3 shade(vec3 p, vec3 eye, material m, vec3 light) {\n  vec3 l = normalize(light-p);\n  vec3 n = normal(p);\n  vec3 v = normalize(eye-p);\n  vec3 rf = normalize(reflect(-l, n));\n  float dotln = dot(n, l);\n  float dotrv = dot(rf, v);\n  vec3 phong;\n  if (dotln <= 0.0) { phong = vec3(0); }\n  else if (dotrv <= 0.0) { phong = m.d * dotln; }\n  else phong = m.d * dotln + m.s * pow(dotrv, m.sh);\n \n  ray r;\n  r.o = p;\n  r.d = normalize(light-p);\n  vec2 lm = march(r);\n  if(length(light-p) > lm.x) phong *= .7;\n\n  return phong;\n}\n\nray camera(vec2 uv, vec3 eye, vec3 target, float zoom) {\n  ray r;\n  r.o = eye;\n  vec3 f = normalize(target - eye);\n  vec3 s = normalize(cross(vec3(0,1,0), f));\n  vec3 u = cross(f,s);\n  r.d = normalize(f*zoom + uv.x*s + uv.y*u);\n  return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 vguv = uv * (1.0 - uv);\n  float vg = pow(20.*vguv.x*vguv.y, .5);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n  vec3 eye = vec3(0,0,0);\n  eye.xz += 4.*vec2(sin(cos(t*.02)*8.), cos(sin(t*.03)*12.));\n  vec3 target = vec3(0,-2,0);\n\n  ray r = camera(uv, eye, target, .2+.0125*sin(sin(t*.9)*3.));\n  vec2 m = march(r);\n  if(m.x>MAX_DIST) {\n    fragColor = vec4(0);\n    return;\n  }\n  \n  vec3 p = r.o+r.d*m.x;\n  \n  float halo = spow(3.*m.y/float(MAX_ITER), 3.);\n  float att =  spow(1. - m.x/(MAX_DIST), 10.);\n  vec3 light = vec3(0,1,0);\n  light.xz += 2.*vec2(sin(t*.5), cos(t));\n\n  material ma;\n  ma.d = vec3(.3,.3,1);\n  ma.s = vec3(1);\n  ma.sh = 10.;\n  material mb;\n  mb.d = vec3(.1,.4,.3);\n  mb.s = vec3(1);\n  mb.sh = 10.;\n  vec3 la = shade(p, eye, ma, light);\n  vec3 lb = shade(p, eye, mb, -light);\n  vec3 color = att * (la+lb);\n  color *= .1+.9*halo;\n\n  color *= vec3(vg);\n  fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 161, 161, 195], [196, 196, 216, 216, 250], [252, 252, 283, 283, 307], [308, 308, 335, 335, 360], [362, 362, 392, 392, 419], [420, 420, 448, 448, 468], [546, 546, 566, 566, 926], [928, 928, 947, 947, 1126], [1128, 1128, 1149, 1149, 1255], [1257, 1257, 1311, 1311, 1778], [1780, 1780, 1836, 1836, 2021], [2023, 2023, 2080, 2080, 3069]]}
{"id": "3dsGzS", "name": "[TWITCH] Double-mod Twisterooney", "author": "evvvvil", "description": "Shader showdown practice session 001: Making a shader in 25 minutes from memory.\nPractising live on TWITCH every tuesdays around 20:30 UK time.\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["time", "demoscene", "shader", "modulo", "double", "limit", "live", "twist", "battle", "shadershowdown", "coding", "twitch", "showdown"], "likes": 9, "viewed": 561, "published": "Public API", "date": "1546708499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coder battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:00 UK time I practise live on TWITCH.\n// This is the result of session 001.\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n// (Apologies for the lack of comments, next sessions will be commented...)\n\nvec2 sc,e=vec2(.00035,-.00035);float t,tt; vec3 newPos;\n\nfloat mx(vec3 p){return max(max(p.x,p.y),p.z);}\nfloat bo(vec3 p,vec3 r){return mx(abs(p)-r);}\n\nvec2 fb( vec3 p)\n{\n  vec2 h,t=vec2(.8*bo(p,vec3(1,.5,6)),5);\n  t.x=min(t.x,.8*bo(p-vec3(1,0,0),vec3(.2,1,1.5)));\n  t.x=min(t.x,.8*bo(p+vec3(1,0,0),vec3(.2,1,1.5)));\n  h=vec2(.8*bo(abs(p)-vec3(.25,0,1.7),vec3(.15,1,1.4)),3);\n  t=(t.x<h.x)?t:h;\n  return t;\n}\n\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r));}\n\nvec2 mp( vec3 p)\n{\n  vec2 t;\n  p.z=mod(p.z+tt*10.,50.)-25.;//clones it along z\n  p.yx*=r2(sin(p.z*0.05+tt)*2.);//rotate it along z\n  newPos=p;\n  newPos.z=mod(p.z+tt*10.,25.)-12.5;\n  float att=clamp(length(p)-1.5,3.,13.);\n  for(int i=0;i<4;i++){\n    newPos=abs(newPos)-vec3(0.5+att*0.3,0.5+att*0.1,2);\n    newPos.yx*=r2(abs(cos(p.z*0.05*float(i))));\n  }\n  t=fb(newPos);\n  t.x=max(t.x,bo(p,vec3(15,15,23)));\n  return t;\n}\n\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>60.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>60.) t.x=0.;\n  return t;\n}\n\nfloat noise(vec3 p){\n  \tvec3 ip=floor(p);p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 sky(vec3 rd){return clamp(vec3(.4,.4,.5)-rd.y*.3,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  tt=mod(iTime,100.);\n  vec3 ro=vec3(0,0,-10),\n  cw=normalize(vec3(sin(tt)*10.,0,cos(tt)*3.)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=normalize(mat3(cu,cv,cw)*vec3(uv,.5)),\n  co,fo,ld=normalize(vec3(-.3,0,.3));co=fo=sky(rd);\n  sc=tr(ro,rd);t=sc.x;\n\n  if(t>0.){\n    vec3 po=ro+rd*t,\n    no=normalize(e.xyy*mp(po+e.xyy).x+\n    e.yyx*mp(po+e.yyx).x+\n    e.yxy*mp(po+e.yxy).x+\n    e.xxx*mp(po+e.xxx).x),al=vec3(.5);\n    if(sc.y<5.) al=vec3(1,.5,0);\n    //LIGHTING MICRO ENGINE\n    float dif=max(0.,dot(no,ld)),\n    aor=t/50.,\n    ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),\n    spo= exp2(5.0+3.0*noise(newPos/vec3(.2,.4,.6))),\n    fresnel=pow(1.+dot(no,rd),4.);\n    vec3 sss=vec3(.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),\n    spec=vec3(2)*pow(max(0.,dot(no,normalize(ld-rd))),spo)*spo/32.;\n    co=mix(spec+al*(0.8*ao+.2)*(dif+sss),sky(rd),fresnel);\n    co=clamp(co,0.,1.);\n    co=mix(co,fo,1.-exp(-.00002*t*t*t));\n  }\n  fragColor = vec4(pow(co,vec3(0.45)),1);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[705, 869, 886, 886, 916], [917, 917, 941, 941, 962], [964, 964, 982, 982, 1220], [1222, 1222, 1239, 1239, 1283], [1285, 1285, 1303, 1303, 1704], [1706, 1706, 1734, 1734, 1898], [1900, 1900, 1920, 1920, 2167], [2169, 2169, 2187, 2187, 2231], [2233, 2233, 2290, 2290, 3434]]}
{"id": "3dX3Wl", "name": "practice-06", "author": "kiyamada96", "description": "day3-1", "tags": ["cellnoise"], "likes": 2, "viewed": 77, "published": "Public", "date": "1547733517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) \n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n    float n=8.;\n    vec3 color=vec3(0.);\n    vec2 fst=fract(uv*n);\n    vec2 ist=floor(uv*n);\n    float m_dist=1.;\n    \n    for(int y=-1;y<=1;y++)\n    {\n \t\tfor(int x=-1;x<=1;x++)\n    \t{\n        \tvec2 neighbor=vec2(x,y);  \n            vec2 point=random2(ist+neighbor);\n            point=0.5+0.5*sin(iTime*5.+6.2831*point);\n            vec2 diff=neighbor+point-fst;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n    \t}\n    }\n    \n    color+=m_dist;\n\n    color+=1.-smoothstep(0.,0.1,m_dist);\n    \n    fragColor= vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dX3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 118], [120, 120, 177, 177, 769]]}
{"id": "3dXGzs", "name": "Temporal Highpassed TPDF Dither", "author": "TheSandvichMaker", "description": "Create TPDF noise by subtracting the previous frame's noise from the current frame's noise for a 1 tap highpass.\nTry pausing the shader to see how the regular and highpassed versions look identical when not in motion.\n\nUsing iq's integer hash II.", "tags": ["dither", "bluenoise", "highpass", "whitenoise", "temporal", "tpdf"], "likes": 5, "viewed": 203, "published": "Public", "date": "1547150963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Single pole highpassed triangular dither.\n// Inspired by: https://www.airwindows.com/pauldither/\n\n// EDIT 2: Added blue noise for fun\n// Regular bluenoise dither is clearly perceptually superior,\n// but the difference between highpassed noises is much more subtle.\n\n\n// change the simulated bit depth here\n#define BIT_DEPTH 2\n\n// uncomment this to get RGB dither\n//#define CHROMA\n\n// uncomment this to use the video as demo\n//#define DEMO_VIDEO\n\n\n/*\n\tthe gradient demo is laid out like\n\twhite noise\n\thighpassed white noise\n\tblue noise\n\thighpassed blue noise\n\n\twhile the video demo is laid out like\n\twhite noise | highpassed white noise\n\tblue noise  | highpassed blue noise\n*/\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define remap(x, a, b) (((x) - (a)) / ((b) - (a)))\n\n\n// iq's integer hash II\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n// Divvy up the 1024x1024 noise for demonstration purposes\n// however you get animated blue noise is fine so long as you can\n// reliably get the previous frame's noise. Using golden ratio to animate the noise\n// didn't seem to play nice with highpass though.\n#define NOISE_TILE_SIZE 64\nvec3 bluenoise(int idx, ivec2 coord)\n{\n    const int s = NOISE_TILE_SIZE;\n    idx %= 1024 / s;\n\tcoord = ivec2(idx * s, (idx / s) * s) + coord % s;\n    return texelFetch(iChannel0, coord, 0).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // demo image\n#ifdef DEMO_VIDEO\n    vec3 col = texture(iChannel1, uv).rgb;\n#else\n    vec3 col = vec3(uv.x);\n#endif\n\t\n    // (2^8)-1 = 255, etc.\n    const float lsb = exp2(float(BIT_DEPTH)) - 1.0;\n    \n    // generate one noise using current frame as seed,\n    // and one noise using previous frame as seed.\n    vec3 n1 = hash(uvec3(fragCoord.xy, iFrame));\n    vec3 n2 = hash(uvec3(fragCoord.xy, iFrame-1));\n    \n    vec3 b1 = bluenoise(iFrame  , ivec2(fragCoord));\n    vec3 b2 = bluenoise(iFrame-1, ivec2(fragCoord));\n    \n    vec3 dither;\n    vec3 uni;\n    if (uv.y > 0.5)\n    {\n#ifdef DEMO_VIDEO\n        bool split = uv.x < 0.5;\n#else   \n        bool split = uv.y > 0.75;\n#endif\n        uni = n1;\n    \tdither = split ? \n            // normal tpdf\n            n1 + n2 - 1.0 :\n        \t// highpass tpdf\n        \tn1 - n2;\n    }\n    else \n    {\n#ifdef DEMO_VIDEO\n        bool split = uv.x < 0.5;\n#else   \n        bool split = uv.y > 0.25;\n#endif\n        // EDIT 3: fixed edgecase solution for blue noise,\n        // which was lerping to uniform white noise instead\n        // of uniform blue noise.\n        uni = b1;\n    \tdither = split ? \n            // normal tpdf\n            b1 + b2 - 1.0 :\n        \t// highpass tpdf\n        \tb1 - b2;\n    }\n    \n    // EDIT 1: added hornet's edgecase solution for completeness\n    const float lobit = 0.5 / lsb;\n    const float hibit = (lsb - 0.5) / lsb;\n    vec3 lo = saturate(remap(col, vec3(0.0), vec3(lobit)));\n    vec3 hi = saturate(remap(col, vec3(1.0), vec3(hibit)));\n    dither = mix(uni - 0.5, dither, min(lo, hi));\n    \n#ifndef CHROMA\n    dither = vec3(dither.r);\n#endif\n        \n    // apply dither\n    col += dither / lsb;\n    \n    // quantise\n    col = round(col * lsb) / lsb;\n\n    // output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 877, 899, 899, 1032], [1035, 1321, 1359, 1359, 1517], [1520, 1520, 1577, 1577, 3410]]}
{"id": "3s23DD", "name": "Shiny Bubbles", "author": "xot", "description": "Baby's First Ray Marcher — This is my first attempt at making anything \"3D\" in a shader. I am indebted to BigWIngs/@The_ArtOfCode for giving me the nudge I needed to get started.", "tags": ["raymarching", "demoscene", "demo", "mirror", "atari", "xanth"], "likes": 4, "viewed": 220, "published": "Public", "date": "1548923578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//      ______   _\n//     / __/ /  (_)__  __ __\n//    _\\ \\/ _ \\/ / _ \\/ // /\n//   /___/_//_/_/_//_/\\_, /\n//               ___ /___/ __   __   __\n//              / _ )__ __/ /  / /  / /__ ___\n//             / _  / // / _ \\/ _ \\/ / -_|_-<\n//            /____/\\_,_/_.__/_.__/_/\\__/___/\n//\n//\tcopyright (c) 2019, John \"xot\" Leffingwell\n//  Creative Commons License (CC BY-NC-SA 3.0)\n//\n//\tBased on the \"Shiny Bubbles\" Atari ST demo\n//\tcreated by Xanth FX (released April, 1987)\n//\thttps://www.pouet.net/prod.php?which=14335\n//\n//\tThanks to Martijn Steinrucken for a helpful\n//\tand inspiring ray marching tutorial series.\n//\thttps://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define ANIM_SPEED .5\n#define MAX_BOUNCES 9\n#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .01\n#define PI 3.14159265\n\n#define bias(b,x) pow(x, log(b)/log(0.5))\n#define boxstep(a,b,x) clamp( ((x)-(a))/((b)-(a)) ,0. ,1.)\n\nstruct material \n{\n    vec3  color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float gloss;\n};\n    \nstruct sphere \n{\n    vec3  center;\n    float radius;\n    int   material;\n};\n\nstruct plane \n{\n    vec4 normal;\n    int  material;\n};\n\nstruct light \n{\n    vec3  position;\n    vec3  color;\n    float intensity;\n};\n\nstruct raysample\n{\n    float dist;\n    vec3  point;\n    int   material;\n    vec3  color;\n};\n\n    \nmaterial M[3];\nplane P[2];\nsphere S[4];\nlight L[1];\n\nvec3  fogColor;\nfloat fogDist;\n\nfloat camFocalLength;\nfloat camPan;\nfloat camTilt;\nvec4  camMove;\n\nvoid Init() \n{\n     //\tMaterials\n    M[0] = material(vec3(1,1,1), 0.0, 0.0, .75, 1.0);\t//\tMirror Balls\n    M[1] = material(vec3(1,1,1), 0.7, 0.4, 0.0, 1.0);\t//\tXOT logotype\n    M[2] = material(vec3(1,1,1), 0.7, 0.8, 0.4, 1.0);\t//\tCheckerboard\n    \n    //\tPlanes\n\tP[0] = plane(vec4(normalize(vec3(0.0, 1.0, 0.0)), -1.5), 1);\n    P[1] = plane(vec4(normalize(vec3(0.0,-1.0, 0.0)), -8.0), 2);\n    \n    //\tSpheres\n    S[0] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[1] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[2] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[3] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    \n    //\tLights\n    L[0] = light(vec3(0, 5, 0), vec3(1.0,1.0,1.0), 1.0);\n    \n    //\tFog\n\tfogColor = vec3(0.35);\n\tfogDist = MAX_DIST;\n    \n    //  Camera\n    camFocalLength = 1.3;\n    camPan = radians(15.0);\n    camTilt = radians(40.0);\n    camMove = vec4(-1.0, 3.0,-4.0, 1.0);\n}\n\nfloat Xor(float a, float b) \n{\n    return a*(1.-b)+b*(1.-a);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p,n.xyz)-n.w;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) \n{\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdXOT(vec3 p, float r) {\n    //\tXOT\n    float dist = MAX_DIST;\n    vec3 a,b;\n        \n    //\tX\n    a = vec3(0.2, 0.0, 0.2);\n    b = vec3(0.4, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    a = vec3(0.4, 0.0, 0.2);\n    b = vec3(0.2, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    //\tO\n    dist = min(dist, sdTorus(p-vec3(0.575, 0.0, 0.3), vec2(0.1, r)));\n\n    //\tT\n    a = vec3(0.75, 0.0, 0.4);\n    b = vec3(0.95, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    a = vec3(0.85, 0.0, 0.2);\n    b = vec3(0.85, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n    \n    return dist;\n}\n\nfloat sdChecked(vec3 p) {\n    p = 2.0 * abs(mod(p, 1.0) - 0.5);\n\treturn Xor(p.x, Xor(p.y, p.z));\n}\n\n\nraysample GetDist(vec3 p) \n{\n    //\tReset Distance & Material\n    raysample d = raysample(MAX_DIST, p, 0, vec3(1));\n    \n    //\tDo Spheres\n    for (int i=0; i<S.length(); i++) \n    {\n        float dS = sdSphere(p-S[i].center, S[i].radius);\n        if (dS < d.dist) {\n            d.dist = dS;\n            d.material = S[i].material;\n        }\n    }\n    \n    //\tDo Planes\n    for (int i=0; i<P.length(); i++) \n    {\n        float dP = sdPlane(p, P[i].normal);\n        if  (dP < d.dist) {\n            d.dist = dP;\n            d.material = P[i].material;\n        }\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    raysample d = GetDist(p);\n    \n    vec2 e = vec2(.01, 0);\n    vec3 n = d.dist - vec3(\n        GetDist(p-e.xyy).dist,\n        GetDist(p-e.yxy).dist,\n        GetDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nraysample RayMarch(vec3 rO, vec3 rD, int bounces, vec3 col) \n{\n    //\tSet Distance to Origin\n    raysample dO = raysample(0., rO, 0, col);\n    \n    for (int i=0; i<MAX_STEPS; i++) \n    {\n        //\tStep Forward\n        vec3 p = rO+dO.dist*rD;\n        raysample dS = GetDist(p);\n        dO.dist += dS.dist;\n        dO.point = p;\n        dO.material = dS.material;\n        \n        //\tOn surface? Can we stop?\n        if (dS.dist<SURF_DIST) {\n            //\tSurface has been hit.\n            //\tIs it a mirror? Can we bounce?\n            if (dO.material == 0 && bounces > 0) {\n                //\tReflect ray\n                rO = rO+dO.dist*rD;\n                rD = reflect(rD, GetNormal(rO));\n                rO = rO-dO.dist*rD;\n                //\tNudge ray away from surface\n                dO.dist += 2.0*SURF_DIST;\n                //\tPick up some color\n                dO.color *= M[dO.material].specular + M[dO.material].color * M[dO.material].diffuse;\n                bounces--;\n            } else {\n                break;\n            }\n        }\n        //\tTired of marching? Can we stop?\n        if (dO.dist>MAX_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetLight(vec3 point, vec3 incident, int mat, vec3 col) \n{\n    //\tLight Accumulator\n    vec3 lightTotal = vec3(0);\n    \n    for (int i=0; i<L.length(); i++) \n    {\n        //\tSurface Normal\n    \tvec3 normal = GetNormal(point);\n        \n        //\tLight Vector\n    \tvec3 light = L[i].position - point;\n        float d = length(light);\n        light = normalize(light);\n    \n        //\tBase Light\n        float lightFalloff = 1.0;//(d * d);\n        vec3 lightBase = col * L[i].color * L[i].intensity / lightFalloff;\n        \n        //\tAmbient Component\n        lightTotal += lightBase * M[mat].color * M[mat].ambient;\n\n        //\tTest for Shadows\n        raysample s = RayMarch(point+normal*SURF_DIST*2., light, 0, vec3(0));\n        \n        //\tNot In Shadow?\n        if (s.dist > d) \n        {\n\t\t    //\tDiffuse Component\n            lightTotal += lightBase * M[mat].color * M[mat].diffuse * max(dot(normal, light), 0.);\n\n            //\tSpecular Component\n            lightTotal += lightBase * M[mat].specular * pow(max(dot(reflect(incident, normal), light), 0.), M[mat].gloss);\n        }\n    }\n    return lightTotal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Init();\n    \n    //\tNormalize UV\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    //\tAnimate Spheres Along 3-Petal Rose\n    for (int i=0; i<4; i++) {\n        float phi = (float(i)*PI/4.) + ANIM_SPEED * iTime;\n        float rad = 4.;\n        S[i].center = rad * vec3(cos(3.*phi)*sin(phi), 0.0, cos(3.*phi)*cos(phi));\n    }\n\t\n    //\tOrient Camera\n    mat4 mPan = mat4(cos(camPan), 0.0,-sin(camPan), 0.0,\n                     0.0,         1.0, 0.0,         0.0,\n                     sin(camPan), 0.0, cos(camPan), 0.0,\n                     0.0,         0.0, 0.0,         1.0);\n    \n    mat4 mTilt = mat4(1.0, 0.0,          0.0,          0.0,\n                      0.0, cos(camTilt), sin(camTilt), 0.0,\n                      0.0,-sin(camTilt), cos(camTilt), 0.0,\n                      0.0, 0.0,          0.0,          1.0);\n    \n    mat4 mMove = mat4(1.0, 0.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, 0.0,\n                      camMove.x, camMove.y, camMove.z, 1.0);\n    \n    mat4 mCamera = mMove * mPan * mTilt;\n    \n    //\tCreate Camera Ray\n    vec4 rO = vec4(0.0, 0.0, -camFocalLength, 1.0);\n    vec4 rD = normalize(vec4(uv.x, uv.y, 0.0, 1.0) - rO);\n    rO = mCamera * rO;\n    rD = mCamera * rD;\n    \n    //\tMarch Through Geometry\n    raysample d = RayMarch(rO.xyz, rD.xyz, MAX_BOUNCES, vec3(1));\n    \n    //\tShade Point of Intersection\n    vec3 color = GetLight(d.point, rD.xyz, d.material, d.color);\n    \n    //\tXOT Texture\n    if  (d.material == 1)\n    {\n        //\tScale\n        float scale = 0.17;\n\t\t\n        //\tTranslate\n        vec3 translate = ANIM_SPEED * iTime * vec3(0,0,-2./PI);\n        \n        vec3 point = fract(scale*d.point+translate);\n        point.y = 0.0;\n        point = mod(point, vec3(1.0, 1.0, 0.5));\n\t\t\n        //\tXOT\n        float rad = 0.017;\n        float dist = sdXOT(point, rad);\n        \n\t\t//\tFilter Texture\n        float f = scale * fwidth(d.dist);\n        dist = smoothstep(rad-f, rad+f, dist);\n        \n        //\tBlue on White\n        color *= mix(vec3(0,0.45,0.68), vec3(1), dist);\n    }\n    \n    //\tCheckerboard Texture\n    if (d.material == 2)\n    {\n        //\tScale\n        float scale = 0.075;\n\t\t\n        //\tTranslate\n        vec3 translate = ANIM_SPEED * iTime * vec3(0,0,-4./PI);\n        \n        //\tCheckerboard\n        vec3 point = scale * d.point + translate;\n        float dist = sdChecked(point);\n        \n        //\tFilter Texture\n        float f = scale * fwidth(d.dist);\n        f *= step(0.1, f);\n        dist = smoothstep(0.5-f, 0.5+f, dist);\n        \n        //\tRed and Yellow\n        color *= mix(vec3(1.0,0.19,0.23), vec3(1.0,1.0,.76), dist);\n    }\n    \n    //\tApply Fog\n    color = mix(color, fogColor, bias(0.3, boxstep(0., fogDist, length(d.point))));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23DD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1480, 1494, 1512, 2367], [2369, 2369, 2399, 2399, 2431], [2433, 2433, 2464, 2464, 2495], [2497, 2497, 2530, 2530, 2553], [2555, 2555, 2606, 2606, 2777], [2779, 2779, 2811, 2811, 2882], [2884, 2884, 2914, 2925, 3516], [3518, 3518, 3543, 3543, 3616], [3619, 3619, 3647, 3680, 4206], [4208, 4208, 4233, 4233, 4449], [4451, 4451, 4513, 4543, 5608], [5610, 5610, 5672, 5697, 6732], [6734, 6734, 6791, 6791, 9610]]}
{"id": "3s23zz", "name": "More Accurate Ellipse Normal", "author": "scratch13764", "description": "An easy and fairly accurate way to calculate the surface normal for an ellipse without needing a perfect SDF. Can be used with ellipsoids using \"revolution\" from: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n", "tags": ["normal", "ellipsoid", "ellipse"], "likes": 3, "viewed": 164, "published": "Public", "date": "1548016212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* IGNORE THE STEP BY STEP THINGY BELOW IT'S WRONG GIVE ME SOME TIME TO FIX IT\nHow to calculate the noral of an ellipse using my method:\n   1.) Start by finding the point on the ellipse where you want to calculate the normal\n   2.) Then,\"stretch\" the scene to make the ellipse into an oval:\n         - StretchedSceneHeight *= EllipseHeight/EllipseWidth;\n         - Similar to how one might fix an aspect ratio\n   3.) Now that you have your point on a circle with rescaled coordinates, find the \n       angle from the center of the circle to the point on the surface.\n         - Let vec2 a be the point on the surface, and vec2 o is the center of the circle\n         - the formula to find the angle is atan(( a.x - o.x ) / ( a.y - o.y ))\n         - See: https://www.youtube.com/watch?v=TTom8n3FFCw by Brian McLogan\n   4.) Now that you have this angle, you can forget about the scaled coordinates from earlier\n       and go back to the nonscaled original ellipse. Let's have the angle from earlier stored\n       in a float, let's call it \"t\".\n   5.) The next step is to take the width and height of the ellipse and add a certain number,\n       it doesn't matter what number just as long as it's above 0. In this case let's call it \"i\"\n       Now take the original angle \"t\" and find the second point. We'll call this point vec2 b. \n       The way to find this point is basically the opposite of what we did to find angle a. \n       First, set b to vec2(sin(t), cos(t)) next multiply b by the width and height of the \n       larger ellipse to get: \n       vec2 b = vec2(sin(t) * (w + i), cos(t) * (h + i));\n   6.) The final step is simply to get the normal of the line between a and b in a new vector,\n       let's call it \"n\":\n       vec2 n = normalize(a - b);\n\nWhy this is a useful method:\n   1.) It is very simple and easy to calculate, meaning it is very fast.\n   2.) It's much more accurate than simply using a normal from a stretched sphere\n   3.) It can be used along with revoluton from 2D to 3D to calculate ellipsoid normals\n   4.) In situations like raytracing, where you don't have SDF's to get normals,\n       this is a great way to get a normal without needing an SDF of any sort.\n\n\nNote that the red line is the standard, highly inaccurate normal and the black line\nis my improved normal. The code in this shader is not a great implementation of my\nmethod because it had to be modified for the visual comparison. The math is essentially\nthe same I just skipped the last step of actually calculating the normal.\n*/\n#define H .8\n#define W .5\n\nfloat Ellipse (vec2 p, float w, float h)\n{\n    if (length(vec2(p.x/w,p.y/h)) <= .5)\n        return 1.;\n    else return 0.;\n}\n\nvec2 EllipsePoint (float t, float w, float h) //Point on an ellipse at a certain angle, stretched circle\n{\n    return vec2(sin(t)*w / 2., cos(t)*h / 2.);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b ) //Line segment SDF made by Inigo Quilez (Thanks!)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 u, in vec2 o )\n{\n    vec2 p = (o - .5*iResolution.xy)/iResolution.y;\n    vec4 c = vec4(.5);\n    \n    vec2 pw = 2. / iResolution.xy;\n    \n    \n    //Ellipse Normal Calculations and drawing\n    float t = iTime*.5;\n    vec2 a = EllipsePoint (t, W, H);\n    vec2 b = EllipsePoint (t, W + .2, H + .2); //My original incorrect normal\n    vec2 d = a + normalize(a * 2.)*.1;\n    vec2 e = a + normalize(EllipsePoint(t,H,W))*.1; //Correct normal - thanks IQ!\n    if ( sdLine(p, a, d) <= .005) c = mix(c, vec4(1,0,0,0), .5);//bad stretched circle normal\n    if ( sdLine(p, a, e) <= .005) c = mix(c, vec4(0), .5); //Much better normal made by expanding the ellipse evenly\n    \n    c = mix (c, vec4(.8), Ellipse (p, W + pw.x, H + pw.y)); //Antialaising...?\n    c = mix (c, vec4(1), Ellipse (p, W, H));\n    \n    \n    \n    u = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s23zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 2553, 2595, 2595, 2677], [2679, 2679, 2785, 2785, 2834], [2836, 2836, 2926, 2926, 3036], [3038, 3038, 3079, 3079, 3878]]}
{"id": "3s2GR1", "name": "[Ese] ray marching", "author": "Eseris", "description": "ray marching", "tags": ["raymarching"], "likes": 1, "viewed": 164, "published": "Public API", "date": "1548158730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POTATO_COMPUTER\n\n#ifdef POTATO_COMPUTER\nconst int MARCHING_STEPS = 160;\nconst int ALIASING_STEPS = 1;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-2;\n#else\nconst int MARCHING_STEPS = 200;\nconst int ALIASING_STEPS = 2;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 40.;\nconst float EPSILON = 1e-3;\n#endif\n\nstruct Light {\n\tvec3 iamb; // ambient intensity\n\tvec3 idiff; // diffuse intensity\n\tvec3 ispec; // specular intensity\n\tvec3 pos;\n\tfloat shininess;\n};\n\nstruct Material {\n\tvec3 amb; // ambient constant\n\tvec3 diff; // diffuse constant\n\tvec3 spec; // specular constant\n};\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n    return mod(p, s) - .5 * s;\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    \n    {\n\t\tvec3 q = p;\n        q.yz *= rot(.2 * cos(iTime));\n\t\tq.zx *= rot(sin(.34* iTime));\n        q.z -= 3. * iTime;\n    \td = sdBox(repeat(q, vec3(5.)), vec3(1.));\n        d -= .1;\n    }\n       \n    //d = max(d, p.y);\n\treturn d;\n}\n\nvec3 mapGradient(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\nfloat rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {\n\tfloat depth = start;\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tfloat dist = map(camPos + depth * rayDir);\n\t\tif(dist < EPSILON) return depth;\n\t\tdepth += dist;\n\t\tif(dist >= end) return end;\n\t}\n\treturn end;\n}\n\nvec3 rayDirection(float camAngle, vec2 coord) {\n\tvec2 uv = (coord - .5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2. / tan(radians(camAngle) / 2.);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\nvec3 applyLight(Material mat, Light light, vec3 p, vec3 eye) {\n\tvec3 n = mapGradient(p);\n\tvec3 l = normalize(light.pos - p);\n\tvec3 v = normalize(eye - p);\n\tvec3 r = reflect(-l, n);\n\n\t// ambient lighting\n\tvec3 col = mat.amb * light.iamb;\n\n\t// diffuse lighting\n    if(dot(l, n) > 0.)\n\t\tcol += mat.diff * light.idiff * dot(l, n);\n\n\t// specular lighting\n    if(dot(r, v) > 0.)\n\t\tcol += mat.spec * light.ispec * pow(dot(r, v), light.shininess);\n    \n    return col;\n}\n\nvec3 processLight(vec3 eye, vec3 p) {\n\tMaterial mat;\n\tmat.amb  = vec3(.2);\n\tmat.diff = vec3(.7, .3, .3); \n\tmat.spec = vec3(1.);\n\n\tLight light;\n\tlight.iamb = vec3(.5, .6, .7);\n\tlight.idiff = vec3(.5);\n\tlight.ispec = vec3(.4);\n\tlight.pos = vec3(2., 5., 0.);\n\tlight.shininess = 6.;\n\n\tvec3 col = applyLight(mat, light, p, eye);\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2. - .5;\n            vec3 camPos = vec3(0., 0., 4.);\n            vec3 dir = rayDirection(90., (fragCoord + offset) / iResolution.xy);\n            float depth = rayProcess(camPos, dir, MIN_DIST, MAX_DIST);\n\n            vec3 col = vec3(0.);\n            if(depth < MAX_DIST - EPSILON) {\n                col = processLight(camPos, camPos + depth * dir);\n            }\n            \n            // fog\n            col *= pow(smoothstep(MAX_DIST, 10., depth), 2.);\n            \n            // gamma\n            tot += pow(col, vec3(1. / 1.7));\n        }\n    }\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2GR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[620, 620, 639, 639, 688], [690, 690, 728, 728, 758], [760, 760, 789, 789, 879], [881, 881, 910, 910, 943], [945, 945, 964, 964, 1220], [1222, 1222, 1248, 1248, 1421], [1423, 1423, 1491, 1491, 1701], [1703, 1703, 1750, 1750, 1904], [1906, 1906, 1968, 1968, 2368], [2370, 2370, 2407, 2407, 2708], [2711, 2711, 2766, 2766, 3570]]}
{"id": "3s2GWR", "name": "Menger sponge Raymarched", "author": "Myro", "description": "a study on rendering 3D fractals with a basic raymarching renderer (menger sponge)", "tags": ["3d", "raymarching", "fractal", "color", "animated", "menger", "orange", "sponge", "render"], "likes": 1, "viewed": 135, "published": "Public", "date": "1548610796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// controls : click and drag to navigate\n\n// base raymarching rendering thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n// raymarching primitives distance functions\n// https://www.shadertoy.com/view/Xds3zN\n\n// fractal by\n// http://www.iquilezles.org/www/articles/menger/menger.htm\n\n\n#define MARCHINGITERATIONS 128\n#define SMALLESTSTEP 0.1\n#define MARCHINGSTEP 0.5\n\n#define DISTANCE 3.0\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.0,0.10,0.20) );\n}\n\n// distance function for a box\n// input p : - the current path being traced\n// input b : - box vector (width/2, heigth/2, depth/2)\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// distance function for a tri-cross\n// input p : - the current path being traced\nfloat tricross( in vec3 p )\n{\n    // dividing by 0 to have an infinite value\n  \tfloat da = box(p.xyz,vec3(1.0/0.0,1.0,1.0));\n  \tfloat db = box(p.yzx,vec3(1.0,1.0/0.0,1.0));\n  \tfloat dc = box(p.zxy,vec3(1.0,1.0,1.0/0.0));\n  \treturn -min(da,min(db,dc));\n}\n\n// MAPPING FUNCTION ... \n// returns the distance of the nearest object in the direction p on the x coordinate \n// and the color on the y coordinate\nvec2 map( in vec3 p )\n{\n    //p = fract(p); \n   \tfloat d = box(p,vec3(1.0));\n\n   \tfloat s = 1.0;\n    float color=0.0;\n   \t// iterations for the fractal effect\n   \tfor( int m=0; m<3; m++ )\n   \t{\n        // stuff, idk\n\t\tvec3 a = mod( p*s, 2.0 )-1.0;      \n      \t// scaling factor (smaller at each iteration)\n      \ts *= 5.0;\n\t\t// moving the cross \n       \tvec3 r = 1.0 - 4.0 * abs(a) * (1.0+cos(iTime)*0.1);\n        \n        // scaling and moving the cross, does the funky animation part\n        r += vec3(cos(iTime*0.2), -sin(iTime*0.3), sin(iTime*0.5));\n\t\t\n        // scaling the cross\n      \tfloat c = -tricross(r)/s;\n\n\t\tcolor = 0.1;\n      \tif( c>d )\n      \t{\n      \t\td = c;        \n      \t\tcolor += 80.0*c* (float(m));\n      \t}\n    }\n\n   \treturn vec2(d,color);\n}\n\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHINGITERATIONS; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tvec2 dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHINGSTEP * dist.x;\n        c += dist.y;\n        if (dist.y < SMALLESTSTEP) break;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotAngle = iTime/3.0 + 6.28*iMouse.x / iResolution.x;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    \n    //camera position (rays origin)\n    float camDist = DISTANCE * iMouse.y / iResolution.y;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tvec2 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2GWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 432, 508, 508, 551], [552, 552, 576, 576, 685], [687, 818, 847, 847, 938], [940, 1022, 1051, 1098, 1275], [1277, 1425, 1448, 1469, 2190], [2193, 2335, 2372, 2444, 2825], [2827, 2827, 2884, 2934, 4010]]}
{"id": "3sB3R1", "name": "practice-09", "author": "kiyamada96", "description": "day6", "tags": ["movingorb"], "likes": 5, "viewed": 86, "published": "Public", "date": "1548086572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n   \tvec3 destColor=vec3(0.);\n    for(float i=0.0;i<5.0;i++)\n    {\n    \tfloat j=i+1.0;\n        vec2 q=p+CS(iTime*j)*0.7;\n        destColor+=0.04/length(q);\n    }\n    fragColor=vec4(destColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sB3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 365]]}
{"id": "3sBGWW", "name": "ice cube tray with subsurface", "author": "mds2", "description": "modification of an older shader, just to be able to show subsurface / no subsurface effects without reloading.", "tags": ["inessaith", "sithing", "hallere", "yourinthat", "thearold", "thersing", "ithearion"], "likes": 2, "viewed": 484, "published": "Public API", "date": "1548800240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLOCKSIZE 0.7\n\n#define EXTENT 15.0\n\n#define MULTI_SAMPLE 2 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nfloat waffle_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n    float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.173, 0.131)), 1.0);\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - vec3(0.05, 0.1 + 0.5 * samp, 0.05));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    float distort = 0.85 + 0.65 * dot(uv, uv);\n    vec3 ray_dir = normalize(vec3(uv * distort - vec2(0.0, 0.1), -0.2));\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, 0.8, -0.6,\n             0.0, 0.6, 0.8) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    float mouseness = step(iMouse.y, fragCoord.y);\n    return vec4(subsurface * mouseness, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.025 * iTime);\n    float s_theta = sin(0.025 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": "MtsGDr", "previewfilepath": "https://soundcloud.com/dog-lick/stopless", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dog-lick/stopless", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 433, 472, 472, 870], [872, 872, 911, 911, 1439], [1441, 1441, 1478, 1478, 1534], [1536, 1536, 1575, 1575, 1828], [1831, 1831, 1870, 1870, 2123], [2126, 2126, 2186, 2186, 2710], [2712, 2712, 2774, 2774, 3247], [3249, 3249, 3315, 3315, 3571], [3664, 3664, 3700, 3700, 6417], [6419, 6766, 6823, 6823, 7724]]}
{"id": "3sBGzh", "name": "Toto 134554135", "author": "theepicsnail", "description": "https://www.youtube.com/watch?v=FTQbiNvZqaY", "tags": ["rains", "africa"], "likes": 6, "viewed": 179, "published": "Public", "date": "1548069865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define MAX_DIST 1000.0\n#define EPS 0.001\n#define ITR 100.0\nvec2 delta = vec2(.01,0);\nvec3 lastCell = vec3(0);\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nint best_id;\nfloat best_distance;\nvec3 best_pos;\nvoid update(int i, vec3 pos, float d) {\n    if(d>best_distance) return;\n    best_pos = pos;\n    best_distance = d;\n    best_id = i;\n}\n\n\nfloat SDF(vec3 ro, vec3 rd) {\n    best_distance= 100.0;\n    update(0, ro, ro.y);\n    \n    float r = rand(floor(ro.xz/10.0-.5));\n    ro.xz = fract(ro.xz/10.0-.5)*10.0-5.0;\n    \n    //d = min(d, length(ro.xz)-.1);\n    \n    for(float len = 1.0; len > 0.0 ; len -= .1) {\n        ro.xz = rotate(ro.xz, 1.4);\n        update(1,ro, sdVerticalCapsule(ro, len, .1));\n        ro.x = abs(ro.x);\n        ro -= vec3(0.0,len,0);\n        ro = reflect(ro, normalize(vec3(rotate(vec2(0,1),1.7+ r*.1 + sin(iTime*3.0)*.01), 0)));\n        update(1,ro, sdVerticalCapsule(ro, len, .1));\n        //d = min(d, sdVerticalCapsule(reflect(ro, normalize(vec3(1.0,.1,0))), 1.0, .1));\n        //d = min(d, sdVerticalCapsule(reflect(ro, normalize(vec3(-1.0,.1,0))), 1.0, .1));\n    }\n    \n    update(2,ro, length(ro)-.2);\n    \n    return best_distance;\n}\n\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+delta.xyy, rd)-SDF(ro-delta.xyy, rd);\n    float cy = SDF(ro+delta.yxy, rd)-SDF(ro-delta.yxy, rd);\n    float cz = SDF(ro+delta.yyx, rd)-SDF(ro-delta.yyx, rd);\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    for(; i < ITR ; i++) {\n    \tt += d = SDF(pos=ro+rd*t,rd);\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 cell = lastCell;\n    vec3 normal = EstNormal(pos, rd);\n    \n    \n    //vec3 color = hsv2rgb(vec3(rand(vec2(float(best_id),0.0)),1,1));\n    vec3 color=vec3(1,0,1);\n    if(i < ITR) \n    switch(best_id){\n        case 0: color=vec3(.2,.5,.1)*(1.0+rand(floor(pos.xz*10.0))); break;\n        case 1: color=vec3(.2,.1,.0)*(1.0+rand3(floor(best_pos*20.0))); break;\n        case 2: color=vec3(.1,.2,.1)*(1.0+rand3(floor(best_pos*100.0))); break;\n    }\n    color *= 10.0;\n    return color*dot(normal,-rd)/(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\t\n    \n    vec3 ro = vec3(0,1,0);\n    ro.xy = rotate(ro.xy, sin(iTime)*.3);\n    ro.z = -7.0;\n    //ro.xz = rotate(ro.xz, iTime);\n    ro.x += 5.0;\n    ro.y += 1.0;\n    ro.z += iTime;\n    float lr = sin(iTime*0.618*0.7)*.2;\n    float ud = sin(iTime*1.618*0.6)*.1;\n\tvec3 rd=lookat(vec3(\n        0, sin(iTime)*.2+3.0, 0\n    )-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n    \n    fragColor = vec4(color,1.0);\n    \n    fragColor.b += .3*rand(vec2(fragCoord.x, iTime));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 164, 164, 211], [213, 213, 233, 233, 305], [307, 307, 327, 327, 437], [439, 439, 460, 460, 541], [543, 543, 564, 564, 664], [667, 667, 689, 689, 858], [860, 860, 913, 913, 976], [1027, 1027, 1066, 1066, 1160], [1163, 1163, 1192, 1192, 1984], [1987, 1987, 2021, 2021, 2241], [2243, 2243, 2282, 2282, 3020], [3022, 3022, 3079, 3079, 3728]]}
{"id": "3sf3Rl", "name": "Grid Move", "author": "M3M", "description": "Проба", "tags": ["jg"], "likes": 0, "viewed": 57, "published": "Public", "date": "1547136467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float faze = cos(iTime / 1.227);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(faze + uv.xyx+vec3(0,2,4));\n    \n    float iWidth = iResolution.x * faze;\n    float iHeight = iResolution.y * faze;\n    \n    if (int(fragCoord.x) % int(iWidth) == 0 && fragCoord.x > 1.0 - faze) col = vec3(1.0 - col.x,1.0-col.y,1.0-col.z);\n\tif (int(iResolution.x - fragCoord.x) % int(iWidth) == 0 && fragCoord.x > 1.0 - faze) col = vec3(1.0 - col.x,1.0-col.y,1.0-col.z);\n\tif (int(fragCoord.y) % int(iHeight) == 0 && fragCoord.y > 1.0 - faze) col = vec3(1.0 - col.x,1.0-col.y,1.0-col.z);\n\tif (int(iResolution.y - fragCoord.y) % int(iHeight) == 0 && fragCoord.y > 1.0 - faze) col = vec3(1.0 - col.x,1.0-col.y,1.0-col.z);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sf3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 931]]}
{"id": "3sf3W2", "name": "ShaderDojo 013", "author": "antonOTI", "description": "Training session for shader showdown.\nI tried to make a smooth edged cube, failed and then roll with it\n(thanks iq for your ever usefull function toolbox)", "tags": ["raymarching", "training", "dojo"], "likes": 9, "viewed": 517, "published": "Public API", "date": "1547488522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159\n\n#define REP(p, r) (mod(p + r/2.,r) - r/ 2.)\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat map(vec3 p)\n{\n  vec3 cp = p;\n  float dist = 1000.;\n\n  float time = iTime * .25;\n p *= .36;\n  p.zx *= rot(-time * .25);\n\n  p.xz *= rot(p.z*1.1);\n\n  for(float it = 0.; it < 2.; it += 1.)\n{\n  p.xz *= rot(sin(p.y + time + (fract(sin(it * 2369.)))) * PI / (it + 1.) * .5);\n\n//  p.y += p.x * .125;\n  p.zy *= rot(time+PI);\nvec3 ap = max(vec3(0.),abs(p)) - 1.;\nfloat cu = length(ap)-.5 + min(max(ap.x,max(ap.y,ap.z)), 0.);\n  dist  =smin(dist, cu , .25);\n\n}\n\n  p = cp;\n  p.xz *= rot(-time * .5);\n\n\n  float rad = 5.;\n  float wi = .5;\n  float sph = length(p) - rad + wi /2.;\n\n  dist = -smin(sph,-dist,.15);\n\n  sph = length(p) - rad - wi /2.;\n\n  dist = -smin(-sph,-dist,.15);\n\n  sph = distance(cp, vec3(0.,0.,-5.)) - 2.;\n\n  dist = -smin(sph,-dist,.3);\n\n  return dist;\n}\n\nfloat ray(inout vec3 cp, vec3 rd, out float cd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1. /128.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n    {\n      break;\n    }\n    cp += rd * cd * .75;\n  }\n\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *= 1.4;\n\n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 cp = eye;\n\n  float cd;\n  float st = ray(cp, rd, cd);\n\n  fragColor = vec4(0.);\n  if(cd < .01)\n  {\n    vec3 ld = normalize(vec3(0.,-1.,1.));\n    ld.xz *= rot(iTime * .1);\n\n    vec3 norm = normal(cp);\n    float li = dot(ld, norm);\n\n    ld.zy *= rot(iTime * .25);\n    float li2 = dot(normalize(vec3(1.,0.,1.)), norm);\n    \n\n    float f = pow(max(li,li2), 2.);\n    f = sqrt(f);\n    vec4 col = vec4(norm, 0.);\n\n    col.xy *= rot(iTime * .5);\n    col.yz *= rot(iTime * .75);\n    col.xz *= rot(iTime * .125);\n    col = abs(col);\n    fragColor = mix(vec4(0.), col * 1.5, f);\n  }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sf3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 109, 109, 209], [211, 211, 230, 230, 303], [305, 305, 350, 350, 451], [453, 453, 472, 472, 1216], [1218, 1218, 1267, 1267, 1425], [1427, 1427, 1448, 1448, 1609], [1611, 1611, 1668, 1668, 2467]]}
{"id": "3sfGD2", "name": "Multiple_lights_rendu", "author": "Clemm_ence", "description": "multiple lights", "tags": ["multiplelights"], "likes": 1, "viewed": 51, "published": "Public", "date": "1547499001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FLT_MAX = 1.0 / 0.0;\nconst int MAX_NB_BOUNCES = 3;\nconst int PIXEL_SAMPLING_SIZE = 25;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int NB_LIGHTS = 2;\n\n\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    \n    \nstruct ShadeInfo\n{\n\tvec3 shadeCol;\n    float Ks;\n};\n    \n    \nstruct LightInfo\n{\n\tvec3 pos;\n    vec3 col;\n    float pow;\n};\nLightInfo lights[NB_LIGHTS];\n//parametre camera\nvec3 camPos=vec3(6,4,-5);\n\nconst vec3 camObj = vec3(3,1,-8);\nconst float camFovY = 90.0;\n\n//parametre sphere\n vec3 center = camObj + vec3(0,1,2);\nconst float rayonS = 1.0;\nconst vec3 sphereCol = vec3(1.0,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int      sphereId     = 1;\n\n//parametre lumiere\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\n\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8,10,-12);\nconst float    light1Pow = 0.8;\n\nconst vec3     light2Col     = vec3(1,1,0.5);\t\t// white/yellow\n      vec3     light2Pos     = vec3(3,10,1);\nconst float    light2Pow = 0.5;\n\n\n\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\nconst int antialliazing=1;\n\n/*\n//CSG objects parameters\nconst vec3     csgSphere1Pos \t= camPos + vec3(-1.125, 2, 0);\nconst float    csgSphere1Radius = 1.4;\nconst vec3\t   csgSphere2Pos \t= camPos + vec3(1.125, 2, 0);\nconst float\t   csgSphere2Radius = 1.4;\nconst vec3\t   csgSphere3Pos \t= camPos + vec3(0, 2.5, 0);\nconst float\t   csgSphere3Radius = 0.5;\nconst vec3\t   csgSphere4Pos \t= camPos + vec3(0, 2.4, -0.5);\nconst float\t   csgSphere4Radius = 0.5;\nconst vec3\t   csgCol1 \t\t\t= vec3(1.0, 0.5, 0.0); //orange\nconst vec3\t   csgCol2 \t\t\t= vec3(0.4, 1.0, 1.0); //light cyan\nconst vec3     csgCol3\t\t\t= vec3(1.0, 0.0, 1.0); //magenta\nconst vec3     csgCol4\t\t\t= vec3(5.0, 5.0, 0.0); //hyper yellow\nconst Material csgMat \t\t\t= Material(0.2, 1.0, 0.1, 90.0);\nconst int \t   csgId\t\t\t= 3;\n\n*/\n\nfloat raySphere(vec3 rayPos, vec3 rayDir,vec3 center, float rayonS,out vec3 intersecPt, out vec3 normal)\n{\n\tvec3 diff = rayPos - center ; \n     float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - rayonS * rayonS;\n    \n    float d = b*b - 4.0*a*c;\n    \n    \n    if (d >= 0.0)\n    {\n        float sd = sqrt(d);\n    \tfloat t1 = (-b - sd ) / (2.0 * a);\n    \tfloat t2 = (-b + sd ) / (2.0 * a);\n        \n       float dir = 1.0;\n       float t = -1.0;\n        if (t1 > 0.0 )\n          t = t1;\n        else if (t2 > 0.0)\n        {\n        \tt = t2;\n        }else\n            return t;\n        intersecPt = rayPos + t * rayDir;\n        normal     = normalize(intersecPt - center) * dir;\n        \n        return t;\n\n     }\n    return -1.0;\n}\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    float den = dot(planeNormal, rayDir);\n    if (abs(den) <= 0.000001)\n        return -1.0;\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    intersecPt = rayPos + t * rayDir;\n     normal = -sign(den) * planeNormal;\n    \n    return t;\n    \n}\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n \n   float focal = 1.0 / tan(radians(camFovY) / 2.0);\n   vec3 cz = normalize(camObj - camPos);\n     vec3 up = vec3(0,1,0);\n   vec3 cx = normalize(cross(-up, cz));\n   vec3 cy = normalize(cross( cz, cx));\n    \n   vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n   rayPos = camPos;\n   rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n \t float minDist  = FLT_MAX;\n          objectId = skyId;   \n    vec3 intersecS, normalS;\n    \n   //test sphere\n      float distS = raySphere(rayPos, rayDir, center, rayonS, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    //test plane\n     vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n       if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n\n}\n\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n     vec3 axisY  = normalize(cross(planeNormal, axisX));\n    \n     vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n\n}\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n/*\nvec3 getCSGColorAtPoint(vec3 pt) \n{\n\tif (subObjectIdC == 1)\n        return csgCol1;\n    if (subObjectIdC == 2)\n        return csgCol2;\n    if (subObjectIdC == 3)\n        return csgCol3;\n    if (subObjectIdC == 4)\n        return csgCol4;\n    return vec3(3);\n}\n*/\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V, LightInfo lights )\n{\n\n     vec3 ambiant  = objectMat.Ka * ambiantCol;\n \t \n   \n    vec3 diffuse  = objectMat.Kd *  objectCol * lights.col *     max(dot(N,L), 0.)*shadowFactor;\n    vec3 specular = objectMat.Ks *              lights.col * pow(max(dot(R,V), 0.), objectMat.Kn)*shadowFactor;\n     \n    vec3 phongCol = ambiant + diffuse + specular;\n\n    return phongCol;   \n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n\tint object;\n    vec3 inter;\n    vec3 nI;\n    float shadowPoint;\n   \t\n    \n        \n    float intersec =computeNearestIntersection(I, L,object,  inter, nI);\n    if ((intersec < 0.0) || (intersec > Ldist))\n    {\tshadowPoint = 0.5;\n    }else {\n        shadowPoint = 0.0;\n}\nreturn  shadowPoint;\n\n}\n\nvoid AnimeScene(float time)\n{\n \t//animate the sphere position\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    center = camObj + rs * vec3(-sin(as),0.0,cos(as))+vec3(0,1,0);\n    \n    //anime ligth position\n    light1Pos += vec3(0,10.5 +9.5 * cos(time)-10.,0);\n    \n    float targetDist = length(camObj - camPos);\n    camPos -=vec3(0,0,targetDist);\n    camPos += targetDist*vec3(sin(time), max(sin(time*0.5),0.),cos(time));\n}\n\n\n\nvec4 RaytraceAtPixelCoord_RT(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    \n    \n    int objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 color;\n   \n    \n    do\n    {\n        \n        \n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        vec3 color;\n        Material objMat;\n        \n         \n        if (distI <= 0.0) //pt dans le ciel\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0 ; \n            break;\n        }\n    \n      \n        //objets\n        \n        vec3 V =- rayDir;\n        vec3 objColor = getObjectColorAtPoint(objectId, intersecI, objMat);\n         vec3 I = intersecI + normalI*0.01;\n         vec3 RayRefract = 2.0 * normalI * dot(normalI, V) - V;\n            \n         for (int l = 0 ; l < NB_LIGHTS ; l++){  // parcours lumiere \t\t\n            vec3 L = normalize(lights[l].pos - intersecI);\n            \n           vec3 R = normalize(2.0 * normalI * dot(normalI, L) - L);\n        \n           \n            float Ldist = length(lights[l].pos - I);\n            \n             float shadowFactor = getShadowFactorAtPoint(I,normalI, objMat,L,Ldist);\n             color += computePhongShading(objColor, objMat,  shadowFactor,normalI, L, R, V, lights[l]);\n             \n         }\n            infos[nbBounces].shadeCol= color;\n            infos[nbBounces].Ks = objMat.Ks;\n            \n          rayDir = RayRefract;\n             rayPos = I;\n            \n               nbBounces++;\n            \n           \n        }\n    \n    while (nbBounces < MAX_NB_BOUNCES);\n    vec3 resCol = vec3(0);\n    \n    for (int i =0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces -i].Ks *resCol + infos[nbBounces - i].shadeCol; \n    \n    }\n    \n    return vec4(resCol,1);\n}\n\n\n\nvec2 noise2(vec2 location , vec2 delta)\n{\n\tconst vec2 c= vec2 (12.9898 , 78.233);\n    const float m = 43758.5453;\n    return vec2(fract(sin(dot(location + delta,c))*m),\n                      fract(sin(dot(location+ vec2(delta.y,delta.x),c)) * m));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t \n    float time = iTime;\n     AnimeScene(time);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].pow = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].pow = light2Pow;\n    \n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int  objectId; \n    vec3 intersecI, normalI;\n   \n    \n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    float pixel = 1.0/iResolution.y;\n    float sousPixel = pixel/float(PIXEL_SAMPLING_GRID_SIZE); \n    vec4 finalColor = vec4(0);\n  \n    \n    if (antialliazing == 0)\n    {\n         for (int i = 0; i < PIXEL_SAMPLING_GRID_SIZE; i++)\n    {\n        \tfor (int j = 0 ; j < PIXEL_SAMPLING_GRID_SIZE; j++)\n        {\n           finalColor +=RaytraceAtPixelCoord_RT(fragCoord + vec2(float(i) * sousPixel, float(j) * sousPixel));\n            \n        }\n    }\n    finalColor /=pow(float(PIXEL_SAMPLING_GRID_SIZE), 2.0);\n    }else {\n        vec2 delta = vec2 (600.0, 5468.265);\n        for (int i= 0; i < PIXEL_SAMPLING_SIZE; i++)\n    {\n            finalColor += RaytraceAtPixelCoord_RT(fragCoord + noise2(fragCoord, delta) * pixel);\n        }\n        finalColor /= float(PIXEL_SAMPLING_SIZE);\n    }\n    \n   \n    fragColor= finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1667, 2417, 2523, 2523, 3215], [3219, 3219, 3359, 3359, 3613], [3615, 3615, 3700, 3700, 4055], [4058, 4058, 4207, 4207, 4974], [4978, 4978, 5015, 5015, 5039], [5041, 5041, 5077, 5077, 5443], [5446, 5446, 5521, 5521, 5783], [5785, 6051, 6184, 6184, 6533], [6535, 6535, 6622, 6622, 6917], [6919, 6919, 6948, 6980, 7429], [7433, 7433, 7478, 7478, 9333], [9337, 9337, 9378, 9378, 9586], [9590, 9590, 9647, 9647, 10969]]}
{"id": "3sfGDj", "name": "Golden ratio visualized", "author": "toocanzs", "description": "attempting to implement the program shown in this video in shader\nhttps://www.youtube.com/watch?v=sj8Sg8qnjOg\n\nComment out line 2 to see the golden ratio\nChange phi at line 12 to any ratio to see how irrational it looks", "tags": ["golden", "ratio", "irrationality"], "likes": 2, "viewed": 243, "published": "Public", "date": "1547474412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DYNAMIC\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define CS(a)  vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = ( 2.*u - R )/ R.y;\n    O = vec4(0);\n\nfloat PI = 3.14159,\n#ifdef DYNAMIC\n        phi = iTime*0.001 + 0.1,\n#else\n        phi = (1. + sqrt(5.))/2.,\n#endif\n          a = phi * 2.*PI,\n         i0 = ( length(U) - .01 ) /.0015,\n         i1 = ( mod( PI-atan(U.y,U.x) ,2.*PI) )/ a, // + k.2PI/a\n          k = floor( (i0-i1) / (2.*PI/a) ), \n          i, d = 1e9;\n    \n    for (float n = 0.; n < 2.; n++) {\n        i = round(i1 + k++ * 2.*PI/a );\n        vec2 p = -( .01+ 0.0015*i) *CS(-i*a);\n    \td = min( d, length(U - p) - .001);\n       //O[int(n)%3] += max(0.,1.-length(uv - p)/.1);    \n    }\n  \n    O += vec4(smoothstep(3./iResolution.y, 0., d - .01));\n}  \n\n/*\nIn making this shader I was told by FabriceNeyret2 about how this loop can \nbe removed and still produce the same image. \nGreat learning experience. \nAbove is his suggested code, and for reference my old code is below.\n\nfloat phi = (1. + sqrt(5.))/2.;\n#define DYNAMIC\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy )/ iResolution.y;\n    \n\tfloat d = 99999.;\n    vec2 p = vec2(0.01,0);\n    #ifdef DYNAMIC\n    phi = iTime*0.001 + 0.1;\n    #endif\n    //phi = (1./3.);\n    float a = phi * 2.*3.14159265358979323846;\n    mat2 rot = mat2(cos(a),sin(a),-sin(a),cos(a));\n    for(int i = 0; i < 1400; i++)\n    {\n        p *= rot;\n    \td = min(d,length(uv + p)-0.001);\n        p = normalize(p) * (length(p)+0.0015);\n    }\n    fragColor = vec4(smoothstep(3./iResolution.y, 0., d - 0.01));\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 141, 141, 833]]}
{"id": "3sfGRj", "name": "Voronoi Cell Boundaries", "author": "mla", "description": "Simple method for Voronoi cell boundaries - keep 3 closest points and check bisector between first and third as well as first and second. Also allow cell point to travel outside cell boundary (we check 16 cells around nearest grid point).", "tags": ["2d", "voronoi", "lines"], "likes": 6, "viewed": 454, "published": "Public API", "date": "1546804517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2019 by Matthew Arcus\n//\n// Simple 2D Voronoi. Examine the 16 cells nearest to the nearest grid point.\n// This allows us to let the cell point range outside the cell, up to 1.0\n// in each direction from the centre (we should keep it to about 0.75 to\n// avoid glitches, but with 1.0 we only get occasional misalignments).\n//\n// For drawing the lines, taking the minimum distance to the boundary lines\n// of the two closest points seems to avoid most of the more serious glitches\n// (see iq's various Voronoi shaders for the proper way to do this).\n//\n// Mouse-x: zoom\n// Mouse-y: line width\n// 'g': show grid\n// 'v': show voronoi cells\n// 'p': show cell points\n// 'x': only check nearest point for line\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Wang Hash, used to seed RNG\nuint ihash(uint a) {\n  a = (a ^ 61U) ^ (a >> 16);\n  a *= 9U;\n  a = a ^ (a >> 4);\n  a = a * 0x27d4eb2dU;\n  a = a ^ (a >> 15);\n  return a;\n}\n\n// Note that we convert from float to integer to unsigned\nuint ihash(ivec2 p) {\n  uint i = uint(p.x), j = uint(p.y);\n  return ihash((i << 16) ^ j);\n}\n\nuint xorshift(uint value) {\n  // Xorshift*32\n  // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n  value ^= value << 13;\n  value ^= value >> 17;\n  value ^= value << 5;\n  return value;\n}\n\nuint seed = 1U;\nuint rng() {\n  //seed = lcg(seed);\n  seed = xorshift(seed);\n  return seed;\n}\n\n// Uniform random float in [0,1)\nfloat rand() {\n  return float(rng())/pow(2.0,32.0);\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_P = 80;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 perp(vec2 r) {\n  return vec2(-r.y,r.x);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  //h = clamp(h, 0.0, 1.0);\n  float d = length(pa-ba*h);\n  return d;\n}\n\nfloat bisectordistance(vec2 pos, vec2 a, vec2 b) {\n  vec2 centre = 0.5*(a+b);\n  vec2 r = perp(a-centre);\n  return segment(pos,centre-r,centre+r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float scale = 1.0;\n  float gridsize = 4.0; // Cells per unit distance\n  float lwidth = 0.05;\n  float speed = 0.5;\n  \n  if (iMouse.x != 0.0) {\n    scale *= 2.0*iMouse.x/iResolution.x;\n    lwidth *= 2.0*iMouse.y/iResolution.y;\n  }\n  vec2 pos  = (2.0*fragCoord - iResolution.xy)/ iResolution.y;\n  pos *= scale;\n  pos *= gridsize;\n  vec2 grid = round(pos); // Nearest grid point\n  // vec4(p.x,p.y,distance,color);\n  vec4 minpoint[3] = vec4[](vec4(1e8),vec4(1e8),vec4(1e8));   // Keep 3 closest points in here.\n  // And iterate through 16 cells around the grid point.\n  for (float i = -2.0; i <= 1.0; i++) {\n    for (float j = -2.0; j <= 1.0; j++) {\n      vec2 cell = grid + vec2(i,j);\n      seed = ihash(ivec2(cell)); // Seed RNG for this cell\n      vec2 p = vec2(rand(),rand());\n      vec2 offset = p*(speed*iTime);\n      float K = 4.0;\n      offset = mod(offset,K);\n      offset = min(offset,K-offset);\n      offset -= 0.25*K;\n      vec2 cellpoint = cell+vec2(0.5)+offset;\n      float d = distance(cellpoint,pos);\n      vec4 celldata = vec4(cellpoint,d,rand());\n      // Insertion sort for 3 closest points\n      if (d < minpoint[2].z) {\n\tif (d >= minpoint[1].z) {\n\t  minpoint[2] = celldata;\n\t} else {\n\t  minpoint[2] = minpoint[1];\n\t  if (d >= minpoint[0].z) {\n\t    minpoint[1] = celldata;\n\t  } else {\n\t    minpoint[1] = minpoint[0];\n\t    minpoint[0] = celldata;\n\t  }\n\t}\n      }\n    }\n  }\n  vec3 basecolor = vec3(0.8);\n  if (!keypress(CHAR_V)) {\n    float d = 1e8;\n    d = min(d,bisectordistance(pos,minpoint[0].xy,minpoint[1].xy));\n    if (!keypress(CHAR_X)) d = min(d,bisectordistance(pos,minpoint[0].xy,minpoint[2].xy));\n    basecolor = hsv2rgb(minpoint[0].w,1.0,1.0);\n    basecolor = mix(vec3(0.2),basecolor,smoothstep(lwidth,1.25*lwidth,d));\n  }\n  \n  if (keypress(CHAR_G)) {\n    // Draw grid\n    vec2 gridpos = pos-floor(pos); // Distance to cell wall\n    gridpos = min(gridpos,1.0-gridpos);\n    basecolor = mix(vec3(0.5),basecolor,\n                    smoothstep(0.02,0.025,min(gridpos.x,gridpos.y)));\n  }\n  if (!keypress(CHAR_P)) {\n    basecolor = mix(vec3(0),basecolor,\n                    smoothstep(1.25*lwidth,1.5*lwidth,distance(pos,minpoint[0].xy)));\n  }\n  fragColor = vec4(basecolor,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[882, 913, 933, 933, 1051], [1053, 1111, 1132, 1132, 1202], [1204, 1204, 1231, 1326, 1415], [1433, 1433, 1445, 1467, 1509], [1511, 1544, 1558, 1558, 1597], [1715, 1715, 1740, 1740, 1800], [1802, 1897, 1938, 1938, 2114], [2116, 2116, 2135, 2135, 2162], [2164, 2164, 2203, 2203, 2351], [2353, 2353, 2403, 2403, 2500], [2502, 2502, 2557, 2557, 4760]]}
{"id": "3sfGWB", "name": "CANABALT", "author": "yasuo", "description": "Inspired from http://canabalt.com/", "tags": ["2ddistance"], "likes": 9, "viewed": 322, "published": "Public API", "date": "1547292014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define noise(x) fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453)\n#define combine2D(d1,d2) d1 < d2 ? d1 : d2\n\n// numbers 0123456789\nint c[] = int[](31599,9362,29671,29391,23497,31183,31215,29257,31727,31695);\nfloat getBit(int num,int bit)\n{\n\treturn float( num>>bit & 1);\n}\n\nfloat Sprite3x5(int sprite,vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn getBit(sprite,int((2.0 - p.x) + 3.0 * p.y)) * bounds;\n}\n\nfloat Digit(int n,vec2 p)\n{\n\tn = int(mod(float(n),10.0));\n    return Sprite3x5(n == 0 ? c[0] : n == 1 ? c[1] : n == 2 ? c[2] : n == 3 ? c[3] : n == 4 ? c[4] : n == 5 ? c[5] : n == 6 ? c[6] : n == 7 ? c[7] : n == 8 ? c[8] : n == 9 ? c[9] : 0,p);\n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise2d( uv ); uv = m*uv;\n\tf += 0.2500*noise2d( uv ); uv = m*uv;\n\tf += 0.1250*noise2d( uv ); uv = m*uv;\n\tf += 0.0625*noise2d( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdQuads( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n    vec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e3.y - e0.y*e3.x );\n    vec2 d = min( min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 \t   vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) )),\n                       vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec3 buildingTex(vec2 uv)\n{\n    float n = 7.9;\n    uv.x -= 0.093;\n    vec2 st = uv;\n    vec3 col = vec3(0.0);\n    if(uv.x>-0.55 && uv.x<0.35){\n         st = fract(uv * n);\n         col = vec3(1.0-smoothstep(0.009,0.01,dBox2d(st, vec2(0.5,0.4))))*vec3(-0.3);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    \n    // bg color\n    vec3 col = vec3(0.65,0.65,0.7);\n    vec3 bcol = vec3(0.55,0.55,0.6);\n    vec3 mcol = vec3(0.25,0.25,0.3);\n    vec3 fcol = vec3(0.6,0.6,0.6);\n    \n    // smoke\n    float smokeD = dBox2d(uv+vec2(1.0,0.0),vec2(0.01,0.8))*fbm(uv - vec2(sin(iTime*0.1)*1.5,iTime*0.2));\n    col = mix( col, (vec3(0.95)+vec3(smokeD))*col, 1.0-smoothstep(0.13,0.15,abs(smokeD)) );\n    \n    // fake camera shake\n    uv.y += fbm(vec2(0.0,iTime*0.3))*0.1;\n    \n    vec2 uvRef = uv;\n    // bottom layer\n    uvRef.x += iTime*0.5;\n\tfloat n = floor(uvRef.x/0.5);\n    uvRef.y -=0.8;\n\tuvRef.y += noise(n)*0.3;\n\tuvRef.x = mod(uvRef.x,1.4)-0.7;\n    \n    float nn = floor(uv.y/1.1);\n    float bl0 = sdQuads(vec2(0.1,0.1),vec2(-0.1,0.15),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float bl1 = sdQuads(vec2(0.5,-0.05),vec2(0.1,0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float bl2 = sdQuads(vec2(-0.1,0.05),vec2(-0.3,-0.1),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float bl3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.6,-0.3),vec2(-0.6,-1.5),vec2(-0.3,-1.5),uvRef);\n    float blD = combine2D(bl0,bl1);\n    float blD1 = combine2D(bl2,bl3);\n    float blD2 = combine2D(blD,blD1);\n    col = mix( col, bcol, 1.0-smoothstep(0.009,0.01,blD2) );\n    \n    uvRef = uv;\n    \n    uvRef.x += iTime*0.5;\n    n = floor(uvRef.x/1.2);\n    uvRef.y += 0.7;\n\tuvRef.y += noise(n)*0.8;\n    uvRef.x = mod(uvRef.x,0.4)-0.2;\n    \n    float buildingD = dBox2d(uvRef,vec2(0.005,0.5));\n    col = mix( col, bcol, 1.0-smoothstep(0.2,0.21,abs(buildingD)) );\n    \n    uvRef = uv;\n    // middle layer\n\tuvRef.x += iTime*0.6;\n\tn = floor(uvRef.x/0.5);\n    uvRef.y -=0.5;\n\tuvRef.y += noise(n)*0.3;\n\tuvRef.x = mod(uvRef.x,1.4)-0.7;\n    \n    float ml0 = sdQuads(vec2(0.1,-0.2),vec2(-0.1,-0.25),vec2(-0.1,-1.5),vec2(0.1,-1.5),uvRef);\n    float ml1 = sdQuads(vec2(0.5,0.1),vec2(0.1,-0.05),vec2(0.1,-1.5),vec2(0.5,-1.5),uvRef);\n    float ml2 = sdQuads(vec2(-0.1,-0.2),vec2(-0.3,-0.15),vec2(-0.3,-1.5),vec2(-0.1,-1.5),uvRef);\n    float ml3 = sdQuads(vec2(-0.3,-0.3),vec2(-0.65,-0.3),vec2(-0.65,-1.5),vec2(-0.3,-1.5),uvRef);\n    float mlD = combine2D(ml0,ml1);\n    float mlD1 = combine2D(ml2,ml3);\n    float mlD2 = combine2D(mlD,mlD1);\n    col = mix( col, mcol, 1.0-smoothstep(0.009,0.01,(mlD2)) );\n    \n    uvRef = uv;\n    // top layer\n    uvRef.x += iTime*1.5;\n    n = floor(uvRef.x/3.0);\n    uvRef.y += 0.5;\n\tuvRef.y += noise(n)*1.1;\n    uvRef.x = mod(uvRef.x,1.5)-0.75;\n    \n    buildingD = dBox2d(uvRef,vec2(0.3,0.5));\n    col = mix( col, fcol+buildingTex(uvRef), 1.0-smoothstep(0.2,0.21,(buildingD)) );\n    \n    // meter\n    uv = ( fragCoord.xy /iResolution.xy ) * vec2(128,64);\n\tvec2 cpos = vec2(112.5,56.3);\n\tfloat dc = Digit(int(fract(iTime)*10.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*20.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*30.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*40.0),floor(uv-cpos));\n    col = mix(col,vec3(0.0),dc );\n    \n    cpos = vec2(112.0,57.0);\n\tdc = Digit(int(fract(iTime)*10.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*20.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*30.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*40.0),floor(uv-cpos));\n   \tcol = mix(col,vec3(1.0),dc );\n    \n    // result\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 220, 251, 251, 283], [285, 285, 321, 321, 474], [476, 476, 503, 503, 722], [724, 873, 894, 894, 1013], [1015, 1015, 1043, 1043, 1501], [1503, 1503, 1523, 1523, 1761], [1763, 1763, 1793, 1793, 1840], [1842, 1842, 1918, 1918, 2714], [2716, 2716, 2743, 2743, 2997], [2999, 2999, 3056, 3056, 6471]]}
{"id": "3sfGWS", "name": "tv shader", "author": "changjiu", "description": "tv", "tags": ["tv"], "likes": 0, "viewed": 291, "published": "Public API", "date": "1547268823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   vec2 position = uv;\n    \n    float time = iTime*5.0;\n\n    float color = 0.0;\n    color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );\n    color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );\n    color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );\n    color *= sin( time / 10.0 ) * 0.5;\n\n    \n    // Time varying pixel color\n    vec3 col = vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 767]]}
{"id": "3sfGzB", "name": "UI test", "author": "yasuo", "description": "This code is based on Iq's 2d distance functions. It's testing the UI drawing.", "tags": ["ui", "2ddistance"], "likes": 25, "viewed": 591, "published": "Public API", "date": "1546609324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\nfloat c_colon = 1040.0;\n\n// 2d distance functions from http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvec3 lineTex(vec2 uv)\n{\n    float stripeSize = 50.0;\n    float t = iTime*10.0;\n    return vec3(tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// modified sdTriangle function\nfloat sdQuads( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n    vec2 e3 = p0 - p3;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    vec2 v3 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e3.y - e0.y*e3.x );\n    vec2 d = min( min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 \t   vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) )),\n                       vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTriangleIsosceles( in vec2 q, in vec2 p )\n{\n    p.y -= 0.5;\n    p.x = abs(p.x);\n    \n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    \n    float s = -sign( q.y );\n\n    vec2 d = min( vec2( dot( a, a ), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot( b, b ), s*(p.y-q.y)  ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nvec3 animateCircle(vec2 uv, vec3 col,vec2 pos, float deg, float size, float thic, float speed) {\n\tfloat rad = ((iTime*speed)+deg)*degToRad;\n    float s = sin(rad);\n    float c = cos(rad);\n    \n    vec2 q = (uv+pos) * mat2(c, -s, s, c);\n    float r2 = (length( q )*size);\n    \n    if(r2 > 1.0-thic && r2 < 1.0 && q.y > 0.15){\n        vec3 ltex = lineTex(q);\n        col *= ltex/100.0;\n    }\n    \n    return col;\n}\n\nfloat getBit(float num,float bit)\n{\n\tnum = floor(num);\n\tbit = floor(bit);\n\t\n\treturn float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n}\n\nfloat Sprite3x5(float sprite,vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\t\n\treturn getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\nfloat Digit(float num,vec2 p)\n{\n\tnum = mod(floor(num),11.0);\n\t\n\tif(num == 0.0) return Sprite3x5(c_0,p);\n\tif(num == 1.0) return Sprite3x5(c_1,p);\n\tif(num == 2.0) return Sprite3x5(c_2,p);\n\tif(num == 3.0) return Sprite3x5(c_3,p);\n\tif(num == 4.0) return Sprite3x5(c_4,p);\n\tif(num == 5.0) return Sprite3x5(c_5,p);\n\tif(num == 6.0) return Sprite3x5(c_6,p);\n\tif(num == 7.0) return Sprite3x5(c_7,p);\n\tif(num == 8.0) return Sprite3x5(c_8,p);\n\tif(num == 9.0) return Sprite3x5(c_9,p);\n\tif(num == 10.0) return Sprite3x5(c_colon,p);\n\t\n\treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 uvRef = uv;\n    \n    // bg color\n    vec3 col = vec3(0.9,0.9,0.9);\n    vec3 bcol = vec3(0.3,0.75,0.7);\n    \n\tfloat r3 = length( uv+vec2(-0.5,0.75) )*3.0;\n    float r4 = length( uv+vec2(-0.5,0.75) )*3.5;\n    \n    col = mix( col, vec3(0.2,0.2,0.2), 1.0-smoothstep(0.98,1.0,r3) );\n    col = mix( col, bcol, 1.0-smoothstep(0.98,1.0,r4) );\n    \n\tif(uv.x >= 0.23 && uv.x<0.7){\n        uvRef = uv;\n        uvRef.x += iTime*0.25;\n        \n        uvRef.x = mod(uvRef.x,2.0)-1.0;\n        uvRef.y += 0.75;\n        col = line( col, vec2(0.0, 0.07), vec2(0.07, -0.07), uvRef, vec2(0.02,2.0), vec4(vec3(0.9),2.0) );\n        col = line( col, vec2(0.1-0.2, 0.07), vec2(0.17-0.2, -0.07), uvRef, vec2(0.02,2.0), vec4(vec3(0.9),2.0) );\n        col = line( col, vec2(0.2-0.4, 0.07), vec2(0.27-0.4, -0.07), uvRef, vec2(0.02,2.0), vec4(vec3(0.9),2.0) );\n        col = line( col, vec2(0.35-0.2, 0.07), vec2(0.27-0.2, -0.07), uvRef, vec2(0.02,2.0), vec4(vec3(0.9),2.0) );\n        col = line( col, vec2(0.45-0.2, 0.07), vec2(0.37-0.2, -0.07), uvRef, vec2(0.02,2.0), vec4(vec3(0.9),2.0) );\n    }   \n    \n    col = animateCircle(uv, col,vec2(-0.5,0.75), 45.0,3.5,0.25,-50.0); \n    \n    \n    float r = length( uv+vec2(-1.0,0.5) )*2.0;\n    float r2 = (length( uv+vec2(-1.0,0.5) )*2.3);\n    \n\tcol = mix( col, vec3(0.2,0.2,0.2), 1.0-smoothstep(0.98,1.0,r) );\n    col = mix( col, bcol, 1.0-smoothstep(0.98,1.0,r2) );\n    \n    col = animateCircle(uv, col,vec2(-1.0,0.5), 0.0,2.3,0.1,20.0);\n   \tcol = animateCircle(uv, col,vec2(-1.0,0.5), 180.0,2.3,0.1,20.0);\n    col = animateCircle(uv, col,vec2(-1.0,0.5), 240.0,2.7,0.2,-50.0);\n    \n    \n    float ax = cos(iTime*2.5)*0.03;\n    float ay = sin(iTime*1.7)*0.04;\n    float ax2 = cos(iTime*1.9)*0.05;\n    float ay2 = sin(iTime*2.1)*0.06;\n\tfloat ad = sdQuads(vec2(0.1+ax,0.1+ay2),vec2(-0.1+ax2,0.1+ay),vec2(-0.1+ax,-0.1+ay2),vec2(0.1+ax2,-0.1+ay),uv+vec2(-1.0,0.5));\n    col = mix( col, vec3(0.5,0.95,0.9), 1.0-smoothstep(0.006,0.01,abs(ad)) );\n    \n    col = line( col, vec2(0.6, 0.8), vec2(0.6, -0.05), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    col = line( col, vec2(-0.6, 0.8), vec2(-0.6, -0.05), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    \n    col = line( col, vec2(0.5, 0.6), vec2(0.5, 0.1), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    col = line( col, vec2(-0.5, 0.6), vec2(-0.5, 0.1), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    \n    if(uv.y >= -0.05 && uv.y<0.8){\n        uvRef = uv;\n\t\tuvRef.y += iTime*0.1;\n    \tuvRef.y = mod(uvRef.y,0.1)-0.05;\n    \tcol = line( col, vec2(-0.65, 0.0), vec2(-0.61, 0.0), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n        col = line( col, vec2(0.65, 0.0), vec2(0.61, 0.0), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n    }\n    \n    if(uv.y >= 0.1 && uv.y<0.6){\n    \tuvRef = uv;\n        uvRef.y -= iTime*0.1;\n    \tuvRef.y = mod(uvRef.y,0.2)-0.1;\n        col = line( col, vec2(-0.49, 0.0), vec2(-0.43, 0.0), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n        col = line( col, vec2(0.49, 0.0), vec2(0.43, 0.0), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n    }\n    \n    if(uv.x >= -0.5 && uv.x<0.5){\n    \tuvRef = uv;\n        uvRef.y -= 0.75;\n        uvRef.x -= iTime*0.1;\n    \tuvRef.x = mod(uvRef.x,0.2)-0.1;\n        col = line( col, vec2(0.0, -0.01), vec2(0.0, 0.01), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n     \n    }\n    \n    // map\n    col = line( col, vec2(0.85, 0.9), vec2(0.85, 0.5), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    col = line( col, vec2(1.45, 0.9), vec2(1.45, 0.5), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    col = line( col, vec2(0.85, 0.9), vec2(1.45, 0.9), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    col = line( col, vec2(0.85, 0.5), vec2(1.45, 0.5), uv, vec2(0.003,2.0), vec4(bcol,2.0) );\n    if(uv.y >= 0.5 && uv.y<0.9){\n        uvRef = uv;\n        uvRef.y -= iTime*0.1;\n    \tuvRef.y = mod(uvRef.y,0.08)-0.04;\n        col = line( col, vec2(0.86, 0.0), vec2(1.44, 0.0), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n    \tif(uv.x >= 0.85 && uv.x<1.45){\n            uvRef = uv;\n    \t\tuvRef.x = mod(uvRef.x,0.08)-0.04;\n        \tcol = line( col, vec2(0.0, 0.5), vec2(0.0, 0.9), uvRef, vec2(0.003,2.0), vec4(bcol,2.0) );\n        }\n    }\n    \n    vec2 tri = vec2(0.03,-0.06);\n\tfloat d = sdTriangleIsosceles( tri, uv+vec2(-1.15,-0.25) );\n    col = mix( col, vec3(0.7,0.0,0.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    \n    // navi icon\n    vec2 triNavi = vec2(0.04,0.08);\n\tfloat navi = sdTriangleIsosceles( triNavi, uv+vec2(sin(iTime)*0.5,-0.3) );\n    col = mix( col, vec3(0.7,0.0,0.0), 1.0-smoothstep(0.0,0.005,abs(navi)) );\n    \n    // guage\n    float gd = sdQuads(vec2(0.7,-0.04),vec2(-0.3,0.07),vec2(-0.2,-0.07),vec2(0.8,-0.18),uv+vec2(1.15,0.5));\n    col = mix( col, bcol, 1.0-smoothstep(0.005,0.01,abs(gd)) );\n    float gd2 = sdQuads(vec2(0.8,-0.04),vec2(-0.1,0.05),vec2(-0.2,-0.09),vec2(0.7,-0.18),uv+vec2(1.15,0.637));\n    col = mix( col, bcol, 1.0-smoothstep(0.005,0.01,abs(gd2)) );\n    \n    float ganimate = mod(iTime*5.0,26.0);\n    float gx = -0.3-ganimate*0.1;\n    if(ganimate>=13.0){\n        gx = -1.4+( ganimate-13.0)*0.1;\n    }\n    \n    if(uv.x >= -1.5 && uv.x<gx){\n        float gd3 = sdQuads(vec2(0.665,-0.08),vec2(-0.21,0.02),vec2(-0.17,-0.03),vec2(0.7,-0.12),uv+vec2(1.15,0.5));\n    \tcol = mix( col, vec3(0.2,0.8,0.5), 1.0-smoothstep(0.02,0.04,abs(gd3)) );\n    }\n    \n    \n    float ganimate2 = mod(iTime*4.5,26.0);\n    float gx2 = -0.3-ganimate2*0.1;\n    if(ganimate2>=13.0){\n        gx2 = -1.4+( ganimate2-13.0)*0.1;\n    }\n    \n    if(uv.x >= -1.5 && uv.x<gx2){\n        float gd4 = sdQuads(vec2(0.72,-0.08),vec2(-0.08,0.0),vec2(-0.12,-0.05),vec2(0.675,-0.135),uv+vec2(1.15,0.637));\n        col = mix( col, vec3(0.9,0.6,0.0), 1.0-smoothstep(0.025,0.04,abs(gd4)) );\n    }\n    \n    // target\n    float targetD = sdRhombus(uv, vec2(0.16+sin(iTime*2.0)*0.01,0.1+sin(iTime*2.0)*0.01));\n    \n    col = mix( col, bcol, 1.0-smoothstep(0.002,0.01,abs(targetD)) );\n    \n    \n    float bar0 = dBox2d(uv+vec2(1.4,-0.3), vec2(0.01,0.1+(sin(iTime*3.0)*0.05)));\n    col = mix( col, bcol, 1.0-smoothstep(0.04,0.05,abs(bar0)) );                    \n    float bar1 = dBox2d(uv+vec2(1.28,-0.3), vec2(0.01,0.1+(sin(iTime*2.0)*0.06)));\n    col = mix( col, bcol, 1.0-smoothstep(0.04,0.05,abs(bar1)) );    \n    float bar2 = dBox2d(uv+vec2(1.16,-0.3), vec2(0.01,0.1+(sin(iTime*3.5)*0.08)));\n    col = mix( col, bcol, 1.0-smoothstep(0.04,0.05,abs(bar2)) );    \n    float bar3 = dBox2d(uv+vec2(1.04,-0.3), vec2(0.01,0.1+(sin(iTime*4.0)*0.07)));\n    col = mix( col, bcol, 1.0-smoothstep(0.04,0.05,abs(bar3)) );\n    \n    // digit\n    uv = ( fragCoord.xy /iResolution.xy ) * vec2(128,64);\n\tvec2 cpos = vec2(2.0,57.0);\n\tfloat dc = Digit(fract(iTime)*10.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*20.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*40.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*50.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*70.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*80.0,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(fract(iTime)*90.0,floor(uv-cpos));\n   \tcol = mix(col,bcol,dc );\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 401, 431, 431, 478], [480, 480, 503, 503, 743], [745, 745, 794, 794, 904], [906, 906, 989, 989, 1123], [1125, 1125, 1192, 1192, 1801], [1803, 1835, 1911, 1911, 2707], [2709, 2709, 2760, 2760, 3096], [3098, 3098, 3127, 3127, 3155], [3156, 3156, 3198, 3198, 3401], [3403, 3403, 3499, 3499, 3815], [3817, 3817, 3852, 3852, 3948], [3950, 3950, 3988, 3988, 4138], [4140, 4140, 4171, 4171, 4675], [4677, 4677, 4734, 4734, 12008]]}
{"id": "3sj3RW", "name": "Circle Segment Distance", "author": "nr4", "description": "Accurate circle segment distance", "tags": ["circle", "distance", "segment", "arc"], "likes": 5, "viewed": 141, "published": "Public", "date": "1548349453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Circle Segment Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Changed isoline drawing code to code from fabrice's comment\n// Update 2: Fixed sign of distance function\n\nconst vec3 c = vec3(1.,0., -1.);\nconst float pi = acos(-1.);\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x);\n    vec2 philo = vec2(max(p0, p1), min(p0, p1));\n    if((p < philo.x && p > philo.y) || (p+2.*pi < philo.x && p+2.*pi > philo.y) || (p-2.*pi < philo.x && p-2.*pi > philo.y))\n    \treturn abs(length(x)-r);\n    return min(\n        length(x-r*vec2(cos(p0), sin(p0))),\n        length(x-r*vec2(cos(p1), sin(p1)))\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n    float d = circlesegment(uv-.4*c.xy,.1, pi/8., 15.*pi/8.);\n    d = min(d, circlesegment(uv+.4*c.xy,.1, -pi/2., pi/2.));\n    d = abs(d)- .02;\n    float e = 1.5/iResolution.y;\n    \n    vec3 col = cos(iTime+uv.xyx+vec3(0,2,4)) * smoothstep(.1+e, 0., abs( fract(20.*d) - .2 ) ) + vec3(1,0,0) * smoothstep(e, -e,d);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sj3RW.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[926, 956, 1014, 1014, 1364], [1366, 1366, 1423, 1423, 1818]]}
{"id": "3sjGDh", "name": "Poster Recreation - Shingeo ", "author": "anemolo", "description": "PLAKAT JAPONSKI 1993 by Shingeo Fukuda\nReally loved this japansese design so i decided to give it a go in a shader.\nI would love to hear how i can make this concept faster. There has to be a better way of doing the clipping and limiting the color to 1 :/", "tags": ["japaneseclipping"], "likes": 5, "viewed": 317, "published": "Public API", "date": "1548741216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Thanks to @FrabriceNeyret2 for all the help and code factoring :)\n\nvec2  size = vec2(.4,.25);\nconst float \n    border = .01,\n        PI = 3.14159265359;\n\n#define R             iResolution\n// Anti alisaing\n#define S(v)          smoothstep(2./R.y, 0., v)\n#define circle(U,r)   S( length(U)-(r) )\n#define rot(a)        mat2(cos(a),-sin(a), sin(a),cos(a))\n\nfloat box( vec2 U,  vec2 r){\n    U = S( abs(U) - .5*r );\n    return U.x*U.y;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    // Normalized Coords * square rotation from center of box aka actually rotating everything \n\tU = ( U/R.xy - .5) * rot (PI * sin(iTime / 8.) ); \n    \n    // M = mask;\n    // M.x = rect without border\n    // M.y = rect with border\n    vec2 M = vec2(0), D;\n    for (float t, i=0.; i<5.; i++) {\n        // Rotation from center of page\n        t = iTime + 2.*PI/5.*i;\n        D = .2 * vec2( sin(t), cos(t)*1.5 );\n        // A new box will only add if M.y has not been already set to white by previous boxes.\n        // Making it so M.x(which is smaller) does not add itself onto previous boxes borders\n        M += (1.-M.y)* vec2( box(U+D, size), box(U+D, size+border) );\n    }\n    \n    O = mix( vec4(1), vec4(.9,.3,.3,1) , circle(U,.27 ));\n\t// This mixes M.x with M.y where M.y has the squares as black and\n\t// and M.x has its square as white(mixed witht the circle)\n    // So when they add, the only part that is black in both is the border\n    // O = mix( vec4(1), O*M.x, M.y);\n    \n    // This other version does the same but instead M.x becones -1 to 0 and when multiplied my M.y\n    // Every black pixel which is now -1 that is outside M.y squares becomes 0\n    // And when adding +1. It becomes white.\n    // Basically, making everything outside M.y white\n    O = 1. + (O*M.x - 1.) * M.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 356, 384, 384, 434], [436, 436, 473, 569, 1770]]}
{"id": "3sl3zS", "name": "Music Bowl", "author": "slimyfrog", "description": "Using fft and waveform to affect shapes", "tags": ["music"], "likes": 2, "viewed": 121, "published": "Public", "date": "1546728561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DISTANCE   50.0\n#define MIN_DISTANCE   0.01\n\n\nmat3 rMatrix;\nmat3 ballMatrix;\nvec2 uv;\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\n// smooth min from iq\nfloat smoothmin( float a, float b)\n{\n    float h = max( 1.0-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h*(1.0/6.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sdPlane(vec3 p)\n{    \n    // the sound texture is 512x2\n    int tx = int(length(p) * 5.0);\n\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n\n    float dist;\n    if (length(p) < 4.0)\n    {\n        dist = p.y + (1.0 - fft * 1.0);\n    }\n   \telse\n    {\n        dist = p.y + (1.0 - fft * -2.0);\n    }\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sdBox( vec3 p, vec3 size)\n{\n  vec3 d = abs(p) - size;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p)\n{\n    int tx = int(uv.x*512.0);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    float dist = sdPlane(p);\n    \n    vec3 sp = ballMatrix * p/2.0;\n    float shapeDist = mix(sdBox(sp, vec3(wave)), sdTorus(sp, vec2(1.0 * wave, 0.5 * wave)),\n                         4.0 - wave * 4.0);\n\n    dist = smoothmin(dist, shapeDist);\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.02f;\n    \n    vec3 normal;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z)) - sceneDf(vec3(p.x - e, p.y, p.z));\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z)) - sceneDf(vec3(p.x, p.y - e, p.z));\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e)) - sceneDf(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat calcShadow(vec3 pt, vec3 dir)\n{\n    float shade = 1.0;\n\tfloat t = 0.001;\n    while(t < 6.0)\n    {\n        float dist = sceneDf(pt + dir * t);\n        t += dist;\n        shade = smoothmin(shade, 4.0 * dist/t);\n        if (dist <= 0.0001){\n            break;\n        }\n    }\n    return clamp(shade, 0.0, 1.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 normal = calcNormal(surfacePoint);\n    vec3 diffuseDir = normalize(vec3(sin(iTime),-1.0,cos(iTime)));\n    \n    float shaded = calcShadow(surfacePoint, -diffuseDir);\n    \n    float diffDot = clamp(dot(-diffuseDir, normal), 0.0, 1.0);\n    vec3 diffuse = (diffDot * vec3(0.0,1.0,1.0)) * shaded;\n            \n    vec3 fillDir = normalize(-diffuseDir * vec3(-1.0, 0.0, -1.0));\n    float fillDot = clamp(dot(fillDir, normal), 0.0, 1.0);\n    vec3 fill = (fillDot * vec3(1.0,1.0,0.4));\n  \n    vec3 color = vec3(0.1, 0.1, 0.1);\n    surfacePoint *= rMatrix;\n\n    vec3 material = vec3(1.0 - 0.5*sin(surfacePoint.x), 1.0 - 0.5*cos(iTime), 1.0 - 0.5*sin(surfacePoint.z));\n    vec3 material2 = normal;\n    if (length(surfacePoint) > 4.0){\n        material = diffuseDir * vec3(sin(iTime)*1.5, 1.2, cos(iTime)*1.5);\n    }\n    else{\n        material = mix(material , material2 , clamp(surfacePoint.y + 1.0, 0.0, 1.0));\n    }\n    return material * (diffuse + fill);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir, vec2 uv)\n{\n    vec3 color =  vec3(0.8) + dir;\n    float t = 0.0001;\n    while(t < MAX_DISTANCE)\n    {\n        vec3 currentPoint = eyePos + (t * dir);\n        float dist = sceneDf(currentPoint);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(0.1, 0.1, 0.1), eyePos, currentPoint);\n            break;\n        }\n        t += dist;\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    rMatrix = rotateMat(0.0, iTime, 0.0);\n    ballMatrix = rotateMat(iTime, 0.0, iTime);\n     // camera\t\n\tvec3 eye = vec3(0.0,  3.0, 11.0);\n    vec3 lookat = vec3( 0.0, -0.2, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir, uv);\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sl3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 151, 151, 512], [514, 536, 572, 572, 656], [658, 787, 810, 848, 1190], [1193, 1322, 1355, 1355, 1454], [1456, 1456, 1489, 1489, 1554], [1556, 1685, 1708, 1708, 2127], [2129, 2258, 2283, 2283, 2609], [2612, 2741, 2778, 2778, 3056], [3058, 3187, 3257, 3257, 4216], [4218, 4347, 4393, 4393, 4773], [4777, 4906, 4963, 4995, 5681]]}
{"id": "3slGWl", "name": "[Ese] Voronoi", "author": "Eseris", "description": "voronoi", "tags": ["voronoi"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1547799233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Pi = 3.1415926535;\n\nvec2 hash22(vec2 st){\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return fract(sin(st) * 43758.5453123);\n}\n\n\nfloat hash21(vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise21(vec2 uv) {\n\tvec2 f = fract(uv);\n\tvec2 i = floor(uv);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash21(i), hash21(i + vec2(1,0)), f.x),\n\t\tmix(hash21(i + vec2(0,1)), hash21(i + vec2(1,1)), f.x), f.y);\n}\n\nvec2 noisyMove(vec2 id, float time) {\n\treturn vec2(\n\t\tnoise21(20. * hash22(id) + time),\n\t\tnoise21(-20. * hash22(id) + time));\n}\n\n\nvec3 voronoi(vec2 x) {\n    vec2 ix = floor(x);\n    vec2 fx = fract(x);\n    float w = .03;\n    \n    float mdist = 8.;\n    vec2  dir   = vec2(0);\n    vec3  col   = vec3(0);\n    \n    for(int j = -1; j <= 1; j++) {\n        for(int i =- 1; i <= 1; i++) {\n            vec2 next = vec2(i, j);\n            vec2 pt = noisyMove(ix + next, .3 * iTime);\n            vec2  diff = vec2(next) - fx + pt;\n        \tfloat weight = dot(pt, pt) * .5 + .5;\n            float dist = length(diff) * pow(weight, .3);\n            \n    \t\tvec3 bcol = mix(vec3(.3, .8, .1), vec3(.9, .95, .1), hash21(ix + next));\n            \n            float h = smoothstep(0., 1., 0.5 + .5*(mdist - dist)/w );\n\t    \tmdist = mix(mdist, dist, h);\n\t\t\tdir   = mix(dir,   diff, h);\n           \tcol   = mix(col,   bcol, h);\n        }\n\t}\n    \n    float angle = atan(dir.y, dir.x) / Pi;\n    angle = .5 * angle + .5;\n    float light = .5 + .5 * sin((angle - .1) * 2. * Pi);\n    \n    col = mix(col, vec3(.07, .1, .05), 1.2 * mdist);\n    return col + .3 * pow(1. - mdist, 2.) * (2. * light - 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 col = voronoi(4. * uv);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 53, 53, 171], [174, 174, 196, 196, 268], [270, 270, 294, 294, 489], [491, 491, 528, 528, 618], [621, 621, 643, 643, 1666], [1668, 1668, 1723, 1723, 1829]]}
{"id": "3slGzf", "name": "Play With Raymarch", "author": "macufrax", "description": "First play with Raymarching\nBased on https://www.shadertoy.com/view/llt3R4 and http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/ and distance function from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n", "tags": ["raymarch"], "likes": 2, "viewed": 322, "published": "Public API", "date": "1548190866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 1 Challenges\n * - Make the circle yellow\n * - Make the circle smaller by decreasing its radius\n * - Make the circle smaller by moving the camera back\n * - Make the size of the circle oscillate using the sin() function and the iTime\n *   uniform provided by shadertoy\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n\nfloat displacement( vec3 p )\n{\n    //return sin(1.5*p.x)*sin(1.2*p.y)*sin(1.1*p.z);\n    return (sin(10.0*p.x)/16.0) * (sin(32.0*p.y+iTime*2.0)*2.0) ;\n}\n\nfloat opDisplace( float v, in vec3 p )\n{\n    float d1 = v;\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    \n    float s1 = sphereSDF(samplePoint+vec3(.0,.0,.3), 1.0);\n    float s2 = sphereSDF(samplePoint+vec3(.5+(sin(iTime/2.)*1.5), .2+(sin(iTime/2.)*1.), -.5), 0.7);    \n    \n    float d = opSmoothUnion( s2, s1, 0.5); \n    //float d = opSmoothSubtraction( s2, s1, 0.1); \n    \n    return d;\n    //return opDisplace( d, samplePoint);\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.1, 0.1, 0.3);\n    vec3 K_d = vec3(0.1, 0.5, 0.5);\n    vec3 K_s = vec3(0.5, 0.2, 0.1);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 500, 544, 544, 582], [584, 584, 636, 636, 736], [738, 738, 796, 796, 897], [899, 899, 958, 958, 1058], [1061, 1061, 1091, 1144, 1212], [1214, 1214, 1254, 1254, 1324], [1328, 1568, 1602, 1602, 1935], [1937, 2026, 2055, 2055, 2365], [2367, 2859, 2999, 2999, 3589], [3591, 3961, 4046, 4046, 4846], [4848, 5269, 5360, 5360, 5666], [5681, 5935, 6000, 6000, 6132], [6135, 6135, 6192, 6192, 6908]]}
{"id": "3slGzX", "name": "Metaballs I", "author": "Sevapp", "description": "Metaballs ", "tags": ["metaballs"], "likes": 5, "viewed": 242, "published": "Public", "date": "1547042838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sum  = 0.0, \n          seed = 0.0;\n    float time = sin(iTime * .5) * 2.0;\n    \n    for (int i = 0; i < 100; i ++)\n    {\n        seed =  mod(seed * 106.0 + 1283.0, 6075.0);\n        sum  += (iResolution.x + iResolution.y) / 600.0 / distance(fragCoord.xy, vec2(\n            iResolution.x / 2.0 + mod(seed, iResolution.x) * cos(-time - seed) * time,\n            iResolution.y / 2.0 + mod(seed, iResolution.y) * sin(seed  + time) * time\n        ));\n    }\n    fragColor = mix(\n        vec4(fragCoord.xy / iResolution.xy, 0.5 + 0.5 * sin(time), 1.0), \n        vec4(sum, 0.0, sum, sum), 0.6\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 660]]}
{"id": "3sS3DW", "name": "Ray Marching playground", "author": "lams3", "description": "A simple ray marched scene for learning purposes.", "tags": ["raymarching"], "likes": 3, "viewed": 366, "published": "Public API", "date": "1548810630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.001f;\n\nstruct intersection {\n    bool hit;\n    vec3 point;\n    vec3 normal;\n};\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n\tvec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    mat4 translation = mat4(\n        vec4(1.0, 0.0, 0.0, eye.x),\n    \tvec4(0.0, 1.0, 0.0, eye.y),\n        vec4(0.0, 0.0, 1.0, eye.z),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 rotation = transpose(\n        mat4(\n            vec4(x, 0.0),\n            vec4(y, 0.0),\n            vec4(z, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0)\n        )\n    );\n    return translation * rotation;\n}\n\nvec3 getRayDir(mat4 camera, float fov, vec2 pixel) {\n    vec2 p = 2.0 * ((pixel / iResolution.xy) - vec2(0.5, 0.5));\n    vec2 h = vec2(\n        tan(fov / 2.0) * (iResolution.x / iResolution.y), \n        tan(fov / 2.0)\n    );\n    vec3 pCam = vec3(p * h, -1.0);\n\treturn normalize((inverse(camera) * vec4(pCam, 0.0)).xyz);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1,d2);\n}\n\nfloat subtractionSDF(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat intersectionSDF(float d1, float d2, float k) {\n    return max(d1,d2);\n}\n\nfloat smoothUnionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smoothSubtractionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smoothIntersectionSDF(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 point) {\n    return length(point) - 1.0f;\n}\n\nfloat torusSDF(vec3 point) {\n    vec2 t = vec2(1.5f, 0.2f);\n\tvec2 q = vec2(length(point.xy) - t.x, point.z);\n    return length(q) - t.y;\n}\n\nfloat sceneSDF(vec3 point) {\n\t//return torusSDF(point - vec3(0.0f, 0.0f, 5.0f));\n    return smoothUnionSDF(\n        sphereSDF(point - vec3(0.0f, 0.0f, 5.0f + cos(iTime))),\n        torusSDF(point - vec3(0.0f, 0.0f, 5.0f)),\n        1.25f\n    );\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n    \tsceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n    \tsceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nintersection rayMarch(vec3 origin, vec3 direction, float tMin, float tMax) {\n    for (float t = tMin; t < tMax; ) {\n        vec3 p = origin + t * direction;\n    \tfloat d = sceneSDF(p);\n        if (d < EPSILON)\n            return intersection(true, p, estimateNormal(p));\n        t += abs(d);\n    }\n    return intersection(false, vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(5.0, 0.0, 0.0);\n    vec3 target = vec3(0.0, 0.0, 5.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float fov = radians(45.0);\n    \n    mat4 camera = lookAt(eye, target, up); \n    vec3 rayDir = getRayDir(camera, fov, fragCoord);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime + uv.xyx + vec3(0,2,4));\n\n    // Output to screen\n    intersection itsc = rayMarch(eye, rayDir, 1.0, 100.0);\n    float diff = clamp(dot(itsc.normal, normalize(eye - itsc.point)), 0.0, 1.0);\n    if (itsc.hit)\n    \tfragColor = vec4(col * diff, 1.0);\n    else\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sS3DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 149, 149, 647], [649, 649, 701, 701, 970], [972, 972, 1008, 1008, 1033], [1035, 1035, 1077, 1077, 1103], [1105, 1105, 1157, 1157, 1182], [1184, 1184, 1235, 1235, 1334], [1336, 1336, 1393, 1393, 1493], [1495, 1495, 1553, 1553, 1652], [1654, 1654, 1683, 1683, 1718], [1720, 1720, 1748, 1748, 1858], [1860, 1860, 1888, 1940, 2104], [2106, 2106, 2135, 2135, 2432], [2434, 2434, 2510, 2510, 2813], [2815, 2815, 2872, 2872, 3583]]}
{"id": "3sS3Rz", "name": "Sun noise attempt", "author": "naxius", "description": "experimenting with noise", "tags": ["noise", "sun"], "likes": 1, "viewed": 97, "published": "Public", "date": "1547906597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(float seed)\n{\n    return fract(sin(19776.15*seed)*1429.14+sin(0.3*iTime));\n}\n\nfloat smootherstep(float start, float end, float u)\n{\n    float p  = (u-start)/(end-start);\n    p =clamp(p, 0., 1.);\n    return 0.5*p*(p*(5.-4.*p)+1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy) / iResolution.y;\n    float r = length(uv);\n    float a = atan(uv.y,uv.x);\n    vec3 color ;\n    //circle\n    float f = 1.-smootherstep(.9, 1., r);\n    color = mix(color, vec3(1.,.6,0.), f);\n    //crown\n    f = (1.-smoothstep(1., 1.03, r+0.1*noise(a)))*smoothstep(0.7, 1., r)*step(0.4,noise(a*r));\n    color = mix(color, vec3(1.,.4,0.), f);\n    //spots 1\n    float l =length(uv-0.3);\n    f = noise(sin(0.001*l+0.01*a));\n\tf*= (1.-smoothstep(.9,1.05,length(uv)));\n    f = step(0.5,f);\n    color = mix(color, vec3(1.,.2,0.), f);\n    //spots 2\n    l =length(uv+0.4);\n    f = noise(sin(0.001*l+0.01*a));\n\tf*= (1.-smoothstep(0.8,1.3,length(uv)));\n    f = step(0.85,f);\n    color = mix(color, vec3(1.,.1,0.), f);\n    //spots \n    l =length(uv+0.4);\n    f = noise(sin(0.021*l+0.01*a));\n\tf*= (1.-smoothstep(0.,1.2,length(uv-0.3)));\n    f = step(0.7,f);\n    color = mix(color, vec3(1.,.05,0.), f);\n   \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sS3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 88], [90, 90, 143, 143, 243], [245, 245, 302, 302, 1273]]}
{"id": "3ss3z2", "name": "Sekundnik", "author": "tomaszborsukowski", "description": "Shader tworzy sekundnik, zielona kulka jest środkiem tarczy sekundnika. Niebieska kulka jest wskazówką sekundnika porusza się w linii prostej od środka tarczy (zielona kulka) do krańca tarczy (półksiężyc). Na podstawie Tutorialu GSLS 2D", "tags": ["sekundnik"], "likes": 2, "viewed": 46, "published": "Public", "date": "1546897547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader sekundnik\n//Ustalanie globalnych wartości\nfloat PI = 3.141592; //liczba PI\nfloat dist = 100.0; //dystans do dyspozycji dla piłeczki\nfloat r2 = 130.0; //promień koła odejmującego kolor od księżyca\nfloat width = 10.0; //uśredniona grubość księżyca\nfloat gap;\nfloat ballwidth = 5.0; //promień piłeczki\nvec2 ballpos = vec2(0.0, 0.0);\nfloat ballmaxdist;\nfloat balldiff;\nfloat r;\nvec2 bouncermiddle;\nvec2 clearmiddle;\nvec2 zero;\n\n//funkcja przemieszczająca środek koła z którego wycinany jest księżyc i obracająca dookoła tego środka drugie koło\nvoid setmiddle(float time){\n    bouncermiddle = zero+vec2(sin(2.0*PI*time)*dist, cos(2.0*PI*time)*dist);\n    clearmiddle = bouncermiddle+vec2(sin(2.0*PI*(time*60.0+time))*(gap-ballwidth),cos(2.0*PI*(time*60.0+time))*(gap-ballwidth));\n}\n\n//funkcja ustalająca ruch piłeczki\nvoid setball(float time){\n    float halfsec = floor(time*120.0);\n    float sec = floor(time*60.0);\n    float partsec = mod(time*60.0, 1.0);\n    float halfasec = mod(time*60.0, 0.5);\n    ballpos.x = (zero.x + sin(2.0*PI*sec/60.0)*(ballwidth+balldiff-balldiff*abs(partsec-0.5)*2.0));\n    ballpos.y = (zero.y + cos(2.0*PI*sec/60.0)*(ballwidth+balldiff-balldiff*abs(partsec-0.5)*2.0));\n}\n\n//funkcja określająca, czy dany piksel jest częścią odbijającego księżyca\nbool isBouncer (vec2 pos, float minmod) {\n    setmiddle(minmod);\n    if (length(pos - bouncermiddle) < r && length(pos - clearmiddle) > r2) { return true; } else { return false; }    \n}\n\n//funkcja określająca, czy dany piksel jest częścią piłeczki\nbool Ball(vec2 pos, float time){\n    setball(time);\n    if (length(pos - ballpos) < ballwidth) return true; else  return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    zero = vec2(iResolution.x/2.0, iResolution.y/2.0); //określenie środka ekranu (punkt zero)\n    gap = (r2-dist)+width; //wyznacznie odległośi między środkami okręgów\n    r = dist+width; //wyznaczenie średnicy okręgu wysującego księżyc\n    ballmaxdist = dist - ballwidth; //maksymalna odległość piłeczki od punktu zero\n    balldiff = ballmaxdist*2.0 - ballwidth;\n    //utworzenie kolorów\n    vec3 bgCol = vec3(1.0, 0.0, 0.0);\n    vec3 pixel = bgCol;\n    vec3 col1 = vec3(0.5, 1.0, 0.75);\n    vec3 col2 = vec3(0.0, 0.2, 0.9);\n    vec3 col3 = vec3(0.19, 0.44, 0.27);\n    if (length(zero - fragCoord) < ballwidth) pixel = col3; //miejscowienie zielonej kulki na środku\n    float t = iTime; //pobranie czasu \n    t = mod(t, 60.0)/60.0; //przypisanie zmniennej t cząstki upłyniętej minuty\n    if (isBouncer(fragCoord, t)) {pixel = col1;} //miejscowienie odbijającego księżyca\n    if (Ball(fragCoord, t)) {pixel = col2;} //miejscowienie piłki\n    fragColor = vec4(pixel,1.0); //rysowanie\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ss3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 573, 600, 600, 808], [810, 847, 872, 872, 1230], [1232, 1314, 1355, 1355, 1499], [1501, 1568, 1600, 1600, 1697], [1699, 1699, 1756, 1756, 2768]]}
{"id": "3sSGRh", "name": "Rave heart", "author": "theepicsnail", "description": "Rainbow heart!", "tags": ["heart", "rainbow", "led"], "likes": 4, "viewed": 176, "published": "Public", "date": "1548058860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cossin(float a) { return vec2(cos(a), sin(a)); }\nconst int[] beyond = int[](\n    0,\t4064,\t2336,\t2336,\t1728,\n    0,\t448,\t672,\t672,\t288,\n    0,\t448,\t32,\t\t36,\t\t504,\n    0,\t192,\t288,\t288,\t192,\n    0,\t480,\t256,\t256,\t224,\n    0,\t192,\t288,\t288,\t4080,\t16,\n    0\n);\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvec2 rotate(vec2 uv, float a) {\n    vec2 cs = cossin(a);\n    return uv * mat2x2(cs.x, -cs.y, cs.y, cs.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 getColor(vec2 uv, int id) {\n    id = 0;\n    switch(id%6) {\n        case 0: break;\n        case 1: uv.x = abs(uv.x); break;\n        case 2: uv.y = abs(uv.y); break;\n        case 3: uv   = abs(uv);   break;\n        case 4: uv.x *= -1.0; break;\n        case 5: uv.y *= -1.0; break;\n    }\n    switch(id%5) {\n    \tcase 0: return hsv2rgb(vec3(uv.y*.1-iTime, 1, 1));\n    \tcase 1: return hsv2rgb(vec3(uv.x*.1-iTime, 1, 1));\n    \tcase 2: return hsv2rgb(vec3(length(uv)*.1-iTime, 1, 1));\n        case 3: return hsv2rgb(vec3(-iTime*.1616, 1, 1));\n        case 4: return hsv2rgb(vec3((abs(uv.x)+abs(uv.y))*.1 - iTime, 1, 1));\n    }\n    return vec3(1,0,1);\n}\n\nfloat heart(vec2 pixel_uv) {\n    pixel_uv.x = abs(pixel_uv.x); // left = right side.\n    pixel_uv.y += 2.0; // shift picture down leds\n    float arm_length = 5.0;\n    float heart_diameter=3.0;\n    float heart_thickness=1.0;\n    // rotate 45 degrees so that y-axis is pointed up/right /\n    pixel_uv = rotate(pixel_uv, 3.14159/4.0);\n    float rect_dist = sdBox(pixel_uv, vec2(0.0,arm_length));\n    float mask = abs(rect_dist-heart_diameter);\n    return mask < heart_thickness ? 1.0 : 0.0;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float boolean_mask = 1.0;\n    vec3 color = vec3(1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv*=20.0; // cells tall.\n    uv.x += .5;\n    \n    vec2 pixel_uv = floor(uv);\n    \n    \n\tboolean_mask = heart(pixel_uv);\n    \n    \n    pixel_uv = rotate(pixel_uv, -3.14159/4.0);\n    int id = int(iTime);\n    color = mix(\n        getColor(floor(uv), id),\n        getColor(floor(uv), id+1),\n        smoothstep(0.0,1.0, fract(iTime)));\n    \n    vec2 subpixel_uv = fract(uv);\n    float led = 1.0-length(subpixel_uv-.5)*2.0;\n    fragColor = vec4(1);\n    fragColor *= boolean_mask;\n    fragColor *= led*2.0;\n    fragColor.rgb *= color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 53], [262, 262, 299, 299, 383], [385, 385, 416, 416, 492], [494, 494, 516, 516, 685], [688, 688, 720, 720, 1338], [1340, 1340, 1368, 1368, 1833], [1835, 1835, 1892, 1892, 2608]]}
{"id": "3sSGzW", "name": "Exponential Noise", "author": "rodolphito", "description": "Fork of [url=https://www.shadertoy.com/view/XsX3zB]this shader[/url], making it exponential noise, based on [url=http://jcgt.org/published/0004/02/01/paper.pdf]this paper[/url].", "tags": ["exponential"], "likes": 13, "viewed": 297, "published": "Public", "date": "1548229414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright © 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec3 random3(vec3 p3)\n{\n    vec4 v = hash43(p3);\n    return (v.xyz - .5) * log(1.0-v.w) * 0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat simplex3d_fractal(vec3 m)\n{\n    float l = 2.0;\n    float il = 1.0/l;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    float result = 0.0f;\n    for (int i = 0; i < 9; i++)\n    {\n    \tresult += simplex3d(m*frequency)*amplitude;\n        frequency *= l;\n        amplitude *= il;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/iResolution.x;\n\tvec3 p3 = vec3(p, iTime*0.025);\n\t\n\tfloat value;\n\t\n\tif (p.x <= 0.6) {\n\t\tvalue = simplex3d(p3*32.0);\n\t} else {\n\t\tvalue = simplex3d_fractal(p3*8.0+8.0);\n\t}\n\t\n\tvalue = 0.5 + 0.5*value;\n\tvalue *= smoothstep(0.0, 0.005, abs(0.6-p.x)); // hello, iq :)\n\t\n\tfragColor = vec4(\n\t\t\tvec3(value),\n\t\t\t1.0);\n\treturn;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSGzW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1344, 1470, 1491, 1491, 1618], [1619, 1619, 1642, 1642, 1715], [1822, 1845, 1870, 2123, 3040], [3042, 3042, 3075, 3075, 3358], [3360, 3360, 3417, 3417, 3758]]}
{"id": "3sX3Df", "name": "Ray Marching - 001", "author": "catafest", "description": "code from https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching", "shader"], "likes": 1, "viewed": 569, "published": "Public API", "date": "1547608082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat add_Capsule(vec3 p,vec3 a,vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot( ab, ap ) / dot( ab, ab);\n    t = clamp (t,0.,1.);\n    vec3 c = a +t*ab;\n    float d = length(p -c) - r ;\n    return d;\n\n}\n\nfloat GetDist(vec3 p){\n\tvec4 s = vec4(0, 1, 6, 1);\n    float sphereDist = length (p - s.xyz)-s.w;\n    float planeDist = p.y;\n    float d = min (sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i=0; i< MAX_STEPS; i++){\n        vec3 p = ro +rd*dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if (dO>MAX_DIST || ds<SURF_DIST) break;\n        }\n    return dO; \n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    //\n    vec3 n = d - vec3(\n       //p -vec3(.01,0,0) GLSL is that the properties can be combined in any order you want,\n       //which makes it easy to cast and mix values and is called swizzle.\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (0, 5, 6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates to 0 with a resolution of 5 \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t// Set color to black\n    vec3 col = vec3(0);\n    //\n    vec3 ro = vec3(0, 1, 0);\n    //\n    vec3 rd = normalize(vec3 (uv.x, uv.y, 1));\n\n    float d = RayMarch(ro,rd);\n    // set point light long d \n    vec3 p = ro + rd * d;\n    // dif is difuse\n    float dif = GetLight(p);\n        \n    //d/=6.;\n    //col = vec3(d);\n    col = vec3 (dif);\n    \n    // Send output to color named col to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sX3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 116, 116, 295], [297, 297, 319, 319, 480], [482, 482, 515, 515, 725], [727, 727, 750, 750, 1109], [1111, 1111, 1134, 1134, 1427], [1429, 1429, 1486, 1551, 2037]]}
{"id": "3sXGW2", "name": "Hurtful Love - Reuploaded", "author": "ReavenTehDerg", "description": "I had to delete my previous account.So im reuploading this here.Even though i removed this shader, webpage still says this shader exist.", "tags": ["colorful", "heart", "multiscene"], "likes": 1, "viewed": 175, "published": "Public", "date": "1547478284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(float value, float t)\n{\n    return value / 1.0 * t;\n}\nfloat map2(float value, float fromSource, float toSource, float fromTarget, float toTarget)\n{\n    return (value - fromSource) / (toSource - fromSource) * (toTarget - fromTarget) + fromTarget;\n}\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2(8356.655414, 645.8778));\n    p += dot(p, p + 72.724);\n    return fract(p.x * p.y);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * iTime;\n    return sin(n) * .4;\n}\nvec3 HeartScene(vec2 uv, vec3 color)\n{    \n    float beat = abs(sin(iTime * 0.3));\n    uv.x *= map2(sin(iTime * 0.6), -1.0, 1.0, 0.7, 1.5);\n    uv.y *= map2(cos(iTime * 0.7), -1.0, 1.0, 1.0, 1.1);\n    uv.y -= sqrt(abs(uv.x * 0.7)) * 0.5;\n    \n    float c = smoothstep(0.3, map(beat, .29), length(uv));\n    if(c > 0.0) color += c;\n\n    return color;\n}\nvec3 DepressionScene(vec2 uv)\n{\n\n    vec3 color = vec3(1.0);\n    color = vec3(uv.x + sin(iTime)) * vec3(0.2, 0.6, 0.9);\n    color *= HeartScene(uv, color);\n    color *= mod(gl_FragCoord.x * gl_FragCoord.y, 2.0);\n    return color;\n}\nfloat GenerateFlake(vec2 uv)\n{\n    uv *= 4.0;\n    uv.y += iTime / 2.;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    //if(gv.x > 0.49 || gv.y > 0.49) color = vec3(1, 0, 0);\n\n    \n    vec2 p = GetPos(id);\n    float d = length(gv - p);\n    float flake = smoothstep(0.1, 0.0, d) / (d * 100.);\n    return flake;\n}\nvec3 RotatingGradientBG(vec2 uv, vec3 color)\n{\n    float cosTime = cos(iTime);\n    float sinTime = sin(iTime);\n    vec2 rotUV = uv * mat2(cosTime, -sinTime, sinTime, cosTime);\n    color *= vec3(rotUV, 0.8);\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y * 2.;\n\n    vec3 color = vec3(1.0);\n    float fade = clamp(5.0 * sin(iTime * 0.4), -1.0, 1.0);\n\n    if(fade >= 0.0)\n    {\n        color *= RotatingGradientBG(uv, color);\n        color *= HeartScene(uv, color);\n        color += GenerateFlake(uv);\n        color = color * abs(fade);\n    }\n    if(fade < 0.0)\n    {\n        color = DepressionScene(uv);\n        color = color * abs(fade);\n    }\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 63], [64, 64, 157, 157, 257], [258, 258, 277, 277, 385], [386, 386, 404, 404, 477], [478, 478, 500, 500, 556], [557, 557, 595, 595, 907], [908, 908, 939, 939, 1139], [1140, 1140, 1170, 1170, 1462], [1463, 1463, 1509, 1509, 1689], [1690, 1690, 1747, 1747, 2240]]}
{"id": "3sXGzl", "name": "cube cube", "author": "changjiu", "description": "my second WebGL program.\nthe simpler one at https://www.shadertoy.com/view/tsXGzf", "tags": ["cube"], "likes": 0, "viewed": 354, "published": "Public API", "date": "1547128968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  \n * @author changjiu\n * @date 2019.1.10\n * @contact  drift bottle\n**/\n\n/*\n * @作者 长久兄\n * @日期 2019.1.10\n * @联系方式 漂流瓶\n**/\n\nstruct Triangle\n{\n    \n    vec3 a; //pointA\n    vec3 b;\t//pointB\n    vec3 c;\t//pointC\n    vec3 n; //normal\n\n};\n\nTriangle triangles[12];\nTriangle triangles2[12];\n\nvoid getOneCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -1.0 );\n    verts[1] = vec3( -1.0, -1.0,  1.0 );\n    verts[2] = vec3( -1.0,  1.0, -1.0 );\n    verts[3] = vec3( -1.0,  1.0,  1.0 );\n    verts[4] = vec3(  1.0, -1.0, -1.0 );\n    verts[5] = vec3(  1.0, -1.0,  1.0 );\n    verts[6] = vec3(  1.0,  1.0, -1.0 );\n    verts[7] = vec3(  1.0,  1.0,  1.0 );\n\n    triangles[0].a = verts[1];\n    triangles[0].b = verts[5];\n    triangles[0].c = verts[7];\n    triangles[0].n = vec3( 0.0, 0.0, 1.0 );\n    \n    triangles[1].a = verts[1];\n    triangles[1].b = verts[7]; \n    triangles[1].c = verts[3];\n    triangles[1].n = vec3( 0.0, 0.0, 1.0 );\n\n\n    triangles[2].a = verts[5];\n    triangles[2].b = verts[4];\n    triangles[2].c = verts[6];\n    triangles[2].n = vec3( 1.0, 0.0, 0.0 );\n\n    triangles[3].a = verts[5];\n    triangles[3].b = verts[6];\n    triangles[3].c = verts[7];\n    triangles[3].n = vec3( 1.0, 0.0, 0.0 );\n\n\n    triangles[4].a = verts[3];\n    triangles[4].b = verts[7];\n    triangles[4].c = verts[6];\n    triangles[4].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles[5].a = verts[3];\n    triangles[5].b = verts[6];\n    triangles[5].c = verts[2];\n    triangles[5].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles[6].a = verts[0];\n    triangles[6].b = verts[6];\n    triangles[6].c = verts[4];\n    triangles[6].n = vec3( 0.0, 0.0, -1.0 );\n\n    triangles[7].a = verts[0];\n    triangles[7].b = verts[2];\n    triangles[7].c = verts[6];\n    triangles[7].n = vec3( 0.0, 0.0, -1.0 );\n\n\n    triangles[8].a = verts[1];\n    triangles[8].b = verts[2];\n    triangles[8].c = verts[0];\n    triangles[8].n = vec3( -1.0, 0.0, 0.0 );\n\n    triangles[9].a = verts[1];\n    triangles[9].b = verts[3];\n    triangles[9].c = verts[2];\n    triangles[9].n = vec3( -1.0, 0.0, 0.0 );\n\n\n    triangles[10].a = verts[1]; \n    triangles[10].b = verts[0]; \n    triangles[10].c = verts[4]; \n    triangles[10].n = vec3( 0.0, -1.0, 0.0 );\n\n    triangles[11].a = verts[1]; \n    triangles[11].b = verts[4];\n    triangles[11].c = verts[5];\n    triangles[11].n = vec3( 0.0, -1.0, 0.0 );\n\n}\n\nvoid getOneCube2( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -1.0 - 3.0 );\n    verts[1] = vec3( -1.0, -1.0,  1.0 - 3.0 );\n    verts[2] = vec3( -1.0,  1.0, -1.0 - 3.0 );\n    verts[3] = vec3( -1.0,  1.0,  1.0 - 3.0 );\n    verts[4] = vec3(  1.0, -1.0, -1.0 - 3.0 );\n    verts[5] = vec3(  1.0, -1.0,  1.0 - 3.0 );\n    verts[6] = vec3(  1.0,  1.0, -1.0 - 3.0 );\n    verts[7] = vec3(  1.0,  1.0,  1.0 - 3.0 );\n\n    triangles2[0].a = verts[1];\n    triangles2[0].b = verts[5];\n    triangles2[0].c = verts[7];\n    triangles2[0].n = vec3( 0.0, 0.0, 1.0 );\n    \n    triangles2[1].a = verts[1];\n    triangles2[1].b = verts[7]; \n    triangles2[1].c = verts[3];\n    triangles2[1].n = vec3( 0.0, 0.0, 1.0 );\n\n\n    triangles2[2].a = verts[5];\n    triangles2[2].b = verts[4];\n    triangles2[2].c = verts[6];\n    triangles2[2].n = vec3( 1.0, 0.0, 0.0 );\n\n    triangles2[3].a = verts[5];\n    triangles2[3].b = verts[6];\n    triangles2[3].c = verts[7];\n    triangles2[3].n = vec3( 1.0, 0.0, 0.0 );\n\n\n    triangles2[4].a = verts[3];\n    triangles2[4].b = verts[7];\n    triangles2[4].c = verts[6];\n    triangles2[4].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles2[5].a = verts[3];\n    triangles2[5].b = verts[6];\n    triangles2[5].c = verts[2];\n    triangles2[5].n = vec3( 0.0, 1.0, 0.0 );\n\n    triangles2[6].a = verts[0];\n    triangles2[6].b = verts[6];\n    triangles2[6].c = verts[4];\n    triangles2[6].n = vec3( 0.0, 0.0, -1.0 );\n\n    triangles2[7].a = verts[0];\n    triangles2[7].b = verts[2];\n    triangles2[7].c = verts[6];\n    triangles2[7].n = vec3( 0.0, 0.0, -1.0 );\n\n\n    triangles2[8].a = verts[1];\n    triangles2[8].b = verts[2];\n    triangles2[8].c = verts[0];\n    triangles2[8].n = vec3( -1.0, 0.0, 0.0 );\n\n    triangles2[9].a = verts[1];\n    triangles2[9].b = verts[3];\n    triangles2[9].c = verts[2];\n    triangles2[9].n = vec3( -1.0, 0.0, 0.0 );\n\n\n    triangles2[10].a = verts[1]; \n    triangles2[10].b = verts[0]; \n    triangles2[10].c = verts[4]; \n    triangles2[10].n = vec3( 0.0, -1.0, 0.0 );\n\n    triangles2[11].a = verts[1]; \n    triangles2[11].b = verts[4];\n    triangles2[11].c = verts[5];\n    triangles2[11].n = vec3( 0.0, -1.0, 0.0 );\n\n}\n\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\n\nvec3 getCameraPosition(){\n    vec2 mouse = iMouse.xy/iResolution.xy*3.0;\n    \n\tvec3 cameraPosition;\n    \n    cameraPosition.x = sin(iTime + mouse.x)*4.0;\n    cameraPosition.y = sin(iTime + mouse.y)*10.0;\n    cameraPosition.z = cos(iTime + mouse.x)*10.0;\n\treturn cameraPosition;\n}\n\nvec4 getFinalV4(vec4 v4) {\n    \n    mat4 modelMatrix = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t//mat4 viewMatrix = mat4(1, 0, -0, 0, -0, 1, -0, 0, 0, 0, 1, 0, 0, 0, -100, 1);\n    \n    vec3 cameraPosition = getCameraPosition();\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\t//mat4 projectMatrix = mat4(2.4142136573791504, 0, 0, 0, 0, 2.4142136573791504, 0, 0, 0, 0, -1.0202020406723022, -1, 0, 0, -2.0202019214630127, 0);\t\n    \n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 mvpMatrix = projectMatrix * viewMatrix * modelMatrix;\n    \n    return mvpMatrix * v4;\n}\n\nvec4 V3ToV4(vec3 v3) {\n    \n    return vec4(v3.xyz, 1.0);\n    \n}\n\nvec2 V3ToV2(vec3 v3) {\n\n    //v3 project to iResolution.xy\n\n    float x = round(iResolution.x/2.0 + v3.x*iResolution.x/2.0);\n    float y = round(iResolution.y/2.0 + v3.y*iResolution.y/2.0);\n    return vec2(x, y);\n\n}\n\nvec2 V4ToV2(vec4 v4) {\n\n    //v4 project to between -1.0 and 1.0\n\n    vec3 v3 = vec3(v4.xyz);\n\n    v3 = v3 / v4.w;\n\n    return V3ToV2(v3);\n}\n\nfloat v2Cross(vec2 v2a, vec2 v2b) {\n    return v2a.x * v2b.y - v2a.y * v2b.x;\n}\n\nbool isPointInTriangle2D(vec2 point,vec2 tpA, vec2 tpB, vec2 tpC) {\n    vec2 PA = tpA - point;\n    vec2 PB = tpB - point;\n    vec2 PC = tpC - point;\n    \n    float t1 = v2Cross(PA,PB);\n    float t2 = v2Cross(PB,PC);\n    float t3 = v2Cross(PC,PA);\n    return t1 * t2 > 0.0 && t1 * t3 > 0.0;\n}\n\nvec3 getlightDirection1(){\n\treturn getCameraPosition();\n}\n\nfloat getLightWeightByNormal(vec3 normal){\n\tfloat lightWeight = 1.0;\n    \n    vec3 lightPosition = getlightDirection1() + vec3(0,0,10);\n    \n    vec3 lightDirection1 = normalize(lightPosition);\n    \n    vec3 lightDirection2 = -1.0*lightDirection1;\n    \n    float lightWeight1 = max(0.0,dot(lightDirection1, normal));\n    \n    float lightWeight2 = max(0.0,dot(lightDirection2, normal));\n    \n\treturn lightWeight1 + lightWeight2;\n}\n\nvec3 getColorOnTriangle(Triangle triangle){\n\n    vec3 color = vec3(1,0,0);\n    \n    float lightWeight = getLightWeightByNormal(triangle.n);\n    \n    color = color * lightWeight;\n    \n    color += 0.0;\n        \n    return color;\n    \n}\n\nvec2 getV2form2Line(vec3 line1, vec3 line2){\n    vec2 v2;\n    \n\t//((b1c2-b2c1)/(a1b2-a2b1)，(a2c1-a1c2)/(a1b2-a2b1))\n    \n    v2.x = (line1.y*line2.z-line2.y*line1.z)/(line1.x*line2.y-line2.x*line1.y);\n    v2.y = (line2.x*line1.z-line1.x*line2.z)/(line1.x*line2.y-line2.x*line1.y);\n    \n\treturn v2;\n}\n\nvec3 getLineABCfrom2Point(vec2 p1, vec2 p2){\n    vec3 lineABC;\n    lineABC.x = p2.y - p1.y; //A\n\n\tlineABC.y = p2.x - p1.x; //B\n\n\tlineABC.z = p2.x * p1.y - p2.y * p1.x; //C\n    \n    return lineABC;\n\n}\n\nvec3 getV3from3v2and2v3(vec3 v3a, vec3 v3b, vec2 v2p, vec2 v2a, vec2 v2b){\n    vec3 v3;\n    \n    float ap = distance(v2a,v2p);\n    float pb = distance(v2b,v2p);\n    v3 = v3a + (v3b-v3a)*ap/(ap+pb);\n\treturn v3;\n}\n\nfloat getPointZonTriangle(vec2 v2a, vec2 v2b, vec2 v2c, vec3 v3a, vec3 v3b, vec3 v3c, vec2 p){\n\tfloat z;\n    \n    vec3 lineab = getLineABCfrom2Point(v2a, v2b);\n    vec3 linecp = getLineABCfrom2Point(v2c, p);\n    \n    vec2 v2ab = getV2form2Line(lineab, linecp);\n    \n    vec3 v3ab = getV3from3v2and2v3(v3a, v3b, v2ab, v2a, v2b);\n    \n    vec3 v3p = getV3from3v2and2v3(v3c, v3ab, p, v2c, v2ab);\n    \n    return v3p.z;\n}\n\nbool isTriangleV2clockwise(vec2 p1, vec2 p2, vec2 p3){\n    bool isTriangleV2clockwise = false;\n    \n    if ((p2.x - p1.x) *(p3.y - p1.y) -(p3.x - p1.x) *(p2.y-p1.y) < 0.0){  \n\t\tisTriangleV2clockwise = true;\n    } \n    \n    return isTriangleV2clockwise;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord;\n    \n    vec3 col;\n    \n    getOneCube();\n    \n    int index = -1;\n    \n    float zBuffer = 99999.0;\n    \n   \tfloat z = -1.0;\n    \n    for(int i=0; i<12; i++ ){\n        vec2 pA = V4ToV2( getFinalV4( V3ToV4(triangles[i].a)));\n    \tvec2 pB = V4ToV2( getFinalV4( V3ToV4(triangles[i].b)));\n    \tvec2 pC = V4ToV2( getFinalV4( V3ToV4(triangles[i].c)));\n        \n        if(isPointInTriangle2D(uv, pA, pB, pC)){\n            vec4 finalV4a = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3a = finalV4a.xyz / finalV4a.w;\n            vec4 finalV4b = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3b = finalV4b.xyz / finalV4b.w;\n            vec4 finalV4c = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3c = finalV4c.xyz / finalV4c.w;\n            //float z = (finalV3a.z+finalV3b.z+finalV3c.z)/3.0;\n                        \n            if(!isTriangleV2clockwise(pA, pB, pC)){            \n            \tindex = i;\n            \tz = getPointZonTriangle(pA, pB, pC, finalV3a, finalV3b, finalV3c, uv);\n                \n                break;\n            }\n            /*\n            if(z < zBuffer){\n            \tzBuffer = z;\n                index = i;\n            }\n\t\t\t*/\n\n        };\n    \t\n    }\n   \n    \n    getOneCube2();\n    \n    int index2 = -1;\n    float z2 = -1.0;\n    \n    for(int i=0; i<12; i++ ){\n        vec2 pA = V4ToV2( getFinalV4( V3ToV4(triangles2[i].a)));\n    \tvec2 pB = V4ToV2( getFinalV4( V3ToV4(triangles2[i].b)));\n    \tvec2 pC = V4ToV2( getFinalV4( V3ToV4(triangles2[i].c)));\n        \n        if(isPointInTriangle2D(uv, pA, pB, pC)){\n            vec4 finalV4a = getFinalV4( V3ToV4(triangles2[i].c));\n            vec3 finalV3a = finalV4a.xyz / finalV4a.w;\n            vec4 finalV4b = getFinalV4( V3ToV4(triangles2[i].c));\n            vec3 finalV3b = finalV4b.xyz / finalV4b.w;\n            vec4 finalV4c = getFinalV4( V3ToV4(triangles2[i].c));\n            vec3 finalV3c = finalV4c.xyz / finalV4c.w;\n            //float z = (finalV3a.z+finalV3b.z+finalV3c.z)/3.0;\n            \n            \n            if(!isTriangleV2clockwise(pA, pB, pC)){            \n            \tindex2 = i;\n            \tz2 = getPointZonTriangle(pA, pB, pC, finalV3a, finalV3b, finalV3c, uv);\n                \n                break;\n            }\n            /*\n            if(z < zBuffer){\n            \tzBuffer = z;\n                index = i;\n            }\n\t\t\t*/\n\n        };\n    \t\n    }\n    \n    if(index == -1 && index2 == -1){\n        col = vec3(0.2,0.2,0);\n    \t\n    }else if(index == -1 && index2 != -1){\n    \tcol = getColorOnTriangle(triangles2[index2]);\n    }else if(index != -1 && index2 == -1){\n    \tcol = getColorOnTriangle(triangles[index]);\n    }else if(index != -1 && index2 != -1){\n        if(z<z2){\n        \tcol = getColorOnTriangle(triangles[index]);\n        }else{\n        \tcol = getColorOnTriangle(triangles2[index2]);\n        }\n    \t\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 314, 339, 339, 2373], [2375, 2375, 2401, 2401, 4531], [4534, 4534, 4616, 4616, 5401], [5403, 5403, 5457, 5457, 5697], [5699, 5699, 5832, 5832, 7109], [7112, 7112, 7137, 7137, 7391], [7393, 7393, 7419, 7419, 8116], [8118, 8118, 8140, 8140, 8182], [8184, 8184, 8206, 8242, 8399], [8401, 8401, 8423, 8465, 8541], [8543, 8543, 8578, 8578, 8622], [8624, 8624, 8691, 8691, 8915], [8917, 8917, 8943, 8943, 8974], [8976, 8976, 9018, 9018, 9405], [9407, 9407, 9450, 9450, 9641], [9643, 9643, 9687, 9687, 9944], [9946, 9946, 9990, 9990, 10145], [10147, 10147, 10221, 10221, 10358], [10360, 10360, 10454, 10454, 10777], [10779, 10779, 10833, 10833, 11034], [11036, 11036, 11093, 11185, 14140]]}
{"id": "3sXGzs", "name": "Sun Rise", "author": "zktosu", "description": "Sun rise animation.", "tags": ["sun", "yellow", "motion"], "likes": 1, "viewed": 86, "published": "Public", "date": "1547151039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fg, in vec2 fc )\n{\n    vec2 uv = fc/iResolution.xy;\n    float cr = uv.x *abs(sin(iTime))*4. * uv.y;\n    vec3 col = vec3(cr,cr,1.2 - abs(cos(iTime)));\n    col += vec3(0.,0.,0.);\n    fg = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 227]]}
{"id": "4lBSWh", "name": "Crime scene...", "author": "denosya", "description": "Improvisation...", "tags": ["normalmapping"], "likes": 8, "viewed": 302, "published": "Public", "date": "1548251787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float zNear = 1.0;\nconst float zFar  = 400.0;\n\n\nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(0.0, 0.0, 4.5);\n    float radius = 4.0;\n    \n    float displacementSize = 0.8 + cos(iTime*0.25)* 0.4;\n    float displacement \t\t= sin(displacementSize*m.x)*sin(displacementSize*m.y)*sin(displacementSize*m.z) * 0.05;\n    \n    return length(m - sphereCenter) - radius + displacement; \n}\n\n\n\nvec3 computeNormalMap(in vec2 UV)\n{\n    float scale = 0.05;\n    vec2 eps = vec2(0.005, 0.0);\n    \n    float hx1 = texture(iChannel0, UV + eps.xy).x;\n    float hx2 = texture(iChannel0, UV - eps.xy).x;    \n    float hz1 = texture(iChannel0, UV + eps.yx).x;\n    float hz2 = texture(iChannel0, UV - eps.yx).x;    \n    \n    vec3 i = vec3(eps.x, 0.0, (hx2-hx1)*scale);\n    vec3 j = vec3(0.0, eps.x, (hz2-hz1)*scale);    \n    \n    return normalize(cross(i, j));\n}\n\n\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.0001) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n\n    vec2 UV = ((normal.xy + 1.0) * 0.5) * (20.0 + cos(iTime*0.01)*5.0);\n    \n    vec3 pixel = texture(iChannel0, UV).xyz;\n    \n    vec3 normalMap = computeNormalMap(UV);\n    \n    vec3 k = normal;\n    vec3 i = normalize(vec3(-k.z, 0.0, k.x));\n    vec3 j = cross(k, i);\n    \n    mat3 local = mat3(i, j, k);\n    \n\tnormal = normalMap * local;    \n    \n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = max(0.0, dot(normal, -lightRay));\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 35.0);\n    \n    float ambiant = 0.2;       \n    \n    vec3 render = pixel * (diffuse + ambiant) + hilight;\n    return vec4(render, 1.0);\n}\n\n\n// IQ's func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.5, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\n\nvec4 run(in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(5.0*cos(iTime*0.5), 3.0, -10.0);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        vec3 normal = computeNormal(m);\n        return computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        return vec4(0.0, 0, 0, 1.0);        \n    }\n    \n}\n    \n#define SUPERSAMPLING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 5x5 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.25) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.25) {\n            fragColor += run(fragCoord + vec2(dx, dy));\n        }\n    }\n    \n    fragColor /= 25.0;\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n\n    \n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 391], [395, 395, 430, 430, 851], [855, 855, 914, 914, 1351], [1354, 1354, 1441, 1441, 2151], [2154, 2170, 2203, 2203, 2412], [2416, 2416, 2446, 2446, 2966], [2995, 2995, 3052, 3052, 3381]]}
{"id": "4ldfDf", "name": "Volumetric Gas Giant", "author": "WB", "description": "Procedural volumetric gas giant made using gradient noise. Move mouse left/right to change color and up/down to change temperature.", "tags": ["procedural", "raymarching", "planet"], "likes": 3, "viewed": 175, "published": "Public", "date": "1546313453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 32\n#define MIN_DIST 0.002\n#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744\n#define _FoV 45.0\n#define _Deg2Rad 0.01745329\n#define ROTATE\n\nconst vec3 _Center = vec3(0.0,0.0,0.0);\nconst vec3 _LightCol = vec3(1.0,1.0,1.0);\nconst vec3 _LightPos = vec3(-10.0,0.0,-10.0);\n\n//const vec3 _Color = vec3(0.1, 0.1, 0.8);\n//const vec3 _Emissive = vec3(0.0, 0.0, 0.0);\nconst vec3 _UpperCloudColor = vec3(0.8,0.8, 0.8);\nconst float _FresnelPow = 23.5;\nconst float _FresnelBias = 0.0;\n\nconst float _WindSpeed1 = -0.5;\nconst float _WindSpeed2 = 1.0;\nconst float _BandScale = 0.4;\nconst float _UpperCloudStrength = 0.2;\nconst float _UpperCloudExponent = 2.0;\nconst float _Radius = 1.0;\nconst float _Oblateness = 1.06;\nconst float _TimeScale = 0.02;\nconst float _StormSpeed = 0.1;\nconst float  _StormSize = 0.34;\nconst float _StormDepth = 0.98;\nconst float _CycloneStability = -0.31;\n\n//Signed distance function for a sphere\nfloat sdSphere(vec3 position)\n{\n    position.y *= _Oblateness;\n    float d = length(_Center - position) - _Radius;\n    return d;\n}\n\n//Raymarching loop\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float dist;\n    vec3 center = _Center;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sdSphere(position);\n        if (dist < MIN_DIST)\n        {\n            return position;\n        }\n\n        position += direction * dist;\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n//Correct geodetic normal for a non-spherical ellipsoids\nvec3 geodeticNormal(vec3 p)\n{\n    vec3 axes = vec3(1.0, _Oblateness*_Oblateness, 1.0);\n    vec3 R = p - _Center;\n    return normalize(R/axes);\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float s)\n{\n    float cosTheta = cos(iTime * s);\n    float sinTheta = sin(iTime * s);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//-------------------------------------------------------------------\n// Description : Array and textureless GLSL 4D simplex\n//               noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//-------------------------------------------------------------------\n\nfloat mod289(float x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nfloat permute(float x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec3 permute(vec3 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p, s;\n\tp.xyz = floor( fract(j * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot( abs(p.xyz), ones.xyz );\n\t\n\t// GLSL: lessThan(x, y) = x < y\n\t// HLSL: 1 - step(y, x) = x < y\n\ts = vec4(\n\t\t1.0 - step(0.0, p)\n\t);\n\tp.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www; \n\t\n\treturn p;\n}\n\n//3D\nfloat snoise(vec3 v)\n{\n\tconst vec2 C = vec2(\n\t\t0.166666666666666667, // 1/6\n\t\t0.333333333333333333  // 1/3\n\t);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\n// First corner\n\tvec3 i = floor( v + dot(v, C.yyy) );\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t\n// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\t\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t\n// Permutations\n\ti = mod289(i);\n\tvec4 p = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0 )\n\t\t\t) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )\n\t\t) \t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 )\n\t);\n\t\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1/7\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\t\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\t\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\t\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\t\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\t\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\t\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\t\n//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t\n// Mix final noise value\n\tvec4 m = max(\n\t\t0.6 - vec4(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2),\n\t\t\tdot(x3, x3)\n\t\t),\n\t\t0.0\n\t);\n\tm = m * m;\n\treturn 42.0 * dot(\n\t\tm*m,\n\t\tvec4(\n\t\t\tdot(p0, x0),\n\t\t\tdot(p1, x1),\n\t\t\tdot(p2, x2),\n\t\t\tdot(p3, x3)\n\t\t)\n\t);\n}\n\n//4D\nfloat snoise(vec4 v)\n{\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t -0.447213595499958  // -1 + 4 * G4\n\t);\n\n// First corner\n\tvec4 i = floor(\n\t\tv +\n\t\tdot(\n\t\t\tv,\n\t\t\tvec4(0.309016994374947451) // (sqrt(5) - 1) / 4\n\t\t)\n\t);\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp(i0, 0.0, 1.0);\n\tvec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n\tvec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n\n\t//\tx0 = x0 - 0.0 + 0.0 * C.xxxx\n\t//\tx1 = x0 - i1  + 1.0 * C.xxxx\n\t//\tx2 = x0 - i2  + 2.0 * C.xxxx\n\t//\tx3 = x0 - i3  + 3.0 * C.xxxx\n\t//\tx4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n// Permutations\n\ti = mod289(i); \n\tfloat j0 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute(i.w) + i.z\n\t\t\t) + i.y\n\t\t) + i.x\n\t);\n\tvec4 j1 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 )\n\t\t\t\t) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )\n\t\t\t) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )\n\t\t) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 )\n\t);\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tconst vec4 ip = vec4(\n\t\t0.003401360544217687075, // 1/294\n\t\t0.020408163265306122449, // 1/49\n\t\t0.142857142857142857143, // 1/7\n\t\t0.0\n\t);\n\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt( dot(p4, p4) );\n\n// Mix contributions from the five corners\n\tvec3 m0 = max(\n\t\t0.6 - vec3(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2)\n\t\t),\n\t\t0.0\n\t);\n\tvec2 m1 = max(\n\t\t0.6 - vec2(\n\t\t\tdot(x3, x3),\n\t\t\tdot(x4, x4)\n\t\t),\n\t\t0.0\n\t);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\t\n\treturn 49.0 * (\n\t\tdot(\n\t\t\tm0*m0,\n\t\t\tvec3(\n\t\t\t\tdot(p0, x0),\n\t\t\t\tdot(p1, x1),\n\t\t\t\tdot(p2, x2)\n\t\t\t)\n\t\t) + dot(\n\t\t\tm1*m1,\n\t\t\tvec2(\n\t\t\t\tdot(p3, x3),\n\t\t\t\tdot(p4, x4)\n\t\t\t)\n\t\t)\n\t);\n}\n\nfloat ridgedNoise(vec4 position, float frequency, float amplitude)\n{\n    return((1.0 - abs(snoise(position * frequency))) * 2.0 - 1.0) * amplitude;\n}\n\nvec4 renderSurface(vec3 normal, vec3 sp, vec3 camPos, float h)\n{\n    //Mouse inputs\n    float lerp = clamp(iMouse.x/iResolution.x, 0.0, 1.0);\n    float temp = clamp(-0.5 + iMouse.y/iResolution.y, 0.0, 0.15);\n    vec3 _Color = mix(vec3(0.1,0.1,0.8), vec3(0.8,0.5,0.3), lerp);\n    vec3 _Emissive = vec3(temp, 0.0, 0.0);\n    \n    float dist = length(_Center - camPos);\n\n    vec4 seed;\n    float fade = min(0.5, max(1.0 - dist / 24.0, 0.0));\n\n    vec3 worldNormal = normal;\n\n    //Surface Distortion\n    //Calculate uv offsets\n    seed.xyz = worldNormal;\n    seed.x += _WindSpeed1 * iTime * _TimeScale;\n    seed.w = iTime * _TimeScale * 0.000001;\n    float n1 = ridgedNoise(seed, 12.0, 1.0);\n    float n2 = snoise(seed * 24.0) + n1;\n    float n3 = snoise(seed * 64.0) + n2;\n    float n4 = min(0.25,ridgedNoise(seed, 16.0, n3) - n3);\n    float offset = mix(n1 + n2, n4, fade);\n\n    //Calculate second layer of noise to simulate contra-rotation of cloud bands/zones\n    seed *= -0.5;\n    seed.x += _WindSpeed2 * iTime * _TimeScale;\n    seed.w *= 10000.0;\n    float n12 = ridgedNoise(seed, 12.0, 1.0);\n    float n22 = snoise(seed * 24.0);\n    float n32 = snoise(seed * 64.0);\n    float n42 = ridgedNoise(seed, 32.0, n32);\n    offset += mix(n12 + n22, n42, fade) * 0.9;\n\n    //Modulate noise bands by cos of lattitude\n    float factor = cos(h * 4.0) * 0.7;\n    offset *= 1.0 - factor;\n\n    //Calculate Cyclone Locations\n    float s = _StormSize;\n    vec3 n = vec3(worldNormal.x, worldNormal.y * 1.5, worldNormal.z);\n    n.x += iTime * _TimeScale * _StormSpeed;\n    float t1 = snoise(n * 2.0) - s;\n    float t2 = snoise((n + 400.0) * 2.0) - s;\n    float t3 = snoise((n + 800.0) * 2.0) - s;\n    float threshold = max(t1 * t2 * t3, 0.0) * _StormDepth;\n\n    //Cyclone offsets\n    seed.xyz = worldNormal;\n    float cycloneOffset = (snoise(seed.xyz * threshold * 0.2 + t1 + (iTime * _TimeScale * 0.2)) + snoise(seed.xyz * 0.2 + t2) + n2*_CycloneStability + snoise(seed.xyz * 0.001) + snoise(seed * 0.0001) * t3) * threshold * threshold * 175.0;\n    cycloneOffset *= sin(abs(h)/_Radius);\n    offset += cycloneOffset;\n\n    //Calculate lookup coordinate\n    float u =  h * _BandScale + offset/150.0;\n\n    //Lighting Model\n\n    //Sample texture\n    vec3 texCol = texture(iChannel0, vec2(u,0.0)).r * _Color;\n    \n    worldNormal = rotateY(worldNormal, -0.02 * _TimeScale);\n\n    //Upper Cloud Layer\n    float cloudScale = 10.0;\n    vec3 skewedSeed = vec3(worldNormal.x, worldNormal.y * 8.0 + iTime * _TimeScale * _WindSpeed1, worldNormal.z);\n    float uCloud = clamp(max(snoise(normal*2.0) + snoise(skewedSeed * cloudScale) + snoise(skewedSeed * 8.0) + snoise(skewedSeed*32.0) + n4, 0.0) * _UpperCloudStrength, 0.0, 1.0);\n    texCol.rgb = mix(texCol.rgb, _UpperCloudColor, pow(uCloud, _UpperCloudExponent));\n\n    //seed *= 8;\n    //seed.y *= 2;\n    //float spots = pow(abs(snoise(seed)), 4);\n    //texCol.rgb = lerp(texCol.rgb, _UpperCloudColor, saturate(spots));\n\n    //Calculate screen space normal from partial derivatives of color values\n    float value = dot(texCol.rgb, texCol.rgb);\n    float snx = dFdx(value);\n    float sny = dFdy(value);\n    float snz = sqrt(1.0 - snx * snx - sny * sny);\n    vec3 ssn = -vec3(snx, sny, snz);\n\n    vec3 N = mix(ssn, normal, clamp(dist/(2.5*_Radius), 0.5, 1.0));\n    //float3 N = normalize(ssn + normal*((dist)/(_Radius)));\n\n    //Calculate lambertian reflection\n    //float NdotL = max(dot(N, lightDir), 0);\n    vec3 _LightDir = -normalize(sp - _LightPos);\n    float NdotL = clamp(dot(N, _LightDir), 0.0, 1.0);\n\n    vec4 col;\n    col.rgb = texCol * _LightCol * NdotL + _Emissive;\n\n    //float w = 0.1;\n    //float3 wrappedDiffuse = lightCol * saturate((NdotL + w) / ((1 + w) * (1 + w)));\n\n    //Fresnel-based atmosphere effect. Not physically accurate but looks good from most distances and relatively cheap.\n    float fresnel = max(0.0, min(1.0, _FresnelBias + ((40.0) * pow(1.0 + dot(normalize(sp - camPos), normal), _FresnelPow))));\n    col.r *= 1. - fresnel * 1.44;\n    col.g *= 1. - fresnel * 0.9;\n    col.b *= 1. - fresnel * 0.7;\n    col.rgb += (fresnel + _Emissive) * NdotL;\n    col.rgb += _Emissive * fresnel;\n    col.a = max(0.0,1.0 - fresnel);\n\n    //if (col.a <= 0.0)\n    //{\n    //    col.rgb = vec3(0.0);\n    //}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0);\n        \n    //Compute eye vector from field of view\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan((_FoV/2.0) * _Deg2Rad);    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    rayOrigin = rotateY(rayOrigin, 0.1);\n    rayDir = rotateY(rayDir, 0.1);\n    #endif\n        \n\tvec3 sp = raymarch(rayOrigin, rayDir);\n    \n    vec3 col;\n    \n    if (sp != vec3(0.0))\n    {\n        //fragColor = vec4(0.0,0.0,0.0,1.0);\n        vec3 normal = geodeticNormal(sp);\n    \n        vec4 color = renderSurface(normal, sp, rayOrigin, sp.y);\n\t\t\t\n        col.rgb = color.rgb * color.a * color.a;\n    }\n    else\n    {\n        col.rgb += smoothstep(0.85, 0.95, abs(snoise(rotateY(rayDir, 0.1) * 128.0)));\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[902, 942, 973, 973, 1072], [1074, 1093, 1139, 1139, 1422], [1424, 1481, 1510, 1510, 1625], [1627, 1652, 1683, 1683, 1893], [1895, 2414, 2437, 2437, 2495], [2497, 2497, 2518, 2518, 2576], [2578, 2578, 2599, 2599, 2657], [2659, 2659, 2680, 2680, 2738], [2740, 2740, 2764, 2764, 2801], [2803, 2803, 2825, 2825, 2862], [2864, 2864, 2886, 2886, 2923], [2925, 2925, 2955, 2955, 3006], [3008, 3008, 3036, 3036, 3087], [3089, 3089, 3119, 3119, 3440], [3442, 3447, 3469, 3469, 5481], [5483, 5488, 5510, 5510, 7994], [7996, 7996, 8064, 8064, 8145], [8147, 8147, 8211, 8230, 12413], [12415, 12415, 12472, 12522, 13401]]}
{"id": "4lGBR1", "name": "2D Trig Mosaic", "author": "WB", "description": "A quick and simple mathematical mosaic.", "tags": ["2d"], "likes": 4, "viewed": 83, "published": "Public", "date": "1546314198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n    \n    float r = length(uv);\n    \n    float t = 25.0;\n    \n    float time = iTime;\n    \n    float a[3];\n    \n    float c = 0.0;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        \n    float s = r;\n        \n    float tuv = uv.x;\n    uv.x = uv.x - uv.y;\n    uv.y = uv.y +tuv;\n        \n    s *= (sin(abs(uv.x) * t * 0.2));\n    \n    s *= (sin(abs(uv.y) * t * 0.2));\n    \n    float m = mod(s + (time + c) * 0.2, 0.5);\n    \n    //m *= mod(r - iTime * 0.2, 0.5);\n    \n    a[i] = m;    \n        \n    c += sin(iTime);\n        \n    }\n    \n    vec3 col = vec3(a[0], a[1], a[2]);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 731]]}
{"id": "4lGfRc", "name": "Fast Nebula", "author": "WB", "description": "Faster nebula using Otavio Good's spiral noise function to generate the density distribution.", "tags": ["nebula"], "likes": 18, "viewed": 343, "published": "Public", "date": "1546313982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 128\n#define STEP_SIZE 0.05\n#define _FoV 45.0\n#define _Quality 5\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Absorption = vec3(0.7,0.6,0.4);\nconst vec3 _Ambient = vec3(0.4,0.15,0.2);\nconst vec3 _Light = vec3(1.0,1.0,1.0);\nconst vec3 _LightPos = vec3(0.0, 0.0, 0.0);\nconst float _LightIntensity = 2.0;\nconst float _Density = 10.0;\nconst float _Radius = 1.0;\nconst float _Mie = 0.6;\nconst float _G = 0.7;\n\n//Improved Heyney-Greenstein phase function\nfloat cornetteShanksPhase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Otavio Good's noise from https://www.shadertoy.com/view/ld2SzK\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float rr = dot(pos,pos);\n    rr = sqrt(rr);\n    float f = exp(-rr);\n    float p = f * _Density;\n    \n    if (p <= 0.0)\n        return p;\n    \n    p += SpiralNoiseC(128.0 + pos * 4.0) * 0.75;\n    pos = rotateY(pos, pos.y * SpiralNoiseC(pos * 2.0)* 2.0);\n    p += SpiralNoiseC(100.0 + pos * 6.0) * 1.5;\n\n    p = max(0.0,p);\n                \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = _LightIntensity/dot(r, r);\n            vec3 ext = max(vec3(0.000001), (_Absorption * p) + vec3(_Mie * p));\n            vec3 trans = exp(-ext * ds);\n            vec3 lightDir = normalize(r);\n            float mu = dot(lightDir, -dir);\n            float phase = cornetteShanksPhase(mu, _G);\n            vec3 lum = _Ambient + _Light * phase * (1.0-_Absorption) * _Mie * p * atten;\n            vec3 integral = (lum - (lum*trans))/ext;\n            \n            result.rgb += integral * result.a;\n            vec3 div = vec3(0.3333333);\n            result.a *= dot(trans, div);\n            \n            if (result.a <= 0.1)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    rayDir = rotateY(rayDir, iTime * 0.1);\n    rayOrigin = rotateY(rayOrigin, iTime * 0.1);\n    #endif\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rayDir * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGfRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 466, 512, 512, 636], [638, 664, 750, 750, 1204], [1206, 1231, 1262, 1262, 1456], [1458, 1480, 1501, 1501, 1670], [1672, 1672, 1698, 1698, 2523], [2525, 2765, 2793, 2793, 3342], [3344, 3344, 3402, 3402, 3566], [3568, 3568, 3598, 3598, 3957], [3959, 3959, 4011, 4011, 5032], [5034, 5302, 5359, 5359, 6665]]}
{"id": "4llBDN", "name": "Rainbow Spectrum", "author": "lanelet", "description": "Attempt to generate a spectrum from mathematical functions.", "tags": ["spectrum", "rainbow"], "likes": 3, "viewed": 74, "published": "Public", "date": "1548456252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float u = uv.x;\n    float v = uv.y;\n    \n    float r = (abs(u-0.5)*2.0);\n    if( u > 0.5 )\n        r = r*r*r*r*r*r;\n    \n    float g = (abs(u-0.5)*2.0);\n    g = g*g;\n    g = 1.0-g;\n    g = sqrt(g)/2.0;\n    \n    float b = u;\n    b = b*b;\n    \n    float a = abs(u-0.5)*2.0;\n    a = a*a*a;\n    a = 1.0-a;\n\n    r += g/2.0;\n    b += g/2.0;\n    \n    r *= sin(iTime/2.0)/2.0+0.5;\n    g *= sin(iTime/3.0)/2.0+0.5;\n    b *= sin(iTime/5.0)/2.0+0.5;\n    \n\tfragColor = vec4(r,g,b,1.0)*a;\n    \n    if( v > fragColor.x/2.0+0.5 )\n        fragColor.x = 0.0;\n    \n    if( v > fragColor.y/2.0+0.5 )\n        fragColor.y = 0.0;\n    \n    if( v > fragColor.z/2.0+0.5 )\n        fragColor.z = 0.0;\n    \n    if( v > 0.48 && v < 0.5 )\n        fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 845]]}
{"id": "4tGBzd", "name": "Bubble Nebula (Value Noise)", "author": "WB", "description": "Attempt at rendering the bubble nebula using iq's fast lut based 3d value noise.", "tags": ["raymarching", "volumetric", "nebula"], "likes": 9, "viewed": 341, "published": "Public", "date": "1546313390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 128\n#define STEP_SIZE 0.04\n#define _FoV 55.0\n#define BACKGROUND\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Emission = vec3(0.35,0.5,1.0);\nconst vec3 _LightColor = vec3(0.4,0.7,1.0);\nconst vec3 _LightPos = vec3(0.1, 0.05, 0.05);\nconst float _LightIntensity = 2.5;\nconst float _Falloff = 0.01;\nconst float _Density = 100.0;\nconst float _DensityExp = 14.0;\nconst float _Radius = 1.0;\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\nvec3 rotateX(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(1.0, 0.0, 0.0,\n        \t\t\t0.0, cosTheta, -sinTheta,\n    \t\t\t    0.0, sinTheta, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's lut based value noise\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    float result = mix( rg.x, rg.y, f.z );\n    result = (2.0 * result) - 1.0;\n\treturn result;\n}\n\n//Brownian pink noise: S(f) ∝ 1/f^α, {0 <= α <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center-pos) - radius;\n}\n\n//Density distribution function\nfloat sampleVolume(vec3 pos)\n{\n    float d = sdSphere(pos, vec3(0.0), _Radius * 0.85);\n    float p = 0.75-abs(d + fbm(100.0+pos, 6, 1.0, 1.0) * 0.075);\n    vec3 n = normalize(-pos);\n    p += fbm(200.0+n, 6, 1.5, 1.0)*0.045;\n    p = max(0.0,p);\n    p = pow(p, _DensityExp);\n    p *= _Density;\n  \n    if (p <= 0.0 || d > 0.6 )\n        return 0.0;\n    \n    p -= smoothstep(0.0,0.5,abs(fbm(400.0+pos, 4, 2.0, 0.5)) * 0.4);\n\n    p = max(0.0,p);\n                \n    return p;\n}\n\n//Raymarching loop\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p >0.0)\n        {\n            result.rgb += _Emission * p * ds;\n            result.a *= exp(-p * ds);\n        }\n        vec3 R = _LightPos - pos;\n        float rr = dot(R, R) + 0.00001;\n        float star = (_Falloff/rr) * ds;\n        result.rgb += star * _LightIntensity * _LightColor;\n        result.a *= exp(-star * ds);\n            \n        pos += dir * ds;\n    }\n    \n    //result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    float t = iMouse.x * 0.01 + iTime * 0.2;\n\t#else\n    float t = iMouse.x * 0.01;\n    #endif\n    \n    rayDir = rotateY(rayDir, t);\n    rayOrigin = rotateY(rayOrigin, t);\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    \n    //Background\n    float starfield = smoothstep(0.9, 1.0, abs(noise(rayDir * 140.0)));\n    col.rgb += starfield * mix(vec3(1.0,0.5,0.3),vec3(0.7,0.8,1.0), starfield);\n    \n    #ifdef BACKGROUND\n    float clouds = fbm(rayDir, 6, 4.0, 1.0);\n    float gas = (clouds + 1.0) * 0.5;\n    if (gas >= 0.0)\n    {\n        float turb = abs(fbm(128.0+rayDir, 8, 16.0, 1.0)) * 0.15;\n        gas -= turb;\n        float colors = abs(fbm(256.0 +rayDir, 8, 4.0, 2.0));\n        gas *= smoothstep(-0.8,0.2,clouds);\n        gas *= 1.5 - colors;\n        gas = gas * gas * 0.5;\n        col.rgb += gas * mix(vec3(1.0,0.4,0.0),vec3(0.0, 0.8, 1.0), gas * colors * 2.5) * 0.5;\n    }\n    #endif\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 428, 514, 514, 968], [970, 970, 1001, 1001, 1195], [1197, 1197, 1228, 1228, 1422], [1424, 1453, 1474, 1474, 1743], [1745, 1799, 1857, 1857, 2021], [2023, 2023, 2076, 2076, 2118], [2120, 2152, 2182, 2182, 2624], [2626, 2645, 2697, 2697, 3302], [3304, 3572, 3629, 3629, 5612]]}
{"id": "4tyfWD", "name": "Colorspace", "author": "WB", "description": "Another basic tunnel effect made with some simple functions.", "tags": ["tunnel", "trig"], "likes": 5, "viewed": 78, "published": "Public", "date": "1546313754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    pos.x += sin(pos.x * 0.5) * 4.0;\n    pos.y += sin(pos.y * 0.5) * 4.0;\n        \n    float r = length(pos);\n        \n    r = cos(exp(-r));\n    \n    float theta = (100.0 + iTime) * 0.02 * 1.0/r;\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    mat2 m = mat2(cosTheta, -sinTheta,\n                  sinTheta, cosTheta);\n    pos = m * pos;\n        \n    float angle = atan(pos.y, pos.x);\n       \n    vec2 uv = vec2(0.5/r + iTime * 0.2, angle/PI);\n\n    float l = length(uv);\n    \n    float t = 25.0;\n    \n    float time = iTime;\n    \n    float a[3];\n    \n    float c = 0.0;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        \n    float s = l;\n        \n    float tuv = uv.x;\n    uv.x = uv.x - uv.y;\n    uv.y = uv.y +tuv;\n        \n    s += (sin(uv.x * t * 0.2));\n    \n    s += (sin(uv.y * t * 0.2));\n    \n    float m = mod(s + (time + c) * 0.2, 0.5);\n    \n    //m *= mod(r - iTime * 0.2, 0.5);\n    \n    a[i] = m;    \n        \n    c += sin(iTime);\n        \n    }\n    \n    vec3 col = vec3(a[0], a[1], a[2]);\n    \n    col.rgb *= exp(r);\n    col.rgb *= pow(r, 4.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyfWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 1284]]}
{"id": "ldycWK", "name": "Sinediff", "author": "klk", "description": "analytical normal for interferencing radial waves", "tags": ["waves"], "likes": 7, "viewed": 395, "published": "Public API", "date": "1546473782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat2 dw(float2 p, float2 c, float t)\n{\n    p-=c;\n    float l=length(p);\n    float s=sin(l-t);\n    s/=l;\n    s*=clamp(1.0-l*0.02,0.0,1.0);\n    float x = 0.5 + 0.5*(p.x*s);\n    float y = 0.5 + 0.5*(p.y*s);\n    return float2(x,y);\n    return float2(s*0.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat2 uv = ((fragCoord-iResolution.xy/2.0)/iResolution.xx)*100.0;\n    float2 m=((iMouse.xy-iResolution.xy/2.0)/iResolution.xx)*100.0;\n    float t=iTime*15.0;\n    float2 col=float2(0);\n    col+=dw(uv,m,t);\n    col+=dw(uv,float2(-13,8),t+1.0);\n    col+=dw(uv,float2(8,15),t+2.0);\n    col+=dw(uv,float2(-18,-5),t-1.0);\n    col*=0.25;\n    fragColor = vec4(col.xxy,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 101, 101, 322], [324, 324, 381, 381, 752]]}
{"id": "llyfRK", "name": "Two Tone Nebula", "author": "WB", "description": "Another raymarched nebula, this time with a two-tone lighting and some rotated noise for a swirling effect.", "tags": ["raymarching", "volumetric", "nebula"], "likes": 15, "viewed": 351, "published": "Public", "date": "1546313920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 256\n#define STEP_SIZE 0.05\n#define _FoV 45.0\n\n#define JITTER\n\nconst vec3 _Absorption = vec3(0.4,0.2,0.7);\nconst vec3 _Light = vec3(0.5,0.9,0.9);\nconst vec3 _LightPos = vec3(0.0, 2.0, 1.0);\nconst float _Density = 0.75;\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Fractal (pink) noise function S(f) ∝ 1/f^α, {0 <= α <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    for (int i = 0; i < octaves; i++)\n    {\n        val += noise(seed * freq * float(i+1)) / (pow(float(i+1), lac));\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    pos = rotateY(pos, iTime * 0.1);\n    float rr = dot(pos,pos);\n    rr = sqrt(rr)+0.5;\n    float p = 1.0/(rr*20.0);\n    p *= _Density;\n    \n    if (p < 0.02)\n        return p;\n    \n    pos = rotateY(pos, noise(pos.y* 0.2 + pos));\n    float n = noise(pos*2.0);\n    n = max(0.0, n - abs(fbm(pos+32.0, 4, 4.0, 0.8)));\n\tn += p * 0.1;\n            \n    return n;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.0,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = 1.0/dot(r, r)*32.0;\n            vec3 scatter = _Light * atten * p * ds;\n            vec3 amb = vec3(0.03,0.03,0.0);\n            float ext = 1.0 - exp(-p * ds);\n            result.rgb += (amb + scatter) * result.a * _Absorption;\n            result.a *= exp(-p);\n\n            if (result.a <= 0.0)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    vec2 uv2 = (-1.0 + 2.0 * uv) * vec2(ar, 1.0);\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3(uv2, d));\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rotateY(rayDir, iTime * 0.1) * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), 1.0))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n        \n        col.rgb = col.rgb * integral.a + integral.rgb * (1.0-integral.a);  \n        col.rgb += pow(1.0001 + dot(uv2,uv2), -1000.0) * 4.0 * vec3(1.0,0.8,0.5) * (integral.a+0.25);\n\n    }\t\n       \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyfRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 263, 349, 349, 803], [805, 830, 861, 861, 1055], [1057, 1079, 1100, 1100, 1269], [1271, 1271, 1297, 1297, 2122], [2124, 2187, 2245, 2245, 2402], [2404, 2404, 2434, 2434, 2795], [2797, 2797, 2849, 2849, 3548], [3550, 3818, 3875, 3875, 5206]]}
{"id": "ltdBDj", "name": "Water World", "author": "WB", "description": "Raymarched procedural water planet shader made from layered noise functions. Moving the mouse up and down simulates climate by increasing/decreasing latitude of polar ice caps.", "tags": ["procedural", "raymarching", "planet"], "likes": 4, "viewed": 118, "published": "Public", "date": "1546313471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MIN_DIST 0.0002\n#define PI = 3.14159265\n//Comment this out disable rotation\n#define ROTATE \n\n//Input Parameters\nconst float _Radius = 5.0;\nconst float _Oblateness = 1.02;\nconst vec3 _Center = vec3(0.0,0.0,0.0);\n\nconst vec3 _LightPos = vec3(-10.0, 0.0, -20.0);\nconst vec3 _LightCol = vec3(1.0, 1.0, 1.0);\n\nconst vec4 _Color = vec4(0.5,0.7,0.8, 1.0);\nconst vec3 _Emissive = vec3(0.0, 0.0, 0.0);\nconst float _Specular = 0.5;\nconst float _SpecularHardness = 10.0;\nconst float _FresnelPow = 16.0;\nconst float _FresnelBias = 0.1;\n\nconst vec4 _OceanColor = vec4(0.2, 0.3, 0.45, 1.0);\nconst float _OceanDepth = 0.1;\n\nconst vec4 _UpperCloudColor = vec4(1.0,1.0,1.0,1.0);\nconst float _UpperCloudScale = 10.0;\nconst float _UpperCloudSkew = 2.0;\nconst float _UpperCloudStrength = 0.5;\nconst float _UpperCloudExponent = 2.0;\nconst float _LowerCloudStrength = 0.4;\nconst float _LowerCloudTurbulence = 2.5;\nconst float _LowerCloudFrequency = 0.4;\n\n//Signed distance function for a spheroid. \n//For oblateness(O), O == 1 : Sphere, O < 1 : Prolate Spheroid, O > 1 : Oblate Spheroid \nfloat sdSpheroid(vec3 position, float oblateness)\n{\n    vec3 center = _Center;\n    position.y *= oblateness;\n    return length(center - position) - _Radius;\n}\n\n//Raymarching loop\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float dist;\n    vec3 center = _Center;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sdSpheroid(position, _Oblateness);\n        if (dist < MIN_DIST)\n        {\n            return position;\n        }\n\n        position += direction * dist;\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n//Fast geodesic normal calculation\nvec3 fastNormal(vec3 p)\n{\n    p.y *= _Oblateness;\n    return normalize(p - _Center);\n}\n\n//Correct geodetic normal for a non-spherical ellipsoid\nvec3 geodeticNormal(vec3 p)\n{\n    vec3 axes = vec3(1.0, _Oblateness*_Oblateness, 1.0);\n    vec3 R = p - _Center;\n    return normalize(R/axes);\n}\n\n//Simplex noise from https://www.shadertoy.com/view/XtBGDG\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat snoise(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat ridgedNoise(vec3 position, float frequency, float amplitude)\n{\n    return((1.0 - abs(snoise(position * frequency))) * 2.0 - 1.0) * amplitude;\n}\n\n//This function generates the planet from layered noise and handles shading\nvec4 renderSurface(vec3 normal, vec3 sp, vec3 camPos, float h)\n{\n    //Get direction to center for parallel light rays\n    vec3 lightDir = -normalize(_Center - _LightPos);\n    //float dist = length(_Center - _WorldSpaceCameraPos);\n    vec3 worldNormal = normal;\n\n    vec3 seed = worldNormal;\n\n    //Terrain Generation\n\n    //Fractal Noise\n    const int octaves = 8;\n    float scale = 3.0;\n    float falloff = 1.0;\n\n    float offset = 0.0;\n    for (int i = 0; i < octaves; i++)\n    {\n        offset += snoise(seed * scale * float(i * i)) / falloff;\n        falloff *= 2.0;\n    }\n\n    //Scales noise based on lattitude to simulate polar climate\n    offset += abs(h * h);\n\n    //Ground color\n    float t = clamp((1.0 + offset) / 2.0, 0.0, 1.0);\n    vec4 texCol = mix(_Color, vec4(1.0, 1.0, 1.0, 1.0), t);\n\n    //Set Sea Level\n    float depth = _OceanDepth * clamp(iMouse.y * 0.5, 0.0, 1000.0);\n    float ocean = step(offset, depth);\n    texCol = mix(texCol, _OceanColor, ocean);\n\n    //Upper Cloud Layer\n    vec3 skewedSeed = vec3(worldNormal.x, worldNormal.y * _UpperCloudSkew, worldNormal.z);\n    vec3 mirroredSeed = worldNormal;\n    mirroredSeed.xy *= -1.0;\n    float uCloud = clamp(max(snoise(skewedSeed * 2.0) - ridgedNoise(seed, 4.0, 1.0) + snoise(skewedSeed * _UpperCloudScale)+ snoise(normal * 8.0) + snoise(skewedSeed * 32.0) + snoise(mirroredSeed * 64.0) / 4.0 + snoise(normal * 128.0)/4.0, 0.0) * _UpperCloudStrength, 0.0, 1.0);\n    float cloudFade = pow(uCloud, _UpperCloudExponent);\n    texCol.rgb = mix(texCol.rgb, _UpperCloudColor.rgb * 2.0, cloudFade);\n\n    //Lower Cloud Layer\n    if (_LowerCloudStrength > 0.0)\n    {\n        seed *= 8.0 * _LowerCloudFrequency;\n        seed.y *= 2.0;\n        float lowerClouds = pow(abs(snoise(seed)), 4.0);\n        lowerClouds -= snoise(seed) + snoise(seed) + snoise(normal * 4.0)/2.0 + snoise(seed * 2.0) / 4.0 + snoise(seed * 8.0) / 3.0 + snoise(seed * 16.0) / 6.0;\n        lowerClouds -= abs(snoise(seed * _LowerCloudTurbulence));\n        lowerClouds = clamp(lowerClouds, 0.0, 1.0);\n        texCol.rgb = mix(texCol.rgb, _UpperCloudColor.rgb * 2.0, clamp(lowerClouds, 0.0, 1.0) * _LowerCloudStrength);\n    }\n\n    //Lambert Reflectance\n    float NdotL = dot(normal, lightDir);\n\n    //Blinn-Phong Specular\n    vec3 viewDir = -normalize(sp - camPos);\n    vec3 halfangle = (lightDir + viewDir)/length(lightDir + viewDir);\n    float NdotH = dot(normal, halfangle);\n    float intensity = pow(clamp(NdotH, 0.0, 1.0), _SpecularHardness);\n\n    vec4 col;\n    col.rgb = clamp(texCol.rgb * _LightCol * NdotL + (intensity * ocean * (1.0-cloudFade) * _Specular) + _Emissive, 0.0, 1.0);\n\n    //Fresnel-based atmosphere effect. Not physically accurate but looks good from most distances and relatively cheap.\n    float fresnel = clamp(_FresnelBias + (40.0) * pow(1.0 + dot(normalize(sp - camPos), normal), _FresnelPow), 0.0, 1.0);\n    //col.a = max(0.0,1.0 - fresnel);\n\n//    float NdotV = dot(normal, viewDir);\n//    col.rgb *= saturate(tex1D(_ScatteringTex, -NdotL * _ScatteringTex_ST.x + _ScatteringTex_ST.z));\n//    col.rgb += saturate(tex1D(_ScatteringTex, -NdotL * _ScatteringTex_ST.y + _ScatteringTex_ST.w)) * fresnel * NdotL;\n//    col.a *= 1-fresnel;\n    col.rgb += (fresnel + _Emissive) * NdotL;\n    col.rgb *= 1.0-fresnel;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Y-axis rotation matrix\n    float cosTheta = cos(iTime * 0.2);\n    float sinTheta = sin(iTime * 0.2);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    //World camera position\n    vec3 camPos = vec3(0.0,0.0,-25.0);\n    #ifdef ROTATE\n    camPos = rot * camPos;\n    #endif\n    \n    //Screen space uv coords\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Eye vector\n    vec3 viewDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1), 4));\n    #ifdef ROTATE\n    viewDir = rot * viewDir;\n    #endif\n    \n    //Get world position on sphere\n    vec3 wPos = raymarch(camPos, viewDir);\n    \n    vec3 col;\n    \n    if (wPos != vec3(0.0))\n    {\n\n        //Calculate surface normal\n        vec3 wNormal = geodeticNormal(wPos);\n\n        col = renderSurface(wNormal, wPos, camPos, abs(wPos.y)).rgb;\n    }\n    else\n    {\n        col.rgb += smoothstep(0.85, 0.9, abs(snoise(rot * viewDir * 32.0)));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[962, 1095, 1146, 1146, 1253], [1255, 1274, 1320, 1320, 1618], [1620, 1655, 1680, 1680, 1741], [1743, 1799, 1828, 1828, 1943], [1945, 2004, 2027, 2027, 2108], [2110, 2110, 2132, 2132, 4257], [4259, 4259, 4327, 4327, 4408], [4410, 4486, 4550, 4604, 7773], [7775, 7775, 7832, 7861, 8861]]}
{"id": "ltVfzK", "name": "Dense Nebula", "author": "WB", "description": "Raymarched volumetric nebula made with some scattering approximations and an analytic integration scheme.", "tags": ["nebula"], "likes": 6, "viewed": 166, "published": "Public", "date": "1546313968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 256\n#define STEP_SIZE 0.06\n#define _FoV 45.0\n#define _Quality 5\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Absorption = vec3(0.7,0.6,0.5);\nconst vec3 _Ambient = vec3(0.4,0.15,0.2);\nconst vec3 _Light = vec3(1.0,0.3,0.2);\nconst vec3 _LightPos = vec3(0.0, 0.0, 0.0);\nconst float _LightIntensity = 2.0;\nconst float _Density = 15.0;\nconst float _Radius = 1.0;\nconst float _Mie = 0.4;\nconst float _G = 0.7;\n\n//Improved Heyney-Greenstein phase function\nfloat cornetteShanksPhase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float r = length(pos);\n    float f = exp(-r);\n    float p = f * _Density;\n    \n    if (p <= 0.5)\n        return p;\n    \n    pos = rotateY(pos, pos.y * noise(16.0+pos) * 4.0);\n    p *= fbm(pos, _Quality, 2.0, 0.5)*8.0*f;\n    p -= abs(noise(150.0+pos * 0.4))*100.0*f;\n    p += pow(f,8.0)*33.33333*_Density;\n        \n    p = max(0.0,p);\n                \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = _LightIntensity/dot(r, r);\n            vec3 ext = max(vec3(0.000001), (_Absorption * p) + vec3(_Mie * p));\n            vec3 trans = exp(-ext * ds);\n            vec3 lightDir = normalize(r);\n            float mu = dot(lightDir, -dir);\n            float phase = cornetteShanksPhase(mu, _G);\n            vec3 lum = _Ambient + _Light * phase * (1.0-_Absorption) * _Mie * p * atten;\n            vec3 integral = (lum - (lum*trans))/ext;\n            \n            result.rgb += integral * result.a;\n            vec3 div = vec3(0.3333333);\n            result.a *= dot(trans, div);\n            \n            if (result.a <= 0.05)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    float t = iTime * 0.1;\n    rayDir = rotateY(rayDir, t);\n\trayOrigin = rotateY(rayOrigin, t);\n    #endif\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rotateY(rayDir, iTime * 0.1) * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVfzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 466, 512, 512, 636], [638, 664, 750, 750, 1204], [1206, 1231, 1262, 1262, 1456], [1458, 1480, 1501, 1501, 1670], [1672, 1672, 1698, 1698, 2523], [2525, 2525, 2583, 2583, 2747], [2749, 2749, 2779, 2779, 3150], [3152, 3152, 3204, 3204, 4226], [4228, 4496, 4553, 4553, 5885]]}
{"id": "MldBWX", "name": "Kaleidescopia", "author": "WB", "description": "Raymarching a 4D gradient noise field.", "tags": ["noise"], "likes": 7, "viewed": 148, "published": "Public", "date": "1546313773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SAMPLES 8\n#define STEP_SIZE 0.4\n#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744\n#define _Radius 1.0\n#define _FoV 45.0\n#define _Deg2Rad 0.01745329\n\nconst float _Freq = 10.0;\nconst float _Timescale = 0.1;\n\n//-------------------------------------------------------------------\n// Description : Array and textureless GLSL 4D simplex\n//               noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//-------------------------------------------------------------------\n\nfloat mod289(float x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nfloat permute(float x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec3 permute(vec3 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p, s;\n\tp.xyz = floor( fract(j * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot( abs(p.xyz), ones.xyz );\n\t\n\t// GLSL: lessThan(x, y) = x < y\n\t// HLSL: 1 - step(y, x) = x < y\n\ts = vec4(\n\t\t1.0 - step(0.0, p)\n\t);\n\tp.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www; \n\t\n\treturn p;\n}\n\n//4D\nfloat snoise(vec4 v)\n{\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t -0.447213595499958  // -1 + 4 * G4\n\t);\n\n// First corner\n\tvec4 i = floor(\n\t\tv +\n\t\tdot(\n\t\t\tv,\n\t\t\tvec4(0.309016994374947451) // (sqrt(5) - 1) / 4\n\t\t)\n\t);\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp(i0, 0.0, 1.0);\n\tvec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n\tvec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n\n\t//\tx0 = x0 - 0.0 + 0.0 * C.xxxx\n\t//\tx1 = x0 - i1  + 1.0 * C.xxxx\n\t//\tx2 = x0 - i2  + 2.0 * C.xxxx\n\t//\tx3 = x0 - i3  + 3.0 * C.xxxx\n\t//\tx4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n// Permutations\n\ti = mod289(i); \n\tfloat j0 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute(i.w) + i.z\n\t\t\t) + i.y\n\t\t) + i.x\n\t);\n\tvec4 j1 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 )\n\t\t\t\t) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )\n\t\t\t) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )\n\t\t) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 )\n\t);\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tconst vec4 ip = vec4(\n\t\t0.003401360544217687075, // 1/294\n\t\t0.020408163265306122449, // 1/49\n\t\t0.142857142857142857143, // 1/7\n\t\t0.0\n\t);\n\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt( dot(p4, p4) );\n\n// Mix contributions from the five corners\n\tvec3 m0 = max(\n\t\t0.6 - vec3(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2)\n\t\t),\n\t\t0.0\n\t);\n\tvec2 m1 = max(\n\t\t0.6 - vec2(\n\t\t\tdot(x3, x3),\n\t\t\tdot(x4, x4)\n\t\t),\n\t\t0.0\n\t);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\t\n\treturn 49.0 * (\n\t\tdot(\n\t\t\tm0*m0,\n\t\t\tvec3(\n\t\t\t\tdot(p0, x0),\n\t\t\t\tdot(p1, x1),\n\t\t\t\tdot(p2, x2)\n\t\t\t)\n\t\t) + dot(\n\t\t\tm1*m1,\n\t\t\tvec2(\n\t\t\t\tdot(p3, x3),\n\t\t\t\tdot(p4, x4)\n\t\t\t)\n\t\t)\n\t);\n}\n\nvec3 raySample(vec3 position)\n{\n    vec3 value = vec3(0.0);\n    \n    float t = _Timescale * iTime;\n    \n    float div = snoise(vec4(position * snoise(vec4(position + 16.0, t)) * 1.0, t));\n    value.r = snoise(vec4(position*div, t));\n    value.g = snoise(vec4(position*div + 4.0, t));\n    value.b = snoise(vec4(position*div + 8.0, t));\n    value = abs(value);\n    value = clamp(value, 0.0, 1.0);\n\n    return value;\n}\n\n//Transfer function\nvec3 rayIntegral(vec3 position, vec3 direction)\n{\n    vec3 integral;\n\n    for(int i = 0; i < NUM_SAMPLES; i++)\n    {\n        integral += raySample(position) * STEP_SIZE;\n\n        position += direction * STEP_SIZE;\n    }\n\n    return integral;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 rayOrigin = vec3(0.0);\n    \n    //Compute eye vector from field of view\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan((_FoV/2.0) * _Deg2Rad);    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n        \n    vec3 col = vec3(1.0);\n    \n    col = rayIntegral(rayOrigin, rayDir);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldBWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 754, 777, 777, 835], [837, 837, 858, 858, 916], [918, 918, 939, 939, 997], [999, 999, 1020, 1020, 1078], [1080, 1080, 1104, 1104, 1141], [1143, 1143, 1165, 1165, 1202], [1204, 1204, 1226, 1226, 1263], [1265, 1265, 1295, 1295, 1346], [1348, 1348, 1376, 1376, 1427], [1429, 1429, 1459, 1459, 1780], [1782, 1787, 1809, 1809, 4293], [4295, 4295, 4326, 4326, 4710], [4712, 4732, 4781, 4781, 4975], [4977, 4977, 5034, 5084, 5493]]}
{"id": "MlGfzR", "name": "phongplaneray", "author": "caudya", "description": "phong", "tags": ["phong", "planeray"], "likes": 0, "viewed": 48, "published": "Public", "date": "1547317015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Photorealistic rendering course - Step 04\n// By Alan \"Latex\" Savary.\n//\n// Next step: \"[Step05] Shadow casting\"\n//\n\n//##############################################################################################\n\n// - The aim is to render a 3D sphere seen by a 3D camera with Phong illumination shading.\n// - The sphere is defined by its 3D position and its radius.\n// - The camera is defined by its 3D position, the fact that it looks towards a 3D point target,\n//   has its up vector as upward as possible, and its field of view defined by a vertical angle.\n// \n// The different space coordinates:\n//\n//                +----------------+\n//                |                |\n//                |     screen     |\n//              Y î                |\n//                |                |\n//                +->--------------+\n//                   X\n//                    \n//\n//                                +-----------------+\n//                               .|                .|\n//                               .|        +      . |\n//                               .|       .     .   |\n//                               .+------.-----.----+\n//                               ..     .    .     .\n//                               ..    .   .    .\n//                               ..   .  .    .\n//                               .   .  .    .\n//                               .  . .  .\n//                               cz.. .\n//                               ./.\n//                               /\n//                      camera  +---> cx      \n//                              |\n//                              |\n//                              v cy\n//\n//            \n//                 Y\n//                  î\n//                  |       world\n//                  +--> X  \n//                 /  \n//              Z /   \n//        \n\n//##############################################################################################\n\n// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\nvec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = vec3(8, 10, -12);\n\n\nconst float eps = 0.01;\n\n    \n//##############################################################################################\n\nvoid animateScene(in float time) {\n    //animate the sphere position\n\tconst float pi = 3.1415926535;\n\tconst float rs = 2.0;\n\tconst float spr = 5.0;\n\tfloat as = 2.0*pi * time /spr;\n\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0, 1, 0);\n    \n    lightPos += vec3(0.0, 10.5 + 9.5 * cos(time) - 10.0, 0.0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist * vec3(sin(time), max(sin(time*0.5), 0.0), cos(time));\n    \n}\n    \n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    // Explanation:\n    //\n    //  Any point P(t) on the ray respect the following equation:\n    //\n    //         P(t) = rayPos + t * rayDir                            (1)\n    //\n    //  Any point on the sphere must be at sphereRadius distance from the sphere center.\n    //  Which, for a point P of space, yields to follow equation:\n    //\n    //                 distance(P - spherePos)   = sphereRadius\n    //     <=>         distance(P - spherePos)^2 = sphereRadius^2\n    //     <=> dot(P - spherePos, P - spherePos) = sphereRadius^2    (2)\n    //\n    // The intersection point(s) of the ray with the sphere must respect both equations.\n    // So, we can replace P of equation (2) with (1) to express both constraints into a\n    // single equation:\n    //\n    //      dot(rayPos+t*rayDir - spherePos, rayPos+t*rayDir - spherePos) = sphereRadius^2\n    //  <=> dot(t*rayDir + rayPos-spherePos, t*rayDir + rayPos-spherePos) = sphereRadius^2\n    //  <=> dot(t * rayDir + diff, t * rayDir + diff)                     = sphereRadius^2\n    //        ; with diff = rayPos - spherePos\n    //\n    // As we can 'distribute' additive component over a dot product, we have:\n    //\n    //      dot(t*rayDir, t*rayDir) + 2*dot(diff,t*rayDir) + dot(diff, diff) = sphereRadius^2\n    //  <=> t^2*dot(rayDir, rayDir) + t*2*dot(diff,rayDir) + dot(diff, diff) = sphereRadius^2\n    //  <=> t^2*dot(rayDir, rayDir) + t*2*dot(diff,rayDir) + dot(diff, diff)-sphereRadius^2 = 0\n    //  <=> a*t^2 + b*t + c = 0\n    //        ; with:\n    //                a =   dot(rayDir, rayDir)\n    //                b = 2*dot(diff  , rayDir)\n    //                c =   dot(diff  , diff  ) - sphereRadius^2\n    //\n    // This is a 2nd degree (quadratic) equation to solve.\n    //\n    // If discriminant di (= b^2 - 4*a*c) is negative, the ray doesn't intersect the sphere.\n    // Otherwise there are up to two solutions (t1 and t2).\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n        // We can notice that 'a' (so 'den') and sdi are positive.\n        // So, we know for sure that t1 <= t2 whatever the configuration.\n\n        // We can also list all the possibilities of intersection or non-intersection:\n        //\n        //    t1...t2.....r------------>\t(t1<0 & t2<0)\t\t\tno intersection\n        //       t1t2.....r------------>\t(t1<0 & t2<0 & t1=t2)\tno intersection\n        //    t1........t2r------------>\t(t1<0 & t2=0)\t\t\tassume no intersection\n        //            t1t2r------------>\t(t1=t2=0)\t\t\t\tassume no intersection\n        //    t1..........r--------t2-->\t(t1<0 & t2>0)\t\t\tintersection at (t2, -n)\n        //              t1r--------t2-->\t(t1=0 & t2>0)\t\t\tintersection at (t2, -n)\n        //                r---t1---t2-->\t(t1>0 & t2>t1)\t\t\tintersection at (t1,  n)\n        //                r---t1t2----->\t(t1>0 & t2=t1)\t\t\tintersection at (t1,  n)\n        \n        // This can be summed up by:\n\t\t//        \n        // If t1 >  0, then the sphere is ahead of the ray, and the point we see is the\n        //             one associated to t1 with a normal pointing outward the sphere.\n        //             \n        // If t1 <= 0 and t2 >  0, then the ray starts inside the sphere, and the point we see\n        //                         is the one associated to t2 with a normal point inward the\n        //                         sphere.\n        //                         \n        // Otherwise, there is no intersection or we assume there is none.\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t * rayDir;\n\n        // Then, we can use the property of a sphere that the infinite line along the\n        // normal vector to a point on the sphere is passing through the center of the\n        // sphere.\n        // Then, we need to reverse the vector direction if the intersection point is\n        // seen from inside the sphere.\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    // Explanation:\n    //\n    //  Any point P(t) on the ray respect the following equation:\n    //\n    //         P(t) = rayPos + t * rayDir                            (1)\n    //\n    //  The analytic equation of a plane is of the form: a * x + b * y + c * z + d = 0\n    //  That can be rewritten with a dot-product:              (a,b,c).(x,y,z) + d = 0\n    //  With (a,b,c) being the normal N to the plane which defines the orientation of the plane,\n    //  with (x,y,z) being any 3D point of space, and 'd' defining at which position the plane\n    //  is located.\n    //\n    //  NOTE: Without loss of generality (a,b,c) can be normalized and d scaled accordingly.\n    //        So, the normal is assumed here to be a unit-vector!!!\n    //\n    //  So, we have:    dot(planeNormal, P) + d = 0   for any 3D point P on the plane\n    //\n    //  We can find d because we know our plane pass through planePos point.\n    //  This means planePos also follow the above equation:\n    //      \n    //          dot(planeNormal, planePos) + d = 0\n    //      <=> d = -dot(planeNormal, planePos)\n    //\n    //  So, we now know the complete equation of the plane:\n    //\n    //          dot(planeNormal, P) + (-dot(planeNormal, planePos)) = 0\n    //      <=> dot(planeNormal, P) - dot(planeNormal, planePos) = 0\n    //      <=> dot(planeNormal, P - planePos) = 0                   (2)\n    //\n    // The intersection point(s) of the ray with the plane must respect both equations.\n    // So, we can replace P of equation (2) with (1) to express both constraints into a\n    // single equation:\n    //\n    //      dot(planeNormal, (rayPos + t * rayDir) - planePos) = 0\n    //  <=> dot(planeNormal, t * rayDir + (rayPos - planePos)) = 0\n    //\n    // As we can 'distribute' additive component over a dot product, we have:\n    //\n    //      dot(planeNormal, t * rayDir) + dot(planeNormal, (rayPos - planePos)) = 0\n    //  <=> t * dot(planeNormal, rayDir) + dot(planeNormal, rayPos - planePos) = 0\n    //  <=> t * dot(planeNormal, rayDir) = -dot(planeNormal, rayPos - planePos)\n    //  <=> t * dot(planeNormal, rayDir) =  dot(planeNormal, planePos - rayPos)\n    //\n    // We can find t if 'den = dot(planeNormal, rayDir)' is not zero.\n    // In the case it is zero, it means the ray is parallel to the plane, and there will be\n    // no interesction (or an infinity if the rayPos is on the plane. In that case, we choose\n    // to assume that we have no intersection at all).\n    //\n    // So, here after in this explanation, we assume 'den' is non zero.\n    //\n    // We can then find the value of 't' at which the intersection occurs:\n    //\n    //    t = dot(planeNormal, planePos - rayPos) / dot(planeNormal, rayDir)\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    // Compute camera focal length for a height on image plane going in [-1,1] range\n    //\n    //        \n    //                     -1\n    //                  /|  \n    //                 / |\n    //                /  |\n    //               /   |\n    //              /). .|. . . . . . fovY (vertical angle field of view expressed in degrees)\n    //             /  )  |\n    //            +---)--|-----> cz\n    //            |\\  )  |           î\n    //            | \\)   |           |\n    //            v  \\   |           |\n    //           cy   \\  |           | h\n    //                 \\ |           |\n    //                  \\|           |\n    //                     1         v\n    //                         \n    //            <------>\n    //              focal length\n    //\n    //    We have that:\n    //\n    //        tan((2*Pi/180)*cameraFovY/2) = h / focal\n    //    <=> focal = h / tan(radians(cameraFovY/2))\n    //    <=> focal = 1 / tan(radians(cameraFovY/2))\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    //         - Then, we use the fact that the cross-product of two vectors (even if not\n    //           perpendicular) gives a third vector that is perpendicular to the two others.\n    //           Plus, the direction given by the result is given by applying the 'right-hand'\n    //           technique by pointing the thumb along the first vector, the index finger along\n    //           the second vector, and the result will be given by the middle finger.\n    //           NOTE: the length of the resulting vector needs to be normalized if the two\n    //                 input vectors aren't perpendicular AND of unit length.\n    //         - To compute the cx vector, we can assume, temporarily, that the cy vector is the\n    //           perfect '-up' vector.\n    //           This is possible because cy must be as near as '-up' and the true cy vector\n    //           will be in the same plane than the plane defined by the cz & the 'up' vectors.\n    //         - So, as: cx = cross-product(cy, cz)\n    //                      = normalized(cross-product(-up, cz))\n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n    // Here we apply a set of transformations to transform the coordinates range:\n    //\n    //     pixCoord.xy                  is in range [0..  iResolution.x] x [0..  iResolution.y]\n    //\n    //  2.*pixCoord.xy                  is in range [0..2*iResolution.x] x [0..2*iResolution.y]\n    //\n    //  2.*pixCoord.xy - iResolution.xy is in range\n    //                        [-iResolution.x..iResolution.x] x [-iResolution.y..iResolution.y]\n    //\n    //  pt = (2.*pixCoord.xy - iResolution.xy) / iResolution.y is in range\n    //                         [-ratio,ratio] x [-1, 1] \n    //            with ratio = iResolution.x / iResolution.y;\n    //\n    // Here the scaled applied is uniform because we divide horizontal & vertical coordinates\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n\t// We can now find the ray properties:\n    //   - The ray start position is the camera position\n    //   - The ray direction can be decomposed into 3 sub-vectors:\n    //      *            dy = (-pt.y) * cy   because pt vertical axis is going in opposite\n    //                                       direction than cy, and pt.y is in range [-1,1],\n    //                                       which matches the range spanned by vertical\n    //                                       positions (in camera space) on the image plane\n    //                                       located at the focal length distance along cz.\n    //\n    //      * similarly: dx =    pt.x * cx   NOTE: pt.x and horizontal positions (in camera\n    //                                             space) shares the same range (taking into\n    //                                             account the image ratio. Said differently,\n    //                                             image & camera have the same ratio).\n    //      * and:       dz =   focal * cz\n    //\n    //     which brings that: rayDir = pt.x * cx - pt.y * cy + focal * cz\n    //\n    //   - Finally, the ray direction is normalized because it makes it more practical later on.\n\n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n    //\n    // NOTE: As this is pixel independent it could be calculated once and\n    //       defined by 'const' global value at the top of this source code.\n\t//    \n    // For that, we need first to compute the two X & Y axis of the plane that will serve with\n    // the plane position as defining fully this texture coordinate frame.\n    //\n    // We assume the plane normal is the plane Z-axis.\n    //\n    // We want to find what will be the plane X-axis if this axis is as near as possible to the\n    // world X axis.\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowAtPoint(in vec3 I, in vec3 normalI, in Material objectMat, in vec3 L, in float Ldist)\n{\n    int object;\n    vec3 vec1, vec;\n    float dist = computeNearestIntersection(I, L, object, vec1, vec);\n    if (dist<Ldist && dist>0.0) {\n        return 0.0;\n    } else {\n        return 1.0;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V, float shadowFactor)\n{\n    // Phong shading is simplification of the 'Rendering equation' of Kajiya.\n    //\n    // It consists:\n    //  - in removing all diffuse inter-reflections and to replace them by one ambiant component\n    //  - in assuming the BRDF of material is the addition of a purely diffuse (mat, lambertian)\n    //    surface, plus a perfectly specular (mirror-like) component.\n    \n    // NOTES:\n    //  - The diffuse color is a mix of the light color and the object color.\n    //    It is logical as a light source has a spectrum that is absorbed by the object surface.\n    //    It is, then, the resulting spectrum that is diffused in all direction.\n    //\n    //    For example, a red light shining on a 'blue' (under white light) object would appear\n    //    black, because a 'blue' object is blue because it absorbs all wavelength except the\n    //    blue one that ends up diffusely reflected off the surface towards the observer.\n    //    Hence, the red spectrum part of the light would be absorbed by the object, leaving\n    //    nothing to be reflected.\n    //\n    //    So, we would thing the diffuse shading equation would be something like:\n    //            factor * max(lightCol - (1-objectCol), 0)\n    //               ; where 1-objectCol represents the color absorbed by th object.\n    //                 and max(lightCol - (1-objectCol), 0) would then represents the\n    //                 color remaining after absorbption.\n    //    But that is not what Phong shading is!\n    //\n    //  - The diffuse ammount depends first on the properties of the object to be 'mat', and\n    //    it's controlled with object Kd parameter.\n    //\n    //    It also depends on how 'frontward' the object surface is to the light.\n    //    The more 'frontward' we are, the more light the surface receive, and will then diffuse\n    //    in every direction of the hemisphere at the surface point.\n    //    This is expressed by the cosinus of the angle between the normal and the light vector,\n    //    which is expressed by the dot-product between those two vectors.\n    //\n    //    When the angle is >= 90° the light doesn't shine anymore on the point, so the\n    //    contribution of this light is zero!\n    //    To take that into account, and avoid negative value of the cosinus, we need to clamp\n    //    its value in [0,1] range. This is done by taking the max between 0 and the cosinus.\n\t//\n    //  - The ambiantCol parameter is the most 'unrealistic' parameter because if not set\n    //    properly, you can obtain a color that is totaly irrelevant of the light sources\n    //    and the surrounding diffuse objects, and more importantly the object's color itself!\n    //    Logically, the ambiant should behave like a diffuse lighting, and should be a mix\n    //    of the ambiant color and the object color.\n    //    But that is not what Phong shading is!\n    //\n    //    A good use is to set Ka to be a small value, and to set the ambiant color to a\n    //    color that is mainly the color of the light and a bit of the overall color of the\n    //    entire scene.\n    //\n    //    An improvment would be to replace the Ka and ambiantCol by a single ambiant component\n    //    associated to each object.\n    //    It would enable to emulate the reddish aspect of an object near a red wall.\n    //    Plus, the color would be blended with the object color.\n    //    We could even add a directional & distance aspect to better emulate inter-reflections.\n    //    But that would not be Phong shading anymore! :-)\n    //\n    //  - The specular works quite like the diffuse but the resulting color depends only on the\n    //    light color because specularity comes from light that did not interact much with the\n    //    micro-geometry of the object surface, hence the reflected color does not depend on the\n    //    object color.\n    //\n    //  - The specular component in Phong shading is a cheat!\n    //    As the light source is a point, the perfectly specular reflection would produce a\n    //    single dot (if not nothing because of aliasing).\n    //\n    //    To give the illusion of a light that has a size, Phong applies a kind of diffuse\n    //    principle that relate the reflection direction (from the light that bounces off the\n    //    object surface) and the observer viewing direction.\n    //    The nearer those vectors are (the smaller the angle in-between) the more reflected\n    //    light the observer is receiving.\n\t//\n    //    To control how big the light spot appears (the pseudo light-size is), a power is\n    //    applied on the cosinus of the angle (like the diffuse, it must remain in [0,1] range).\n    //    The higher the value, the smaller the spot will appears.\n    \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + shadowFactor*diffuse + shadowFactor*specular;\n\n    return phongCol;\n}\n\n//##############################################################################################\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    animateScene(time);\n    \n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light\n\t    vec3 L = normalize(lightPos - intersecI);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI,objectMat);\n        \n        vec3 I = intersecI + normalI*eps;\n        \n        float Ldist = length(lightPos-I);\n        \n        float shadowfactor = getShadowAtPoint(I, normalI, objectMat, L, Ldist);\n        //float shadowfactor = 1.0;\n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \tfragColor = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor), 1);\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \tfragColor = vec4(skyCol, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3514, 3612, 3646, 3680, 4135], [4142, 4142, 4287, 6184, 8948], [9048, 9092, 9232, 11934, 12812], [12814, 12912, 12997, 13969, 17813], [17913, 18009, 18158, 18235, 19173], [19175, 19273, 19310, 19310, 19334], [19434, 19478, 19514, 20150, 20791], [20793, 20891, 20966, 20966, 21228], [21230, 21328, 21430, 21430, 21631], [21633, 21731, 21845, 26561, 26897], [26899, 27094, 27151, 27151, 28886]]}
{"id": "MtGfDm", "name": "Animated Mandelbulb", "author": "WB", "description": "8th order Mandelbulb animated with phase shift.", "tags": ["raymarching", "fractal", "mandelbulb"], "likes": 5, "viewed": 86, "published": "Public", "date": "1546313319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _FoV 45.0\n#define _Iterations 16\n#define _Esc 2.0\n#define MAX_STEPS 512\n#define MIN_DIST 0.00065\n#define _Eps 0.4\n#define _TextureScale 1.0\n#define _SpecularExp 100.0\n#define _PI 3.14159265\n\n//This exponent determines the order of the generated fractal\n//Most people seem to like the 8th order but the quadratic and cubic ones are interesting as well\n#define _Exp 8.0\n\n#define AUTOROTATE\n\n//Ray-sphere intersection test\nbool raycastSphere(vec3 ro, vec3 rd, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//Distance estimator\nfloat map (vec3 pos)\n{   \n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    \n    for (int i = 0; i < _Iterations; i++)\n    {\n        r = length(z);\n        \n        if (r > _Esc)\n            break;\n        \n        //Convert to spherical coords and apply phase shift\n        float phase = iTime * 0.2;\n        float theta = acos(z.z/r) + phase;\n        float phi = atan(z.y, z.x);\n        \n        dr = pow(r, _Exp - 1.0) * _Exp * dr + 1.0;        \n        float zr = pow(r, _Exp);\n        theta *= _Exp;\n        phi *= _Exp;\n        \n        //Convert back to cartesian coords\n        z = zr * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        \n        z += pos;\n    }\n    \n    return _Eps * log(r) * r/dr;\n}\n\n//Approximate surface normal using central difference\nvec3 calculateNormal(vec3 p)\n{\n    const float eps = 0.001;\n\n    return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n                          map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n                          map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))));\n}\n\nvec3 raymarch (vec3 pos, vec3 dir)\n{\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = map(pos);\n\n        if (dist < MIN_DIST)\n            return pos;\n\n        pos += dist * dir;\n    }\n    \n    return vec3(0.0);\n}\n\n//iq's soft shadow method\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int i = 0;\n    for( float t=mint; t < maxt && i < 128; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        i++;\n    }\n    return res;\n}\n\n//Tri-planar texture mapping\nvec3 triPlanar(vec3 p, vec3 n, float k)\n{\n    vec2 xUV = p.zy/_TextureScale;\n    vec2 yUV = p.xz/_TextureScale;\n    vec2 zUV = p.xy/_TextureScale;\n    \n    vec3 colX = texture(iChannel0, xUV).rgb;\n    vec3 colY = texture(iChannel0, yUV).rgb;\n    vec3 colZ = texture(iChannel0, zUV).rgb;\n    \n    vec3 blend = pow(abs(n),vec3(k));\n    blend = blend/(blend.x + blend.y + blend.z);\n    \n    return colX * blend.x + colY * blend.y + colZ * blend.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AUTOROTATE\n    \tfloat rot = iTime * 0.15;\n    #else\n        float rot = (iMouse.x/iResolution.x) * 2.0 * _PI;\n    #endif\n        \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.5 + (5.5 * (iMouse.y/iResolution.y)));\n        \n    //Compute perspective correct vector from field of view angle\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    vec3 col = vec3(1.0,0.6,0.4) * smoothstep(0.8,1.1,dot(rayDir, vec3(0.0,0.0,1.0)));\n                   \n    rayDir = rotateY(rayDir, rot);\n    rayOrigin = rotateY(rayOrigin, rot);\n    \n    //Bounding sphere test\n    if (raycastSphere(rayOrigin, rayDir, vec3(0.0), 1.5))\n    {\n\n        vec3 sp = raymarch(rayOrigin, rayDir);\n\n        //Only perform shading on surface points\n        if (sp != vec3(0.0))\n        {\n            vec3 n = calculateNormal(sp);\n\n            //Inverse square attenuation\n            vec3 lightPos = vec3(0.0, 0.0, -5.0);\n            lightPos = rotateY(lightPos, rot);\n            vec3 r = sp - lightPos;\n            float intensity = 20.0;\n            float atten = 1.0/dot(r, r) * intensity;\n\t\t\t\n            //Diffuse term\n            float NdotL = dot(n, -rayDir);\n\n            //Blinn-Phong specular term\n            vec3 h = (n-rayDir)/length(n-rayDir);     \n            float spec = pow(max(dot(n, h), 0.0), _SpecularExp) * max(0.0, NdotL);\n\n            //Soft shadows\n            float d = length(r);\n            vec3 dir = r/d;\n            float shadow = softShadow(sp, -dir, 0.01, d, 8.0);\n\n            //Ambient light\n            vec3 amb = vec3(0.1,0.1,0.1);\n            \n            //Scroll the texture in the direction of phase shift. Not perfect but close enough.\n            sp.z -= iTime * 0.2;\n            col = amb + triPlanar(sp, n, 0.2) * (NdotL + spec) * atten * shadow;\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 428, 488, 488, 810], [812, 837, 868, 868, 1062], [1064, 1085, 1107, 1107, 1823], [1825, 1879, 1909, 1909, 2180], [2182, 2182, 2218, 2218, 2412], [2414, 2440, 2510, 2510, 2764], [2766, 2795, 2836, 2836, 3241], [3243, 3243, 3300, 3300, 5272]]}
{"id": "MtVBzw", "name": "Tunnel of Trig", "author": "WB", "description": "An abstract spiral tunnel effect textured with a few simple trig functions.", "tags": ["2d", "tunnel"], "likes": 3, "viewed": 76, "published": "Public", "date": "1546314148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 pos = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float r = length(pos);\n    \n    float theta = iTime + sin(r * 12.0) * 0.04;\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    mat2 m = mat2(cosTheta, -sinTheta,\n                  sinTheta, cosTheta);\n    \n    pos = m * pos;\n       \n    float angle = atan(pos.y, abs(pos.x));\n    \n    vec2 uv = vec2(r - iTime, angle/PI);\n\n    float l = length(uv);\n    \n    float t = 25.0;\n    \n    float time = iTime;\n    \n    float a[3];\n    \n    float c = 0.0;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        \n    float s = l;\n        \n    float tuv = uv.x;\n    uv.x = uv.x - uv.y;\n    uv.y = uv.y +tuv;\n        \n    s += (sin(uv.x * t * 0.2));\n    \n    s += (sin(uv.y * t * 0.2));\n    \n    float m = mod(s + (time + c) * 0.2, 0.5);\n    \n    //m *= mod(r - iTime * 0.2, 0.5);\n    \n    a[i] = m;    \n        \n    c += sin(iTime);\n        \n    }\n    \n    vec3 col = vec3(a[0], a[1], a[2]);\n    \n    col *= r;\n    col = 1.0 - exp(-col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 1159]]}
{"id": "td23WW", "name": "World's best shader", "author": "ihsancelik", "description": "Default", "tags": ["colorfulshader"], "likes": 2, "viewed": 117, "published": "Public", "date": "1548932236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td23WW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "td2GRw", "name": "Sonic Fusion", "author": "BigWIngs", "description": "Watch fullscreen with sound till the end! Use mouse to scrub time.", "tags": ["torus", "music"], "likes": 54, "viewed": 4398, "published": "Public", "date": "1548642537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sonic Fusion by Martijn Steinrucken aka BigWings - 2019\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// What you get when you play with the inside of a torus for too long.\n// Originally inspired by: https://turtletoy.net/turtle/90e6288a6b\n// \n// Turns out that if music is groovy enough, it can cause fusion! ;)\n// Use mouse to scrub time.\n//\n// Music: Daft Punk - Beyond (Nicolas Jaar Feat Dave Harrington Remix)\n// https://soundcloud.com/mamulashvili1/daft-punk-beyond-nicolas-jaar-feat-dave-harrington-remix\n\n#define MAX_STEPS 50.\n#define SURF_DIST .001\n#define SIN(x) (sin(x)*.5+.5)\n#define COS(x) (cos(x)*.5+.5)\n#define S(x) smoothstep(0.,1.,x)\n#define PI 3.1415\n#define HPI 1.5708\n\nfloat bigRadius = 1.;\nfloat smallRadius = .8;\n\nfloat Fade(float a, float b, float c, float d) {\n    float t = mod(iTime,315.); // iChannelTime[0];   // doesn't work on some systems ?\n\treturn smoothstep(a, b, t)*smoothstep(d, c, t);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f, r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat GlowDist(vec3 p) {\n    float x = atan(p.x, p.z)+PI;\n    float fft = texture(iChannel0, fract(vec2(x/6.2831+.5)), 1./512.).x;\n    \n    p.y += (fft-.5)*.4;\n    \n    float s = 1.+sin(x*4.+iTime)*.05;\n    float circle = length(vec2(length(p.xz*s)-bigRadius, p.y));\n\tfloat d = (circle+smallRadius*.001);\n    return d;\n}\n\nfloat D(vec3 p) {\n    float circle = length(vec2(length(p.xz)-bigRadius, p.y));\n\tfloat d = -(circle-smallRadius);\n    return d;\n}\n\nvec3 N(vec3 p, float eps) {\n\tvec2 e = vec2(eps,0);\n    return normalize(\n        vec3(\n           D(p+e.xyy)-D(p-e.xyy),\n           D(p+e.yxy)-D(p-e.yxy),\n           D(p+e.yyx)-D(p-e.yyx)\n        )\n    );\n}\n\nvec2 TV(vec3 p) {\n    float y = atan(length(p.xz)-bigRadius, p.y);\n\tfloat x = atan(p.x, p.z);\n    return vec2(x, y); \n}\n                      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 UV = fragCoord/iResolution.xy;\n\tvec2 uv = (UV-.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n   \tfloat t = iTime*2.-m.x*100.;\t// can scrub 50 seconds with mouse\n    float t4 = t/4.;\n    float t8 = t/8.;\n    float t16 = t/16.;\n    float t32 = t/32.;\n    \n    float fft = texture( iChannel0, vec2(.7,0) ).x;\n    \n    smallRadius = mix(.125, .8, S(SIN(t8)));\n    \n    // screen twist\n    float d = 1.-dot(uv,uv);\n    float twist = Fade(0., 100., 200., 300.);\n    uv *= Rot(d*2.*twist*sin(t16)*(1.-COS(t32)));\n    \n    // torus cam setup\n    vec3 ro = vec3(0., sin(t8)*.25*smallRadius, -bigRadius-sin(t4)*smallRadius*.3);\n    float lookAngle = ((SIN(-t8)));\n    vec3 lookDir = vec3(0, 0, 1);\n    lookDir.xz *= Rot(lookAngle*HPI);\n    float fov =  mix(.5, .1+COS(t32), Fade(30.,60., 250., 300.));      \n    vec3 rd = R(uv*Rot(t*.1), ro, ro+lookDir, vec3(0,1,0), fov);\n    \n    // Ray march\n    float dO = 0.;\n    float minDistC = 5.;\n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + dO*rd;\n        float dS = D(p);\n        float dC = GlowDist(p);\n        \n        minDistC = min(minDistC, dC);\n        \n        dO += min(dS, dC);\n        if(dS<SURF_DIST) break;\n    }\n    \n    vec3 col = vec3(0);\n    \n    // get pos, normal and torus uvs\n    vec3 p = ro + dO*rd;\n \tvec3 n = N(p,.01);\n    vec2 tv = TV(p)/6.2831+.5;\n    \n    // Texture\n    tv.y += t*.05*Fade(143.5, 143.51, 220.,230.);\n    d = fract((tv.y+tv.x)*10.);\n    float outline = smoothstep(.3, .28, abs(d-.5));\n    float swirl = smoothstep(.25, .2, abs(d-.5));\n    float hatchUv = (tv.y-tv.x)*10.*3.1415;\n    float hatch = sin(hatchUv*20.+t4)*SIN(t4);\n    hatch += sin(hatchUv+t)*SIN(t8);\n    col += (outline-swirl*hatch)*.5;\n    \n    // vignette\n    col *= 1.-dot(uv,uv);\n    \n    // color inversion\n    float bw = 1.-clamp(sin(length(uv)*1.-t*.1)*3., 0., 1.);\n    col = mix(col, 1.-col, bw);\n    \n    // add more 3d-ness\n    float fresnel = -dot(n, rd);\n    fresnel *= fresnel;\n    col *= mix(1., fresnel*fresnel, SIN(t8*.5674));\n    \n    \n    // Add some color\n    vec3 c = cross(rd, n);\n    c.xy *= Rot(t);\n    c.zy *= Rot(t4);\n    c = c*.5+.5;\n    c = pow(c, vec3(1.+SIN(t4)*3.));\n    float tasteTheRainbow = Fade(82., 83., 100., 120.);\n    tasteTheRainbow += Fade(143.5, 144.5, 170., 200.);\n    tasteTheRainbow += Fade(205., 206., 230., 260.);\n    col = mix(col, col*c*3., tasteTheRainbow);\n    \n    // add lightning\n    float lightning = fft*(.1/(minDistC));\n    vec3 lightningCol = lightning*mix(vec3(1.,.1,.1), vec3(.1, .1, 1.), bw);\n    float fade = Fade(21., 25., 50., 70.);\n    fade += Fade(82., 83., 100., 120.);\n    fade += Fade(143.5, 144.5, 170., 200.);\n    fade += Fade(215., 216., 230., 260.);\n    \n    col += lightningCol * fade;\n    \n    col *= Fade(0., 10., 290., 315.);\n    \n    // preview window gets the party right away\n    if(iResolution.x<300.) {\n       col = col*c*3.+lightningCol;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "llsGWr", "previewfilepath": "https://soundcloud.com/mamulashvili1/daft-punk-beyond-nicolas-jaar-feat-dave-harrington-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mamulashvili1/daft-punk-beyond-nicolas-jaar-feat-dave-harrington-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2GRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 837, 885, 885, 1023], [1025, 1025, 1076, 1076, 1263], [1265, 1265, 1284, 1284, 1360], [1363, 1363, 1387, 1387, 1683], [1685, 1685, 1702, 1702, 1814], [1816, 1816, 1843, 1843, 2022], [2024, 2024, 2041, 2041, 2143], [2167, 2167, 2224, 2224, 5194]]}
{"id": "td2GzR", "name": "Arcs12341324", "author": "theepicsnail", "description": "arcs", "tags": ["arcs"], "likes": 6, "viewed": 98, "published": "Public", "date": "1548022148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v,r,e) smoothstep(-.5*e/R.y, .5*e/R.y,  abs( fract(v)- .5) -r/2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2  R = iResolution.xy,\n          U = ( u*2. - R ) / R.y;\n   \n    float r = length(U) * 10.,\n      barId = ceil(r),\n        TAU = 6.2831852,\n          a = atan(U.y, U.x)/TAU + iTime * barId * .05 ,\n      inBar = 1.- S( r, .8, 40. ),\n  arcLength = .5 + .4*sin(iTime*.1), \n      inArc = S( a-arcLength/2.+.5, arcLength, 8./r );\n    \n    O = vec4(1.-inBar*inArc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2GzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 116, 116, 482]]}
{"id": "tdBGR1", "name": "SDF Symbol (finally)", "author": "Del", "description": "An attempt to express 'the symbol' as a Distance Field using some simple shapes and modifiers...", "tags": ["2d", "sdf", "shapes", "twist", "symbol", "bend", "mods"], "likes": 5, "viewed": 477, "published": "Public API", "date": "1548114231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// An attempt to express 'the symbol' as a Distance Field using some simple shapes and modifiers...\n//\n// I suck at modelling!\n\n#define PI 3.141592\n#define\tTAU 6.28318\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// simple bend(Y) mod\nvec2 opBendTest( vec2 p, float angle, float xmod )\n{\n    p.x += xmod;\n    p = rotate( angle * p.x ) * p.xy;\n    p.x -= xmod;\n    return p;\n}\n// simple spriral(x) mod\nfloat spiral(vec2 p, float sa, float b)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  float n = (log(l/sa)/b - a) / (2.*PI);\n  float upper_ray = sa * exp(b *(a + 2.*PI*ceil(n)));\n  float lower_ray = sa * exp(b *(a + 2.*PI*floor(n)));\n  return min(abs(upper_ray - l), abs(l-lower_ray));\n}\n\n// 2D-shapes (Trapezoid, Ring, Box, Triangle)\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y < 0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat ring(vec2 uv, float rad, float thickness)\n{\n    return abs(rad - length(uv)) - thickness;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}    \n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// 1xTriangle, 4xTrapezoid, 3xBox, 1xRing\n// 1xBend distort modifier\n// 1xSpiral distor modifier\n// 5xCircle cuts\nfloat NewSymbol(vec2 uv)\n{\n    vec2 p = uv+vec2(0.27,0.09);\n\tfloat s1 = length(p)-0.2;\t\t\t\t\t\t// circle1\n  \tfloat s2 = length(p+vec2(-0.22,-0.01))-0.18;\t// circle2\n\tp.x = spiral(p.xy, PI*0.5, -0.33);\t\t\t\t// Spiral distort\n    float d = sdTrapezoid(p,0.015,0.015,0.08);\t\t// could just be a box...\n\td = max(d, s1);\t\t\t\t\t\t\t\t\t// subtract circle\n\td = max(d,-s2);\t\t\t\t\t\t\t\t\t// subtract circle\n\n    p = vec2(abs(uv.x),uv.y);\n    //\td = min(d,sdTriangle(vec2(-0.155,0.1),vec2(-0.055,0.1),vec2(-0.105,0.05),p.yx)); // mid-cross tri\n    d = min(d, sdTrapezoid(p.yx+vec2(0.105,-0.075),0.0,0.05,0.025));   \t\t\t// mid-cross trapeziod!\n    d = min(d,sdBox(p+vec2(-0.05,0.105),vec2(0.025,0.025)));\t\t\t\t\t\t// mid-cross bar\n    d = min(d,sdTriangle(vec2(0.0, -0.425),vec2(0.1, -0.25),vec2(-0.025, -0.35),p.xy)); // bottom triangle\n    \n\tp = opBendTest(uv+vec2(0.16, -0.088),radians(77.0),-0.103);\n    d = smin(d, sdTrapezoid(p.yx,0.018,0.025,0.19), 0.012); // bent arm (attempted to smooth the join, needs work)\n\n    d = min(d,ring(uv+vec2(0.0,-0.26),0.13,0.028));\t\t\t// top-ring\n    d = min(d,sdBox(uv+vec2(0.0,0.13),vec2(0.032,0.2)));\t// main body\n    d = min(d,sdBox(uv+vec2(-0.08,-0.085),vec2(0.09,0.025))); // horn1 (bar)\n\n    float cuts = length( uv+vec2(-0.17,-0.32))-0.21;\n    cuts = min(cuts,length( uv+vec2(-0.17,0.15))-0.21);\n    cuts = min(cuts,length( uv+vec2(-0.73,-0.085))-0.4);\n    p = uv+vec2(-0.26,-0.085);\n    d = min(max(sdTrapezoid(p.yx,0.025,0.13,0.09),-cuts),d); // horn2 (cutout)\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    float time = iTime+0.2;\n    p.z -= 1.5;\n    \n    float twist = 0.5+sin(fract(time*0.4)*TAU)*0.5;\n    twist *= p.y * 1.5;\n    p.xz *= rotate(twist+fract(time*0.26)*TAU);\n    \n    float dist = NewSymbol(p.xy);\n    \n    float dep = 0.02;\n    vec2 e = vec2( dist, abs(p.z) - dep );\n    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    dist -= 0.01;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 2.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 120; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 20.) break;\n\t\tt += d*0.75;\n\t}\n    \n    vec3 c = vec3(0.35,0.35,0.45);\n    c*= 1.2-abs(uv.y);\n    \n    if (t<20.0)\n    {\n\t   \tvec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n        vec3 nor = normal(p);\n\n        float dif = max(dot(nor, lightDir), 0.0);\n        c = vec3(0.5) * dif;\n\n        float tf = 0.16;\n        c += vec3(0.65,0.6,0.25) + reflect(vec3(p.x*tf, p.y*tf,p.z*tf), nor);\n\n        vec3 ref = reflect(rd, nor);\n        float spe = max(dot(ref, lightDir), 0.0);\n        c += vec3(2.0) * pow(spe, 32.);\n    }\n\n    c *= 1.0 - 0.3*length(uv);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 169, 191, 191, 258], [260, 260, 301, 301, 394], [396, 418, 470, 470, 558], [559, 584, 625, 625, 880], [882, 928, 952, 952, 971], [972, 972, 1037, 1037, 1361], [1363, 1363, 1412, 1412, 1460], [1462, 1462, 1500, 1500, 1582], [1588, 1624, 1691, 1691, 2300], [2302, 2416, 2442, 2442, 3908], [3910, 3910, 3929, 3929, 4303], [4306, 4378, 4404, 4519, 4715], [4717, 4717, 4739, 4739, 5509], [5511, 5511, 5568, 5568, 5728]]}
{"id": "tdBGRh", "name": "Normal", "author": "valler", "description": "Numerical normals for SDFs", "tags": ["ray", "distance", "normal", "numerical", "march"], "likes": 1, "viewed": 75, "published": "Public", "date": "1548105848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat f (vec3 p)\n{\n    return sdTorus(p,vec2(cos(iTime)+4.5,.5*cos(iTime)+1.1));\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( vec3 p, float t )\n{\n    float e = 1.e-3*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*f( p + h.xyy*e ) + \n\t\t\t\t\t  h.yyx*f( p + h.yyx*e ) + \n\t\t\t\t\t  h.yxy*f( p + h.yxy*e ) + \n\t\t\t\t\t  h.xxx*f( p + h.xxx*e ));\n}\n\n// https://www.shadertoy.com/view/tsXGRl\nvec3 bg (vec2 p)\n{    \n    vec2 c = step(.1,fract(p*2.25+.05));\n    return vec3(c.x*c.y);\n}\n\nvoid mainImage( out vec4 c, in vec2 a )\n{\n    vec3 o = vec3(0,sin(iTime)+2.5,0);\n    vec3 y = vec3(0,1,0);\n    vec3 w = normalize(-o);\n    if (abs(dot(o,y)) > .999) y = y.xxy;\n    vec3 u = normalize(cross(w,y));\n    vec2 g = (a-.5*iResolution.xy)/iResolution.x;\n\tvec3 d = mat3(u,cross(u,w),w) * normalize(vec3(g,.25));\n    float t = 0., e = 1.e-4, m = 1.e6, h;\n    vec3 p = o;\n    while (t < m)\n    {\n        h = f(p);\n        if (h < e) break;\n        t = min(m,t+h);\n        p = o+d*t;\n    }\n    vec3 n = t > e && t < m ? calcNormal(p,t) : bg(g);\n    c = vec4(n,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 103, 103, 168], [170, 170, 188, 188, 252], [254, 318, 354, 354, 561], [563, 604, 622, 622, 695], [697, 697, 738, 738, 1266]]}
{"id": "tdfGRX", "name": "TraceCircles", "author": "Sevapp", "description": "TraceCircles", "tags": ["raytracing", "circles", "animate"], "likes": 0, "viewed": 76, "published": "Public", "date": "1547019461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distToCirc(vec3 rayPos, vec3 rayVec, vec3 planePos, vec3 planeNormal)\n{\n\tfloat  dist = dot(rayPos - planePos, planeNormal) / dot(rayVec, planeNormal);\n\treturn dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 pixelColor  = vec4(1.0);  \n    vec2 pixelPos    = fragCoord.xy;\n    \n    vec2 uv    = fragCoord / iResolution.xy;\n    vec3 col   = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n    \n    pixelColor = vec4(col * (abs(fragCoord.y - iResolution.y / 2.0)) * 0.005, 1.0);\n    \n    vec3 camPos = vec3(iResolution.x / 2.0, iResolution.y / 2.4, 600.0);\n    vec3 rayVec = normalize(vec3(pixelPos, 0.0) - camPos);\n    \n    \n    vec3 planeNormal = vec3(cos(iTime) / 5.0,  1.0,  0.0);\n    float offset = 500.0 * cos(iTime);\n    for (int i = -10; i < 10; i ++)\n    {\n        vec3 planePos = vec3(0.0, iResolution.y + float(i) * 100.0 + offset, -2100.0);\n        \n        float dist    = distToCirc(camPos, rayVec, planePos, planeNormal);\n\n        if (dist > 0.0)\n        {\n            vec3 point = rayVec * (abs(dist) + camPos);\n            float cDist = distance(point, planePos);\n            if (cDist < 1000.0 && cDist > 900.0) pixelColor = vec4(col, 1.0);\n        }\n    }\n    \n    \n    \n    fragColor = pixelColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 77, 77, 172], [174, 174, 229, 229, 1248]]}
{"id": "tdfGWr", "name": "Rotate Earth", "author": "gena", "description": "Forked from https://www.shadertoy.com/view/lstXW8\nadded mouse rotation", "tags": ["earth"], "likes": 13, "viewed": 355, "published": "Public", "date": "1546424312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from the amazing shader by mhnewman: https://www.shadertoy.com/view/XlXGD7\n\n//\tMy first contribution to Shadertoy\n//\tI have been a big fan of this community for a while and I want to thank iq for\n//\tthis wonderful site.\n//\tHash functions from David Hoskins via https://www.shadertoy.com/view/4djSRW\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat hash12_3(vec2 p) {\n\tfloat f = hash12(p);\n    return f * f * f;\n}\n\nfloat noise_3(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12_3(i + vec2(0.0, 1.0)), \n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5 * noise(p); p = m * p;\n    f += 0.25 * noise(p); p = m * p;\n    f += 0.125 * noise(p); p = m * p;\n    f += 0.0625 * noise(p); p = m * p;\n    f += 0.03125 * noise(p); p = m * p;\n    f += 0.015625 * noise(p);\n    return f / 0.984375;\n}\n\nvec3 getDir(vec2 screenPos) {\n    screenPos -= 0.5;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    return normalize(vec3(0.0, -1.0, -3.0)\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\n}\n\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\n    bool valid = false;\n    \n\tfloat b = dot(camera, dir);\n\tfloat c = dot(camera, camera) - 1.0;\n\tfloat h = b * b - c;\n\tif (h > 0.0) {\n        valid = true;\n        \n        vec3 p = camera + (-b - sqrt(h)) * dir;\n        pos = p.xz + iTime * vec2(0.005, 0.02) + vec2(-iMouse.x, iMouse.y) / 1000.0;        \n\t}\n\n\treturn valid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    \n    vec3 camera = vec3(0.0, 1.2, 0.7);\n    vec3 dir = getDir(screen);\n    \n    vec3 earth = vec3(0.0, 0.0, 0.0);\n    vec2 position;\n    if (getPosition(camera, dir, position)) {\n        float geography = fbm(6.0 * position);\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\n        vec2 p = 40.0 * position;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast);\n        population = smoothstep(0.0, 0.02, population);\n\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\n        vec3 water = vec3(0.0, 0.05, 0.1);\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \n\n        float lightning = 0.0;\n        vec2 strike;\n        if (getPosition(camera, getDir(hash21(iTime)), strike)) {\n            vec2 diff = position - strike;\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\n        }\n        lightning *= smoothstep(0.65, 0.75, weather);\n        earth += lightning * vec3(1.0, 1.0, 1.0);\n    }\n    \n    vec3 altitude = camera - dir * dot(camera, dir);\n    float horizon = sqrt(dot(altitude, altitude));\n    \n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\n    atmosphere = mix(atmosphere, vec3(0.05, 0.1, 0.3), smoothstep(0.992, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\n\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 361, 383, 383, 510], [512, 512, 534, 534, 701], [703, 703, 727, 727, 1019], [1021, 1021, 1045, 1045, 1091], [1093, 1093, 1119, 1119, 1419], [1421, 1421, 1440, 1440, 1706], [1708, 1708, 1737, 1737, 1989], [1991, 1991, 2052, 2052, 2379], [2381, 2381, 2438, 2438, 4725]]}
{"id": "tdfGzX", "name": "Simple 2D Flame Shader Spinoff", "author": "red", "description": "A knockoff of catafest's shader, with a few more effects: https://www.shadertoy.com/view/3sX3RX", "tags": ["2d", "flame", "spinoff"], "likes": 15, "viewed": 261, "published": "Public", "date": "1546991277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I made some tweaks to catafest's simple flame shader for fun \n//Original can be found here: https://www.shadertoy.com/view/3sX3RX\n\n//I wanted to preserve his simplicity, but make it a little more realistic while adding parameters that could \n//be easily tweaked for clarity\n\n//Bloom brightness\n#define Bloom 0.1\n//Vertical bobbing caused by candle impurities\n#define VerticalMotion 0.01\n//Horizontal paremeter that simulates small air currents\n#define HorizontalMotion 0.35\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv;\n    float aspect = iResolution.y / iResolution.x;\n    nuv.x *= aspect;\n    \n\tvec2 pos = uv * 2.0-vec2(1.,1.);\n    // create horizontal flame variation\n    pos.x += sin(iTime*0.1) * uv.y * (sin(iTime - uv.y) + cos((iTime - uv.y) * 0.1)) * 0.5 * HorizontalMotion;\n    \n    // create vertical flame variation \n    pos.y += VerticalMotion * fract(sin(30.0*iTime)) + VerticalMotion * sin(iTime);\n    \n    // select background to black\n\tvec3 color = vec3(0.0,0.0,0.0);\n    \n\t// set scale of flame \n\tfloat p =.001;\n    \n    // create shape of flame (output y)\n\tfloat y = pow(abs(pos.x), 3.0 + cos(iTime)*0.1)/(1.0*p)*1.0;\n    \n\t// create the hight of flame \n\tfloat flame_out = length(pos+vec2(pos.x,y)) * 0.78332; // 0.78332 = sin(0.9)\n    \n\t// fix colors flame by RGB\n\tcolor.rg += smoothstep(0.0,0.3,0.6-flame_out);\n    \n    // fix color of flame by G (green)\n\tcolor.g /=2.4;\n    \n    //add slight blue to the base of the flame\n    color.b -= 0.2 * pos.y / flame_out;\n\t\n    //Add bloom\n    color.rg += smoothstep(0.0, 10.1, 1.0 / distance(nuv, vec2(pos.x+0.25, (pos.y*0.1+0.4)))) * Bloom;\n    color.r += smoothstep(0.0, 5.1, 1.0 / distance(nuv, vec2(pos.x+0.25, (pos.y*0.1+0.5)))) * Bloom;\n    \n    // output color\n\tcolor += pow(color.r,1.0);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 477, 534, 584, 1920]]}
{"id": "tdj3Rm", "name": "The sign - pierwsza modyfikacja", "author": "aga1212", "description": "Zmiana vec2 rightDot = dotCoordinates(0.45) na vec2 rightDot = dotCoordinates(0.7, vec2(0.9)  doprowadziła do zniekształcenia głównego elementu shendera.", "tags": ["beginer"], "likes": 1, "viewed": 49, "published": "Public", "date": "1548510196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.1, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\nvec2 dotCoordinates (float radius, vec2 offset, float t)\n{\n\tvec2 pos;\n    pos.x = offset.x + radius*cos(t);\n    pos.y = offset.y + radius*sin(t)*cos(t);\n    return pos;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n   // pMod3(q, vec3(0.75, 1., 0.8));\n    pMod3(q, vec3(1., cos(iTime), 0.));\n    \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(cos(p.x*10.)) *\n                       abs(cos(p.y*10.)) *\n                       abs(cos(p.z*10.)) );\n    \t//s1 += disp;\n    \ts1 *= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(s1, s2); // Intersection\n    float df3 = max(s1, -s3); // Difference\n    \n    return df3;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r;\n        float d = map(p);\n        t += d;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(cos(iTime), 0.12, 0.536);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, sin(iTime), cos(iTime));\n    float t = trace(origin, ray);\n    t  *= smoothstep(0., 2., length(uv.y/uv.x)*10.);\n\n    float expFog = 0.5 / (t*t* 0.5);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    fragColor = vec4((fc+color),6.0);\n    vec2 uv1 = fragCoord.xy / iResolution.xy;\n    \n    \n    int tailLength = 250; // Number of tail particles.\n    float particleSize = 0.025; // Radius of the particles.\n    \n    for (int h = tailLength; h > 0; h--)\n    {\n        vec2 rightDot = dotCoordinates(0.7, vec2(0.9, 0.5), iTime - (0.02 * float(h)));\n        vec2 leftDot = dotCoordinates(-0.5, vec2(0.5, 0.5), iTime - (0.02 * float(h))); \n        float d = distance(leftDot, uv1);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv1.x, uv1.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n        d = distance(rightDot, uv1);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv1.x, uv1.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdj3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 127, 127, 198], [200, 200, 237, 237, 280], [282, 282, 317, 317, 349], [350, 350, 408, 408, 520], [522, 522, 541, 541, 1102], [1105, 1105, 1140, 1140, 1289], [1292, 1292, 1349, 1349, 2664]]}
{"id": "tdjGRm", "name": "The sign- projekt główny", "author": "aga1212", "description": "project", "tags": ["beginner"], "likes": 2, "viewed": 55, "published": "Public", "date": "1548508811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nvoid pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tp = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\nvec2 dotCoordinates (float radius, vec2 offset, float t)\n{\n\tvec2 pos;\n    pos.x = offset.x + radius*cos(t);\n    pos.y = offset.y + radius*sin(t)*cos(t);\n    return pos;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n\n   // pMod3(q, vec3(0.75, 1., 0.8));\n    pMod3(q, vec3(1., cos(iTime), 0.));\n    \n    \n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);\n    float s3 = sphere(q, 0.7);\n    \n    float disp = 0.5 * (abs(cos(p.x*10.)) *\n                       abs(cos(p.y*10.)) *\n                       abs(cos(p.z*10.)) );\n    \t//s1 += disp;\n    \ts1 *= disp;\n    \t\n    \n    \n  \tfloat df1 = min(s1, s2); // Union\n    float df2 = max(s1, s2); // Intersection\n    float df3 = max(s1, -s3); // Difference\n    \n    return df3;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r;\n        float d = map(p);\n        t += d;\n        }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(cos(iTime), 0.12, 0.536);\n    uv = uv *2.-1.; // Remap the space to -1. to 1.\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \t\n   \tfloat FOV = 1.0;\n   \tvec3 ray = normalize(vec3(uv, FOV));\n    \n    \n    vec3 origin = vec3(iTime, sin(iTime), cos(iTime));\n    float t = trace(origin, ray);\n    t  *= smoothstep(0., 2., length(uv.y/uv.x)*10.);\n\n    float expFog = 0.5 / (t*t* 0.45);\n    \n    vec3 fc = vec3(expFog);\n    \n\n    fragColor = vec4((fc+color),1.0);\n    vec2 uv1 = fragCoord.xy / iResolution.xy;\n    \n    \n    int tailLength = 250; // Number of tail particles.\n    float particleSize = 0.025; // Radius of the particles.\n    \n    for (int h = tailLength; h > 0; h--)\n    {\n        vec2 rightDot = dotCoordinates(0.45, vec2(0.5, 0.5), iTime - (0.02 * float(h)));\n        vec2 leftDot = dotCoordinates(-0.45, vec2(0.5, 0.5), iTime - (0.02 * float(h))); \n        float d = distance(leftDot, uv1);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv1.x, uv1.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n        d = distance(rightDot, uv1);\n        if (d < particleSize)\n        {\n            fragColor = vec4(uv1.x, uv1.y, 0.8 + 0.2*sin(iTime), 1.0) - float(h)/float(tailLength);   \n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 127, 127, 198], [200, 200, 237, 237, 280], [282, 282, 317, 317, 349], [350, 350, 408, 408, 520], [522, 522, 541, 541, 1102], [1105, 1105, 1140, 1140, 1289], [1292, 1292, 1349, 1349, 2667]]}
{"id": "tdl3DN", "name": "mountain terrain", "author": "hchow", "description": "rough shell for CS1230 final project. includes terrain generation using perlin noise and fog!", "tags": ["terrain", "mountain"], "likes": 10, "viewed": 758, "published": "Public", "date": "1546391533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float dMax = 10.0;\n\nfloat rand(vec2 p) {\t\n\treturn fract(sin(dot(p, vec2(12.231,64.102))) * 63360.01203);\n}\n\nfloat noise(vec2 p) {\n    float A = rand(vec2(floor(p.x), floor(p.y)));\n    float B = rand(vec2(floor(p.x) + 1.0, floor(p.y)));\n    float C = rand(vec2(floor(p.x), floor(p.y) + 1.0));\n    float D = rand(vec2(floor(p.x) + 1.0, floor(p.y) + 1.0));\n\n    float fc = fract(p.x);\n    float bicubicc = fc * fc * (3.0 - 2.0 * fc);\n\n    float fr = fract(p.y);\n    float bicubicr = fr * fr * (3.0 - 2.0 * fr);\n\n    float AB = mix(A, B, bicubicc);\n    float CD = mix(C, D, bicubicc);\n\n    float final = mix(AB, CD, bicubicr);\n\n    return final;\n}\n\n\nfloat heightmap(vec3 p) {\n    \n   \n    float dMin = dMax; // nearest intersection\n    float d; // depth\n    float material = -1.0; // material ID\n    \n    // adding octaves of height\n    float h = 0.0; // height\n    float w = 0.5; // octave weight\n    float m = 0.4; // octave multiplier\n    \n    //iterating through 10 octaves of height\n    for (int i=0; i < 9; i++) {\n        h += w * noise(p.xz * m);\n        w *= 0.5;\n        m *= 2.0;\n    }\n    \n    \n    //makes a more mountainous look\n    h += smoothstep(0.3, 1.0, h);\n    \n    d = p.y - h;\n    if (d<dMin) { \n        dMin = d;\n        material = 0.0;\n    }\n    \n    return dMin;\n}\n\n\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    const float marchDist = 0.001; // precision\n    float currHeight = 0.0; // distance\n    float nextStep = marchDist * 2.0; // step\n   \n    for (int i=0; i < 36; i++) {\n        if (abs(nextStep)> marchDist) {\n            currHeight += nextStep; // next step\n            float pos = heightmap(ro + rd * currHeight); // next intersection\n            nextStep = pos; // distance\n           \n        } else {\n            break;\n        }\n    }\n    return currHeight;\n}\n\n\n\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float x = heightmap(p - e.xyy) - heightmap(p + e.xyy);\n    float y = 2.0*epsilon;\n    float z = heightmap(p - e.yyx) - heightmap(p + e.yyx);\n    return normalize(vec3(x,y,z));\n}\n\nvec3 render( vec3 ro, vec3 rd ) {\n\n    //color of the sky\n    vec3 color = vec3(0.3,0.4,0.6);\n    float height = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 0.0));\n    vec3 world = ro + rd * height;\n    \n    \n    vec3 normal = calcNormal(world); // terrain normals\n    \n    \n    // color it like a mountain if it satisfies these heights\n    if (height < dMax) {\n        \n        // gray undertone of rock color\n        color = vec3(102.0) / 255.0;\n        \n        float slope = 1.0 - dot (normal, vec3 (0.0, 1.0, 0.0));\n        if (slope < 0.05){\n    \t\tcolor = mix(vec3(1.0, 1.0, 1.0), color, 0.15);\n    \t}\n        \n        //phong lighting model\n        float ambient = 0.4;\n        float diffuse = 2.25 * clamp(dot(normal, light), 0.0, 2.0);\n        float specular = pow(clamp(dot(rd, reflect(light, normal)), 0.0, 1.0), 32.0);\n     \n        color *= (ambient + diffuse);\n    }\n    \n    if (height > dMax){\n   \t\tfloat fog = exp(-0.005 * height * height); // exponential fog equation\n   \t\tcolor = mix(color, vec3(1.0), fog); // add fog in distance\n    }\n   \t\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = 2.0*(fragCoord/iResolution.xy) - vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float x = 0.0 + 16.0 + (0.5*iTime);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + 16.0 + sin(0.1*iTime);\n\tvec3 rayOrigin = vec3(x, y, z); // position;\n    rayOrigin.y = 0.4 * noise((rayOrigin.xz * 0.5)) + 1.5;\n    \n    const vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 target = vec3(0.0);\n    vec3 look = normalize(rayOrigin - target);\n    \n    \n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    \n    vec3 rayDirection = vec3(uv, 1.0);\n    rayDirection = normalize(rayDirection.x * cameraRight + rayDirection.y * cameraUp + rayDirection.z * cameraForward);\n    \n\n    vec3 color = render(rayOrigin, rayDirection);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdl3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 92, 92, 158], [160, 160, 181, 181, 695], [698, 698, 723, 723, 1336], [1341, 1341, 1375, 1375, 1842], [1904, 1921, 1946, 1946, 2128], [2130, 2130, 2163, 2187, 3231], [3233, 3233, 3290, 3290, 4139]]}
{"id": "tdl3Wl", "name": "Thingadgasfhasfh1", "author": "theepicsnail", "description": "thing1", "tags": ["thing1"], "likes": 0, "viewed": 39, "published": "Public", "date": "1547837647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cossin(float r) { return vec2(cos(r), sin(r)); }\nmat2x2 rotMat(float r) { \n    vec2 cs = cossin(r);\n    return mat2x2(cs.x, -cs.y, cs.y, cs.x);\n}\nvoid rotate(inout vec2 p, float r) { p = rotMat(r)*p; }\nvoid translate(inout vec2 p, vec2 offset) { p+=offset; }\n\nfloat closesedMirror = 100.0;\nfloat totalMirror = 0.0;\nfloat flipCount = 0.0;\nvoid vmirror(inout vec2 p) {\n    if(p.y < .0) flipCount += 1.0;\n    p.y=abs(p.y);\n    totalMirror += p.y;\n    closesedMirror=min(closesedMirror,p.y);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid scale(inout vec2 p, float s) { p *= s; }\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n    uv/=iResolution.xy;\n    uv = (uv-.5)*2.0;\n    uv.x*=iResolution.x/iResolution.y;\n    float angle;\n    \n    scale(uv, 1.0);\n    \n     angle = atan(uv.y,uv.x);\n    float d = length(uv);\n    \n    \n    //uv = vec2(cos(uv.x), sin(uv.y));\n    //translate(uv, cossin(iTime));\n    \n    \n    fragColor.r=(1.0-length(fract(uv+.5)-.5));\n   \tfragColor.g=cos(.1*iTime*length(floor(uv+.5)))*.2+.2;\n    //fragColor.gb=fract(uv);\n    \n    \n    //*\n    scale(uv, 3.0);\n\tfloat max_itr = 100.0;\n    float itr = max_itr;\n    vec3 colorScale = vec3(3,4,5) * itr *.2;\n    \n    vec2 center = vec2(0,0);\n     angle = 0.0;\n    while(itr-->0.0) {\n        angle = fract(angle/3.1415926535)*3.1415926535;\n        center = cossin(angle);\n        angle += iTime/max_itr;\n        \n        \n\t    // move mirror center to center to (0,0)\n\t    translate(uv, -center);\n\t    rotate(uv, angle);\n        \n        vmirror(uv);\n\t    rotate(uv, -angle);\n\t    translate(uv, center);\n    }\n    \n    // coloring \n    uv = fract(uv);\n    float K = .2;\n    \n    float bloom = pow(totalMirror + .0, -K);\n    float mirror_dist = closesedMirror*max_itr;\n    float cell_color = abs(cos(flipCount));\n    \n    fragColor = vec4(0);\n    fragColor.r = fract(bloom);\n    \n    fragColor.g = fract(bloom*.1);\n    fragColor.b = fract(bloom*.01);\n    \n    float base = iTime*.1;\n    float hue = base+ sin(cell_color*iTime)*.2;\n    fragColor.rgb = hsv2rgb(vec3(hue, bloom, mirror_dist*.1));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdl3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 53], [54, 54, 78, 78, 150], [151, 151, 187, 187, 206], [207, 207, 250, 250, 263], [343, 343, 371, 371, 494], [496, 496, 518, 518, 687], [689, 689, 724, 724, 734], [735, 735, 785, 785, 2225]]}
{"id": "tdlGDB", "name": "Johny Huang Jelek", "author": "beefburrito", "description": "Tonjok pemain dota tutorial itu", "tags": ["asdf"], "likes": 1, "viewed": 282, "published": "Public API", "date": "1547449438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end,float blur){\n    float step1 = smoothstep (start - blur, start + blur, t);\n    float step2 = smoothstep( end + blur, end-blur,t);\n    return step1 * step2;\n}\n\nfloat Rectangle(vec2 uv, float blur, float left, float right,float bottom, float top){\n    float r;\n    r = Band(uv.x, left, right, blur);\n    r *= Band(uv.y, bottom,top,blur);\n    return r;\n}\n\nfloat Square( vec2 uv, float blur, float point) {\n    return Rectangle(uv, blur, -point,point,-point,point);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 col, col1, col2;\n    \n    float c;\n    \n    float x =uv.x;\n    float y=uv.y;\n    \n    c = Rectangle(vec2(x,y), .001,-1. ,1.,-0.005,.0005);\n    c += Rectangle(vec2(x,y), .001,-.005 ,.0005,-1.00,1.);\n\t\n    col1 = vec4(1.,0.,0.,0.)*c;\n    \n    float m = -(x-.5) * (x + .5);\n    float a =1.,f=10.,t=2.;\n    m *= sin(iTime*t-x*f) * a;\n    y += m;\n    \n    c+= Rectangle(vec2(x,y),.001,-1.,1.,-0.01,.01);// \n    \n    col2 =vec4(1.,1.,0.,0.)*c;\n    \n    col = mix(col1,col2,.3);\n    \n    fragColor =vec4(col);\n\n    // Time varying pixel color\n\n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 200], [202, 202, 288, 288, 394], [396, 396, 445, 445, 506], [512, 512, 569, 619, 1297]]}
{"id": "tdlGR2", "name": "Voronoi Cell Boundaries 2", "author": "mla", "description": "Looking at [url]https://www.shadertoy.com/view/3sfGRj[/url] a little more, it's turned into something like tomkh's [url]https://www.shadertoy.com/view/llG3zy[/url]. Find closest point, then distance to all borders.", "tags": ["2d", "voronoi", "cell", "boundaries"], "likes": 9, "viewed": 700, "published": "Public API", "date": "1546993787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2019 by Matthew Arcus\n//\n// Simple 2D Voronoi. Examine the 16 cells nearest to the nearest grid point.\n//\n// For drawing the lines, take the closest point and find minimum distance to\n// the bisector of that point and all the other grid points examined (we store\n// the point from the first pass in an array). This seems to give a correct\n// distance function to the cell borders. An approximate but satisfactory\n// solution is to just keep the closest N points.\n//\n// Mouse-x: zoom\n// Mouse-y: line width\n// 'g': show grid\n// 'i': show isolines\n// 'm': monochrome\n// 'p': show cell points\n// 'q': show glitches\n// 'v': show voronoi cells\n// 'w': wrap grid\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Determine how far outside the cell the cell point may go.\n// Too far and we get glitches where the computed nearest cell\n// boundary is not in fact the closest (see with 'q' key).\nconst float K = 0.6;  // Point offset limit. 0.5 = the cell itself\nconst float gridsize = 3.0;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n// Wang Hash, used to seed RNG\nuint ihash(uint a) {\n  a = (a ^ 61U) ^ (a >> 16);\n  a *= 9U;\n  a = a ^ (a >> 4);\n  a = a * 0x27d4eb2dU;\n  a = a ^ (a >> 15);\n  return a;\n}\n\n// Note that we convert from float to integer to unsigned\nuint ihash(ivec2 p) {\n  uint i = uint(p.x), j = uint(p.y);\n  return ihash((i << 16) ^ j);\n}\n\n// xorshift from George Marsaglia, http://www.jstatsoft.org/v08/i14/paper,\n// via https://www.shadertoy.com/view/tsf3Dn from zeh.\nuint xorshift(uint value) {\n  // Xorshift*32\n  value ^= value << 13;\n  value ^= value >> 17;\n  value ^= value << 5;\n  return value;\n}\n\nuint seed = 1U;\nuint rng() {\n  //seed = lcg(seed);\n  seed = xorshift(seed);\n  return seed;\n}\n\n// Uniform random float in [0,1)\nfloat rand() {\n  return float(rng())/pow(2.0,32.0);\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nfloat bisectordistance(vec2 pos, vec2 a, vec2 b) {\n  vec2 centre = 0.5*(a+b);\n  return dot(pos-centre,normalize(a-b));\n}\n\n// Returns point for particular cell in the grid\n// Also seeds RNG for the cell.\nvec2 getcellpoint(vec2 grid, float i, float j) {\n  float speed = 0.5;\n  float t = speed*iTime;\n  vec2 cell = grid + vec2(i,j);\n  vec2 mcell = cell;\n  if (keypress(CHAR_W)) mcell = mod(mcell,2.0*gridsize);\n  seed = ihash(ivec2(mcell)); // Seed RNG for this cell\n  vec2 p = vec2(rand(),rand());\n  vec2 offset = K+t*p;\n  offset = mod(offset,4.0*K);\n  offset = min(offset,4.0*K-offset);\n  offset -= K;\n  return cell+vec2(0.5)+offset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float scale = 1.0;\n  float lwidth = 0.05;\n  \n  if (iMouse.x != 0.0) {\n    scale *= 2.0*iMouse.x/iResolution.x;\n    lwidth *= 2.0*iMouse.y/iResolution.y;\n  }\n  vec2 pos  = (2.0*fragCoord - iResolution.xy)/ iResolution.y;\n  pos *= scale;\n  pos *= gridsize;\n  vec2 grid = round(pos); // Nearest grid point\n  const int NPOINTS = 16;\n  vec4 points[NPOINTS];   // vec4(p.x,p.y,distance,color);\n  // And iterate through 16 cells around the grid point.\n  int pointindex = 0;\n  int closest = 0;\n  float mindist = 1e8;\n  for (float i = -2.0; i <= 1.0; i++) {\n    for (float j = -2.0; j <= 1.0; j++) {\n      vec2 cellpoint = getcellpoint(grid,i,j);\n      float d = distance(cellpoint,pos);\n      if (d < mindist) {\n        closest = pointindex;\n        mindist = d;\n      }\n      points[pointindex++] = vec4(cellpoint,d,rand());\n    }\n  }\n  vec3 basecolor = vec3(0.8);\n  if (!keypress(CHAR_V)) {\n    // Look through previously calculated points and find minimum distance\n    // from point to cell wall.\n    float mindist = 1e8;\n    for (int i = 0; i < NPOINTS; i++) {\n      if (i != closest) {\n        mindist = min(mindist,bisectordistance(pos,points[closest].xy,points[i].xy));\n      }\n    }\n    if (keypress(CHAR_M)) {\n      basecolor = vec3(points[closest].w);\n    } else {\n      basecolor = hsv2rgb(points[closest].w,1.0,1.0);\n    }\n    if (!keypress(CHAR_I)) basecolor *= 2.0*(mindist+0.1)*(0.5*sin(80.0*mindist)+0.5);\n    basecolor = mix(vec3(0.05),basecolor,smoothstep(lwidth,1.25*lwidth,mindist));\n\n    // Check things: for the next layer of cells out, check that the bisector\n    // distance isn't closer that the one we have calculated above.\n    if (keypress(CHAR_Q)) {\n      for (float i = -3.0; i <= 2.0; i++) {\n        for (float j = -3.0; j <= 2.0; j++) {\n          if (i >= -2.0 && i <= 1.0 && j >= -2.0 && j <= 1.0) continue;\n          vec2 cellpoint = getcellpoint(grid,i,j);\n          if (distance(cellpoint,points[closest].xy) > 1e-2) {\n            float d = bisectordistance(pos,points[closest].xy,cellpoint);\n            assert(d >= mindist);\n          }\n        }\n      }\n    }\n  }\n  \n  if (keypress(CHAR_G)) {\n    // Draw grid\n    vec2 gridpos = pos-floor(pos); // Distance to cell wall\n    gridpos = min(gridpos,1.0-gridpos);\n    basecolor *= 0.5+0.5*smoothstep(0.04,0.05,min(gridpos.x,gridpos.y));\n  }\n  if (keypress(CHAR_P)) {\n    basecolor *= 0.25+0.75*smoothstep(1.25*lwidth,1.5*lwidth,\n                                      distance(pos,points[closest].xy));\n  }\n  basecolor = sqrt(basecolor);\n  if (alert) basecolor.x = 1.0;\n  fragColor = vec4(basecolor,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[837, 1137, 1158, 1158, 1184], [1186, 1217, 1237, 1237, 1355], [1357, 1415, 1436, 1436, 1506], [1508, 1638, 1665, 1682, 1771], [1789, 1789, 1801, 1823, 1865], [1867, 1900, 1914, 1914, 1953], [2117, 2117, 2142, 2142, 2202], [2204, 2299, 2340, 2340, 2516], [2518, 2518, 2568, 2568, 2638], [2640, 2721, 2769, 2769, 3152], [3154, 3154, 3209, 3209, 5792]]}
{"id": "tdlGWX", "name": "Realtime Review", "author": "tmcgillicuddy", "description": "Just a basic review of graphics", "tags": ["class"], "likes": 0, "viewed": 265, "published": "Public API", "date": "1547740330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circleLoc = vec2(0.5,0.5), squareCenter = vec2(0.5,0.5);\nfloat rad1 = 0.1, rad2 = 0.2;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    //Correct uv for aspect ratio\n    uv.y *= iResolution.y/iResolution.x;\n    \n    //Correct shape location for aspect ratio\n    circleLoc.y *= iResolution.y/iResolution.x;\n    squareCenter.y *= iResolution.y/iResolution.x;\n    \n    //Move square center\n    vec2 newLoc = squareCenter; \n    newLoc.y = squareCenter.y * (1.0+sin(iTime));\n    \n    //Creat the first circle\n    float circle1 = step(rad1, distance(circleLoc,uv));\n    vec4 Layer3 = (1.0-circle1) * vec4(1,0,0,1);\n    \n    //Create rectangle\n    float interpX = step(newLoc.x-0.1, uv.x) - step(newLoc.x + 0.1, uv.x);\n\tfloat interpY = step(newLoc.y-0.1, uv.y) - step(newLoc.y + 0.1, uv.y);\n    vec4 Layer2 = (interpX * interpY) * vec4(0,1,0,1);\n\n    //Create 2nd Circle\n    float circle2 = step(rad2, distance(circleLoc,uv));\n    vec4 Layer1 = (1.0-circle2) * vec4(0,0,1,1);\n    \n    \n    //Create the base canvas with the rainbow colors\n    vec4 Canvas = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0);\n    \n    //Add the layers in order from 3 to 1\n    Canvas = mix(Canvas, Layer1, Layer1.a);\n    Canvas = mix(Canvas, Layer2, Layer2.a);\n    Canvas = mix(Canvas, Layer3, Layer3.a);\n    \n    fragColor = Canvas;\n    \n        //float circleLength = length(circleLoc - uv);\n\t\n    //if(circleLength< rad1) //Render Top most circle\n    //{\n    // \tfragColor = vec4(1.0,0,0,1);   \n    //}\n    //else if(uv.x > newLoc.x- 0.1 && uv.x < newLoc.x + 0.1 &&\n    //       uv.y > newLoc.y- 0.1 && uv.y < newLoc.y + 0.1) //Render Rectangle\n    //{\n    //    fragColor = vec4(0.0,0.0,1.0,1.0);\n    //}\n    //else if(circleLength< rad2) //Render Bottom most circle\n    //{\n    //    fragColor = vec4(0,1.0,0,1);   \n    //}\n    //else //Render general background\n    //{\n    //\t// Time varying pixel color\n    //\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //\t// Output to screen\n    //\tfragColor = vec4(col,1.0);\n    //}\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 201, 2133]]}
{"id": "tds3RX", "name": "Fake SSS", "author": "bitnenfer", "description": "Just testing some very bad sss but that kind of works on some shapes", "tags": ["sss"], "likes": 5, "viewed": 128, "published": "Public", "date": "1547086931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 0.01\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nvec3 kLightDir = vec3(0.0, 0.1, 0.0);\nfloat kSSS = 0.25;\nfloat kRoughness = 0.1;\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nmat2 rot(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r));}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat map(vec3 p)\n{    \n    float s0 = length(vec3(1.0, 1.0, 2.0) * p + vec3(0.5, 0.0, 0.0)) - 0.3;\n    float s1 = length(vec3(1.0, 1.0, 2.0) * p + vec3(-0.5, 0.0, 0.0)) - 0.3;\n    float t = 0.0;sin(4.0 * p.y + iTime * 3.0) * 0.1;\n    float b = box(p, vec3(0.3 + t, 0.3, 0.3)) - 0.05;\n    return smin(s0, smin(s1, b, 0.1), 0.1);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 d = vec2(0.0, 0.01);\n    return normalize(map(p) - vec3(\n        map(p - d.yxx),\n        map(p - d.xyx),\n        map(p - d.xxy)\n    ));\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = PI * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(vec3 n, vec3 v, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    float NdotV = max(0.0, dot(n, v));\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(vec3 n, vec3 v, vec3 l, float a)\n{\n    float g1 = GeometryGGX(n, l, a);\n    float g2 = GeometryGGX(n, v, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 PBR(vec3 p, vec3 n, vec3 v, in DirLight l, in Material material, float shadowContrib)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(n, v, l.dir, roughness);\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = (num / max(denom, EPSILON)) * pow(shadowContrib, 2.0);\n    \n    return (material.albedo * 0.03) + ((Kd * material.albedo / PI + specularBRDF) * radiance * NdotL * shadowContrib);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    kLightDir.x = cos(iTime * 0.5);\n    kLightDir.z = sin(iTime * 0.5);\n    vec3 color = vec3(0.04);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float mx = 6.28 * (iMouse.x / iResolution.x * 2.0 - 1.0);\n    float t = 0.0;\n    vec3 l = normalize(kLightDir);\n    \n    ro.xz *= rot(mx);\n    rd.xz *= rot(mx);\n    \n    float atten = 0.1;\n    \n    vec3 matColor = vec3(0.1, 0.1, 0.4);\n    vec3 lightColor = vec3(3.0, 0.1, 0.1);\n    \n    Material mat = Material(matColor, kRoughness, 0.0);\n    \n    for (int i = 0; i < 400; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n\n        if (d < 0.001)\n        {\n            vec3 l = normalize(l);\n            vec3 v = normalize(-rd);\n            vec3 h = normalize(v + l);\n            vec3 n = norm(p);\n            \n            // Shadows\n            float shadowContrib = 1.0;\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n                float stepSize = 0.0;\n                float atten = 1.0;\n                for (int j = 0; j < 32; ++j)\n                {\n                    float d2 = map(ro2 + rd2 * stepSize);\n                    if (d2 < 0.01)\n                    {\n                        shadowContrib = clamp(atten * stepSize, 0.0, 1.0);\n                        break;\n                    }\n                    stepSize += 0.01;\n                    atten *= 1.05;\n                }\n            }\n            \n            DirLight dirLight = DirLight(l, lightColor);\n            color = PBR(p, n, v, dirLight, mat, shadowContrib);\n    \t\t\n            // Fake SSS\n            {\n                vec3 rd2 = l;\n                vec3 ro2 = p + rd2 * 0.1;\n\n                if (kSSS > 0.0)\n                {\n                    for (int j = 0; j < 32; ++j)\n                    {\n                        float stepSize = kSSS;\n                        float d2 = map(ro2 + rd2 * kSSS);\n                        if (d2 < 0.0)\n                        {\n                            break;\n                        }\n                        color += (matColor + (lightColor * d2 * 0.1)) * 0.01 * d2;\n                    }\n                }\n            }\n            \n            break;\n        }\n        t += d * 0.5;\n        if (t > 100.0) break;\n    }\n            \n    // tone mapping\n    color = color / (color + 1.0);\n    \n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tds3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 302, 302, 401], [404, 404, 423, 423, 470], [472, 472, 499, 499, 594], [596, 596, 615, 615, 926], [928, 928, 947, 947, 1094], [1096, 1096, 1160, 1160, 1360], [1362, 1362, 1406, 1406, 1534], [1536, 1536, 1590, 1590, 1686], [1688, 1688, 1734, 1734, 1827], [1829, 1829, 1921, 1921, 2676], [2678, 2678, 2733, 2733, 5289]]}
{"id": "tds3WN", "name": "chessboard: endless zoom", "author": "morisil", "description": "moving within logarithmic perspective lis weird, looks like endless zoom", "tags": ["zoom", "endless", "loop", "checker", "perspective", "double", "chess"], "likes": 1, "viewed": 323, "published": "Public API", "date": "1546380959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 5.0\n\n#define EDGE_SHARPNESS 20000.0\n\n#define AIR_PERSPECTIVE 2.0\n\nfloat getChessboardLuminance(vec2 point) {\n    float value =\n        (1.0 - pow(sin(point.x), EDGE_SHARPNESS))\n        * sign(cos(point.x));\n    value *=\n        (1.0 - pow(sin(point.y - iTime), EDGE_SHARPNESS))\n        * sign(cos(point.y - iTime));\n    return (value + 1.0) / 2.0;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 trans = vec2(pixel.x / pixel.y, log2(abs(pixel.y)));\n    trans *= SCALE;\n    \n\tfloat luminance = getChessboardLuminance(trans);\n\n    // apply air perspective\n    luminance *= abs(pixel.y * 2.0);\n    fragColor = vec4(vec3(luminance),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tds3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 122, 122, 367], [369, 369, 424, 424, 740]]}
{"id": "tdS3Wz", "name": "shutters BW 2 (140 chars)", "author": "FabriceNeyret2", "description": "NB: the last line is optional ", "tags": ["short", "onetweet", "golf"], "likes": 2, "viewed": 262, "published": "Public API", "date": "1548590686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wsBGWz\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    int i = int(iTime); float f = fract(-iTime);\n    vec2 A = abs( 2.*u/iResolution.xy - 1. );\n    A[ i%2 ] < f ? i++, O += f : O++;\n    O *= .5 + .5* fract( A[ i % 2 ] ); } ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdS3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 86, 86, 260]]}
{"id": "tds3zf", "name": "CastingBall", "author": "Sevapp", "description": "CastingBall", "tags": ["castingball"], "likes": 1, "viewed": 78, "published": "Public", "date": "1547121079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3  ballPos;\nfloat ballRadius;\nvec4  ballColor;\n\nfloat getDist(vec3 rayPos)\n{\n    return distance(ballPos, rayPos) - ballRadius;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2  e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 outputPixel = vec4(0.0);\n    vec2 pixelPos    = fragCoord.xy;\n    \n    vec3 camPos = vec3(\n        iResolution.x / 2.0, \n        iResolution.y / 2.0, \n        -300.0\n    );\n    \n    vec3 rayPos = vec3(pixelPos, 0.0);\n    vec3 rayVec = normalize(rayPos - camPos);\n    \n    vec3 lightPos = vec3(\n        iResolution.x / 2.0 + sin(iTime) * 100.0, \n        iResolution.y / 2.0 + cos(iTime) * 100.0,\n        -100.0\n    );\n    \n    ballPos    = vec3(\n        iResolution.x / 2.0 + cos(iTime * 2.0) * 100.0, \n        iResolution.y / 2.0,\n        99.99 + sin(iTime * 2.0) * 20.0\n    );\n    \n    ballRadius = 100.0;\n    ballColor = vec4(1.0, 0.4, 1.0, 1.0);\n    \n    vec3  curRayPos = rayPos;\n    for (int i = 0; i < 40; i ++)\n    { \n    \tfloat distToBall = getDist(curRayPos);\n        if (distToBall < .1)\n        {\n            vec3  normal = getNormal(curRayPos);\n            float light  = dot(normalize(lightPos - curRayPos), normal);\n            light = clamp(light, 0.0, 1.0) + 0.02;\n            outputPixel = pow(light, 1.0 / 1.8) * ballColor;\n            break;\n            \n        } else\n        {\n        \tcurRayPos += rayVec * distToBall;\n        }\n    }\n    \n    fragColor = outputPixel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tds3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 79, 79, 132], [134, 134, 158, 158, 365], [367, 367, 424, 424, 1630]]}
{"id": "tdS3zw", "name": "Temple of Time - Variation", "author": "Flopine", "description": "This is a variation on a shader made during a twitch live session : https://www.shadertoy.com/view/td23zD \nI really like this cheap \"old school effect\" :D", "tags": ["raymarching", "zelda", "posterize"], "likes": 5, "viewed": 183, "published": "Public", "date": "1548409857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// This is a variation on this shader : https://www.shadertoy.com/view/td23zD \n// Made during a twitch live session :) \n\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n\n#define ITER 64.\n#define time (iTime*0.3)\n#define PI 3.141592\n\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat random (vec2 st)\n{return fract(sin(dot(st.xy, vec2(12.2544, 35.1571)))*5418.548416);}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    p.xz *= rot(-iTime);\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat column (vec3 p)\n{\n    float width = 5.;\n    float c1 = length(p.xz)-width;\n    \n    p.xz *= rot(p.y*0.2);\n    p.xz *= rot(iTime);\n    p.xz = moda(p.xz, PI);\n    p.x -= width;\n    float c2 = length(p.xz)-2.;\n    \n    return min(c1, c2);\n}\n\nfloat g2 = 0.;\nfloat columns (vec3 p)\n{\n\tp.xz = moda(p.xz, PI/3.);\n    p.x -= 60.;\n    float d = column(p);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat room (vec3 p)\n{\n    float g = abs(p.y+5.)-0.5;\n    float h = sdHexPrism(p.xzy, vec2(60.));\n    return min (g,-h);\n}\n\nfloat pedestal (vec3 p)\n{\n    vec3 new_p = vec3(p.x, p.z, p.y+4.);\n    float width = 15.;\n    float height = 0.2;\n    float st = 2.;\n\n    float hexs = sdHexPrism(new_p, vec2(width, height));\n\n    for (float i = 0.; i<2.; i++)\n    {\n        new_p.z -= 0.7;\n        width -= 4.+i;\n        height += 0.1+i;\n        hexs = stmin(hexs, sdHexPrism(new_p, vec2(width, height)), 1., st);\n        st++;\n    } \n    return hexs;\n}\n\nfloat g1 = 0.;\nfloat triforce (vec3 p)\n{\n    p.y -= 7.;\n    float tri1 = sdTriPrism(p, vec2(3,0.3));\n    float tri2 = sdTriPrism(vec3(p.x-2.5, p.y+4.5, p.z), vec2(3,0.3));\n    float tri3 = sdTriPrism(vec3(p.x+2.5, p.y+4.5, p.z), vec2(3,0.3));\n    float d = min(tri3,min(tri1, tri2));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    float r = stmin(room(p), columns(p), 10., 3.);\n    float hs = pedestal(p);\n    return min(triforce(p),stmin(hs, r, 0.5, 2.));\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3 (SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                          )\n                    );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec3 point_light(vec3 p, vec3 n)\n{\n    vec3 lpos = vec3(0, 8, 0);\n    vec3 ldir = normalize(lpos - p);\n    float ldist = length(lpos - p);\n    float dotNL = dot(n, ldir)*0.5+0.5;\n\treturn (vec3(.8, .8, 0) * dotNL) / (.007 * ldist * ldist);\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n    vec3 forward = normalize(target - ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross (forward, left));\n    return normalize(forward*fov+ left*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    //pixellate\n    uv = floor(uv * 100.)/100.;\n    \n    vec3 ro = vec3(-18.*cos(time),5., -18.*sin(time)); vec3 p = ro; \n    vec3 target = vec3(0.);\n    vec3 rd = get_cam(ro, target, uv, 1.);\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    float dither = random(uv);\n       \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            vec3 n = get_normals(p);\n            \n            // hemi light\n            col = mix(vec3(0.5, 0.1, 0.5), vec3(0.3, 0.8, 0.9),lighting(n, vec3(1., 10.,-2.)));\n            \n            // point light\n            col += point_light(p, n);\n            \n            // ao\n            shad = i/ITER;\n            col *= (1.- shad);\n            break;\n        }\n        d *= 0.9 + dither*0.2;\n        p += d*rd;\n    }\n    \n    float t = length(p-ro);\n\tcol += g1*vec3(1.,1.,0.)*0.8;\n    col += g2*0.1;\n    col = mix(col, vec3(0.5, 0.8, 0.9), (1.-exp(-0.002*t*t))*0.8);\n    \n    // posterize\n    col = floor(col*10.)/10.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdS3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 374, 405, 405, 531], [533, 533, 553, 553, 599], [601, 601, 625, 625, 692], [694, 694, 743, 743, 849], [851, 851, 887, 887, 999], [1001, 1001, 1037, 1037, 1320], [1322, 1322, 1345, 1345, 1565], [1582, 1582, 1606, 1606, 1715], [1717, 1717, 1738, 1738, 1838], [1840, 1840, 1865, 1865, 2259], [2276, 2276, 2301, 2301, 2585], [2587, 2587, 2607, 2607, 2739], [2741, 2741, 2768, 2768, 3023], [3025, 3025, 3058, 3058, 3095], [3097, 3097, 3131, 3131, 3337], [3339, 3339, 3396, 3396, 3604], [3606, 3606, 3663, 3713, 4873]]}
{"id": "tdsGDN", "name": "modulo waves", "author": "morisil", "description": "polar variation of my previous modulo shaders,", "tags": ["modulo", "polarcoordinates"], "likes": 1, "viewed": 554, "published": "Public API", "date": "1546387979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n#define SEGMENTS 8.0\n\n#define RINGS 5.0\n\n#define SPEED -0.3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    float x = dist * RINGS;\n    float y = angle * (SEGMENTS / 8.0);\n    float t = iTime * SPEED;\n    fragColor = vec4(\n          mod(x + mod(y + t, PI / 4.0) + y + mod(x + t, PI / 4.0), PI) / PI,\n          0,\n          mod(x + mod(y + t, PI / 2.0) + y + mod(x + t, PI / 2.0), PI) / PI,\n        1.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 142, 142, 584]]}
{"id": "tdSGR1", "name": "Ice cubes in my glass", "author": "Alkama", "description": "Made live shading style.\nUses the nice nusan_fx transparency trick he demoed on stream a few days ago :D", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 10, "viewed": 505, "published": "Public API", "date": "1548111515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t mod(iTime, 100.0)\n\nstruct Ray { vec3 o, d; };\n\nfloat rectify(float f, float b) { return b+f*b*.5; }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 v) { return max(max(v.x,v.y),v.z); }\nfloat sphere(vec3 p, float r) {return length(p)-r;}\nfloat cube(vec3 p, vec3 s, float sm) {\n  vec3 b=abs(p)-s;\n  return length(max(b,0.0) + min(vmax(b), 0.0)) - sm;\n}\nvec3 rep(vec3 p, float n) { return mod(p-vec3(n*.5), n) - .5*n; }\nfloat scene(vec3 p) {\n  p = rep(p,3.0+sin(t*.42));\n  p.xy = abs(p.xy);\n  p.xz *= rot(t*.6+p.y);\n  p.xy *= rot(t*.3);\n  float s=sphere(p,.2);\n  float c=cube(p, vec3(.5), .5);\n  return max(-s,c);\n}\n\nRay camera(vec2 uv, vec3 o, vec3 tg, float z) {\n  Ray r;\n  r.o = o;\n  vec3 f = normalize(tg-o);\n  vec3 s = normalize(cross(vec3(0,1,0), f));\n  vec3 u = cross(f,s);\n  r.d = normalize(f*z+uv.x*s+uv.y*u);\n  return r;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e=vec2(-0.001, 0.001);\n  return normalize(e.xyy*scene(p+e.xyy) + e.yxy*scene(p+e.yxy) + e.yyx*scene(p+e.yyx) + e.xxx*scene(p+e.xxx));\n}\n\nvec3 shade(vec3 p) {\n  vec3 l=normalize(vec3(sin(t*.9), 2, cos(t)));\n  vec3 n=normal(p);\n  return vec3(max(0.0,dot(l, n)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv /= 1.0-length(uv)*1.5;\n  //uv.x = abs(uv.x);\n  vec3 eye = vec3(1,3,-2);\n  eye.xz += 4.0*vec2(sin(t*.2),cos(t*.2));\n  vec3 target = vec3(0);\n  target.xy += 2.0*vec2(cos(t*.2),sin(t*.2));\n\n  Ray r = camera(uv, eye, target, .2+.1*sin(t*2.0));\n  vec3 col = vec3(0);\n\n  // lets try nusan's transparency trick\n  vec3 p = r.o;\n  float d=0.0;\n  float acc=.27;\n  int bbb=0;\n  float side=sign(scene(p));\n  for(int i=0; i<200; i++) {\n    float h=scene(p)*side*.92;\n    if(h<0.00001) {\n      bbb++;\n      vec3 n=normal(p)*side;\n      col += 1.*shade(p)+acc*vec3(-.1,0.1,.2+.1*cos(t));\n      side=-side;\n      acc *= .84;\n      h = 0.001;\n      r.d = refract(r.d, n, 1.0+.025*side);\n    }\n    p+=r.d*h;\n    d+=h;\n  }\n  col /= float(bbb);\n  fragColor = vec4(pow(col, vec3(1.1/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 90, 90, 109], [110, 110, 129, 129, 174], [175, 175, 195, 195, 227], [228, 228, 259, 259, 279], [280, 280, 318, 318, 393], [394, 394, 421, 421, 459], [460, 460, 481, 481, 655], [657, 657, 704, 704, 872], [874, 874, 895, 895, 1038], [1040, 1040, 1060, 1060, 1165], [1167, 1167, 1224, 1224, 2142]]}
{"id": "tdsGRS", "name": "Voronoi Circular Pattern", "author": "Passion", "description": "black n white click for grid and voronoin border", "tags": ["2d", "voronoin"], "likes": 6, "viewed": 169, "published": "Public", "date": "1546745559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n#define TWO_PI PI*2.\n\nmat2 r2(float a){\n    float s =sin(a);\n    float c = cos(a);\n    return mat2(s,c,-c,s);\n}\n\nvec2 rnd(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.12, 256.45, 359.88));\n    a += dot(a, a+47.88);\n    return fract(vec2(a.x*a.y, a.z*a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float t =iTime;\n\tuv *= 1.+dot(uv,uv)*.0911275;\n      \n    uv *= 4.+sin(t/2.);\n    uv+=vec2(sin(t),cos(t));\n    uv*=r2(sin(t/3.)*.5)*1.12;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float minDist = 100.;\n    vec2 cid = vec2(0);\n    for(int y = -1; y<1; y++){\n        for(int x =-1; x<1; x++){\n            vec2 offset = vec2(x, y);\n            vec2 rand = rnd(id + offset);\n            \n            vec2 point = offset + sin(rand*iTime)*.5+.5;\n            \n            point-=gv;\n            point*=r2(cid.x-t);\n            float d = length(point);\n            float md = abs(point.x)+abs(point.y);\n            \n            float dst = mix(d,md,sin(rnd(cid).x+rnd(cid).y));\n            \n            if(d<minDist){\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0); \n    \n    float c = length(minDist)-.3;\n    \n    float grd = step(.46,gv.x)+step(.46,gv.y);   \n    fragColor =  vec4(smoothstep(0.05,0.03, c*sin(3.*t-c*22.+sin(t-rnd(cid).x*12.))));   // vec4(minDist);\n    if(iMouse.z>0.0){\n        fragColor +=vec4(cos(rnd(cid)*4.).xyxy);\n        fragColor.r += grd;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 60, 60, 132], [134, 134, 151, 151, 277], [279, 279, 336, 336, 1612]]}
{"id": "tdsGRX", "name": "Braid Variation", "author": "yx", "description": "variation on https://www.shadertoy.com/view/Wds3zf", "tags": ["braid"], "likes": 12, "viewed": 442, "published": "Public API", "date": "1547077313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c - a.y*s,\n        a.x*s + a.y*c\n    );\n}\n\nfloat sdbox2d(vec2 p, float r)\n{\n    p=abs(p);\n    return max(p.x,p.y)-r;\n}\n\nvec2 boffset(vec2 p, float t)\n{\n    t*=pi*2.;\n    return rotate(p+vec2(\n        cos(t)*2.,\n        -sin(t*3.)\n    )*.15, sin(t)*(pi*2./3.));\n}\n\nfloat tick(float t)\n{\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    return t;\n}\n\nfloat pattern(float t)\n{\n    t=fract(t);\n    return clamp(abs(t-.5)*-16.+7.5,-1.,1.)+1.;\n    return tick(abs(t-.5)*2.);\n}\n\nfloat scene2(vec2 p, float angle)\n{\n    float time = ((angle/tau)/5.)*4.+iTime*.25;\n\n    float q = iTime+angle;\n\n    float r = .02 + pattern((angle/tau)*30.)*.02;\n\n    float a = sdbox2d(boffset(p,time),r);\n    float b = sdbox2d(boffset(p,time+1./5.),r);\n    float c = sdbox2d(boffset(p,time+2./5.),r);\n    float d = sdbox2d(boffset(p,time+3./5.),r);\n    float e = sdbox2d(boffset(p,time+4./5.),r);\n    return min(min(min(a,b),min(c,d)),e);\n}\n\nfloat scene(vec3 p)\n{\n    p.xz = mod(p.xz+2.,4.)-2.;\n\n    float angle = atan(p.x,p.z);\n\n    float q = .75;\n\n    p.y += (angle/tau)*(q+q);\n\n    p.y = mod(p.y+q,(q+q))-q;\n\n    vec2 a = vec2(length(p.xz)-1., p.y);\n\n    return scene2(a, angle);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 1.+length(uv)*.3;\n    \n    uv = abs(uv);\n    uv=vec2(max(uv.x,uv.y),min(uv.x,uv.y)).yx;\n    uv *= 2.5;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv, 2.5));\n\n    cam.yz = rotate(cam.yz, pi/5.);\n    dir.yz = rotate(dir.yz, pi/5.);\n\n    cam.xz = rotate(cam.xz, pi/4.);\n    dir.xz = rotate(dir.xz, pi/4.);\n\n    cam.y += iTime;\n\n    float t =0.;\n    float k = 0.;\n    int iter=0;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t)*.7;\n        t+=k;\n        iter=i;\n        if (k < .001)break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.002,0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n\n    if (k < .001)\n    {\n        float iterFog = 1.-float(iter)/100.;\n        iterFog = pow(iterFog, 3.);\n        float light = max(n.y,0.);\n        out_color.rgb += mix(vec3(.01,.01,.1), vec3(.1,.5,.5), iterFog);\n        out_color.rgb += mix(vec3(0.), vec3(sin(iTime),sin(iTime+2.),sin(iTime+4.))+1., light*iterFog);\n    }\n    else\n    {\n        out_color *= 0.;\n    }\n\n    out_color.rgb = vec3(pow(length(out_color.rgb)/sqrt(3.),2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 72, 72, 187], [189, 189, 221, 221, 264], [266, 266, 297, 297, 408], [410, 410, 431, 431, 563], [565, 565, 589, 589, 686], [688, 688, 723, 723, 1129], [1131, 1131, 1152, 1152, 1373], [1375, 1375, 1427, 1427, 2688]]}
{"id": "tdsGWX", "name": "planetoid /w satellite", "author": "chadams", "description": "ray marching test\n\nupdate: atmosphere shadow\nupdate: atmosphere on planetoid\nupdate: smoothed shadows, sandy planetoid lowlands, colorization\nupdate: code cleanup etc\nupdate: rotating & zooming camera, fine tuned ray marching", "tags": ["raymarching", "planet", "asteroid"], "likes": 10, "viewed": 317, "published": "Public", "date": "1547694718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n// Soft shadow implementation based on: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// 3D simplex noise from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 (by Ian McEwan)\n// Arbitraty axis rotation from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/ (blarg)\n\n\n/////// -- simplex noise start\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return (42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                   dot(p2,x2), dot(p3,x3) ) )) * 0.5 + 0.5;\n}\n\n\n////// -- simplex noise end / abritrary rotation axis start\n\n\nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n\n////// -- abritrary rotation axis end / ray<->sphere intersect start\n\n\nvec2 raySphere(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float test = b*b - 4.0*a*c;\n    if (test < 0.0) {\n        return vec2(-1.0, -1.0);\n    }\n    test = sqrt(test);\n    float X = (-b - test)/(2.0*a);\n    float Y = (-b + test)/(2.0*a);\n    return vec2(\n        min(X, Y),\n        max(X, Y)\n    );\n}\n\n\n////// -- ray<->sphere intersect end / main start\n\n\n\n// Planetoid terrain functions\nfloat planetHeightHD(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*2.5 + pseed * 1234.1) * 0.5 +\n        snoise(n*2.5*2. + pseed * 1234.1) * 0.25 +\n        snoise(n*2.5*4. + pseed * 1234.1) * 0.125 +\n        snoise(n*2.5*8. + pseed * 1234.1) * 0.125*0.5 +\n        snoise(n*2.5*16. + pseed * 1234.1) * 0.125*0.25;\n}\n\nfloat planetHeightHDS(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*1.5 + pseed * 1234.1) * 0.85,\n        snoise(n*2.5 + pseed * 1234.1) * 0.15;\n}\n\nvec3 clrPlanetHD(vec3 p, vec3 pc, vec3 pseed, mat3 rot) {\n    vec3 n = normalize(rot * (p - pc));\n    float ph = planetHeightHD(n, pseed);\n    float t = pow(ph, 1.5);\n    float t2 = pow((1. - ph) * 1.5, 2.0);\n    return mix(\n        mix(\n        \tvec3(0.3, 0.3, 0.3),\n            vec3(1., 1., 1.),\n            t2\n        ),\n    \tvec3(1., 1., .7) * (0.25 + pow(snoise(n*2.5*1. + pseed * 11234.1), 0.2) * 0.75),\n        t\n   \t);\n}\n\nfloat distPlanetHD(vec3 p, vec3 pc, float pr, vec3 pseed, float hd, mat3 rot) {\n    \n    // Start with sphere\n    float d0 = length(p - pc);\n    // Offset by layered simplex noise\n    float ph = planetHeightHD(normalize(rot * (p - pc)), pseed);\n    float phs = planetHeightHDS(normalize(rot * (p - pc)), pseed);\n    float r = pr - pr * hd * mix(ph, phs * 3.5, pow(ph, 1.5));\n    \n    return d0 - r;\n    \n}\n\n// Satellite terrain functions\nfloat planetHeight(vec3 n, vec3 pseed) {\n\treturn \n        snoise(n*0.5 + pseed * 1234.1) +\n        snoise(n*0.5*4. + pseed * 1234.1) * 0.25 +\n        snoise(n*0.5*16. + pseed * 1234.1) * 0.125 * 0.5;\n}\n\nfloat distPlanet(vec3 p, vec3 pc, float pr, vec3 pseed, float hd, mat3 rot) {\n    \n    float d0 = length(p - pc);\n    float r = pr + pr * hd * planetHeight(normalize(rot * (p - pc)), pseed);\n    \n    return d0 - r;    \n    \n}\n\n// Scene function\nfloat getDist(vec3 p) {\n    \n    // Planetoid self rotation\n    mat3 p1r = rotAxis(normalize(vec3(.5, -.2, 1.)), iTime * 0.1);\n    // Orbital rotation\n    mat3 p1r2 = rotAxis(normalize(vec3(-1, -.1, 0.05)), -iTime * 0.2);\n    // Satellite self rotation\n    mat3 p2r = rotAxis(normalize(vec3(.1, .5, -1.)), -iTime * 0.5);\n    \n    return min(\n\t    distPlanetHD(p, vec3(0., 0., 0.), 5., vec3(.4315, .3415, .141561), 0.1, p1r),\n        distPlanet(p, p1r2 * vec3(1., 3., 7.) * 1., 0.5, vec3(.1315, .7615, .5341561), 1., p2r)\n    );\n    \n}\n\nvec3 getClr(vec3 p) {\n    vec3 clr = vec3(0.75, 0.75, 0.75);\n    mat3 p1r = rotAxis(normalize(vec3(.5, -.2, 1.)), iTime * 0.1);\n    float dp = distPlanetHD(p, vec3(0., 0., 0.), 5., vec3(.4315, .3415, .141561), 0.1, p1r);\n    if (dp < (1e-3)) {\n        return clrPlanetHD(p, vec3(0., 0., 0.), vec3(.4315, .3415, .141561), p1r);\n    }\n    return clr;\n}\n\n// Raymarching implementation\n#define MAX_ITERATIONS 256\n#define FAR_CLIP 60.\n#define MIN_DIST (1e-3)\n\nfloat rayMarch(vec3 r0, vec3 rd) {\n    float ds = 0.;\n    for (int i=0; i<MAX_ITERATIONS; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < MIN_DIST) {\n            return ds;\n        }\n        if (ds >= FAR_CLIP) {\n            break;\n        }\n    }\n    return FAR_CLIP;\n}\n\n// Lighting functions\n#define LIGHT vec3(0., 15., -1.)\n#define SHADOW_STRENGTH 0.8\n#define AMBIENT_LIGHT 0.01\n#define SURFACE_DIST 0.02\n#define NORMAL_SAMPLE_DIST (1e-3)\n#define SHADOW_ITERATIONS 32\n#define SHADOW_MIN_DIST (1e-4)\n#define SHADOW_SHARPNESS 2.25\n\nfloat shadowRay(vec3 r0, vec3 rd, float maxDist) {\n    float ds = 0.;\n    float ret = 1.;\n    for (int i=0; i<SHADOW_ITERATIONS && ds < maxDist; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < SHADOW_MIN_DIST) {\n            return 0.0;\n        }\n        ret = min(ret, SHADOW_STRENGTH * dist/ds);\n    }\n    return pow(ret, 1.0 / SHADOW_SHARPNESS);\n}\n\nfloat shadowRayLD(vec3 r0, vec3 rd, float maxDist) {\n    float ds = 0.;\n    float ret = 1.;\n    for (int i=0; i<16 && ds < maxDist; i++) {\n        vec3 p = r0 + rd * ds;\n        float dist = getDist(p);\n        ds += dist;\n        if (dist < (0.5 * 1e-1)) {\n            return 0.0;\n        }\n        ret = min(ret, SHADOW_STRENGTH * dist/ds);\n    }\n    return pow(ret, 1.0 / 2.);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 eps = vec2(NORMAL_SAMPLE_DIST, 0.);\n    return normalize(\n        getDist(p) - vec3(\n            getDist(p - eps.xyy),\n            getDist(p - eps.yxy),\n            getDist(p - eps.yyx)\n        )\n    );\n}\n\nfloat getLight(vec3 n, vec3 p) {\n       \n    vec3 ld = normalize(LIGHT - p);\n    \n    // Apply defuse lighting\n    float l = clamp(dot(n, ld), 0., 1.) * (1. - AMBIENT_LIGHT) + AMBIENT_LIGHT;\n      \n    return l;\n}\n\nfloat getShading(vec3 n, vec3 p) {\n\n    vec3 ld = normalize(LIGHT - p);\n    return shadowRay(p + n*SURFACE_DIST, ld, length(LIGHT - p)-SURFACE_DIST);\n\n}\n\nfloat getShadingLD(vec3 n, vec3 p) {\n\n    vec3 ld = normalize(LIGHT - p);\n    return shadowRayLD(p + n, ld, length(LIGHT - p)-1.0);\n\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Translate viewport\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvx1 = ((fragCoord-vec2(2., 0.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvx2 = ((fragCoord+vec2(2., 0.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvy1 = ((fragCoord-vec2(0., 2.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n    vec2 uvy2 = ((fragCoord+vec2(0., 2.))/iResolution.xy - vec2(0.5, 0.5)) * vec2(1., iResolution.y / iResolution.x);\n\n    // Animate camera and compute camera ray\n    mat3 crot = rotAxis(vec3(0., 1., 0.), iTime * 0.15);\n    vec3 r0 = vec3(0., 0., -40. + (sin(iTime * 0.25) * 0.5 + 0.5) * 15.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    r0 = crot * r0;\n    rd = normalize(crot * rd);\n    \n    vec3 rdx1 = normalize(crot * normalize(vec3(uvx1, 1.)));\n    vec3 rdx2 = normalize(crot * normalize(vec3(uvx2, 1.)));\n    vec3 rdy1 = normalize(crot * normalize(vec3(uvy1, 1.)));\n    vec3 rdy2 = normalize(crot * normalize(vec3(uvy2, 1.)));\n    \n    // Render fragment\n    float id = rayMarch(r0, rd);\n    vec3 rp = r0 + rd * id;\n    vec3 n = getNormal(rp);\n    float shadow = getShading(n, rp);\n    float light = getLight(n, rp) * shadow;\n    if (id < (FAR_CLIP-(1e-6))) {\n    \tfragColor = vec4(getClr(rp) * light, 1.0);\n    }\n    else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n    \n    // Atmosphere\n    vec2 rsi = raySphere(r0, rd, vec3(0., 0., 0.), 5.75);\n    if (rsi.x > 0.) {\n        rsi.y = min(rsi.y, id);\n        vec3 rp2 = r0 + rd * (rsi.x+rsi.y) * 0.5;\n        float ashadow = 0.35 + 0.65 * getShadingLD(n, rp2);\n        float astr = max(rsi.y - rsi.x, 0.) / 11.5 * max(dot(normalize(LIGHT), normalize(rp2)), 0.0);\n        fragColor.rgb += vec3(1., 1., 0.8) * ashadow * pow(astr, 2.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 420, 441, 441, 478], [479, 479, 506, 506, 554], [556, 556, 577, 577, 2308], [2311, 2373, 2407, 2407, 2619], [2622, 2693, 2746, 2746, 3129], [3185, 3216, 3258, 3258, 3532], [3534, 3534, 3577, 3577, 3682], [3684, 3684, 3741, 3741, 4112], [4114, 4114, 4193, 4223, 4519], [4521, 4552, 4592, 4592, 4753], [4755, 4755, 4832, 4832, 4980], [4982, 5000, 5023, 5059, 5534], [5536, 5536, 5557, 5557, 5886], [5888, 5991, 6025, 6025, 6323], [6325, 6586, 6636, 6636, 6997], [6999, 6999, 7051, 7051, 7380], [7382, 7382, 7406, 7406, 7620], [7622, 7622, 7654, 7654, 7835], [7837, 7837, 7871, 7871, 7989], [7991, 7991, 8027, 8027, 8125], [8128, 8136, 8193, 8219, 10085]]}
{"id": "tdXGD7", "name": "ok so basically", "author": "ruko", "description": "monky", "tags": ["im"], "likes": 0, "viewed": 59, "published": "Public", "date": "1546600305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p) {\n    p += vec3(sin(iTime), 0., cos(iTime) - 1.0);\n    return length(p) - 1.;\n}\n\nfloat ground(vec3 p) {\n    return p.y + 1.5;\n}\n\nfloat ceiling(vec3 p) {\n    return -p.y + 1.5;\n}\n\nfloat walls(vec3 p) {\n    return min(-p.z + 3.0, \n               min(p.x + 3.0, -p.x + 3.0));\n}\n\nfloat creature (vec3 p) {\n    p += vec3(2.*sin(iTime/3.), 0.5*sin(iTime/3.01), cos(iTime/3.) - 1.0);\n    p.x += 0.1*sin(p.y*2.0+iTime);\n    p.z += 0.1*cos(p.y*2.0+iTime);\n    return length(p) - 1.0;\n}\n\nfloat f(vec3 p) {\n    return \n        min(creature(p), \n            min(ground(p),\n               min(ceiling(p),\n                  walls(p))));\n}\n\nfloat raymarch(vec3 o, vec3 d) {\n    vec3 p = o;\n    int count = 0;\n    while (abs(f(p)) > 0.001 && count < 160) {\n        p += f(p) * d;\n        count++;\n    }\n    return length(o - p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2(fragCoord.x - 0.5 * iResolution.x, fragCoord.y - 0.5 * iResolution.y);\n    uv /= iResolution.y;\n    \n    mat3 maty = mat3(\n        cos(iTime), 0, -sin(iTime),\n        0, 1, 0,\n        sin(iTime), 0, cos(iTime));\n    \n    mat3 matx = mat3(\n        1, 0, 0, \n        0, cos(iTime), sin(iTime),\n        0, -sin(iTime), cos(iTime));\n    \n    mat3 matz = mat3(\n        cos(iTime), sin(iTime), 0,\n        -sin(iTime), cos(iTime), 0,\n        0, 0, 1);\n    \n    vec3 start = vec3(uv.x/10., uv.y/10., 0.);\n    if (mod(iTime+3.14, 4.*3.14) < 6.28) {\n        start.z -= 3.;\n    } else {\n        start.z -= 3.;\n    }\n    vec3 dir = normalize(vec3(uv.x/1., uv.y/1., 1.));\n    \n    float dist = raymarch(start, dir);\n    vec3 hit = start + dist * dir;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1. - raymarch(start, dir)/10.);\n    \n    if (abs(hit.y) < 1.49 && abs(hit.z) < 2.99 && abs(hit.x) < 2.99) {\n        col = vec3(float(\n            (int(abs(hit.z*10.)) % 2)));\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 100], [102, 102, 124, 124, 148], [150, 150, 173, 173, 198], [200, 200, 221, 221, 295], [297, 297, 322, 322, 497], [499, 499, 516, 516, 645], [647, 647, 679, 679, 835], [837, 837, 894, 944, 2005]]}
{"id": "ts23Rh", "name": "3D objects", "author": "yashgugale", "description": "3D distance fuctions.", "tags": ["3ddistancefunctions"], "likes": 1, "viewed": 112, "published": "Public", "date": "1548187950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plane:\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n\n// Torus:\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// Ellipsoid:\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\n\n// Capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// Round Cone:\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Union, Subtraction, Intersection:\n//Union:\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n// Subtraction:\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection:\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n// Round box:\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n// Sphere:\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n    \n    float an = sin(iTime);\n\n    // opUnion\n    {\n    vec3 q = pos - vec3(-2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opUnion(d1,d2);\n    d = min( d, dt );\n  \t}\n\n    // opSubtraction\n    {\n    vec3 q = pos - vec3(0.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opSubtraction(d1,d2);\n    d = min( d, dt );\n    }\n\n    // opIntersection\n    {\n    vec3 q = pos - vec3(2.0,0.0,-1.3);\n    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n    float dt = opIntersection(d1,d2);\n    d = min( d, dt );\n    }\n    \n\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    //vec3 sphere = vec3(uv, 0.3);\n    //float d1 = sdSphere(sphere, 0.4);\n    //float r = length( uv )*1.9;\n    \n    //vec3 col = mix( vec3(0.6, 0.0, 0.5), vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec3 tot = vec3(0.0);\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n\n    }\n    tot /= float(AA*AA);\n\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts23Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 35, 35, 50], [54, 64, 97, 97, 152], [154, 168, 227, 227, 321], [324, 335, 387, 387, 501], [503, 518, 582, 582, 860], [862, 980, 1017, 1017, 1042], [1043, 1059, 1102, 1102, 1128], [1130, 1147, 1191, 1191, 1216], [1217, 1231, 1286, 1286, 1381], [1383, 1394, 1429, 1429, 1455], [1457, 1457, 1481, 1481, 2298], [2300, 2364, 2396, 2396, 2630], [2632, 2694, 2781, 2781, 3039], [3055, 3055, 3112, 3519, 4635]]}
{"id": "ts23RW", "name": "Warped Value Noise (fbm)", "author": "Elyxian", "description": "Based on the warping functions from IQ (https://www.shadertoy.com/view/lsl3RH) with inspiration from Dave Hoskins (https://www.shadertoy.com/view/MlSXDm)\n", "tags": ["noise", "warp", "dirt", "camo", "camoflauge"], "likes": 4, "viewed": 109, "published": "Public", "date": "1548398184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    float hashScale = 0.1031;\n\tvec3 p3  = fract(vec3(p.xyx) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec2 add = vec2(1.0,0.0);\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p), hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n// Noise functions and warping methods inspired and modified from https://www.shadertoy.com/view/lsl3RH\n\nconst float angle = 0.2;\nconst float scale = 3.24;\nconst mat2 m = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * scale;\n\nfloat fbm4( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p ) {\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec3 warpedNoise(in vec2 q) {\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5*fbm6(vec2(2.0*q));\n    o.y = 0.5*fbm6(vec2(2.0*q));\n    \n    vec2 n = vec2(0.0);\n    n.x = fbm6(vec2(7.0*o+vec2(19.2)));\n    n.y = fbm6(vec2(7.0*o+vec2(15.7)));\n\n    vec2 p = 4.0*q + 4.0*n;\n    \n    float f = 0.5 + 0.5 * fbm4(p);\n    \n    // Rendering the value in different ways\n    float time = mod(iTime - 13.0, 4.0 * 4.0);\n    \n    // Option 1: Grayscale rendering\n    if (time < 4.0) {\n    \treturn 0.8 * vec3(f);\n    }\n    \n    // Option 2: Rendering with steps\n    if (time < 8.0) {\n    \tfloat steps = 10.0;\n    \treturn 0.8 * vec3(floor(f * steps) / steps);\n    }\n    \n    // Option 3: Dirt-like Colours\n    if (time < 12.0) {\n    \tfloat steps = 10.0;\n    \tfloat val = floor(f * steps) / steps;\n        val = min(max(val, 0.6), 0.8);\n    \treturn 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(val*1583343.0));\n    }\n        \n    // Option 4: Camo-like Colours\n    else {\n    \tfloat steps = 10.0;\n    \tfloat val = floor(f * steps) / steps;\n        val = min(max(val, 0.6), 0.8);\n    \treturn 0.25 + 0.15*sin(vec3(0.05,0.08,0.10)*(val*1234.1));\n    }\n        \n    // Option 5: Time-based Colours (unused)\n    //float steps = 10.0;\n    //float val = floor(f * steps) / steps;\n    // Color function from iq: https://www.shadertoy.com/view/Xds3zN\n    //return 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(val*iTime*10.0));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    p += vec2(0.0, iTime / 15.0);\n    \n    vec3 col = warpedNoise(p * 2.3);\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts23RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 96, 96, 247], [281, 281, 307, 307, 537], [539, 774, 796, 796, 977], [979, 979, 1001, 1001, 1329], [1331, 1331, 1360, 1360, 2706], [2708, 2708, 2765, 2765, 2997]]}
{"id": "ts2GDD", "name": "Infinite Tetration", "author": "YsmrRy", "description": "a^a^a^a^a^a^a^...\n\nConvergence and divergence of infinite tetration on Gauss plane. (the coordinate corresponds to a)\nbibliography:\n(1) https://www.ajimatics.com/entry/2018/12/01/070000\n(2) http://paulbourke.net/fractals/tetration/", "tags": ["fractal"], "likes": 3, "viewed": 150, "published": "Public", "date": "1548953972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float iter = 256.0;\nconst float cx = -1.0, cy = 0.0;\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*3.14159265358979/2.0 : atan(y, x);\n}\n\nfloat f( float x ) {\n\treturn x*x;    \n}\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float x = ((uv.x-0.5)*3.0-cx)*(1.0/f(iTime))+cx, y = (uv.y*3.0-cy)*(1.0/f(iTime))+cy;\n    float r = sqrt(x*x+y*y), theta = atan2(y,x);\n    float itrX = x, itrY = y;\n    float a = 3.0;\n    \n    float i;\n    for( i = 0.0; i < iter; ++i )\n    {\n        float tmpX = itrX, tmpY = itrY;\n        \n        itrX = pow(r,tmpX)*exp(-tmpY*theta)*cos(tmpY+tmpX*theta);\n        itrY = pow(r,tmpX)*exp(-tmpY*theta)*sin(tmpY+tmpX*theta);\n       \n        if( length(vec2(itrX-x,itrY-y)) > 30.0 )\n        \tbreak;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3((10.0*i)/iter),1.0);\n    //fragColor = vec4(vec3(1.0-length(vec2(itrX-x,itrY-y))/10000.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2GDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 96, 96, 163], [165, 165, 185, 185, 204], [206, 206, 242, 242, 421], [423, 423, 480, 530, 1249]]}
{"id": "tsBGD1", "name": "maGma", "author": "nabehide", "description": "Music: https://soundcloud.com/nabehide/mdppw\nYoutube: https://youtu.be/iWTq2pKvlxs", "tags": ["loop"], "likes": 10, "viewed": 357, "published": "Public API", "date": "1548768771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nconst int NRow = 10;\nconst int NCol = 10;\nconst float period = 100.;\n\nconst float X_MAX = 0.9;\nconst float X_MIN = -0.9;\nconst float Y_MAX = 0.9;\nconst float Y_MIN = -0.9;\nconst int NOrb = 3;\nconst float speed = 0.5;\n\n/*\nconst vec3 color1 = vec3(0.05, 1.00, 0.80);\nconst vec3 color2 = vec3(0.80, 1.00, 0.05);\nconst vec3 color3 = vec3(0.05, 1.00, 0.05);\n*/\nconst vec3 color1 = vec3(1.00, 0.01, 0.01);\nconst vec3 color2 = vec3(1.00, 0.01, 0.01);\nconst vec3 color3 = vec3(1.00, 0.01, 0.01);\n\nmat2 rot(float t){\n    return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nfloat rand(vec2 co){                                             \n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat loopNoise(float s, float o, float period){\n    float i = floor(s);\n    float f = fract(s);\n    float u = f * f * (3. - 2. * f);\n    \n    float s1 = rand(vec2(i/100., i*o/100.));\n    float s2;\n    if(s < period - 1.){\n        s2 = rand(vec2((i+1.)/100., (i+1.)*o/100.));\n    } else {\n        s2 = rand(vec2(0.,0.));\n    }\n    \n    return mix(s1, s2, u);\n}\n\nfloat circle(vec2 p) {\n    return 0.05/pow(length(p), 1.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p *= 0.7;\n\n    vec3 draw = vec3(0.);\n\n    float m_dist = 3.;\n    for (int i=0; i<NRow; i++) {\n        for (int j=0; j<NCol; j++) {\n            float tx = mod(time*speed+rand(vec2(float(i),float(j))*period), period);\n            float ty = mod(time*speed+rand(vec2(float(j),float(i))*period), period);\n            float dx = loopNoise(tx, float(i*NRow+j), period)*0.2-0.1;\n            float dy = loopNoise(ty, float(j*NRow+i), period)*0.2-0.1;\n            float x = 2./float(NRow-1)*float(i)-1. + dx;\n            float y = 2./float(NCol-1)*float(j)-1. + dy;\n        \tfloat dist = distance(p, vec2(x, y));\n        \tm_dist = min(m_dist, dist);\n        }\n    }\n    \n    vec3 orbs = vec3(0.);\n    for (int i=0; i<NOrb; i++) {\n        vec3 color;\n        if (i == 0) {\n            color = color1;\n        } else if (i == 1) {\n            color = color2;\n        } else {\n            color = color3;\n        }\n        orbs += circle(p-vec2(\n            loopNoise(mod((time*speed+rand(vec2(float(i),1.)*period)),period),float(i)+0.1,period)*(X_MAX-X_MIN)+X_MIN,\n            loopNoise(mod((time*speed+rand(vec2(float(i),2.)*period)),period),float(i)+0.2,period)*(Y_MAX-Y_MIN)+Y_MIN\n        )) * color;\n    }\n    float f = textureLod( iChannel0, p/256.0, 0.0 ).x;\n    draw += pow(m_dist*(6.+f),3.) * orbs;\n   \n    fragColor = vec4(draw,1.0);\n}", "image_inputs": [{"id": "MtlGDr", "previewfilepath": "https://soundcloud.com/nabehide/mdppw", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nabehide/mdppw", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 509, 527, 527, 576], [577, 577, 597, 597, 710], [711, 711, 759, 759, 1071], [1073, 1073, 1095, 1095, 1134], [1136, 1136, 1193, 1193, 2615]]}
{"id": "tsf3Rs", "name": "limbs 2", "author": "mds2", "description": "modification of https://www.shadertoy.com/view/wssGRX with slightly better smoothed edges, and fewer limbs", "tags": ["sdf", "animation", "tree", "subsurface", "skin"], "likes": 2, "viewed": 184, "published": "Public", "date": "1547179595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_DIST 4.0\n\n\n mat3 mat_a = mat3(0.8, 0.6, 0.0,\n                        -0.6, 0.8, 0.0,\n                        0.0, 0.0, 1.0) * mat3(0.96, 0.0, 0.28, 0.0, 1.0, 0.0, -0.28, 0.0, 0.96);\n\n mat3 mat_b = mat3(0.96, 0.0, -0.28, 0.0, 1.0, 0.0, 0.28, 0.0, 0.96) *\n    mat3(0.6, -0.8, 0.0,\n         0.8, 0.6, 0.0,\n         0.0, 0.0, 1.0);\n\n mat3 mat_c = mat3(0.8, 0.0, -0.6, 0.0, 1.0, 0.0, 0.6, 0.0, 0.8) *\n    mat3(1.0, 0.0, 0.0,\n         0.0, 0.96, -0.28,\n         0.0, 0.28, 0.96);\n\nconst float cutoff = 0.81; // ad-hoc, should be much larger\n\nfloat pill(in vec3 pt, in float l, in float r) {\n    vec3 to_core = abs(pt - vec3(0.0, 0.5 * l, 0.0));\n    to_core.y -= 0.5 * l;\n    to_core = max(vec3(0.0), to_core);\n    return length(to_core) - 2.0 * r;\n}\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\n\nfloat sdf_3(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    return d;\n}\n\n\nfloat sdf_2(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    // d = s_min(d, 0.8 * sdf_3(1.25 * mat_a * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_3(1.25 * mat_b * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_3(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nfloat sdf_1(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025);\n    d = s_min(d, 0.8 * sdf_2(1.25 * mat_a * (pt - off)), 0.025);\n    // d = s_min(d, 0.8 * sdf_2(1.25 * mat_b * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_2(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nfloat sdf(in vec3 pt) {\n    vec3 off = vec3(0.0, 0.25, 0.0);\n    if (dot(pt-off, pt-off) > cutoff) {\n        return length(pt-off);\n    }\n    float d = pill(pt, 0.25, 0.025); // temporary sdf\n    d = s_min(d, 0.8 * sdf_1(1.25 * mat_a * (pt - off)), 0.025);\n    d = s_min(d, 0.8 * sdf_1(1.25 * mat_b * (pt - off)), 0.025);\n    // d = s_min(d, 0.8 * sdf_1(1.25 * mat_c * (pt - off)), 0.025);\n    return d;\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return h_inv *\n        vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n             sdf(pt + vec3(0.0, h, 0.0)) - f,\n             sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 128; ++i) {\n        if (accum > MAX_DIST || s < 1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * s;\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s > 1.0e-3) {\n        return MAX_DIST + 1.0;\n    }\n    return accum;\n}\n\nfloat raymarch_out(in vec3 pt, in vec3 dir) {\n    vec3 d = normalize(dir);\n    vec3 p = pt;\n    float accum = 0.0;\n    float s = sdf(pt);\n    for(int i = 0; i < 2; ++i) {\n        if (accum > 1.0e-3 && s > -1.0e-3) {\n            return accum;\n        }\n        accum += 0.75 * max(abs(s), 1.0e-3);\n        p = pt + accum * d;\n        s = sdf(p);\n    }\n    if (s < -1.0e-3) {\n        return 1000.0;\n    }\n    return accum;\n}\n\nfloat ramp(in float a, in float b, in float x) {\n    float p = (x-a)/(b-a);\n    return clamp(p, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 6.0));\n    \n    vec3 orig = vec3(0.0, 0.25, -2.5);\n    \n    float theta = 0.1 * iTime;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    mat3 spin = mat3(ct, 0.0, st,\n                     0.0, 1.0, 0.0,\n                     -st, 0.0, ct);\n    \n    theta = 0.25 * sin(iTime);\n    vec2 trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    mat_a =\n\t    mat3(ct, st, 0.0,\n                        -st, ct, 0.0,\n                        0.0, 0.0, 1.0) * mat3(0.96, 0.0, 0.28, 0.0, 1.0, 0.0, -0.28, 0.0, 0.96);\n\ttheta = 0.25 * sin(1.21 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.6 * trigs.x - 0.8 * trigs.y;\n    st = 0.8 * trigs.x + 0.6 * trigs.y;\n    \n    mat_b = \n        mat3(0.96, 0.0, -0.28, 0.0, 1.0, 0.0, 0.28, 0.0, 0.96) *\n    mat3(ct, -st, 0.0,\n         st, ct, 0.0,\n         0.0, 0.0, 1.0);\n    \n    theta = 0.25 * sin(0.93 * iTime);\n    trigs = cos(vec2(theta, theta + 0.5 * 3.141592654));\n    ct = 0.8 * trigs.x - 0.6 * trigs.y;\n    st = 0.6 * trigs.x + 0.8 * trigs.y;\n    \n    mat_c = mat3(ct, 0.0, -st, 0.0, 1.0, 0.0, st, 0.0, ct) *\n    mat3(1.0, 0.0, 0.0,\n         0.0, 0.96, -0.28,\n         0.0, 0.28, 0.96);\n    orig = spin * orig;\n    dir = spin * dir;\n    \n    float dist = raymarch(orig, dir);\n    \n    float bright = 0.0;\n    \n    vec3 refl_color = vec3(1.0);\n    vec3 trans_color = vec3(1.0, 0.5, 0.4);\n    const vec3 light_dir = vec3(1.0, 0.0, 0.0);\n    float thru_dist = 1000.0;\n    vec3 n = dir;\n    if (dist < MAX_DIST) {\n        n = normalize(sdf_grad(orig + dir * dist));\n//        float inc \n        // bright = smoothstep(0.0, 0.2, abs(dot(dir, n)));\n        float dist_out = raymarch_out(orig + dir * (dist + 1.0e-2), dir);\n        bright = ramp(0.0, 1.0 / iResolution.y, dist_out);\n        dir = mix(dir, normalize(reflect(dir, n)), bright);\n        thru_dist = raymarch_out(orig + dir * (dist + 1.0e-2), light_dir);\n        refl_color = vec3(0.8, 0.7, 0.6);\n    }\n\n    vec3 col = (0.5 + 0.5 * bright) *\n        (0.2 * smoothstep(0.7, 1.0, dot(dir, light_dir)) + 0.7 * smoothstep(0.1, 1.0,\n                                                                      dot(n, light_dir)))*\n        refl_color;\n    \n    col += bright * (1.0 / max(abs(1.0 * thru_dist), 0.5)) * trans_color;\n\n    // Output to screen\n    fragColor =  vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsf3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 549, 597, 597, 756], [758, 758, 807, 807, 932], [935, 935, 960, 960, 1127], [1130, 1130, 1155, 1155, 1520], [1522, 1522, 1547, 1547, 1912], [1914, 1914, 1937, 1937, 2319], [2321, 2321, 2348, 2348, 2595], [2597, 2597, 2638, 2638, 3007], [3009, 3009, 3054, 3054, 3431], [3433, 3433, 3481, 3481, 3541], [3543, 3543, 3600, 3650, 6150]]}
{"id": "tsf3RX", "name": "Thought Bubble", "author": "kubiak", "description": "Cartoon thought bubble with help from iq.", "tags": ["cartoon"], "likes": 1, "viewed": 536, "published": "Public API", "date": "1546984156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mainBubbleSize = 70.0;\nfloat bubbleOutline = 5.0;\nfloat curlHeight = 9.0;\nfloat curlFrequency = 10.0;\nfloat curlNoisePower = 25.0;\n\nvec2 leadBubble = vec2(120.0, 20.0);\nfloat startBabyBubbleSize = 7.0;\nfloat babyBubbleWidth = 2.0;\n\nconst int babyBubbles = 4;\n\nfloat horizontalStretch = 0.6;\nfloat swimPower = 40.0;\nfloat babySwimPower = 10.0;\n\n// Uses Inigo Quilez Simpex Noise\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat n_noise(in vec2 p)\n{\n    return 0.5 + 0.5 * noise(p);\n}\n\n\n// https://www.shadertoy.com/view/XsfGzn\nvec4 videoColor(vec2 center, vec2 coord, float size) {\n    vec4 bg = vec4(1.0, 1.0, 1.0, 1.0);\n    vec2 q = (coord - center) / size;\n    q.x += 0.5;\n    q.y += 0.5;\n    \n    if(q.x <= 0.0)\n        return bg;\n    if(q.x >= 1.0)\n        return bg;\n    if(q.y <= 0.0)\n        return bg;\n    if(q.y >= 1.0)\n        return bg;\n    \n\tvec3 fg = texture( iChannel0, q ).xyz;\n\t\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n    float uvDist = distance(vec2(0.5, 0.5), q);\n    uvDist = pow(uvDist, 1.0/1.6) / 0.7071;\n    \n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n    fg = mix(fg, bg.xyz, uvDist);\n    \n    \n\n    return vec4( mix(fg, bg.xyz, k), uvDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float outsideBubble= mainBubbleSize + bubbleOutline;\n    vec2 center = vec2(320, 190);\n    float bubbleSwimX = noise(vec2(iTime * 0.1, 0.0)) * swimPower;\n    float bubbleSwimY = noise(vec2(iTime * 0.06, 0.0)) * swimPower;\n    center.x += bubbleSwimX;\n    center.y += bubbleSwimY;\n    \n    \n    vec2 pt = fragCoord - center;\n    pt.x *= horizontalStretch;\n    \n    float angle = atan(pt.y / pt.x);\n    float d = length(pt);\n    \n    d -= abs(cos(angle * curlFrequency)) * curlHeight;\n    d -= n_noise(fragCoord * 0.01) * curlNoisePower;\n    \n    \n    vec4 c = vec4(1.0, 1.0, 1.0, 1.0);\n    \n\n    if(d < mainBubbleSize) {        \n        c = videoColor(center, fragCoord, mainBubbleSize * 2.0);\n    }\n    else if(d < outsideBubble) {\n        c = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else {\n        for(int i = 0; i < babyBubbles; i++) {\n            float fi = float(i);\n            vec2 babyBubble = leadBubble;\n     \t\tfloat babySwimX = noise(vec2(iTime * 0.1 * fi, 0.0)) * babySwimPower;\n    \t\tfloat babySwimY = noise(vec2(iTime * 0.06 * fi, 0.0)) * babySwimPower;           \n            babyBubble.x += babySwimX;\n            babyBubble.y += babySwimY;\n            babyBubble.x += fi * 35.0;\n            babyBubble.y += pow(fi * 2.5, 2.0);\n            \n            float babyBubbleSize = startBabyBubbleSize * (fi*0.4 + 1.0);\n            pt = fragCoord - babyBubble;\n            pt.x *= horizontalStretch;\n            d = length(pt);\n            if(d > babyBubbleSize && d < babyBubbleSize + babyBubbleWidth) {\n                c = vec4(0.0, 0.0, 0.0, 1.0);\n            }\n        }\n    }\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = c;\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsf3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 457, 514, 514, 635], [637, 637, 663, 663, 1116], [1118, 1118, 1144, 1144, 1179], [1182, 1223, 1277, 1277, 1959], [1961, 1961, 2018, 2018, 3745]]}
{"id": "tsfGDj", "name": "Golden ratio visu (loopless)", "author": "FabriceNeyret2", "description": "Making toocanzs's shader [url]https://shadertoy.com/view/3sfGDj[/url] loopless.", "tags": ["loopless", "golden", "ratio", "irrationality"], "likes": 5, "viewed": 465, "published": "Public API", "date": "1547503578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Loopless version of toocanzs's https://shadertoy.com/view/3sfGDj\n\n\n#define DYNAMIC\n\n#define CS(a)  vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = ( 2.*u - R )/ R.y;\n    O = vec4(0);\n\n    float PI = 3.14159,\n#ifdef DYNAMIC\n        phi = iTime*0.001 + 0.1,\n#else\n        phi = (1. + sqrt(5.))/2.,\n#endif\n          a = phi * 2.*PI,\n         i0 = ( length(U) - .01 ) /.0015,\n         i1 = ( mod( PI-atan(U.y,U.x) ,2.*PI) )/ a, // + k.2PI/a\n          k = floor( (i0-i1) / (2.*PI/a) ), \n          i, d = 1e9;\n    \n    for (float n = 0.; n < 2.; n++) {\n        i = round(i1 + k++ * 2.*PI/a );\n        vec2 p = ( .01+ 0.0015*i) *CS(PI-i*a);\n    \td = min( d, length(U - p) - .001);\n        //O[int(n)%3] += max(0.,1.-length(U - p)/.1);    \n    }\n  \n    O += vec4(smoothstep(3./iResolution.y, 0., d - .01));\n}      \n\n\n\n\n\n\n/**    // toocanzs's shader https://shadertoy.com/view/3sfGDj\n\nfloat phi = (1. + sqrt(5.))/2.;\n#define DYNAMIC\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy )/ iResolution.y;\n    \n\tfloat d = 99999.;\n    vec2 p = vec2(0.01,0);\n#ifdef DYNAMIC\n    phi = iTime*0.001 + 0.1;\n#endif\n\n    float a = phi * 2.*3.14159265358979323846;\n    mat2 rot = mat2(cos(a),sin(a),-sin(a),cos(a));\n    for(int i = 0; i < 1400; i++)\n    {\n        p *= rot;\n    \td = min(d,length(uv + p)-0.001);\n        p = normalize(p) * (length(p)+0.0015);\n    }\n    fragColor = vec4(smoothstep(3./iResolution.y, 0., d - 0.01));\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 123, 161, 161, 858]]}
{"id": "tsfGDM", "name": "Blood cells", "author": "jaszunio15", "description": "Having fun with cellular noise\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)", "tags": ["noise", "cellular", "cells", "blood"], "likes": 9, "viewed": 228, "published": "Public", "date": "1546476611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//EDIT: Thanks to FabriceNyret2 for this nice rotation tip\n#define ROTATE_VEC2(angle) vec2(cos(angle), sin(angle)) \n\n//Comment to enable previus shader version\n#define ONLY_CIRCULAR_CELLS\n\n\nconst int iterations = 5;\nconst float pi = 3.141592;\nconst float doublePi = 6.283185;\n\nvec2 randomNumber(in vec2 v)\n{\n    //EDIT: Thanks to FabriceNyret2 for optimization tip \n    //return vec2(fract(sin(dot(v, vec2(12.1215, 23.02751))) * 541.9283),\n    //            fract(sin(dot(v, vec2(23.02751, 12.1215))) * 632.6047));\n    return fract(sin(v * mat2(0.7400775, -0.6725215, 0.1241045, 0.9922691)) * vec2(541.9283, 638.1429));\n}\n\nvec2 cellCenter(in vec2 uv)\n{\n \tvec2 rand = randomNumber(uv);\n    \n    //EDIT: Removed code redundancy pointed by FabriceNyret2, thanks again!\n    //return uv + vec2(cos(iTime * rand.x * 0.3), sin(iTime * rand.x * 0.3)) * rand.y * float(iterations - 1);\n\tfloat time = iTime * rand.x * 0.3;\n\treturn uv + ROTATE_VEC2(time) * rand.y * float(iterations - 1);\n}\n\nvec4 cellularNoise(in vec2 uv)\n{\n    //xy - floor uv (root point), zw - cell center\n \tvec4 uvData = vec4(floor(uv), 0.0, 0.0);\n    uvData.zw = cellCenter(uvData.xy);\n    \n    //xy - point coordinates, z - distance from point to uv\n    vec3 firstPointData = vec3(0.0, 0.0, 99999.0);\n    for(int x = -iterations; x <= iterations; x++)\n    {\n        for(int y = -iterations; y <= iterations; y++)\n        {\n            vec4 tempUVData = vec4(uvData.xy + vec2(x, y), 0.0, 0.0);\n            tempUVData.zw = cellCenter(tempUVData.xy);\n            vec2 v = uv - tempUVData.zw;\n     \t\tfloat distToTemp = v.x * v.x + v.y * v.y;\n            \n            //changed () ? : into if statement, thanks to Fabrice again!\n           \tif(firstPointData.z > distToTemp)\n            {\n                firstPointData.z = distToTemp;\n            \tfirstPointData.xy = tempUVData.zw;\n            }\n            else\n            {\n                firstPointData.z = firstPointData.z;\n            \tfirstPointData.xy = firstPointData.xy;\n            }   \n        } \n    }\n    \n    vec3 secondPointData = vec3(0.0, 0.0, 99999.0);\n    for(int x = -iterations; x <= iterations; x++)\n    {\n        for(int y = -iterations; y <= iterations; y++)\n        {\n            vec4 tempUVData = vec4(uvData.xy + vec2(x, y), 0.0, 0.0);\n            tempUVData.zw = cellCenter(tempUVData.xy);\n            vec2 v = uv - tempUVData.zw;\n     \t\tfloat distToTemp = v.x * v.x + v.y * v.y;\n            \n            //changed () ? : into if statement\n            if (secondPointData.z > distToTemp && distToTemp > firstPointData.z)\n            {\n                secondPointData.z = distToTemp;\n                secondPointData.xy = tempUVData.zw;\n            }\n            else\n            {\n                secondPointData.z = secondPointData.z;\n                secondPointData.xy = secondPointData.xy;\n            }\n            \n            \n        } \n    }\n    \n    firstPointData.z = sqrt(firstPointData.z);\n    secondPointData.z = sqrt(secondPointData.z);\n    vec3 centralPoint = (firstPointData + secondPointData) / 2.0;\n    \n    //Added this line to remove all not circular cells\n#ifdef ONLY_CIRCULAR_CELLS\n    centralPoint.z = clamp(centralPoint.z, 0.0, 0.5);\n#endif\n    \n    float effect = pow(sin(fract(centralPoint.z) * doublePi) * 0.5 + 0.5, 4.0);\n    vec3 col = vec3(0.8, 0.0, 0.0) * effect;\n    \n    return vec4(col + vec3(0.1, 0.0, 0.0), 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //EDIT: Removed useless mousePos\n\t//float mousePos = iMouse.y / iResolution.y;\n\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    uv -= vec2(0.0, 1.5);\n    float time = iTime * 0.1;\n    mat2 mat = mat2(\tcos(time), \tsin(time),\n    \t\t\t\t\t-sin(time), cos(time));\n    uv = mat * uv;\n\n    fragColor = cellularNoise(uv * 10.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfGDM.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[179, 339, 369, 576, 683], [685, 685, 714, 714, 1041], [1043, 1043, 1075, 1126, 3450], [3453, 3453, 3510, 3593, 3852]]}
{"id": "tsfGzB", "name": "Colorful Gradient", "author": "williamlawes", "description": "A Gradient shader.", "tags": ["color"], "likes": 2, "viewed": 399, "published": "Public API", "date": "1546668431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "tsj3Rh", "name": "Assimilation", "author": "deaths_angel", "description": "Inspired by https://www.shadertoy.com/view/wdlGRM\n\n", "tags": ["circles", "animation", "transform", "concentric"], "likes": 8, "viewed": 181, "published": "Public", "date": "1548186979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\tuv *= mat2(.71+ (0.145 * iTime) , -.707 -(0.175 * iTime), .701+ (0.125 * iTime), .707+ (0.105 * iTime)); \n    uv *= 15.;\n\n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n\n\n    vec4 mc = vec4(0,0,0,0);\n    float t;\n    for(float y=-1.; y<=-1.; y++) {\n        for(float x=-1.; x<=2.; x++) {\n            vec2 offs = vec2(x, y);\n\n            t = -iTime+length(id-offs)* 0.87; \n            float r = mix(.88, 1.75, sin(t)*.45);\n              float r2 = mix(.88, 2.05, sin(t + 0.15)*.75); \n            float r3 = mix(.88, 1.05, sin(t + 0.25) *1.95);\n            float c = smoothstep(r * 1.7, r * 0.9, length(gv+offs));\n            mc.x = mc.x*(1.0-c) + c*(1.-mc.x) * ( r2 );\n            mc.y = mc.y*(1.-c) + c*(1.-mc.y)* r;\n            mc.z = mc.z*(1.-c) + c*(1.-mc.z) * r3;\n            mc.a = mc.a*(1.-c) + c*(1.-mc.a); } } \n    \t\n    \t\tmc *= 0.5; \n   \n    \n    fragColor = mc; \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsj3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1004]]}
{"id": "tsj3zw", "name": "Boy's Surface Implicit", "author": "YsmrRy", "description": "forked from iq\nBoy's surface implicit equation", "tags": ["raymarch"], "likes": 2, "viewed": 113, "published": "Public", "date": "1548504175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 1 is your machine is too slow\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 1\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n#endif    \n#if 0    \n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n#if 0    \n    float ibal = inversesqrt(baba);\n    float x = length(pa-ba*paba*ibal*ibal) - r;\n    float y = (abs(paba-baba*0.5)-baba*0.5)*ibal;\n    return min(max(x,y),0.0) + length(max(vec2(x,y),0.0));\n#else\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n#endif    \n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat func( vec3 pos )\n{\n  \tfloat x = pos.x, y = pos.y, z = pos.z;\n    \n    return -2749.231165*x*x*x*z*y*y-1832.820776*y*z*z*x*x+648.*z*x*x*y*y-1620.*z*z*x*x*y*y+1832.820776*y*z*z*z*x*x-4123.846747*y*y*y*y*x*z+916.4103882*z*z*z*x*y*y-288.*z*z*z*z+64.*z*z*z+432.*z*z*z*z*z-216.*z*z*z*z*z*z-729.*x*x*x*x*x*x-729.*y*y*y*y*y*y-144.*z*z*x*x-144.*z*z*y*y+324.*z*z*z*z*x*x+324.*z*z*z*z*y*y+324.*z*x*x*x*x+324.*z*y*y*y*y+610.9402588*y*y*y*z*z-810.*z*z*x*x*x*x-810.*z*z*y*y*y*y-610.9402588*y*y*y*z*z*z-2187.*x*x*x*x*y*y-2187.*x*x*y*y*y*y+1374.615582*x*x*x*x*x*z-305.4701294*z*z*z*x*x*x;\n}\n\nvec3 grad( vec3 pos )\n{\n\tvec2 h = vec2(0.00001, 0.);\n    \n    return vec3(\n    \tfunc(pos+h.xyy)-func(pos-h.xyy),\n        func(pos+h.yxy)-func(pos-h.yxy),\n        func(pos+h.yyx)-func(pos-h.yyx)\n    )/(2.0*h.xxx);\n}\n\nvec3 gradAna( vec3 pos )\n{\n  float x = pos.x, y = pos.y, z = pos.z;\n\n  return vec3(\n    -2749.231165*3.*x*x*z*y*y-1832.820776*y*z*z*2.*x+648.*z*2.*x*y*y-1620.*z*z*2.*x*y*y+1832.820776*y*z*z*z*2.*x-4123.846747*y*y*y*y*z+916.4103882*z*z*z*y*y-729.*6.*x*x*x*x*x-144.*z*z*2.*x+324.*z*z*z*z*2.*x+324.*z*4.*x*x*x-810.*z*z*4.*x*x*x-2187.*4.*x*x*x*y*y-2187.*2.*x*y*y*y*y+1374.615582*5.*x*x*x*x*z-305.4701294*z*z*z*3.*x*x,\n    -2749.231165*x*x*x*z*2.*y-1832.820776*z*z*x*x+648.*z*x*x*2.*y-1620.*z*z*x*x*2.*y+1832.820776*z*z*z*x*x-4123.846747*4.*y*y*y*x*z+916.4103882*z*z*z*x*2.*y-729.*6.*y*y*y*y*y-144.*z*z*2.*y+324.*z*z*z*z*2.*y+324.*z*4.*y*y*y+610.9402588*3.*y*y*z*z-810.*z*z*4.*y*y*y-610.9402588*3.*y*y*z*z*z-2187.*x*x*x*x*2.*y-2187.*x*x*4.*y*y*y,\n    -2749.231165*x*x*x*y*y-1832.820776*y*2.*z*x*x+648.*x*x*y*y-1620.*2.*z*x*x*y*y+1832.820776*y*3.*z*z*x*x-4123.846747*y*y*y*y*x+916.4103882*3.*z*z*x*y*y-288.*4.*z*z*z+64.*3.*z*z+432.*5.*z*z*z*z-216.*6.*z*z*z*z*z-144.*2.*z*x*x-144.*2.*z*y*y+324.*4.*z*z*z*x*x+324.*4.*z*z*z*y*y+324.*x*x*x*x+324.*y*y*y*y+610.9402588*y*y*y*2.*z-810.*2.*z*x*x*x*x-810.*2.*z*y*y*y*y-610.9402588*y*y*y*3.*z*z+1374.615582*x*x*x*x*x-305.4701294*3.*z*z*x*x*x\n  );\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( sdPlane(     pos), 1.0 );\n    \n    pos -= vec3( -0.5,0.25, 0.0);\n    pos *= 2.;\n    \n    res = opU( res, vec2( abs(func(pos))/length(gradAna(pos)), 46.9) );\n    \n    res.x /= 2.0;\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 rot( vec3 pos, float theta )\n{\n    return vec3( pos.x*cos(theta)-pos.z*sin(theta), pos.y, pos.x*sin(theta)+pos.z*cos(theta) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0;\n\n    \n    vec3 tot = vec3(0.0);\n    vec3 dif = vec3( 0., 2.4, -1.5 );\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n         vec3 ta = vec3( -0.5, -0.4, 0.5 );\n         vec3 ro = ta+rot( dif, iTime/15. );\n       // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsj3zw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1395, 1465, 1490, 1490, 1505], [1507, 1507, 1542, 1542, 1568], [1570, 1570, 1601, 1601, 1692], [1694, 1694, 1753, 1753, 1847], [1849, 1849, 1904, 1904, 1999], [2002, 2002, 2035, 2035, 2090], [2092, 2092, 2128, 2128, 2685], [2687, 2687, 2739, 2739, 2853], [2855, 2855, 2919, 2919, 3197], [3199, 3199, 3223, 3223, 3240], [3241, 3241, 3304, 3368, 3955], [3958, 3958, 4001, 4001, 4252], [4254, 4254, 4290, 4290, 4473], [4475, 4487, 4523, 4523, 4622], [4624, 4649, 4700, 4700, 5274], [5276, 5276, 5314, 5314, 5483], [5485, 5485, 5510, 5510, 5529], [5530, 5530, 5601, 5601, 5939], [5941, 5941, 6008, 6047, 6419], [6421, 6421, 6446, 6446, 6483], [6485, 6485, 6510, 6510, 6568], [6570, 6570, 6595, 6595, 6660], [6662, 6662, 6697, 6697, 6768], [6770, 6770, 6805, 6805, 6876], [6878, 6878, 6915, 6915, 6968], [6970, 7040, 7073, 7073, 7099], [7101, 7101, 7131, 7131, 7164], [7166, 7166, 7196, 7196, 7225], [7227, 7227, 7251, 7251, 7383], [7485, 7555, 7579, 7579, 8135], [8137, 8137, 8160, 8160, 8351], [8353, 8353, 8379, 8379, 9535], [9537, 9537, 9562, 9562, 9786], [9788, 9788, 9828, 9828, 10448], [10451, 10513, 10591, 10591, 10856], [10858, 10922, 10954, 10954, 11485], [11487, 11487, 11529, 11529, 11831], [11833, 11909, 11945, 11966, 12189], [12191, 12191, 12230, 12230, 13931], [13933, 13933, 13985, 13985, 14162], [14164, 14164, 14199, 14199, 14297], [14299, 14299, 14356, 14356, 15293]]}
{"id": "tsjGDW", "name": "Bloup 2", "author": "rcargou", "description": "a shader", "tags": ["ellipse"], "likes": 1, "viewed": 408, "published": "Public API", "date": "1548937114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_POINT 256\n#define HARMONIK 8.0f\n#define KERNEL 4 + 1\n#define TIME (5000.0f + iTime) * 0.07f\nvec2 points[KERNEL];\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1f);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n    \nreturn vec2(fract(sin(dot(vec2(p, p * vec2(20.0f)), vec2(12.9898, 78.233))) * 43758.5453), fract(sin(dot(vec2(p,p), vec2(8.9898, 78.233))) * 41758.5453));\n}\n\nvec2 getPoint(int graine) {\n   // return vec2(0.5f + 0.1f * float(graine),float(graine)*0.0f + .5f);\n    vec2 p = hash21(float(graine));\n    for (int i = 0; i < int(HARMONIK); ++i) {\n    float c = hash11(float(graine + i*NUM_POINT));\n     float h = hash11(float(graine + i*NUM_POINT));\n    p += 16.0f*(vec2(cos(float(i) / float(HARMONIK) + c * TIME * HARMONIK), sin(h * TIME * HARMONIK)) / (1.0f + 18.0f)) / float(HARMONIK);\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = 0.0 + 0.005*cos(iTime+uv.xyx+vec3(0,2,4)) * vec3(1.0f, 0.5f, 0.5f);\n\n    for (int i = 0; i < KERNEL; ++i)\n        points[i] = vec2(1000.0f);\n    for (int i = 0; i < NUM_POINT; ++i) {\n\t\tvec2 p = getPoint(i);\n\t\tfloat m = 0.0f;\n        int mi = 0;\n        for (int j = 0; j < KERNEL - 1; ++j) {\n            if (length(uv - points[j]) > m) {\n                m = length(uv - points[j]) ;\n                    mi = j;\n                    }\n        }\n        if (m > length(uv - p))\n            points[mi] = p;\n\n    }\n    //points[2] = vec2(0.5f + 0.1f * 0.0f,0.0f + .5f);\n //   points[1] = vec2(0.5f + 0.1f * 1.0f,0.0f + .5f);\n //   points[0] = vec2(0.5f + 0.1f * 2.0f,0.0f + .5f);\n    \n    float t = (.0f);\n    for (int i = 0; i < KERNEL - 1; ++i) {\n        t += length(points[i] - uv);\n    }\n    t /= float(KERNEL);\n    if (t < 0.1f * float(KERNEL)){\n        col +=1200.5f * t*t*t*t * vec3(0.2f, 0.7f, 0.1f);\n        col += 0.00000002f *1.0f / (t*t *t*t) * vec3(.5f,0.f, .5f);\n    }\n    for (int i = 0; i < KERNEL-1; ++i) {\n          if (length(uv - points[i]) < 0.01f)\n           col += .0001f + (1.0f / (t*t)) * .000000004f * 1.0f / length(uv - points[i]) * (.8f + .2f * sin(0.0f * 40.0f));   \n    }\ncol *= 8.0f;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 149, 149, 260], [262, 262, 284, 284, 446], [448, 448, 475, 548, 894], [896, 896, 953, 1003, 2401]]}
{"id": "tsjGzD", "name": "pizza slice distance", "author": "abje", "description": "a piece of a circle. use mouse.", "tags": ["2d", "circle", "distance", "keyhole"], "likes": 12, "viewed": 498, "published": "Public API", "date": "1548361803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi acos(-1.0)\n\nfloat oldpizza( vec2 p, vec2 c, float rad1, float rad2)\n{\n    p.x = abs(p.x);\n    \n    float len2 = dot(vec2(c.y,-c.x),p.xy);\n    float len3 = dot(c,p);\n    \n    float len;\n    if (len2 > 0.0) {\n        len = len3;\n    } else {\n        len = length(p);\n        if (len3 < 0.0) {\n            len2 = -len;\n        }\n    }\n    \n    vec2 lens = vec2(abs(len-(rad1+rad2)*0.5)-(rad2-rad1)*0.5,len2);\n    \n    len = min(max(lens.x,lens.y),0.0)+length(max(lens,0.0));\n    \n    return len;\n}\n\nfloat pizza( vec2 p, vec2 c, float rad1, float rad2)\n{\n    p.x = abs(p.x);\n    \n    vec2 c2 = vec2(c.y,-c.x);\n    \n    float l = -dot(c,p.xy);\n    float q = p.x+c.x*l;\n    float l2;\n    \n    if (max(q,-sign(p.y*c.y)) < 0.0) {\n        l = -length(p.xy);\n    }\n    \n    if (l < 0.0) {\n        l2 = length(p.xy);\n    } else {\n        l2 = dot(c2,p.xy)*sign(c.y);\n    }\n    \n    \n    \n    vec2 a = vec2(max(l2-rad2,rad1-l2),l);\n    \n    return length(max(a,0.0))+min(0.0,max(a.x,a.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    if (iMouse.x <= 0.0) \n        muv = vec2(0.4+sin(iTime)*0.1,0.85+cos(iTime)*0.1);\n    \n    float t = muv.y*pi*2.0;\n    float r = muv.x*0.5;\n    \n    float len = pizza(uv,vec2(-cos(t),sin(t)), r,0.5);\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(len));\n\tcol *= 0.8 + 0.2*cos(120.0*abs(len));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(len)) );\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 506], [508, 508, 562, 562, 991], [993, 993, 1050, 1100, 1719]]}
{"id": "tslGWs", "name": "polka dots 3 (98 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "pattern", "short", "onetweet", "golf"], "likes": 5, "viewed": 337, "published": "Public API", "date": "1547847419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of https://shadertoy.com/view/wdlGWs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.yy,\n         U = sin( u / R /.05 );\n    O = sin(  ( U.x*U.y - sin(iTime) ) /.1 )  *R.yyyy/2e2; }/*\n\n// color version:\n// O += sin(  ( U.x*U.y - sin(iTime+vec4(0,23,21,0)) ) /.1 )  *R.y/2e2\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 83, 83, 205]]}
{"id": "tss3Rl", "name": "ShaderDojo 011", "author": "antonOTI", "description": "Result of my training for shader showdowns", "tags": ["raymarching", "training", "cookie"], "likes": 4, "viewed": 370, "published": "Public API", "date": "1547240904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat map(vec3 p)\n{\n  vec3 cp = p;\n  float dist = 1000.;\n\n  float time = iTime * .5;\n\n  p.zx *= rot(-time * .25);\n\n  for(float it = 0.; it < 4.; it += 1.)\n{\n  p.xz *= rot(sin(p.y + time + (fract(sin(it * 2369.)))) * PI / (it + 1.) * 1.5);\n\n  p.y += p.x * .125;\n  p.zy *= rot(time);\n\n  dist  =smin(dist, length(p) - 1., .25);\n}\n\n  return dist;\n}\n\nfloat ray(inout vec3 cp, vec3 rd, out float cd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1. /32.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n    {\n      break;\n    }\n    cp += rd * cd * .75;\n  }\n\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *= .35;\n\n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 cp = eye;\n\n  float cd;\n  float st = ray(cp, rd, cd);\n\n  fragColor = vec4(0.);\n  if(cd < .01)\n  {\n    vec3 ld = normalize(vec3(0.,-1.,1.));\n    ld.xz *= rot(iTime * .1);\n\n    vec3 norm = normal(cp);\n    float li = dot(ld, norm);\n\n    ld.zy *= rot(iTime * .25);\n    float li2 = dot(normalize(vec3(1.,0.,1.)), norm);\n    \n\n    float f = 1.-exp(-max(li,li2));\n    //f = sqrt(f);\n    vec4 col = vec4(norm, 0.);\n\n    col.xy *= rot(iTime * .5);\n    col.yz *= rot(iTime * .75);\n    col.xz *= rot(iTime * .125);\n    col = abs(col);\n    fragColor = mix(vec4(0.), col * 1.5, f);\n  }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tss3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 64, 64, 164], [166, 166, 185, 185, 258], [260, 260, 279, 279, 604], [606, 606, 655, 655, 812], [814, 814, 835, 835, 996], [998, 998, 1055, 1055, 1856]]}
{"id": "tss3Rs", "name": "[twitch] Gold and Silver", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can disable the FRINGE effect at the top.\nYou can also lower the STEPS if too slow", "tags": ["3d", "raymarching", "transparency", "live", "twitch"], "likes": 15, "viewed": 409, "published": "Public", "date": "1547245586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can disable the FRINGE effect with the define below.\nYou can also lower the STEPS if too slow\n*/\n                             \n#define FRINGE 1\n#define STEPS 100\n\n#define time (iTime*0.3)\n//float time = texture(texFFTIntegrated, 0.01).x*0.2;\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 r) {\n  vec3 ap=abs(p)-r;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);  \n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*843.231)*8631.1423);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\nfloat mat=0.0;\n\nfloat map(vec3 p) {\n\n  vec3 bp=p;\n\n  float t = time*0.17;\n\n  for(int i=0; i<5; ++i) {\n    float t1 = curve(t+float(i)*0.42,0.4) * 2.0;\n    p-=0.1+0.1*float(i)+t1*0.1;\n    p.xy *= rot(t1*0.7);\n    p.yz *= rot(t1);\n    p=abs(p);\n    p-=0.2;\n  }\n  vec3 rp=p;\n\n  float t1 = curve(t+98.7424,0.7) * 3.0;\n  p-=0.3 - t1*.1;\n  p.xy *= rot(t1*0.7);\n  p.yz *= rot(t1);\n  p-=0.2;\n\n  float trans=box(rp, vec3(0.5));\n  float opa=box(p, vec3(0.05+curve(time, 1.2)*0.2));\n  opa = min(opa, cyl(rp.xy,0.05));\n  opa = smin(opa, sph(bp, 7.0), -3.0);\n  //opa = 10000;\n\n  \n  trans = max(trans, -opa+.02);\n  opa = max(opa, -trans+.02);\n\n  mat=0.0;\n  if(trans>opa) mat=1.0;\n\n  return min(trans, opa);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvoid cam(inout vec3 p) {\n  float t1=time*0.3 + curve(time, 0.7)*3.0;\n  p.zx *= rot(t1);\n  p.zy *= rot(t1*1.2);\n}\n\nvec3 ref(vec3 r) {\n  float px = pow(1.0-abs(fract(abs(r.x)*10.0)-0.5)*2.0, 3.0);\n  float py = pow(1.0-abs(fract(abs(r.y)*10.0)-0.5)*2.0, 3.0);\n  vec3 col = vec3(1,0.8,0.2)*px;\n  //col = mix(col, vec3(1,1.0,1.4)*0.7, py);\n  return col*0.5;\n}\n\nvec2 mir(vec2 uv, float a) {\n  uv *= rot(a);\n  uv.x = abs(uv.x);\n  return uv;\n}\n\nvec4 color(vec2 uv)\n{\n  float fsize=1.0;\n  #if FRINGE\n  \tfloat fringe = fract(floor(gl_FragCoord.y/fsize)*fsize/3.0);\n  \tvec3 fcol = 1.0-abs(fringe*3.0-vec3(0,1,2));\n  \tfcol = mix(fcol, vec3(1), 0.5);\n  #else\n\tfloat fringe = 0.5;\n    vec3 fcol=vec3(0.8);\n  #endif\n  float cx = (curve(time, 0.7)-0.5)*7.0;\n  float cy = (curve(time, 0.8)-0.5)*3.0;\n\n  vec3 s=vec3(cx,cy,-10);\n  vec3 r=normalize(vec3(-uv,0.6 + curve(time, 0.3)));\n\n  cam(s);\n  cam(r);\n\n  vec3 col = vec3(0);\n\n  vec3 p=s;\n  float dd=0.0;\n  float side=sign(map(p));\n  vec3 prod = vec3(1.0);\n  int i=0;\n  for(i=0; i<STEPS; ++i) {\n    float d=map(p)*side;\n    if(d<0.001) {\n      \n      vec3 n=norm(p)*side;\n      vec3 l = normalize(vec3(-1));\n\n      if(dot(l,n)<0.0) l=-l;\n\n      vec3 h = normalize(l-r);\n\n      float opa = mat;\n      vec3 diff=mix(vec3(1), vec3(1,0.8,0.2), mat);\n      vec3 diff2=mix(vec3(1), vec3(1,0.7,0.0), mat);\n      float spec=mix(0.2, 1.5, mat);\n      float fresnel = pow(1.0-max(0.0,dot(n,-r)),5.0);\n      \n      col += max(0.0, dot(n,l)) * (spec*(pow(max(0.0,dot(n,h)),50.0) * 0.5 + 0.5*diff2*pow(max(0.0,dot(n,h)),12.0)  )) * diff * prod;\n      \n      vec3 back = ref(reflect(r,n))*0.5*fresnel;\n      col += back;\n\n      side = -side;\n      d = 0.01;\n      r = refract(r,n,1.0 - 0.05*side*(0.5+0.5*fringe));\n      prod *= fcol*0.9;\n      if(opa>0.5) {\n        /*vec3 back = ref(r)*1.0*fresnel;\n        col = mix(col, back, prod);*/\n        prod=vec3(0);\n        break;\n      }\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  if(i>99) {\n    prod=vec3(0);\n  }\n\n  vec3 back = ref(r);\n  col = mix(col, back, prod);\n  //col *= 3;\n\n  //col *= 3*pow(1-length(uv),0.7);\n  vec2 auv = abs(uv)-vec2(0.5,0.0);\n  col *= vec3(2.0*pow(1.0-clamp(pow(length(max(vec2(0),auv)),3.0),0.0,1.0),10.0));\n\n  #if 1\n    col = smoothstep(0.0,1.0,col);\n    col = pow(col, vec3(0.4545));\n  #endif\n  \n  //col = vec3( step(curve(uv.x, 0.04), uv.y*5) );\n  //col = fcol;\n\n  return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec4 col = color(uv);\n\n  fragColor = vec4(col.xyz, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tss3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 311, 339, 339, 363], [365, 365, 393, 393, 417], [419, 419, 446, 446, 540], [542, 542, 561, 561, 632], [634, 634, 673, 673, 752], [754, 754, 774, 774, 818], [820, 820, 851, 851, 956], [974, 974, 993, 993, 1652], [1654, 1654, 1673, 1673, 1781], [1783, 1783, 1807, 1807, 1895], [1897, 1897, 1915, 1915, 2137], [2139, 2139, 2167, 2167, 2218], [2220, 2220, 2241, 2241, 4211], [4213, 4213, 4270, 4270, 4467]]}
{"id": "tsS3WW", "name": "practice-16", "author": "kiyamada96", "description": "aa", "tags": ["aa"], "likes": 3, "viewed": 105, "published": "Public", "date": "1548904707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n\n    for(int i=1;i<=6;++i)\n    {  \n   \t\tp=abs(p*1.5)-0.8;\n        float b=float(i)*iTime+iMouse.x*0.01;\n        float c=cos(b);\n   \t\tfloat s=sin(b);\n        p*=mat2(c,s,-s,c);\n    }\n    \n    vec2 axis=1.-smoothstep(0.01,0.05,abs(p));\n    vec2 color=mix(p,vec2(1),axis.x+axis.y);  \n    fragColor=vec4(color,0.4,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsS3WW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 436]]}
{"id": "tsS3zR", "name": "Beneath the Surface", "author": "texel", "description": "Mostly an art project.", "tags": ["sdf", "fish", "shoal"], "likes": 3, "viewed": 334, "published": "Public API", "date": "1547926253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opUnion(float d1, float d2) { return min(d1, d2); }\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\nfloat opSubtraction(float d1, float d2) { return max(d1, -d2); }\nfloat opOnion(float d, float thikness) { return abs(d) - thikness; }\n\nmat2 rotMat(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdFish(vec2 p, float r)\n{\n    float upperCircle = sdCircle(p - vec2(0, 0.6) * r, r);\n    float lowerCircle = sdCircle(p - vec2(0, -0.6) * r, r);\n    \n    float upperTail = sdCircle(p - vec2(1.4, 0.5) * r, r);\n    float lowerTail = sdCircle(p - vec2(1.4, -0.5) * r, r);\n    \n    float body = opIntersection(upperCircle, lowerCircle);\n    float tail = opSubtraction(opIntersection(upperTail, lowerTail), sdCircle(p - vec2(2, 0) * r, r));\n    float eye = sdCircle(p - vec2(-0.4, 0.1) * r, 0.07 * r);\n    return opSubtraction(opUnion(body, tail), eye);\n}\n\nfloat sdMovingFish(vec2 p, float r, float t, float speed, float period)\n{\n    float x = mod(p.x + 0.5 + speed * t, period) - 0.5;\n    return sdFish(vec2(x, p.y), r);\n}\n\nfloat sdRect(vec2 p, vec2 r)\n{\n    vec2 d = abs(p) - r;\n    return length(max(d, 0.0))\n        + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2)\n{\n    vec2 v0 = p1 - p0;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p0 - p2;\n    \n    vec3 sd = vec3(\n        dot(p - p0, normalize(vec2(-v0.y, v0.x))),\n        dot(p - p1, normalize(vec2(-v1.y, v1.x))),\n        dot(p - p2, normalize(vec2(-v2.y, v2.x)))\n    );\n\n    return max(sd[0], max(sd[1], sd[2]));\n}\n\nfloat sdBoat(vec2 p, float s)\n{\n    vec2[] points = vec2[](\n        vec2(+1.5, 0.0) * s,\n        vec2(-1.5, 0.0) * s,\n        vec2(-2.0, 1.0) * s,\n        vec2(+2.0, 1.0) * s,\n        vec2(0) // to make the array cyclic\n    );\n    points[points.length() - 1] = points[0];\n    int pointCount = points.length() - 1;\n    \n    mat2 normalMat = mat2(0.0, 1.0, -1.0, 0.0);\n    \n    float maxSd = -99999.0;\n    \n    for (int i = 0; i < pointCount; i++)\n    {\n        vec2 p0 = points[i];\n        vec2 p1 = points[i + 1];\n        vec2 normal = normalize(normalMat * (p1 - p0));\n        float sd = dot(p - p0, normal);\n        maxSd = max(maxSd, sd);\n    }\n    \n    return maxSd;\n}\n\nfloat sdSail(vec2 p, float s)\n{\n    return sdTriangle(\n        p,\n        vec2(vec2(-1.0, 1.0) * s),\n        vec2(vec2(+0.0, 2.0) * s),\n        vec2(vec2(+1.0, 1.0) * s)\n    );\n}\n\nfloat sdFisher(vec2 p)\n{\n    float body = sdRect(p, vec2(0.015, 0.05)) - 0.008;\n    float head = sdCircle(p - vec2(0, 0.09), 0.03);\n    float rod = sdRect((p - vec2(0.05, 0.03)) * rotMat(-1.0), vec2(0.004, 0.1));\n    float line = sdRect(p - vec2(0.13, -0.17), vec2(0.002, 0.25));\n    \n    return opUnion(opUnion(body, head), opUnion(rod, line));\n}\n\nfloat sdHook(vec2 p, float s)\n{\n    float base = opUnion(sdCircle(p, s * 0.7), sdRect(p - vec2(0, -1.5) * s, vec2(0.3, 1.0) * s));\n    float hookCircle = opOnion(sdCircle(p - vec2(0, -3.3) * s, s), 0.2 * s);\n    float mask = sdRect(p - vec2(-1.2, -3) * s, vec2(1, 1.0) * s);\n    float hook = opSubtraction(hookCircle, mask);\n    return opUnion(base, hook);\n}\n\nvec2 flipX(vec2 v) { return vec2(-v.x, v.y); }\n\nfloat waterLevel(float xn, float t)\n{\n    return 0.7 + sin(iTime * 2.0 + xn * 2.3) * 0.03;\n}\n\nfloat waterGradient(float xn, float t)\n{\n    return 2.0 * cos(iTime * 2.0 + xn * 2.3) * 0.03;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel coordinates normalized by the screen height\n    vec2 uvn = fragCoord/iResolution.y;\n    // The screen width normalized by screen height;\n    float nWidth = iResolution.x / iResolution.y;\n    \n    float water = waterLevel(uvn.x, iTime);\n    \n    vec3 col = vec3(0.79);\n    if (uvn.y < water)\n    {\n        //col = vec3(0.193, 0.434, 0.8) * uv.y / waterLevel;\n        col = vec3(0, 0.58, 0.58) * uvn.y / water;\n    }\n    \n    float[] fish = float[](\n        sdMovingFish(uvn - vec2(nWidth * 0.0, 0.12), \t\t0.2, iTime, 0.1, 3.0),\n        sdMovingFish(flipX(uvn - vec2(nWidth * 0.9, 0.2)), \t0.12, iTime, 0.1, 2.0),\n        sdMovingFish(uvn - vec2(nWidth * 0.3, 0.33), \t\t0.1, iTime, 0.3, 6.0),\n        sdMovingFish(flipX(uvn - vec2(nWidth * 0.9, 0.4)), \t0.09, iTime, 0.12, 4.0),\n        sdMovingFish(uvn - vec2(nWidth * 0.6, 0.47), \t\t0.08, iTime, 0.16, 2.3),\n        sdMovingFish(flipX(uvn - vec2(nWidth * 0.7, 0.55)), 0.07, iTime, 0.15, 2.0),\n        sdMovingFish(uvn - vec2(nWidth * 0.2, 0.46), \t\t0.06, iTime, 0.13, 2.0),\n        sdMovingFish(uvn - vec2(nWidth * 0.1, 0.35), \t\t0.05, iTime, 0.17, 2.5),\n        sdMovingFish(flipX(uvn - vec2(nWidth * 0.2, 0.43)), 0.04, iTime, 0.1, 2.7),\n        sdMovingFish(flipX(uvn - vec2(nWidth * 0.7, 0.34)), 0.1, iTime, 0.08, 2.2),\n        sdMovingFish(uvn - vec2(nWidth * 0.3, 0.23), \t\t0.1, iTime, 0.07, 2.3)\n        );\n    \n    for (int i = 0; i < fish.length(); i++)\n    {\n        if (fish[i] < 0.0)\n        {\n            col = vec3(0);\n        }\n    }\n    \n    ///// Boat /////\n    \n    float boatX = nWidth / 2.0;\n    float boatY = waterLevel(boatX, iTime) - 0.03;\n    vec2 boatPos = vec2(boatX, boatY);\n    mat2 boatRot = rotMat(waterGradient(boatX, iTime));\n    \n    vec2 fisherPos = (boatRot * vec2(0.10, 0.10)) + boatPos;\n    fisherPos = round(fisherPos * iResolution.y) / iResolution.y; // Round to nearest pixel\n    \n    if (sdSail((uvn - boatPos) * boatRot, 0.1) < 0.0)\n    {\n        col = vec3(0.93);\n    }\n    \n    if (sdFisher(uvn - fisherPos) < 0.0)\n    {\n        col = vec3(0);\n    }\n    \n    if (sdHook(uvn - fisherPos - vec2(0.13, -0.42), 0.01) < 0.0)\n    {\n        col = vec3(0.5);\n    }\n    \n    if (sdBoat((uvn - boatPos) * boatRot, 0.1) < 0.0)\n    {\n        col = vec3(0.99);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsS3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 57], [58, 58, 100, 100, 122], [123, 123, 164, 164, 187], [188, 188, 228, 228, 256], [258, 258, 284, 284, 373], [375, 375, 408, 408, 436], [438, 438, 469, 469, 994], [996, 996, 1069, 1069, 1163], [1165, 1165, 1195, 1195, 1288], [1290, 1290, 1343, 1343, 1641], [1643, 1643, 1674, 1674, 2315], [2317, 2317, 2348, 2348, 2495], [2497, 2497, 2521, 2521, 2844], [2846, 2846, 2877, 2877, 3204], [3206, 3206, 3226, 3226, 3252], [3254, 3254, 3291, 3291, 3346], [3348, 3348, 3388, 3388, 3443], [3445, 3445, 3502, 3552, 5903]]}
{"id": "tss3zs", "name": "Julia's Lava Lamp", "author": "bignobody", "description": "Same as Julia's Quilt but also animating c based on time. ", "tags": ["juliaset", "orbittrap"], "likes": 1, "viewed": 156, "published": "Public", "date": "1547259481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 p = uv - vec2(0.5,0.5);\n    vec2 z = p * 1.5;\n    vec2 c = vec2(-0.745  + (sin(iTime*0.05)), 0.19 + (sin(iTime*0.05)));\n    float t = 0.0;\n    vec2 bo = vec2(9999.0,9999.0);\n    float bl = 99999.0;\n    vec2 wo = vec2(0.0,0.0);\n    float wl = 0.0;\n    float it = 0.0;\n    float os = 0.0;\n    for (int i = 0; i < 64; i ++)\n    {\n     \tvec2 nz = vec2(z.x*z.x - z.y*z.y, (1.5 - cos(iTime * 0.033)) * z.x * z.y) +c;\n        vec2 no = nz - p;\n        float nl = length(no);\n        os += nl;\n        it += 1.0;\n        if (nl > wl)\n        {\n        \two = no;\n            wl = nl;\n            \n        }\n        if (nl < bl)\n        {\n        \tbo = no;\n            bl = nl;\n            \n        }\n        \n        float m2 = dot(z.x,z.x);\n        if (m2 > 4.0)\n        {\n           // bl = 1.0;\n        \tbreak;   \n        }\n        z = nz;\n        t += 1.0/63.0;\n    }\n    \n\tvec3 tintb = vec3(0.3,0.6,0.8);\n    vec3 tintr = vec3(0.8,0.4,0.1);\n    float avgo = os/it;\n    \n    vec3 col = mix(mix(vec3(t) , tintb, dot(bo,wo)+avgo) , mix(vec3(t) , tintr, sqrt(avgo)) , sqrt(bl));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tss3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1287]]}
{"id": "tssGRX", "name": "Amas globulaire", "author": "Alkama", "description": "Made live shading style.", "tags": ["raymarching", "distancefield", "liveshading"], "likes": 5, "viewed": 484, "published": "Public API", "date": "1547078597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t mod(iTime, 100.)*4.\n#define sat(v) clamp(v, 0., 1.)\n#define spow(v, p) clamp(pow(v, p), 0., 1.)\n\nconst float pi = acos(-1.);\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 40.;\n\nstruct ray {\n  vec3 o, d;\n};\n\nstruct material {\n  vec3 diffuse, specular;\n  float shine;\n};\n\nvec2 repeat(vec2 p, float n) { return mod(p-.5*n, n)-.5*n; }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nmat2 rot(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nfloat torus(vec3 p, vec2 c) {\n  vec2 q = vec2(length(p.xz)-c.x, p.y);\n  return length(q)-c.y;\n}\n\nfloat dist(vec3 p) {\n  vec3 sp = p;\n  sp.xy = repeat(p.xy, 2.);\n  sp.xz = repeat(p.xz, 4.8);\n  sp.xz *= rot(t+p.y*8.)+.2*sin(t*.4);\n  sp.xy *= rot(pi/2.);\n\n  return torus(sp, vec2(1., .5));\n}\n\nray camera(vec2 uv, vec3 eye, vec3 target, float zoom) {\n  ray r;\n  r.o = eye;\n  vec3 f = normalize(target - eye);\n  //vec3 s = normalize(cross(vec3(0,1,0), f));\n  vec3 s = cross(vec3(0,1,0), f);\n  vec3 u = cross(f, s);\n  r.d = normalize(f*zoom + uv.x*s + uv.y*u);\n  return r;\n}\n\nvec2 march(ray r) {\n  float d = 0.;\n  for(int i=0; i<MAX_ITER*5; i++) {\n    float h = dist(r.o+r.d*d)*.1;\n    if(h<0.001*d || d>MAX_DIST) return vec2(d,i);\n    d+=h;\n  }\n  return vec2(d,MAX_ITER);\n}\n\n\nvec3 norm(vec3 p) {\n  vec2 e = vec2(-0.001, 0.001);\n  return normalize(e.xyy*dist(p+e.xyy) + e.yxy*dist(p+e.yxy) + e.yyx*dist(p+e.yyx) + e.xxx*dist(p+e.xxx));\n}\n\nvec3 phong(vec3 p, material m, vec3 eye, vec3 lightPos) {\n  vec3 n = norm(p);\n  vec3 l = normalize(lightPos-p);\n  vec3 v = normalize(eye - p);\n  vec3 rf = normalize(reflect(-l, n));\n\n  vec3 diff = m.diffuse * max(0., dot(n, l));\n  vec3 spec = m.specular * max(0., pow(dot(rf, v), m.shine));\n\n  return diff + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 ruv = uv * (1.-uv);\n  float vig = pow(ruv.x*ruv.y * 15., .8);;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n  uv *= 1.+length(uv)*2.;\n\n  uv.y = abs(uv.y);\n  vec3 eye = vec3(0,1,-2);\n  eye.xz += .1*vec2(sin(cos(t*.05)*8.), cos(sin(t*.04)*12.));\n  vec3 target = vec3(0.,1.+2.*sin(t*.1),0.);\n\n  ray r = camera(uv, eye, target, .3+sin(t*.2)*.04);\n  vec2 m = march(r);\n  if(m.x > MAX_DIST) {\n    fragColor = vec4(0.);\n    return;\n  }\n\n  vec3 p = r.o+r.d*m.x;\n\n  float halo = spow(.5*m.y/float(MAX_ITER), 2.);\n\n  vec3 lightPos = vec3(3,3,-3);\n  lightPos.xz += 20.*vec2(sin(t*.25), cos(t*.5));\n\n  material mta;\n  mta.diffuse = vec3(.14, .3, .9);\n  mta.specular = vec3(1, 0, 0);\n  mta.shine = 5.;\n\n  vec3 color = phong(p, mta, eye, lightPos );\n  color *= halo*20.;\n  color = color*sat(exp(-m.y)) + color*halo;\n\n  color *= vig;\n  fragColor = vec4(pow(color, vec3(1./2.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 313, 313, 343], [344, 344, 364, 364, 398], [399, 399, 418, 418, 466], [468, 468, 497, 497, 563], [565, 565, 585, 585, 756], [758, 758, 814, 814, 1036], [1038, 1038, 1057, 1057, 1236], [1239, 1239, 1258, 1258, 1399], [1401, 1401, 1458, 1458, 1716], [1718, 1718, 1775, 1775, 2747]]}
{"id": "tssGzX", "name": "Fractal Flower", "author": "Jamesika", "description": "Fractal Flower", "tags": ["fractal", "flower"], "likes": 7, "viewed": 385, "published": "Public API", "date": "1547100344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nvec2 ToPolar(vec2 pos)\n{\n   \tfloat r = length(pos);\n    // a (0, 2*PI)\n    float a = atan(-pos.y,-pos.x)+PI;\n    return vec2(r,a);\n}\n\nvec2 Rotate(vec2 pos, float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*pos;\n}\n\nfloat Shake(float from,float to,float rate)\n{\n    return from + (to-from)*(sin(iTime*rate)*0.5+0.5);\n}\n\nvec3 Rgb2hsb(in vec3 c )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 Hsb2rgb(in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Draw a piece of leaf points to RIGHT ((0,0)->(1,0))\n// width (0.,1.)\nfloat DrawLeaf(vec2 pos, float radius, float width)\n{\n    // width = 1 -> angle = 2*PI\n\n    vec2 polar = ToPolar(pos);\n\t// limit distance\n    width *= smoothstep(radius,0.0,polar.x);\n    // limit angle\n    float w = abs(polar.y-PI)/PI;// 0 ~ 1 ~ 0\n    float c = step(1.0-width,w)*0.2 +  smoothstep(1.0-width,1.0,w);\n\n    return c*step(polar.x,radius);\n}\n\n// draw several patterns\nfloat DrawComponents(vec2 pos, float radius)\n{\n    radius *= Shake(1.,1.5,1.);\n    float width = Shake(0.15,0.85,1.5);\n\treturn \n        DrawLeaf(pos, radius, width) + // Basic leaf\n        0.3*DrawLeaf(pos, radius*1.5, pow(width*0.3,1.5)); \t// Thin Leaf\n}\n\nfloat Fbm(vec2 pos, float radius)\n{\n    const int n = 6;\n    \n    vec2 center = vec2(0.0);\n    float angle = PI/4.*Shake(1.0,1.8,1.0);\n    \n    pos.y = abs(pos.y);\n    float c = DrawComponents(pos,radius);\n\tfor(int i = 0;i<n;i++)\n    {\n        // move to next position\n        pos -= vec2(0.8,0.6)*Shake(0.0,0.6,0.5)*radius;\n        pos = Rotate(pos,angle);\n        pos.y = abs(pos.y);\n\n        radius /= 2.*Shake(0.65,1.,1.2);\n       \tc += DrawComponents(pos,radius)*pow(0.5,float(i));\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = 500.0*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n\t\n    pos = Rotate(pos, iTime*0.5+Shake(1.,3.5,1.));\n    \n    const int n = 6;\n    float c = 0.0;\n    for(int i = 0;i<n;i++)\n    {\n    \tpos = Rotate(pos,2.0*PI/(float(n)));\n        c += Fbm(pos, 250.);\n    }\n   \t\n    c = smoothstep(0.0,5.0,c)*2.0;\n    \n    vec2 polar = ToPolar(pos);\n    \n    vec3 backColor = Rgb2hsb(vec3(0.1,0.15,0.2)*0.3);\n    backColor.x = fract(iTime*0.1)+smoothstep(0.0,1000.0,polar.x)*0.1;\n    backColor = Hsb2rgb(backColor);\n    \n    // color it\n    vec3 col = \n        backColor*pow(1.5-length(uv-vec2(0.5)),2.0) + \n        vec3(0.4,0.8,0.88)*pow(c,0.8);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 156], [158, 158, 194, 194, 263], [265, 265, 310, 310, 367], [369, 369, 395, 395, 825], [827, 901, 927, 927, 1159], [1161, 1233, 1286, 1319, 1586], [1588, 1613, 1659, 1659, 1868], [1870, 1870, 1905, 1905, 2378], [2380, 2380, 2437, 2437, 3165]]}
{"id": "tsX3zs", "name": "code golfing simple shader", "author": "bitnenfer", "description": "a small practice for js1k", "tags": ["codegolf"], "likes": 3, "viewed": 145, "published": "Public", "date": "1547185318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime\nvec4 shader(vec2 coord){float D=.01,r,c,s,a,b,h,q;\nvec3 C=vec3(1),RD=normalize(vec3(coord.xy-0.5,1)),P=vec3(0,0,-2.),d,p,RP=vec3(2,0,0);\nfor (int i=0;i<99;++i){p=(P+=RD*(D*.7));\nr=p.y*5.+T;\nc=cos(r),s=sin(r);\na=min(q=length(P*vec3(.5,3.+sin(T)*.2,3.))-.5,length((mod(p,RP)-.5*RP)*vec3(2.5,1,1))-(1.1+.08*sin(T)));\np.xz*=mat2(c,s,-s,c);\nd=abs(p*vec3(1,sin(T+P.y*2.),1))-vec3(.3,9,.3);\nb=length(max(d,0.))-min(max(d.x,max(d.y, d.z)),0.);\nh=clamp(.5+.5*(a-b)/.7,0.,1.);\nD=mix(a,b,h)-.7*h*(1.-h);\nif (D<.01) {\nC=vec3((1.-max(.0, float(i)/90.))*.7);\nC-=vec3(1,.4,.1)*max(.12,pow(max(dot(RD+vec3(.5*sin(T),0,0),normalize(P)),.001),.4));\nC=1.-C;\nbreak;}}\nC = mix(C, vec3(0,0,1), max(0.0, pow(length(1.*RD.xy), 3.)));\nreturn vec4(C,1);}\n\n// Shadertoy entry point \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = shader(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsX3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 40, 40, 744], [746, 772, 829, 879, 974]]}
{"id": "tsXGDl", "name": "Latihan 7", "author": "dennyraymond", "description": "Sierpinski Triangle Fractal - manuals way :)", "tags": ["triangle", "simpletriangle", "2dtriangle", "cgk3", "sierpinskitrianglefractal"], "likes": 2, "viewed": 282, "published": "Public API", "date": "1547778025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band (float t, float start, float end, float blur){\n  float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    float stepFinal = step1 * step2;\n    return stepFinal;\n}\n\nfloat rectangle (vec2 uv, float blur, float left, float right, float bottom, float top) {\n    float r;\n    r = Band (uv.x, left, right, blur);\n    r *= Band (uv.y, bottom, top, blur);\n    return r;\n}\n\nfloat triangle1 (vec2 uv, float blur, float point) {\n    float t = uv.y;\n    // times with 2 to get the isoceles triangle shape\n    return rectangle (uv*2., blur, -point+t, point-t, -point-t, point+t);\n}\n\nfloat triangle2 (vec2 uv, float blur, float point) {\n    float t = uv.y*-1.;\n    return rectangle (uv*2., blur, -point+t, point-t, -point-t, point+t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5; //move center\n    uv.x*= iResolution.x/iResolution.y;\n    float x = uv.x;\n    float y = uv.y;\n    float try;\n    //vec3 col1, col2, col3;\n    \n    try = triangle1(vec2(x,y+.2), 0.001, .6);\n    float tri1 = triangle2(vec2(x,y+.1), 0.0001, .3);\n    float tri2 = triangle2(vec2(x-.2,y+.25), 0.001, .15);\n    float tri3 = triangle2(vec2(x+.2,y+.25), 0.001, .15);\n    float tri4 = triangle2(vec2(x,y-.15), 0.001, .15);\n    float tri5 = triangle2(vec2(x,y-.275),0.001, .075);\n    float tri6 = triangle2(vec2(x+.1,y-.075), 0.001, .075);\n    float tri7 = triangle2(vec2(x-.1,y-.075), 0.001, .075);\n    float tri8 = triangle2(vec2(x+.2,y+.125), 0.001, .075);\n    float tri9 = triangle2(vec2(x-.2,y+.125), 0.001, .075);\n    float tri10 = triangle2(vec2(x+.3,y+.325), 0.001, .075);\n    float tri11 = triangle2(vec2(x+.1,y+.325), 0.001, .075);\n    float tri12 = triangle2(vec2(x-.1,y+.325), 0.001, .075);\n    float tri13 = triangle2(vec2(x-.3,y+.325), 0.001, .075);\n    float tot = tri1 + tri2 + tri3 + tri4 + tri5 + tri6 + tri7 + tri8 + tri9 + tri10 + tri11 + tri12 + tri13;\n    \n    vec3 col = vec3(1); // bg color\n \n    vec3 col1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); // time varying color\n    \n    //col += vec3(1.0,1.0,0)*try;\n    col -= col1*try; // color for big1 triangle\n   // col += vec3(0);\n    col += col1*tot; // color for inside triangle\n    \n\t//col += col1 + col2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 226], [228, 228, 317, 317, 427], [429, 429, 481, 481, 632], [634, 634, 686, 686, 786], [788, 788, 845, 895, 2379]]}
{"id": "tsXGWB", "name": "PewDiePie Texture", "author": "scratch13764", "description": "Procedural shader to produce the signature texture of PewDiePie using sinewave distortion and radial sampled MSAA.", "tags": ["texture", "msaa", "pewd"], "likes": 7, "viewed": 455, "published": "Public", "date": "1547343792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Tau 6.2831853071\n\nvec4 pewd (vec2 b){\n    b.x *= iResolution.x/iResolution.y;\n    b.x += sin(b.y*3.)/15.* sin(.75 + iTime/3.5)*1.3 + iTime/28.;\n    b.y += sin(b.x*4.)/3. - iTime/40. + sin(iTime/8.5);\n    \n    vec4 a = vec4(0);\n    \n    if (mod(b.y + b.y, .2) <= .1)\n    a = vec4(.9608,0,.3647,1);\n        \n    return a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = .5/iResolution.xy;\n    vec4 a = vec4 (0);\n    \n    a += pewd(uv); //centered samples\n    \n    for (float i = 0.; i < Tau; i += Tau/10.) //radial samples\n    {\n        a += pewd(uv + \n                    vec2(sin(i),cos(i))*p\n                    );\n    }\n    \n    fragColor = a/11.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 329], [332, 332, 389, 389, 726]]}
{"id": "tsXGWl", "name": "Simple diffuse nebula", "author": "WB", "description": "Another procedural nebula with simple emission and anisotropic scattering approximation.", "tags": ["raymarching", "space", "volumetric", "nebula", "scattering"], "likes": 7, "viewed": 1143, "published": "Public", "date": "1547840114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 128\n#define STEP_SIZE 0.05\n#define _FoV 45.0\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Absorption = vec3(0.9,0.7,0.5);\nconst vec3 _Emission = vec3(0.3,0.15,0.0);\nconst vec3 _Light = vec3(1.0,1.0,1.0);\nconst vec3 _LightPos = vec3(0.0, 0.0, 0.0);\nconst float _LightIntensity = 0.2;\nconst float _Density = 9.0;\nconst float _Radius = 1.0;\nconst float _Mie = 0.6;\nconst float _G = 0.2;\n\n//Cornette-Shanks phase function\nfloat phase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Otavio Good's fast spiral noise from https://www.shadertoy.com/view/ld2SzK\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\n//Fractal (pink) noise function S(f) ∝ 1/f^α, {0 <= α <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\n//Density distribution function\nfloat sampleVolume(vec3 pos)\n{\n    float rr = dot(pos,pos);\n    rr = sqrt(rr);\n    float f = exp(-rr);\n    float p = f * _Density;\n    \n    if (p <= 0.0)\n        return p;\n    \n    p += SpiralNoiseC(512.0 + pos * 8.0) * 0.75;\n    pos = rotateY(pos, pos.y * SpiralNoiseC(pos * 4.0)* 2.0);\n    p += SpiralNoiseC(200.0 + pos * 3.0) * 1.5;\n    p *= rr/_Radius;\n        \n    p = max(0.0,p);\n                \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = _LightIntensity/dot(r, r);\n            vec3 ext = max(vec3(0.000001), (_Absorption * p) + vec3(_Mie * p));\n            vec3 trans = exp(-ext * ds);\n            vec3 lightDir = normalize(r);\n            float mu = dot(lightDir, dir);\n            float phase = phase(mu, _G);\n            vec3 lum = _Emission + _Light * phase * (1.0-_Absorption) * _Mie * p * atten;\n            vec3 integral = (lum - (lum*trans))/ext;\n            \n            result.rgb += integral * result.a;\n            vec3 div = vec3(0.3333333);\n            result.a *= dot(trans, div);\n            \n            if (result.a <= 0.1)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n        \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    \n    #ifdef ROTATE\n\tfloat t = iMouse.x * 0.01 + iTime * 0.1;\n    #else\n    float t = iMouse.x * 0.01;\n    #endif\n    \n    rayDir = rotateY(rayDir, t);\n    rayOrigin = rotateY(rayOrigin, t);\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    //col.rgb += smoothstep(0.45, 0.9, abs(noise(rayDir * 256.0)));\n    float star = smoothstep(0.45, 0.8, abs(noise(rayDir * 256.0)));\n    col.rgb += star * mix(vec3(1.0,0.7,0.2),vec3(0.0,0.5,1.0), star);\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {   \n        p0 = (dot(rayOrigin, rayOrigin) < dot(p0, p0)) ? rayOrigin : p0;\n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 436, 468, 468, 592], [594, 620, 706, 706, 1160], [1162, 1187, 1218, 1218, 1412], [1414, 1436, 1457, 1457, 1626], [1628, 1628, 1654, 1654, 2479], [2481, 2733, 2761, 2761, 3310], [3312, 3375, 3433, 3433, 3597], [3599, 3631, 3661, 3661, 4049], [4051, 4051, 4103, 4103, 5071], [5073, 5341, 5398, 5398, 6986]]}
{"id": "tsXGWs", "name": "Ecolocation Simulation", "author": "saabi", "description": "Rough ecolocation of a pulse with five microphones.\n\nYou can add or remove mikes, or change their position, to see how it affects the response (by copying and pasting or commenting for now)\n\nReal ecolocation with three mikes can be more precise than this.", "tags": ["ecolocationsimulation"], "likes": 4, "viewed": 117, "published": "Public", "date": "1547778689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ecolocating the direction of a pulse with four virtual microphones\n\n\nconst float PI = 3.141592;\nconst vec2 SOURCE = vec2(38.0, 26.0);\n\nconst vec2 MIC0 = vec2(-1.0, 1.0);\nconst vec2 MIC1 = vec2(-1.0, -1.0);\nconst vec2 MIC2 = vec2(1.0, 1.0);\nconst vec2 MIC3 = vec2(1.0, -1.0);\nconst vec2 MIC4 = vec2(0.0, 0.0);\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat cmag(float dist) {\n\tfloat phase = dist*2.0 - iTime*10.0;\n\tfloat mp = mod(phase, PI * 30.0);\n\treturn (mp > 0.0 && mp < PI*1.0) ? sin(phase)/*(dist*dist)*/ : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n\tpos -= 0.5;\n\tpos.x *= aspect;\n\tpos *= 60.;\n\t\n\tfloat mag = cmag(length(pos+SOURCE));\n\tfloat mag0 = cmag(length(MIC0-SOURCE)+length(pos+MIC0));\n\tfloat mag1 = cmag(length(MIC1-SOURCE)+length(pos+MIC1));\n\tfloat mag2 = cmag(length(MIC2-SOURCE)+length(pos+MIC2));\n\tfloat mag3 = cmag(length(MIC3-SOURCE)+length(pos+MIC3));\n\tfloat mag4 = cmag(length(MIC4-SOURCE)+length(pos+MIC4));\n\n\tvec3 color = vec3( mag );\n\tcolor += vec3( mag0, mag1, mag2 );\n\tcolor += vec3( mag3, mag3, 0 );\n\tcolor += vec3( 0, mag4, mag4 );\n\n    if (mag0+mag1+mag2+mag3+mag4 > 4.8) color = vec3(0.0);\n\telse if (mag0+mag1+mag2+mag3+mag4 > 4.5) color *= 1.0;\n\telse color /= 6.0;\n\n    if (length(pos-SOURCE) < 0.2) color = vec3(1.0,0.0,0.0);\n\tif (length(pos+SOURCE) < 0.2) color = vec3(1.0,0.0,0.0);\n\tif (length(MIC0+pos) < 0.2) color = vec3(1.0,0.0,0.0);\n\tif (length(MIC1+pos) < 0.2) color = vec3(0.0,1.0,0.0);\n\tif (length(MIC2+pos) < 0.2) color = vec3(0.0,0.0,1.0);\n\tif (length(MIC3+pos) < 0.2) color = vec3(1.0,1.0,0.0);\n\tif (length(MIC4+pos) < 0.2) color = vec3(0.0,1.0,1.0);\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 379, 403, 403, 547], [549, 549, 606, 606, 1777]]}
{"id": "wd23DD", "name": "FirstTestingShader", "author": "quicksilver", "description": "I'm using shadertoy to try and learn GLSL. This is my first experiment shader on this platform. ", "tags": ["test"], "likes": 2, "viewed": 42, "published": "Public", "date": "1548953805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //noise \n    float noise = fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    \n    //alter the normalized pixel coordinates so its more centered to the screen\n    uv -= .5;\n    \n    //alter the shape along the y or x axis (choice is yours).\n    //uv.x makes it more circular. uv.y makes it a stretched, thinner oval. \n    uv.y *= (iResolution.x / 1.185 )/(iResolution.y * 2.5);\n    \n    //stretch the shape along the uv x axis \n    uv.x *= 5.*cos(iTime / 2.)  + noise;\n    //stretch the shape along the uv y axis\n    uv.y *= -5. * sin(iTime / 2.) + noise;\n    \n    //gets the length of the vector of normalized pixel coordinates\n    float leng= length(uv);\n    \n    //if length value is less than 0.3\n    if(leng < 0.3)\n        //make it white\n        leng = 1.;\n    \t\n    //this adds another range of colour (grey)\n    else if (0.3 < leng && leng <= .6)\n        leng = 0.5;\n    else\n        //make it black\n        leng = 0.;\n\n    // Output to screen\n    fragColor = vec4(vec3(leng * col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1255]]}
{"id": "Wd23R1", "name": "Lambert Torus", "author": "valler", "description": "Lambert", "tags": ["ray", "distance", "lambert", "field", "march"], "likes": 1, "viewed": 113, "published": "Public", "date": "1548163257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat f (vec3 p)\n{\n    return sdTorus(p,vec2(1.,.5));\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( vec3 p, float t )\n{\n    float e = 1.e-3*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*f( p + h.xyy*e ) + \n\t\t\t\t\t  h.yyx*f( p + h.yyx*e ) + \n\t\t\t\t\t  h.yxy*f( p + h.yxy*e ) + \n\t\t\t\t\t  h.xxx*f( p + h.xxx*e ));\n}\n\nvec3 bg (vec2 p)\n{    \n    return normalize(vec3(fract(fract(p*.5)+sin(p.yx)),1.3)*.5-.5);\n}\n\nvec3 lambert (vec3 c, vec3 n, vec4 l)\n{\n\treturn max(0.,dot(n,l.xyz))*c*l.w;\n}\n\nvoid mainImage( out vec4 c, in vec2 a )\n{\n    vec2 s = (a-.5*iResolution.xy)/iResolution.x;\n    vec3 o = vec3(0,3.,0);\n    vec3 y = vec3(0,1,0);\n    vec3 w = normalize(-o);\n    if (abs(dot(o,y)) > .999) y = y.yxx;\n    vec3 u = normalize(cross(w,y));\n\tvec3 d = mat3(u,cross(u,w),w) * normalize(vec3(s,.25));\n    float t = 0., e = 1.e-4, h = 1.;\n    vec3 p = o+d*t;\n    float m = 1.e6;\n    while (t < m)\n    {\n        h = f(p);\n        if (h < e) break;\n        t = min(m,t+h);\n        p = o+d*t;\n    }\n    vec4 l = vec4(normalize(vec3(cos(iTime*.2),1,sin(iTime*.2))),1);\n    vec3 k = calcNormal(p,t);\n    vec3 n = t > e && t < m ? lambert(vec3(.025),k,l) : lambert(vec3(.5),-bg(10.*s),l);\n    c = vec4(sqrt(n),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 103, 103, 168], [170, 170, 188, 188, 225], [227, 291, 327, 327, 534], [536, 536, 554, 554, 628], [630, 630, 669, 669, 707], [709, 709, 750, 750, 1423]]}
{"id": "Wd23RD", "name": "Jungle", "author": "gaz", "description": "3d", "tags": ["raymarching", "fractal"], "likes": 8, "viewed": 401, "published": "Public", "date": "1548334698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat pattern(vec2 p)\n{\n    p *= 15.0;\n    return abs(sin(p.x) + sin(p.y));\n}\n\nfloat boxmap(vec3 p)\n{\n    p *= 0.3;\n    vec3 m = pow(abs(normalize(p)), vec3(20));\n    vec3 a = vec3(pattern(p.yz),pattern(p.zx),pattern(p.xy));\n\treturn dot(a,m)/(m.x+m.y+m.z);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    float k = 0.08;\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 sabs(vec3 p)\n{\n \treturn  p - 2.0 * smin(vec3(0), p); \n}\n\nfloat map(in vec3 p)\n{  \n    float s = 3.7;\n    float amp = 1.0/s;\n    float c = 0.5;\n    p = sabs(mod(p, c * 2.0) - c); \n    float de = 100.;\n    for(int i=0; i<3; i++){\n        p.xy *= rotate(0.4+sin(iTime*0.2+ 0.3*sin(iTime*0.4))*0.2);\n        p.yz *= rotate(0.4+sin(iTime*0.3+ 0.5*sin(iTime*0.5))*0.2);\n        p = sabs(p); \n        p *= s;\n        p -= vec3(0.2*p.z, 0.6*p.x, 0.4) * (s - 1.0);\n\t    de = abs(length(p*amp) - 0.2) ;\n        amp /= s;\n    }   \n    return de + boxmap(p) * 0.02 - 0.01;\n}\n\nvec3 calcNormal(vec3 p){\n  vec2 e = vec2(1, -1) * 0.001;\n  return normalize(\n    e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n    e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx)\n  );\n}\n\nvec3 doColor(vec3 p){\n\treturn vec3(0.2,0.9,0.2) * boxmap(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.2, 0.1, 0.5)+iTime*0.1;\n    vec3 rd = normalize(vec3(p, 2));\n    rd.xz *= rotate(sin(iTime*0.3)*0.6);\n    rd.yz *= rotate(sin(iTime*0.2)*0.6);\n    rd.xy *= rotate(sin(iTime*0.05));   \n    vec3 col = mix(\n        vec3(0.3, 0.7, 0.8),\n        vec3(0.1, 0.1, 0.2),\n        smoothstep(0.3, 2.5, length(p)));    \n    float t = 0.1, d;\n \tfor(int i = 0; i < 300; i++)\n  \t{\n        d = map(ro + rd * t);\n    \tt += 0.1 * d;\n    \tif(d < 0.001 || t > 5.0) break;\n  \t}\n  \tif(d < 0.001)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        vec3 c = doColor(p);\n        c *= clamp(dot(nor, li), 0.3, 1.0);\n        c *= max(0.5 + 0.5 * nor.y, 0.0);\n        c += pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 20.0);\n        c.x +=1.0- exp(-t*t*0.15);\n        c = clamp(c,0.0,1.0);\n        col = mix(col,c,exp(-t*t*0.6));\n    }\n  \tcol = pow(col, vec3(0.8));\n    col= mix(col, vec3(col.x), clamp(sin(iTime*0.5 + sin(iTime*0.2)*0.5)*2.0-1.0, 0.0, 1.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd23RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 74], [76, 76, 99, 99, 153], [155, 155, 177, 177, 334], [336, 336, 363, 363, 471], [473, 473, 492, 492, 533], [535, 535, 557, 557, 1040], [1042, 1042, 1066, 1066, 1211], [1213, 1213, 1234, 1234, 1275], [1277, 1277, 1334, 1334, 2456]]}
{"id": "wd23RR", "name": "Broken voronoi ", "author": "theepicsnail", "description": "Trying to build a 3d voronoi  but it's broken :(", "tags": ["voronoi"], "likes": 3, "viewed": 144, "published": "Public", "date": "1548020364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define MAX_DIST 20.0\n#define EPS 0.0001\n#define ITR 100.0\n#define SDF_RESULT vec2\nvec2 normal_delta = vec2(.01,0);\nvec3 cell_delta = vec3(-1,0,1);\n\nvec3 lastCell = vec3(0);\nvec2 rotate(vec2 v, float angle) { return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nvec2 rand2(vec2 co) { return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);}\nfloat rand3(vec3 co) { return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);}\nmat3 lookat(vec3 fw) { fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 vpos(vec3 cell) {\n    vec3 angle = iTime*cos(cell*123.93);\n    vec3 innerPos = cos(angle+rand3(cell))*0.5+.5;\n    return cell+innerPos;\n}\n\nSDF_RESULT SDF(vec3 ro, vec3 rd) {\n    vec4 d1 = vec4(MAX_DIST);\n    vec4 d2 = vec4(MAX_DIST);\n    vec4 d3 = vec4(MAX_DIST);\n    ro -= .5;\n    for(int dx = -1; dx <= 1; dx++)\n    for(int dy = -1; dy <= 1; dy++)\n    for(int dz = -1; dz <= 1; dz++) {\n        vec3 local_cell = floor(ro)+vec3(dx,dy,dz);\n        vec3 pos = vpos(local_cell);\n        float dist = length(pos-ro);\n        \n        if(dist < d1.w) {\n            d3 = d2;\n            d2 = d1;\n            d1 = vec4(pos, dist);\n            lastCell = local_cell;\n        }else if(dist < d2.w) {\n            d3 = d2;\n            d2 = vec4(pos, dist);\n        }else if(dist <d3.w) {\n            d3 = vec4(pos, dist);\n        }\n    }\n    \n    //vec3 mid = (d1+d2+d3).xyz/3.0;\n    //vec3 dir = normalize(cross((d2-d1).xyz, (d3-d1).xyz));\n    //return vec2(length(cross(dir,mid-ro))-.01,0);\n    \n    //return vec2( length(ro-d1.xyz-.5)-.1 );\n    //return vec2(length(ro-mid)-.1,0);\n    return vec2(max(d2-d1,d3-d2).w-.01,0);\n}\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+normal_delta.xyy, rd).x-SDF(ro-normal_delta.xyy, rd).x;\n    float cy = SDF(ro+normal_delta.yxy, rd).x-SDF(ro-normal_delta.yxy, rd).x;\n    float cz = SDF(ro+normal_delta.yyx, rd).x-SDF(ro-normal_delta.yyx, rd).x;\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    SDF_RESULT result;\n    for(; i < ITR ; i++) {\n        result = SDF(pos=ro+rd*t,rd);\n           result *= .5;\n        t += d = result.x;\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 cell = lastCell;\n    vec3 normal = EstNormal(pos, rd);\n    vec3 color = hsv2rgb(vec3(rand3(cell),1,1));\n    if (i + 1. <= ITR)\n    \treturn color*dot(normal,-rd)/sqrt(t);\n    else\n        return vec3 (0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    ro.yz *= .2;\n    ro.yz += .5;\n    ro.x += iTime*.5;\n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 226, 226, 274], [275, 275, 296, 296, 363], [364, 364, 385, 385, 490], [491, 491, 513, 513, 589], [590, 590, 612, 612, 710], [712, 712, 734, 734, 903], [905, 905, 927, 927, 1047], [1049, 1049, 1083, 1083, 2028], [2030, 2030, 2064, 2064, 2338], [2340, 2340, 2379, 2379, 2900], [2902, 2902, 2959, 2959, 3385]]}
{"id": "wd23zz", "name": "BuRiSaBa", "author": "tatsunoru", "description": "BuRiSaBa", "tags": ["circle", "magic"], "likes": 16, "viewed": 331, "published": "Public", "date": "1548071150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI05 (M_PI * 0.5)\n\nvec2 rotate(vec2 v, float c, float s){\n\treturn vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\n\nvec2 rotate(vec2 v, float r){\n\treturn rotate(v, cos(r), sin(r));\n}\n\nfloat boxLength(vec2 pos) {\n\tvec2 q = abs(pos);\n\treturn max(q.x, q.y);\n}\n\nfloat capsuleLength(vec2 pos, vec2 dir) {\n\tvec2 ba = -dir;\n\tvec2 pa = pos + ba;\n\tba *= 2.0;\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n} \n\nfloat triangleLength(vec2 p) {\n    p.y += 0.32;\n\treturn max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\n\nvec2 fracOrigin(vec2 v){\n\treturn (fract(v) - 0.5) * 2.0;\n}\n\nfloat Bu(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);  \n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Ri(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(-0.5, 0.0), vec2(0.0, 1.0));   \n \tfloat b = capsuleLength(pos + vec2(0.0, 0.0), vec2(0.1, -0.8) * 0.4);    \n    return min(a, b);\n}\n\nfloat To(vec2 pos){ \t\n    float a = capsuleLength(pos + vec2(0.0, -0.7), vec2(0.5, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(-0.3, -0.3), vec2(0.3, 1.3));  \n    float c = capsuleLength(pos + vec2(0.3, -0.5), vec2(0, 0.5)); \n    return min(min(a, b), c);\n}\n\nfloat Ba(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.8, 0.0), vec2(0.3, 1.0));   \n \tfloat b = capsuleLength(pos + vec2(-0.8, 0.0), vec2(-0.3, 1.0));     \n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Burisaba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Bu(pos)\n     + power / Ri(pos + vec2(-3.0, 0.0))\n     + power / To(pos + vec2(-6.0, 0.0))\n     + power / Ba(pos + vec2(-9.0, 0.0))\n        ;\n    \n    return ret;\n}\n\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 0.5;\n    return smoothstep(lower - width, lower, value) * (1.0 - smoothstep(upper, upper + width, value));\n}\n\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\n\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\n\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos * 0.5);\n    float triangle = triangleLength(pos * 0.3);    \n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\n\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * M_PI05 : atan(y, x);\n}\n\nvec2 polar(vec2 uv) {\n\tfloat r = length(uv);\n\tfloat s = atan2(uv.y, uv.x) / M_PI;\n\treturn vec2(r, s);\n}\n\nfloat BurisabaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -iTime) * 0.75);\n    return Burisaba(mod(rotate(pp * vec2(2.0, 32.0), M_PI05), vec2(16.0, 4.0)) - 1.5, 0.05) * smoothstepLine(6.0, 7.5, pp.x, 1.5);\n}\n\nfloat BurisabaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Burisaba(mod(rotate(pp * vec2(x, y), M_PI05), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 20.0;     \n      \n    uv *= clamp(iTime * 0.25, 0.0, 1.0);\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n        \n    uv = rotate(uv, iTime * 0.3);\n    \n    vec2 c2 = circleTriangle2(uv * 1.4 + vec2(0.0, 8.0));\n    vec2 c3 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), M_PI * 2.0 * 0.3333));\n    vec2 c4 = circleTriangle2(uv * 1.4 + rotate(vec2(0.0, 8.0), M_PI * 2.0 * 0.6666));\n    \n    float mask = c2.x * c3.x * c4.x;\n    \n    float len = length(uv);\n    \n    col.g = BurisabaCircle(uv)\n  \t\t\n        + (BurisabaCircle2(uv, 0.995, 8.0, 64.0, 12.0, 4.0, 7.5, 8.0, 5.0 + iTime * 0.2)\n        + smoothLine(len, 8.0, 0.02)\n        + smoothLine(len, 7.5, 0.02)\n        \n        + BurisabaCircle2(uv, 1.1, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 5.0 + iTime * 0.7)\n        + BurisabaCircle2(uv, 1.2, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + iTime * 0.1564)\n        \n        + BurisabaCircle2(uv, 1.45, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 15.0 + iTime * 0.2418654)\n        + smoothLine(len, 5.0, 0.02)\n        + smoothLine(len, 5.5, 0.02)\n        \n        + BurisabaCircle2(uv, 2.15, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 35.0 + iTime * 0.34685)\n        + BurisabaCircle2(uv, 2.25, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 135.0 + iTime * 0.114)\n        + BurisabaCircle2(uv, 1.8, 8.0, 64.0, 12.0, 4.0, 7.5, 7.9, 532.0 + iTime * 0.54158)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05 * 0.0 - iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05 * 0.25 - iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05 * 0.5 - iTime * 0.5)) - 4.5)\n        + 0.005 / abs(boxLength(rotate(uv, M_PI05 * 0.75 - iTime * 0.5)) - 4.5)\n        + 0.1 / abs(boxLength(uv * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, M_PI * 2.0 * 0.3333) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n        + 0.1 / abs(boxLength(rotate(uv, M_PI * 2.0 * 0.6666) * vec2(8.0, 0.5) - vec2(0.0, 2.9)) - 1.0)\n           \n          ) * mask\n      \n        + circleTriangle(uv) \n        + c2.y\n    \t+ c3.y\n     \t+ c4.y\n        ;\n   \n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy) + vec4(col, 1.0);\n        \n    //fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd23zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 115, 115, 161], [163, 163, 192, 192, 229], [231, 231, 258, 258, 303], [305, 305, 346, 346, 468], [471, 471, 501, 501, 579], [581, 581, 605, 605, 639], [641, 641, 660, 660, 937], [939, 939, 958, 958, 1127], [1129, 1129, 1148, 1148, 1389], [1391, 1391, 1410, 1410, 1682], [1684, 1684, 1722, 1722, 1921], [1923, 1923, 1996, 1996, 2118], [2120, 2120, 2177, 2177, 2219], [2221, 2221, 2278, 2278, 2353], [2355, 2355, 2386, 2386, 2556], [2558, 2558, 2589, 2589, 2730], [2732, 2732, 2769, 2769, 2824], [2826, 2826, 2847, 2847, 2929], [2931, 2931, 2962, 2962, 3144], [3146, 3146, 3264, 3264, 3438], [3440, 3440, 3497, 3497, 5725]]}
{"id": "Wd2GD1", "name": "practice-15", "author": "kiyamada96", "description": "fbm practice", "tags": ["fbm"], "likes": 6, "viewed": 153, "published": "Public", "date": "1548755379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 5\n\nfloat random(in vec2 st)\n{\n\treturn fract(sin(dot(st.xy,vec2(12.443,78.4)))*43758.2);\n}\n\nfloat noise(in vec2 st)\n{\n\tvec2 i=floor(st);\n    vec2 f=fract(st);\n    float a=random(i);\n    float b=random(i+vec2(1.0,0.0));\n    float c=random(i+vec2(0.0,1.0));\n    float d=random(i+vec2(1.0,1.0));\n    \n    vec2 u=smoothstep(0.0,1.0,f);\n    return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n    \n}\n\nfloat fbm(vec2 p)\n{\n\tfloat result=0.0;\n    float amplitude=1.0;\n    \n    for(int i=0;i<OCTAVES;i++)\n    {\n    \tresult+=amplitude*noise(p);\n        amplitude*=0.5;\n        p*=2.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y+vec2(iTime*0.05);\n    \n    vec2 q=vec2(0.);\n    q.x=fbm(p+vec2(0.));\n    q.y=fbm(p+vec2(1.));\n    \n    vec2 r=vec2(0.);\n    r.x=fbm(p+(4.*q)+vec2(1.9,9.2)+(0.15*iTime));\n    r.y=fbm(p+(4.*q)+vec2(8.3,2.8)+(0.12*iTime));\n    \n    float f=fbm(p+4.*r);\n    fragColor = vec4(f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2GD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 45, 45, 105], [107, 107, 132, 132, 412], [414, 414, 433, 433, 618], [620, 620, 677, 677, 1010]]}
{"id": "Wd2GDW", "name": "RXR ", "author": "jpupper", "description": "Kind of discover this kind of patterns by accident.\n\nI called it rxr because is a ridgedMF inside a ridgedMF from this link while working with thebookofshaders :\n\nHere´s the link to the original rigedMF https://thebookofshaders.com/edit.php#13/ridge.frag ", "tags": ["noise"], "likes": 14, "viewed": 994, "published": "Public API", "date": "1548890238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//RXR shader. \n\n\n\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\n//SCALE\nmat2 scale(vec2 _scale){\n    mat2 e = mat2(_scale.x,0.0,\n                0.0,_scale.y); \n    return e;\n}\n\n//SNOISE\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 4\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat time = iTime;\n    \n    //fixed aspect radio\n    float fx = iResolution.x/iResolution.y;\n    uv.x *= fx;\n    \n    vec2 p = vec2(0.5*fx,0.5) - uv;\n    \n    //define radius and angle\n    float r = length(p);\n    float a = atan(p.x,p.y);\n    \n    //Make a snoise\n    float n = snoise(vec2(uv.x*100.,uv.y*100.+iTime)*0.002) ;\n    \n    //This is where the magic happens : A ridgedMF inside a ridgedMF\n    float e = ridgedMF(vec2(0.5,0.5)\n             *(ridgedMF(vec2(uv.x*0.8,uv.y*0.5-time*0.1)))\n             +n\n             *ridgedMF(vec2(uv.x*1.,uv.y+time*0.002)\n             *ridgedMF(vec2(uv.x*0.5,uv.y*0.5+time*0.02))));\n    \n    \n    //VERSION 2 :\n    /*e = ridgedMF(vec2(uv.x*0.5*uv.y,uv.y*0.5)\n             *(ridgedMF(vec2(uv.x*2.2,uv.y*2.0+time*0.01)))\n             +n\n             *ridgedMF(vec2(uv.x,uv.y)*ridgedMF(vec2(uv.x*0.5,uv.y*0.5-time*0.002))));\n    */\n    //simplify version : \n\t//e = ridgedMF(vec2(ridgedMF(uv)));\n    \n    \n    //Some colors: \n    vec3 col1 = vec3(0.1,0.1,0.4);\n    vec3 col2 = vec3(0.5,0.8,1.-r);\n \n    //mixing color1 and color2 with the pattern\n    vec3 fin = mix(col1,col2,e);\n         //fin = vec3(smoothstep(0.2,0.9,fin));\n         //fin = hsb2rgb(vec3(e,1.0,1));\n    \n    fragColor = vec4(fin,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2GDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 44, 65, 65, 112], [113, 113, 134, 134, 181], [182, 182, 204, 204, 239], [242, 250, 274, 274, 354], [356, 365, 387, 440, 2137], [2158, 2246, 2282, 2282, 2427], [2429, 2429, 2453, 2453, 2859], [2860, 2860, 2886, 2886, 3118], [3145, 3145, 3202, 3252, 4540]]}
{"id": "Wd2GRR", "name": "3dCross grid", "author": "theepicsnail", "description": "Flying through a grid of crosses", "tags": ["asdf"], "likes": 7, "viewed": 204, "published": "Public", "date": "1547971084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define MAX_DIST 10.0\n#define EPS 0.0001\n#define ITR 100.0\nvec2 delta = vec2(.01,0);\nvec3 lastCell = vec3(0);\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 co){\n    return fract(sin(vec2(dot(co.xy ,vec2(12.9898,78.233)),dot(co.yx,vec2(13.1898,73.231)))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 49.566))) * 43758.5453);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SDF(vec3 ro, vec3 rd) {\n    float d =MAX_DIST;\n    vec3 c = ro + .5;\n    lastCell = floor(c);\n    ro=fract(c)-.5;\n    \n    float t = iTime*.8 + length(lastCell)*.3;\n    float p = fract(t);\n    float r = p;//length(lastCell);\n    r *= PI / 2.0;\n    switch(int(mod(t,3.0))){\n        case 0: ro.xy = rotate(ro.xy,r); break;\n        case 1: ro.yz = rotate(ro.yz,r); break;\n        case 2: ro.zx = rotate(ro.zx,r); break;\n    }\n    \n    t= min(.1,length(ro.xy));\n    d = min(d, length(ro)*.1);\n    d = min(d, length(ro.xy)-t);\n    d = min(d, length(ro.yz)-t);\n    d = min(d, length(ro.zx)-t);\n    d = max(d, length(ro)-.45);\n    return d;\n}\n\n\nvec3 EstNormal(vec3 ro, vec3 rd) {\n    float cx = SDF(ro+delta.xyy, rd)-SDF(ro-delta.xyy, rd);\n    float cy = SDF(ro+delta.yxy, rd)-SDF(ro-delta.yxy, rd);\n    float cz = SDF(ro+delta.yyx, rd)-SDF(ro-delta.yyx, rd);\n    return normalize(vec3(cx,cy,cz));\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 p = ro;\n    float t;\n    float d;\n    float i = 0.0;\n    float c = 1.0;\n    vec3 pos;\n    for(; i < ITR ; i++) {\n    \tt += d = SDF(pos=ro+rd*t,rd);\n        c = min(d,c);\n        if(t > MAX_DIST || d < EPS) break;\n    }\n   \tvec3 cell = lastCell;\n    vec3 normal = EstNormal(pos, rd);\n    \n    \n    vec3 lightPos = ro + vec3(sin(iTime),cos(iTime),cos(iTime*.1))*100.0;\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightColor = hsv2rgb(vec3(iTime*.1,.5+.5*sin(iTime*.2),1));\n    float lightDist = length(lightPos-pos)+length(ro-pos);\n    float l = -dot(normal, lightDir);\n    //float l = clamp(0.0,1.0,dot(reflect(rd,normal), normalize(lightPos)));\n    \n    vec3 color = hsv2rgb(vec3(rand3(cell),1,1));\n    return color*(lightColor/lightDist + dot(normal,-rd)/t);\n    //return fract(ro+rd*t)/d*.02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat tim=iTime;\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\ttim*=0.5;\n\tvec3 ro=vec3(cos(tim),cos(tim*0.3)*0.5,cos(tim*0.7))*min(0.5+tim*0.1+cos(tim*0.4)*0.5,1.5);\n\tvec3 rd=lookat(-ro)*normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y,1.0));\n    \n    ro.yz *= .2;\n    ro.yz += .5;\n    ro.x += iTime*.5;\n    \n\tvec3 color=scene(ro,rd,fragCoord.xy);\n\tcolor=clamp(color,0.0,min(tim,1.0));\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2GRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 163, 163, 210], [212, 212, 232, 232, 304], [306, 306, 326, 326, 436], [438, 438, 459, 459, 540], [542, 542, 563, 563, 663], [666, 666, 688, 688, 857], [859, 859, 888, 888, 1500], [1503, 1503, 1537, 1537, 1757], [1759, 1759, 1798, 1798, 2616], [2618, 2618, 2675, 2675, 3101]]}
{"id": "Wd2GzR", "name": "ringseg", "author": "Del", "description": "rings", "tags": ["2d", "ring", "segment"], "likes": 8, "viewed": 391, "published": "Public API", "date": "1547992224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple 2d Ring / RingSegment functions - Del 20/01/2019\n// updated & added pattern variation...\n\n#define\tPI 3.141592\n#define\tTAU 6.283185\n\nfloat remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\n\n// Ring\nfloat ring(vec2 uv, float rad, float thickness)\n{\n    return abs(rad - length(uv)) - thickness;\n}\n\n// Ring Segment (start 0-1, len 0-1)\nfloat ringseg(vec2 uv, float rad, float thickness,float segstart, float seglen)\n{\n    float d = ring(uv,rad,thickness);\n    float rr = fract((atan(uv.x, uv.y)/TAU)+segstart);\n    return seglen > rr ? d : 1.0;\n}\n\n// Ring Segment pattern\nfloat ringsegpat(vec2 uv, float rad, float thickness,float segstart, float seglen,float pat)\n{\n    float rr = fract((atan(uv.x, uv.y)/TAU)+segstart);\n    float v1 = remap(rr, 0.0, seglen, 0.0, pat);\n    thickness *= sin(v1*PI);\t\t\t// example pattern 1\n    //thickness *= SmoothTri2(v1,1.0);\t// example pattern 2\n    thickness *= fract(v1);\t\t\t\t// example pattern 3\n    float d = abs(rad - length(uv)) - thickness;\n    return seglen > rr ? d : 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    // ring segments\n    float s = fract(iTime*0.3);\n    float r1 = ringseg(uv,0.5,0.025,s,0.2);\n    float r2 = ringseg(uv,0.4,0.025,-s,0.2);\n    // whole ring\n    float r3 = ring(uv,0.6,0.025);\n    // pattern ring\n    float r4 = ringsegpat(uv,0.8,0.1,fract(iTime*0.1),1.0,16.0);\n    // combine\n    float d = min(r4,min(r3,min(r1,r2)));\n    float c = smoothstep(0.0,0.01,d);\n    \n    vec4 backgroundcol = vec4(0.2,0.2,0.2,1.0);\n    vec4 imagecol = vec4(0.7,0.6,0.9,1.0);\n    \n    fragColor = mix(imagecol,backgroundcol,c);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2GzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 204, 204, 246], [248, 266, 304, 304, 351], [353, 361, 410, 410, 458], [460, 497, 578, 578, 707], [709, 733, 827, 827, 1180], [1182, 1182, 1237, 1237, 1828]]}
{"id": "WdB3Dw", "name": "Bubble rings", "author": "tdhooper", "description": "Clifford torus intersected with a sphere", "tags": ["torus", "glow", "4d", "stereographic"], "likes": 176, "viewed": 3522, "published": "Public API", "date": "1548967825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Main SDF\n// https://www.shadertoy.com/view/wsfGDS\n// --------------------------------------------------------\n\nvec4 inverseStereographic(vec3 p, out float k) {\n    k = 2.0/(1.0+dot(p,p));\n    return vec4(k*p,k-1.0);\n}\n\nfloat fTorus(vec4 p4) {\n    float d1 = length(p4.xy) / length(p4.zw) - 1.;\n    float d2 = length(p4.zw) / length(p4.xy) - 1.;\n    float d = d1 < 0. ? -d1 : d2;\n    d /= PI;\n    return d;\n}\n\nfloat fixDistance(float d, float k) {\n    float sn = sign(d);\n    d = abs(d);\n    d = d / k * 1.82;\n    d += 1.;\n    d = pow(d, .5);\n    d -= 1.;\n    d *= 5./3.;\n    d *= sn;\n    return d;\n}\n\nfloat time;\n\nfloat map(vec3 p) {\n    float k;\n    vec4 p4 = inverseStereographic(p,k);\n\n    pR(p4.zy, time * -PI / 2.);\n    pR(p4.xw, time * -PI / 2.);\n\n    // A thick walled clifford torus intersected with a sphere\n\n    float d = fTorus(p4);\n    d = abs(d);\n    d -= .2;\n    d = fixDistance(d, k);\n    d = smax(d, length(p) - 1.85, .2);\n\n    return d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = mod(iTime / 2., 1.);\n\n    vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;\n    vec3 camTar = vec3(.0,0,.0);\n    vec3 camUp = vec3(-1,0,-1.5);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 5.;\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n\n    float distance = 0.;\n    vec3 color = vec3(0);\n\n    vec3 c;\n\n    // Keep iteration count too low to pass through entire model,\n    // giving the effect of fogged glass\n    const float ITER = 82.;\n    const float FUDGE_FACTORR = .8;\n    const float INTERSECTION_PRECISION = .001;\n    const float MAX_DIST = 20.;\n\n    for (float i = 0.; i < ITER; i++) {\n\n        // Step a little slower so we can accumilate glow\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\n        rayPosition = camPos + rayDirection * rayLength;\n        distance = map(rayPosition);\n\n        // Add a lot of light when we're really close to the surface\n        c = vec3(max(0., .01 - abs(distance)) * .5);\n        c *= vec3(1.4,2.1,1.7); // blue green tint\n\n        // Accumilate some purple glow for every step\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\n        c *= smoothstep(20., 7., length(rayPosition));\n\n        // Fade out further away from the camera\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\n        c *= rl;\n\n        // Vary colour as we move through space\n        c *= spectrum(rl * 6. - .6);\n\n        color += c;\n\n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    // Tonemapping and gamma\n    color = pow(color, vec3(1. / 1.8)) * 2.;\n    color = pow(color, vec3(2.)) * 3.;\n    color = pow(color, vec3(1. / 2.2));\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdB3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 199, 231, 231, 276], [278, 278, 317, 317, 409], [412, 604, 672, 672, 715], [717, 717, 741, 741, 839], [842, 1016, 1064, 1064, 1122], [1124, 1124, 1147, 1147, 1312], [1314, 1314, 1351, 1351, 1504], [1519, 1519, 1538, 1538, 1860], [1863, 1997, 2047, 2047, 2190], [2192, 2192, 2247, 2247, 4096]]}
{"id": "wdBGDR", "name": "2D texture to 3D cube", "author": "valerysntx", "description": "forked from https://www.shadertoy.com/view/WdjGzm, small changes for the `effect`", "tags": ["raymarching"], "likes": 3, "viewed": 337, "published": "Public", "date": "1548572834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATIONS 1000\n#define COLLISION_DISTANCE  0.00001\n#define MAX_DISTANCE 400.0\n\nfloat Sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p-pos) - radius;\n}\n\nfloat Plane(vec3 p, float height)\n{\n    return abs(p.y - height);\n}\n\nfloat Cube(vec3 p, vec3 pos, vec3 size)\n{\n    p -= pos;  \n    \n    return length(max(abs(p) - size,0.0));\n}\n\nfloat Intersect(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat Difference(float a, float b)\n{\n    return Intersect(a, -b);\n}\n\nfloat Union(float a, float b, vec3 colorA, vec3 colorB, out vec3 color)\n{\n    if(a <= b)\n    {\n        color = colorA;\n        return a;\n    }\n    \n    color = colorB;\n    return b;\n}\n\nvec3 TransformPoint(vec3 p, vec3 centerOfRotation, vec3 rotation)\n{\n    rotation *= 0.017453292519943295;\n    \n    vec4 p4 = vec4(p - centerOfRotation, 21.0);\n    \n    mat4 zyxRotation = mat4(\n        vec4(cos(rotation.z) * cos(rotation.y), sin(rotation.z)*cos(rotation.x) + cos(rotation.z)*sin(rotation.y)*(rotation.x), sin(rotation.z)*sin(rotation.x) - cos(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0),\n        vec4(-sin(rotation.z)*cos(rotation.y),cos(rotation.z)*cos(rotation.x)-sin(rotation.z)*sin(rotation.y)*sin(rotation.x), cos(rotation.z)*sin(rotation.x) + sin(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0),\n        vec4(sin(rotation.y), -sin(rotation.x)*cos(rotation.y), cos(rotation.y)*cos(rotation.x), 0.0),\n        vec4(0.0,1.0, 0.0, 1.0)); \n    \n     p4 *= zyxRotation;\n    \n    return p4.xyz + centerOfRotation;          \n}\n\nfloat Test(vec3 p, vec3 piv,sampler2D samp, vec3 rot, out vec3 color)\n{      \n   \n    p = TransformPoint(p, piv, rot);\n    \n    vec2 uv = p.xy - piv.xy;\n    \n    uv= (uv) / 2.0;\n    \n    uv = uv * vec2(0.5);\n    uv /= 3.0;\n    \n    vec4 tex = vec4(0.15);\n    \n    if(abs(uv.x) < 1.0 && abs(uv.y) < 1.0)\n    \ttex = texture(samp,uv);\n    color = tex.rgb;\n    \n    p.z += 1.1* (tex.r * 0.8 + tex.g * 0.5 + tex.b * 0.2);\n\n    \n    return  Cube(p, piv, vec3(5.1));\n}\n \n\n\nfloat Scene(vec3 p, out vec3 color)\n{\n   float inOutRotate \n    = p.x * sin(iMouse.y / 254.0) * 1.02;\n    \n    float d = Test(p, vec3(-7.5,6.6, 3.0),iChannel0,vec3(-15.0, -15.0, inOutRotate), color);\n    \n   \n    \n    vec3 col1;\n    float d1 = Test(p, vec3(7.5,6.0, 4.0),iChannel1,vec3(-15.0, 15.0, inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 =  Test(p, vec3(7.5,-6.0, 4.0),iChannel3,vec3(15.0 + 2.5, 15.0, -inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 = Test(p, vec3(-8.5,-6.5, 2.0),iChannel2,vec3(15.0, -15.0, inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    return d;\n}\n\nfloat Raymarching(vec3 cameraPos, vec3 rd, out vec3 color)\n{   \n    float t = 0.0;\n    for(int i=0;i<MAX_ITERATIONS;++i)\n    {\n        float d = Scene(cameraPos + rd * t, color);\n        \n        t += d;\n        \n        if(t > MAX_DISTANCE || d < COLLISION_DISTANCE)\n            break;\n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(COLLISION_DISTANCE * 0.111, 1.0);\n    vec3 color;\n    float d = Scene(p, color);\n    \n    vec3 n = vec3(\n        d - Scene(p-e.xyy, color),\n        d - Scene(p-e.yxy, color),\n        d - Scene(p-e.yyx, color));\n    \n    return normalize(n);\n}\n\nfloat GetDiffuseLight(vec3 p, vec3 pos)\n{\n    vec3 normal = GetNormal(p);\n    \n    vec3 light = pos - p;\n    \n    return dot(normalize(light), normal);\n}\n\nvec3 GetShadow(vec3 p, vec3 light)\n{\n    vec3 dir = normalize(light - p);\n    vec3 color;\n    float d = Raymarching(p, dir, color);\n    \n    if(d < length(light - p))\n        return vec3(0.1);\n    \n    return vec3(1.0);\n}\n\n\nfloat GetLight(vec3 p)\n{\n    vec3 pos1 = vec3(5.0 * sin(2.0 * iTime), 5.0 * cos(2.0 * iTime), -2.0); \n    \n    float diff = 0.25 + 0.5 * clamp(GetDiffuseLight(p, pos1), 0.5, 1.0);\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 cameraPos = vec3(0.1,1.0, -30.0  );\n    \n    vec3 dir = vec3(normalize(vec3(uv.xy, 1.50 )));\n    \n    vec3 color = vec3(0.0) * dir;\n    \n    float d = Raymarching(cameraPos, dir, color);\n    \n    float light = GetLight( cameraPos +  d * dir);\n\n  \n\n\n    // post\n    float vgn = smoothstep(1.1,1.5,abs(uv.y)) * smoothstep(1.1,1.5,abs(uv.x));\n    color *= 1.8 - (0.44 - vgn) * 0.23;\t\n    \n    fragColor = vec4(color * light, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 138, 138, 175], [177, 177, 212, 212, 244], [246, 246, 287, 287, 353], [355, 355, 390, 390, 413], [415, 415, 451, 451, 482], [484, 484, 557, 557, 667], [669, 669, 736, 736, 1516], [1518, 1518, 1589, 1589, 1979], [1984, 1984, 2021, 2021, 2646], [2648, 2648, 2708, 2708, 2961], [2963, 2963, 2987, 2987, 3248], [3250, 3250, 3291, 3291, 3403], [3405, 3405, 3441, 3441, 3626], [3629, 3629, 3653, 3653, 3832], [3834, 3834, 3891, 3891, 4394]]}
{"id": "wdBGR1", "name": "Projection test", "author": "Rerecursing", "description": "Testing a projection from the plane to a circle with a grid", "tags": ["circle"], "likes": 3, "viewed": 284, "published": "Public API", "date": "1548114989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y * 3.0 - 1.5;\n    uv.x -= 1.0;\n    float l = length(uv);\n    float s = tan(atan(l)*2.0) / l;\n    vec2 op = sin(uv * s * iTime - 1.0);\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(op.x, op.y, l/2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 414]]}
{"id": "wdBGRz", "name": "Polynomstränge-Iterationen", "author": "yokuldreki", "description": "none", "tags": ["none"], "likes": 0, "viewed": 62, "published": "Public", "date": "1547932768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float repeat = 16.0; // 20.0 Oder 10.0\n     \n    float Time = iTime - repeat * float((int(iTime)/int(repeat)));\n\n    \n    \n    float Scale = 7.5 ;\n    int Iterations = int(Time*5.0);//int(exp(Time/2.0));///28;  int(exp(iTime));\n    \n    \n    \n     //Oder\n\n    /*\n    \n \tfloat Scale = exp(-Time);\n\tint Iterations = 32;\n\n\t*/\n\n\t\n    \n    \n    float margin = 0.0000000001;\n    float bound = 8.0;\n    \n    vec2 MAX = vec2(Scale/2.0, Scale /1.0 * iResolution.y/iResolution.x);\n    \n    vec2 coord = Scale*(fragCoord.xy/iResolution.xy)- vec2(Scale/2.0);\n\tcoord.y = coord.y*iResolution.y/iResolution.x;///(iResolution.y/iResolution.x);\n    vec3 color = vec3(1.0); // White background\n\n    coord += vec2(0.0, 0.0);\n    \n    for(int i = 0; i < Iterations; i++){\n    \n        if(abs(coord.x) < margin && abs(coord.y) < margin){\n         \n            color = vec3(1.0, 0.0, 1.0);\n            break;\n            \n        }\n        /*\n        else if(abs(coord.x) < margin){\n            \n        \tcolor = vec3(0.0, 0.0, float(i) / float(Iterations));      \n            \n            //if(i < Iterations)\n                color = vec3(0.0, 1.0, 1.0);\n            \n            break;\n            \n        }\n        \n        else if(abs(coord.y) < margin){\n              \n            color = vec3(0.0, float(i) / float(Iterations), 0.0);    \n           \n            break;\n            \n        }*/\n        \n        else if (abs(coord.x) < margin || abs(coord.y) < margin){\n            \n            color = vec3(0.0, float(i) / float(Iterations), 0.0);    \n            \n            break;\n            \n        }\n            \n              \n        else if(length(coord) > bound){\n            \n         \tcolor = vec3( float(i) / float(Iterations), 0.0, 0.0);\n            break;           \n            \n        }       \n        else{\n\n        \tcoord = vec2(-coord.x - coord.y, coord.x*coord.y);\n            \n        }\n        \n    }\n    \n    \n    \n\tfloat phi = atan(coord.y, coord.x);// * 0.5 / PI + 0.5; //acos( dot(normalize(coord), vec2(0, -1)) );\n\tfloat R = length(coord);\n    \n    //color = R / length(MAX) * vec3(sin(phi), sin(phi + 2.0/3.0 * PI), sin(phi + 4.0/3.0*PI));\n\n    \n    // Output to screen\n        \n    fragColor = vec4(color, 1.0);\n        \n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 2330]]}
{"id": "WdBGW1", "name": "Star Fox Boss Battle", "author": "yasuo", "description": "Not playable", "tags": ["lowpoly", "triintersect", "starfox"], "likes": 5, "viewed": 337, "published": "Public API", "date": "1548695392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Code is based on: https://www.shadertoy.com/view/MlGcDz\n\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n\n// data from my modeling data.\nconst int numVertices = 60;\nconst int numFaces = 42;\n\nconst float vertices[60] = float[](\n    1.013484,-0.004748,-0.170576,1.363493,-0.372823,-1.554794,0.917013,-0.178702,-0.862685,1.288280,-0.178702,-0.862685,1.350874,-0.372823,1.669797,1.010963,-0.004748,0.212469,0.914492,-0.178702,0.904577,1.285759,-0.178702,0.904577,0.581273,-0.024900,0.352901,1.127463,-0.024900,0.352901,1.146371,0.728927,1.492630,0.581273,-0.023149,-0.350895,1.127463,-0.023149,-0.350895,1.146371,0.730678,-1.392582,1.000000,-0.010163,0.363769,1.000000,-0.002439,-0.369747,-1.000000,0.000000,0.006199,0.830098,0.325427,-0.003099,0.862253,-0.223150,0.009298,1.247514,-0.006511,0.004402\n);\n\nconst int faces[42] = int[](\n    3,4,2,1,4,3,7,8,6,5,8,7,9,10,11,12,13,14,17,15,18,18,20,16,15,17,19,16,17,18,19,17,16,16,20,19,19,20,15,20,18,15\n);\n\nconst int numVertices2 = 60;\nconst int numFaces2 = 69;\n\nconst float vertices2[60] = float[](\n-0.050644,-1.000000,-0.287185,-0.046908,-1.000000,0.282374,-0.022325,1.000000,-0.603118,0.252637,-0.756947,0.001045,0.086070,-0.554094,0.470331,0.080405,-0.581953,-0.393294,-0.310284,-0.550998,-0.745497,-0.299836,-0.538616,0.847426,0.301236,-0.464652,0.021582,-0.203997,0.661104,-0.847783,0.081116,0.650054,-0.284954,0.155316,0.606239,-0.650704,0.163361,0.764587,-0.622910,-0.191163,0.699229,0.950683,0.172071,0.792447,0.705030,0.085968,0.690296,0.454854,0.166343,0.645718,0.705368,-0.012304,0.995923,0.721267,0.357289,0.557239,0.010229,0.082718,1.115938,0.002954\n);\n\nconst int faces2[69] = int[](\n3,11,13,12,11,9,2,5,8,2,4,5,4,1,6,4,2,1,6,1,7,6,7,10,11,3,19,8,5,14,18,14,15,14,5,9,14,9,17,9,10,12,10,9,6,11,19,9,19,16,9,3,20,19,18,16,19,16,17,9,20,18,19,3,13,10,18,15,16\n);\n\n// Triangle intersection. Returns { t, u, v }\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\tvec2 prevP = p;\n    \n    // camera\n\tvec3 ro = vec3(5.0,1.0,0.0);\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  pos = vec3(0.0);\n\tfloat oid = 0.0;\n\n    // player model\n    int index = 0;\n    float xpos = 3.0;\n    float ypos = 0.3+sin(iTime*0.5)*0.5;\n    float zpos = 0.0;\n    vec3 airCraftColor = vec3(0.7);\n    mat3 rotX = matRotateX(radians(sin(iTime*0.7)*30.0));\n    for(int i = 0; i<numFaces/3; i++){\n        int f1 = faces[index];\n        int f2 = faces[index+1];\n        int f3 = faces[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \t\n        v0.x += 1.0;\n        v1.x += 1.0;\n        v2.x += 1.0;\n        \n        v0 *= rotX;\n        v1 *= rotX;\n        v2 *= rotX;\n        \n        float xspeed = 0.9;\n        v0.z += sin(iTime*xspeed)*1.5;\n        v1.z += sin(iTime*xspeed)*1.5;\n        v2.z += sin(iTime*xspeed)*1.5;\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 2.0;\n            airCraftColor = vec3(0.6-(float(i)*0.02));\n            if(f1 == 9 && f2 == 10 && f3 == 11 || f1 == 12 && f2 == 13 && f3 == 14){\n            \tairCraftColor = vec3(0.0,0.0,1.0);\n            } else if(f1 == 19 && f2 == 20 && f3 == 15){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.45,0.2):vec3(0.9,0.45,0.2)*1.5;\n            } else if(f1 == 16 && f2 == 20 && f3 == 19){\n                airCraftColor = mod(iTime,0.2)<0.1?vec3(0.9,0.4,0.2):vec3(0.9,0.4,0.2)*1.5;\n            }\n        }\n        index += 3;\n    }\n\n    // boss model\n    index = 0;\n    ypos = 1.5+sin(iTime*0.3)*-0.1;\n    xpos = 1.0+sin(iTime*0.5)*-1.5;\n    zpos = sin(iTime*1.2)*2.0;\n    vec3 bossColor = vec3(0.7);\n    float manimate = sin(iTime*5.0)*0.05;\n    for(int i = 0; i<numFaces2/3; i++){\n        int f1 = faces2[index];\n        int f2 = faces2[index+1];\n        int f3 = faces2[index+2];\n        \n        vec3 v0 = vec3(vertices2[(f1*3)-3],vertices2[((f1*3)-3)+1],vertices2[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices2[(f2*3)-3],vertices2[((f2*3)-3)+1],vertices2[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices2[(f3*3)-3],vertices2[((f3*3)-3)+1],vertices2[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \n\t\tv0.x -= xpos;\n        v1.x -= xpos;\n        v2.x -= xpos;\n        \n\t\tv0.z += zpos;\n        v1.z += zpos;\n        v2.z += zpos;\n        \n        // mouth animation\n        if(f1 == 9){\n            v0.y += manimate;\n        }\n        if(f2 == 9){\n            v1.y += manimate;\n        }\n        if(f3 == 9){\n            v2.y += manimate;\n        }\n        \n\t\tif(f1 == 4){\n            v0.y += manimate*-1.0;\n        }\n        if(f2 == 4){\n            v1.y += manimate*-1.0;\n        }\n        if(f3 == 4){\n            v2.y += manimate*-1.0;\n        }\n        \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 3.0;\n            bossColor = vec3(0.7-(float(i)*0.02));\n        }\n        index += 3;\n    }\n    \n\t// enemy bullet\n\tvec3 box = vec3(0.2,0.03,0.2);\n    vec3 bcolor = vec3(0.8);\n    mat4 brotX = rotationAxisAngle(vec3(1.0,0.0,0.0),radians(iTime*30.0));\n    mat4 tra = translate( -xpos+mod(iTime*2.0,3.0)*3.0, 1.0, zpos );\n    mat4 txi = tra *brotX; \n    mat4 txx = inverse( txi );       \n\t\n    vec4 res = iBox( ro, rd, txx, txi, box);\n    if( res.x>0.0 && res.x<tmin )\n    {\n        tmin = res.x; \n        oid = 1.0;\n        bcolor = vec3(0.8-(tmin*0.1));\n    }\n    \n    // material/bg\n\tvec3 col = vec3(1.0);\n\tif( tmin<100.0 )\n\t{\n        // material\n\t\tvec3  mate = vec3(.0);\n\t\tif( oid<1.5 ) {\n\t\t    mate = bcolor;\n\t\t} else if( oid>=1.5 && oid<=2.0 ) {\n\t\t    mate = airCraftColor;\n\t\t} else if( oid>2.1 && oid<=3.0 ){\n            mate = bossColor;\n        }\n\t\tmate = mate*mate*1.1;\n        \t\n\t\tcol *= mate;\n\n\t\tcol = sqrt( col );\n    } else {\n        // bg\n    \tcol = vec3(0.0);\n        prevP.x+=sin(iTime+p.y)*0.7;\n        float rbg = (length(prevP+vec2(2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(0.9,0.5,0.0), 1.0-smoothstep(0.15,2.5,abs(rbg)));\n        \n\t\tfloat lbg = (length(prevP+vec2(-2.5,0.0))-0.5)+sin(iTime+p.y)*0.2;\n        col = mix( col, vec3(1.0,0.2,0.2), 1.0-smoothstep(0.15,2.5,abs(lbg)));\n    }\n\t\n    // UI\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float ganimate = sin(iTime*1.5)*0.1;\n    \n    float playerBarBg = dBox2d(p+vec2(1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(playerBarBg)));\n    \n    float playerBar = dBox2d(p+vec2(1.3-ganimate, 0.85), vec2(0.15+ganimate,0.006));\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.029,0.03,abs(playerBar)));\n    \n\tfloat bossBarBg = dBox2d(p+vec2(-1.20, 0.85), vec2(0.3,0.055));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.011,abs(bossBarBg)));\n    \n    float bossBar = dBox2d(p+vec2(-1.2, 0.85), vec2(0.25,0.006));\n    col = mix( col, vec3(0.6,0.6,1.0), 1.0-smoothstep(0.029,0.03,abs(bossBar)));\n    \n    // result\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBGW1.jpg", "access": "shaders20k", "license": "mit", "functions": [[3007, 3121, 3202, 3202, 4169], [4171, 4239, 4316, 4353, 4871], [4873, 4873, 4920, 4920, 5324], [5326, 5326, 5371, 5371, 5487], [5489, 5489, 5519, 5519, 5566], [5568, 5568, 5625, 5625, 11335]]}
{"id": "WdBGWR", "name": "triIntersect test for OBJ Model", "author": "yasuo", "description": "The Code is barely based on: https://www.shadertoy.com/view/MlGcDz\nI just modified, simplified, and added reading vertexes and indices from .obj file data.\nI created low poly aircraft modeling data using a blender and exported as a .obj file.", "tags": ["raytrace", "triintersect"], "likes": 6, "viewed": 381, "published": "Public API", "date": "1548521135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Code is based on https://www.shadertoy.com/view/MlGcDz\n\n\n// data from my modeling data.\nconst int numVertices = 60;\nconst int numFaces = 42;\n\nconst float vertices[60] = float[](\n    1.013484,-0.004748,-0.170576,1.363493,-0.372823,-1.554794,0.917013,-0.178702,-0.862685,1.288280,-0.178702,-0.862685,1.350874,-0.372823,1.669797,1.010963,-0.004748,0.212469,0.914492,-0.178702,0.904577,1.285759,-0.178702,0.904577,0.581273,-0.024900,0.352901,1.127463,-0.024900,0.352901,1.146371,0.728927,1.492630,0.581273,-0.023149,-0.350895,1.127463,-0.023149,-0.350895,1.146371,0.730678,-1.392582,1.000000,-0.010163,0.363769,1.000000,-0.002439,-0.369747,-1.000000,0.000000,0.006199,0.830098,0.325427,-0.003099,0.862253,-0.223150,0.009298,1.247514,-0.006511,0.004402\n);\n\nconst int faces[42] = int[](\n    3,4,2,1,4,3,7,8,6,5,8,7,9,10,11,12,13,14,17,15,18,18,20,16,15,17,19,16,17,18,19,17,16,16,20,19,19,20,15,20,18,15\n);\n\n// Triangle intersection. Returns { t, u, v }\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)/rd.y;\n\t\n    if( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\toid = 1.0;\n\t}\n    \n\t// raytrace OBJ model;\n    //rd.y = mod(rd.y,0.5)-0.25;\n    \n    int index = 0;\n    float ypos = 1.0;\n    for(int i = 0; i<numFaces/3; i++){\n        int f1 = faces[index];\n        int f2 = faces[index+1];\n        int f3 = faces[index+2];\n        \n        vec3 v0 = vec3(vertices[(f1*3)-3],vertices[((f1*3)-3)+1],vertices[((f1*3)-3)+2]);\n        vec3 v1 = vec3(vertices[(f2*3)-3],vertices[((f2*3)-3)+1],vertices[((f2*3)-3)+2]);\n        vec3 v2 = vec3(vertices[(f3*3)-3],vertices[((f3*3)-3)+1],vertices[((f3*3)-3)+2]);\n        v0.y+=ypos;\n        v1.y+=ypos;\n        v2.y+=ypos;\n    \n    \tvec3 res = triIntersect( ro, rd, v0, v1, v2);\n        if( res.x>0.0 && res.x<tmin )\n        {\n            tmin = res.x; \n            oid = 2.0;\n        }\n        index += 3;\n    }\n    \n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n        vec3 lig = normalize(vec3(-0.8,0.4,0.1));\n\t\tpos = ro + tmin*rd;\n\t\t\n        // material\n\t\tfloat occ = 1.0;\n\t\tvec3  mate = vec3(1.0);\n\t\tif( oid<1.5 ) // plane\n\t\t{\n\t\t    mate = vec3(0.0,0.3,0.0);\n\t\t\tocc = 0.2 + 0.8*smoothstep( 0.0, 1.5, length(pos.xz) );\n\t\t}\t\t\t\n\t\telse // model\n\t\t{\n\t\t    mate = vec3(0.5,0.5,0.5)+tmin*0.05;\n\t\t}\t\t\n\t\tmate = mate*mate*1.1;\n        \n\t\t// lighting\n\t\tfloat dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t\n\t\tcol = vec3(0.13,0.17,0.2)*occ*3.0 + 1.5*dif*vec3(1.0,0.9,0.8);\n\n        // material * lighting\t\t\n\t\tcol *= mate;\n\n        // fog\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBGWR.jpg", "access": "shaders20k", "license": "mit", "functions": [[1983, 2097, 2178, 2178, 3145], [3147, 3147, 3194, 3194, 3598], [3600, 3600, 3645, 3645, 3761], [3763, 3763, 3820, 3820, 6208]]}
{"id": "wdBGWz", "name": "shutters (101 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["short", "onetweet", "golf"], "likes": 1, "viewed": 259, "published": "Public API", "date": "1548589169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    int i = int(iTime);\n    abs( 2.*U/iResolution.xy - 1.) [i%2] < fract(-iTime) ? i += 2 : i;\n    O[ i % 3 ] ++; }                                       /*\n\n\n\n\n\n\n// --- 103 chars\n\n#define mainImage(O,U)                                     \\\n    int i = int(iTime);                                    \\\n    O[ ( i + 2* int( abs( 2.*U/iResolution.xy - 1.) [i%2]  \\\n                     < fract(-iTime) )                     \\\n       ) %3 ] ++                                          /*\n\n\n\n\n\n\n// --- 107 chars (new version)\n\n#define mainImage(O,U)                                     \\\n    int i = int(iTime);                                    \\\n    abs(2.*U/iResolution.xy - 1.)[i%2]                     \\\n      > fract(-iTime) ?  O[i%3]++ : O[(i+2)%3]++          /*\n\n\n\n\n\n\n// --- 97 chars (simpler version)\n\n#define mainImage(O,U)                                     \\\n    int i = int(iTime);                                    \\\n    abs(2.*U/iResolution.xy - 1.) [i%2]                    \\\n                    > fract(-iTime) ?  O[i%3]++ : 0.      /*\n\n\n\n\n\n\n// --- 122 chars (simpler version)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 2.*U/iResolution.xy - 1.;\n    int i = int(iTime);\n    O-=O;\n    O[i%3] = float(abs(U[i%2]) > fract(-iTime) );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 152]]}
{"id": "wdf3D2", "name": "Tint sky", "author": "SourceW", "description": "e", "tags": ["clouds", "sky"], "likes": 0, "viewed": 225, "published": "Public", "date": "1547620053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Hash(vec3 uv) {\n    float dt = dot(abs(uv)*sin(uv), vec3(3.2, 7.2, 5.0));\n    float sn = dot(dt, 3.1415926);\n    return fract(sin(sn)*sin(sn) * 75.6);\n}\n\nfloat noise(vec3 p)\n{\n    vec2 add = vec2(1.0, 0.0);\n\tvec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(Hash(i  \t\t\t), \tHash(i + add.xyy),f.x),\n\t\t\tmix(Hash(i + add.yxy),\t\tHash(i + add.xxy),f.x),\n\t\t\tf.y),\n\t\tmix(mix(Hash(i + add.yyx),    \tHash(i + add.xyx),f.x),\n\t\t\tmix(Hash(i + add.yxx), \t\tHash(i + add.xxx),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\n\nfloat FBM(vec3 p) {\n    vec3 coord = p;\n    coord += 100.0;\n\tcoord.x += iTime * 0.1;\n\nfloat n  = noise(coord) * 0.5;   coord *= 3.0;\n          n += noise(coord) * 0.3;  coord *= 2.1;\n          n += noise(coord) * 0.2; coord *= 2.2;\n          n += noise(coord) * 0.0625;\n\n\n    return pow(abs(n), 1.155);\n\t\n}\n\n float MapCloud(vec3 pos){\n \n  float d = 1.0 - 0.3 * abs(3.8 - pos.y);\n  \n   d -= 2.2 * FBM( pos*0.3 );\n   d = clamp( d, 0.0, 1.0 );\n\n  return d; \n}\n\nvec4 Clouds(vec3 rd,float tmax){\n\n\nvec4 sum ;\n\n float t = 0.1;\n for (int i = 0; i < 64; i++) {\n\n vec3 pos = t*rd;\n \n float den = MapCloud(pos);\n \n  float dif =  clamp((den - MapCloud(pos+0.5*normalize(vec3(0.0,1.0,0.0))))/0.6, 0.0, 1.0 );\n \n  vec4 col = vec4( 1.0,1.0,1.0,den );\n \n vec3 lin = vec3(0.5,0.7,0.8)*1.4 + vec3(2.0, 0.6, 0.3)*dif;        \n \n col.xyz *= lin;\n\n col.xyz = mix( col.xyz, vec3(0.0,0.0,0.0), 1.0-exp(-0.0018*t*t) );\n\n col.a *= 1.0;\n col.rgb *= col.a;\n \n  sum += col * (1.0 - sum.a);  \n  t += max(0.1,0.05*t);\n}\n\nsum =  clamp( sum, 0.0, 1.0 );\n\nreturn sum;\n }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\n    vec3 ro = 4.0*normalize(vec3(sin(2.0*m.x), 0.1*m.y, cos(2.0*m.x)));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 rd =  ca*normalize( vec3(p.xy,1.5));\n    \n    vec4 C = Clouds(rd,2000.0);\n    \n    C.a *= length(rd.y*2.5);\n    \n    vec4 sky = mix(vec4(0.125,0.45,0.9,1.0),vec4(0.85,0.85,0.85,1.0),0.45-rd.y);\n    \n    fragColor = mix(sky,C,C.a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdf3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 159], [161, 161, 182, 182, 531], [534, 534, 553, 553, 840], [843, 843, 868, 868, 990], [992, 992, 1024, 1024, 1572], [1574, 1574, 1626, 1626, 1803], [1805, 1805, 1862, 1862, 2361]]}
{"id": "Wdf3WB", "name": "day13 ponde lion", "author": "kiyoshidainagon", "description": ",move light ball", "tags": ["shadeaday"], "likes": 3, "viewed": 122, "published": "Public", "date": "1547308147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a) vec2(cos(a),sin(a))\n\nconst float PI = 3.14159265359;\n\n\nfloat oneLinerFor(in vec2 p, in float num) {\n    float a = 2.0 * PI / num;\n    return floor( mod( atan(p.y, p.x) + a / 2.0 - PI - iTime , 2.0 * PI) / a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 destColor = vec3(0.0);\n    \n    float j = oneLinerFor(p, 10.0);\n    vec2 q = p + CS(iTime + j * 2.0 * PI / 10.0) * 0.8;\n    destColor += 0.01 / abs(length(q) - 0.3);    \n\n    // Output to screen\n    fragColor = vec4(destColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdf3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 113, 113, 224], [226, 226, 283, 283, 597]]}
{"id": "Wdf3zl", "name": "AIR VAPORMAX", "author": "yasuo", "description": "Tried to make it look like the Nike By You advertising campaign.", "tags": ["ui", "2ddistance", "nike"], "likes": 14, "viewed": 530, "published": "Public API", "date": "1547137078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define combine(v1,v2) v1.w < v2.w ? v1 : v2\n#define opSubtraction(d1,d2) max(-d1,d2)\n#define hash(h) fract(sin(h) * 43758.5453123)\n\nconst float WallDistance = 0.03;\nconst float GlowDistance = 0.01874;\nconst float MarchDumping = 0.358;\n\n// numbers 0123456789:\nint c[] = int[](31599,9362,29671,29391,23497,31183,31215,29257,31727,31695,1040);\n\n/* The glass like shader is based on https://www.shadertoy.com/view/Md3SDB */\n// 2d distance functions from http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvec3 lineTex(vec2 uv)\n{\n    float stripeSize = 50.0;\n    float t = iTime*10.0;\n    return vec3(tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 1.0, h );\n    return length( p ) - r;\n}\n\nfloat opElongate( in vec3 p, in vec2 size, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return sdTorus( max(q,0.0), size ) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 map(vec3 p){\n    float speed = iTime*15.0;\n    vec3 prevP = p;\n    \n    float cmnR = 0.035;\n    float floorD = p.y+3.0;\n    float sole0 = opElongate(p+vec3(-0.05,0,2.9), vec2(0.3,0.11), vec3(0.3,0.05,0.001));\n   \tsole0 = opSubtraction(length(p+vec3(0,0,2.6))-0.3, sole0)-cmnR;\n    \n    float sole1 = opElongate(p+vec3(0.05,0,1.8), vec2(0.35,0.11), vec3(0.6,0.05,0.001));\n   \tsole1 = opSubtraction(length(p+vec3(0.2,0,1.45))-0.3, sole1)-cmnR;\n    sole1 = opSubtraction(length(p+vec3(0.1,0,2.15))-0.3, sole1);\n    \n    float sole2 = opElongate(p+vec3(0.1,0,0.7), vec2(0.4,0.11), vec3(0.75,0.05,0.001));\n   \tsole2 = opSubtraction(length(p+vec3(0.3,0,1.1))-0.3, sole2)-cmnR;\n    \n    float sole3 = opElongate(p+vec3(0,0,-0.5), vec2(0.35,0.11), vec3(0.6,0.05,0.001));\n   \tsole3 = opSubtraction(length(p+vec3(0,0,-1.1))-0.8, sole3)-cmnR;\n    \n    p.x = -abs(p.x);\n    float sole4 = sdCapsule(p+vec3(0.7,0,-0.3),1.3,0.2);\n    p = prevP;\n    \n    float sole5 = opElongate(p+vec3(0,0,-2.5), vec2(0.35,0.12), vec3(0.3,0.05,0.001));\n   \tsole5 = opSubtraction(length(p+vec3(0,0,-1.95))-0.7, sole5)-cmnR;\n    \n    vec4 res = combine(vec4(vec3(0.9,0.3,0.3),sole0),vec4(vec3(0.9,0.3,0.3),sole1));\n    vec4 res2 = combine(vec4(vec3(0.9,0.3,0.3),sole2),vec4(vec3(0.9,0.3,0.3),sole3));\n    vec4 res3 = combine(vec4(vec3(0.9,0.3,0.3),sole4),vec4(vec3(0.9,0.3,0.3),sole5));\n    vec4 res4 = combine(res,res2);\n    vec4 res5 = combine(res3,res4);\n    \n    return res5;\n}\n\nfloat getBit(int num,int bit)\n{\n\treturn float( num>>bit & 1);\n}\n\nfloat Sprite3x5(int sprite,vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn getBit(sprite,int((2.0 - p.x) + 3.0 * p.y)) * bounds;\n}\n\nfloat Digit(int n,vec2 p)\n{\n\tn = int(mod(float(n),11.0));\n    return Sprite3x5(n == 0 ? c[0] : n == 1 ? c[1] : n == 2 ? c[2] : n == 3 ? c[3] : n == 4 ? c[4] : n == 5 ? c[5] : n == 6 ? c[6] : n == 7 ? c[7] : n == 8 ? c[8] : n == 9 ? c[9] : n == 10 ? c[10] : 0,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camRotY = matRotateY(radians(-iTime*30.0))*matRotateX(radians(40.0));\n\t//mat3 camRotY = matRotateX(radians(90.0)); // for debug purpose\n    \n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n    \n    vec3 accu = vec3(0.0);\n    float glowFactor = 0.0;\n    float steps = 0.0;\n\tfor(int i = 0; i < 60; i++){\n        steps = float(i);\n        \n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n        float absd = abs(dist);\n        absd *= 0.8 + hash(absd) * 0.2;\n        \n\t\tif(dist < 1e-4){break;}\n        if(t>30.)break;\n        \n\t\tglowFactor += pow(1.0 - smoothstep(0.0, GlowDistance, dist), 14.0) * step(0.0, dist);\n        float f = absd * (1.0 - smoothstep(0.0, WallDistance, absd));\n        accu += vec3(f);\n\n        t += max(0.0001, absd * MarchDumping);\n        \n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n    glowFactor /= steps;\n\taccu += 0.7 * pow(glowFactor, 1.2) * vec3(1.0);\n\n    // drawing UI\n    vec2 uv = p;\n    vec2 uvRef = uv;\n    \n    // bg color\n    vec3 uicol = vec3(0.0);\n    vec3 white = vec3(1.0);\n    \n    uvRef.y -= 0.5;\n    uvRef.x = mod(uvRef.x,1.0)-0.5;\n    uvRef.y = mod(uvRef.y,1.0)-0.5;\n    uicol = line( uicol, vec2(0.0, 0.2), vec2(0.0, -0.2), uvRef, vec2(0.002,1.0), vec4(white,2.0) );\n\tuicol = line( uicol, vec2(0.2, 0.0), vec2(-0.2, 0.0), uvRef, vec2(0.002,1.0), vec4(white,2.0) );\n    \n    // guage\n    float guageBg = dBox2d(uv+vec2(-1.0, -0.5), vec2(0.11,0.36));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.0001,0.01,abs(guageBg)) );\n    \n    vec3 ltex = lineTex(uv);\n    float ganimate = sin(iTime*1.2)*0.1;\n    float guageBar = dBox2d(uv+vec2(-1.0, -0.4-ganimate), vec2(0.0005,0.15+ganimate));\n    uicol = mix( uicol, ltex, 1.0-smoothstep(0.09,0.105,abs(guageBar)) );\n    \n    float naviSize = 0.03;\n    float navi = sdTriangle(vec2(naviSize,naviSize*2.0),vec2(-naviSize,naviSize),vec2(naviSize,-naviSize*0.25),uv+vec2(-1.15,-0.62-ganimate*2.2));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.003,0.01,abs(navi)) );\n\n    // guage2\n    ganimate = sin(iTime*1.5)*0.1;\n    float guage0 = dBox2d(uv+vec2(1.1-ganimate, 0.4), vec2(0.15+ganimate,0.006));\n    uicol = mix( uicol, ltex, 1.0-smoothstep(0.029,0.03,abs(guage0)));\n    \n    ganimate = sin(iTime*1.7)*0.1;\n    float guage1 = dBox2d(uv+vec2(1.1-ganimate, 0.5), vec2(0.15+ganimate,0.006));\n    uicol = mix( uicol, ltex, 1.0-smoothstep(0.029,0.03,abs(guage1)));\n    \n    ganimate = sin(iTime*1.9)*0.1;\n    float guage2 = dBox2d(uv+vec2(1.1-ganimate, 0.6), vec2(0.15+ganimate,0.006));\n    uicol = mix( uicol, ltex, 1.0-smoothstep(0.029,0.03,abs(guage2)));\n    \n    // fake 3D graph\n    uicol = line( uicol, vec2(1.0, -0.15), vec2(1.0, -0.5), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(1.0, -0.5), vec2(0.7, -0.7), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(1.0, -0.5), vec2(1.3, -0.7), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    \n    uicol = line( uicol, vec2(1.0, -0.3), vec2(0.85, -0.6), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(1.0, -0.3), vec2(1.15, -0.6), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.85, -0.6), vec2(1.15, -0.6), uv, vec2(0.003,1.0), vec4(white,2.0) );\n    \n\tfloat dot0 = dBox2d(uv+vec2(-1.0, 0.15), vec2(0.001,0.001));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.025,0.03,abs(dot0)) );\n\tfloat dot1 = dBox2d(uv+vec2(-0.7, 0.7), vec2(0.001,0.001));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.025,0.03,abs(dot1)) );\n\tfloat dot2 = dBox2d(uv+vec2(-1.3, 0.7), vec2(0.001,0.001));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.025,0.03,abs(dot2)) );\n    \n    float ax = cos(iTime*2.5)*0.03;\n    float ay = sin(iTime*1.7)*0.04;\n    float ax2 = cos(iTime*1.9)*0.05;\n    float ay2 = sin(iTime*2.1)*0.06;\n    \n    float rotVal = radians(-iTime*30.0);\n    mat2 m = rot(rotVal);\n    \n\tfloat td = sdTriangle(vec2(0.12+ax,0.12+ay)*m,vec2(-0.12+ax2,0.12+ay2)*m,vec2(-0.12+ax,-0.12+ay)*m,uv+vec2(-1.0,0.55));\n    uicol = mix( uicol, white, 1.0-smoothstep(0.006,0.01,abs(td)) );\n    \n    // AIR LOGO\n    vec2 logoPos = vec2(1.25,-0.5);\n\tuicol = line( uicol, vec2(0.1, 0.07), vec2(0.0, -0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n\tuicol = line( uicol, vec2(0.14, 0.07), vec2(0.14, -0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.23, 0.07), vec2(0.23, -0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.32, 0.07), vec2(0.32, -0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.36, 0.07), vec2(0.45, 0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.45, 0.07), vec2(0.37, -0.03), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    uicol = line( uicol, vec2(0.37, -0.03), vec2(0.5, -0.07), uv+logoPos, vec2(0.02,2.0), vec4(white,2.0) );\n    \n    // digit\n    uv = ( fragCoord.xy /iResolution.xy ) * vec2(256,128);\n\tvec2 cpos = vec2(113.0,117.0);\n\tfloat dc = Digit(int(fract(iTime)*10.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*20.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*40.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*50.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(10,floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*70.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*80.0),floor(uv-cpos));\n\tcpos.x += 3.5;\n\tdc += Digit(int(fract(iTime)*90.0),floor(uv-cpos));\n   \tuicol = mix(uicol,white,dc );\n    \n\t// rendering result\n\tfloat brightness = 2.0;\n    vec3 dst = accu*brightness;\n\tfragColor = vec4(dst+uicol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdf3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[572, 755, 785, 785, 832], [834, 834, 857, 857, 1097], [1099, 1099, 1148, 1148, 1258], [1260, 1260, 1343, 1343, 1477], [1479, 1479, 1546, 1546, 2155], [2157, 2157, 2190, 2190, 2255], [2257, 2257, 2302, 2302, 2365], [2367, 2367, 2423, 2423, 2521], [2523, 2523, 2540, 2540, 3976], [3978, 3978, 4009, 4009, 4041], [4043, 4043, 4079, 4079, 4232], [4234, 4234, 4261, 4261, 4498], [4500, 4500, 4556, 4556, 10381]]}
{"id": "WdfGRl", "name": "Bubble fractal ", "author": "JoshScholar", "description": "scriptkiddying  Dave_Hoskins Space Jewels https://www.shadertoy.com/view/llX3zr Note the mouse moves up/down in/out - you get a pretty nice tour without touching the mouse (I recommend), but there are realms above and below you can only see with the mouse", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 182, "published": "Public", "date": "1547122664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// When I tried forking it, it never appeared on the page, so I'm forking by copying,\n// Joshua Scholar 1/10/2019\n// Space Jewels. December 2014\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/llX3zr\n\n//I realize that after playing with cross fading between iteration levels, changing\n//the path, messing with the shadow code, the only difference between the equation\n//of David Hoskins' Jewels and the bubbles is one line I deleted by accident.   I \n//I do have alternate equations that are cool but they make rather enclosed spaces\n//that are hard to tour.\n\n//Define REJEWEL to turn it from bubbles back into jewels. It is cool\n//If I were to turn that on and off, parts of the image would go back and forth\n//between being solid and being waving and ephemeral. \n//#define REJEWEL\n\n//--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(0.07, 0.05, 0.05)\n#define MOD2 vec2(443.8975,397.2973)\n\nvec3 CSize;\nvec4 aStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\n//----------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\nfloat Hash(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\t\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.z-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n\t\tfloat k = max((1.1)/(r2), .03);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(1.647,-1.0,4.9)));\n}\n\n//--------------------------------------------------------------------------\n\nvec4 initp(vec3 p)\n{\n    return vec4(p,1.0);\n}\n//p.w starts as 1.0\nvec4 Map1( vec4 p)\n{\n\t  p.xyz = 2.0*clamp(p.xyz, -CSize, CSize) - p.xyz;\n      //p.xyz = 1.5*vec3(mod(p.x+CSize.x, 2.*CSize.x)-CSize.x,mod(p.y+CSize.y,2.*CSize.y)-CSize.y,mod(p.z+CSize.z,2.*CSize.z)-CSize.z);\n\n\tfloat r2 = dot(p.xyz,p.xyz);\n\tfloat k = max((1.1)/(r2), .03);\n\tp.xyz     = p.xyz*k;\n#ifdef REJEWEL    \n    p.w *= k;\n#endif    \n    return p;\n//      return vec4(sqrt(abs(p.z*p.x))*sign(p.z*p.x),p.y,p.x,p.w*k);\n  //    return vec4(sqrt(abs(p.z*p.x))*sign(p.z*p.x),sqrt(abs(p.y*p.x))*sign(p.y*p.x),sqrt(abs(p.z*p.y))*sign(p.z*p.y),p.w*k);\n //   return vec4(p.z,p.y,p.x,p.w*k);\n}\nfloat p2v(vec4 p)\n{\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) / (length(p.xyz))-.1);\n\treturn (rxy) / abs(p.w);\n}\n\nfloat Map( vec3 ps, float level )\n{\n\tfloat scale = 1.0;\n\t\n//    float level = abs(mod(((iTime+10.)/15.+20.),40.)-20.);\n    int it = int(level);\n    float amount = level-float(it);\n    vec4 p = initp(ps);\n    vec4 d = vec4(1.0,1.0,1.0,1.0);\n    p=Map1(p);\n    p=Map1(p);\n\n    while (it-->=0) \n        p=Map1(p);\n/*    \n    switch (it){\n        case 15:\n    \tp=Map1(p);\n        case 14:\n    \tp=Map1(p);\n        case 13:\n    \tp=Map1(p);\n        case 12:\n    \tp=Map1(p);\n        case 11:\n    \tp=Map1(p);\n        case 10:\n    \tp=Map1(p);\n        case 9:\n    \tp=Map1(p);\n        case 8:\n    \tp=Map1(p);\n        case 7:\n    \tp=Map1(p);\n        case 6:\n    \tp=Map1(p);\n        case 5:\n    \tp=Map1(p);\n        case 4:\n    \tp=Map1(p);\n        case 3:\n    \tp=Map1(p);\n        case 2:\n    \tp=Map1(p);\n        case 1:\n    \tp=Map1(p);\n        case 0:\n        d=Map1(p);\n        break;\n        default:\n        amount=0.;\n    }\n*/\n     d=Map1(p);\n    //return p2v((1.0-amount)*p+amount*d);\n \treturn (1.0-amount)*p2v(p)+amount*p2v(d);   \n    //return p2v(p);\n}\n\nfloat Map(vec3 p)\n{\n     return Map(p,abs(mod(((iTime+10.)/15.+20.),40.)-20.));\n}\n\n//--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    float level = abs(mod(((iTime+10.)/15.+20.),40.)-20.);\n    int by= (20-int(level))/3;    \n    \n    //int by = int(iTime/26.)*3;\n    \n    for (int i = 0; i < 1+by; i++)\n\t{\n\t\th = Map( ro + rd*t, level );\n\t\tres = min(7.0*h / t, res);\n\t\tt += h+.01;\n\t}\n    return max(res, 0.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n    vec3 sunLight  = normalize( vec3(  0.5, 0.2,  0.3 ) );\n\tfloat sh = Shadow(pos,  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    //col += mat * vec3(0.1, .0, .0)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 25.0)  * SUN_COLOUR * 1.5 *sh;\n    // Abmient..\n    col += mat * .2 * max(normal.z, 0.0);\n    col = mix(FOG_COLOUR,col, min(exp(-d*d*.05), 1.0));\n    \n\treturn col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n//--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n\tif (t< 1.4) t= (1.4-t) * 4.5;\n\tt = t*0.04;\n\treturn max(t*t, 16.0/iResolution.x);\n}\n\n//--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n    //float t = 0.0;\n\tfloat t = .1 * Hash(fcoord*fract(iTime));\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (hits == 8 || alphaAcc >= 1.0 || t > 10.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n        // Is it within the sphere?...\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t// Accumulate the alphas with the scoop of geometry from the sphere...\n            // Think of it as an expanding ice-cream scoop flying out of the camera! \n\t\t\tfloat alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);\n\t\t\t// put it on the 2 stacks, alpha and distance...\n\t\t\taStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;\n\t\t\taStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n\t\t\tdStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\talphaAcc += alpha;\n\t\t\thits++;\n\t\t}\n\t\tt +=  h*.85+t*.001;\n        \n\t}\n\t\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t// Then...\n\t#define CONTRAST 1.3\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t// Vignette...\n\trgb *= .5+0.5*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel0, pos*.1, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t, float inward )\n{\n    vec3 p = inward*vec3(-2.9 +2.5 * sin(t),-3.8+5.0 * cos(t),-1.94+2.2 * sin(1.3*t+2.0) );\n\treturn p;\n} \n    \n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x);\n\tfloat n = ((iMouse.y-iResolution.y)/iResolution.y+.5)*20.0;\n    \n\tfloat gTime = ((iTime+26.)*.12);\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    // Animate...\n    CSize = vec3(.808, .99-sin((gTime+35.0)*.5)*.3, 1.151-sin((gTime+16.0)*.78)*.3);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime*.3 + 0.0, 2.*(m-.5))+vec3(0.,0.,n);\n\tvec3 camTarget \t= vec3 (-12., .0, -2.0);\n\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir);\n\t\n    \n    // Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            float d = dStack[s][i];\n            if (d < 0.0) continue;\n            float sphereR = SphereRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 alb = Albedo(pos, normal);\n            col += DoLighting(alb, pos, normal, dir, d)* aStack[s][i];\n        }\n    }\n    // Fill in the rest with fog...\n   col += FOG_COLOUR *  (1.0-alpha);\n   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "Xtl3RM", "previewfilepath": "https://soundcloud.com/in-an-electronic-way-1/arrival", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/in-an-electronic-way-1/arrival", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1129, 1266, 1286, 1286, 1372], [1374, 1465, 1487, 1487, 1757], [1759, 1837, 1857, 1857, 1883], [1884, 1904, 1924, 1924, 2492], [2493, 2493, 2512, 2512, 2651], [2653, 2653, 2688, 2688, 3697], [3699, 3699, 3718, 3718, 3780], [3782, 3859, 3898, 3898, 4228], [4230, 4307, 4394, 4394, 4935], [4938, 5015, 5054, 5054, 5252], [5254, 5331, 5363, 5363, 5447], [5449, 5526, 5563, 5584, 6533], [6536, 6613, 6650, 6669, 7016], [7018, 7095, 7148, 7148, 7335], [7337, 7414, 7447, 7447, 7541], [7544, 7621, 7663, 7663, 7768], [7776, 7853, 7910, 7910, 9358]]}
{"id": "wdfGRX", "name": "negative space", "author": "robin_be", "description": "dazzling!\n\ntry uncommenting line 5 for more dazzling!", "tags": ["space", "negative"], "likes": 10, "viewed": 433, "published": "Public API", "date": "1546975701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 100.\n#define PI 3.14159265359\n#define PI2 1.570796326795\n\n//#define HORIZONTAL\n\nmat2 rot(float a)\n{\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\nfloat in_out_cubic(float t)\n{\n    t *= 2.;\n    if (t < 1.) return .5*t*t*t;\n    t-=2.;\n    return .5*(t*t*t+2.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 uv)\n{\n    vec2 R2 = iResolution.xy / 2.;\n    float t = fract(iTime / 2.),\n         t3 = step(abs(mod(iTime, 4.) - 2.), 1.),\n         t4 = 1. - t3,\n   halfdiag = sqrt(2.)/2.,\n        pad = .5-halfdiag;\n\n#ifndef HORIZONTAL\n    t = in_out_cubic(t);\n    uv = (uv - R2) * rot(-iTime/5.) + R2;\n#else\n    uv.y += sin(t*PI)*pad*SIZE/2.;\n    uv.x += t*-halfdiag*SIZE;\n    uv.x -= halfdiag*SIZE*floor(iTime/2.);\n#endif\n\n    uv = fract(uv / SIZE + t4 / 2.);\n    uv = (1.-pad-pad-.6/SIZE)*uv+pad;\n    uv = (uv - .5) * rot(t*PI2);\n    uv =\n#ifdef HORIZONTAL\n        // smoothstep makes the transition look\n        //   somewhat less smooth if horizontal\n        step(0.,\n#else\n        smoothstep(0.,2./SIZE,\n#endif\n                              .5-abs(uv));\n\n    fragColor = vec4(1.,.6,1.,1.)*mix(t4,t3,uv.x*uv.y);\n}\n\n\n\n\n\n/* old code for reference\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fc = (fragCoord.xy - iResolution.xy/2.) * rot(-iTime/5.) + iResolution.xy/2.;\n    float t = in_out_cubic(mod(iTime, 2.) / 2.);\n    float t3 = mod(iTime, 4.);\n    t3 = step(1., t3) * step(t3, 3.);\n    float t4 = 1. - t3;\n    \n    float pad = (1.-sqrt(2.))/2.;\n    vec2 uv = mod(fc + SIZE/2. * t4, vec2(SIZE))/SIZE;\n    uv = (1.-pad-pad)*uv+pad;\n    uv = (uv - .5) * rot(t*PI2) + .5;\n    \n    vec3 incol = vec3(1.,.6,1.);\n    float val = step(0.,uv.x)*step(0.,uv.y)*step(uv.x,1.)*step(uv.y,1.);\n    fragColor = vec4(incol*val*t3+t4*incol-t4*incol*val,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 93, 112, 112, 178], [179, 179, 208, 208, 293], [294, 294, 342, 342, 1140]]}
{"id": "WdfGW2", "name": "2d wave patterns 3", "author": "public_int_i", "description": "multiple waves added together to make a nice pattern", "tags": ["2d", "wave", "patterns"], "likes": 5, "viewed": 351, "published": "Public API", "date": "1547479528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Alexander Shulman 2019, made on livestream at twitch.tv/ethanshulman\n\n#define time iTime\n\nfloat voronoi(vec2 u, float i) {\n\t#define l(i) length(fract(abs(u*.01+fract(i*vec2(1,8))+sin(u.yx*.2+i*8.)*.02+sin(u*.06+1.6+i*6.)*.1))-.5)\n\treturn l(i);\n}\nfloat triwave(float t) {\n\treturn t*2.-max(0.,t*4.-2.);\n}\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.y;\n\tfloat s = 0.,scal = 10.+triwave(fract(time*.02))*200.;\n\tfor (int i = 0; i < 8; i++) {\n\t\ts += (sin(voronoi(uv*scal*float(i+1),float(i)/8.0)*pow(float(i+2),2.)-time*pow(float(i+1),1.2))*.5+.5)/float(i+1);\n\t}\n\ts = pow(s*.35,2.);\n\to = vec4(s,s,s,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 130, 130, 253], [254, 254, 278, 278, 310], [312, 312, 353, 353, 653]]}
{"id": "WdfGWj", "name": "Deck card", "author": "TaoJinJin", "description": "this is an experiment of drawing 2d shape using the method in pixelspiritdeck.com", "tags": ["2d", "shape"], "likes": 2, "viewed": 115, "published": "Public", "date": "1547459059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n\nvec2 scale(vec2 st, vec2 n) {\n\treturn st * n;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st;\n}\n\nfloat fill(float x, float size) {\n    return 1. - step(size, x);\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n\treturn max(abs(st.x/s.x), abs(st.y/s.y));\n}\n\nfloat circleSDF(vec2 st) {\n\treturn length(st - .5) * 2.;\n}\n\n\nfloat circleSDF2(vec2 st, float r) {\n    float v = (length(st) - r);\n\treturn v * 2.;\n}\n\nfloat starSDF2(vec2 uv, int V, float s) {\n\t// st = st * 4. - 2.;\n    vec2 st = uv;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5)/float(V) + mix(s, -s, step(.5, fract(seg)))) * TAU;\n\treturn abs(dot(vec2(cos(a), sin(a)), st));\n}\n\nfloat stroke(float x, float size, float w) {\n\tfloat d = step(size, x + w * .5) - step(size, x - w * .5);\n\treturn clamp(d, 0., 1.);\n}\n\nfloat fakeAtan(float v) {\n    float abs_v = abs(v);\n    return log(abs_v + 1.)*sign(v);\n}\n\nfloat triSDF(vec2 uv) {\n    vec2 st = (uv * 2. - 1.) * 2.;\n    return max(abs(st.x) * 0.866025 + st.y * 0.5, -st.y * 0.5);\n}\n\nfloat hexSDF(vec2 uv) {\n\tvec2 st = abs(uv * 2. - 1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y * 0.5);\n}\n\nfloat crossSDF(vec2 uv, float s) {\n\tvec2 size = vec2(.25, s);\n    return min(rectSDF(uv.xy, size.xy), rectSDF(uv.xy, size.yx));\n}\n\nfloat polySDF(vec2 uv, int V) {\n\tfloat a = atan(uv.x, uv.y) + PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    return cos(round(a / v) * v - a) * r;\n}\n\nfloat heartSDF(vec2 uv) {\n\tvec2 st = uv;\n    float r = length(st) * 5.0;\n    st = normalize(st);\n    return r -\n        \t((st.y*pow(abs(st.x), 0.67))/\n        \t(st.y + 1.5) - (2.) * st.y + 1.26);\n}\n\nfloat flowerSDF(vec2 uv, int N) {\n\tvec2 st = uv;\n    float r = length(st) * 2.;\n    float a = atan(st.y, st.x);\n    float v = float(N) * .5;\n    return 1. - (abs(cos(a * v)) * .5 + .5) / r;\n}\n\nfloat rhombSDF(vec2 uv) {\n\treturn max(triSDF(uv), triSDF(vec2(uv.x, 1. - uv.y)));\n}\n\nfloat vesicaSDF(vec2 st, float r, float w) {\n\tvec2 offset = vec2(w * .5, 0.);\n    return max(circleSDF2(st - offset, r), circleSDF2(st + offset, r));\n}\n\n\nfloat spiralSDF(vec2 uv, float t) {\n    vec2 st = uv - .5;\n    float r = dot(st,st);\n    float a = atan(st.y,st.x);\n    return abs(sin(fract(log(r)*t+a*0.159)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st =  ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n    \n    // vec3 color = vec3(0);\n    color -= stroke(circleSDF2(st, 0.08), .4, .035);\n    color -= stroke(starSDF2(st, 4 + 2 * int(sin(iTime) * 2.0), 0.296), 0.12, 0.02);\n  \tcolor -= fill(starSDF2(st, 8 * int((sin(iTime) + 2.) * 2.), 0.296), 0.033);\n    color -= stroke(heartSDF(scale(st, vec2(3.2, 3.5)) - vec2(0., 0.3)), 0.27, 0.18);\n    \n    vec2 c = vec2(-2., 0);\n    color -= fill(flowerSDF(rotate(st + vec2(1.0, 0.5), iTime + 1.) * 5., 3), 0.02);\n    color -= fill(flowerSDF(rotate(st + vec2(0.0, 0.5), iTime) * 5., 3), 0.02);\n    \n    color -= stroke(vesicaSDF(rotate(st, HALF_PI) + vec2(0.5, -1.), 0.1, 0.25 * (sin(iTime * 1.5)*0.2 + 1.)), .4, .03);\n    color -= stroke(vesicaSDF(rotate(st, HALF_PI) + vec2(0.5, 0.), 0.1, 0.25 * (cos(iTime * 1.5)*0.2 + 1.)), .4, .03);\n    \n    color -= stroke(crossSDF(st + vec2(0., -0.4), 0.8), .12, .05);\n    color -= stroke(rhombSDF(st + vec2(0.5, 0.1)), .12, .03);\n    vec3 col = vec3(0.);\n    // col += polySDF(st, 4);\n    color += stroke(polySDF(st, 3 + int(round((cos(iTime)+1.) * 7.)) ), .28, .035);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 463, 463, 481], [483, 483, 514, 514, 599], [601, 601, 634, 634, 667], [669, 669, 701, 701, 746], [748, 748, 774, 774, 806], [809, 809, 845, 845, 895], [897, 897, 938, 961, 1173], [1175, 1175, 1219, 1219, 1307], [1309, 1309, 1334, 1334, 1398], [1400, 1400, 1423, 1423, 1524], [1526, 1526, 1549, 1549, 1638], [1640, 1640, 1674, 1674, 1769], [1771, 1771, 1802, 1802, 1934], [1936, 1936, 1961, 1961, 2133], [2135, 2135, 2168, 2168, 2326], [2328, 2328, 2353, 2353, 2411], [2413, 2413, 2457, 2457, 2564], [2567, 2567, 2602, 2602, 2730], [2732, 2732, 2789, 2839, 4107]]}
{"id": "WdfGzB", "name": "Mandelbrot Orbit Traps", "author": "oalpha", "description": "Experimenting with coloring the mandelbrot set", "tags": ["fractal", "mandelbrot", "orbit"], "likes": 1, "viewed": 129, "published": "Public", "date": "1546884856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 complexMultiply( vec2 a, vec2 b )\n{\n    return vec2(dot(a, b * vec2(1.,-1.)), dot(a, b.yx));\n}\nvec2 complexPower( vec2 a, int power )\n{\n    vec2 o = vec2(1.,0.);\n    int i = 0;\n    while(i < power) {\n        complexMultiply(o, a);\n        i++;\n    }\n    return o;\n}\nvec2 mandelbrot(vec2 z, vec2 c, int power) {\n    return complexMultiply(z, z) + c;\n    //return complexPower(z, power) + c;\n}\nvec2 pinwheel(float t) {\n    float BIGF = .25;\n    float LITTLEF = .9;\n    BIGF *= 4.;\n    LITTLEF *= 4.;\t\n    float BIGR = 1.;\n    float LITTLER = .4;\n    BIGR *= 2.;\n    LITTLER *= 2.;\n    return (BIGR - LITTLER) * vec2(cos(BIGF * t), sin(BIGF * t)) +\n        LITTLER * vec2(cos(LITTLEF * t), sin(LITTLEF * t));\n}\n#define ITERATIONS 500\n#define modi(a, b) ((a) - ((a) / (b)) * (b))\nstruct linetrap {\n    vec2 base;\n    vec2 dir;\n    vec3 cola;\n    vec3 colb;\n    vec3 colc;\n    float weight;\n    int num;\n    float dist;\n    float mean;\n    float var;\n};\nstruct pointtrap {\n    vec2 point;\n    vec3 cola;\n    vec3 colb;\n    vec3 colc;\n    float weight;\n    int num;\n    float dist;\n    float mean;\n    float var;\n};\n    #define AA 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float zoo = 0.62 + 0.38*cos(.07*time);\n        float coa = cos( 0.15*(1.0-zoo)*time );\n        float sia = sin( 0.15*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2. * fragCoord/iResolution.y - (iResolution.xy / iResolution.y);\n    float scale = 1.2;\n    scale = 5e-2;\n    vec2 shift = vec2(.5, 0.);\n    shift = vec2(1.4, .098);\n    uv = uv * scale - shift;\n        uv = c;\n    \n    vec2 z = uv, dz = vec2(0.);\n        /*\n        dz = vec2(1.);\n        uv = vec2(-.1,.7);\n        uv = vec2(-.79,.15);\n        uv = vec2(-.162,1.04);\n        uv = vec2(.3,-.01);\n        //uv = vec2(-1.476,.0);\n        //uv = vec2(-.12,-.77);\n        //uv = vec2(.28,.008);\n\t\t*/\n    int iterations = 0;\n    float bailout = 2.;\n    bailout = 2e5;\n    float bailoutradius = 0., bailoutiteration = 0.;\n    int power = 2;\n    float t = .59;\n    vec2 pointtrap = pinwheel(t);\n    vec2 linetrappoint = vec2(1., 0.);\n    t = 9.16;\n    //t = 0.;\n    linetrappoint = pinwheel(t);\n    vec2 linetrapdir = normalize(vec2(1., 1.));\n    float pointorbit = 1e10;\n    vec2 innerpointtrap = vec2(0.);\n    float innerpointorbit = 1e10;\n    \n    #define LINETRAPS 6\n    linetrap linetraps[LINETRAPS];\n    //*\n    for(int i = 0; i < 5; i++) {\n        float a = float(i - 2) * 3.14159 / (6. * 10.);\n        linetraps[i] = linetrap(\n            linetrappoint,\n            mat2(cos(a), sin(a), -sin(a), cos(a)) * linetrapdir,\n            //vec3(.5,0.,1.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            //.1 * vec3(1.,1.,0.),\n            vec3(float(0xA2) / 255., float(0xCC) / 255., float(0xB6) / 255.),\n            //vec3(0.,0.,1.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            .2,\n            0,\n            1e10,\n            0.,\n            0.\n        );\n    }\n\t//*/\n    t = 0.;\n    //*\n    linetraps[5] = linetrap(\n        pinwheel(t),\n        normalize(vec2(1., 2.)),\n        //vec3(0.,1.,1.),\n        vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n        .0 * vec3(1.,0.,1.),\n        //vec3(0.,1.,0.),\n        vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n        .5,\n        0,\n        1e10,\n        0.,\n        0.\n    );\n\t//*/\n    \n    while(iterations < ITERATIONS && length(z) < bailout) {\n        dz = 2. * complexMultiply(z, dz) + vec2(1.,0.);\n        z = mandelbrot(z, uv, power);\n        pointorbit = min(pointorbit, distance(pointtrap, z));\n        innerpointorbit = min(innerpointorbit, distance(innerpointtrap, z));\n        for(int i = 0; i < LINETRAPS; i++) {\n            vec2 ld = z - linetraps[i].base;\n            vec2 lp = dot(ld, linetraps[i].dir) * linetraps[i].dir;\n            float d = length(ld - lp);\n            linetraps[i].num = iterations;\n            linetraps[i].dist = min(linetraps[i].dist, d);\n            linetraps[i].mean =\n                float(iterations) / float(iterations + 1) * linetraps[i].mean +\n                1. / float(iterations + 1) * d;\n            linetraps[i].var += d * d;\n        }\n        iterations++;\n        if(iterations >= ITERATIONS || length(z) >= bailout) {\n            bailoutradius = length(z);\n            bailoutiteration = float(iterations);\n        }\n    }\n    for(int i = 0; i < LINETRAPS; i++)\n        linetraps[i].var = linetraps[i].var / float(linetraps[i].num) -\n        pow(linetraps[i].mean, 2.);\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    float escape = 1. - log(log(length(z))/log(bailout))/log(float(power));\n\n    // Output to screen\n    float minside = iterations < ITERATIONS ? 1. : 0.;\n    float cinside = length(uv) < 1. ? 1. : 0.;\n    \n    vec3 escapetimecolor = mix(vec3(0.), mix(\n        vec3(0.),\n        vec3(1., 0., 0.),\n        bailoutiteration / float(ITERATIONS)\n    ), minside);\n    vec3 distancecolor = mix(vec3(0.), mix(\n        vec3(1., 0., 0.),\n        vec3(0.),\n        pow(d, .125)\n    ), minside);\n    const int grade = 4;\n    const int cols = 7;\n    vec3 histogramcolors[grade * cols];\n    histogramcolors[0] = vec3(1.,0.,0.);\n    histogramcolors[grade] = vec3(1.,.5,0.);\n    histogramcolors[2 * grade] = vec3(1.,1.,0.);\n    histogramcolors[3 * grade] = vec3(0.,1.,0.);\n    histogramcolors[4 * grade] = vec3(0.,1.,1.);\n    histogramcolors[5 * grade] = vec3(0.,0.,1.);\n    histogramcolors[6 * grade] = vec3(1.,0.,1.);\n    for(int i = 0; i < cols; i++)\n        for(int j = 1; j < grade; j++)\n            histogramcolors[i*grade+j] = mix(\n                histogramcolors[i*grade],\n                histogramcolors[(i == cols - 1 ? 0 : i + 1)*grade],\n                float(j) / float(grade)\n            );\n    vec3 histogramcolor = mix(\n        vec3(0.),\n        histogramcolors[modi(iterations, grade * cols)],\n        minside\n    );\n    vec3 histogramcolora = histogramcolor;\n    vec3 histogramcolorb = mix(\n        vec3(0.),\n        histogramcolors[modi(iterations + 1, grade * cols)],\n        minside\n    );\n    bool useescape = true;\n    vec3 histogramcolori = mix(\n        histogramcolora,\n        histogramcolorb,\n        useescape ? escape : 1.\n    );\n    vec3 pointorbitcolor = mix(\n        vec3(0.),\n        mix(\n            //vec3(1.,0.,0.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            vec3(0.),\n            clamp(pointorbit, 0., 1.)\n        ),\n        minside\n    );\n    vec3 lineorbitcolor = vec3(0.);\n    for(int i = 0; i < LINETRAPS; i++)\n        lineorbitcolor += mix(\n            vec3(0.),\n            mix(\n                mix(\n                    linetraps[i].cola,\n                    linetraps[i].colc,\n                    log(float(linetraps[i].num + 1)) / log(float(ITERATIONS))\n                ),\n                linetraps[i].colb,\n                //linetraps[i].dist\n                clamp(linetraps[i].dist, 0., 1.)\n                //clamp(log(linetraps[i].mean)/log(bailout), 0., 1.)\n            ),\n            minside\n        ) * linetraps[i].weight;\n    vec3 innerpointorbitcolor = mix(\n        mix(\n            1.5 * vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n            -2. + vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            clamp(innerpointorbit, 0., 1.)\n        ),\n        vec3(0.),\n        minside\n    );\n    float shade = 1.;\n    fragColor = vec4(\n        vec3(minside) * vec3(1., 1. - cinside, 1. - cinside) * shade,\n        1.0\n    );\n    fragColor = vec4(escapetimecolor * shade,1.0);\n    fragColor = vec4(distancecolor * shade,1.0);\n    fragColor = vec4(histogramcolor * shade,1.0);\n    fragColor = vec4(histogramcolori * shade,1.0);\n    //*\n    fragColor = vec4(pointorbitcolor * shade,1.0);\n    fragColor = vec4(lineorbitcolor * shade,1.0);\n    fragColor = vec4((pointorbitcolor + lineorbitcolor + innerpointorbitcolor) * shade,1.0);\n    //fragColor = vec4(vec3(linetraps[2].dist) * shade,1.0);\n\t//*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 99], [100, 100, 140, 140, 270], [271, 271, 315, 315, 396], [397, 397, 421, 421, 712]]}
{"id": "WdfGzj", "name": "Stateless Analytic Ball Physics", "author": "fizzer", "description": "Here is a method to do a sort of physics \"simulation\" without needing to store anything between frames. The ball paths are split in to parabolic arcs, one arc for each sphere-disc collision.", "tags": ["collision", "sphere", "balls", "bounce", "stateless"], "likes": 30, "viewed": 1250, "published": "Public", "date": "1546799302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Here is a method to do a sort of physics \"simulation\" without needing to store anything\n// between frames. The ball paths are split in to parabolic arcs, one arc for each sphere-disc\n// collision.\n//\n// This allows for cool effects such as making time go backwards. Change the GO_BACKWARDS\n// macro to 1 to see this in action.\n//\n// This approach was used in this 4kb demo too: http://www.pouet.net/prod.php?which=71550\n\n#define NUM_SPHERES\t\t18\n#define GO_BACKWARDS\t0\n\nfloat time;\n\nvec4 discP[5];\nvec3 discN[5];\nvec4 spheres[NUM_SPHERES];\n\n// Ray vs. sphere intersection\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    \n    if (desc < 0.)\n        return vec2(1, 0);\n\n    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nvec3 traceSpherePath(int index, out float radscale)\n{\n    // Set up initial position and velocity\n    vec3 origin = vec3(0, 2, 0);\n    vec3 initial_velocity = vec3(.6, 1.5 + cos(float(index)) * .4, 0);\n\n    // Rotate velocity\n    float ya = float(index);\n    initial_velocity.xz *= mat2(cos(ya), sin(ya), -sin(ya), cos(ya));\n    \n    // Gravity\n    vec3 acceleration = vec3(0, -1.2, 0) * 3.;\n\n    vec3 pos, norm;\n\n    float tt = time + float(index)*.2;\n\n    float lifetime = 2.5;\n    tt = mod(tt, lifetime);\n    radscale = 1.;\n    radscale = smoothstep(0., .1, tt) - smoothstep(lifetime - .1, lifetime, tt);\n\n    float rad;\n\n    // Go through the whole particle motion up to the current timepoint, one parabolic arc at a time.\n    // Gravity is kept constant, so acceleration is not changed.\n    for(int j = 0; j < 3; ++j)\n    {\n        float minq = tt;\n\n        // Candidate arc resulting from a collision\n        vec3 new_origin, new_initial_velocity;\n\n        for(int i = 0; i < 5; ++i)\n        {\n            pos = discP[i].xyz;\n            rad = discP[i].w;\n            norm = discN[i];\n\n            // Set up a quadratic equation representing the intersection of the current\n            // parabolic arc with the plane which this disc lies on.\n            // This works because the arc of motion lies in a plane. The intersection of that\n            // plane with the disc's plane is a line. This line can be projected back in to the\n            // arc's plane and the intersection test then becomes a test for intersection between\n            // a parabola and a line in 2D, which is a quadratic equation.\n            float b = initial_velocity.y + dot(initial_velocity.xz, norm.xz) / norm.y;      \n            float d = b * b - acceleration.y * dot(origin - pos, norm) / norm.y * 4.;            \n            float q = (-b - sqrt(d)) / acceleration.y / 2.;\n\n            if(d > 0.)\n            {\n                // The equation has a real root\n                vec3 o = origin + initial_velocity * q + acceleration * q * q;\n\n                if(q > 0.&& q < minq && length(o - pos) < rad)\n                {\n                    // The intersection timepoint is valid, and the intersection point is\n                    // contained by the disc. So, update the collision candidate.\n                    new_origin = o;\n                    new_initial_velocity = reflect(initial_velocity + acceleration * q * 2., norm) * .6;\n                    minq = q;\n                }\n            }\n        }\n\n        if(tt>minq)\n        {\n            // The current arc collided with a disc, so replace it\n            // with a new arc representing the deflected particle motion.\n            origin = new_origin;\n            initial_velocity = new_initial_velocity;\n            tt -= minq;\n        }\n        else\n            break;\n    }\n\n    // Calculate the final particle position by evaluating the final parabola.\n    pos = origin + initial_velocity * tt + acceleration * tt * tt;\n\n    return pos;\n}\n\n// Returns an attentuated shadow amount and intersection distance of ray\nvec2 traceDiscs(vec3 ro, vec3 rd, float cone, out vec3 mn, float time)\n{\n    float l = 1.;\n    float mt = 1e4, t, w, d;\n    float rad;\n    vec3 pos, norm;\n    for(int i = 0; i < 5; ++i)\n    {\n        pos = discP[i].xyz;\n        rad = discP[i].w;\n        norm = discN[i];\n        t = dot(pos - ro, norm) / dot(rd, norm);\n        if(t > 0.)\n        {\n            w = t * cone;\n            d = length(ro + rd * t - pos) - rad;\n            l *= smoothstep(-w, w, d);\n            if(t < mt && d < 0.)\n            {\n                mt = t;\n                mn = norm * -sign(dot(norm, rd));\n            }\n        }\n    }\n    return vec2(l, mt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    time = iTime;\n    \n    // Set up disc positions, orientations, sizes\n    discP[0] = vec4(1, -.8, 0, 1);\n    discN[0] = normalize(vec3(.3, -1, 0));\n\n    discP[1] = vec4(-1, -.4, 0, 1);\n    discN[1] = normalize(vec3(-.3, -1, 0.4));\n\n    discP[2] = vec4(0, -.8, 1.4, 1.1);\n    discN[2] = normalize(vec3(0, -1, .3));\n\n    discP[3] = vec4(.4, 0.1, .1, .4);\n    discN[3] = normalize(vec3(0, -1, 0.1));\n\n    discP[4] = vec4(0, -1.5, 0, 1);\n    discN[4] = normalize(vec3(.0, -1, 0));\n\n    // Motion jitter\n    time += texelFetch(iChannel0, ivec2(mod(fragCoord.xy, 1024.)), 0).x * .015;\n\n    // Set up primary ray\n    float an = 1. + time / 2.;\n    an = 2.3 + sin(time / 2.);\n\n    vec3 ro = vec3(0., 0., 4.4);\n    vec3 rd = normalize(vec3(uv.xy, -1.9));\n\n    rd.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * rd.xz;\n    ro.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * ro.xz;\n\n\n#if GO_BACKWARDS\n    time = -time;\n#endif\n\n    vec3 norm;\n    float t = 1e4;\n\n    vec3 hitcol = vec3(1);\n\n    // Test intersection with spheres\n    for(int j = 0; j < NUM_SPHERES; ++j)\n    {\n        float radscale;\n        vec3 p = traceSpherePath(j, radscale);\n\t\tfloat r = 1.2 * radscale * mix(.06, .1, .5 + .5 * cos(float(j)));\n        \n        spheres[j] = vec4(p, r);\n        \n        vec2 i = intersectSphere(ro, rd, p, r);\n        \n        if(i.x > 0. && i.x < i.y && i.x < t)\n        {\n            t = i.x;\n            norm = ro + rd * t - p;\n            hitcol = mix(vec3(1, .4, .05), vec3(.3, 1, .1), .5 + .5 * cos(float(j) * 8.));\n        }\n\n    }\n\n    // Test intersection with discs\n    vec3 dn;\n    vec2 dt = traceDiscs(ro, rd, 0., dn, time);\n\n    if(dt.y < t)\n    {\n        t = dt.y;\n        norm = dn;\n        hitcol = vec3(1);\n    }\n\n    if(t > 1e3)\n    {\n        // Background\n        fragColor.rgb = vec3(.05 - length(uv) / 40.);\n    }\n    else\n    {\n        // Intersected with sphere or disc\n        vec3 hitp = ro + rd * t;\n        float l = 1.;\n\n        norm = normalize(norm);\n\n        vec3 ld = normalize(vec3(1, 1, 1));\n        vec3 r = reflect(rd, norm);\n\n        // Do some soft shadowing\n        l *= mix(.125, 1., traceDiscs(hitp + norm * 1e-4, ld, .2, dn, time).x);\n        l *= mix(.25, 1., traceDiscs(hitp + norm * 1e-4, vec3(0, 1, 0), .53, dn, time).x);\n\n\t\t// Trace hard sphere shadows\n        for(int j = 0; j < NUM_SPHERES; ++j)\n        {\n            vec4 sph = spheres[j];\n\n            vec2 i = intersectSphere(hitp + norm * 1e-4, ld, sph.xyz, sph.w);\n            \n            if(i.x > 0. && i.x < i.y)\n            {\n                l *= 0.5;\n                break;\n            }\n\n        }\n\n        // Shading\n        vec3 h = normalize(ld - rd);\n\n        float fr = (1. - dot(-rd, norm)) * .3;\n\n        fragColor.rgb = l * (vec3(max(0., dot(norm, ld))) * hitcol + vec3(fr * .7 + pow(max(0., dot(norm,h)), 64.)) / 2.);\n        fragColor.rgb += .01;\n    }\n    \n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n    \n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    // Dither\n    fragColor.rgb += texelFetch(iChannel0, ivec2(mod(fragCoord.xy, 1024.)), 0).y / 100.;\n}\n\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 574, 635, 635, 919], [921, 921, 974, 1018, 3911], [3913, 3986, 4058, 4058, 4625], [4628, 4628, 4685, 4735, 7937]]}
{"id": "wdj3Wz", "name": "gede kecil gede kecil", "author": "sanddroo", "description": "teuing ah lier", "tags": ["gatau"], "likes": 0, "viewed": 245, "published": "Public API", "date": "1548654311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define  PI 3.142857142\n#define DPI 6.285714285\nfloat pol(in vec2 uv, float n, float tam){\n    \n    float a = atan(uv.x, uv.y) - 3.14;\n    float r = DPI/n;\n    float d = cos(floor(0.5+a/r)*r-a)*length(uv);\n    d = 1.0-step(tam,d); \n    return d;\n}\t\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,0.0,_scale.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    uv -= .5;\n   \tuv.x *= iResolution.x/iResolution.y;\n    uv = scale( vec2(sin(iTime)+1.0) ) *uv;\n    \n    float p1 = pol(uv, 6.0, 0.25);\n   \tcol += vec3(p1)*vec3(0,0.5,1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdj3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 90, 90, 247], [250, 250, 274, 274, 320], [322, 322, 379, 379, 669]]}
{"id": "wdj3zD", "name": "Register Allocation", "author": "iq", "description": "Shows how register allocation can kill GPU parallelism, even if the amount of computations are the same and the same number of registers are touched. Change NUM in line 23 to see the effects.", "tags": ["performance", "gpu", "reguster"], "likes": 17, "viewed": 2260, "published": "Public API", "date": "1548365072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Shows how register allocation can kill GPU parallelism, even if the amount of computations\n// are the same and the same number of registers are touched. This is the performance I get in\n// my laptop as a function of the buffer size NUM: \n//\n// NUM     fps\n//\n//  128    120\n//  192    108\n//  224     98\n//  256     85\n//  384     60\n//  448     52\n//  512     45\n//  768     31\n// 1024     24\n// 2048     12\n\n#define NUM 256   // change this\n\nvec4 data[NUM];\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int id = (int(fragCoord.x) + iFrame) % NUM;\n\n    data[0    ] = vec4(sin(iTime+0.0), 0.0, 0.0, 1.0 );\n\tdata[id   ] = vec4(0.0, sin(iTime+2.0), 0.0, 1.0 );\n\tdata[NUM-1] = vec4(0.0, 0.0, sin(iTime+4.0), 1.0 );\n    \n    fragColor = data[0] + data[id] + data[NUM-1];\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdj3zD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1079, 1547, 1604, 1604, 1872]]}
{"id": "wdjGDz", "name": "Kendall Jenner Hot", "author": "sanddroo", "description": "hahhahaah", "tags": ["spinny", "muter", "toeng"], "likes": 2, "viewed": 266, "published": "Public API", "date": "1548658981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define  PI 3.142857142\n#define DPI 6.285714285\n\nfloat pol(in vec2 uv, float n, float tam){\n    \n    float a = atan(uv.x, uv.y) - 3.14;\n    float r = DPI/n;\n    float d = cos(floor(0.5+a/r)*r-a)*length(uv);\n    d = 1.0-step(tam,d); \n    return d;\n}\n\nfloat Circle (vec2 uv, float blur, float r) {\n    float d = length(uv);\n    float c = smoothstep(r,r-blur,d);\n    return c;\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; \n    vec2 uv1 = fragCoord/iResolution.xy; \n    vec2 uv2= fragCoord/iResolution.xy; \n    vec2 uv3 = fragCoord/iResolution.xy;\n    vec2 uv4 = fragCoord/iResolution.xy; \n    vec2 pos= vec2(-1.,0.);\n    vec2 pos1= vec2(-1.,0.);\n    \n    vec3 col;\n    uv -= .5;\n    uv1 -= .5;\n    uv2 -= .5;\n    uv3 += pos;\n    uv4 += pos1;\n    \n   \tuv.x *= iResolution.x/iResolution.y;\n\tuv1.x *= iResolution.x/iResolution.y;\n\tuv2.x *= iResolution.x/iResolution.y;\n    uv3.x *= iResolution.x/iResolution.y;\n    uv4.x *= iResolution.x/iResolution.y;\n\n   \tuv = scale( vec2(sin(iTime)/1.5+1.) ) *uv;\n    float p1 = pol(uv, 6.0, 0.1);\n    \n    uv1 = rotate2d( sin(iTime)*PI) * uv1;\n    float t1= pol(uv1,3.0,0.1);\n\n    vec2 translate = vec2(cos(iTime),sin(iTime));\n    uv2 += translate*0.4;\n    float r1= pol(uv2,4.0,0.1);\n    \n    pos = vec2(-1.+sin(iTime)/2.,0.5);\n    float c0 = Circle(uv3-pos ,.001,.08);\n    \n    pos1 = vec2(-.9,0.5+sin(iTime)/2.);\n    float c1 = Circle(uv4 -pos1,.001,.08);\n\n    col += vec3(p1)*vec3(0,0.5,1);\n\tcol += vec3(t1)*vec3(1.,0.,0.);\n    col += vec3(r1)*vec3(0.,1.,0.);\n    col += vec3(c0)*vec3(.5,.5,0.);\n    col += vec3(c1)*vec3(0.,.5,.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 91, 91, 248], [250, 250, 295, 295, 375], [376, 376, 400, 400, 446], [448, 448, 476, 476, 562], [563, 563, 620, 620, 1871]]}
{"id": "WdjGR1", "name": "simple spiral test", "author": "Fab48", "description": "my first shader here !\nbased on an other spiral :  https://www.shadertoy.com/view/XtsGDj", "tags": ["spiral"], "likes": 2, "viewed": 127, "published": "Public", "date": "1548155875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPIRAL_COUNT 5.\n#define RADIUS 2.\n#define TWISTPOW 1.\n    \nvec4 color = vec4(1.0,0.0, 1.0,1.0);\nvec4 colorBackground = vec4(0.0,0.0, 0.0,1.0);\n\n//my first shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime*0.5;\n    \n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angle = atan(uv.y,uv.x) +t ;\n        \n    angle -= TWISTPOW *length(uv) ;\n\n    vec4 col = color * vec4(cos( SPIRAL_COUNT * angle));\n    \n    vec3 center = vec3(clamp(RADIUS-length(uv*2.2),0.,1.));\n        \n    \n    //gradient\n    col = ( mix(col,color , smoothstep(RADIUS,0., length(center)  )) ) ;\n    \n    //center black\n    col *= vec4( smoothstep(0.0,0.5*RADIUS, length(uv)*2. ));\n    \n    fragColor =  mix(color,colorBackground, length(col));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 170, 227, 227, 787]]}
{"id": "WdjGRm", "name": "CastingBallsWave", "author": "impfromliga", "description": "CastingBallsWave", "tags": ["castingballswave"], "likes": 1, "viewed": 83, "published": "Public", "date": "1548450602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float minDrawDist = 10.0;\nconst int   maxRayMarcs = 1000;\nconst float cellSize    = 1000.0;\nconst float ballRadius  = 200.0;\n\nvec3 camPos;\n\nfloat getDist(vec3 rayPos)\n{\n    float t = iTime / 4.0;\n\tfloat t1 = 1000.0 - (t - floor(t)) * 1000.0;\n\tfloat t2 = 2000.0 - (t - floor(t)) * 2000.0;\n\tfloat t4 = - (t/6.282 - floor(t/6.282)) * 16000.0;\n    rayPos.z -= t4;\n    vec3 vertex = floor(-((camPos - rayPos) - ballRadius) / cellSize) * cellSize;\n\tfloat y = vertex.y;\n    vertex.z += (sin((vertex.z + y + 8.0 * sqrt(2.0 * abs(t - floor(t) - .5)) ) / 2.0) + 1.0) * 250.0; //floor(iTime * 500.0 / cellSize) * cellSize;\n    vertex.y += abs(cos((vertex.z ) / 2000.0 + iTime) * 400.0);\n    vertex.y += abs(sin((vertex.z ) / 250.0 + iTime) * 200.0);\n    \n//vertex.z += (sin(iTime * 3.0) + 1.0) * 180.0; //floor(iTime * 500.0 / cellSize) * cellSize;\n    \n\t\n\tvec3 pos = camPos + vertex;\n\treturn distance(pos, rayPos) - ballRadius;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2  e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n\t    getDist(p - e.xyy),\n\t    getDist(p - e.yxy),\n\t    getDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 outputPixel = vec4(0.0);\n\t\n\tvec2 position = gl_FragCoord.xy;\n\t\n\tcamPos = vec3(\n\t\tiResolution.x / 2.0, \n\t\tiResolution.y / 2.0, \n\t\t-600.0\n\t);\n\t\n\tvec3 lightPos = vec3(\n\t\tiResolution.x * 6.0 + sin(11.0 / 10.0 * iTime + .5) * 2000.0, \n\t\tcos(7.0 / 10.0 * iTime + .5) * iResolution.y * 10.0,\n\t\tcos(3.0 / 10.0 * iTime + 1.5) * 5000.0\n\t);\n\t    \n\tvec3 rayPos = vec3(position, 0.0);\n\tvec3 rayVec = normalize(rayPos - camPos);\n\t\n\tvec4 ballColor = vec4(1.0, .4, .4, 1.0);\n\t\n\tvec3 curRayPos = rayPos * minDrawDist;\n\tfor (int i = 0; i < maxRayMarcs; i ++)\n\t{ \n\t\tfloat distToBall = getDist(curRayPos);\n\t\tif (distToBall < .1)\n\t\t{\n\t\t\tvec3  normal = getNormal(curRayPos);\n            \t\tfloat light  = dot(normalize(lightPos - curRayPos), normal);\n           \t\tlight = clamp(abs(light), 0.0, 1.0) + 0.02;\n\t\t\tlight *= 1000000.0 / pow(abs(curRayPos.z - camPos.z), 2.0);\n\t\t\toutputPixel = pow(light, 1.0 / 1.8) * ballColor;\n\t\t\t\n\t\t\t\n\t\t\tbreak;\n\t\n\t\t} else\n\t\t{\n\t\t\tcurRayPos += rayVec * 20.0;\n\t\t}\n\t}\n\t\n\t\n\tfragColor = outputPixel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 174, 174, 925], [927, 927, 951, 951, 1149], [1151, 1151, 1208, 1208, 2217]]}
{"id": "wdjGWR", "name": "mandelbulb raymarched", "author": "Myro", "description": "a study on rendering 3D fractals with a basic raymarching renderer (mandelbulb)", "tags": ["3d", "raymarching", "fractal", "mandelbrot", "mandelbulb", "animated", "red", "blue"], "likes": 12, "viewed": 1760, "published": "Public", "date": "1548637075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// controls : click and drag to navigate\n\n// base raymarching rendering thing\n// https://www.youtube.com/watch?v=yxNnRSefK94\n\n\n// fractal by\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n\n\n#define MARCHINGITERATIONS 64\n\n#define MARCHINGSTEP 0.5\n#define SMALLESTSTEP 0.1\n\n#define DISTANCE 3.0\n\n#define MAXMANDELBROTDIST 1.5\n#define MANDELBROTSTEPS 64\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(0.01,0.01,0.01),vec3(0.00, 0.15, 0.20) );\n}\n\n// distance estimator to a mandelbulb set\n// returns the distance to the set on the x coordinate \n// and the color on the y coordinate\nvec2 DE(vec3 pos) {\n    float Power = 3.0+4.0*(sin(iTime/30.0)+1.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < MANDELBROTSTEPS ; i++) {\n\t\tr = length(z);\n\t\tif (r>MAXMANDELBROTDIST) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,50.0*pow(dr,0.128/float(MARCHINGITERATIONS)));\n}\n\n// MAPPING FUNCTION ... \n// returns the distance of the nearest object in the direction p on the x coordinate \n// and the color on the y coordinate\nvec2 map( in vec3 p )\n{\n    //p = fract(p); \n   \tvec2 d = DE(p);\n\n  \n\n   \treturn d;\n}\n\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n\t\n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHINGITERATIONS; i++) {\n    \tvec3 path = origin + ray * t;\t\n    \tvec2 dist = map(path);\n    \t// we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHINGSTEP * dist.x;\n        c += dist.y;\n        if (dist.y < SMALLESTSTEP) break;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t// Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    //ROTATING THE CAMERA (rotating the ray)\n    float rotAngle = 0.4+iTime/40.0 + 6.28*iMouse.x / iResolution.x;\n    //rotation matrix around the y axis\n    ray.xz *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));\n    \n    //camera position (rays origin)\n    float camDist = DISTANCE * iMouse.y / iResolution.y;\n    if (iMouse.xy==vec2(0)) camDist = DISTANCE*0.55;\n    vec3 origin = vec3 (camDist * sin(rotAngle),0.0,-camDist *cos(rotAngle));           \n    \n    //tracing the ray (getting the distance of the closest object in the ray direction)\n\tvec2 depth = trace(origin,ray);\n\t\n    //rendering with a fog calculation (further is darker)\n\tfloat fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 470, 546, 546, 589], [590, 590, 614, 614, 726], [728, 863, 882, 882, 1525], [1527, 1675, 1698, 1719, 1760], [1763, 1905, 1942, 2014, 2395], [2397, 2397, 2454, 2504, 3633]]}
{"id": "WdjGWz", "name": "The Keeper", "author": "Flopine", "description": "Sunday mood! A quick draft shader :) Hope you'll enjoy it.\nThe animation is looping after 50 seconds.", "tags": ["raymarching", "modeling", "glow"], "likes": 15, "viewed": 275, "published": "Public", "date": "1548618444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 64.\n#define PI 3.141592\n#define anim mod(iTime*10., 500.)\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a), sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rep3d (inout vec3 p, float per)\n{\n    vec3 id = floor((p-per/2.)/per);\n    p = mod(p-per/2., per)-per/2.;\n    return id;\n}\n\nfloat half_sphe (vec3 p, float r)\n{\n    float d = max(length(p)-r, abs(p.y-r/2.)-r/2.);\n    return d ;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat g1 = 0.;\nfloat od (vec3 p, float q)\n{\n\tp.yz *= rot(iTime);\n    float d = dot(p, normalize(sign(p)))-q;\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat tentacle (vec3 p)\n{\n    float o = od (vec3(p.x, p.y-12., p.z), 2.);\n    p.xz *= rot(p.y*0.15);\n    p.xz = moda(p.xz, PI/4.);\n    p.x -= 5.;\n    float t = cyl(p.xzy, 0.5+p.y*0.02, 20.);\n    float d =  min(t, o);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat bodies (vec3 p)\n{\n    p.y -= 5.;\n    p.xz += sin(p.y*0.4+iTime);\n    float hs = max(-half_sphe(vec3(p.x, p.y+1., p.z), 5.),half_sphe(p, 7.));\n    p.y += 20.;\n    float t = tentacle(p);\n    float d = smin(hs, t, 1.5);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n    \n}\n\nfloat bubulle (vec3 p)\n{\n    p.y += iTime*0.6;\n    vec3 id = rep3d(p, 10.);\n    p.xy *= rot(iTime*0.1*hash(id));\n    p += sin(iTime*hash(id));\n    return length(p)-.2;\n}\n\nfloat SDF (vec3 p)\n{\n    p.y -= anim*1.2;\n    float b = bubulle(p);\n    p.xz *= rot(iTime*0.5);\n    return min(bodies(p), b);\n\n}\n\nvec3 norms (vec3 p)\n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(vec3(SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n    \t\t\t\t\t)\n                    );\n}\n\nfloat lighting(vec3 n, vec3 l)\n{return dot (n, normalize(l))*0.5+0.5;}\n\n\nvec3 get_cam (vec3 eye, vec3 tar, vec2 uv, float fov)\n{\n    vec3 forward = normalize(tar-eye);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross(forward, left));\n    return normalize(forward*fov + left*uv.x + up * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = 2.*(q)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += texture(iChannel0, uv+iTime*0.4).rg*length(uv*0.5)*0.1;\n    \n    vec3 ro = vec3(5.,3.+anim, -20.); vec3 p = ro;\n    vec3 target = vec3(0., -6.+anim*1.2, 0.);\n    vec3 rd = get_cam(ro,target, uv, 1.);\n        \n    bool hit = false;\n    vec3 col = vec3(0.);\n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.4;\n    }\n    \n    if (hit)\n    {\n        vec3 n = norms(p);\n        col = mix(vec3(0.1,0.5,0.9), vec3(1.),lighting(n, vec3(2.,10.,-20.)));\n    }\n    \n    // glow\n\tcol += g1 * vec3(1.,0.7, 0.1);\n\tcol += g2*vec3(uv.y,0.1,uv.y+2.)*0.2*clamp(sin(iTime), 0., 1.);\n    \n    // fog\n    float t = length(ro-p); \n    col = mix(col, vec3(0.,0.08,0.2),1.-exp(-0.001*t*t));\n    \n    // vignetting from iq\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 2.);\n    \n    // gamma correct\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 259, 279, 279, 374], [376, 376, 396, 396, 440], [442, 442, 473, 473, 600], [602, 602, 643, 643, 736], [738, 738, 776, 776, 865], [867, 867, 902, 902, 971], [973, 973, 1011, 1011, 1050], [1067, 1067, 1095, 1095, 1201], [1203, 1203, 1228, 1228, 1435], [1452, 1452, 1475, 1475, 1720], [1722, 1722, 1746, 1746, 1891], [1893, 1893, 1913, 1913, 2021], [2023, 2023, 2044, 2044, 2279], [2281, 2281, 2313, 2313, 2351], [2354, 2354, 2409, 2409, 2615], [2617, 2617, 2674, 2724, 3857]]}
{"id": "wdjGzz", "name": "Creation + Flame", "author": "PcChip", "description": "kaleidoscope + flame", "tags": ["kaleidoscope"], "likes": 6, "viewed": 170, "published": "Public", "date": "1548034701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvec4 background(vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<10;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\t//fragColor=vec4(c/l,t);\n    return vec4(c*2.0*(sin(t)+1.5) / l, 1.0);\n}\n\n\n\n\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.7,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.0);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*1.666,4.));\n    fragColor += background(fragCoord.xy);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 168, 201, 201, 494], [500, 500, 542, 542, 779], [781, 781, 813, 813, 850], [852, 852, 873, 873, 1005], [1007, 1007, 1028, 1028, 1076], [1078, 1078, 1113, 1113, 1391], [1393, 1393, 1450, 1450, 1846]]}
{"id": "wdl3Rl", "name": "Julia's Quilt", "author": "bignobody", "description": "First attempts at colouring a Julia Set fractal with orbit trapping. Thanks to iq for the articles!", "tags": ["juliaset", "orbittrap"], "likes": 1, "viewed": 70, "published": "Public", "date": "1547259456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 p = uv - vec2(0.5,0.5);\n    vec2 z = p * 1.5;\n    vec2 c = vec2(-0.745, 0.19);\n    float t = 0.0;\n    vec2 bo = vec2(9999.0,9999.0);\n    float bl = 99999.0;\n    vec2 wo = vec2(0.0,0.0);\n    float wl = 0.0;\n    float it = 0.0;\n    float os = 0.0;\n    for (int i = 0; i < 64; i ++)\n    {\n     \tvec2 nz = vec2(z.x*z.x - z.y*z.y, (1.5 - cos(iTime * 0.022)) * z.x * z.y) +c;\n        vec2 no = nz - p;\n        float nl = length(no);\n        os += nl;\n        it += 1.0;\n        if (nl > wl)\n        {\n        \two = no;\n            wl = nl;\n            \n        }\n        if (nl < bl)\n        {\n        \tbo = no;\n            bl = nl;\n            \n        }\n        \n        float m2 = dot(z.x,z.x);\n        if (m2 > 4.0)\n        {\n           // bl = 1.0;\n        \tbreak;   \n        }\n        z = nz;\n        t += 1.0/63.0;\n    }\n    \n\tvec3 tintb = vec3(0.3,0.6,0.8);\n    vec3 tintr = vec3(0.8,0.4,0.1);\n    float avgo = os/it;\n    \n    vec3 col = mix(mix(vec3(t) , tintb, dot(bo,wo)+avgo) , mix(vec3(t) , tintr, sqrt(avgo)) , sqrt(bl));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdl3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1246]]}
{"id": "Wdl3W4", "name": "Simple Rose Petal", "author": "jonobr1", "description": "Attempt to make a GLSL based 3D looking leaf rotating. To be used with a WebGL Particle System. With help and explanation from: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/ and http://iquilezles.org/www/articles/distfunctions/d", "tags": ["3d", "geometry"], "likes": 10, "viewed": 862, "published": "Public API", "date": "1546386515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdEllipsoid( in vec3 p, in vec3 r ) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 sight ) {\n\n    // Of the object\n    vec3 position = vec3( 0.0, 0.0, 0.0 );\n\n    // The xyz component radius values of the ellipsoid\n    vec3 radius = vec3( 1.5, 0.1, 1.0 );\n\n    // Define position in relation to the camera\n    position = sight - position;\n\n    // Bend the ellipsoid on the z axis\n    float bend = 0.2;\n    float c = cos( position.z * bend );\n    float s = sin( position.z * bend );\n    mat2  m = mat2( c, - s, s, c );\n    vec3  q = vec3( m * position.xy, position.z );\n\n   \t// Bend the ellipsoid on the x axis\n    bend = - 0.1;\n    c = cos( q.x * bend );\n    s = sin( q.x * bend );\n    m = mat2( c, - s, s, c );\n    q = vec3( m * q.xy, q.z );\n\n    vec3 worldPosition = q;\n\n    float sdf = sdEllipsoid( worldPosition, radius );\n    vec2 res = vec2( sdf, 0.0 );\n\n    return res;\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n\n    // Near / Far Clipping Plane\n    float tmin = 1.0;\n    float tmax = 50.0;\n    \n    float t = tmin;\n    float m = - 1.0;\n    // TODO: Why does it need so many iterations\n    // to march correctly?\n    for( int i = 0; i < 128; i++ ) {\n\n\t    float precis = 0.0004 * t;\n\t    vec2 res = map( ro + rd * t );\n\n        // Means no intersection\n        // and no possibility of checking again\n        // so stop the Ray Marching\n        if( res.x < precis || t > tmax ) break;\n\n        t += res.x;\n\t    m = res.y; // Identify which shape was intersected via a float\n\n    }\n\n    if( t > tmax ) m =- 1.0;\n    return vec2( t, m );\n}\n\nvec3 render( in vec3 ro, in vec3 rd ) {\n\n    vec3 col = vec3( 0.85 );\n    vec2 res = castRay( ro,rd );\n\n    float t = res.x;\n\tfloat m = res.y;\n\n    // Ray intersected object\n    if( m >= 0.0 ) {\n        // normalize t and flip it\n\t\tfloat tn = 1.0 - t / 24.5;\n        vec3 white = vec3( 1.0, 1.0, 0.75 );\n        vec3 red = vec3( 1.0, 0.0, 0.15 );\n\t\tcol = mix( red, white, pow( tn, 2.0 ) );\n    }\n\n\treturn vec3( clamp( col, 0.0, 1.0 ) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\n    vec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv = normalize( cross( cu, cw ) );\n\n    return mat3( cu, cv, cw );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = iTime;\n\n    vec2 p = ( - iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n\t// Camera Position\n    // vec3 ro = vec3( 10.0 * cos( mo.x * 3.14 ), 10.0 * mo.y - 5.0, 10.0 * sin( mo.x * 3.14 ) );\n    vec3 ro = vec3( 10.0 * cos( time ), 10.0 * sin( time * 2.0 ), 10.0 * sin( time ) );\n    // Camera Look At Vector\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    // TODO: Don't understand the z-component `8.0`\n    // But I think it has soemthing to do with\n    // the zoom of the camera.\n    vec3 rd = ca * normalize( vec3( p.xy, 8.0 ) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4( col, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdl3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 132], [134, 204, 231, 253, 1018], [1020, 1020, 1060, 1094, 1686], [1688, 1688, 1727, 1727, 2126], [2128, 2128, 2180, 2180, 2380], [2382, 2382, 2439, 2439, 3217]]}
{"id": "wdlGDB", "name": "Re: materials", "author": "gest", "description": "original: https://www.shadertoy.com/view/Xsl3DS", "tags": ["lighting", "sphere", "materials", "plane", "intersect"], "likes": 5, "viewed": 124, "published": "Public", "date": "1547449768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\nPlane plane_1 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,1,0));\nPlane plane_2 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,0,1));\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\nSphere sphere_1 = Sphere(vec3(-1.0, 1.5, 1.0), 0.4);\nSphere sphere_2 = Sphere(vec3( 1.0, 1.5, 1.0), 0.4);\nSphere sphere_3 = Sphere(vec3( 0.0, 1.5, 1.0), 0.4);\nSphere sphere_4 = Sphere(vec3( 0.0, 1.5, 2.0), 0.4);\n\t\nstruct Box {\n\tvec3 center;\n\tvec3 size;\n};\nBox box_1 = Box(vec3(-1.0, 1.5, -1.0), vec3(0.4) );\nBox box_2 = Box(vec3( 1.0, 1.5, -1.0), vec3(0.4) );\nBox box_3 = Box(vec3( 0.0, 1.5, -1.0), vec3(0.4) );\nBox box_4 = Box(vec3( 0.0, 1.5, -2.0), vec3(0.4) );\n\nstruct Material {\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n\tfloat shininess;\n\t\n\tfloat reflectivity;\n\tfloat refractivity;\n\tfloat indexRefractive;\n\tbool flagSolid;\n};\nMaterial material_sphere_1;\nMaterial material_sphere_2;\nMaterial material_sphere_3;\nMaterial material_sphere_4;\nMaterial material_plane_1b;\nMaterial material_plane_1w;\n\nstruct Light {\n\tvec3 position;\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n};\nLight light_0 = Light ( vec3(-0.5, -0.5, -2.0), vec3(1), vec3(1), vec3(1) );\nLight light_1 = Light ( vec3( 0.5,  0.5, -2.0), vec3(1), vec3(1), vec3(1) );\nconst int lightCount = 1;\n\nMaterial getMaterial (Ray ray) {\n\tMaterial material;\n\tif (ray.object.id == 0) {\n\t\tmaterial = material_sphere_1;\n\t} else if (ray.object.id == 1) {\n\t\tmaterial = material_sphere_2;\n\t} else if (ray.object.id == 2) {\n\t\tmaterial = material_sphere_3;\n\t} else if (ray.object.id == 3) {\n\t\tmaterial = material_sphere_4;\n\t} else if (ray.object.id == 4) {\n//\t\tfloat r = 0.25;\n//\t\tfloat squareSize = ( 1.0 + r*2.0 ) / 2.0;\n\t\tfloat squareSize = 0.5;\n\t\tvec3 p = mod ( ray.position - plane_1.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s;\n\t\tfloat h = s;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_1b;\n\t\t} else {\n\t\t\tmaterial = material_plane_1w;\n\t\t}\n\t}\n\treturn material;\n}\n\t\n//-----------------------------------------------------------------------------------------\t\n//Пересечение луча со сферой\nfloat intersectSphere(Ray ray, Sphere sphere, inout vec3 normal) {\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.center - ray.origin;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 ) return ray.far;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 ) return ray.far;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 ) {\n\t\tt = t1;\n\t} else if ( t1 < 0.0 ) {\n\t\tt = t0;\n\t} else {\n\t\tt = min(t0,t1);\n\t}\n\tif (t<0.0) return ray.far;\n\tvec3 p = ray.origin + t * ray.direction;\n\tfloat flagInside = -sign(dot(ray.direction, p - sphere.center));\n\tnormal = normalize ( p - sphere.center ) * flagInside;\n\treturn t;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane(Ray ray, Plane plane, inout vec3 normal) {\n\tfloat det = dot ( plane.normal, ray.direction );\n\tif (abs(det) < ray.epsilon) return ray.far;\n\n\tfloat t = - ( dot ( plane.normal, ray.origin ) + length(plane.center) ) / dot ( plane.normal, ray.direction );\n\t\n\tif ( t < 0.0 ) return ray.far;\n\t\n\tfloat flagInside = -sign(dot(ray.direction, plane.normal));\n\tnormal = plane.normal;\n\tnormal *= flagInside;\n\t\t\n\treturn t;\t\n}\n//Пересечение луча с кубом\nfloat intersectBox(Ray ray, Box box, inout vec3 normal) {\n\t\n\tvec3 minp = box.center - box.size;\n\tvec3 maxp = box.center + box.size;\n\t\n\tfloat tmin = (minp.x - ray.origin.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.origin.x) / ray.direction.x;\n\tif (tmin > tmax) { \n\t\tfloat s = tmin; \n\t\ttmin = tmax; \n\t\ttmax = s; \n\t}\n\tfloat tymin = (minp.y - ray.origin.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.origin.y) / ray.direction.y;\n\tif (tymin > tymax) { \n\t\tfloat s = tymin; \n\t\ttymin = tymax; \n\t\ttymax = s; \n\t}\n\tif ((tmin > tymax) || (tymin > tmax)) return ray.far;\n\tif (tymin > tmin) tmin = tymin;\n\tif (tymax < tmax) tmax = tymax;\n\tfloat tzmin = (minp.z - ray.origin.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.origin.z) / ray.direction.z;\n\tif (tzmin > tzmax) { \n\t\tfloat s = tzmin; \n\t\ttzmin = tzmax; \n\t\ttzmax = s; \n\t}\n\tif ((tmin > tzmax) || (tzmin > tmax)) return ray.far;\n\tif (tzmin > tmin) tmin = tzmin;\n\tif (tzmax < tmax) tmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < ray.epsilon && tmax < ray.epsilon ) return ray.far;\n\tif ( tmin < ray.epsilon ) {\n\t\tt = tmax;\n\t} else if ( tmax < ray.epsilon ) {\n\t\tt = tmin;\n\t} else {\n\t\tt = min(tmin, tmax);\n\t}\n\t\n\tfloat flagInside = 1.;\n\tif ( tmin < ray.epsilon && tmax > ray.epsilon ) flagInside = -1.;\n\t\n\tvec3 p = ray.origin + t * ray.direction;\n\t\n\tif ( abs(p.x - maxp.x) < ray.epsilon ) {\n\t\tnormal = vec3(1,0,0) * flagInside;\n\t} else if ( abs(p.x - minp.x) < ray.epsilon ) {\n\t\tnormal = vec3(-1,0,0) * flagInside;\n\t} else if ( abs(p.y - maxp.y) < ray.epsilon ) {\n\t\tnormal = vec3(0,1,0) * flagInside;\n\t} else if ( abs(p.y - minp.y ) < ray.epsilon ) {\n\t\tnormal = vec3(0,-1,0) * flagInside;\n\t} else if ( abs(p.z - maxp.z ) < ray.epsilon ) {\n\t\tnormal = vec3(0,0,1) * flagInside;\n\t} else {\n\t\tnormal = vec3(0,0,-1) * flagInside;\n\t}\n\treturn t;\n}\n\n\n//---------------------------------------------------------------------------------\nvoid rayMarch(inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.hit \t\t= false;\n\tray.distance \t= ray.far;\n\tray.position \t= ray.origin + ray.distance * ray.direction;\n\tray.normal \t\t= vec3(0);\n\tray.object.id \t= -1;\n\n\tSphere sphere;\n\tPlane plane;\n\t\n\tfloat d;\n\tvec3 normal;\n\n\tfloat radius = 0.25;\n\t\n\tfor (float i=0.; i<4.; i++) {\n\t\tvec3 position = vec3(sin(i*1000.0), sin(i*10000.0), sin(i*100.0));\n\t\tvec3 velocity = vec3(cos(i*200.0+i*400.0+500.0), cos(i*400.0+i*2000.0+500.0), cos(i*600.0)) / 2.0;\n\t\tvec3 center = position + velocity * u_time;\n\t\t\n\t\tcenter = mod ( center, 4.0 ) - 2.0;\n\t\tif ( center.x >  1.0 ) center.x =  2.0 - center.x;\n\t\tif ( center.y >  1.0 ) center.y =  2.0 - center.y;\n\t\tif ( center.z >  1.0 ) center.z =  2.0 - center.z;\n\t\tif ( center.x < -1.0 ) center.x = -2.0 - center.x;\n\t\tif ( center.y < -1.0 ) center.y = -2.0 - center.y;\n\t\tif ( center.z < -1.0 ) center.z = -2.0 - center.z;\n\n\t\tsphere = Sphere(center, radius);\n\t\td = intersectSphere ( ray, sphere, normal );\n\t\tif (ray.distance > d) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= int(i);\n\t\t}\n\t}\n\t\n\tPlane planes[5];\n\tplanes[0] = Plane(vec3( 0,\t\t\t-1. - radius, 0\t\t\t ), vec3( 0, 1, 0));\n\tplanes[1] = Plane(vec3( 0,\t\t\t 1. + radius, 0\t\t\t ), vec3( 0,-1, 0));\n\tplanes[2] = Plane(vec3(-1. - radius\t,0,\t\t\t  0\t\t\t ), vec3( 1, 0, 0));\n\tplanes[3] = Plane(vec3( 1. + radius ,0,\t\t\t  0\t\t\t ), vec3(-1, 0, 0));\n\tplanes[4] = Plane(vec3( 0,\t\t\t 0, \t\t  1. + radius), vec3( 0, 0,-1));\n\t\n\tfor (int i=0; i<5; i++) {\n\t\td = intersectPlane ( ray, planes[i], normal );\n\t\tif (ray.distance > d) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= 4;\n\t\t}\n\t}\n}\n\nvec3 lighting(Ray ray, Light lights[lightCount], Material material) {\n\tvec3 col = vec3(0);\n\t\n\tfor (int i=0; i<lightCount; i++) {\n\t\tLight light = lights[i];\n\t\t\n\t\tfloat lightDistance = length(light.position - ray.position);\n\t\t\n\t\t//Тень\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= normalize(light.position - ray.position);\n\t\t\tray1.near \t\t= 0.01;\n\t\t\tray1.far\t\t= lightDistance;\n\t\t}\n\t\trayMarch ( ray1 );\n\t\n\t\t\n\t\tif ( ray1.distance < ray1.far) {\n\t\t\tshadowFactor = clamp(1. - (lightDistance - 3.*ray1.distance) / lightDistance, 0.2, 1.);\n\t\t}\n\t\t\n\t\tfloat distanceAttenuationPower = 0.2;\n\t\tvec3 lightDir \t= normalize(light.position - ray.position);\n\t\tvec3 eyeDir \t= - ray.direction; //normalize ( ray.origin - ray.position );\n\t\tvec3 reflected \t= reflect ( -lightDir, ray.normal );\n\t\n\t\tvec3 color = light.colorAmbient * material.colorAmbient;\n\t\n\t\tcolor += shadowFactor * light.colorDiffuse * material.colorDiffuse * max(dot(ray.normal,lightDir), 0.0);\n\t\tcolor += shadowFactor * light.colorSpecular * material.colorSpecular * pow ( max ( dot(reflected, eyeDir), 0.0) , material.shininess ) * step(1., shadowFactor) ;\t\n\t\tcolor *= min ( 1.0/pow(length(ray.position - ray.origin), distanceAttenuationPower), 1.0);\n\t\n\t\tcol += color/float(lightCount);\n\t}\n\t\n\treturn col;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[lightCount]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\t//Цвет фона\n\t\t\tcolor += vec3(0.1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[lightCount]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления сквозь фигуру\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n            \n            if (! material.flagSolid) {\n\n\t\t\t\t\n\t\t\t\tif (ray.hit) {\n\t\t\t\t\t//Достигли границы 2 фигуры\n\t\t\t\t\t//Луч преломления сквозь границу 2 фигуры\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t//Цвет за границей 2 фигуры\n\t\t\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t\t\t\t\n\t\t\t\t\t//Луч отражения от границы 2\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Отражение от границы 2\n\t\t\t\t\trayMarch (ray);\n\t\t\t\t\t\n\t\t\t\t\tif (ray.hit) {\n\t\t\t\t\t\t//Отраженный луч достиг границы 1 фигуры\n\t\t\t\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy -= 0.5;\n    if (u_mouse.xy==vec2(0) ) mouse.xy = vec2(0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin  = vec3(0.0, 0.0, -3.0);\n        rotate (cam.origin, vec3(1,1,0) * vec3(mouse.y*PI, mouse.x*PI*2., 0));\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 1e6;\n        ray.epsilon = 0.001;\n        ray.steps \t= 1;\n    }\t\n\n    Light lights[lightCount];\n    lights[0] = light_0;\n//\tlights[1] = light_1;\n\n    //Периодичность изменения материалов 5 сек\n    float time = mod(ceil(u_time/5.), 6.);\n\n\n    if (time==1.) {\n        //Металлические шарики и не отражающие стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0, true );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==2.) {\n        //Один прозрачный сплошной шарик\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.8, 0.8, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==3.) {\n        //Все шарики разные\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.8, 0.85, false  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.8, 0.85, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.0, 0.0,  true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.8, 0.85, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==4.) {\n        //Белые прозрачные стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.5, 0.5, 1.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.5, 0.5, 1.0, true );\n    } else if (time==5.) {\n        //Частично прозрачные стены\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.5, 0.5, 1.0, false );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==6.) {\n        //Все прозрачные сплошные шарики\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.5, 0.5, 0.8, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.5, 0.5, 1.0, false );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    } else if (time==0.) {\n        //Все матовые шарики\n        material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(0.0), 128.0, 0.0, 0.0, 0.0, true  );\n        material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.1, 0.1, 0.1), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n        material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\n    }\t\n    \n\tvec3 color = vec3(0);\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);\n\n    GL_FragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1670, 1719, 1762, 1826, 2305], [2307, 2429, 2464, 2464, 2478], [2479, 2519, 2562, 2562, 2580], [2581, 2615, 2652, 2652, 2940], [2941, 4305, 4337, 4337, 5148], [5151, 5296, 5362, 5362, 5967], [5968, 6026, 6089, 6089, 6458], [6459, 6507, 6564, 6564, 8288], [8291, 8375, 8405, 8405, 10202], [10204, 10204, 10273, 10273, 11522], [11524, 11554, 11612, 11643, 12241], [12242, 12276, 12334, 12334, 14453], [14454, 14454, 14517, 14517, 21467]]}
{"id": "wdlGRB", "name": "FuncyOrgan Prototype.", "author": "ccorcos", "description": "https://github.com/ccorcos/FuncyOrgan", "tags": ["musicvisualizer"], "likes": 2, "viewed": 155, "published": "Public", "date": "1546825579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n\n// References:\n// https://www.shadertoy.com/view/ldjcDD\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // normalized\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n    // Polar coordinates:\n    // https://www.shadertoy.com/view/ltlXRf\n    vec2 relativePos = fragCoord.xy - (iResolution.xy / 2.0);\n    vec2 polar;\n    polar.y = sqrt(relativePos.x * relativePos.x + relativePos.y * relativePos.y);\n    polar.y /= iResolution.x / 2.0;\n    polar.y = 1.0 - polar.y;\n\n    polar.x = atan(relativePos.y, relativePos.x);\n    polar.x -= 1.57079632679;\n    if(polar.x < 0.0){\n\t\tpolar.x += 6.28318530718;\n    }\n    polar.x /= 6.28318530718;\n    polar.x = 1.0 - polar.x;\n    \n    // Radius is also 0-1.\n    // Angle is not in radians, but 0-1.\n    \n    \n    float speed = 1. / 1000.;\n    float osc = sin(iTime * speed);\n\n    float size = 20.;\n    \n    \n    float n_min = 20.0;\n    float n_max = 100.0;\n    float n = n_min + osc*(n_max - n_min);\n    \n    float r = polar.y * size;\n    float t = polar.x * 2. * PI;\n    \n    float x = fragCoord.x / iResolution.x * size;\n    float y = fragCoord.y / iResolution.x * size;\n\n    \n    // Cartesian example\n    float v = (pow(x,2.) + pow(y,2.)) * n;\n\n    // Polar Example\n    // (r ^ 2 + t) ^ 2 / (100 * n)\n    // float v = pow(pow(r, 2.) + pow(mod(n,cos(t)), 2.), 2.);\n    \n    \n    float hue = mod(v, 1.0);\n   \tvec3 rgb = hsl2rgb(vec3(hue, 1.0, 0.6));\n    fragColor = vec4(rgb, 1.0);\n       \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 84, 111, 111, 254], [257, 257, 314, 337, 1654]]}
{"id": "wdlGWs", "name": "polka dots 2 (86 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "pattern", "short", "onetweet", "golf"], "likes": 3, "viewed": 371, "published": "Public API", "date": "1547846555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.yy/60.,\n         U = sin( u / R );\n    O = ( U.x*U.y - sin(iTime) )  *R.yyyy;  }      /*\n\n\n\n\n\n\n// -- 98 chars\n\n#define mainImage( O, u )                    \\\n    vec2 R = iResolution.xy,                 \\\n         U = sin( 30.* ( u+u - R ) / R.y );  \\\n    O += ( U.x*U.y - sin(iTime) )  *R.y/60.  /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 142]]}
{"id": "Wds3DS", "name": "slide", "author": "bpaf", "description": "pois", "tags": ["slide"], "likes": 2, "viewed": 79, "published": "Public", "date": "1547392612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589;\nfloat mmod(float a, float b) { return a - floor(a/b); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c1 = vec2(0.5,0.5);\n    float n = 0.0 + 1.0*sin(pi*mmod(iTime,1.0));\n    float a = 10.0*mod(uv.x,0.1);\n    float b = 10.0*mod(uv.y,0.1);\n    vec3 col = vec3(0,1,0) * ( cos(2.0 * pi * (a+n)) * sin(2.0 * pi * (b+n)) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wds3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 88], [89, 89, 146, 146, 443]]}
{"id": "wdS3R1", "name": "Intersecting Lines", "author": "mrtownsend", "description": "Part one of my working through the \"LiveCoding - The Universe Within - Part 1\" tutorial on YouTube (https://www.youtube.com/watch?v=3CycKKJiwis&t=1611s).  Great tutorial and I gotta start somewhere.", "tags": ["tutorial"], "likes": 11, "viewed": 204, "published": "Public", "date": "1548121891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\n\nfloat N21(vec2 p)\n{\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\n\n// Returns the position of a dot in a grid cell.\nvec2 GetPosition(vec2 id, vec2 offset)\n{\n    //vec2 noise = N22(id+offset);\n    //float x = sin(iTime*noise.x);\n    //float y = cos(iTime*noise.y);\n    //return offset+vec2(x, y)*.4;\n    vec2 noise = N22(id+offset)*iTime;\n    return offset+sin(noise)*.4;\n}\n\n\n// Draw line.\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n    float distance = DistLine(p, a, b);\n    float m = SMOOTH(.02, .01, distance);\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float m = 0.;\n    \n    uv *= 5.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // Array\n    vec2 gridCells[9];\n    int i = 0;\n    \n    for(float y=-1.; y<=1.; y++)\n    {\n        for(float x=-1.; x<=1.; x++)\n        {\n            gridCells[i++] = GetPosition(id, vec2(x, y));\n        }\n    }\n    \n    // Draw the primary lines.\n    for(int i=0; i<9; i++)\n    {\n        m += Line(gv, gridCells[4], gridCells[i]);\n    }\n    \n    // Draw the lines that overlap the grid lines.\n    m += Line(gv, gridCells[1], gridCells[3]);\n    m += Line(gv, gridCells[1], gridCells[5]);\n    m += Line(gv, gridCells[7], gridCells[3]);\n    m += Line(gv, gridCells[7], gridCells[5]);\n    \n    vec3 col = vec3(m);\n    \n    // The below code renders a grid.\n    //if(gv.x > .48 || gv.y > .48) col = vec3(1,1,0);\n    \n    m = N22(uv) .y;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdS3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 81, 81, 205], [208, 208, 227, 227, 321], [324, 324, 342, 342, 396], [399, 448, 488, 630, 704], [707, 721, 757, 757, 855], [858, 858, 915, 915, 1844]]}
{"id": "WdS3Wh", "name": "practice-13", "author": "kiyamada96", "description": "noise", "tags": ["noise"], "likes": 2, "viewed": 77, "published": "Public", "date": "1548681363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(in vec2 st)\n{\n\treturn fract(sin(dot(st.xy,vec2(12.443,78.4)))*43758.2);\n}\n\nfloat noise(in vec2 st)\n{\n\tvec2 i=floor(st);\n    vec2 f=fract(st);\n    float a=random(i);\n    float b=random(i+vec2(1.0,0.0));\n    float c=random(i+vec2(0.0,1.0));\n    float d=random(i+vec2(1.0,1.0));\n    \n    vec2 u=smoothstep(0.0,1.0,f);\n    return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y+vec2(iTime*0.05);\n\tvec3 col=vec3(0.,0.,0.);\n    vec2 pos=vec2(p*10.0);\n    float n=noise(pos);\n    col+=smoothstep(.35,.4,n);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdS3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 86], [88, 88, 113, 113, 393], [395, 395, 452, 452, 668]]}
{"id": "Wds3WN", "name": "scattering sky on earth", "author": "cailuming", "description": "another one for  atmosphere scattering, including fbm ", "tags": ["noise", "ao", "rayleigh"], "likes": 6, "viewed": 157, "published": "Public", "date": "1546789042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define INNER 0.0\n#define OUTTER 40.0\n#define FAREST 150.0\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n\nvec2 sphereIntersect(vec3 o,vec3 dir,vec4 sp){\n   vec3 a = sp.xyz - o;\n   float b = dot(dir,a);\n   float d = sqrt(dot(a,a)-b*b);\n   float t = sqrt(sp.w*sp.w-d*d);\n   if(d>sp.w) return vec2(-1);\n    \n   return vec2(b-t,b+t);\n}\n\nfloat density(float h,float s){\n    return exp(-h/s);\n}\n    \nfloat phase_ray(float c){\n    return 3.0/16.0/PI*(1.+c*c);    \n}\n\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn ( 3.0 / 8.0 / PI ) * a / b;\n}\n\n\nfloat optics(vec3 hi,vec3 lw,float s){\n    vec3  a   = hi-lw;\n    vec3  d   = normalize(a);\n    vec3  c   = lw;  \n    float ret = 0.0;\n    float smp = 8.0;\n    float t   = 0.0;\n    \n    float stp = length(a)/smp;\n    \n    for(float i=0.0;i<smp;i++){\n       t= c.y-INNER;\n       \n       if(t<=0.){\n           break;\n       }\n       ret+= density(t*0.5,s);\n       c+=d*stp; \n    }\n    \n    return ret*stp;\n}\n\n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = sin(a);\n   return mat2(c,s,-s,c); \n}\n\nmat3 rot3D(vec4 a){\n   float c  = cos(a.w);\n   float s  = sin(a.w);\n   float rc = 1.0-c;\n   \n   float m00 = a.x*a.x*rc+c;\n   float m01 = a.y*a.x*rc+a.z*s;\n   float m02 = a.z*a.x*rc-a.y*s;\n   \n   float m10 = a.x*a.y*rc-a.z*s;\n   float m11 = a.y*a.y*rc+c;\n   float m12 = a.z*a.y*rc+a.x*s;\n   \n   float m20 = a.x*a.z*rc+a.y*s;\n   float m21 = a.y*a.z*rc-a.x*s;\n   float m22 = a.z*a.z*rc+c;\n    \n   return mat3(\n      m00,m01,m02,\n      m10,m11,m12,\n      m20,m21,m22\n   ); \n}\n\n\nfloat hash1(float x){\n    \n\treturn fract(sin(dot(vec2(x),vec2(PI,2.73461)))*327672.0);\n}\n\nfloat hash1(vec2 v){\n   return fract(sin(dot(v,vec2(1623713,1241701)))*3267137.0);\n}\n\nvec2 hash2(vec2 v){\n   float x =  fract(sin(dot(v,vec2(1.4623713,0.734566)))*100000.0*PI);\n    \n   float y =  fract(sin(dot(v,x*vec2(0.923713,-0.7441701)))*100000.0*PI);\n    \n   return vec2(x,y);\n}\n\nvec3 hash3(vec3 v){\n   float x =  fract(sin(dot(v,vec3(1.4623713,0.734566,0.334566)))*100000.0*PI);\n   float y =  fract(sin(dot(v,x*vec3(0.923713,-0.7441701,-0.334566)))*100000.0*PI);\n   float z =  fract(sin(dot(v,y*vec3(-0.223713,1.4441701,0.634566)))*100000.0*PI);\n    //*rot3D(vec4(0.5,0.5,0,iTime*0.1+y))\n   return vec3(x,y,z);\n}\n\n\nfloat curve_cubic(float v){\n   return v*v*(3.0-2.0*v);\n}\n\nvec2 curve_cubic(vec2 v){\n   return v*v*(3.0-2.0*v);\n}\n\nfloat curve_pro(float v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec2 curve_pro(vec2 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\nvec3 curve_pro(vec3 v){\n   return v*v*v*(v*(6.0*v-15.0)+10.0);\n}\n\n\nvec3 getColor(float v){\n   float r = cos((v-0.78)*PI*1.66);\n   float g = cos((v-0.58)*PI*1.66);\n   float b = cos((v-0.28)*PI*1.66);\n   return vec3(r,g,b); \n}\n\n    \nfloat noise1D(float x){\n   float p  = floor(x);\n   float f  = fract(x); \n    \n   float v1 = hash1(p);\n   float v2 = hash1(p+1.0);\n    \n   f  = curve_pro(f);\n    \n   return mix(v1,v2,f); \n}\n\nfloat noise2D(vec2 v){\n   vec2 p = floor(v);\n   vec2 f = fract(v); \n   vec2 e = vec2(1,0);\n    \n   vec2 h00 = hash2(p);\n   vec2 h01 = hash2(p+e.xy);\n   vec2 h10 = hash2(p+e.yx);\n   vec2 h11 = hash2(p+e.xx);\n     \n   float d00 = dot(h00,f);\n   float d01 = dot(h01,f-e.xy);\n   float d10 = dot(h10,f-e.yx);\n   float d11 = dot(h11,f-e.xx);\n    \n   f = curve_pro(f);\n   \n   return mix(mix(d00,d01,f.x),mix(d10,d11,f.x),f.y); \n}\n\n\n// 3d noise ,inspired by iq ,but without the gradient\nfloat noise3D(vec3 p){\n   vec3 x000 = floor(p);\n   //evaluate the eight corner first \n   vec3 x001 = x000+vec3(0,0,1);\n   vec3 x010 = x000+vec3(0,1,0);\n   vec3 x011 = x000+vec3(0,1,1);\n   \n   vec3 x100 = x000+vec3(1,0,0);\n   vec3 x101 = x000+vec3(1,0,1);\n   vec3 x110 = x000+vec3(1,1,0);\n   vec3 x111 = x000+vec3(1,1,1);\n   \n   // get the interpolation coe  \n   vec3 cp  = fract(p);\n   \n   //get each random vector of the corner \n   vec3 v000 = hash3(x000);\n   vec3 v001 = hash3(x001);\n   vec3 v010 = hash3(x010);\n   vec3 v011 = hash3(x011);\n   vec3 v100 = hash3(x100);\n   vec3 v101 = hash3(x101);\n   vec3 v110 = hash3(x110);\n   vec3 v111 = hash3(x111);\n    \n   //do the projection \n   float d000 = dot(v000,p-x000);\n   float d001 = dot(v001,p-x001);\n   float d010 = dot(v010,p-x010);\n   float d011 = dot(v011,p-x011);\n    \n   float d100 = dot(v100,p-x100);\n   float d101 = dot(v101,p-x101);\n   float d110 = dot(v110,p-x110);\n   float d111 = dot(v111,p-x111);\n    \n   //interpolation curve vector \n   cp = curve_pro(cp);\n   \n    \n   d000 = mix(d000,d010,cp.y);\n   d100 = mix(d100,d110,cp.y);\n   \n   d001 = mix(d001,d011,cp.y);\n   d101 = mix(d101,d111,cp.y);\n   \n   return mix(mix(d000,d100,cp.x),mix(d001,d101,cp.x),cp.z);\n    \n}\n//fbm stuffs\nfloat fbm1(float x){\n   float freq = 0.5;\n   float am   = 1.0;\n   float ret  = 0.0;\n   \n   for(int i=0;i<5;i++){\n       ret+=noise1D(x*freq)*am;\n       freq *=2.0;\n       am   *=0.5;\n   }\n    \n   return ret; \n}\n\nfloat fbm2(vec2 x){\n   float freq = 0.5;\n   float am   = 5.0;\n   float ret  = 0.0;\n    \n   for(int i=0;i<9;i++){\n       ret+=noise2D(x*freq)*am;\n       \n       freq *=2.;\n       am   *=.4;\n       x    *=rot2D(freq);\n   } \n    \n   return ret; \n}\n \nfloat getHeight(vec2 p){\n   \n  return fbm2(p.xy*0.1)*1.4;\n}\nvec2 ground(vec3 p ,vec3 c){\n    p-=c;\n    float m = getHeight(p.xz)+fbm1(p.y*0.9+noise1D(p.x*.1)*0.5)*1.2;\n    return vec2(p.y-m,0);\n}\n \nvec2 sphere(vec3 p ,vec3 c){\n    p-=c;\n    return vec2(length(p)-4.0,1);\n}\n\n\nvoid cmp(inout vec2 a,vec2 b){\n    a = a.x>b.x?b:a;\n}\n\nvec2 map(vec3 p){\n   vec2 res = vec2(1000.0);\n    \n   cmp(res,ground(p,vec3(0)));\n   //cmp(res,sphere(p,vec3(1,1,40)));\n     \n   return res;\n}\n\nfloat occlusion(vec3 p,vec3 norm){\n    float scalor=0.7;\n    \n    float occ =0.;\n    float sm = 4.0;\n    for(float i=0.;i<sm;i++){\n       float k= i/sm;\n       k*=scalor;\n       float d=map(p+k*norm).x;\n       occ+= pow(0.5,i*0.3)*(k-d);\n    }\n    occ=1.-clamp(occ,0.,1.);\n    return occ;\n}\n\n\nvec3 grad(vec3 p){\n   float m = map(p).x;\n   vec2 e = vec2(1,0)*0.01; \n   return normalize(vec3(map(p+e.xyy).x-m,map(p+e.yxy).x-m,map(p+e.yyx).x-m)); \n}\n\nvoid atmosphere(inout vec3 col,vec3 sp,vec3 endp,vec3 lp){\n    float t_ray0 = 0.0;\n    float t_ray1 = 0.0;\n    float t_mie0 = 0.0;\n    float t_mie1 = 0.0;\n    float d_ray  = 0.0;\n    float d_mie  = 0.0;\n    float g = -0.9;\n    float h_ray  = 10.5;\n    float h_mie  = h_ray*0.225;\n    \n    vec3 kray = vec3(5.5e-2,13e-2,22.4e-2);\n    vec3 kmie = vec3(20e-4);\n\n    vec3  cmul   = vec3(0.0);\n    vec3  sray   = vec3(0.0);\n    vec3  smie   = vec3(0.0);\n    vec3  ld     = normalize(lp);\n    vec3  d      = normalize(endp-sp);\n    \n    float c      = dot(-d,ld);\n    float intens = 2.7;\n    float s = 0.11;\n    \n    \n    float smp    = 16.0;\n    float t      = 0.0;\n    vec3  p      = vec3(0);\n    float stp    = length(endp-sp)/smp;\n    \n    vec2 v1 = sphereIntersect(lp,-ld,vec4(0,0,0,OUTTER));\n    \n    for(float i=0.0;i<smp;i++){\n       p = sp+d*t;\n       if(p.y<0.) break; \n       d_ray = density(p.y,h_ray)*stp;\n       d_mie = density(p.y,h_mie)*stp;\n        \n       t_ray0 += d_ray;\n       t_mie0 += d_mie;\n        \n       t_ray1 = optics(OUTTER*ld,p,h_ray);\n       t_mie1 = optics(OUTTER*ld,p,h_mie);\n          \n       cmul = (t_ray0+t_ray1)*kray+(t_mie0+t_mie1)*kmie*0.;\n       cmul = exp(-cmul*s);\n       sray += cmul*d_ray;\n       smie += cmul*d_mie;\n           \n       t+=stp; \n    }\n    \n    col+= (sray*kray*phase_ray(c)+smie*kmie*phase_mie(g,c,c*c))*intens;\n}\n void shading(inout Ray r,vec3 lp,inout vec3 col,vec2 res){\n    vec3 p = r.o+r.d*res.x;\n    vec3 n = grad(p);\n    vec3 ld = normalize(lp);\n    float nl = smoothstep(-1.0,1.,dot(ld,n));\n    float oc = occlusion(p,n);    \n    float hv = dot(normalize(-ld+r.d),n);\n    hv = 0.3+0.7*(1.0-pow(hv,5.0)); \n    atmosphere(col,r.o,p,lp);\n    if(res.x<FAREST){\n   \n        if(res.y==0.0){\n           float v = fbm2(p.xz*0.1); \n           col = mix(col,(nl*oc)*getColor(nl*0.08+0.66),nl+1.0-exp(-res.x*0.1));\n            \n        }  \n    } \n}\n    \nvoid rayMarch(in Ray r,vec3 lp,inout vec3 col,inout vec2 res){\n    float t =0.0;\n    vec2 h  = vec2(0);\n    vec3 p  = vec3(0);\n     \n    for(int i=0;i<64;i++){\n       p = r.o+r.d*t;\n       h = map(p);\n      \n       if(t>=FAREST){\n           t=FAREST;\n  \n           break;\n       }\n        \n       if(h.x<=0.0005){\n                 \n           break;\n       } \n       \n        t+=h.x; \n    }\n     \n    res = vec2(t,h.y);\n}\n       \nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n    vec3 look = normalize(tar-eye);\n    vec3 right = normalize(cross(vec3(0,1,0),look));\n    vec3 up   = normalize(cross(look,right));\n    \n    r.o = eye;\n    r.d = normalize(uv.x*right + uv.y*up+ look);\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv- vec2(0.5);\n    cuv.x*=iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    float a = PI*0.44;\n    float t = sin(iTime*0.5);\n  \n \n    vec3 lp  = vec3(0,50.0*cos(a),100.0*sin(a));\n    vec3 eye = vec3(0,4.,-9.0);\n    vec3 tar = vec3(0,3.,1);\n    eye*=rot3D(vec4(normalize(vec3(0,1,0)),iTime*0.1));\n    vec2 res = vec2(0);\n    \n    Ray r;\n    setCamera(r,eye,tar,cuv);\n    rayMarch(r,lp,col,res);\n    shading(r,lp,col,res);\n    \n    col = smoothstep(0.,1.,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wds3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 164, 164, 343], [345, 345, 376, 376, 400], [406, 406, 431, 431, 470], [472, 472, 519, 519, 690], [693, 693, 731, 731, 1098], [1101, 1101, 1121, 1121, 1192], [1194, 1194, 1213, 1213, 1665], [1668, 1668, 1689, 1689, 1756], [1758, 1758, 1778, 1778, 1842], [1844, 1844, 1863, 1863, 2041], [2043, 2043, 2062, 2062, 2376], [2379, 2379, 2406, 2406, 2435], [2437, 2437, 2462, 2462, 2491], [2493, 2493, 2518, 2518, 2559], [2561, 2561, 2584, 2584, 2625], [2627, 2627, 2650, 2650, 2691], [2694, 2694, 2717, 2717, 2851], [2858, 2858, 2881, 2881, 3046], [3048, 3048, 3070, 3070, 3470], [3473, 3527, 3549, 3549, 4756], [4757, 4770, 4790, 4790, 4980], [4982, 4982, 5001, 5001, 5226], [5229, 5229, 5253, 5253, 5288], [5289, 5289, 5317, 5317, 5424], [5427, 5427, 5455, 5455, 5501], [5504, 5504, 5534, 5534, 5557], [5559, 5559, 5576, 5576, 5701], [5703, 5703, 5737, 5737, 5993], [5996, 5996, 6014, 6014, 6148], [6150, 6150, 6208, 6208, 7519], [7521, 7521, 7579, 7579, 8051], [8057, 8057, 8119, 8119, 8478], [8487, 8487, 8541, 8541, 8747], [8752, 8752, 8809, 8859, 9474]]}
{"id": "Wds3Ws", "name": "IFS particles", "author": "aadebdeb", "description": "IFS particles", "tags": ["ifs"], "likes": 9, "viewed": 291, "published": "Public", "date": "1547823617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(float x){\n    return fract(sin(x * 12.9898) * 43758.5453);\n}\n\nfloat valuenoise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n\n    float u = f * f * (3.0 - 2.0 * f);\n\n    return mix(random(i), random(i + 1.0), u);\n}\n\nfloat fbm(float x) {\n    float s = 0.0;\n    float a = 0.5;\n    for (int i = 0; i < 4;i++) {\n        s += a * valuenoise(x);\n        a *= 0.5;\n        x += 2.15;\n    }\n    return s;\n}\n\nfloat box(vec3 p, vec3 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, max(p.y, p.z)));\n}\n\nmat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float d = 10000.0;\n    float s = 1.0;\n    p.xz *= rotate(iTime * 0.39);\n    for (int i = 0; i < 5; i++) {\n        p.yz *= rotate(iTime * 0.34);\n        p = abs(p);\n        p -= 15.0;\n        p.xz *= rotate(iTime * 1.94);\n        p.xy *= rotate(iTime * 1.32);\n        d = min(d, box(p, vec3(1.0)) / s);\n        p *= 2.0;\n        s *= 2.0;\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    float d = 0.01;\n    return normalize(vec3(\n        map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n        map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n        map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvec3 lightDir = normalize(vec3(0.5, 1.0, -0.8));\nvec3 lightColor = vec3(1.0) * 2.0;\nvec3 diffuseColor = vec3(0.4, 0.7, 0.9);\nvec3 growColor = vec3(1.0, 0.8, 0.2);\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    float minD = 10000.0;\n    for (int i = 0; i < 64; i++) {\n        float d = map(p);\n        p += d * rd;\n        minD = min(minD, d);\n        if (d < 0.01) {\n            vec3 n = calcNormal(p);\n            vec3 diffuse = diffuseColor * max(0.0, dot(n, lightDir)) * lightColor; \n            vec3 grow = growColor * 0.3;\n            return  diffuse + grow;\n        }\n    }\n    return growColor * 0.08 / minD;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\n    vec3 ro = vec3( 0.0, 0.0, -50.0 + (fbm(iTime * 0.3) * 2.0 - 1.0) * 25.0);\n    vec3 ta = vec3(0.0);\n    vec3 z = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(x * st.x + y * st.y + z * 1.5);\n\n    vec3 c = raymarch(ro, rd);\n\n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wds3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 73], [75, 75, 102, 102, 240], [242, 242, 262, 262, 424], [426, 426, 453, 453, 543], [545, 545, 567, 567, 643], [645, 645, 664, 664, 1028], [1030, 1030, 1055, 1055, 1306], [1472, 1472, 1505, 1505, 1934], [1936, 1936, 1991, 1991, 2446]]}
{"id": "Wds3zf", "name": "[twitch] Braid", "author": "yx", "description": "I stream shader creation every Wednesday at 9pm UK time, over at [url]https://twitch.tv/lunasorcery[/url]\nCome and watch a show!\n\nOr watch the VOD for this shader here: [url]https://www.twitch.tv/videos/361407647[/url]", "tags": ["twitch", "braid"], "likes": 38, "viewed": 895, "published": "Public API", "date": "1547072928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThis shader was created live on stream!\n\tYou can watch the VOD here: https://www.twitch.tv/videos/361407647\n\t\n\tI use the Bonzomatic tool by Gargaj/Conspiracy:\n\thttps://github.com/Gargaj/Bonzomatic\n\n\tWednesdays around 9pm UK time I stream at https://twitch.tv/lunasorcery\n\tCome and watch a show!\n\n\t~yx\n*/\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c - a.y*s,\n        a.x*s + a.y*c\n    );\n}\n\nfloat sdbox2d(vec2 p, float r)\n{\n    p=abs(p);\n    return max(p.x,p.y)-r;\n}\n\nvec2 boffset(vec2 p, float t)\n{\n    t*=pi*2.;\n    return rotate(p+vec2(\n        cos(t)*2.,\n        -sin(t*3.)\n    )*.15, sin(t)*(pi*2./3.));\n}\n\nfloat tick(float t)\n{\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    return t;\n}\n\nfloat pattern(float t)\n{\n    t=fract(t);\n    return clamp(abs(t-.5)*-16.+7.5,-1.,1.)+1.;\n    return tick(abs(t-.5)*2.);\n}\n\nfloat scene2(vec2 p, float angle)\n{\n    float time = ((angle/tau)/5.)*4.+iTime*.25;\n\n    float q = iTime+angle;\n\n    float r = .02 + pattern((angle/tau)*30.)*.02;\n\n    float a = sdbox2d(boffset(p,time),r);\n    float b = sdbox2d(boffset(p,time+1./5.),r);\n    float c = sdbox2d(boffset(p,time+2./5.),r);\n    float d = sdbox2d(boffset(p,time+3./5.),r);\n    float e = sdbox2d(boffset(p,time+4./5.),r);\n    return min(min(min(a,b),min(c,d)),e);\n}\n\nfloat scene(vec3 p)\n{\n    p.xz = mod(p.xz+8.,16.)-8.;\n\n    float angle = atan(p.x,p.z);\n\n    float q = .75;\n\n    p.y += (angle/tau)*(q+q);\n\n    p.y = mod(p.y+q,(q+q))-q;\n\n    vec2 a = vec2(length(p.xz)-1., p.y);\n\n    return scene2(a, angle);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 1.+length(uv)*.3;\n\n    vec3 cam = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(uv, 2.5));\n\n    cam.yz = rotate(cam.yz, pi/5.);\n    dir.yz = rotate(dir.yz, pi/5.);\n\n    cam.xz = rotate(cam.xz, pi/4.);\n    dir.xz = rotate(dir.xz, pi/4.);\n\n    cam.y += iTime;\n\n    float t =0.;\n    float k = 0.;\n    int iter=0;\n    for(int i=0;i<100;++i)\n    {\n        k = scene(cam+dir*t)*.7;\n        t+=k;\n        iter=i;\n        if (k < .001)break;\n    }\n    vec3 h = cam+dir*t;\n    vec2 o = vec2(.002,0);\n    vec3 n = normalize(vec3(\n        scene(h+o.xyy)-scene(h-o.xyy),\n        scene(h+o.yxy)-scene(h-o.yxy),\n        scene(h+o.yyx)-scene(h-o.yyx)\n    ));\n\n    if (k < .001)\n    {\n        float iterFog = 1.-float(iter)/100.;\n        iterFog = pow(iterFog, 3.);\n        float light = max(n.y,0.);\n        out_color.rgb += mix(vec3(.01,.01,.1), vec3(.1,.5,.5), iterFog);\n        out_color.rgb += mix(vec3(0.), vec3(sin(iTime),sin(iTime+2.),sin(iTime+4.))+1., light*iterFog);\n    }\n    else\n    {\n        out_color *= 0.;\n    }\n\n    out_color.rgb = mix(out_color.rgb, vec3(out_color.r+out_color.g+out_color.b)/3., .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wds3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 351, 381, 381, 496], [498, 498, 530, 530, 573], [575, 575, 606, 606, 717], [719, 719, 740, 740, 872], [874, 874, 898, 898, 995], [997, 997, 1032, 1032, 1438], [1440, 1440, 1461, 1461, 1683], [1685, 1685, 1737, 1737, 2937]]}
{"id": "wdS3zW", "name": "practice-11", "author": "kiyamada96", "description": "Julia St", "tags": ["juliaset"], "likes": 1, "viewed": 53, "published": "Public", "date": "1548338363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int count = 360;\nvec2 x=vec2(-0.54,0.654);\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n    int j=0;\n\t\n    x.x += sin(x.y * 2.0 + iTime * 0.2) / 30.0;\n    vec2 z=p;\n    vec2 y=vec2(0.0005*iTime,0.0);\n    \n    for(int i=0;i<count;i++)\n    {\n    \tj++;\n        if(length(z)>2.){break;}\n        z=mat2(z,-z.y,z.x)*z+x+y;\n        \n    }\n    \n    float h = (100.0 / float(count)) * float(j);\n    vec3 rgb=hsv(h,1.,1.);\n    fragColor=vec4(rgb,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdS3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 85, 85, 170], [172, 172, 229, 229, 649]]}
{"id": "WdsGRB", "name": "3 Ary Blobs", "author": "VJSpackOMat", "description": "even more simple 3ary anim, control the frequency of outer buttons with horiz/verti mouse", "tags": ["3ary"], "likes": 0, "viewed": 42, "published": "Public", "date": "1546715647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI =3.14159265359;\nconst float PI2 =2.0*PI;\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 mouse = iMouse.xy/iResolution.xy;\n\n    \n    float freq1=mouse.x*10.0;\n    float freq2= .730;\n    float freq3=mouse.y*10.0;\n    \nvec3 col;\n    if(uv.x>0.66){\n    // Time varying pixel color\n        // align with pi, use stepping for new colors on each frequency pass\n        float hue=mod(floor(iTime/freq1),256.0)/256.0;\n        \n       col =hsv2rgb(vec3( hue,uv.y,.50 + 0.5*sin(iTime*freq1)));\n    }else if(uv.x>0.33){\n         // align with pi, use stepping for new colors on each frequency pass\n        float hue=mod(floor(iTime/freq2),256.0)/256.0;\n        \n       col =hsv2rgb(vec3( hue,uv.y,.50 + 0.5*sin(iTime*freq2)));\n    }else{\n  // align with pi, use stepping for new colors on each frequency pass\n        float hue=mod(floor(iTime/freq3),256.0)/256.0;\n        \n       col =hsv2rgb(vec3( hue,uv.y,.50 + 0.5*sin(iTime*freq3)));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 79, 79, 248], [249, 249, 306, 356, 1310]]}
{"id": "wdsGRj", "name": "wildlights", "author": "maddievision", "description": "lots of colorful moving lights", "tags": ["lights"], "likes": 5, "viewed": 161, "published": "Public", "date": "1546898595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 calcLight(vec4 color, vec2 pos, vec2 coord) {\n\treturn color * 0.04/distance(pos / iResolution.y, coord / iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 0);\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime)), abs(sin(iTime)), abs(sin(iTime/2.0)), 0.5),\n        vec2(abs(sin(iTime/1.3)) * iResolution.x, 200.0 + 10.0 * sin(iTime*12.0)),\n        fragCoord\n    );\n    \n    fragColor += calcLight(\n        vec4(abs(cos(iTime)), abs(sin(iTime)), 0, 0.5),\n        vec2(200.0 + 15.0 * sin(iTime*6.0), abs(sin(iTime*3.4))* iResolution.y),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime*2.0)), abs(sin(iTime/0.75)), abs(sin(iTime/2.0)), 0.5),\n        vec2(200.0 + 5.0 * sin(iTime*30.0), abs(sin(iTime*1.5))* iResolution.y),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(sin(iTime*3.0)), abs(cos(iTime/0.75)), abs(sin(iTime/2.0)), 0.5),\n        vec2(300.0 + 90.0 * sin(iTime*2.0), abs(sin(iTime))* iResolution.y),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime)/2.0), abs(sin(iTime*0.5)), abs(sin(iTime*1.3)), 0.5),\n        vec2(45.0 + 15.0 * cos(iTime*3.33), abs(sin(iTime*4.0))* iResolution.y),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime)*0.3) + sin(iTime)*0.7, abs(sin(iTime/2.2)), abs(sin(iTime/3.3)), 0.5),\n        vec2(abs(sin(iTime/3.0))* iResolution.x, 100.0 + 5.0 * sin(iTime*6.0)),\n        fragCoord\n    );\n    \n    fragColor += calcLight(\n        vec4(abs(cos(iTime*12.0)),abs(sin(iTime*15.0)),abs(cos(iTime*10.0)), 1.0),\n        vec2(abs(sin(iTime/2.0))* iResolution.x, 300.0 + 60.0 * sin(iTime*0.5)),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime*3.0)), abs(sin(iTime*4.0)), abs(sin(iTime*5.0)), 0.5),\n        vec2(abs(sin(iTime))* iResolution.x, abs(cos(iTime/3.0) * iResolution.y)),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(sin(iTime*3.0)), abs(cos(iTime*4.0)), abs(sin(iTime*5.0)), 0.5),\n        vec2(abs(cos(iTime))* iResolution.x, abs(sin(iTime/3.0) * iResolution.y)),\n        fragCoord\n    );\n\n\n    fragColor += calcLight(\n        vec4(abs(sin(iTime*2.22)), abs(cos(iTime*12.0)), abs(sin(iTime*2.20)), 0.5),\n        vec2(abs(cos(iTime*2.27))* iResolution.x, abs(sin(iTime*4.31) * iResolution.y)),\n        fragCoord\n    );\n\n    fragColor += calcLight(\n        vec4(abs(cos(iTime*2.22)), abs(cos(iTime*12.0)), abs(cos(iTime*2.20)), 0.5),\n        vec2(abs(sin(iTime*2.27))* iResolution.x, abs(sin(iTime*3.3) * iResolution.y)),\n        fragCoord\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 127], [129, 129, 186, 186, 2626]]}
{"id": "WdsGRl", "name": "simple 2d animation", "author": "naxius", "description": "simple animation attempt.", "tags": ["beginner", "animation"], "likes": 7, "viewed": 396, "published": "Public", "date": "1547196761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    float a = atan(uv.y,uv.x);\n    float r = 0.5*length(uv);\n    float counter = 100.;\n    a = 4.*a+20.*r+50.*cos(r)*cos(.1*t)+abs(a*r);\n    float f = 0.02*abs(cos(a))/(r*r);\n    \n    \n    vec2 v = vec2(0.);\n    for(float i=0.;i<counter;i++){\n    \tv = mat2(v,-v.y,v.x) * v + vec2(2.*f+cos(0.5*t*(exp(-0.2* r))),-cos(t*r*r)*cos(0.5*t));\n        if(length(v)>2.){\n        \tcounter = i;\n            break;\n        }  \n    }\n\n    col=vec3(min(0.9,1.2*exp(-pow(f,0.45)*counter)));\n\n\tfragColor =    min(0.9,1.2*exp(-pow(f,0.45)*counter) )\n                * ( 0.7 + 0.3* cos(10.*r - 2.*t -vec4(.7,1.4,2.1,0) ) );}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 124, 820]]}
{"id": "wdsGRS", "name": "cellular noise stacked", "author": "caseymacneil", "description": "cellular noise based off https://thebookofshaders.com/12/\n", "tags": ["noise", "distancefields", "cellularnoise"], "likes": 7, "viewed": 196, "published": "Public", "date": "1546746244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 4.\nfloat rand(vec2 value)\n{\n\treturn fract(sin(dot(value, vec2(23.1245,87.2980))) * 5387.58135649);\n}\n\nvec2 rand2d(vec2 value)\n{\n\treturn fract(sin(vec2(dot(value, vec2(23.1245,87.2980)), dot(value, vec2(127.5123,39.183)))) * 5387.58135649);\n}\n\n//https://thebookofshaders.com/12/\nfloat getCell(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec3 col = (fuv).xyy;\n    float mdist = 1.;\n    \n    // get neighbour tiles\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 n = vec2(float(x),float(y));\n            \n            vec2 p = rand2d(iuv + n);\n            \n            // animate\n            p.y = 0.5 + 0.5*sin(iTime + 5.*p.y);\n            p.x = 0.5 + 0.5*cos(iTime + 5.*p.x);\n            \n            vec2 diff = n + p - fuv;\n            float dist = length(diff);\n            mdist = min(mdist,dist);\n        }\n    }\n    return mdist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 vFontSize = vec2(8.0, 15.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //scale\n    vec2 p = fragCoord * .01;\n    p += 1.0;\n    //tile\n    \n    // draw center\n    //mdist += step(mdist,.02);\n    \n    vec3 col = vec3(0.);\n    \n    for(float i = 1. ; i < OCTAVES; i++)\n    {\n    \tcol += vec3(getCell(p)) / i;\n        p *= OCTAVES;\n    }\n    \n    //gamma\n    col = pow(col,vec3(2.2));\n    // make pretty :)\n    col.r *= uv.x;\n    col.b *= 1.-uv.y;\n    col.g *= .8 * 1.-uv.x;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 43, 43, 116], [118, 118, 143, 143, 257], [259, 294, 318, 318, 929], [931, 931, 988, 988, 1528]]}
{"id": "WdsGWj", "name": "AA Grid (Tup)", "author": "Tup", "description": "Drag mouse to scale/rotate. Number keys change line thickness. QWERTY row changes smoothed edge size.\n\nSometimes you get the Grid Illusion (https://en.wikipedia.org/wiki/Grid_illusion), which appears as shimmering dots at the intersections of the lines.", "tags": ["grid", "illusion"], "likes": 3, "viewed": 134, "published": "Public", "date": "1547519550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ASCNUMS  48 // ASCII code for 0\n#define ASCALPHA 64 // ASCII code for a\n\nbool keyPressed(int ascii) {\n\treturn (texture(iChannel2,vec2((float(ascii)+0.5)/256.,0.5/3.0)).x > 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // first part just sets the scale using the keyboard\n\n    float WIDTH; // percent width of grid-line relative to square\n\n         if (keyPressed(ASCNUMS+1))\n\t    WIDTH = 0.001;\n    else if (keyPressed(ASCNUMS+2))\n\t    WIDTH = 0.002;\n    else if (keyPressed(ASCNUMS+3))\n\t    WIDTH = 0.004;\n    else if (keyPressed(ASCNUMS+4))\n\t    WIDTH = 0.008;\n    else if (keyPressed(ASCNUMS+5))\n\t    WIDTH = 0.016;\n    else if (keyPressed(ASCNUMS+6))\n\t    WIDTH = 0.032;\n    else if (keyPressed(ASCNUMS+7))\n\t    WIDTH = 0.064;\n    else if (keyPressed(ASCNUMS+8))\n\t    WIDTH = 0.256;\n    else if (keyPressed(ASCNUMS+9))\n\t    WIDTH = 0.512;\n    else if (keyPressed(ASCNUMS+0))\n\t    WIDTH = 1.000;\n    else \n\t    WIDTH = 0.128;\n\n    float aa;\n        \n         if (keyPressed(ASCALPHA+17)) // Q\n\t    aa = 2.;\n    else if (keyPressed(ASCALPHA+23)) // W\n\t    aa = 3.;\n    else if (keyPressed(ASCALPHA+ 5)) // E\n\t    aa = 4.;\n    else if (keyPressed(ASCALPHA+18)) // R\n\t    aa = 5.;\n    else if (keyPressed(ASCALPHA+20)) // T\n\t    aa = 6.;\n    else if (keyPressed(ASCALPHA+25)) // Y\n\t    aa = 7.;\n    else if (keyPressed(ASCALPHA+21)) // U\n\t    aa = 8.;\n    else if (keyPressed(ASCALPHA+ 9)) // I\n\t    aa = 16.;\n    else if (keyPressed(ASCALPHA+15)) // O\n\t    aa = 32.;\n    else if (keyPressed(ASCALPHA+16)) // P\n\t    aa = 64.;\n    else \n\t    aa = 1.;\n        \n    // second part just sets up some interactivity with the mouse\n    \n\tvec2 center = iResolution.xy/2.;\n    \n    vec2 m = iMouse.xy - center;\n    \n    float len = length(m);\n\n    float scale = iResolution.x / len;\n    \n    mat2 rot = len > 0. ?\n        mat2(m.x, m.y, -m.y, m.x) / len :\n    \tmat2(1., 0., 0., 1.);\n\n\t// press space bar to stop rotation\n    if (!keyPressed(32)) {\n\t    float t = -iTime/60.;\n\t    rot *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    }\n    \n    vec2 xy = (fragCoord.xy - center) * rot ;\n    \n    // third part does all the rendering\n   \n    // normalize coords and slide everything up and over half a square\n    vec2 uv = xy/iResolution.xx + .5/scale;\n\n    // scale coords up and center them around the origin\n    vec2 st = fract( scale * uv ) - .5;\n\n\tfloat edge  = aa/len;\n    float solid = (WIDTH - edge) / 2.;\n\n    st = 1. - clamp( (abs(st) - solid) / edge, 0., 1. );\n\n  \tfragColor = vec4(smoothstep(0., 1., max(st.x, st.y)));\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 109, 109, 186], [188, 188, 245, 302, 2550]]}
{"id": "wdSGWW", "name": "Snoopy and the Red Baron", "author": "dr2", "description": "Two famous characters locked in eternal conflict", "tags": ["plane", "flight", "peanuts", "aerobatics"], "likes": 11, "viewed": 379, "published": "Public API", "date": "1548838026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Snoopy and the Red Baron\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_SEG 12\n\nmat3 flyerMat[2], flMat;\nvec3 flyerPos[2], flPos, qHit, qHitTransObj, sunDir, trkA, trkF, cPt[N_SEG],\n   cPtOrg, cUpCirc, cDnCirc, oDir, oNorm;\nfloat tCur, dstFar, flyVel, tLen[N_SEG], hTop, rLoop, sHzRamp, rCirc, sDnRamp, sUpRamp,\n   sHzStr, pathDir, vfLoop, ptFac;\nint idObj, idObjGrp;\nconst int idFus = 1, idPipe = 2, idWing = 3, idStrut = 4, idHstab = 5,\n   idFin = 6, idLeg = 7, idAxl = 8, idWhl = 9, idNose = 10, idCan = 11, idPlt = 12;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float h, wAmp;\n  qRot = 1.9 * mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.04 * p;\n  h = 0.;\n  wAmp = 1.;\n  for (int j = 0; j < 4; j ++) {\n    h += wAmp * Noisefv2 (q);\n    wAmp *= 0.45;\n    q *= qRot;\n  }\n  return 5. * h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 ws;\n  float d, wr, h;\n  int ig;\n  ig = idObjGrp / 256;\n  q = p;\n  wr = -0.2 + q.z;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.), 0.05);\n  d = max (d, - PrRoundBoxDf (q - vec3 (0., 0.16, 0.), vec3 (0.04, 0.03, 0.07), 0.04)); \n  DMINQ (idObjGrp + idFus);\n  q = p;  q -= vec3 (0., 0.17, 0.5);\n  d = PrCylDf (q, 0.015, 0.15);\n  DMINQ (idObjGrp + idCan);\n  q = p;  q.y -= 0.17;\n  d = PrSphDf (q, 0.04); \n  DMINQ (idObjGrp + idPlt);\n  q = p - vec3 (0., 0.03, 0.8);  q.x = abs (q.x) - 0.1;\n  d = PrCapsDf (q, 0.02, 0.15);\n  DMINQ (idObjGrp + idPipe);\n  q = p - vec3 (0., 0.03, 1.1);\n  d = PrConeDf (q, vec3 (0.8, 0.6, 0.06));\n  DMINQ (idObjGrp + idNose);\n  q = p - vec3 (0., ((ig == 1) ? 0.12 : 0.09), 0.4);\n  qq = q;\n  if (ig == 1) qq.y += 0.12;\n  h = (ig == 1) ? 0.24 : 0.42;\n  qq.y = mod (qq.y, h) - 0.5 * h;\n  wr = q.z / 0.24;\n  d = PrRoundBoxDf (qq, vec3 (1.2, 0.01 * (1. - wr * wr), 0.24), 0.005);\n  d = max (d, abs (q.y) - 0.26);\n  DMINQ (idObjGrp + idWing);\n  h = (ig == 1) ? 0.12 : 0.09;\n  q = p - vec3 (0., h, 0.42);  q.xz = abs (q.xz) - vec2 (0.5, 0.1);\n  h = (ig == 1) ? 0.24 : 0.21;\n  d = PrCylDf (q.xzy, 0.01, h);\n  DMINQ (idObjGrp + idStrut);\n  h = (ig == 1) ? 0.24 : 0.15;\n  q = p - vec3 (0., h, 0.42);  q.x = abs (q.x) - 0.1;\n  h = (ig == 1) ? 0.12 : 0.15;\n  d = PrCylDf (q.xzy, 0.01, h);\n  DMINQ (idObjGrp + idStrut);\n  q = p;  q.z -= -0.9;\n  wr = q.z / 0.15;\n  d = PrRoundBoxDf (q, vec3 (0.42, 0.005 * (1. - wr * wr), 0.15), 0.002);\n  q.x = abs (q.x);\n  d = max (d, 0.02 - 1.5 * q.x - q.z);\n  DMINQ (idObjGrp + idHstab);\n  q = p;  q.z -= -0.87;\n  q.yz = Rot2D (q.yz, 0.15);\n  ws = q.yz / vec2 (0.37, 0.15);\n  ws *= ws;\n  d = PrRoundBoxDf (q, vec3 (0.005 * (1. - ws.y), 0.37, 0.15 * (1. - 0.3 * ws.x)), 0.002);\n  d = max (d, - q.y);\n  DMINQ (idObjGrp + idFin);\n  q = p - vec3 (0., -0.24, 0.7);  q.x = abs (q.x) - 0.135;\n  q.xy = Rot2D (q.xy, -0.55);\n  q.yz = Rot2D (q.yz, 0.15);\n  d = PrCylDf (q.xzy, 0.013, 0.13);\n  DMINQ (idObjGrp + idLeg);\n  q = p - vec3 (0., -0.34, 0.715);  q.x = abs (q.x) - 0.22;\n  d = PrCylDf (q.yzx, 0.01, 0.035);\n  DMINQ (idObjGrp + idAxl);\n  q.x -= 0.01;\n  d = PrCylDf (q.yzx, 0.1, 0.015);\n  DMINQ (idObjGrp + idWhl);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int j = 0; j < 2; j ++) {\n    idObjGrp = (j + 1) * 256;\n    dMin = FlyerDf (flyerMat[j] * (p - flyerPos[j]), dMin);\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat PropelDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - vec3 (0., 0.02, 1.07);\n  d = PrCylDf (q, 0.3, 0.007);\n  if (d < dMin) { dMin = d;  qHitTransObj = q; }\n  return dMin;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int j = 0; j < 2; j ++) {\n    dMin = PropelDf (flyerMat[j] * (p - flyerPos[j]), dMin);\n  }\n  return dMin;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol (int ig, int id, vec3 vn)\n{\n  vec3 col, bCol;\n  vec2 w;\n  float spec, s;\n  spec = 0.2;\n  bCol = vec3 (0.7, 0.4, 0.2);\n  col = (ig == 2) ? vec3 (0.1, 0.9, 0.) : vec3 (1., 0., 0.);\n  if (id == idFus) {\n    if (ig == 2) col = mix (col, bCol, step (mod (4. * qHit.z, 1.), 0.5));\n    if (qHit.z > 1.01) {\n      col = vec3 (0.9);\n      spec = 0.4;\n      if (length (abs (qHit.xy + vec2 (0., 0.05)) * vec2 (0.6, 1.)) < 0.03) col *= 1. -\n         0.7 * SmoothBump (0.2, 0.8, 0.05, mod (64. * ((ig == 1) ? qHit.y : qHit.x), 1.));\n    }\n    w = abs (qHit.xz) - vec2 (0.09, 0.12);\n    if (abs (qHit.y - 0.1) < 0.04 && max (w.x, w.y) < 0.) col = vec3 (0.2, 0.15, 0.05);\n    qHit.z += 0.3;\n    if (ig == 2) col = mix (vec3 (0.9), col,\n       (1. - SmoothBump (0.05, 0.08, 0.005, length (qHit.yz))) *\n       (1. - SmoothBump (-0.01, 0.03, 0.005, length (qHit.yz))));\n    else col = mix (vec3 (0.2), col,\n       (1. - SmoothBump (0.02, 0.04, 0.01, length (abs (qHit.yz) - 0.04))));\n  } else if (id == idWing) {\n    if (ig == 2) col = mix (col, bCol, step (mod (4. * abs (qHit.x) + 0.25, 1.), 0.5));\n    s = 1.2 / 8.;\n    s = mod (qHit.x + 0.5 * s, s) - 0.5 * s;\n    col *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, s);\n    if (abs (qHit.y) > 0.1) {\n      if (abs (qHit.x) > 0.7)\n         col *= 1. - 0.6 * SmoothBump (-0.158, -0.147, 0.002, qHit.z);\n      if (qHit.z < -0.155)\n         col *= 1. - 0.6 * SmoothBump (0.695, 0.705, 0.002, abs (qHit.x));\n      if (qHit.y * vn.y > 0.) {\n        qHit.x = abs (qHit.x) - 0.8;\n        qHit.z -= 0.03;\n        if (ig == 2) col = mix (vec3 (0.9), col,\n           (1. - SmoothBump (0.08, 0.12, 0.01, length (qHit.xz))) *\n           (1. - SmoothBump (-0.01, 0.03, 0.01, length (qHit.xz))));\n        else col = mix (vec3 (0.2), col,\n           (1. - SmoothBump (0.03, 0.06, 0.01, length (abs (qHit.xz) - 0.06))));\n      }\n    }\n  } else if (id == idHstab) {\n    if (ig == 2) col = mix (col, bCol, step (mod (4. * abs (qHit.x) + 0.25, 1.), 0.5));\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qHit.z);\n  } else if (id == idFin) {\n    if (ig == 2) col = mix (col, bCol, step (mod (4. * qHit.y, 1.), 0.5));\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qHit.z);\n  } else if (id == idNose) {\n    if (qHit.z > -0.04) {\n      col = mix (col, vec3 (1.), 0.5);\n      spec = 0.4;\n    } else col = vec3 (0.1);\n  } else if (id == idPipe) {\n    col = vec3 (0.8, 0.8, 0.85) * (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05, mod (16. * qHit.z, 1.)));\n    spec = 0.4;\n  } else if (id == idStrut || id == idLeg) {\n    col = 0.6 * col + vec3 (0.4);\n  } else if (id == idAxl) {\n    col = vec3 (0.3, 0.2, 0.);\n  } else if (id == idCan) {\n    col = vec3 (0.2, 0.2, 0.22);\n  } else if (id == idPlt) {\n    col = vec3 (0.4, 0.2, 0.1);\n    spec = 0.;\n    if (qHit.z > 0.02 && qHit.y < 0.03) col = (ig == 2) ? vec3 (0.9) : vec3 (0.6, 0.4, 0.4);\n    if (qHit.z > 0. && length (vec2 (abs (qHit.x) - 0.011, qHit.y - 0.015)) < 0.01) {\n      col = vec3 (0., 0.2, 0.);\n      spec = 0.4;\n    }\n    if (qHit.z > 0. && ig == 2 && length (qHit.xy - vec2 (0., -0.02)) < 0.012) col = vec3 (0.1);\n  } else if (id == idWhl) {\n    if (length (qHit.yz) < 0.07) col = vec3 (0.4, 0.4, 0.4);\n    else {\n      col = vec3 (0.02);\n      spec = 0.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.41, 0.55), smoothstep (-0.02, 0.01, rd.y));\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) * min (0.3 * pow (sd, 64.) +\n       0.5 * pow (sd, 2048.), 1.);\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.7), skCol, 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, roo;\n  float dstObj, dstGrnd, dstPropel, sh, f, s;\n  int ig, id;\n  dstObj = ObjRay (ro, rd);\n  dstPropel = TransObjRay (ro, rd);\n  if (dstObj < dstPropel) dstPropel = dstFar;\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    ig = idObj / 256;\n    id = idObj - 256 * ig;\n    col4 = FlyerCol (ig, id, ((ig == 1) ? flyerMat[0] : flyerMat[1]) * vn);\n    if (id == idWing || id == idHstab) vn = VaryNf (128. * ro, vn, 0.1);\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n       0.6 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else if (rd.y < 0.) {\n    roo = ro;\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    f = 1. - clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.);\n    s = 1. - smoothstep (0.2, 0.6, dstGrnd / dstFar);\n    vn = VaryNf (4. * ro, vn, 4. * f * f * s);\n    col = mix (vec3 (0.35, 0.5, 0.2), vec3 (0.3, 0.4, 0.1),\n       smoothstep (0.2, 0.8, Fbm2 (0.3 * ro.xz)));\n    col = mix (vec3 (0.33, 0.45, 0.15), col, s);\n    col = col * (0.1 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.));\n    col = mix (col, SkyBgCol (roo, rd), pow (1. + rd.y, 32.));\n  } else col = SkyBgCol (ro, rd);\n  if (dstPropel < dstFar) col = vec3 (0.1) * (1. - 0.3 * SmoothBump (0.25, 0.27,\n     0.006, length (qHitTransObj.xy))) + 0.7 * col;\n  return clamp (col, 0., 1.);\n}\n\nvoid PathSetup ()\n{\n  ptFac = 20.;\n  cPtOrg = vec3 (2. * pathDir, 0., -3.);\n  hTop = 1.5;\n  rLoop = 2.2;\n  sHzRamp = 1.;\n  rCirc = 2.;\n  sDnRamp = 1.5;\n  sUpRamp = 1.3 * sDnRamp;\n  sHzStr = sDnRamp - sUpRamp + 3. * sHzRamp;\n  vfLoop = 0.3;\n  cDnCirc = cPtOrg + vec3 (- rCirc * pathDir, 0., -2. * sHzRamp);\n  cUpCirc = cPtOrg + vec3 (- rCirc * pathDir, 2. * hTop, 2. * sDnRamp + 6. * sHzRamp);\n  cPt[0] = cDnCirc;   cPt[0].xz += vec2 (- rCirc * pathDir, sHzStr);\n  cPt[1] = cPt[0];    cPt[1].z += sHzStr;\n  cPt[3] = cUpCirc;   cPt[3].x -= rCirc * pathDir;\n  cPt[4] = cUpCirc;   cPt[4].x += rCirc * pathDir;\n  cPt[2] = cPt[3];    cPt[2].z -= 2. * sHzRamp;\n  cPt[5] = cPt[4];    cPt[5].z -= 2. * sHzRamp;\n  cPt[7] = cPtOrg;\n  cPt[8] = cPtOrg;\n  cPt[6] = cPt[7];    cPt[6].z += 4. * sHzRamp;\n  cPt[9] = cDnCirc;   cPt[9].x += rCirc * pathDir;\n  cPt[10] = cDnCirc;  cPt[10].x -= rCirc * pathDir;\n  cPt[11] = cPt[0];\n  tLen[0] = 0.;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] = length (cPt[k] - cPt[k - 1]);\n  tLen[4] = pi * rCirc;\n  tLen[8] = 2. * pi * rLoop * (1. + vfLoop);\n  tLen[10] = pi * rCirc;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] += tLen[k - 1];\n}\n\nvoid FlyerPM1 (float t)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = vec3 (dot (trkA, sin (trkF * t)), 10. + 3. * SmoothBump (0.25, 0.75, 0.2, mod (0.001 * t, 1.)), t);\n  vel = vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n  va = cross (vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 20. * length (va) * sign (va.y) + 0.4 * (Fbm1 (0.02 * t) - 0.5);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid FlyerPM2 (float t, float vu)\n{\n  vec3 p, p1, p2, u;\n  vec2 cs;\n  float w, ft, ftt, s, h, oRl;\n  int ik;\n  h = 2. * sin (0.43 * pi * t) + sin (0.79 * pi * t);\n  oRl = 0.01 * pi * h;\n  t = mod (t, tLen[N_SEG - 1]);\n  for (int k = 1; k < N_SEG; k ++) {\n    if (t < tLen[k]) {\n      t -= tLen[k - 1];\n      p1 = cPt[k - 1];\n      p2 = cPt[k];\n      w = tLen[k] - tLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  oNorm = vec3 (0., 1., 0.);\n  ftt = t / w;\n  ft = ftt;\n  if (ik == 4 || ik == 10) oRl += -0.25 * pi * SmoothBump (0.05, 0.95, 0.05, ft);\n  if (ik == 4) oRl += 2. * pi * smoothstep (0.4, 0.6, ft);\n  if (ik == 2 || ik == 6) {\n    oDir = p2 - p1;\n    p.xz = p1.xz + oDir.xz * ft * vec2 (pathDir, 1.);\n    p.y = p1.y + oDir.y * smoothstep (0., 1., ft);\n    oDir.y *= 6. * ft * (1. - ft);\n    oDir = normalize (oDir);\n  } else if (ik == 4) {\n    ft *= pi;\n    p = cUpCirc;\n    u = vec3 (- cos (ft) * pathDir, 0., sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= pathDir;\n  } else if (ik == 8) {\n    ft = (ft < 0.5) ? ft * (1. + vfLoop * (1. - 2. * ft)) :\n       ft * (1. + 2. * vfLoop * (ft - 1.5)) + vfLoop;\n    p = 0.5 * (cPt[7] + cPt[8]);\n    ft *= 2. * pi;\n    u = vec3 (0., cos (ft), sin (ft));\n    p.yz += rLoop * (vec2 (1., 0.) - u.yz);\n    oNorm = u;\n    oDir = normalize (vec3 (0., 2. * pi * rLoop * vec2 (sin (ft), - cos (ft))));\n  } else if (ik == 10) {\n    ft *= pi;\n    p = cDnCirc;\n    u = vec3 (cos (ft) * pathDir, 0., - sin (ft));\n    p.xz += rCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= pathDir;\n  } else {\n    oDir = p2 - p1;\n    p = p1 + oDir * ft;\n    oDir = normalize (oDir);\n  }\n  p *= ptFac;\n  p.y += 2. + 0.1 * h;\n  p.y += 8.;\n  flPos = p;\n  if (vu > 0.) {\n    oDir *= -1.;\n    oRl *= -1.;\n  }\n  oRl += 0.2 * (Fbm1 (t) - 0.5) * SmoothBump (0.1, 0.9, 0.1, ftt);\n  cs = sin (oRl * pathDir + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) * AxToRMat (oDir, oNorm);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, uvs, ori, ca, sa;\n  float az, el, s, t, sr;\n  int tpTrk;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  tCur = mod (tCur, 3600.) + floor (dateCur.w / 3600.);\n  tpTrk = 1;\n  t = 0.01 * tCur;\n  if (length (uvs) < 1.5 * SmoothBump (0.2, 0.9, 0.01, mod (t, 1.))) tpTrk = 2;\n  if (tpTrk == 1) {\n    flyVel = 20.;\n    trkA = 8. * vec3 (1.9, 2.9, 4.3);\n    trkF = 0.15 * vec3 (0.23, 0.17, 0.13);\n    s = mod (0.022 * tCur, 1.);\n  } else if (tpTrk == 2) {\n    tCur = 100. * mod (t, 1.) + 10.;\n    flyVel = 0.8;\n    pathDir = (mod (t, 2.) > 1.) ? 1. : -1.;\n    PathSetup ();\n  }\n  for (int j = 0; j < 3; j ++) {\n    t = tCur * flyVel;\n    if (tpTrk == 1) {\n      if (j < 2) t += (j == 0) ? 4.5 : 10.5;\n      else t += 1.5 + 12. * SmoothBump (0.25, 0.75, 0.15, s);\n    } else if (tpTrk == 2) {\n      if (j < 2) t += ((j == 0) ? 0.3 : 0.8);\n    }\n    if (tpTrk == 1) {\n      FlyerPM1 (t);\n    } else if (tpTrk == 2) {\n      FlyerPM2 (t, 0.);\n    }\n    if (j < 2) {\n      flyerPos[j] = flPos;\n      if (tpTrk == 1) flyerPos[j].x += (j == 0) ? -0.1 : 0.1;\n      flyerMat[j] = flMat;\n    } else {\n      ro = flPos;\n      if (tpTrk == 2) ro += 0.7 * oNorm + 0.5 * cross (oNorm, oDir) * sin (0.2 * t);\n    }\n  }\n  if (tpTrk == 1) {\n    ro.y += 0.5 + SmoothBump (0.25, 0.75, 0.15, mod (2. * s, 1.)) * sign (s - 0.5);\n    ro.x += 9. * SmoothBump (0.25, 0.75, 0.15, mod (2. * s, 1.)) * sign (s - 0.5);\n    vd = normalize (0.5 * (flyerPos[0] + flyerPos[1]) - ro);\n    az = 0.5 * pi + atan (- vd.z, vd.x);\n    el = asin (vd.y);\n  } else if (tpTrk == 2) {\n    az = 0.;\n    el = 0.;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 300.;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 2., - sin (0.01 * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv;\n    if (naa > 1.) uvv += Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = normalize (vec3 (uvv, 3.));\n    if (tpTrk == 2) rd = rd * flMat;\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y), vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSGWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1120, 1143, 1143, 1384], [1386, 1386, 1408, 1408, 1548], [1621, 1621, 1657, 1657, 3902], [3904, 3904, 3926, 3926, 4107], [4109, 4109, 4142, 4142, 4318], [4320, 4320, 4341, 4341, 4533], [4535, 4535, 4572, 4572, 4723], [4725, 4725, 4752, 4752, 4898], [4900, 4900, 4938, 4938, 5118], [5120, 5120, 5161, 5161, 8413], [8415, 8415, 8452, 8452, 8674], [8676, 8676, 8710, 8710, 9587], [9589, 9589, 9624, 9624, 11193], [11195, 11195, 11214, 11214, 12351], [12353, 12353, 12378, 12378, 12957], [12959, 12959, 12994, 12994, 14938], [14940, 14940, 14996, 14996, 17510], [17512, 17512, 17544, 17544, 17644], [17646, 17646, 17692, 17692, 17739], [17741, 17741, 17774, 17774, 17801], [17803, 17803, 17845, 17845, 17896], [17898, 17898, 17941, 17941, 18005], [18007, 18007, 18040, 18040, 18113], [18115, 18115, 18172, 18172, 18255], [18257, 18257, 18291, 18291, 18453], [18455, 18455, 18485, 18485, 18598], [18632, 18632, 18656, 18656, 18709], [18711, 18711, 18735, 18735, 18865], [18867, 18867, 18892, 18892, 19038], [19040, 19040, 19065, 19065, 19251], [19253, 19253, 19275, 19275, 19429], [19431, 19431, 19452, 19452, 19607], [19609, 19609, 19638, 19638, 19850], [19852, 19852, 19891, 19891, 20071]]}
{"id": "WdsGzl", "name": "luminance fusion 2", "author": "FabriceNeyret2", "description": "blinking checkered tiles at different framerate ( left: 60 fps right: 2 fps ) and different size ( 1 -> 32 ).\nbottom line = plain,  left column = constant mid-grey.\nBetter seen in fullscreen.\nNote that LCD hardware might interfere.", "tags": ["illusion", "perception", "short"], "likes": 2, "viewed": 351, "published": "Public API", "date": "1547217004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of grey    https://shadertoy.com/view/4sVfWD\n// variant of colored https://shadertoy.com/view/4dVfWD\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    \n    float y = floor( 6.*U.y/R.y -1. ),       \n          n = y < 0. ? 1e-5 : exp2(y) ,   // checker scale\n          x = (floor(U.x/n)*n - 32. ) / R.x,\n          t = float(iFrame),\n        //v = (1.+60.*x);\n          v = exp2(log2(60.)*x);          // fps\n    \n    ivec2 I = ivec2(U/n);                 // chechers\n    \n    v = exp2( floor(log2(v)) ); // bands of same fps (or horrible aliasing)\n                                // left: 60fps  right: swap at 2 fps\n    \n    O =  x < 0. ? vec4( pow( .5, 1./2.2 ) ) \n                : vec4( ( int(t/v) + I.x + I.y ) % 2 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 151, 151, 756]]}
{"id": "WdX3Dn", "name": "Triangle party", "author": "levgogol", "description": "My home work on computer graphics", "tags": ["triangle", "rotate"], "likes": 2, "viewed": 318, "published": "Public API", "date": "1548426417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot2(vec2 point, float alpha, vec2 center){\n    vec2 temp;\n    temp.x = center.x + (point.x - center.x) * cos(alpha) - (point.y - center.y) * sin(alpha);\n\ttemp.y = center.y + (point.y - center.y) * cos(alpha) + (point.x - center.x) * sin(alpha);\n    return temp;\n}\n\n\nfloat PseudoScalarProduct(vec2 a, vec2 b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nvec3 P(vec3 r){\n    mat3 A = mat3(vec3(sin(iTime), 0., 0.),\n                  vec3(0., cos(iTime), 0.),\n                  vec3(0., 0., .0));\n    vec3 B = A * r;\n\treturn B;\n}\n\nfloat triangle (vec2 A, vec2 B, vec2 C, vec2 uv) {\n    float p1 = PseudoScalarProduct(vec2(B.x - A.x, B.y - A.y), vec2(uv.x - A.x, uv.y - A.y));\n    float p2 = PseudoScalarProduct(vec2(C.x - B.x, C.y - B.y), vec2(uv.x - B.x, uv.y - B.y));\n    float p3 = PseudoScalarProduct(vec2(A.x - C.x, A.y - C.y), vec2(uv.x - C.x, uv.y - C.y));\n    \n    return step(3., abs(sign(p1) + sign(p2) + sign(p3)));\n    //if ((p1 >= 0. && p2 >= 0. && p3 >= 0.) || (p1 <= 0. && p2 <= 0. && p3 <= 0.)) return 1.;\n    //else return 0.;\n}\n\nfloat leftTriangle (vec2 uv) {\n    vec2 A = vec2(-0.2, 0.2);\n\tvec2 B = vec2(-0.8, 0.2);\n    vec2 C = vec2(-0.5, 0.8);\n    \n    vec2 center = vec2((A.x + B.x +C.x)/3., (A.y + B.y + C.y)/3.);\n    \n    float alpha = iTime;\n    \n    A = rot2(A, alpha, center);\n    B = rot2(B, alpha, center);\n    C = rot2(C, alpha, center);\n    \n  \n    return triangle (A, B, C, uv);\n}\n\nfloat rightTriangle (vec2 uv) {\n    vec2 A = vec2(0.2, 0.2);\n\tvec2 B = vec2(0.8, 0.2);\n    vec2 C = vec2(0.5, 0.8);\n    \n    vec2 center = vec2((A.x + B.x +C.x)/3., (A.y + B.y + C.y)/3.);\n    \n    float alpha = sin(iTime) * 3. + iTime * 4.;\n    \n    A = rot2(A, alpha, center);\n    B = rot2(B, alpha, center);\n    C = rot2(C, alpha, center);\n    \n    return triangle (A, B, C, uv);\n}\n\nfloat centralTriangle(vec2 uv) {\n    vec3 A = vec3(-0.2, -0.2, 1);\n\tvec3 B = vec3(0.2, -0.2, 1);\n    vec3 C = vec3(0, 0.2, 1);\n    \n    A = P(A);\n    B = P(B);\n    C = P(C);\n    \n    return triangle (A.xy, B.xy, C.xy, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. -1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //vec3 col = vec3(0.8);\n    vec3 col = vec3(uv.x * uv.y, uv.y * -uv.x, uv.y);\n\n\n    col += (vec3(1., 0., 0.) - col) * leftTriangle (uv);\n    col += (vec3(uv.x, uv.y, uv.x * uv.y) - col) * rightTriangle(uv);\n    col += (cos(iTime+uv.xyy+vec3(0,2,4)) - col) * centralTriangle(uv);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdX3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 269], [272, 272, 315, 315, 351], [353, 353, 368, 368, 526], [528, 528, 578, 578, 1042], [1044, 1044, 1074, 1074, 1409], [1411, 1411, 1442, 1442, 1794], [1796, 1796, 1828, 1828, 2020], [2022, 2022, 2079, 2079, 2490]]}
{"id": "WdX3DS", "name": "Quick Flips!", "author": "compy_art", "description": "Having some fun with shaders", "tags": ["bookofshaders"], "likes": 1, "viewed": 74, "published": "Public", "date": "1547278153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    mat2 rotation_matrix = mat2(cos(t), sin(t), -sin(t), cos(t));\n\n    vec2 center = iResolution.xy / vec2(2.0, 2.0);\n    vec2 st = fragCoord.xy - center;\n    \n    \n    vec2 rt_hard = st * rotation_matrix;\n    vec2 rt_soft = normalize(st) * rotation_matrix;\n    \n    \n    vec3 color = vec3(mix(rt_hard, rt_soft, abs(tan(iTime / 2.0))), 0.5);\n\tfragColor = vec4(color, 1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdX3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 503]]}
{"id": "wdX3Wl", "name": "[TWITCH] Amaterasu inspiration", "author": "Flopine", "description": "Result from 2 twitch sessions, each of 1 hour and a half. \nHeavily inspired by the masterpiece game Okami :D ", "tags": ["raymarching", "toonshading", "twitch", "okami"], "likes": 7, "viewed": 167, "published": "Public", "date": "1547765126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n#define time iTime\n#define EPS 0.01\n\n#define MAT_SHIELD 0.\n#define MAT_BACK 1.\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 moda (vec2 p, float per)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  a = mod (a-per/2., per)-per/2.;\n  return vec2(cos(a),sin(a))*l; \n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n  if (a.x < b.x) return a;\n  else return b;\n}\n\n\nfloat spiral (vec2 p, float sa, float b)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n\n  float n = (log(l/sa)/b - a) / (2.*PI);\n\n  float upper_ray = sa * exp(b *(a + 2.*PI*ceil(n)));\n  float lower_ray = sa * exp(b *(a + 2.*PI*floor(n)));\n\n  return min(abs(upper_ray - l), abs(l-lower_ray));\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\n\nfloat roots (vec3 p)\n{\n  p.x += sin(p.z)*0.3;\n  p.xz = moda(p.xz, 2.*PI/7.);\n  p.x -= 3.;\n  p.y += sin(p.x)*0.5;\n  return cyl(p.yzx, 0.2-p.x*0.2, 2.);\n}\n\n\nfloat base (vec3 p)\n{\n  p.xy -= vec2(0.8,2.5);\n  p.x -= sin(p.y)*0.7;\n  return cyl(p.xzy, 1.08-p.y*0.2, 2.);\n}\n\n\nfloat bud (vec3 p)\n{\n  float s = length(p)-2.35;\n  p.x = spiral(p.xy, PI/5., .3);\n  float d = cyl (p.xzy, 0.4-p.y*0.15, 1.5);\n  d = max(s, d);\n  return d;\n}\n\n\nfloat island (vec3 p)\n{\n  p.y += 2.5;\n  float s = length(vec3(p.x*0.5, p.y+2.7, p.z*0.5))-5.;\n  return s;\n}\n\n\nfloat pic (vec3 p)\n{\n  p.x += 0.7;\n  p.x += sin(p.y*0.5);\n  float c3 = cyl(vec3(p.x*2., p.z, p.y), 0.5-p.y*0.5, 1.5);\n  return c3;\n}\n\n\nfloat pics (vec3 p)\n{\n  p.yz = moda(p.yz, 2.*PI/8.);\n  p.y -= 6.;\n  return min(cyl(vec3(p.x, p.z, p.y+3.), 0.3, 2.),pic(p));\n}\n\n\nfloat rings (vec3 p)\n{  \n  float c1 = cyl(p.yzx, 2.5, 0.1);\n  float c2 = max(-cyl(p.yzx, 3.5,1.), cyl(p.yzx, 4., 0.05));\n  return min (c1, c2);\n}\n\n\nfloat top_shield (vec3 p)\n{\n  p.xy *= rot(-PI/2.);\n  float s = max(-p.y,length(p)-1.8);\n  p.xz = moda(p.xz, PI/2.);\n  float c = cyl(vec3(p.y-1., p.z, p.x), 0.5, 5.);\n  return max(-c, s);\n}\n\n\nvec2 shield (vec3 p)\n{\n  float t1 = floor(time);\n  float t2 = fract(time);\n\n  t2 = pow(t2, 4.);\n  float anim1 = PI/5.*(t1+ t2);\n  float anim2 = floor(time)+sin(fract(time)*PI/2.);\n\n  float anim = mix(anim1, anim2, 0.2);\n  p.yz *= rot(anim);\n  return vec2(min(min(rings(p), pics(p)),top_shield(p)), MAT_SHIELD);\n\n}\n\n\nvec2 background (vec3 p)\n{\n  float tree = smin(bud(vec3(p.x-2.85, p.y-5.9, p.z+0.1)),smin(roots(p),base(p), 0.5), 0.1);\n  return vec2(min(island(p), tree), MAT_BACK);\n}\n\n\nvec2 SDF (vec3 p)\n{\n  vec2 b = background(p);\n  p += vec3(3.,-4., 5.);\n  return mat_min(shield(p/0.5)*0.5, b);\n}\n\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.1,0.);\n  return normalize(vec3(SDF(p+eps.xyy).x - SDF(p - eps.xyy).x,\n                        SDF(p+eps.yxy).x - SDF(p - eps.yxy).x,\n                        SDF(p+eps.yyx).x - SDF(p - eps.yyx).x\n                        )\n                   );\n}\n\n\nfloat lighting(vec3 p)\n{\n  vec3 n = getnorm(p);\n  return dot(n, normalize(vec3(2.,10., -3.)))*0.5+0.5;\n}\n\n\nvec3 color_ramp(float t)\n{\n  float sm = smoothstep(0., 0.5, t);\n  float sm2 = smoothstep(0.5, .8, t);\n  vec3 col1 = mix(vec3(0.8, 0., 0.7), vec3(0.9,0.2,0.), sm);\n  return mix(col1,vec3(0.9,0.8,0.), sm2);\n}\n\n\nvec3 getcam (vec3 ro, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target - ro);\n  vec3 right = normalize(cross(vec3(0.,1.,0.), forward));\n  vec3 up = normalize(cross(forward, right));\n  return forward * fov + right * uv.x + up * uv.y;\n}\n\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(time*.3);\n  return vec3(0.8,0.1,0.)+floor(cos(atan(uv.y, uv.x)*12.));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(10.,5.,-10.0); \n  vec3 p = ro;\n  vec3 target = vec3(-2.5, 3., 0.);\n  vec3 rd = getcam(ro, target, uv, 1.);\n    \n  vec3 col = vec3(0.);\n  float shad, pd, t=0., tmax=50.;\n  vec2 d = vec2(0.);\n  float outline = 1.;\n\n  for(float i = 0.; i<ITER; i++)\n  {\n    pd = d.x;\n    d = SDF(p);\n  // Tricks from lnae : https://www.shadertoy.com/view/4tdyRj\n  if (d.x > pd + EPS && d.x < 0.14) outline = 0.;\n\n  if (d.x < EPS || t > tmax) break;\n    t+=d.x*0.4;\n    p = ro + rd * t;\n  }\n\n  if (t<=tmax)\n  {\n    if(d.y == MAT_BACK) col = mix(vec3(0.4,0.1,0.), vec3(0.9,0.8,0.8), lighting(p));\n    if (d.y == MAT_SHIELD) col = color_ramp(lighting(p));\n  }\n  else col = vec3(0.8) + pales(uv-vec2(0.8))*(1.-length(uv))*0.4;\n\n  col *= outline;\n  col += texture(iChannel0, uv*0.5).rgb * 0.1;\n\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdX3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 307, 327, 327, 370], [373, 373, 404, 404, 524], [527, 527, 568, 568, 661], [664, 664, 695, 695, 741], [744, 744, 786, 786, 1044], [1047, 1047, 1085, 1085, 1125], [1128, 1128, 1150, 1150, 1280], [1283, 1283, 1304, 1304, 1393], [1396, 1396, 1416, 1416, 1552], [1555, 1555, 1578, 1578, 1662], [1665, 1665, 1685, 1685, 1797], [1800, 1800, 1821, 1821, 1926], [1929, 1929, 1951, 1951, 2074], [2077, 2077, 2104, 2104, 2265], [2268, 2268, 2290, 2290, 2581], [2584, 2584, 2610, 2610, 2752], [2755, 2755, 2774, 2774, 2867], [2870, 2870, 2893, 2893, 3158], [3161, 3161, 3185, 3185, 3265], [3268, 3268, 3294, 3294, 3474], [3477, 3477, 3533, 3533, 3731], [3734, 3756, 3778, 3778, 3862], [3866, 3866, 3923, 3923, 4881]]}
{"id": "wdX3Ws", "name": "f*ck", "author": "xavior", "description": "silahkan copy", "tags": ["alotofwork"], "likes": 0, "viewed": 289, "published": "Public API", "date": "1547780285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band (float t, float start, float end, float blur) {\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep( end + blur, end - blur,t );\n    return step1 * step2;\n}\n\nfloat Rectangle (vec2 uv, float blur, float left, float right, float bottom, float top) {\n    float r;\n    r = Band(uv.x, left, right, blur);\n    r *= Band(uv.y, bottom, top, blur);\n    return r;\n}\n\nfloat Triangle (vec2 uv, float blur, float point) {\n    float t = uv.y;\n    return Rectangle( uv, blur, -point + t, point -t ,-point - t , point + t);\n}\n\nfloat Triangle1 (vec2 uv, float blur, float point) {\n    float t = uv.y*-1.;\n    return Rectangle( uv, blur, -point + t, point -t ,-point - t , point + t);\n}\n\nfloat skerpski(vec2 uv, int lvl) {\n    float c;\n    \n    if (lvl == 1){\n        c = Triangle(uv- vec2(.0,-.1), .001,.6);//paling besar\n        //=====================================\n        c -= Triangle1(uv- vec2(.0,-.1), .001,.3);//sedang1\n        //=======================================\n    }\n    else if (lvl == 2){\n        c = Triangle(uv- vec2(.0,-.1), .001,.6);//paling besar\n        //=====================================\n        c -= Triangle1(uv- vec2(.0,-.1), .001,.3);//sedang1\n        //=======================================\n        c -= Triangle1(uv- vec2(.0,.2), .001,.15);//sedang\n        c -= Triangle1(uv- vec2(.45,-.25), .001,.15);\n        c -= Triangle1(uv- vec2(-.45,-.25), .001,.15);\n        //b += Triangle(uv- vec2(.0,-.1), .001,.15);\n        //=========================================\n    }\n    else if(lvl == 3){\n        c = Triangle(uv- vec2(.0,-.1), .001,.6);//paling besar\n       //=====================================\n       c -= Triangle1(uv- vec2(.0,-.1), .001,.3);//sedang1\n       //=======================================\n       c -= Triangle1(uv- vec2(.0,.2), .001,.15);//sedang\n       c -= Triangle1(uv- vec2(.45,-.25), .001,.15);\n       c -= Triangle1(uv- vec2(-.45,-.25), .001,.15);\n       //b += Triangle(uv- vec2(.0,-.1), .001,.15);\n       //=========================================\n       c -= Triangle1(uv- vec2(-.68,-.32), .001,.075);//kecil kiri\n       c -= Triangle1(uv- vec2(-.23,-.32), .001,.075);\n       c -= Triangle1(uv- vec2(-.45,-.1), .001,.075);\n       //b += Triangle(uv- vec2(-.45,-.25), .001,.075);\n       //============================================\n       c -= Triangle1(uv- vec2(.68,-.32), .001,.075);//kecil kanan\n       c -= Triangle1(uv- vec2(.23,-.32), .001,.075);\n       c -= Triangle1(uv- vec2(.45,-.1), .001,.075);\n       //b += Triangle(uv- vec2(.45,-.25), .001,.075);\n       //============================================\n       c -= Triangle1(uv- vec2(-.23,.13), .001,.075);//kecil atas\n       c -= Triangle1(uv- vec2(.23,.13), .001,.075);\n       c -= Triangle1(uv- vec2(.0,.35), .001,.075);\n       //b += Triangle(uv- vec2(.0,.2), .001,.075);\n    }\n    else {\n        c = Triangle(uv- vec2(.0,-.1), .001,.6);//paling besar\n        //=====================================\n        c -= Triangle1(uv- vec2(.0,-.1), .001,.3);//sedang1\n        //=======================================\n        c -= Triangle1(uv- vec2(.0,.2), .001,.15);//sedang\n        c -= Triangle1(uv- vec2(.45,-.25), .001,.15);\n        c -= Triangle1(uv- vec2(-.45,-.25), .001,.15);\n        //b += Triangle(uv- vec2(.0,-.1), .001,.15);\n         //=========================================\n        c -= Triangle1(uv- vec2(-.68,-.32), .001,.075);//kecil kiri\n        c -= Triangle1(uv- vec2(-.23,-.32), .001,.075);\n        c -= Triangle1(uv- vec2(-.45,-.1), .001,.075);\n        //b += Triangle(uv- vec2(-.45,-.25), .001,.075);\n        //============================================\n        c -= Triangle1(uv- vec2(.68,-.32), .001,.075);//kecil kanan\n        c -= Triangle1(uv- vec2(.23,-.32), .001,.075);\n        c -= Triangle1(uv- vec2(.45,-.1), .001,.075);\n        //b += Triangle(uv- vec2(.45,-.25), .001,.075);\n        //============================================\n        c -= Triangle1(uv- vec2(-.23,.13), .001,.075);//kecil atas\n        c -= Triangle1(uv- vec2(.23,.13), .001,.075);\n        c -= Triangle1(uv- vec2(.0,.35), .001,.075);\n        //b += Triangle(uv- vec2(.0,.2), .001,.075);\n        //=============================================\n        c -= Triangle(uv- vec2(-.788,-.36), .001,.055);\n        c -= Triangle(uv- vec2(-.568,-.36), .001,.055);\n        c -= Triangle(uv- vec2(-.675,-.245), .001,.055);\n        c -= Triangle(uv- vec2(-.225,-.245), .001,.055);\n        c -= Triangle(uv- vec2(-.337,-.36), .001,.055);\n        c -= Triangle(uv- vec2(-.12,-.36), .001,.055);\n        c -= Triangle(uv- vec2(.12,-.36), .001,.055);\n        c -= Triangle(uv- vec2(.788,-.36), .001,.055);\n        c -= Triangle(uv- vec2(.568,-.36), .001,.055);\n        c -= Triangle(uv- vec2(.675,-.245), .001,.055);\n        c -= Triangle(uv- vec2(.225,-.245), .001,.055);\n        c -= Triangle(uv- vec2(.337,-.36), .001,.055);\n        c -= Triangle(uv- vec2(-.563,-.135), .001,.055);\n        c -= Triangle(uv- vec2(-.335,-.135), .001,.055);\n        c -= Triangle(uv- vec2(-.45,-.02), .001,.055);\n        c -= Triangle(uv- vec2(.563,-.135), .001,.055);\n        c -= Triangle(uv- vec2(.335,-.135), .001,.055);\n        c -= Triangle(uv- vec2(.45,-.02), .001,.055);\n        c -= Triangle(uv- vec2(.225,.208), .001,.055);\n        c -= Triangle(uv- vec2(.118,.095), .001,.055);\n        c -= Triangle(uv- vec2(.335,.095), .001,.055);\n        c -= Triangle(uv- vec2(-.225,.208), .001,.055);\n        c -= Triangle(uv- vec2(-.118,.095), .001,.055);\n        c -= Triangle(uv- vec2(-.335,.095), .001,.055);\n        c -= Triangle(uv- vec2(.115,.315), .001,.055);\n    \tc -= Triangle(uv- vec2(-.115,.315), .001,.055);\n    \tc -= Triangle(uv- vec2(.0,.425), .001,.055);\n    \t//============================================\n    }\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    uv -= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float c = skerpski(uv, 4);//panggil fungsinya\n    //col = vec3(0.,0.,1.)*c;\n    col = vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*c;\n    //col += vec3(1.,0.,0.)*b;\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdX3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 205], [207, 207, 296, 296, 404], [406, 406, 457, 457, 558], [560, 560, 612, 612, 717], [719, 719, 753, 753, 5784], [5786, 5786, 5841, 5841, 6180]]}
{"id": "WdX3zl", "name": "gltf loader", "author": "changjiu", "description": "this program can render any geometry,but you need a tool to convert gltf or stl file to my struct Triangle.Have fun!\nthe deepTest is closed. ", "tags": ["gltf"], "likes": 0, "viewed": 340, "published": "Public API", "date": "1547136584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * @author changjiu\n * @date 2019.1.9\n * @contact  drift bottle\n**/\n\n/*\n * @作者 长久兄\n * @日期 2019.1.9\n * @联系方式 漂流瓶\n**/\n\n#define triangleCount 364\n\nstruct Triangle\n{\n    \n    vec3 a; //pointA\n    vec3 b;\t//pointB\n    vec3 c;\t//pointC\n    vec3 n; //normal\n\n};\n\nTriangle triangles[triangleCount];\n\nvoid getOneCube( void )\n{ \n\ntriangles[0].a = vec3(0.5,0.5,0.5);\ntriangles[0].b = vec3(0.5,-0.5,0.5);\ntriangles[0].c = vec3(0.5,0.5,-0.5);\ntriangles[0].n = vec3(1,0,0);\ntriangles[1].a = vec3(0.5,-0.5,0.5);\ntriangles[1].b = vec3(0.5,-0.5,-0.5);\ntriangles[1].c = vec3(0.5,0.5,-0.5);\ntriangles[1].n = vec3(1,0,0);\ntriangles[2].a = vec3(-0.5,0.5,-0.5);\ntriangles[2].b = vec3(-0.5,-0.5,-0.5);\ntriangles[2].c = vec3(-0.5,0.5,0.5);\ntriangles[2].n = vec3(-1,0,0);\ntriangles[3].a = vec3(-0.5,-0.5,-0.5);\ntriangles[3].b = vec3(-0.5,-0.5,0.5);\ntriangles[3].c = vec3(-0.5,0.5,0.5);\ntriangles[3].n = vec3(-1,0,0);\ntriangles[4].a = vec3(-0.5,0.5,-0.5);\ntriangles[4].b = vec3(-0.5,0.5,0.5);\ntriangles[4].c = vec3(0.5,0.5,-0.5);\ntriangles[4].n = vec3(0,1,0);\ntriangles[5].a = vec3(-0.5,0.5,0.5);\ntriangles[5].b = vec3(0.5,0.5,0.5);\ntriangles[5].c = vec3(0.5,0.5,-0.5);\ntriangles[5].n = vec3(0,1,0);\ntriangles[6].a = vec3(-0.5,-0.5,0.5);\ntriangles[6].b = vec3(-0.5,-0.5,-0.5);\ntriangles[6].c = vec3(0.5,-0.5,0.5);\ntriangles[6].n = vec3(0,-1,0);\ntriangles[7].a = vec3(-0.5,-0.5,-0.5);\ntriangles[7].b = vec3(0.5,-0.5,-0.5);\ntriangles[7].c = vec3(0.5,-0.5,0.5);\ntriangles[7].n = vec3(0,-1,0);\ntriangles[8].a = vec3(-0.5,0.5,0.5);\ntriangles[8].b = vec3(-0.5,-0.5,0.5);\ntriangles[8].c = vec3(0.5,0.5,0.5);\ntriangles[8].n = vec3(0,0,1);\ntriangles[9].a = vec3(-0.5,-0.5,0.5);\ntriangles[9].b = vec3(0.5,-0.5,0.5);\ntriangles[9].c = vec3(0.5,0.5,0.5);\ntriangles[9].n = vec3(0,0,1);\ntriangles[10].a = vec3(0.5,0.5,-0.5);\ntriangles[10].b = vec3(0.5,-0.5,-0.5);\ntriangles[10].c = vec3(-0.5,0.5,-0.5);\ntriangles[10].n = vec3(0,0,-1);\ntriangles[11].a = vec3(0.5,-0.5,-0.5);\ntriangles[11].b = vec3(-0.5,-0.5,-0.5);\ntriangles[11].c = vec3(-0.5,0.5,-0.5);\ntriangles[11].n = vec3(0,0,-1);\ntriangles[12].a = vec3(2.0112340123850636,0.5,1);\ntriangles[12].b = vec3(2.0112340123850636,-0.5,1);\ntriangles[12].c = vec3(2.718340781469994,0.5,0.7071067690849304);\ntriangles[12].n = vec3(0.38268345145128857,0,0.9238795246055241);\ntriangles[13].a = vec3(2.0112340123850636,-0.5,1);\ntriangles[13].b = vec3(2.718340781469994,-0.5,0.7071067690849304);\ntriangles[13].c = vec3(2.718340781469994,0.5,0.7071067690849304);\ntriangles[13].n = vec3(0.38268345145128857,0,0.9238795246055241);\ntriangles[14].a = vec3(2.718340781469994,0.5,0.7071067690849304);\ntriangles[14].b = vec3(2.718340781469994,-0.5,0.7071067690849304);\ntriangles[14].c = vec3(3.0112340123850636,0.5,6.123234262925839e-17);\ntriangles[14].n = vec3(0.9238795246055241,0,0.3826834514512886);\ntriangles[15].a = vec3(2.718340781469994,-0.5,0.7071067690849304);\ntriangles[15].b = vec3(3.0112340123850636,-0.5,6.123234262925839e-17);\ntriangles[15].c = vec3(3.0112340123850636,0.5,6.123234262925839e-17);\ntriangles[15].n = vec3(0.9238795246055241,0,0.3826834514512886);\ntriangles[16].a = vec3(3.0112340123850636,0.5,6.123234262925839e-17);\ntriangles[16].b = vec3(3.0112340123850636,-0.5,6.123234262925839e-17);\ntriangles[16].c = vec3(2.718340781469994,0.5,-0.7071067690849304);\ntriangles[16].n = vec3(0.9238795246055241,0,-0.3826834514512885);\ntriangles[17].a = vec3(3.0112340123850636,-0.5,6.123234262925839e-17);\ntriangles[17].b = vec3(2.718340781469994,-0.5,-0.7071067690849304);\ntriangles[17].c = vec3(2.718340781469994,0.5,-0.7071067690849304);\ntriangles[17].n = vec3(0.9238795246055241,0,-0.3826834514512885);\ntriangles[18].a = vec3(2.718340781469994,0.5,-0.7071067690849304);\ntriangles[18].b = vec3(2.718340781469994,-0.5,-0.7071067690849304);\ntriangles[18].c = vec3(2.0112340123850636,0.5,-1);\ntriangles[18].n = vec3(0.3826834514512886,0,-0.9238795246055241);\ntriangles[19].a = vec3(2.718340781469994,-0.5,-0.7071067690849304);\ntriangles[19].b = vec3(2.0112340123850636,-0.5,-1);\ntriangles[19].c = vec3(2.0112340123850636,0.5,-1);\ntriangles[19].n = vec3(0.3826834514512886,0,-0.9238795246055241);\ntriangles[20].a = vec3(2.0112340123850636,0.5,-1);\ntriangles[20].b = vec3(2.0112340123850636,-0.5,-1);\ntriangles[20].c = vec3(1.3041272433001332,0.5,-0.7071067690849304);\ntriangles[20].n = vec3(-0.3826834514512885,0,-0.9238795246055241);\ntriangles[21].a = vec3(2.0112340123850636,-0.5,-1);\ntriangles[21].b = vec3(1.3041272433001332,-0.5,-0.7071067690849304);\ntriangles[21].c = vec3(1.3041272433001332,0.5,-0.7071067690849304);\ntriangles[21].n = vec3(-0.3826834514512885,0,-0.9238795246055241);\ntriangles[22].a = vec3(1.3041272433001332,0.5,-0.7071067690849304);\ntriangles[22].b = vec3(1.3041272433001332,-0.5,-0.7071067690849304);\ntriangles[22].c = vec3(1.0112340123850636,0.5,-1.8369701465288538e-16);\ntriangles[22].n = vec3(-0.9238795246055241,0,-0.3826834514512887);\ntriangles[23].a = vec3(1.3041272433001332,-0.5,-0.7071067690849304);\ntriangles[23].b = vec3(1.0112340123850636,-0.5,-1.8369701465288538e-16);\ntriangles[23].c = vec3(1.0112340123850636,0.5,-1.8369701465288538e-16);\ntriangles[23].n = vec3(-0.9238795246055241,0,-0.3826834514512887);\ntriangles[24].a = vec3(1.0112340123850636,0.5,-1.8369701465288538e-16);\ntriangles[24].b = vec3(1.0112340123850636,-0.5,-1.8369701465288538e-16);\ntriangles[24].c = vec3(1.3041272433001332,0.5,0.7071067690849304);\ntriangles[24].n = vec3(-0.9238795246055241,0,0.38268345145128846);\ntriangles[25].a = vec3(1.0112340123850636,-0.5,-1.8369701465288538e-16);\ntriangles[25].b = vec3(1.3041272433001332,-0.5,0.7071067690849304);\ntriangles[25].c = vec3(1.3041272433001332,0.5,0.7071067690849304);\ntriangles[25].n = vec3(-0.9238795246055241,0,0.38268345145128846);\ntriangles[26].a = vec3(1.3041272433001332,0.5,0.7071067690849304);\ntriangles[26].b = vec3(1.3041272433001332,-0.5,0.7071067690849304);\ntriangles[26].c = vec3(2.011234012385063,0.5,1);\ntriangles[26].n = vec3(-0.3826834514512887,0,0.9238795246055241);\ntriangles[27].a = vec3(1.3041272433001332,-0.5,0.7071067690849304);\ntriangles[27].b = vec3(2.011234012385063,-0.5,1);\ntriangles[27].c = vec3(2.011234012385063,0.5,1);\ntriangles[27].n = vec3(-0.3826834514512887,0,0.9238795246055241);\ntriangles[28].a = vec3(2.0112340123850636,0.5,1);\ntriangles[28].b = vec3(2.718340781469994,0.5,0.7071067690849304);\ntriangles[28].c = vec3(2.0112340123850636,0.5,0);\ntriangles[28].n = vec3(0,1,0);\ntriangles[29].a = vec3(2.718340781469994,0.5,0.7071067690849304);\ntriangles[29].b = vec3(3.0112340123850636,0.5,6.123234262925839e-17);\ntriangles[29].c = vec3(2.0112340123850636,0.5,0);\ntriangles[29].n = vec3(0,1,0);\ntriangles[30].a = vec3(3.0112340123850636,0.5,6.123234262925839e-17);\ntriangles[30].b = vec3(2.718340781469994,0.5,-0.7071067690849304);\ntriangles[30].c = vec3(2.0112340123850636,0.5,0);\ntriangles[30].n = vec3(0,1,0);\ntriangles[31].a = vec3(2.718340781469994,0.5,-0.7071067690849304);\ntriangles[31].b = vec3(2.0112340123850636,0.5,-1);\ntriangles[31].c = vec3(2.0112340123850636,0.5,0);\ntriangles[31].n = vec3(0,1,0);\ntriangles[32].a = vec3(2.0112340123850636,0.5,-1);\ntriangles[32].b = vec3(1.3041272433001332,0.5,-0.7071067690849304);\ntriangles[32].c = vec3(2.0112340123850636,0.5,0);\ntriangles[32].n = vec3(0,1,0);\ntriangles[33].a = vec3(1.3041272433001332,0.5,-0.7071067690849304);\ntriangles[33].b = vec3(1.0112340123850636,0.5,-1.8369701465288538e-16);\ntriangles[33].c = vec3(2.0112340123850636,0.5,0);\ntriangles[33].n = vec3(0,1,0);\ntriangles[34].a = vec3(1.0112340123850636,0.5,-1.8369701465288538e-16);\ntriangles[34].b = vec3(1.3041272433001332,0.5,0.7071067690849304);\ntriangles[34].c = vec3(2.0112340123850636,0.5,0);\ntriangles[34].n = vec3(0,1,0);\ntriangles[35].a = vec3(1.3041272433001332,0.5,0.7071067690849304);\ntriangles[35].b = vec3(2.011234012385063,0.5,1);\ntriangles[35].c = vec3(2.0112340123850636,0.5,0);\ntriangles[35].n = vec3(0,1,0);\ntriangles[36].a = vec3(2.718340781469994,-0.5,0.7071067690849304);\ntriangles[36].b = vec3(2.0112340123850636,-0.5,1);\ntriangles[36].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[36].n = vec3(0,-1,0);\ntriangles[37].a = vec3(3.0112340123850636,-0.5,6.123234262925839e-17);\ntriangles[37].b = vec3(2.718340781469994,-0.5,0.7071067690849304);\ntriangles[37].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[37].n = vec3(0,-1,0);\ntriangles[38].a = vec3(2.718340781469994,-0.5,-0.7071067690849304);\ntriangles[38].b = vec3(3.0112340123850636,-0.5,6.123234262925839e-17);\ntriangles[38].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[38].n = vec3(0,-1,0);\ntriangles[39].a = vec3(2.0112340123850636,-0.5,-1);\ntriangles[39].b = vec3(2.718340781469994,-0.5,-0.7071067690849304);\ntriangles[39].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[39].n = vec3(0,-1,0);\ntriangles[40].a = vec3(1.3041272433001332,-0.5,-0.7071067690849304);\ntriangles[40].b = vec3(2.0112340123850636,-0.5,-1);\ntriangles[40].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[40].n = vec3(0,-1,0);\ntriangles[41].a = vec3(1.0112340123850636,-0.5,-1.8369701465288538e-16);\ntriangles[41].b = vec3(1.3041272433001332,-0.5,-0.7071067690849304);\ntriangles[41].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[41].n = vec3(0,-1,0);\ntriangles[42].a = vec3(1.3041272433001332,-0.5,0.7071067690849304);\ntriangles[42].b = vec3(1.0112340123850636,-0.5,-1.8369701465288538e-16);\ntriangles[42].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[42].n = vec3(0,-1,0);\ntriangles[43].a = vec3(2.011234012385063,-0.5,1);\ntriangles[43].b = vec3(1.3041272433001332,-0.5,0.7071067690849304);\ntriangles[43].c = vec3(2.0112340123850636,-0.5,0);\ntriangles[43].n = vec3(0,-1,0);\ntriangles[44].a = vec3(-1.6999586268479536,1,0);\ntriangles[44].b = vec3(-2.1999586268479536,0.8660253882408142,0);\ntriangles[44].c = vec3(-2.053512011390419,0.8660253882408142,0.3535533845424652);\ntriangles[44].n = vec3(-0.25734444158454267,0.9604224196115209,0.10659556413421618);\ntriangles[45].a = vec3(-1.6999586268479536,1,0);\ntriangles[45].b = vec3(-2.053512011390419,0.8660253882408142,0.3535533845424652);\ntriangles[45].c = vec3(-1.6999586268479536,0.8660253882408142,0.5);\ntriangles[45].n = vec3(-0.10659556413421618,0.9604224196115209,0.2573444415845426);\ntriangles[46].a = vec3(-1.6999586268479536,1,0);\ntriangles[46].b = vec3(-1.6999586268479536,0.8660253882408142,0.5);\ntriangles[46].c = vec3(-1.3464052423054884,0.8660253882408142,0.3535533845424652);\ntriangles[46].n = vec3(0.10659556413421617,0.9604224196115209,0.25734444158454267);\ntriangles[47].a = vec3(-1.6999586268479536,1,0);\ntriangles[47].b = vec3(-1.3464052423054884,0.8660253882408142,0.3535533845424652);\ntriangles[47].c = vec3(-1.1999586268479536,0.8660253882408142,6.123234262925839e-17);\ntriangles[47].n = vec3(0.2573444415845426,0.9604224196115209,0.10659556413421618);\ntriangles[48].a = vec3(-1.6999586268479536,1,0);\ntriangles[48].b = vec3(-1.1999586268479536,0.8660253882408142,6.123234262925839e-17);\ntriangles[48].c = vec3(-1.3464052423054884,0.8660253882408142,-0.3535533845424652);\ntriangles[48].n = vec3(0.25734444158454267,0.9604224196115209,-0.10659556413421617);\ntriangles[49].a = vec3(-1.6999586268479536,1,0);\ntriangles[49].b = vec3(-1.3464052423054884,0.8660253882408142,-0.3535533845424652);\ntriangles[49].c = vec3(-1.6999586268479536,0.8660253882408142,-0.5);\ntriangles[49].n = vec3(0.10659556413421621,0.9604224196115209,-0.25734444158454267);\ntriangles[50].a = vec3(-1.6999586268479536,1,0);\ntriangles[50].b = vec3(-1.6999586268479536,0.8660253882408142,-0.5);\ntriangles[50].c = vec3(-2.053512011390419,0.8660253882408142,-0.3535533845424652);\ntriangles[50].n = vec3(-0.10659556413421614,0.9604224196115209,-0.25734444158454267);\ntriangles[51].a = vec3(-1.6999586268479536,1,0);\ntriangles[51].b = vec3(-2.053512011390419,0.8660253882408142,-0.3535533845424652);\ntriangles[51].c = vec3(-2.1999586268479536,0.8660253882408142,-1.2246468525851679e-16);\ntriangles[51].n = vec3(-0.25734444158454267,0.9604224196115209,-0.10659556413421621);\ntriangles[52].a = vec3(-2.053512011390419,0.8660253882408142,0.3535533845424652);\ntriangles[52].b = vec3(-2.1999586268479536,0.8660253882408142,0);\ntriangles[52].c = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[52].n = vec3(-0.678598288582369,0.6785984033079782,0.28108463095826225);\ntriangles[53].a = vec3(-2.1999586268479536,0.8660253882408142,0);\ntriangles[53].b = vec3(-2.565984015088768,0.5,0);\ntriangles[53].c = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[53].n = vec3(-0.6785983544929652,0.6785983544929652,0.2810845896858807);\ntriangles[54].a = vec3(-1.6999586268479536,0.8660253882408142,0.5);\ntriangles[54].b = vec3(-2.053512011390419,0.8660253882408142,0.3535533845424652);\ntriangles[54].c = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[54].n = vec3(-0.28108465284143663,0.6785983414130221,0.6785983414130221);\ntriangles[55].a = vec3(-2.053512011390419,0.8660253882408142,0.3535533845424652);\ntriangles[55].b = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[55].c = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[55].n = vec3(-0.281084577051627,0.6785983902280341,0.6785983239911729);\ntriangles[56].a = vec3(-1.3464052423054884,0.8660253882408142,0.3535533845424652);\ntriangles[56].b = vec3(-1.6999586268479536,0.8660253882408142,0.5);\ntriangles[56].c = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[56].n = vec3(0.28108463095826225,0.6785984033079782,0.6785982885823691);\ntriangles[57].a = vec3(-1.6999586268479536,0.8660253882408142,0.5);\ntriangles[57].b = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[57].c = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[57].n = vec3(0.2810845896858807,0.6785983544929652,0.6785983544929652);\ntriangles[58].a = vec3(-1.1999586268479536,0.8660253882408142,6.123234262925839e-17);\ntriangles[58].b = vec3(-1.3464052423054884,0.8660253882408142,0.3535533845424652);\ntriangles[58].c = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[58].n = vec3(0.678598341413022,0.6785983414130222,0.2810846528414366);\ntriangles[59].a = vec3(-1.3464052423054884,0.8660253882408142,0.3535533845424652);\ntriangles[59].b = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[59].c = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[59].n = vec3(0.6785983239911728,0.678598390228034,0.281084577051627);\ntriangles[60].a = vec3(-1.3464052423054884,0.8660253882408142,-0.3535533845424652);\ntriangles[60].b = vec3(-1.1999586268479536,0.8660253882408142,6.123234262925839e-17);\ntriangles[60].c = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[60].n = vec3(0.678598288582369,0.6785984033079782,-0.2810846309582622);\ntriangles[61].a = vec3(-1.1999586268479536,0.8660253882408142,6.123234262925839e-17);\ntriangles[61].b = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[61].c = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[61].n = vec3(0.6785983544929652,0.6785983544929652,-0.2810845896858807);\ntriangles[62].a = vec3(-1.6999586268479536,0.8660253882408142,-0.5);\ntriangles[62].b = vec3(-1.3464052423054884,0.8660253882408142,-0.3535533845424652);\ntriangles[62].c = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[62].n = vec3(0.28108465284143663,0.6785983414130221,-0.6785983414130221);\ntriangles[63].a = vec3(-1.3464052423054884,0.8660253882408142,-0.3535533845424652);\ntriangles[63].b = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[63].c = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[63].n = vec3(0.28108457705162704,0.6785983902280341,-0.6785983239911729);\ntriangles[64].a = vec3(-2.053512011390419,0.8660253882408142,-0.3535533845424652);\ntriangles[64].b = vec3(-1.6999586268479536,0.8660253882408142,-0.5);\ntriangles[64].c = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[64].n = vec3(-0.2810846309582622,0.6785984033079782,-0.678598288582369);\ntriangles[65].a = vec3(-1.6999586268479536,0.8660253882408142,-0.5);\ntriangles[65].b = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[65].c = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[65].n = vec3(-0.2810845896858807,0.6785983544929652,-0.6785983544929652);\ntriangles[66].a = vec3(-2.1999586268479536,0.8660253882408142,-1.2246468525851679e-16);\ntriangles[66].b = vec3(-2.053512011390419,0.8660253882408142,-0.3535533845424652);\ntriangles[66].c = vec3(-2.565984015088768,0.5,-2.1211504944260596e-16);\ntriangles[66].n = vec3(-0.6785983414130221,0.6785983414130221,-0.28108465284143663);\ntriangles[67].a = vec3(-2.053512011390419,0.8660253882408142,-0.3535533845424652);\ntriangles[67].b = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[67].c = vec3(-2.565984015088768,0.5,-2.1211504944260596e-16);\ntriangles[67].n = vec3(-0.6785983239911728,0.6785983902280341,-0.28108457705162704);\ntriangles[68].a = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[68].b = vec3(-2.565984015088768,0.5,0);\ntriangles[68].c = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[68].n = vec3(-0.8968088623149036,0.24029911014003327,0.37147032470892816);\ntriangles[69].a = vec3(-2.565984015088768,0.5,0);\ntriangles[69].b = vec3(-2.6999586268479536,6.123234262925839e-17,0);\ntriangles[69].c = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[69].n = vec3(-0.8968088045054851,0.24029922281168387,0.3714703913874474);\ntriangles[70].a = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[70].b = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[70].c = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[70].n = vec3(-0.3714703132687065,0.24029923090114474,0.8968088346957603);\ntriangles[71].a = vec3(-2.3123310848290632,0.5,0.6123724579811096);\ntriangles[71].b = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[71].c = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[71].n = vec3(-0.3714704012949723,0.24029911822949174,0.8968088284243644);\ntriangles[72].a = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[72].b = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[72].c = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[72].n = vec3(0.37147032470892816,0.24029911014003327,0.8968088623149036);\ntriangles[73].a = vec3(-1.6999586268479536,0.5,0.8660253882408142);\ntriangles[73].b = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[73].c = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[73].n = vec3(0.3714703913874474,0.2402992228116839,0.8968088045054853);\ntriangles[74].a = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[74].b = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[74].c = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[74].n = vec3(0.8968088346957602,0.2402992309011446,0.37147031326870655);\ntriangles[75].a = vec3(-1.087586168866844,0.5,0.6123724579811096);\ntriangles[75].b = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[75].c = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[75].n = vec3(0.8968088284243644,0.24029911822949174,0.3714704012949723);\ntriangles[76].a = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[76].b = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[76].c = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[76].n = vec3(0.8968088623149036,0.24029911014003327,-0.3714703247089281);\ntriangles[77].a = vec3(-0.8339332386071394,0.5,1.0605752472130298e-16);\ntriangles[77].b = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[77].c = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[77].n = vec3(0.8968088045054853,0.2402992228116839,-0.3714703913874474);\ntriangles[78].a = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[78].b = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[78].c = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[78].n = vec3(0.37147031326870655,0.2402992309011447,-0.8968088346957602);\ntriangles[79].a = vec3(-1.087586168866844,0.5,-0.6123724579811096);\ntriangles[79].b = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[79].c = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[79].n = vec3(0.37147040129497233,0.24029911822949176,-0.8968088284243645);\ntriangles[80].a = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[80].b = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[80].c = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[80].n = vec3(-0.3714703247089281,0.24029911014003327,-0.8968088623149036);\ntriangles[81].a = vec3(-1.6999586268479534,0.5,-0.8660253882408142);\ntriangles[81].b = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[81].c = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[81].n = vec3(-0.37147039138744736,0.24029922281168387,-0.8968088045054853);\ntriangles[82].a = vec3(-2.565984015088768,0.5,-2.1211504944260596e-16);\ntriangles[82].b = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[82].c = vec3(-2.6999586268479536,6.123234262925839e-17,-2.4492937051703357e-16);\ntriangles[82].n = vec3(-0.8968088346957602,0.24029923090114466,-0.3714703132687066);\ntriangles[83].a = vec3(-2.3123310848290632,0.5,-0.6123724579811096);\ntriangles[83].b = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[83].c = vec3(-2.6999586268479536,6.123234262925839e-17,-2.4492937051703357e-16);\ntriangles[83].n = vec3(-0.8968088284243645,0.24029911822949176,-0.37147040129497233);\ntriangles[84].a = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[84].b = vec3(-2.6999586268479536,6.123234262925839e-17,0);\ntriangles[84].c = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[84].n = vec3(-0.8968088284243646,-0.2402991182294917,0.3714704012949723);\ntriangles[85].a = vec3(-2.6999586268479536,6.123234262925839e-17,0);\ntriangles[85].b = vec3(-2.565984015088768,-0.5,0);\ntriangles[85].c = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[85].n = vec3(-0.8968088346957602,-0.24029923090114458,0.37147031326870655);\ntriangles[86].a = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[86].b = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[86].c = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[86].n = vec3(-0.37147039138744753,-0.24029922281168384,0.8968088045054851);\ntriangles[87].a = vec3(-2.407065395932884,6.123234262925839e-17,0.7071067690849304);\ntriangles[87].b = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[87].c = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[87].n = vec3(-0.3714703247089282,-0.24029911014003322,0.8968088623149038);\ntriangles[88].a = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[88].b = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[88].c = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[88].n = vec3(0.3714704012949722,-0.24029911822949174,0.8968088284243646);\ntriangles[89].a = vec3(-1.6999586268479536,6.123234262925839e-17,1);\ntriangles[89].b = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[89].c = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[89].n = vec3(0.37147031326870655,-0.24029923090114458,0.8968088346957602);\ntriangles[90].a = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[90].b = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[90].c = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[90].n = vec3(0.8968088045054853,-0.24029922281168384,0.3714703913874476);\ntriangles[91].a = vec3(-0.9928518577630232,6.123234262925839e-17,0.7071067690849304);\ntriangles[91].b = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[91].c = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[91].n = vec3(0.8968088623149036,-0.24029911014003316,0.3714703247089282);\ntriangles[92].a = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[92].b = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[92].c = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[92].n = vec3(0.8968088284243646,-0.24029911822949174,-0.3714704012949722);\ntriangles[93].a = vec3(-0.6999586268479536,6.123234262925839e-17,1.2246468525851679e-16);\ntriangles[93].b = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[93].c = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[93].n = vec3(0.8968088346957603,-0.24029923090114458,-0.3714703132687065);\ntriangles[94].a = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[94].b = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[94].c = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[94].n = vec3(0.3714703913874476,-0.2402992228116839,-0.8968088045054851);\ntriangles[95].a = vec3(-0.9928518577630232,6.123234262925839e-17,-0.7071067690849304);\ntriangles[95].b = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[95].c = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[95].n = vec3(0.37147032470892827,-0.2402991101400332,-0.8968088623149036);\ntriangles[96].a = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[96].b = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[96].c = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[96].n = vec3(-0.37147040129497216,-0.24029911822949174,-0.8968088284243645);\ntriangles[97].a = vec3(-1.6999586268479534,6.123234262925839e-17,-1);\ntriangles[97].b = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[97].c = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[97].n = vec3(-0.3714703132687065,-0.24029923090114458,-0.8968088346957603);\ntriangles[98].a = vec3(-2.6999586268479536,6.123234262925839e-17,-2.4492937051703357e-16);\ntriangles[98].b = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[98].c = vec3(-2.565984015088768,-0.5,-2.1211504944260596e-16);\ntriangles[98].n = vec3(-0.8968088045054851,-0.2402992228116838,-0.3714703913874476);\ntriangles[99].a = vec3(-2.407065395932884,6.123234262925839e-17,-0.7071067690849304);\ntriangles[99].b = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[99].c = vec3(-2.565984015088768,-0.5,-2.1211504944260596e-16);\ntriangles[99].n = vec3(-0.8968088623149035,-0.24029911014003313,-0.37147032470892827);\ntriangles[100].a = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[100].b = vec3(-2.565984015088768,-0.5,0);\ntriangles[100].c = vec3(-2.053512011390419,-0.8660253882408142,0.3535533845424652);\ntriangles[100].n = vec3(-0.6785983239911728,-0.678598390228034,0.2810845770516269);\ntriangles[101].a = vec3(-2.565984015088768,-0.5,0);\ntriangles[101].b = vec3(-2.1999586268479536,-0.8660253882408142,0);\ntriangles[101].c = vec3(-2.053512011390419,-0.8660253882408142,0.3535533845424652);\ntriangles[101].n = vec3(-0.6785983414130222,-0.6785983414130222,0.2810846528414366);\ntriangles[102].a = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[102].b = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[102].c = vec3(-1.6999586268479536,-0.8660253882408142,0.5);\ntriangles[102].n = vec3(-0.2810845896858807,-0.6785983544929652,0.6785983544929652);\ntriangles[103].a = vec3(-2.3123310848290632,-0.5,0.6123724579811096);\ntriangles[103].b = vec3(-2.053512011390419,-0.8660253882408142,0.3535533845424652);\ntriangles[103].c = vec3(-1.6999586268479536,-0.8660253882408142,0.5);\ntriangles[103].n = vec3(-0.2810846309582623,-0.6785984033079783,0.6785982885823689);\ntriangles[104].a = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[104].b = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[104].c = vec3(-1.3464052423054884,-0.8660253882408142,0.3535533845424652);\ntriangles[104].n = vec3(0.281084577051627,-0.6785983902280341,0.6785983239911729);\ntriangles[105].a = vec3(-1.6999586268479536,-0.5,0.8660253882408142);\ntriangles[105].b = vec3(-1.6999586268479536,-0.8660253882408142,0.5);\ntriangles[105].c = vec3(-1.3464052423054884,-0.8660253882408142,0.3535533845424652);\ntriangles[105].n = vec3(0.2810846528414366,-0.6785983414130222,0.6785983414130222);\ntriangles[106].a = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[106].b = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[106].c = vec3(-1.1999586268479536,-0.8660253882408142,6.123234262925839e-17);\ntriangles[106].n = vec3(0.6785983544929652,-0.6785983544929651,0.2810845896858807);\ntriangles[107].a = vec3(-1.087586168866844,-0.5,0.6123724579811096);\ntriangles[107].b = vec3(-1.3464052423054884,-0.8660253882408142,0.3535533845424652);\ntriangles[107].c = vec3(-1.1999586268479536,-0.8660253882408142,6.123234262925839e-17);\ntriangles[107].n = vec3(0.6785982885823689,-0.6785984033079783,0.2810846309582623);\ntriangles[108].a = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[108].b = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[108].c = vec3(-1.3464052423054884,-0.8660253882408142,-0.3535533845424652);\ntriangles[108].n = vec3(0.6785983239911729,-0.6785983902280341,-0.2810845770516269);\ntriangles[109].a = vec3(-0.8339332386071394,-0.5,1.0605752472130298e-16);\ntriangles[109].b = vec3(-1.1999586268479536,-0.8660253882408142,6.123234262925839e-17);\ntriangles[109].c = vec3(-1.3464052423054884,-0.8660253882408142,-0.3535533845424652);\ntriangles[109].n = vec3(0.6785983414130222,-0.6785983414130222,-0.2810846528414366);\ntriangles[110].a = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[110].b = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[110].c = vec3(-1.6999586268479536,-0.8660253882408142,-0.5);\ntriangles[110].n = vec3(0.2810845896858807,-0.6785983544929651,-0.6785983544929652);\ntriangles[111].a = vec3(-1.087586168866844,-0.5,-0.6123724579811096);\ntriangles[111].b = vec3(-1.3464052423054884,-0.8660253882408142,-0.3535533845424652);\ntriangles[111].c = vec3(-1.6999586268479536,-0.8660253882408142,-0.5);\ntriangles[111].n = vec3(0.28108463095826236,-0.6785984033079782,-0.678598288582369);\ntriangles[112].a = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[112].b = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[112].c = vec3(-2.053512011390419,-0.8660253882408142,-0.3535533845424652);\ntriangles[112].n = vec3(-0.2810845770516269,-0.678598390228034,-0.6785983239911729);\ntriangles[113].a = vec3(-1.6999586268479534,-0.5,-0.8660253882408142);\ntriangles[113].b = vec3(-1.6999586268479536,-0.8660253882408142,-0.5);\ntriangles[113].c = vec3(-2.053512011390419,-0.8660253882408142,-0.3535533845424652);\ntriangles[113].n = vec3(-0.2810846528414366,-0.6785983414130222,-0.6785983414130222);\ntriangles[114].a = vec3(-2.565984015088768,-0.5,-2.1211504944260596e-16);\ntriangles[114].b = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[114].c = vec3(-2.1999586268479536,-0.8660253882408142,-1.2246468525851679e-16);\ntriangles[114].n = vec3(-0.6785983544929651,-0.6785983544929652,-0.28108458968588074);\ntriangles[115].a = vec3(-2.3123310848290632,-0.5,-0.6123724579811096);\ntriangles[115].b = vec3(-2.053512011390419,-0.8660253882408142,-0.3535533845424652);\ntriangles[115].c = vec3(-2.1999586268479536,-0.8660253882408142,-1.2246468525851679e-16);\ntriangles[115].n = vec3(-0.678598288582369,-0.6785984033079782,-0.28108463095826236);\ntriangles[116].a = vec3(-2.053512011390419,-0.8660253882408142,0.3535533845424652);\ntriangles[116].b = vec3(-2.1999586268479536,-0.8660253882408142,0);\ntriangles[116].c = vec3(-1.6999586268479536,-1,8.659560603426554e-17);\ntriangles[116].n = vec3(-0.25734444158454267,-0.9604224196115208,0.10659556413421618);\ntriangles[117].a = vec3(-1.6999586268479536,-0.8660253882408142,0.5);\ntriangles[117].b = vec3(-2.053512011390419,-0.8660253882408142,0.3535533845424652);\ntriangles[117].c = vec3(-1.6999586268479536,-1,1.2246468525851679e-16);\ntriangles[117].n = vec3(-0.10659556413421621,-0.9604224196115209,0.2573444415845427);\ntriangles[118].a = vec3(-1.3464052423054884,-0.8660253882408142,0.3535533845424652);\ntriangles[118].b = vec3(-1.6999586268479536,-0.8660253882408142,0.5);\ntriangles[118].c = vec3(-1.6999586268479536,-1,8.659560603426554e-17);\ntriangles[118].n = vec3(0.10659556413421618,-0.9604224196115208,0.2573444415845427);\ntriangles[119].a = vec3(-1.1999586268479536,-0.8660253882408142,6.123234262925839e-17);\ntriangles[119].b = vec3(-1.3464052423054884,-0.8660253882408142,0.3535533845424652);\ntriangles[119].c = vec3(-1.6999586268479534,-1,1.4997597572211942e-32);\ntriangles[119].n = vec3(0.2573444415845427,-0.9604224196115209,0.10659556413421621);\ntriangles[120].a = vec3(-1.3464052423054884,-0.8660253882408142,-0.3535533845424652);\ntriangles[120].b = vec3(-1.1999586268479536,-0.8660253882408142,6.123234262925839e-17);\ntriangles[120].c = vec3(-1.6999586268479536,-1,-8.659560603426554e-17);\ntriangles[120].n = vec3(0.2573444415845427,-0.9604224196115208,-0.10659556413421618);\ntriangles[121].a = vec3(-1.6999586268479536,-0.8660253882408142,-0.5);\ntriangles[121].b = vec3(-1.3464052423054884,-0.8660253882408142,-0.3535533845424652);\ntriangles[121].c = vec3(-1.6999586268479536,-1,-1.2246468525851679e-16);\ntriangles[121].n = vec3(0.10659556413421621,-0.9604224196115208,-0.25734444158454267);\ntriangles[122].a = vec3(-2.053512011390419,-0.8660253882408142,-0.3535533845424652);\ntriangles[122].b = vec3(-1.6999586268479536,-0.8660253882408142,-0.5);\ntriangles[122].c = vec3(-1.6999586268479536,-1,-8.659560603426554e-17);\ntriangles[122].n = vec3(-0.10659556413421618,-0.9604224196115209,-0.2573444415845427);\ntriangles[123].a = vec3(-2.1999586268479536,-0.8660253882408142,-1.2246468525851679e-16);\ntriangles[123].b = vec3(-2.053512011390419,-0.8660253882408142,-0.3535533845424652);\ntriangles[123].c = vec3(-1.6999586268479538,-1,-2.9995195144423884e-32);\ntriangles[123].n = vec3(-0.25734444158454267,-0.9604224196115208,-0.10659556413421621);\ntriangles[124].a = vec3(0,0,-1.608873287647763);\ntriangles[124].b = vec3(0,0,-1.608873287647763);\ntriangles[124].c = vec3(0,0,-1.2088732816872985);\ntriangles[124].n = vec3(0,0,0);\ntriangles[125].a = vec3(0,0,-1.608873287647763);\ntriangles[125].b = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[125].c = vec3(0,0,-1.2088732816872985);\ntriangles[125].n = vec3(0,-1,0);\ntriangles[126].a = vec3(0,0,-1.2088732816872985);\ntriangles[126].b = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[126].c = vec3(0,0.05000000074505806,-1.2588732936082274);\ntriangles[126].n = vec3(0.1861568059727335,0.6947466658291958,0.6947465105412519);\ntriangles[127].a = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[127].b = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[127].c = vec3(0,0.05000000074505806,-1.2588732936082274);\ntriangles[127].n = vec3(0.18615676225458228,0.6947464765240478,0.694746711560632);\ntriangles[128].a = vec3(0,0.05000000074505806,-1.2588732936082274);\ntriangles[128].b = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[128].c = vec3(0,0.07500000298023224,-1.5088732861576468);\ntriangles[128].n = vec3(0.02665246460102649,0.9946837119922897,0.09946838305678318);\ntriangles[129].a = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[129].b = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[129].c = vec3(0,0.07500000298023224,-1.5088732861576468);\ntriangles[129].n = vec3(0.026652475969347913,0.9946837126589727,0.09946837334382061);\ntriangles[130].a = vec3(0,0.07500000298023224,-1.5088732861576468);\ntriangles[130].b = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[130].c = vec3(0,0.10000000149011612,-1.5288732894359023);\ntriangles[130].n = vec3(0.2047983263934887,0.6114542143578388,0.7643175971089926);\ntriangles[131].a = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[131].b = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[131].c = vec3(0,0.10000000149011612,-1.5288732894359023);\ntriangles[131].n = vec3(0.20479827134878148,0.6114541266869272,0.7643176819949138);\ntriangles[132].a = vec3(0,0.10000000149011612,-1.5288732894359023);\ntriangles[132].b = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[132].c = vec3(0,0.4000000059604645,-1.5288732894359023);\ntriangles[132].n = vec3(0.2588190046557119,0,0.9659258371267572);\ntriangles[133].a = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[133].b = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[133].c = vec3(0,0.4000000059604645,-1.5288732894359023);\ntriangles[133].n = vec3(0.2588190046557119,0,0.9659258371267572);\ntriangles[134].a = vec3(0,0.4000000059604645,-1.5288732894359023);\ntriangles[134].b = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[134].c = vec3(0,0.41999998688697815,-1.5088732861576468);\ntriangles[134].n = vec3(0.1861566573792735,-0.6947469963129355,0.6947462198727892);\ntriangles[135].a = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[135].b = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[135].c = vec3(0,0.41999998688697815,-1.5088732861576468);\ntriangles[135].n = vec3(0.18615674392784462,-0.6947469140085647,0.6947462789866233);\ntriangles[136].a = vec3(0,0.41999998688697815,-1.5088732861576468);\ntriangles[136].b = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[136].c = vec3(0,0.47999998927116394,-1.4688732870517165);\ntriangles[136].n = vec3(0.21760476422051833,-0.5414078754481196,0.8121118635947181);\ntriangles[137].a = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[137].b = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[137].c = vec3(0,0.47999998927116394,-1.4688732870517165);\ntriangles[137].n = vec3(0.21760469398880358,-0.5414079226921311,0.8121118509172431);\ntriangles[138].a = vec3(0,0.47999998927116394,-1.4688732870517165);\ntriangles[138].b = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[138].c = vec3(0,0.5,-1.4088732846675307);\ntriangles[138].n = vec3(0.08443045454765442,-0.9452958583114335,0.31509877594831565);\ntriangles[139].a = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[139].b = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[139].c = vec3(0,0.5,-1.4088732846675307);\ntriangles[139].n = vec3(0.08443048753847995,-0.9452958465833211,0.3150988022927684);\ntriangles[140].a = vec3(0,0.5,-1.4088732846675307);\ntriangles[140].b = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[140].c = vec3(0,0.5400000214576721,-1.358873287647763);\ntriangles[140].n = vec3(0.16508983978058117,-0.7701539647596221,0.6161235390457475);\ntriangles[141].a = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[141].b = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[141].c = vec3(0,0.5400000214576721,-1.358873287647763);\ntriangles[141].n = vec3(0.16508981925750674,-0.7701539829561646,0.6161235217992246);\ntriangles[142].a = vec3(0,0.5400000214576721,-1.358873287647763);\ntriangles[142].b = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[142].c = vec3(0,1.2000000476837158,-1.308873275726834);\ntriangles[142].n = vec3(0.2581288869512748,-0.0729810758058116,0.9633500092362706);\ntriangles[143].a = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[143].b = vec3(0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[143].c = vec3(0,1.2000000476837158,-1.308873275726834);\ntriangles[143].n = vec3(0.2581289490730858,-0.07298106206624695,0.9633499936316536);\ntriangles[144].a = vec3(0,0,-1.608873287647763);\ntriangles[144].b = vec3(0,0,-1.608873287647763);\ntriangles[144].c = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[144].n = vec3(0,0,0);\ntriangles[145].a = vec3(0,0,-1.608873287647763);\ntriangles[145].b = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[145].c = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[145].n = vec3(0,-1,0);\ntriangles[146].a = vec3(0.20000000298023224,0,-1.2624631323514373);\ntriangles[146].b = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[146].c = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[146].n = vec3(0.5085898412946055,0.6947465341143171,0.5085898412946055);\ntriangles[147].a = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[147].b = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[147].c = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[147].n = vec3(0.5085898412946056,0.6947465341143171,0.5085898412946056);\ntriangles[148].a = vec3(0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[148].b = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[148].c = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[148].n = vec3(0.07281590644320564,0.9946837123114607,0.07281590644320564);\ntriangles[149].a = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[149].b = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[149].c = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[149].n = vec3(0.07281590644320564,0.9946837123114608,0.07281590644320564);\ntriangles[150].a = vec3(0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[150].b = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[150].c = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[150].n = vec3(0.5595193547143101,0.6114541547819952,0.5595193547143101);\ntriangles[151].a = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[151].b = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[151].c = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[151].n = vec3(0.5595193547143101,0.6114541547819952,0.5595193547143101);\ntriangles[152].a = vec3(0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[152].b = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[152].c = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[152].n = vec3(0.7071067811865476,0,0.7071067811865476);\ntriangles[153].a = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[153].b = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[153].c = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[153].n = vec3(0.7071067811865476,0,0.7071067811865476);\ntriangles[154].a = vec3(0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[154].b = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[154].c = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[154].n = vec3(0.50858957005334,-0.6947469312389349,0.50858957005334);\ntriangles[155].a = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[155].b = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[155].c = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[155].n = vec3(0.50858957005334,-0.6947469312389349,0.50858957005334);\ntriangles[156].a = vec3(0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[156].b = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[156].c = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[156].n = vec3(0.5945071368148962,-0.5414079132708615,0.5945071368148962);\ntriangles[157].a = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[157].b = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[157].c = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[157].n = vec3(0.5945071368148962,-0.5414079132708615,0.5945071368148962);\ntriangles[158].a = vec3(0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[158].b = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[158].c = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[158].n = vec3(0.23066833202133558,-0.9452958485072226,0.23066833202133558);\ntriangles[159].a = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[159].b = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[159].c = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[159].n = vec3(0.23066833202133558,-0.9452958485072226,0.23066833202133558);\ntriangles[160].a = vec3(0.10000000149011612,0.5,-1.4356682099996);\ntriangles[160].b = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[160].c = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[160].n = vec3(0.451033729865809,-0.7701539774919512,0.451033729865809);\ntriangles[161].a = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[161].b = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[161].c = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[161].n = vec3(0.45103372986580903,-0.7701539774919514,0.45103372986580903);\ntriangles[162].a = vec3(0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[162].b = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[162].c = vec3(0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[162].n = vec3(0.7052211582950427,-0.07298106457154878,0.7052211582950427);\ntriangles[163].a = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[163].b = vec3(0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[163].c = vec3(0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[163].n = vec3(0.7052211582950427,-0.07298106457154879,0.7052211582950427);\ntriangles[164].a = vec3(0,0,-1.608873287647763);\ntriangles[164].b = vec3(0,0,-1.608873287647763);\ntriangles[164].c = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[164].n = vec3(0,0,0);\ntriangles[165].a = vec3(0,0,-1.608873287647763);\ntriangles[165].b = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[165].c = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[165].n = vec3(0,-1,0);\ntriangles[166].a = vec3(0.3464101552963257,0,-1.4088732846675307);\ntriangles[166].b = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[166].c = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[166].n = vec3(0.6947466753903974,0.6947464891444054,0.18615685014393832);\ntriangles[167].a = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[167].b = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[167].c = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[167].n = vec3(0.6947465231615894,0.694746678449536,0.1861567117732267);\ntriangles[168].a = vec3(0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[168].b = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[168].c = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[168].n = vec3(0.09946838029223301,0.9946837122885933,0.02665246386026774);\ntriangles[169].a = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[169].b = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[169].c = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[169].n = vec3(0.09946838301974524,0.9946837116219103,0.02665247856200466);\ntriangles[170].a = vec3(0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[170].b = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[170].c = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[170].n = vec3(0.7643176552765137,0.6114541364281443,0.20479834197943236);\ntriangles[171].a = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[171].b = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[171].c = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[171].n = vec3(0.7643176092855057,0.6114542240990516,0.2047982518663576);\ntriangles[172].a = vec3(0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[172].b = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[172].c = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[172].n = vec3(0.9659258371267572,0,0.25881900465571195);\ntriangles[173].a = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[173].b = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[173].c = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[173].n = vec3(0.9659258371267572,0,0.25881900465571195);\ntriangles[174].a = vec3(0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[174].b = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[174].c = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[174].n = vec3(0.6947463051962398,-0.6947469048636294,0.18615668024161938);\ntriangles[175].a = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[175].b = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[175].c = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[175].n = vec3(0.6947462107278689,-0.694746987168005,0.18615672563796265);\ntriangles[176].a = vec3(0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[176].b = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[176].c = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[176].n = vec3(0.8121118293108492,-0.5414079305661309,0.21760475503418142);\ntriangles[177].a = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[177].b = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[177].c = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[177].n = vec3(0.8121118754057224,-0.541407883322122,0.21760470055047124);\ntriangles[178].a = vec3(0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[178].b = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[178].c = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[178].n = vec3(0.31509881456880623,-0.9452958445136536,0.08443046489598273);\ntriangles[179].a = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[179].b = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[179].c = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[179].n = vec3(0.31509877525842633,-0.9452958562417668,0.08443048029464832);\ntriangles[180].a = vec3(0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[180].b = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[180].c = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[180].n = vec3(0.6161235154657551,-0.770153984978002,0.16508983346233994);\ntriangles[181].a = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[181].b = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[181].c = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[181].n = vec3(0.6161235406632192,-0.7701539667814604,0.16508982431209943);\ntriangles[182].a = vec3(0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[182].b = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[182].c = vec3(0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[182].n = vec3(0.9633500102957077,-0.07298106081719538,0.25812888723515015);\ntriangles[183].a = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[183].b = vec3(0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[183].c = vec3(0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[183].n = vec3(0.9633499927487893,-0.07298107455675974,0.258128948836523);\ntriangles[184].a = vec3(0,0,-1.608873287647763);\ntriangles[184].b = vec3(0,0,-1.608873287647763);\ntriangles[184].c = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[184].n = vec3(0,0,0);\ntriangles[185].a = vec3(0,0,-1.608873287647763);\ntriangles[185].b = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[185].c = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[185].n = vec3(0,-1,0);\ntriangles[186].a = vec3(0.4000000059604645,0,-1.608873287647763);\ntriangles[186].b = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[186].c = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[186].n = vec3(0.6947465105412519,0.6947466658291958,-0.18615680597273349);\ntriangles[187].a = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[187].b = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[187].c = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[187].n = vec3(0.694746711560632,0.6947464765240476,-0.18615676225458225);\ntriangles[188].a = vec3(0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[188].b = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[188].c = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[188].n = vec3(0.09946838305678318,0.9946837119922897,-0.026652464601026486);\ntriangles[189].a = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[189].b = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[189].c = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[189].n = vec3(0.09946837334382064,0.9946837126589728,-0.026652475969347913);\ntriangles[190].a = vec3(0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[190].b = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[190].c = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[190].n = vec3(0.7643175971089927,0.611454214357839,-0.2047983263934887);\ntriangles[191].a = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[191].b = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[191].c = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[191].n = vec3(0.7643176819949139,0.6114541266869272,-0.20479827134878148);\ntriangles[192].a = vec3(0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[192].b = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[192].c = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[192].n = vec3(0.9659258371267572,0,-0.25881900465571184);\ntriangles[193].a = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[193].b = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[193].c = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[193].n = vec3(0.9659258371267572,0,-0.25881900465571184);\ntriangles[194].a = vec3(0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[194].b = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[194].c = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[194].n = vec3(0.6947462198727891,-0.6947469963129355,-0.18615665737927345);\ntriangles[195].a = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[195].b = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[195].c = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[195].n = vec3(0.6947462789866233,-0.6947469140085646,-0.1861567439278446);\ntriangles[196].a = vec3(0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[196].b = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[196].c = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[196].n = vec3(0.8121118635947181,-0.5414078754481196,-0.21760476422051828);\ntriangles[197].a = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[197].b = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[197].c = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[197].n = vec3(0.8121118509172431,-0.5414079226921311,-0.21760469398880355);\ntriangles[198].a = vec3(0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[198].b = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[198].c = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[198].n = vec3(0.3150987759483156,-0.9452958583114335,-0.08443045454765441);\ntriangles[199].a = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[199].b = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[199].c = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[199].n = vec3(0.3150988022927684,-0.945295846583321,-0.08443048753847994);\ntriangles[200].a = vec3(0.20000000298023224,0.5,-1.608873287647763);\ntriangles[200].b = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[200].c = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[200].n = vec3(0.6161235390457477,-0.7701539647596221,-0.16508983978058117);\ntriangles[201].a = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[201].b = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[201].c = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[201].n = vec3(0.6161235217992246,-0.7701539829561646,-0.16508981925750668);\ntriangles[202].a = vec3(0.25,0.5400000214576721,-1.608873287647763);\ntriangles[202].b = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[202].c = vec3(0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[202].n = vec3(0.9633500092362706,-0.0729810758058116,-0.2581288869512747);\ntriangles[203].a = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[203].b = vec3(0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[203].c = vec3(0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[203].n = vec3(0.9633499936316536,-0.07298106206624695,-0.25812894907308576);\ntriangles[204].a = vec3(0,0,-1.608873287647763);\ntriangles[204].b = vec3(0,0,-1.608873287647763);\ntriangles[204].c = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[204].n = vec3(0,0,0);\ntriangles[205].a = vec3(0,0,-1.608873287647763);\ntriangles[205].b = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[205].c = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[205].n = vec3(0,-1,0);\ntriangles[206].a = vec3(0.3464101552963257,0,-1.8088732906279952);\ntriangles[206].b = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[206].c = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[206].n = vec3(0.5085898412946055,0.6947465341143171,-0.5085898412946055);\ntriangles[207].a = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[207].b = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[207].c = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[207].n = vec3(0.5085898412946056,0.6947465341143171,-0.5085898412946056);\ntriangles[208].a = vec3(0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[208].b = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[208].c = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[208].n = vec3(0.07281590644320564,0.9946837123114607,-0.07281590644320564);\ntriangles[209].a = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[209].b = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[209].c = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[209].n = vec3(0.07281590644320564,0.9946837123114608,-0.07281590644320564);\ntriangles[210].a = vec3(0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[210].b = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[210].c = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[210].n = vec3(0.5595193547143101,0.6114541547819952,-0.5595193547143101);\ntriangles[211].a = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[211].b = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[211].c = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[211].n = vec3(0.5595193547143101,0.6114541547819952,-0.5595193547143101);\ntriangles[212].a = vec3(0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[212].b = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[212].c = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[212].n = vec3(0.7071067811865476,0,-0.7071067811865476);\ntriangles[213].a = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[213].b = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[213].c = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[213].n = vec3(0.7071067811865476,0,-0.7071067811865476);\ntriangles[214].a = vec3(0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[214].b = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[214].c = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[214].n = vec3(0.50858957005334,-0.6947469312389349,-0.50858957005334);\ntriangles[215].a = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[215].b = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[215].c = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[215].n = vec3(0.50858957005334,-0.6947469312389349,-0.50858957005334);\ntriangles[216].a = vec3(0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[216].b = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[216].c = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[216].n = vec3(0.5945071368148962,-0.5414079132708615,-0.5945071368148962);\ntriangles[217].a = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[217].b = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[217].c = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[217].n = vec3(0.5945071368148962,-0.5414079132708615,-0.5945071368148962);\ntriangles[218].a = vec3(0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[218].b = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[218].c = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[218].n = vec3(0.23066833202133558,-0.9452958485072226,-0.23066833202133558);\ntriangles[219].a = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[219].b = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[219].c = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[219].n = vec3(0.23066833202133558,-0.9452958485072226,-0.23066833202133558);\ntriangles[220].a = vec3(0.17320507764816284,0.5,-1.708873289137879);\ntriangles[220].b = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[220].c = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[220].n = vec3(0.451033729865809,-0.7701539774919512,-0.451033729865809);\ntriangles[221].a = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[221].b = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[221].c = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[221].n = vec3(0.45103372986580903,-0.7701539774919514,-0.45103372986580903);\ntriangles[222].a = vec3(0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[222].b = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[222].c = vec3(0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[222].n = vec3(0.7052211582950427,-0.07298106457154878,-0.7052211582950427);\ntriangles[223].a = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[223].b = vec3(0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[223].c = vec3(0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[223].n = vec3(0.7052211582950427,-0.07298106457154879,-0.7052211582950427);\ntriangles[224].a = vec3(0,0,-1.608873287647763);\ntriangles[224].b = vec3(0,0,-1.608873287647763);\ntriangles[224].c = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[224].n = vec3(0,0,0);\ntriangles[225].a = vec3(0,0,-1.608873287647763);\ntriangles[225].b = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[225].c = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[225].n = vec3(0,-1,0);\ntriangles[226].a = vec3(0.20000000298023224,0,-1.9552834429440886);\ntriangles[226].b = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[226].c = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[226].n = vec3(0.18615685014393835,0.6947464891444053,-0.6947466753903973);\ntriangles[227].a = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[227].b = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[227].c = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[227].n = vec3(0.1861567117732268,0.6947466784495361,-0.6947465231615895);\ntriangles[228].a = vec3(0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[228].b = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[228].c = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[228].n = vec3(0.026652463860267747,0.9946837122885932,-0.09946838029223301);\ntriangles[229].a = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[229].b = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[229].c = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[229].n = vec3(0.026652478562004662,0.9946837116219103,-0.09946838301974524);\ntriangles[230].a = vec3(0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[230].b = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[230].c = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[230].n = vec3(0.2047983419794324,0.6114541364281443,-0.7643176552765137);\ntriangles[231].a = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[231].b = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[231].c = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[231].n = vec3(0.20479825186635756,0.6114542240990515,-0.7643176092855055);\ntriangles[232].a = vec3(0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[232].b = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[232].c = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[232].n = vec3(0.25881900465571195,0,-0.9659258371267572);\ntriangles[233].a = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[233].b = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[233].c = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[233].n = vec3(0.25881900465571195,0,-0.9659258371267572);\ntriangles[234].a = vec3(0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[234].b = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[234].c = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[234].n = vec3(0.18615668024161938,-0.6947469048636293,-0.6947463051962398);\ntriangles[235].a = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[235].b = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[235].c = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[235].n = vec3(0.18615672563796265,-0.694746987168005,-0.6947462107278689);\ntriangles[236].a = vec3(0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[236].b = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[236].c = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[236].n = vec3(0.21760475503418142,-0.5414079305661308,-0.812111829310849);\ntriangles[237].a = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[237].b = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[237].c = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[237].n = vec3(0.21760470055047124,-0.541407883322122,-0.8121118754057224);\ntriangles[238].a = vec3(0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[238].b = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[238].c = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[238].n = vec3(0.08443046489598273,-0.9452958445136536,-0.31509881456880623);\ntriangles[239].a = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[239].b = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[239].c = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[239].n = vec3(0.08443048029464832,-0.9452958562417667,-0.31509877525842633);\ntriangles[240].a = vec3(0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[240].b = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[240].c = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[240].n = vec3(0.16508983346233996,-0.770153984978002,-0.6161235154657552);\ntriangles[241].a = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[241].b = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[241].c = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[241].n = vec3(0.16508982431209943,-0.7701539667814604,-0.6161235406632192);\ntriangles[242].a = vec3(0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[242].b = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[242].c = vec3(0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[242].n = vec3(0.25812888723515015,-0.07298106081719538,-0.9633500102957077);\ntriangles[243].a = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[243].b = vec3(3.6739405577555036e-17,1.2000000476837158,-1.908873299568692);\ntriangles[243].c = vec3(0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[243].n = vec3(0.258128948836523,-0.07298107455675974,-0.9633499927487893);\ntriangles[244].a = vec3(0,0,-1.608873287647763);\ntriangles[244].b = vec3(0,0,-1.608873287647763);\ntriangles[244].c = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[244].n = vec3(0,0,0);\ntriangles[245].a = vec3(0,0,-1.608873287647763);\ntriangles[245].b = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[245].c = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[245].n = vec3(0,-1,0);\ntriangles[246].a = vec3(4.8985870794684264e-17,0,-2.0088732936082274);\ntriangles[246].b = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[246].c = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[246].n = vec3(-0.18615680597273349,0.6947466658291959,-0.694746510541252);\ntriangles[247].a = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[247].b = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[247].c = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[247].n = vec3(-0.1861567622545822,0.6947464765240478,-0.694746711560632);\ntriangles[248].a = vec3(4.2862636531758425e-17,0.05000000074505806,-1.9588732816872985);\ntriangles[248].b = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[248].c = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[248].n = vec3(-0.026652464601026483,0.9946837119922897,-0.09946838305678318);\ntriangles[249].a = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[249].b = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[249].c = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[249].n = vec3(-0.02665247596934791,0.9946837126589728,-0.09946837334382064);\ntriangles[250].a = vec3(1.2246467698671066e-17,0.07500000298023224,-1.708873289137879);\ntriangles[250].b = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[250].c = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[250].n = vec3(-0.20479832639348866,0.6114542143578389,-0.7643175971089927);\ntriangles[251].a = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[251].b = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[251].c = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[251].n = vec3(-0.20479827134878148,0.6114541266869272,-0.7643176819949139);\ntriangles[252].a = vec3(9.797174324372975e-18,0.10000000149011612,-1.6888732858596236);\ntriangles[252].b = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[252].c = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[252].n = vec3(-0.25881900465571184,0,-0.9659258371267572);\ntriangles[253].a = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[253].b = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[253].c = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[253].n = vec3(-0.25881900465571184,0,-0.9659258371267572);\ntriangles[254].a = vec3(9.797174324372975e-18,0.4000000059604645,-1.6888732858596236);\ntriangles[254].b = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[254].c = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[254].n = vec3(-0.18615665737927348,-0.6947469963129353,-0.6947462198727892);\ntriangles[255].a = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[255].b = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[255].c = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[255].n = vec3(-0.18615674392784456,-0.6947469140085647,-0.6947462789866233);\ntriangles[256].a = vec3(1.2246467698671066e-17,0.41999998688697815,-1.708873289137879);\ntriangles[256].b = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[256].c = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[256].n = vec3(-0.21760476422051825,-0.5414078754481196,-0.8121118635947181);\ntriangles[257].a = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[257].b = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[257].c = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[257].n = vec3(-0.21760469398880355,-0.5414079226921311,-0.8121118509172431);\ntriangles[258].a = vec3(1.714505527444786e-17,0.47999998927116394,-1.7488732882438094);\ntriangles[258].b = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[258].c = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[258].n = vec3(-0.08443045454765442,-0.9452958583114335,-0.31509877594831565);\ntriangles[259].a = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[259].b = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[259].c = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[259].n = vec3(-0.08443048753847993,-0.945295846583321,-0.3150988022927683);\ntriangles[260].a = vec3(2.4492935397342132e-17,0.5,-1.8088732906279952);\ntriangles[260].b = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[260].c = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[260].n = vec3(-0.16508983978058114,-0.7701539647596221,-0.6161235390457476);\ntriangles[261].a = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[261].b = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[261].c = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[261].n = vec3(-0.16508981925750668,-0.7701539829561646,-0.6161235217992246);\ntriangles[262].a = vec3(3.0616171314629196e-17,0.5400000214576721,-1.858873287647763);\ntriangles[262].b = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[262].c = vec3(3.6739405577555036e-17,1.2000000476837158,-1.908873299568692);\ntriangles[262].n = vec3(-0.2581288869512747,-0.0729810758058116,-0.9633500092362706);\ntriangles[263].a = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[263].b = vec3(-0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[263].c = vec3(3.6739405577555036e-17,1.2000000476837158,-1.908873299568692);\ntriangles[263].n = vec3(-0.25812894907308576,-0.07298106206624695,-0.9633499936316536);\ntriangles[264].a = vec3(0,0,-1.608873287647763);\ntriangles[264].b = vec3(0,0,-1.608873287647763);\ntriangles[264].c = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[264].n = vec3(0,0,0);\ntriangles[265].a = vec3(0,0,-1.608873287647763);\ntriangles[265].b = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[265].c = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[265].n = vec3(0,-1,0);\ntriangles[266].a = vec3(-0.20000000298023224,0,-1.9552834429440886);\ntriangles[266].b = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[266].c = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[266].n = vec3(-0.5085898412946055,0.6947465341143171,-0.5085898412946055);\ntriangles[267].a = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[267].b = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[267].c = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[267].n = vec3(-0.5085898412946056,0.6947465341143171,-0.5085898412946056);\ntriangles[268].a = vec3(-0.17499999701976776,0.05000000074505806,-1.911982188433209);\ntriangles[268].b = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[268].c = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[268].n = vec3(-0.07281590644320564,0.9946837123114607,-0.07281590644320564);\ntriangles[269].a = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[269].b = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[269].c = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[269].n = vec3(-0.07281590644320564,0.9946837123114608,-0.07281590644320564);\ntriangles[270].a = vec3(-0.05000000074505806,0.07500000298023224,-1.6954758264718444);\ntriangles[270].b = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[270].c = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[270].n = vec3(-0.5595193547143101,0.6114541547819952,-0.5595193547143101);\ntriangles[271].a = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[271].b = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[271].c = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[271].n = vec3(-0.5595193547143101,0.6114541547819952,-0.5595193547143101);\ntriangles[272].a = vec3(-0.03999999910593033,0.10000000149011612,-1.6781553201971442);\ntriangles[272].b = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[272].c = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[272].n = vec3(-0.7071067811865476,0,-0.7071067811865476);\ntriangles[273].a = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[273].b = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[273].c = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[273].n = vec3(-0.7071067811865476,0,-0.7071067811865476);\ntriangles[274].a = vec3(-0.03999999910593033,0.4000000059604645,-1.6781553201971442);\ntriangles[274].b = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[274].c = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[274].n = vec3(-0.50858957005334,-0.6947469312389349,-0.50858957005334);\ntriangles[275].a = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[275].b = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[275].c = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[275].n = vec3(-0.50858957005334,-0.6947469312389349,-0.50858957005334);\ntriangles[276].a = vec3(-0.05000000074505806,0.41999998688697815,-1.6954758264718444);\ntriangles[276].b = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[276].c = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[276].n = vec3(-0.5945071368148962,-0.5414079132708615,-0.5945071368148962);\ntriangles[277].a = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[277].b = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[277].c = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[277].n = vec3(-0.5945071368148962,-0.5414079132708615,-0.5945071368148962);\ntriangles[278].a = vec3(-0.07000000029802322,0.47999998927116394,-1.7301168464718253);\ntriangles[278].b = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[278].c = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[278].n = vec3(-0.23066833202133558,-0.9452958485072226,-0.23066833202133558);\ntriangles[279].a = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[279].b = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[279].c = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[279].n = vec3(-0.23066833202133558,-0.9452958485072226,-0.23066833202133558);\ntriangles[280].a = vec3(-0.10000000149011612,0.5,-1.7820783652959258);\ntriangles[280].b = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[280].c = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[280].n = vec3(-0.451033729865809,-0.7701539774919512,-0.451033729865809);\ntriangles[281].a = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[281].b = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[281].c = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[281].n = vec3(-0.45103372986580903,-0.7701539774919514,-0.45103372986580903);\ntriangles[282].a = vec3(-0.125,0.5400000214576721,-1.8253796347079665);\ntriangles[282].b = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[282].c = vec3(-0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[282].n = vec3(-0.7052211582950427,-0.07298106457154878,-0.7052211582950427);\ntriangles[283].a = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[283].b = vec3(-0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[283].c = vec3(-0.15000000596046448,1.2000000476837158,-1.8686809041200072);\ntriangles[283].n = vec3(-0.7052211582950427,-0.07298106457154879,-0.7052211582950427);\ntriangles[284].a = vec3(0,0,-1.608873287647763);\ntriangles[284].b = vec3(0,0,-1.608873287647763);\ntriangles[284].c = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[284].n = vec3(0,0,0);\ntriangles[285].a = vec3(0,0,-1.608873287647763);\ntriangles[285].b = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[285].c = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[285].n = vec3(0,-1,0);\ntriangles[286].a = vec3(-0.3464101552963257,0,-1.8088732906279952);\ntriangles[286].b = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[286].c = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[286].n = vec3(-0.6947466753903973,0.6947464891444054,-0.18615685014393835);\ntriangles[287].a = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[287].b = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[287].c = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[287].n = vec3(-0.6947465231615895,0.6947466784495361,-0.1861567117732268);\ntriangles[288].a = vec3(-0.30310890078544617,0.05000000074505806,-1.7838732846675307);\ntriangles[288].b = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[288].c = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[288].n = vec3(-0.09946838029223301,0.9946837122885932,-0.026652463860267747);\ntriangles[289].a = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[289].b = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[289].c = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[289].n = vec3(-0.09946838301974524,0.9946837116219102,-0.026652478562004662);\ntriangles[290].a = vec3(-0.08660253882408142,0.07500000298023224,-1.658873288392821);\ntriangles[290].b = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[290].c = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[290].n = vec3(-0.7643176552765141,0.6114541364281443,-0.2047983419794325);\ntriangles[291].a = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[291].b = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[291].c = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[291].n = vec3(-0.7643176092855055,0.6114542240990515,-0.2047982518663576);\ntriangles[292].a = vec3(-0.06928203254938126,0.10000000149011612,-1.6488732867536933);\ntriangles[292].b = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[292].c = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[292].n = vec3(-0.9659258371267573,0,-0.258819004655712);\ntriangles[293].a = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[293].b = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[293].c = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[293].n = vec3(-0.9659258371267573,0,-0.258819004655712);\ntriangles[294].a = vec3(-0.06928203254938126,0.4000000059604645,-1.6488732867536933);\ntriangles[294].b = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[294].c = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[294].n = vec3(-0.6947463051962397,-0.6947469048636294,-0.18615668024161938);\ntriangles[295].a = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[295].b = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[295].c = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[295].n = vec3(-0.6947462107278688,-0.694746987168005,-0.18615672563796268);\ntriangles[296].a = vec3(-0.08660253882408142,0.41999998688697815,-1.658873288392821);\ntriangles[296].b = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[296].c = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[296].n = vec3(-0.8121118293108491,-0.5414079305661308,-0.21760475503418145);\ntriangles[297].a = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[297].b = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[297].c = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[297].n = vec3(-0.8121118754057223,-0.5414078833221219,-0.21760470055047126);\ntriangles[298].a = vec3(-0.12124355882406235,0.47999998927116394,-1.6788732879457862);\ntriangles[298].b = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[298].c = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[298].n = vec3(-0.31509881456880623,-0.9452958445136536,-0.08443046489598274);\ntriangles[299].a = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[299].b = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[299].c = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[299].n = vec3(-0.31509877525842633,-0.9452958562417667,-0.08443048029464834);\ntriangles[300].a = vec3(-0.17320507764816284,0.5,-1.708873289137879);\ntriangles[300].b = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[300].c = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[300].n = vec3(-0.6161235154657551,-0.770153984978002,-0.16508983346233996);\ntriangles[301].a = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[301].b = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[301].c = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[301].n = vec3(-0.6161235406632191,-0.7701539667814604,-0.16508982431209943);\ntriangles[302].a = vec3(-0.21650634706020355,0.5400000214576721,-1.733873287647763);\ntriangles[302].b = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[302].c = vec3(-0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[302].n = vec3(-0.9633500102957077,-0.07298106081719538,-0.2581288872351502);\ntriangles[303].a = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[303].b = vec3(-0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[303].c = vec3(-0.25980761647224426,1.2000000476837158,-1.7588732936082274);\ntriangles[303].n = vec3(-0.9633499927487894,-0.07298107455675977,-0.2581289488365231);\ntriangles[304].a = vec3(0,0,-1.608873287647763);\ntriangles[304].b = vec3(0,0,-1.608873287647763);\ntriangles[304].c = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[304].n = vec3(0,0,0);\ntriangles[305].a = vec3(0,0,-1.608873287647763);\ntriangles[305].b = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[305].c = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[305].n = vec3(0,-1,0);\ntriangles[306].a = vec3(-0.4000000059604645,0,-1.608873287647763);\ntriangles[306].b = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[306].c = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[306].n = vec3(-0.694746510541252,0.6947466658291959,0.18615680597273349);\ntriangles[307].a = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[307].b = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[307].c = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[307].n = vec3(-0.694746711560632,0.6947464765240478,0.1861567622545822);\ntriangles[308].a = vec3(-0.3499999940395355,0.05000000074505806,-1.608873287647763);\ntriangles[308].b = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[308].c = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[308].n = vec3(-0.09946838305678318,0.9946837119922897,0.026652464601026483);\ntriangles[309].a = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[309].b = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[309].c = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[309].n = vec3(-0.09946837334382061,0.9946837126589727,0.026652475969347902);\ntriangles[310].a = vec3(-0.10000000149011612,0.07500000298023224,-1.608873287647763);\ntriangles[310].b = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[310].c = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[310].n = vec3(-0.7643175971089927,0.611454214357839,0.20479832639348866);\ntriangles[311].a = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[311].b = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[311].c = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[311].n = vec3(-0.7643176819949139,0.6114541266869272,0.20479827134878142);\ntriangles[312].a = vec3(-0.07999999821186066,0.10000000149011612,-1.608873287647763);\ntriangles[312].b = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[312].c = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[312].n = vec3(-0.9659258371267572,0,0.25881900465571184);\ntriangles[313].a = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[313].b = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[313].c = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[313].n = vec3(-0.9659258371267572,0,0.25881900465571184);\ntriangles[314].a = vec3(-0.07999999821186066,0.4000000059604645,-1.608873287647763);\ntriangles[314].b = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[314].c = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[314].n = vec3(-0.6947462198727892,-0.6947469963129355,0.18615665737927342);\ntriangles[315].a = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[315].b = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[315].c = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[315].n = vec3(-0.6947462789866233,-0.6947469140085647,0.1861567439278445);\ntriangles[316].a = vec3(-0.10000000149011612,0.41999998688697815,-1.608873287647763);\ntriangles[316].b = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[316].c = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[316].n = vec3(-0.8121118635947182,-0.5414078754481196,0.21760476422051825);\ntriangles[317].a = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[317].b = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[317].c = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[317].n = vec3(-0.8121118509172432,-0.5414079226921311,0.21760469398880353);\ntriangles[318].a = vec3(-0.14000000059604645,0.47999998927116394,-1.608873287647763);\ntriangles[318].b = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[318].c = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[318].n = vec3(-0.31509877594831565,-0.9452958583114335,0.08443045454765438);\ntriangles[319].a = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[319].b = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[319].c = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[319].n = vec3(-0.3150988022927684,-0.945295846583321,0.08443048753847993);\ntriangles[320].a = vec3(-0.20000000298023224,0.5,-1.608873287647763);\ntriangles[320].b = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[320].c = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[320].n = vec3(-0.6161235390457477,-0.7701539647596223,0.16508983978058114);\ntriangles[321].a = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[321].b = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[321].c = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[321].n = vec3(-0.6161235217992247,-0.7701539829561646,0.16508981925750665);\ntriangles[322].a = vec3(-0.25,0.5400000214576721,-1.608873287647763);\ntriangles[322].b = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[322].c = vec3(-0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[322].n = vec3(-0.9633500092362706,-0.07298107580581162,0.25812888695127467);\ntriangles[323].a = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[323].b = vec3(-0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[323].c = vec3(-0.30000001192092896,1.2000000476837158,-1.608873287647763);\ntriangles[323].n = vec3(-0.9633499936316537,-0.07298106206624695,0.2581289490730857);\ntriangles[324].a = vec3(0,0,-1.608873287647763);\ntriangles[324].b = vec3(0,0,-1.608873287647763);\ntriangles[324].c = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[324].n = vec3(0,0,0);\ntriangles[325].a = vec3(0,0,-1.608873287647763);\ntriangles[325].b = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[325].c = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[325].n = vec3(0,-1,0);\ntriangles[326].a = vec3(-0.3464101552963257,0,-1.4088732846675307);\ntriangles[326].b = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[326].c = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[326].n = vec3(-0.5085898412946055,0.6947465341143171,0.5085898412946055);\ntriangles[327].a = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[327].b = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[327].c = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[327].n = vec3(-0.5085898412946056,0.6947465341143171,0.5085898412946056);\ntriangles[328].a = vec3(-0.30310890078544617,0.05000000074505806,-1.4338732906279952);\ntriangles[328].b = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[328].c = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[328].n = vec3(-0.07281590644320564,0.9946837123114607,0.07281590644320564);\ntriangles[329].a = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[329].b = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[329].c = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[329].n = vec3(-0.07281590644320564,0.9946837123114608,0.07281590644320564);\ntriangles[330].a = vec3(-0.08660253882408142,0.07500000298023224,-1.5588732869027049);\ntriangles[330].b = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[330].c = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[330].n = vec3(-0.5595193547143101,0.6114541547819952,0.5595193547143101);\ntriangles[331].a = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[331].b = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[331].c = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[331].n = vec3(-0.5595193547143101,0.6114541547819952,0.5595193547143101);\ntriangles[332].a = vec3(-0.06928203254938126,0.10000000149011612,-1.5688732885418326);\ntriangles[332].b = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[332].c = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[332].n = vec3(-0.7071067811865476,0,0.7071067811865476);\ntriangles[333].a = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[333].b = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[333].c = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[333].n = vec3(-0.7071067811865476,0,0.7071067811865476);\ntriangles[334].a = vec3(-0.06928203254938126,0.4000000059604645,-1.5688732885418326);\ntriangles[334].b = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[334].c = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[334].n = vec3(-0.50858957005334,-0.6947469312389349,0.50858957005334);\ntriangles[335].a = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[335].b = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[335].c = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[335].n = vec3(-0.50858957005334,-0.6947469312389349,0.50858957005334);\ntriangles[336].a = vec3(-0.08660253882408142,0.41999998688697815,-1.5588732869027049);\ntriangles[336].b = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[336].c = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[336].n = vec3(-0.5945071368148962,-0.5414079132708615,0.5945071368148962);\ntriangles[337].a = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[337].b = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[337].c = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[337].n = vec3(-0.5945071368148962,-0.5414079132708615,0.5945071368148962);\ntriangles[338].a = vec3(-0.12124355882406235,0.47999998927116394,-1.5388732873497397);\ntriangles[338].b = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[338].c = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[338].n = vec3(-0.23066833202133558,-0.9452958485072226,0.23066833202133558);\ntriangles[339].a = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[339].b = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[339].c = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[339].n = vec3(-0.23066833202133558,-0.9452958485072226,0.23066833202133558);\ntriangles[340].a = vec3(-0.17320507764816284,0.5,-1.5088732861576468);\ntriangles[340].b = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[340].c = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[340].n = vec3(-0.451033729865809,-0.7701539774919512,0.451033729865809);\ntriangles[341].a = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[341].b = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[341].c = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[341].n = vec3(-0.45103372986580903,-0.7701539774919514,0.45103372986580903);\ntriangles[342].a = vec3(-0.21650634706020355,0.5400000214576721,-1.483873287647763);\ntriangles[342].b = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[342].c = vec3(-0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[342].n = vec3(-0.7052211582950427,-0.07298106457154878,0.7052211582950427);\ntriangles[343].a = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[343].b = vec3(-0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[343].c = vec3(-0.25980761647224426,1.2000000476837158,-1.4588732816872985);\ntriangles[343].n = vec3(-0.7052211582950427,-0.07298106457154879,0.7052211582950427);\ntriangles[344].a = vec3(0,0,-1.608873287647763);\ntriangles[344].b = vec3(0,0,-1.608873287647763);\ntriangles[344].c = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[344].n = vec3(0,0,0);\ntriangles[345].a = vec3(0,0,-1.608873287647763);\ntriangles[345].b = vec3(-9.797174158936853e-17,0,-1.2088732816872985);\ntriangles[345].c = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[345].n = vec3(0,-1,0);\ntriangles[346].a = vec3(-0.20000000298023224,0,-1.2624631323514373);\ntriangles[346].b = vec3(-9.797174158936853e-17,0,-1.2088732816872985);\ntriangles[346].c = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[346].n = vec3(-0.18615685014393835,0.6947464891444053,0.6947466753903973);\ntriangles[347].a = vec3(-9.797174158936853e-17,0,-1.2088732816872985);\ntriangles[347].b = vec3(-8.572527306351685e-17,0.05000000074505806,-1.2588732936082274);\ntriangles[347].c = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[347].n = vec3(-0.1861567117732268,0.6947466784495361,0.6947465231615895);\ntriangles[348].a = vec3(-0.17499999701976776,0.05000000074505806,-1.3057643868623168);\ntriangles[348].b = vec3(-8.572527306351685e-17,0.05000000074505806,-1.2588732936082274);\ntriangles[348].c = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[348].n = vec3(-0.026652463860267747,0.9946837122885932,0.09946838029223301);\ntriangles[349].a = vec3(-8.572527306351685e-17,0.05000000074505806,-1.2588732936082274);\ntriangles[349].b = vec3(-2.4492935397342132e-17,0.07500000298023224,-1.5088732861576468);\ntriangles[349].c = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[349].n = vec3(-0.02665247856200467,0.9946837116219103,0.09946838301974524);\ntriangles[350].a = vec3(-0.05000000074505806,0.07500000298023224,-1.5222707488236815);\ntriangles[350].b = vec3(-2.4492935397342132e-17,0.07500000298023224,-1.5088732861576468);\ntriangles[350].c = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[350].n = vec3(-0.2047983419794325,0.6114541364281443,0.764317655276514);\ntriangles[351].a = vec3(-2.4492935397342132e-17,0.07500000298023224,-1.5088732861576468);\ntriangles[351].b = vec3(-1.959434864874595e-17,0.10000000149011612,-1.5288732894359023);\ntriangles[351].c = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[351].n = vec3(-0.20479825186635767,0.6114542240990515,0.7643176092855057);\ntriangles[352].a = vec3(-0.03999999910593033,0.10000000149011612,-1.5395912550983817);\ntriangles[352].b = vec3(-1.959434864874595e-17,0.10000000149011612,-1.5288732894359023);\ntriangles[352].c = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[352].n = vec3(-0.25881900465571206,0,0.9659258371267572);\ntriangles[353].a = vec3(-1.959434864874595e-17,0.10000000149011612,-1.5288732894359023);\ntriangles[353].b = vec3(-1.959434864874595e-17,0.4000000059604645,-1.5288732894359023);\ntriangles[353].c = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[353].n = vec3(-0.25881900465571206,0,0.9659258371267572);\ntriangles[354].a = vec3(-0.03999999910593033,0.4000000059604645,-1.5395912550983817);\ntriangles[354].b = vec3(-1.959434864874595e-17,0.4000000059604645,-1.5288732894359023);\ntriangles[354].c = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[354].n = vec3(-0.1861566802416194,-0.6947469048636293,0.6947463051962397);\ntriangles[355].a = vec3(-1.959434864874595e-17,0.4000000059604645,-1.5288732894359023);\ntriangles[355].b = vec3(-2.4492935397342132e-17,0.41999998688697815,-1.5088732861576468);\ntriangles[355].c = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[355].n = vec3(-0.18615672563796273,-0.694746987168005,0.6947462107278689);\ntriangles[356].a = vec3(-0.05000000074505806,0.41999998688697815,-1.5222707488236815);\ntriangles[356].b = vec3(-2.4492935397342132e-17,0.41999998688697815,-1.5088732861576468);\ntriangles[356].c = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[356].n = vec3(-0.21760475503418145,-0.5414079305661308,0.812111829310849);\ntriangles[357].a = vec3(-2.4492935397342132e-17,0.41999998688697815,-1.5088732861576468);\ntriangles[357].b = vec3(-3.429011054889572e-17,0.47999998927116394,-1.4688732870517165);\ntriangles[357].c = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[357].n = vec3(-0.21760470055047126,-0.5414078833221219,0.8121118754057223);\ntriangles[358].a = vec3(-0.07000000029802322,0.47999998927116394,-1.4876297288237006);\ntriangles[358].b = vec3(-3.429011054889572e-17,0.47999998927116394,-1.4688732870517165);\ntriangles[358].c = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[358].n = vec3(-0.08443046489598274,-0.9452958445136536,0.31509881456880623);\ntriangles[359].a = vec3(-3.429011054889572e-17,0.47999998927116394,-1.4688732870517165);\ntriangles[359].b = vec3(-4.8985870794684264e-17,0.5,-1.4088732846675307);\ntriangles[359].c = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[359].n = vec3(-0.08443048029464835,-0.9452958562417667,0.31509877525842633);\ntriangles[360].a = vec3(-0.10000000149011612,0.5,-1.4356682099996);\ntriangles[360].b = vec3(-4.8985870794684264e-17,0.5,-1.4088732846675307);\ntriangles[360].c = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[360].n = vec3(-0.16508983346233996,-0.770153984978002,0.616123515465755);\ntriangles[361].a = vec3(-4.8985870794684264e-17,0.5,-1.4088732846675307);\ntriangles[361].b = vec3(-6.123234262925839e-17,0.5400000214576721,-1.358873287647763);\ntriangles[361].c = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[361].n = vec3(-0.16508982431209948,-0.7701539667814604,0.6161235406632191);\ntriangles[362].a = vec3(-0.125,0.5400000214576721,-1.3923669405875594);\ntriangles[362].b = vec3(-6.123234262925839e-17,0.5400000214576721,-1.358873287647763);\ntriangles[362].c = vec3(-0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[362].n = vec3(-0.25812888723515026,-0.0729810608171954,0.9633500102957075);\ntriangles[363].a = vec3(-6.123234262925839e-17,0.5400000214576721,-1.358873287647763);\ntriangles[363].b = vec3(-7.347881115511007e-17,1.2000000476837158,-1.308873275726834);\ntriangles[363].c = vec3(-0.15000000596046448,1.2000000476837158,-1.3490656711755187);\ntriangles[363].n = vec3(-0.25812894883652304,-0.07298107455675976,0.9633499927487893);\n\n    \n}\n\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(iTime)*5.0;\n    cameraPosition.y = sin(iTime+0.5)*5.0;\n    cameraPosition.z = cos(iTime)*5.0;\n\treturn cameraPosition;\n}\n\nvec4 getFinalV4(vec4 v4) {\n    \n    mat4 modelMatrix = mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t//mat4 viewMatrix = mat4(1, 0, -0, 0, -0, 1, -0, 0, 0, 0, 1, 0, 0, 0, -100, 1);\n    \n    vec3 cameraPosition = getCameraPosition();\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\t//mat4 projectMatrix = mat4(2.4142136573791504, 0, 0, 0, 0, 2.4142136573791504, 0, 0, 0, 0, -1.0202020406723022, -1, 0, 0, -2.0202019214630127, 0);\t\n    \n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 mvpMatrix = projectMatrix * viewMatrix * modelMatrix;\n    \n    return mvpMatrix * v4;\n}\n\nvec4 V3ToV4(vec3 v3) {\n    \n    return vec4(v3.xyz, 1.0);\n    \n}\n\nvec2 V3ToV2(vec3 v3) {\n\n    //v3 project to iResolution.xy\n\n    float x = round(iResolution.x/2.0 + v3.x*iResolution.x/2.0);\n    float y = round(iResolution.y/2.0 + v3.y*iResolution.y/2.0);\n    return vec2(x, y);\n\n}\n\nvec2 V4ToV2(vec4 v4) {\n\n    //v4 project to between -1.0 and 1.0\n\n    vec3 v3 = vec3(v4.xyz);\n\n    v3 = v3 / v4.w;\n\n    return V3ToV2(v3);\n}\n\nfloat v2Cross(vec2 v2a, vec2 v2b) {\n    return v2a.x * v2b.y - v2a.y * v2b.x;\n}\n\nbool isPointInTriangle2D(vec2 point,vec2 tpA, vec2 tpB, vec2 tpC) {\n    vec2 PA = tpA - point;\n    vec2 PB = tpB - point;\n    vec2 PC = tpC - point;\n    \n    float t1 = v2Cross(PA,PB);\n    float t2 = v2Cross(PB,PC);\n    float t3 = v2Cross(PC,PA);\n    //return t1 * t2 > 0.0 && t1 * t3 > 0.0;\n    return t1 >= 0.0 && t2 >= 0.0 && t3 > 0.0;\n}\n\nfloat getLightWeightByNormal(vec3 normal){\n\tfloat lightWeight = 1.0;\n    \n    vec3 lightDirection1 = normalize(vec3(1.0, 0.6, 0.3));\n    \n    vec3 lightDirection2 = -1.0*lightDirection1;\n    \n    float lightWeight1 = max(0.0,dot(lightDirection1, normal));\n    \n    float lightWeight2 = max(0.0,dot(lightDirection2, normal));\n    \n\treturn lightWeight1 + lightWeight2;\n}\n\nvec3 getColorOnTriangle(Triangle triangle){\n\n    vec3 color = vec3(1,0,0);\n    \n    float lightWeight = getLightWeightByNormal(triangle.n);\n    \n    color = color * lightWeight;\n    \n    color += 0.0;\n        \n    return color;\n    \n}\n\nvec2 getV2form2Line(vec3 line1, vec3 line2){\n    vec2 v2;\n    \n\t//((b1c2-b2c1)/(a1b2-a2b1)，(a2c1-a1c2)/(a1b2-a2b1))\n    \n    v2.x = (line1.y*line2.z-line2.y*line1.z)/(line1.x*line2.y-line2.x*line1.y);\n    v2.y = (line2.x*line1.z-line1.x*line2.z)/(line1.x*line2.y-line2.x*line1.y);\n    \n\treturn v2;\n}\n\nvec3 getLineABCfrom2Point(vec2 p1, vec2 p2){\n    vec3 lineABC;\n    lineABC.x = p2.y - p1.y; //A\n\n\tlineABC.y = p2.x - p1.x; //B\n\n\tlineABC.z = p2.x * p1.y - p2.y * p1.x; //C\n    \n    return lineABC;\n\n}\n\nvec3 getV3from3v2and2v3(vec3 v3a, vec3 v3b, vec2 v2p, vec2 v2a, vec2 v2b){\n    vec3 v3;\n    \n    float ap = distance(v2a,v2p);\n    float pb = distance(v2b,v2p);\n    v3 = v3a + (v3b-v3a)*ap/(ap+pb);\n\treturn v3;\n}\n\nfloat getPointZonTriangle(vec2 v2a, vec2 v2b, vec2 v2c, vec3 v3a, vec3 v3b, vec3 v3c, vec2 p){\n\tfloat z;\n    \n    vec3 lineab = getLineABCfrom2Point(v2a, v2b);\n    vec3 linecp = getLineABCfrom2Point(v2c, p);\n    \n    vec2 v2ab = getV2form2Line(lineab, linecp);\n    \n    vec3 v3ab = getV3from3v2and2v3(v3a, v3b, v2ab, v2a, v2b);\n    \n    vec3 v3p = getV3from3v2and2v3(v3c, v3ab, p, v2c, v2ab);\n    \n    return v3p.z;\n}\n\nbool isTriangleV2clockwise(vec2 p1, vec2 p2, vec2 p3){\n    bool isTriangleV2clockwise = false;\n    \n    if ((p2.x - p1.x) *(p3.y - p1.y) -(p3.x - p1.x) *(p2.y-p1.y) < 0.0){  \n\t\tisTriangleV2clockwise = true;\n    } \n    \n    return isTriangleV2clockwise;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord;\n    \n    vec3 col;\n    \n    bool isCurrentPixInCube = false;\n    \n    getOneCube();\n    \n    int index = -1;\n    \n    float zBuffer = 99999.0;\n    \n    for(int i=0; i<triangleCount; i++ ){\n        vec2 pA = V4ToV2( getFinalV4( V3ToV4(triangles[i].a)));\n    \tvec2 pB = V4ToV2( getFinalV4( V3ToV4(triangles[i].b)));\n    \tvec2 pC = V4ToV2( getFinalV4( V3ToV4(triangles[i].c)));\n        \n        if(isPointInTriangle2D(uv, pA, pB, pC)){\n            vec4 finalV4a = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3a = finalV4a.xyz / finalV4a.w;\n            vec4 finalV4b = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3b = finalV4b.xyz / finalV4b.w;\n            vec4 finalV4c = getFinalV4( V3ToV4(triangles[i].c));\n            vec3 finalV3c = finalV4c.xyz / finalV4c.w;\n            //float z = (finalV3a.z+finalV3b.z+finalV3c.z)/3.0;\n            \n            //float z = getPointZonTriangle(pA, pB, pC, finalV3a, finalV3b, finalV3c, uv);\n            \n            if(!isTriangleV2clockwise(pA, pB, pC)){            \n            \tindex = i;\n                break;\n            }\n            /*\n            if(z < zBuffer){\n            \tzBuffer = z;\n                index = i;\n            }\n\t\t\t*/\n\n        };\n    \t\n    }\n    \n    \n    if(index != -1){\n    \tcol = getColorOnTriangle(triangles[index-0]);\n    }else{\n    \tcol = vec3(0.2,0.2,0);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdX3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 323, 348, 348, 110155], [110158, 110158, 110240, 110240, 111025], [111027, 111027, 111081, 111081, 111321], [111323, 111323, 111456, 111456, 112733], [112736, 112736, 112761, 112761, 112930], [112932, 112932, 112958, 112958, 113655], [113657, 113657, 113679, 113679, 113721], [113723, 113723, 113745, 113781, 113938], [113940, 113940, 113962, 114004, 114080], [114082, 114082, 114117, 114117, 114161], [114163, 114163, 114230, 114230, 114503], [114505, 114505, 114547, 114547, 114873], [114875, 114875, 114918, 114918, 115109], [115111, 115111, 115155, 115155, 115412], [115414, 115414, 115458, 115458, 115613], [115615, 115615, 115689, 115689, 115826], [115828, 115828, 115922, 115922, 116245], [116247, 116247, 116301, 116301, 116502], [116504, 116504, 116561, 116653, 118104]]}
{"id": "WdXGDB", "name": "day15 cross light", "author": "kiyoshidainagon", "description": "cross light", "tags": ["shadeaday"], "likes": 5, "viewed": 109, "published": "Public", "date": "1547308139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a) vec2(cos(a),sin(a))\n\nconst float PI = 3.14159265359;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 destColor = vec3(0.1, 0.8, 0.6);\n    float f = 0.0;\n    \n    for (float i = 0.0; i < 10.0; i++) {\n        vec2 P = CS(iTime + i * 2.0 * PI / 10.0);\n        P = abs(p + P);\n        // ここは足す\n        f += 0.001 / (P.x * P.y);\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(destColor * f),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 176, 613]]}
{"id": "wdXGDf", "name": "Deep Space Sky", "author": "ReavenTehDerg", "description": "Just played around with smooth noise generation that i learnt from the youtube channel ArtOfCode.\n\nAlso a friend of mine wanted me to do something sky alike. So i came up with this :)", "tags": ["noise", "sky"], "likes": 7, "viewed": 160, "published": "Public", "date": "1547646327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p)\n{\n    p = fract(p * vec2(6574.5414, 8961.8778));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * 24.;\n    return sin(n) * .4;\n}\nfloat sn(vec2 uv)\n{\n    vec2 lv = fract(uv * 10.0);\n    vec2 id = floor(uv * 10.0);\n\n    lv = lv * lv * (3. - 2. * lv);\n\n    float bl = N21(id);\n    float br = N21(id +vec2(1, 0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = N21(id + vec2(0,1));\n    float tr = N21(id +vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\nfloat stars(vec2 uv)\n{\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 pos = GetPos(id);\n    float distance = length(gv - pos);\n    float shineRate = abs(sin(iTime * 0.8 * N21(id)));\n\n    float star = smoothstep(0.06, clamp(0.9 - sqrt(iTime / 10.0), 0.001, 0.059), distance) * shineRate;\n    return star - 0.15;\n}\n\nvec3 animate(vec2 uv)\n{\n    float zoomout = sqrt((iTime * 0.25));\n    float andromedaFade = sqrt(iTime / 8.);\n    uv *= clamp(zoomout, 0.0, 1.8);\n\n    vec3 spaceCol = vec3(0.0, 0.0, 0.10);\n    vec3 andromedaColPink = vec3(0.8, 0.0, 0.7);\n    vec3 andromedaColGreen = vec3(0.2, 0.9, 0.2);\n\n    spaceCol += stars(uv);\n\n    vec2 androUV = uv;\n    float s = sin(iTime * 0.08);\n    float c = cos(iTime * 0.08);\n    mat2 rotmat = mat2(c, -s, s, c);\n    //androUV -= iTime * 0.2;\n    androUV *= rotmat;\n    float andromedaPinkNoise = sn(androUV * 0.03) * clamp(andromedaFade, 0.0, 1.6);\n    andromedaPinkNoise += sn(androUV * 0.25) * 0.125;\n    andromedaPinkNoise += sn(androUV * 0.125) * 0.625;\n    andromedaPinkNoise /= 5.0;\n    spaceCol +=  mix(spaceCol, andromedaColPink, andromedaPinkNoise);\n\n\n    s = sin(iTime * 0.03);\n    c = cos(iTime * 0.03);\n    rotmat = mat2(c, s, -s, c);\n    vec2 androUV2 = uv;\n    androUV2.y += iTime * 0.3;\n    androUV2 *= rotmat;\n    float andromedaGreenNoise = sn(androUV2 * 0.03) * clamp(andromedaFade, 0.0, 1.6);\n    andromedaGreenNoise += sn(androUV2 * 0.25) * 0.125;\n    andromedaGreenNoise += sn(androUV2 * 0.125) * 0.625;\n    andromedaGreenNoise /= 3.0;\n    spaceCol +=  mix(spaceCol, andromedaColGreen, andromedaGreenNoise);\n\n    return spaceCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y * 10.;\n    vec3 col = animate(uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 125], [126, 126, 144, 144, 217], [218, 218, 240, 240, 294], [295, 295, 314, 314, 645], [646, 646, 668, 668, 977], [979, 979, 1002, 1002, 2262], [2264, 2264, 2321, 2321, 2458]]}
{"id": "WdXGDN", "name": "2019", "author": "iapafoto", "description": "Recycling shader. Happy new year !", "tags": ["2019"], "likes": 19, "viewed": 300, "published": "Public", "date": "1546346097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------\n// Created by sebastien durand - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n// Lightening, essentially based on one of incredible TekF shaders:\n// https://www.shadertoy.com/view/lslXRj\n\n//-----------------------------------------------------\n\n\n// Change this to improve quality (3 is good)\n\n#define ANTIALIASING 1\n\n#define iTime (1.5*iTime)\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n// Isosurface Renderer\nconst int g_traceLimit=240;\nconst float g_traceSize=.004;\n\n\nconst vec3 g_boxSize = vec3(.4);\n\nconst vec3 g_ptOnBody = vec3(g_boxSize.x*.5, g_boxSize.y*.15, g_boxSize.z*.5); \nconst vec3 g_ptOnBody2 = vec3(g_boxSize.x*.5, -g_boxSize.y*.5, -g_boxSize.z*.5); \n\n// Data to read in Buf A\nvec3 g_posBox;\nmat3 g_rotBox;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); // Global ambiant color\nvec3 g_lightPos1, g_lightPos2;\nvec3 g_vConnexionPos, g_posFix; \nvec3 g_vConnexionPos2;\nconst vec3 g_posFix2 = vec3(0.,1.,0.);\nfloat g_rSpring, g_rSpring2;\nbool g_WithSpring2;\n\n// -----------------------------------------------------------------\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// ---------------------------------------------\n\n// Distance from ray to point\nfloat dista(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n// Intersection ray / sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\n\n// -- Modeling Primitives ---------------------------------------------------\n// [iq] https://www.shadertoy.com/view/lsccR8\nfloat sdfStar5( in vec2 p )\n{\n    // using reflections\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\n//const int[] txt = int[] (50,48,49,57,0,2,2,2,2,0);\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [iq] https://www.shadertoy.com/view/4lyfzw\n//       https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----------------------------------------------------------\n\nfloat opExtrusion( in vec3 p, in float d )\n{\n    vec2 w = vec2( d, p.z );\n    return max(p.z, min(max(w.x,w.y),0.0) + length(max(w,0.0)));\n}\n\n//----------------------------------------------------------\n// FONT\n//----------------------------------------------------------\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\n//----------------------------------------------------------\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage(vec2 p, float scale) { \n    p /= scale;\n    float d;\n    d = sdFont(p, 50);\n    p.x-=.5;\n    d = min(d, sdFont(p, 48));\n    p.x-=.5;\n    d = min(d, sdFont(p, 49));\n    p.x-=.5;\n    d = min(d, sdFont(p, 57));\n    return d*scale;\n}\n\n\nfloat map(vec3 p) { \n\n    p.y -=1.2;\n    float z = iTime + p.z;\n    p.x += .01*cos(z);\n\tfloat k = .1*z+.5*cos(z*.2)*(.5+.5*cos(z));\n    float c = cos(4.*k);\n    float s = sin(4.*k);\n    mat2  m = mat2(c,-s,s,c);\n    p.xy*=m;\n    float sc = .6+.5*cos(z);\n    float d2D = sdMessage(p.xy, sc);\n    \n    vec2 p2 = p.xy-vec2(.5,.75);\n    p2 *= m*m;\n    sc = 4.+5./sc;\n    float sc2 = (.9 +.1*sc)*.5;\n    float fstar = sdfStar5((p2+sc2*vec2(.1,.15))*sc)/sc;\n     fstar = min(fstar, sdfStar5((p2+sc2*vec2(.1,-.15))*sc)/sc);\n     fstar = min(fstar, sdfStar5((p2+sc2*vec2(-.1,0.))*sc)/sc);\n    return opExtrusion(p, min(fstar,d2D));\n}\n\n\n\n//----------------------------------------------------------------------\n\n\n\n\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.0,1.,abs(mod(p+v*.5, v)-v*.5)/.01);\n    return k.x * k.y;\n}\n\n\n// render for color extraction\nvec3 colorField(vec3 p) {\n    p.y -= 1.2;\n    float z = iTime + p.z;\n    \n    p.x += .01*cos(z);\n\tfloat k = .1*z+.5*cos(z*.2)*(.5+.5*cos(z));\n    float c = cos(4.*k);\n    float s = sin(4.*k);\n    mat2  m = mat2(c,-s,s,c);\n    p.xy*=m;\n    float sc = .6+.5*cos(z);\n    \n    float d2D = sdMessage(p.xy, sc);\n    \n    vec2 p2 = p.xy-vec2(.5,.75);\n    p2 *= m*m;\n    float sc1 = 4.+5./sc;\n    float sc2 = (.9 +.1*sc1)*.5;\n    float fstar = sdfStar5((p2+sc2*vec2(.1,.15))*sc1)/sc1;\n    fstar = min(fstar, sdfStar5((p2+sc2*vec2(.1,-.15))*sc1)/sc1);\n    fstar = min(fstar, sdfStar5((p2+sc2*vec2(-.1,0.))*sc1)/sc1);\n   \n    return (d2D < fstar) ? vec3(p.xy/sc,z) : vec3(.05,2.05,z);\n}\n\n\n// ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n// -------------------------------------------------------------------\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n\n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n    \n    // ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n    \n\tambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t// And sub surface scattering too! Because, why not?\n    float transmissionRange = distance/10.0; // this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*transmissionRange )/transmissionRange;\n    float transmission2 = map( pos + lightDir2*transmissionRange )/transmissionRange;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + \n                   lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .012; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 albedo;\n\n    if (pos.y<-.48) {  \n        pos.z+=iTime;\n       \tfloat f = mod( floor(2.*pos.z) + floor(2.*pos.x), 2.0);\n        albedo = (0.4 + 0.1*f)*vec3(.7,.6,.8);\n        albedo *= .2*(.3+.5*isGridLine(pos.xz, vec2(.5)));\n      \tspecPower *= 5.;\n\n    } else {\n    \tvec3 colorId = colorField(pos);\n        vec3 col = colorId.y > .5 ? vec3(.96,.96,0) : \n        \t\t\tcolorId.x < .2 ? vec3(.6,.3,.0) : \n                   colorId.x < .7 ? vec3(.3,.6,.0) : \n        \t\t\tcolorId.x < 1.2 ? vec3(0.,.6,.3) : vec3(0,.3,.6);\n        float grid = .7+.3*isGridLine(vec2(colorId.z),vec2(.1))*isGridLine(colorId.xy,vec2(.1));\n        albedo = grid * 2.*col; \n    }       \n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t// specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - map( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd ) {\n    float t0=0.,t1=100.;\n    float t2=0.,t3=100.;\n    // trace only if intersect bounding spheres\n  \n\tfloat t = max(traceStart, min(t2,t0));\n\ttraceEnd = min(traceEnd, max(t3,t1));\n\tfloat h;\n\tfor( int i=0; i < g_traceLimit; i++) {\n\t\th = map( pos+t*ray );\n\t\tif (h < g_traceSize || t > traceEnd)\n\t\t\treturn t>traceEnd?100.:t;\n\t\tt = t+h*.45;\n\t}\n        \n\treturn 100.0;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t / iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n// Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 m = iMouse.xy/iResolution.y - .5;\n\n \tfloat time = 15.0 + iTime;\n\n    \n\n// Positon du point lumineux\n    float distLightRot =  .7;\n                              \n    float lt = 3.*(time-1.);\n    \n   \n    g_lightPos1 = g_posBox + distLightRot*vec3(cos(lt*.5), .4+.15*sin(2.*lt), sin(lt*.5));\n    g_lightPos2 = g_posBox + distLightRot*vec3(cos(-lt*.5), .4+.15*sin(-2.*lt), sin(-lt*.5));\n\t\n\t// Ambiant color\n\tg_envBrightness = vec3(.6,.65,.9);\n    \n// intensitee et couleur du point\n    vec3 lightCol1 = vec3(1.05,.95,.95)*.5;//*.2*g_envBrightness;\n\tvec3 lightCol2 = vec3(.95,1.,1.05)*.5;//*.2*g_envBrightness;\n\t\n\n    \n\tfloat lightRange1 = .4, \n          lightRange2 = .4; \n\tfloat traceStart = .2;\n\n    float t, s1, s2;\n    \n    vec3 col, colorSum = vec3(0.);\n\tvec3 pos;\n    vec3 ro, rd;\n\t\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n        vec2 q = (fragCoord.xy)/iResolution.xy;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n        float randPix = hash(iTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)/float(ANTIALIASING)));        \n    \t// camera\t\n        vec2 q = (fragCoord.xy+subPix)/iResolution.xy;\n#endif\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n\n        float dis = 7.*(1.2+.6*cos(.41*iTime)); \n        ro = vec3( dis*cos(.2*time),6.5, dis*sin(.2*time) );\n        vec3 ta = vec3( -1., 1., 0. );\n\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0);\n\n        // ray direction\n         rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -(ro.y+.5) / rd.y;\n        float traceEnd = min(tGround+1.,100.); \n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        if ( t > tGround ) {\n            pos = ro + rd*tGround;   \n            n = vec3(0,1.,0);\n            t = tGround;\n        } else {\n            pos = ro + rd*t;\n            n = Normal(pos, rd, t);\n        }\n\n        // Shadows\n        vec3 lightDir1 = g_lightPos1-pos;\n        float lightIntensity1 = length(lightDir1);\n        lightDir1 /= lightIntensity1;\n        \n        vec3 lightDir2 = g_lightPos2-pos;\n        float lightIntensity2 = length(lightDir2);\n        lightDir2 /= lightIntensity2;\n\n        s1 = Trace(pos, lightDir1, .04, lightIntensity1 );\n        s2 = Trace(pos, lightDir2, .01, lightIntensity2 );\n\n        lightIntensity1 = lightRange1/(.1+lightIntensity1*lightIntensity1);\n        lightIntensity2 = lightRange2/(.1+lightIntensity2*lightIntensity2);\n\n        col = Shade(pos, rd, n, lightDir1, lightDir2, lightCol1*lightIntensity1, lightCol2*lightIntensity2,\n                    (s1<40.0)?0.0:1.0, (s2<40.0)?0.0:1.0, t );\n\n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum/float(ANTIALIASING);\n#endif\n    \n    // fog\n    float f = 100.0;\n    col = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n    \n    // Draw light\n    s1 = .5*max(dista(ro, rd, g_lightPos1)+.05,0.);\n    float dist = .5*length(g_lightPos1-ro);\n    if (dist < t*.5) {\n        vec3 col1 = 2.*lightCol1*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col1*col1/(1.+s1*s1*s1*BloomFalloff);\n    }\n\n    s2 = .5*max(dista(ro, rd, g_lightPos2)+.05,0.);\n    dist = .5*length(g_lightPos2-ro);\n    if (dist < t*.5) {\n        vec3 col2 = 2.*lightCol2*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col2*col2/(1.+s2*s2*s2*BloomFalloff);\n    }\n        \n    // Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.0);\n    c = sqrt(c*c+.05); // soft abs\n    col = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n    \n\tfragColor =  vec4(pow(col,vec3(1./2.)),1);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXGDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1152, 1223, 1246, 1246, 1284], [1336, 1366, 1405, 1405, 1439], [1441, 1470, 1567, 1567, 1740], [1743, 1867, 1896, 1921, 2254], [2256, 2256, 2281, 2281, 2296], [2353, 2620, 2664, 2664, 2760], [2894, 3092, 3121, 3121, 3297], [3299, 3299, 3337, 3337, 3544], [3547, 3547, 3566, 3566, 4172], [4176, 4253, 4287, 4287, 4372], [4375, 4406, 4431, 4431, 5082], [5085, 5165, 5219, 5219, 5281], [5283, 5283, 5304, 5304, 5401], [5403, 5476, 5641, 5641, 8812], [8815, 8815, 8884, 8884, 9250], [9254, 9254, 9297, 9297, 9765], [9767, 9777, 9819, 9819, 9889], [9892, 9911, 9965, 10036, 10143], [10146, 10146, 10171, 10171, 10240], [10242, 10242, 10293, 10293, 10470]]}
{"id": "wdXGRB", "name": "Timer_Practice", "author": "shuerpiola", "description": "Practicing\n\nSmall graphical glitch goes away on fullscreen mode", "tags": ["practice"], "likes": 2, "viewed": 66, "published": "Public", "date": "1546720721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define COUNTER_TURN // Uncomment to reverse timer direction\n// #define NO_REPEAT // Uncomment to prevent timer looping\n// #define NO_SMOOTHING\n\n#define H_PI 1.57079632679 // Pi/2\n#define TTC 3. // Time to count\n#define OUTER_DIAMETER .9\n#define INNER_DIAMETER .5\n#define BACKGROUND_COLOR vec3(0.,.5,1.)\n#define TIMER_COLOR(A) (mix(vec3(0.,1.,0.),vec3(0.,1.,1.),A)))\n\n#ifndef NO_SMOOTHING\n\t#define TIMER_BODY ((1.-smoothstep(OUTER_DIAMETER-.01,OUTER_DIAMETER,len))*smoothstep(INNER_DIAMETER-.01,INNER_DIAMETER, len))\n#else\n\t#define TIMER_BODY ((1.-step(OUTER_DIAMETER,len))*step(INNER_DIAMETER, len))\n#endif\n\n#ifndef NO_REPEAT\n\t#define REPEATING_TIME (mod(iTime,TTC))\n\t#define REPEATING_COND (step(0.,sin(iTime/TTC*2.*H_PI)))\n#else\n\t#define REPEATING_TIME iTime\n\t#define REPEATING_COND 1.\n#endif\n\n#ifndef COUNTER_TURN\n\t#define SECTOR(X,Y) abs(step(0.,-1.*X)-step(0.,-1.*Y))+(2.*step(0.,-1.*X))\n\t#define CONDITION(X,Y) abs(step(0.,X)-step(0.,Y));\n#else\n\t#define SECTOR(X,Y) abs(step(0.,-1.*Y)-step(0.,X))+(2.*step(0.,X))\n    #define CONDITION(X,Y) abs(1.-step(0.,X)-step(0.,Y))\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float len = length(uv);\n    \n    float cond = CONDITION(uv.x,uv.y);\n    float ang = ((1.-cond)*atan(abs(uv.x/uv.y)))+(cond*atan(abs(uv.y/uv.x)));\n    ang += (H_PI*(SECTOR(uv.x,uv.y)));\n    \n    float nang = ang/(H_PI*4.);\n    float ttime = TTC*nang;\n    float etime = REPEATING_TIME;\n    \n    float rep = REPEATING_COND;\n    float c = TIMER_BODY;\n    c *= rep*(1.-step(ttime,etime))+(1.-rep)*(step(ttime,etime));\n    \n    vec3 col = (c*TIMER_COLOR(nang)+((1.-c)*BACKGROUND_COLOR);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1088, 1145, 1145, 1759]]}
{"id": "wdXGRS", "name": "The Dancefloor", "author": "Peetu", "description": "Some raymarching stuff", "tags": ["raymarching"], "likes": 2, "viewed": 587, "published": "Public", "date": "1546624070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float end = 100.0;\nconst float start = 0.01;\nconst float PI = 3.14159265359;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat r = 0.05;\nfloat sdRoundBox(vec3 p) {\n    return length(max(abs(p) - vec3(.25, 10.5, .25), 0.0)) - r;\n}\n\nfloat c = .68;\nvec4 sceneSDF(vec3 p) {\n    vec3 q = mod(p,c)-0.5*c;\n    vec3 z1 = floor(p / c) + vec3(floor(iTime)) * 25.12;\n    vec3 z2 = floor(p / c) + vec3(floor(iTime) + 1.) * 25.12;\n    q.y = p.y;\n    float d = sdRoundBox(q);\n    \n    vec3 col1 = vec3(\n        rand(z1.xz * 2.14), rand(z1.xz * 3.52), rand(z1.zx * 5.21)\n    );\n    vec3 col2 = vec3(\n        rand(z2.xz * 2.14), rand(z2.xz * 3.52), rand(z2.zx * 5.21)\n    );\n    \n    return vec4(mix(col1, col2, mod(iTime, 1.)), d);\n}\n\nmat3 rotationMatrixY(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nmat3 rotationMatrixX(float rad) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad), -sin(rad)),\n        vec3(0.0, sin(rad), cos(rad))\n    ); \n}\n\nmat3 rotationMatrixZ(float rad) {\n    return mat3(\n        vec3(cos(rad), -sin(rad), 0.0),\n        vec3(sin(rad), cos(rad), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec4 rayMarch(vec3 eye, vec3 rayDir) {\n    float depth = start;\n    for(int i = 0; i < 255; i++) {\n   \t\tvec4 data = sceneSDF(eye + rayDir * depth);\n        float dist = data.w;\n        \n        if(dist < EPSILON){\n \t      \treturn vec4(data.xyz, depth);   \n        }else if(depth >= end) {\n        \treturn vec4(vec3(0.0), end);   \n        }\n        \n        depth += dist;\n    }\n    return vec4(vec3(0.0), end);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float E = 0.1;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + E, p.y, p.z)).w - sceneSDF(vec3(p.x - E, p.y, p.z)).w,\n        sceneSDF(vec3(p.x, p.y + E, p.z)).w - sceneSDF(vec3(p.x, p.y - E, p.z)).w,\n        sceneSDF(vec3(p.x, p.y, p.z + E)).w - sceneSDF(vec3(p.x, p.y, p.z - E)).w\n    ));\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float t = iTime * 0.1;\n    float rSine = 0.6 * sin(3. * t) + 1.6 * sin(0.7 * t) - 2.1 * sin(0.2 * t);\n    \n    \n\tmat3 rot = rotationMatrixY(rSine) * rotationMatrixX(0.5);\n    \n    vec3 eye = vec3(0.0, 14.0, 5. - iTime);\n    vec3 rayDir = rot * rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec4 data = rayMarch(eye, rayDir);\n    float depth = data.w;\n    \n    vec3 col;\n   \n   \tif(depth >= end - EPSILON) {\n    \tcol = vec3(0.);\n    }else{\n        vec3 normal = estimateNormal(eye + depth * rayDir);\n        vec3 light = vec3(-1.0, -.4, .9) * rotationMatrixY(0.5);\n        float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * .8;\n        \n        vec3 viewDir = normalize(-rayDir);\n\t\tvec3 reflectDir = reflect(light, normal);  \n        float specular = pow(max(dot(viewDir, reflectDir) * .75, 0.0), 8.) * .5;\n        float i = 0.1 + diffuse + specular;\n        col = data.xyz * i;\n    }\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 134, 134, 206], [224, 224, 250, 250, 316], [333, 333, 356, 356, 805], [807, 807, 840, 840, 973], [975, 975, 1008, 1008, 1142], [1144, 1144, 1177, 1177, 1310], [1312, 1312, 1350, 1350, 1724], [1726, 1726, 1755, 1755, 2059], [2061, 2061, 2118, 2118, 2242], [2244, 2244, 2301, 2351, 3336]]}
{"id": "wdXGzj", "name": "Raymarched Sphere.", "author": "caseymacneil", "description": "sphere", "tags": ["3d", "raymarching", "sdf", "sphere"], "likes": 2, "viewed": 87, "published": "Public", "date": "1546873983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 512\n#define MAXDIST 200.\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n)\n{\n\tn = normalize(n);\n\treturn dot(p, n.xyz)+1.;\n}\n\nvec3 opRep(vec3 p, vec3 r)\n{\n\treturn mod(abs(p),r)-.5*r;\n}\n\nfloat map(vec3 p)\n{\n\treturn min(sdSphere(opRep(vec3(0.0,0.,0.0)-p,vec3(10.,0.,10.)),1.0),sdPlane(vec3(0.,0.,0.)-p,vec3(0.,-1.,0.)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n// soft shadow function by iq\n//http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n//\n\n// taken from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.00 + 0.15*float(i)/4.0;\n        float d = map(p + h*n);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 1.5 * occ, 0.1, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up camera\n    vec2 sp =  (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(sin(iTime*.5)*2.,3.,4.);\n    vec3 rd = normalize(vec3(sp,-2.));\n    //\n\t\n    vec3 lightDir = normalize(vec3(sin(iTime),sin(iTime*2.)*.5 + .75,cos(iTime)));\n\n    vec3 col = vec3(0.3,0.5,0.8);\n   \t\n    // sun\n    col += vec3(pow(max(dot(rd,lightDir),0.),80.));\n    \n    float t = 0.;\n    \n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n    \tvec3 p = ro + rd * t;\n        float d = map(p);\n        \n        if(t > MAXDIST) break;\n        \n        // draw\n        if(d < 0.001)\n        {\n            vec3 n = calcNormal(p);\n            float NDotL = dot(n,lightDir);\n            float iNDotL = dot(n,-lightDir);\n            NDotL = max(NDotL,0.);\n           \tiNDotL = max(iNDotL,0.);\n            float shadow = softshadow(p,lightDir,.1,16.,16.)+.4;\n            \n            // fresnel\n            float NDotV = dot(n, rd); \n            float fscale= 2.;\n            float fpow  =2.;\n            float fbump = -.7;\n            float f = 1.-pow(NDotV,fpow) * fscale;\n            f = max(f+fbump,0.);\n            \n            float occ = calcAO(p,n);\n            \n            \n        \tcol = vec3(NDotL+.1) * shadow * occ;\n            col += f *(shadow+.5);\n            //col = n;\n            break;\n        }\n        \n        t += d;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 76, 76, 101], [103, 103, 134, 134, 181], [183, 183, 211, 211, 241], [243, 243, 262, 262, 377], [379, 379, 407, 407, 643], [645, 740, 817, 817, 1145], [1150, 1202, 1232, 1232, 1479], [1481, 1481, 1538, 1559, 2932]]}
{"id": "ws23DD", "name": "Cartesian to L1 Polar", "author": "paniq", "description": "Demonstrating how cartesian coordinates can be mapped to circles using L1-norm distances (see cart2rad())", "tags": ["polar", "cartesian", "l1"], "likes": 11, "viewed": 722, "published": "Public API", "date": "1548964544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\nvoid modulate(vec2 h);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvoid reddot(vec2 d) {\n    const float R = 0.02;\n    set_source_rgba(vec4(vec3(1.0,0.0,0.0),1.0));\n    circle(d,R);\n    fill();\n}\n\nvoid bludot(vec2 d) {\n    const float R = 0.02;\n    //set_source_rgba(vec4(vec3(0.0,0.0,1.0),1.0));\n    circle(d,R);\n    fill();\n}\n\nfloat sawsin(float x) {\n    return 4.0 * abs( floor(x + 0.5 - 0.75) - x + 0.75) - 1.0;\n}\n\nfloat sawcos(float x) {\n    return -4.0 * abs( floor(x + 0.5) - x) + 1.0;\n}\n\nconst float PI = 3.14159;\n\nfloat L1sinc(float x) {\n    if (x == 0.0) return PI / 2.0;\n    return sin(2.0 * PI * x) / (4.0 * x);\t\n}\n\nfloat L1L2cos(float x) {\n\treturn L1sinc(mod(x,0.5) - 0.25);\n}\n\nfloat L1L2sin(float x) {\n\treturn L1L2cos(x + 0.25);\n}\n\nfloat Lsin(float x) {\n\treturn sawsin(x)*mix(1.0, L1L2sin(x), sin(iTime)*0.5+0.5);\n}\n\nfloat Lcos(float x) {\n\treturn sawcos(x)*mix(1.0, L1L2cos(x), sin(iTime)*0.5+0.5);\n}\n\nvoid cdist(vec2 c, float r, int i, float ph) {\n\tset_line_width_px(1.0);\n    set_source_rgba(0.0,0.0,0.0,0.6);\n    float iph = 1.0 / float(i);\n    float n0 = ph * iph;\n    move_to(r * vec2(Lcos(n0),Lsin(n0)));\n    for (int k = 1; k <= i; ++k) {\n    \tfloat n = (float(k) + ph) * iph;\n        line_to(r * vec2(Lcos(n),Lsin(n)));\n    }\n    stroke();\n    for (int k = 0; k < i; ++k) {\n    \tfloat n = (float(k) + ph) * iph;\n        reddot(r * vec2(Lcos(n),Lsin(n)));\n    }\n}\n\nconst float radius = 0.07;\n\nvec2 cart2rad(vec2 p) {\n    float n = abs(p.x) + abs(p.y);\n    float i = 0.0;\n    if (p.x < 0.0) {\n        // works also for \n        i = 2.0*n - p.y;\n    } else {\n        i = p.y;\n    }\n    float nc = max(1.0,n)*4.0;\n    float r = n*radius;\n    float ph = mod(i / nc,1.0);\n    //ph = ph * 2.0 * 3.1415926;\n    return r * vec2(Lcos(ph), Lsin(ph));\n}\n\nvoid paint() {\n    float t = iTime;\n\n\n    set_source_rgba(vec4(1.0));\n    clear();\n\n    set_line_width_px(1.0);\n    set_source_rgba(0.0, 0.0, 0.0, 1.0);\n\n    float k = 0.0;\n    int n0 = 0;\n    int n1 = 1;\n    for (int i = 0; i < 10; ++i) {\n    \tint n2 = n0 + n1;\n        n0 = n1; n1 = n2;\n        cdist(vec2(0.0), k, max(1,i*4), 0.0); \n        k = k + radius;\n    }\n #if 1   \n    for (int y = -9; y < 9; ++y) {\n        for (int x = -9; x < 9; ++x) {\n            int mx = max(abs(x),abs(x+1));\n            int my = max(abs(y),abs(y+1));\n            if ((abs(mx)+abs(my)) > 9)\n                set_source_rgba(0.0,0.0,1.0,0.3);\n            else\n            \tset_source_rgba(0.0,0.0,1.0,1.0);              \n            move_to(cart2rad(vec2(x,y)));\n            line_to(cart2rad(vec2(x+1,y)));\n            line_to(cart2rad(vec2(x+1,y+1)));\n            line_to(cart2rad(vec2(x,y+1)));\n            close_path();\n            stroke();\n            if ((abs(x)+abs(y)) >= 9)\n                set_source_rgba(0.0,0.0,1.0,0.3);\n            else\n            \tset_source_rgba(0.0,0.0,1.0,1.0);              \n            bludot(cart2rad(vec2(x,y)));\n        }\n    }\n    #endif\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nvoid modulate(vec2 h) {\n\t_stack.position = mod(_stack.position, h.xyxy);\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5987, 6071, 6092, 6092, 6199], [6201, 6201, 6222, 6222, 6331], [6333, 6333, 6356, 6356, 6421], [6423, 6423, 6446, 6446, 6498], [6527, 6527, 6550, 6550, 6630], [6632, 6632, 6656, 6656, 6693], [6695, 6695, 6719, 6719, 6748], [6750, 6750, 6771, 6771, 6833], [6835, 6835, 6856, 6856, 6918], [6920, 6920, 6966, 6966, 7388], [7418, 7418, 7441, 7441, 7767], [7769, 7769, 7783, 7783, 8931], [9108, 9168, 9195, 9195, 9221], [9223, 9283, 9304, 9304, 9411], [9413, 9413, 9450, 9450, 9536], [9538, 9538, 9584, 9584, 9617], [9619, 9757, 9785, 9785, 10245], [10273, 10273, 10292, 10292, 10325], [10327, 10327, 10345, 10345, 10378], [10380, 10380, 10404, 10404, 10508], [10510, 10510, 10533, 10533, 10584], [10586, 10586, 10603, 10603, 10624], [10626, 10626, 10653, 10675, 10958], [10960, 10960, 10988, 10988, 11222], [11224, 11224, 11248, 11248, 11334], [11336, 11336, 11363, 11363, 11576], [11578, 11578, 11604, 11604, 11832], [11834, 11834, 11856, 11856, 11982], [11984, 11984, 12004, 12004, 12064], [12066, 12066, 12098, 12098, 12125], [12127, 12127, 12148, 12148, 12170], [12172, 12172, 12196, 12196, 12256], [12258, 12258, 12292, 12292, 12316], [12318, 12318, 12332, 12332, 12396], [12398, 12398, 12424, 12424, 12462], [12464, 12464, 12490, 12490, 12511], [12513, 12513, 12536, 12536, 12631], [12633, 12633, 12657, 12657, 12726], [12728, 12728, 12753, 12753, 12800], [12802, 12802, 12819, 12819, 12932], [12934, 12934, 12957, 12957, 13086], [13088, 13088, 13116, 13116, 13244], [13246, 13246, 13270, 13270, 13410], [13412, 13412, 13450, 13450, 13584], [13586, 13586, 13623, 13623, 13658], [13660, 13660, 13687, 13687, 13737], [13739, 13739, 13769, 13769, 13825], [13827, 13827, 13856, 13856, 14037], [14039, 14039, 14061, 14061, 14228], [14230, 14230, 14243, 14243, 14282], [14284, 14284, 14314, 14314, 14343], [14345, 14345, 14378, 14378, 14435], [14437, 14437, 14463, 14463, 14513], [14515, 14515, 14536, 14536, 14601], [14603, 14603, 14627, 14627, 14710], [14712, 14712, 14727, 14727, 14768], [14770, 14770, 14786, 14786, 14824], [14826, 14826, 14844, 14844, 14901], [14903, 14903, 14933, 14955, 15337], [15339, 15339, 15397, 15397, 15435], [15437, 15437, 15466, 15466, 15502], [15504, 15504, 15552, 15552, 15583], [15585, 15585, 15619, 15619, 15678], [15680, 15680, 15757, 15757, 15922], [15924, 15924, 16001, 16001, 16081], [16083, 16083, 16159, 16159, 16275], [16277, 16277, 16353, 16353, 16431], [16433, 16433, 16471, 16471, 16505], [16507, 16507, 16529, 16529, 16575], [16577, 16577, 16604, 16604, 16648], [16650, 16650, 16672, 16672, 17066], [17068, 17068, 17097, 17097, 17125], [17127, 17127, 17176, 17176, 17437], [17439, 17439, 17512, 17512, 17566], [17568, 17568, 17600, 17600, 17636], [17638, 17638, 17694, 17694, 17750], [17752, 17752, 17782, 17782, 17875], [17876, 17876, 17916, 17916, 17939], [17941, 17987, 18026, 18026, 19182], [19184, 19184, 19214, 19214, 19316], [19318, 19318, 19370, 19370, 19410], [19412, 19412, 19434, 19434, 19485], [19487, 19487, 19519, 19519, 19541], [19543, 19558, 19580, 19580, 19872], [19874, 19874, 19906, 19906, 19928], [19930, 19930, 19949, 19949, 19981], [20030, 20093, 20135, 20135, 20201], [20203, 20273, 20324, 20324, 20676], [20678, 20712, 20758, 20758, 21270], [21272, 21341, 21387, 21387, 21893], [21895, 21895, 21928, 21928, 22144], [22146, 22146, 22205, 22205, 22250], [22252, 22252, 22295, 22295, 22356], [22358, 22358, 22400, 22400, 22442], [22444, 22504, 22561, 22561, 22760]]}
{"id": "Ws23R1", "name": "Boom boom", "author": "Sabouh", "description": "Sphere pulsing.", "tags": ["pulse", "sphere", "disk"], "likes": 2, "viewed": 70, "published": "Public", "date": "1548164754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord-.5*iResolution.xy )/iResolution.y;\n\n    // Time varying pixel color\n     vec3 col = 0.5+ 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float ray = iResolution.x*10.;\n    vec2 center= vec2(iResolution.x/2.,iResolution.y/2.);\n    float  xa =(fragCoord.x - center.x)*(cos(iTime));\n    float xb = (fragCoord.y - center.y)*(cos(iTime));\n    \n    if( ( xa*xa + xb*xb ) <= ray){\n         col = 0.5+ 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 618]]}
{"id": "ws23RR", "name": "A Sphere", "author": "valler", "description": "A sphere", "tags": ["ray", "sphere", "distance", "field", "march"], "likes": 1, "viewed": 59, "published": "Public", "date": "1548092890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, in vec2 a )\n{\n    vec3 o = vec3(sin(iTime),2.3,cos(iTime));\n    vec3 w = normalize(-o);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n\tvec3 d = mat3(u,cross(u,w),w)*\n        normalize(vec3((2.*a-iResolution.xy)/max(iResolution.x,iResolution.y),.25));\n    float t = 0., e = 1.e-4, m = 5., h = 1.;\n    while (t < m && h > e)\n    {\n        h = length(o+d*t+vec3(0,0,1))-2.;\n        t = min(m,t+h);\n    }\n    c = vec4(.2*t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 450]]}
{"id": "ws23Rw", "name": "LSD Fires Your Brain", "author": "ReavenTehDerg", "description": "Some cool effect i learnt how to make yesterday.Made it extra trippy :)", "tags": ["trippy", "cirlcles", "psychedeilic"], "likes": 3, "viewed": 110, "published": "Public", "date": "1548499254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float xor(float a, float b)\n{\n    return a * (1. - b) + b * (1.0 - a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n\n    float a = iTime * 0.3;\n    float s = sin(a);\n    float c = cos(a);\n\n\n    uv *= mat2(c, -s, s, c);\n    uv *= mix(15.0, 20.0,sin(iTime) * 0.5 + 0.5);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    float m = 0.0;\n    float t = iTime;\n\n    for(float y = -1.; y <= 1.0; y++)\n    {\n        for(float x = -1.; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n            float d = length(gv - offs);\n            float dist = length(id + offs) * 0.3;\n\n            float r = mix(.3, 1.5, sin(dist - t) * 0.5 + 0.5);\n            m = xor(m, smoothstep(r, r * 0.9, d)) * 1.2;\n        }\n    }\n    col += m;\n\n    float uvL = length(uv) / 4.;\n    col *= vec3(uvL * sin(iTime * 2.) * 0.5 + 0.5, uvL * cos(iTime * 4.) * 0.5 + 0.5,uvL * sin(iTime * 6.) * 0.5 + 0.5);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 72], [74, 74, 131, 131, 1041]]}
{"id": "Ws23WD", "name": "Molten core", "author": "LordSk", "description": "A simple deformed sphere.", "tags": ["raymarching", "lava"], "likes": 6, "viewed": 457, "published": "Public", "date": "1548906358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (3.14159265358979323846)\n#define EPSILON (0.0001)\n\nvec2 rotate(vec2 v, float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  return vec2(\n    v.x*c-v.y*s,\n    v.x*s+v.y*c\n  );\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat scene(vec3 p)\n{\n  float b = sphere(p, 1.6);\n  if(b > 0.001) return b; // optimisation\n\n  vec3 disp = vec3(0);\n  float f = 0.5;\n  disp.x = texture(iChannel0, p.zy * 0.05 + iTime * 0.02).x * f;\n  disp.z = texture(iChannel0, p.xy * 0.05 + iTime * 0.03).z * f;\n  disp.y = texture(iChannel0, p.xz * 0.05 + iTime * 0.04).y * f;\n\n  return sphere(p + disp, 1.0 + sin(iTime*2.4) * 0.15);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = vec3(0, -0.15, -3.5);\n  vec3 dir = normalize(vec3(uv,1));\n\n  float cam_a2 = sin(iTime) * pi * 0.1;\n  cam.yz = rotate(cam.yz, cam_a2);\n  dir.yz = rotate(dir.yz, cam_a2);\n\n  float cam_a = iTime * pi * 0.1;\n  cam.xz = rotate(cam.xz, cam_a);\n  dir.xz = rotate(dir.xz, cam_a);\n\n  vec3 color = vec3(0.16, 0.12, 0.10);\n  float t = 0.00001;\n  const int maxSteps = 128;\n  for(int i = 0; i < maxSteps; ++i) {\n      vec3 p = cam + dir * t;\n      float d = scene(p);\n\n      if(d < 0.0001 * t) {\n          color = vec3(1.0, length(p) * (0.6 + (sin(iTime*3.0)+1.0) * 0.5 * 0.4), 0);\n          break;\n      }\n\n      t += d;\n  }\n\n  fragColor.rgb = color;\n  fragColor.a = 1.0;\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws23WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 92, 92, 187], [189, 189, 220, 220, 244], [246, 246, 267, 267, 632], [634, 634, 691, 691, 1504]]}
{"id": "ws23Wz", "name": "FlyingLines", "author": "Sevapp", "description": "FlyingLines", "tags": ["raymarching"], "likes": 2, "viewed": 149, "published": "Public", "date": "1548656646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float minDrawDist = 0.0;\nconst int   maxRayMarcs = 500;\nconst float cellSize    = 900.0;\nconst float ballRadius  = 120.0;\nvec4 color;\nvec3 camPos;\n\n// Thank, Íñigo Quílez...)\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat getDist(vec3 rayPos)\n{\n    rayPos.x -= sin(iTime) * 800.0;\n    rayPos.y -= cos(iTime) * 800.0;\n    rayPos.z += float(iFrame) * 20.0;\n    \n    vec3 vc = camPos + floor(-((camPos - rayPos) - ballRadius) / cellSize) * cellSize;\n    vec3 vl = vc; vl.x -= cellSize;\n    vec3 vr = vc; vr.x += cellSize;\n    vec3 vu = vc; vu.y -= cellSize;\n    vec3 vd = vc; vd.y += cellSize;\n    vec3 vb = vc; vb.z -= cellSize;\n    vec3 vf = vc; vf.z += cellSize;\n    \n    float r    = 50.0;\n    float dist = min(\n        min(\n            sdCapsule(rayPos, vl, vr, r),\n            sdCapsule(rayPos, vu, vd, r)\n        ),  sdCapsule(rayPos, vb, vf, r)\n    );\n    \n    float distToBall = distance(vc, rayPos) - ballRadius;\n    \n    if (distToBall <= 0.1) {\n        dist = distToBall;\n        color = vec4(abs(atan(iTime)), 0, abs(tan(iTime)), 1.0);\n    }\n    \n\treturn dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    const vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n\t    getDist(p - e.xyy),\n\t    getDist(p - e.yxy),\n\t    getDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 outputPixel = vec4(0.0);\n\t\n\tvec2 position = gl_FragCoord.xy;\n\t\n\tcamPos = vec3(\n\t\tiResolution.x / 2.0, \n\t\tiResolution.y / 2.0, \n\t\t-600.0\n\t);\n\t    \n\tvec3 rayPos = vec3(position, 0.0);\n\tvec3 rayVec = normalize(rayPos - camPos);\n\t\n\tcolor = vec4(abs(cos(iTime)), .2, abs(sin(iTime)), 1.0);\n\t\n\tvec3 curRayPos = rayPos * minDrawDist;\n\tfor (int i = 0; i < maxRayMarcs; i ++)\n\t{ \n\t\tfloat distToBall = getDist(curRayPos);\n\t\tif (distToBall < .1)\n\t\t{\n\t\t\tvec3  normal = getNormal(curRayPos);\n            float light  = dot(normalize(camPos - curRayPos), normal);\n           \t\n            light = clamp(light, 0.0, 1.0) + 0.02;\n\t\t\tlight *= 1000000.0 / pow(abs(curRayPos.z - camPos.z), 2.0);\n\t\t\toutputPixel = pow(light, 1.0 / 1.8) * color;\n\t\t\tbreak;\n\t\n\t\t} else\n\t\t{\n\t\t\tcurRayPos += rayVec * 30.0;\n\t\t}\n\t}\n\t\n\tfragColor = outputPixel;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws23Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 184, 236, 236, 363], [365, 365, 393, 393, 1221], [1223, 1223, 1247, 1247, 1450], [1452, 1452, 1509, 1509, 2333]]}
{"id": "Ws23zz", "name": "LAMENTEVIRTUAL", "author": "mynorarriaga", "description": "CRISTOMISUPERHEREO", "tags": ["httpswwwshadertoycommediaap94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0png"], "likes": 1, "viewed": 82, "published": "Public", "date": "1548010672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws23zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "ws2GRm", "name": "Candyland Steps", "author": "Elyxian", "description": "Raymarching a stepped noise function. Because the heightmap has infinitely steep sections, a maximum step size is enforced on the raymarching, with some interval bisection stuff to prevent overstepping. This gives pretty good (but imperfect) results.", "tags": ["raytracing", "raymarching", "canyon"], "likes": 7, "viewed": 182, "published": "Public", "date": "1548556368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPHEIGHT 1.0\n#define HSCALE 0.5\n#define VSCALE 8.0\n\n//#define STEPHEIGHT 0.2\n//#define HSCALE 0.3\n//#define VSCALE 2.0\n\nfloat saturate(float t) {return clamp(t, 0.0, 1.0);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n// RGB and HSV Conversion from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n\nvec3 increaseSaturation(vec3 c) {\n\t\n    float strength = 1.15;\n    \n    // Convert to hsv\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    vec3 hsv = vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    \n    // Increase saturation\n    hsv.y *= strength;\n    saturate(hsv.y);\n    \n    // Convert to rgb\n    vec4 K2 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p2 = abs(fract(hsv.xxx + K2.xyz) * 6.0 - K2.www);\n    vec3 rgb = hsv.z * mix(K2.xxx, clamp(p2 - K2.xxx, 0.0, 1.0), hsv.y);\n    \n    return rgb;\n\n}\n\n// Hash function by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    \n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\n// Standard value noise function\n\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}\n\n// The heightmap is 2d value noise but filtered into 'steps'\n\nfloat heightMap(vec2 p) {\n\t\n    float height = valueNoise(p * HSCALE) * VSCALE;\n    height = floor(height / STEPHEIGHT) * STEPHEIGHT;\n    return height;\n    \n}\n\nfloat raytrace(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 500;\n    float maxStepDist = 0.12;\n    float maxDist = 100.0;\n    int maxIterations = 10;\n    float eps = 0.01;\n    \n    // Initial Raymarching Steps\n    bool didHit = false;\n    float beforeDist = -1.0;\n    float afterDist = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < maxSteps && t < maxDist; i++) {\n        \n        beforeDist = afterDist;\n        afterDist = t;\n    \tvec3 p = ro + t * rd;\n        float height = heightMap(p.xz);\n        if (p.y - height < eps) {\n\t\t\tdidHit = true;\n            break;\n        }\n        \n        // Normally raymarching would just be done using 'p.y - height', however this does not\n        // take into account the proximity to the nearest cliff. To account for this, a maximum\n        // step size is imposed. Additionally, if the ray is currently above the maximum height\n        // of the heightmap, it can safely move forward by the distance to the top of the heightmap\n        //t += min(p.y - height, maxStepDist);\n        t += max(min(p.y - height, maxStepDist), p.y - VSCALE);\n        \n    }\n    if (!didHit) {\n    \treturn -1.0;\n    }\n    \n    // Use the interval bisection method to find a closer point, as moving forward by a fixed step\n    // size may have embedded the ray in a cliff\n    for (int i = 0; i < maxIterations; i++) {\n    \tfloat midVal = (beforeDist + afterDist) / 2.0;\n        vec3 p = ro + midVal * rd;\n        if (p.y < heightMap(p.xz)) {\n        \tafterDist = midVal;\n        }\n        else {\n        \tbeforeDist = midVal;\n        }\n    }\n    \n    // Return the midpoint of the closest point before the terrain, and the closest point after it\n    return (beforeDist + afterDist) / 2.0;\n    \n\n}\n\n/*vec3 getNormal(vec3 p) {\n    \n    // Central differences method to generate a normal vector\n    // This is imperfect for this non-continuous heightmap, and I believe\n    // this is the cause of the bad normal lighting\n    vec2 eps = vec2(0.005, 0.00);\n    vec3 normal = vec3(\n    \theightMap(p.xz + eps.xy) - heightMap(p.xz - eps.xy),\n\t\t2.0 * eps.x,\n\t\theightMap(p.xz + eps.yx) - heightMap(p.xz - eps.yx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}*/\n\nvec3 getNormal(vec3 p) {\n    \n    // This is a somewhat hacky way of getting the normal for this heightmap\n    // The above getNormal function is imperfect due to the non-continous heightmap\n    \n    // Get the normal of the value noise (not the stepped heightmap)\n    \n    vec2 eps = vec2(0.005, 0.00);\n    vec3 normal = vec3(\n    \t(valueNoise((p.xz + eps.xy) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.xy) * HSCALE) * VSCALE),\n\t\t2.0 * eps.x,\n\t\t(valueNoise((p.xz + eps.yx) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.yx) * HSCALE) * VSCALE)\n    );\n    \n    // Work out whether the point is in a horizontal or vertical section\n    float stepEps = 0.012;\n    float stepSection = mod(p.y / STEPHEIGHT, 1.0);\n    bool isOnCliff = true;\n    if (stepSection < stepEps || stepSection > (1.0 - stepEps)) {\n    \tisOnCliff = false;\n    }\n    \n    // Adjust the normal accordingly\n    if (isOnCliff) {\n    \tnormal = vec3(normal.x, 0.0, normal.z);\n    }\n    else {\n    \tnormal = vec3(0.0, 1.0, 0.0);\n    }\n    \n    // Normalise and return the normal\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getDiffuse(vec3 p) {\n    \n    // Get which band the point belongs to\n    float eps = 0.01;\n    p.y += eps;\n    float height = floor(p.y / STEPHEIGHT) * STEPHEIGHT;\n    \n    // Color function from iq: https://www.shadertoy.com/view/Xds3zN\n    vec3 col = 0.45 + 0.35*sin(vec3(0.15,0.08,0.10)*(height*124.2));\n    \n    // Increase saturation\n    col = increaseSaturation(col);\n    \n    // Darken the lower colors\n    col = mix(vec3(0.0), col, 0.1 + 0.9 * (height / VSCALE));\n    \n    return col;\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(0.8, 1.0, -0.8));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = max(0.05, saturate(dot(normal, lightDir)));\n    //float normalLight = max(0.1, step(0.5, dot(normal, lightDir)));\n    lightCol *= normalLight;\n    \n    // Gets the diffuse lighting\n    vec3 diffuse = getDiffuse(p);//vec3(0.368, 0.372, 0.901);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    vec3 skyCol = vec3(0.9, 0.9, 0.9);\n    float fogFalloff = 0.1;\n    float fogDist = 90.0;\n    \n    float t = raytrace(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    // If the terrain is hit\n    if (t >= 0.0) {\n    \t\n        // Get the color of the terrain\n        col = getColor(ro + t * rd);\n        \n        // Add the fog (better fog functions exist though)\n        float fogAmount = exp(fogFalloff * (t - fogDist));\n        col = mix(col, skyCol, fogAmount);\n        \n    }\n    \n    // If the terrain is not hit\n    else {\n        col = skyCol;\n    }\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, VSCALE + 2.0, 0.0) + vec3(1.0, 0.0, 1.0) * iTime * 0.5;\n    vec3 rd = normalize(vec3(p, 1.4));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.16, -0.1):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 130, 155, 155, 182], [183, 183, 204, 204, 256], [258, 366, 399, 399, 1099], [1101, 1174, 1196, 1196, 1324], [1326, 1360, 1386, 1386, 1680], [1682, 1744, 1769, 1769, 1903], [1905, 1905, 1939, 1959, 3639], [3641, 4114, 4138, 4378, 5215], [5217, 5217, 5242, 5290, 5721], [5723, 5723, 5746, 5780, 6509], [6511, 6511, 6542, 6542, 7128], [7131, 7131, 7188, 7225, 8072]]}
{"id": "ws2GRw", "name": "Trippy Circle Shader", "author": "koi", "description": "Playing around with separate time offsets for each color channel.", "tags": ["circles", "animated", "trippy"], "likes": 5, "viewed": 147, "published": "Public", "date": "1548482704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - iResolution.xy / 2.0;\n    coord /= iResolution.x;\n    \n    vec2 offset = round(coord / 0.025) * 0.025;\n    vec4 col = vec4(0.0);\n    \n    for(int i = 0; i < 3; i++) {\n        float t = iTime + float(i)*2.1 + (abs(coord.x) + abs(coord.y))*10.0;\n        float r = (pow(sin(t), 3.0) + 1.0) * 0.02;\n        \n        if(length(coord - offset) < r) {\n           col[i] = 1.0;\n        }\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 500]]}
{"id": "ws2GzD", "name": "oliwia", "author": "oliwiajaworska", "description": "Piłeczka poruszająca się po krawędzi", "tags": ["pileczkanakrawedzi"], "likes": 2, "viewed": 49, "published": "Public", "date": "1548363380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Wyznaczam środek ekrani\n    vec2 zero = iResolution.xy/2.0;\n    vec3 col;\n    //defniniuję kolory, dla tła gradient zależny od czasu:\n    vec3 background = vec3(((sin(iTime/5.0)+1.0)/2.0), fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    //Ciemnoszary dla koloru linii\n    vec3 line = vec3(0.1, 0.1, 0.1);\n    //Zielony dla kuleczki\n    vec3 ball = vec3(0.2, 0.9, 0.0);\n    //Białawy dla drogi\n    vec3 road = vec3(0.9, 0.9, 0.9);\n    //Określam położenie piłeczki\n    vec2 ballvec = vec2(zero.x-(sin((sin(iTime/4.0)*50.0+100.0)/20.0+iTime*3.0)*110.0), sin(iTime/4.0)*50.0+110.0);\n    //Ustawiam domyślny kolor piksela jako kolor tła\n    col = background;\n    //Rysuję piłeczkę pierwszą (na ostatnim planie) kiedy jest po lewej stronie\n    if (length(fragCoord-ballvec)<10.0 && sin((sin(iTime/4.0)*50.0+100.0)/20.0+iTime*3.0) >= 0.0) {col = ball;}\n    //Tworzę drogę\n    if (fragCoord.y <= iResolution.y/2.0){\n        //Określam ruchy obydwu krawędzi drogi\n        float x1 = zero.x-fragCoord.x-(sin(fragCoord.y/20.0+iTime*3.0)*100.0);\n        float x2 = zero.x-fragCoord.x-(sin(fragCoord.y/20.0+iTime*3.0)*120.0);\n        //Warunkuję kolorowanie drogi przez znajdowanie się pomiędzy granicami\n        if (fragCoord.x-zero.x > x2*100.0 && fragCoord.x-zero.x < x1*110.0 || fragCoord.x-zero.x < x2*100.0 && fragCoord.x-zero.x > x1*110.0)col=road;\n        //Koloruję obrys drogi\n        if (abs(x1)<2.0 || abs(x2)<2.0){\n            col=line;\n        }\n    }\n    //Maluję piłeczkę ostatnią (na pierwszym planie) kiedy jest po prawej stronie\n    if (length(fragCoord-ballvec)<10.0 && sin((sin(iTime/4.0)*50.0+100.0)/20.0+iTime*3.0) <= 0.0) {col = ball;}\n    //Uzupełniam obraz\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2GzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 88, 1806]]}
{"id": "Ws2Gzw", "name": "domain repetition - lab", "author": "yashgugale", "description": "domain repetition", "tags": ["domainrepetition"], "likes": 1, "viewed": 94, "published": "Public", "date": "1548446277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Generate periodic coordinates from p.\n//Coords repeat in x,y with period c.x, c.y\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n// signed distance to a regular octogon\nfloat sdOctogon( in vec2 p, in float r )\n{\n  // pi/8: cos, sin, tan.\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n\n  // reflections\n  p = abs(p);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    \n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy -vec2(1.0);\n    \n    //Generate periodic coords\n    vec2 rep_uv = opRep(uv, vec2(0.5));\n    \n    //Pass periodic coords to distnace function to create repeating shape\n    float d = sdOctogon(rep_uv, 0.2);\n\n    vec3 col = vec3(smoothstep(0.0, 1.0, d)*iTime*10.0) * vec3(0.4, 0.9, 0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2Gzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 84, 119, 119, 148], [151, 191, 233, 259, 678], [680, 680, 737, 788, 1174]]}
{"id": "wsB3DR", "name": "emit fractal", "author": "ukeyshima", "description": "emit fractal", "tags": ["fractal"], "likes": 0, "viewed": 115, "published": "Public", "date": "1548582723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nconst vec3 cPos = vec3(0.0, 0.0, -2.0);\nconst vec3 cDir = vec3(0.0, 0.0, 1.0);\nconst vec3 cUp = vec3(0.0, 1.0, 0.0);\nconst float depth = 1.0;\nconst vec3 lPos = vec3(10.0, 10.0, -10.0);\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m =\n      mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s,\n           a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s,\n           a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n  return m * p;\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nfloat fractal(vec3 p) {\n  float result = 100.0;\n  for (float i = 0.0; i < 10.0; i++) {\n    p = rotate(p, iTime, vec3(0.2, 0.3, 0.5));\n    result = min(result, sphere(p, exp(-i / 1.2)));\n    result =\n        max(result, -sphere(p, exp(-i / 1.2 * abs(1.5 * sin(iTime / 2.0)))));\n    p = abs(p) - exp(-i / 1.2) / 2.0;\n  }\n  return result;\n}\n\nfloat distFunc(vec3 p) { return fractal(p); }\n\nvec3 getNormal(vec3 p) {\n  float d = 0.001;\n  return normalize(\n      vec3(distFunc(p + vec3(d, 0.0, 0.0)) - distFunc(p + vec3(-d, 0.0, 0.0)),\n           distFunc(p + vec3(0.0, d, 0.0)) - distFunc(p + vec3(0.0, -d, 0.0)),\n           distFunc(p + vec3(0.0, 0.0, d)) - distFunc(p + vec3(0.0, 0.0, -d))));\n}\n\nvec3 rayMarching(vec3 color, vec2 p) {\n  vec3 cSide = cross(cDir, cUp);\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n  vec3 rPos = cPos;\n  float rLen = 0.0;\n  for (float i = 0.0; i < 22.0; i++) {\n    float distance = distFunc(rPos);\n    color = clamp(vec3(0.8, 0.2, 0.6) / distance, 0.0, 1.0);\n    if (distance < 0.01) {\n      vec3 normal = getNormal(rPos);\n      float diffuse = clamp(dot(normal, -lPos), 0.0, 1.0) + 0.03;\n      color = (color / diffuse / 50.0);\n      break;\n    }\n    rLen += distance;\n    rPos = cPos + rLen * ray;\n  }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color = rayMarching(vec3(0.0), p);\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsB3DR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 252, 252, 619], [621, 621, 652, 652, 676], [678, 678, 701, 701, 1015], [1017, 1017, 1041, 1041, 1062], [1064, 1064, 1088, 1088, 1368], [1370, 1370, 1408, 1408, 1945], [1947, 1947, 2002, 2002, 2170]]}
{"id": "WsB3Rz", "name": "Raining Spheres", "author": "Elyxian", "description": "Attempting to create a sparse distance field of 'randomly' placed spheres where a sample of the distance field doesn't need to calculate the position of the neighbouring spheres.", "tags": ["raymarching", "distancefield"], "likes": 2, "viewed": 128, "published": "Public", "date": "1547904484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n\n}\n\nfloat saturate(float t) {\n\t\n    return clamp(t, 0.0, 1.0);\n    \n}\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat sphereDist(vec3 p) {\n\t\n    // Get the position of the current box and position in that box\n    float boxSize = 2.0;\n    vec3 i = floor(p / boxSize) * boxSize;\n    vec3 f = fract(p / boxSize) * boxSize;\n    \n    // Get the position of the center of the ball inside the box\n    // Designed so that the ball can't within a certain radius of the boundary of the box\n    float ballRadius = 0.025;\n    float edgeRadius = 0.1;\n    float radiusSum = ballRadius + edgeRadius;\n    vec3 hashVal = hash33(i);\n    //vec3 relativeSpherePos = vec3(boxSize / 2.0);\n    vec3 relativeSpherePos = vec3(radiusSum) + hashVal * (boxSize - 2.0 * radiusSum);\n    \n    // Get the distance to the sphere\n    float sphereDist = distance(f, relativeSpherePos) - ballRadius;\n    \n    // Get the distance to the nearest possible other circle box\n    float xDist = min(distance(f.x, -edgeRadius), distance(f.x, boxSize + edgeRadius));\n    float yDist = min(distance(f.y, -edgeRadius), distance(f.y, boxSize + edgeRadius));\n    float zDist = min(distance(f.z, -edgeRadius), distance(f.z, boxSize + edgeRadius));\n    float nearestBox = min(xDist, min(yDist, zDist));\n    \n    // Calculate and return a lower bound on the distance to the nearest sphere\n    float dist = min(sphereDist, nearestBox);\n    return dist;\n    \n}\n\nfloat distanceMap(vec3 p) {\n    \n  \tfloat dist = sphereDist(p);\n    return dist;\n    \n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n\t\n    // Parameters\n    int maxSteps = 200;\n    float maxDist = 250.0;\n    float surfaceDist = 0.005;\n    \n    // Main raymarching loop\n    float t = 0.0;\n    for (int i = 0; i < maxSteps; i++) {\n    \t\n        vec3 p = ro + t * rd;\n        float d = distanceMap(p);\n        \n        // A surface is found\n        if (d < surfaceDist) {\n        \treturn t;\n        }\n        \n        // The ray has travelled too far from the origin\n        if (t > maxDist) {\n        \treturn -1.0;\n        }\n        \n        t += d;\n    }\n    \n    // Too many steps were taken from the origin\n    return -1.0;\n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    // Samples neighbouring points to generate a normal vector\n    vec2 eps = vec2(0.005, 0.00);\n    float dist = distanceMap(p);\n    vec3 normal = vec3(\n    \tdist - distanceMap(p - eps.xyy),\n\t\tdist - distanceMap(p - eps.yxy),\n\t\tdist - distanceMap(p - eps.yyx)\n    );\n    normal = normalize(normal);\n    return normal;\n    \n}\n\nvec3 getColor(vec3 p) {\n\t\n    // Directional light source\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(p);\n    float normalLight = saturate(dot(normal, lightDir));\n    lightCol *= normalLight;\n    \n    // Applies hard-shadow lighting\n    //float eps = 0.01;\n    //bool isInShadow = (raymarch(p + normal * eps, lightDir) > 0.00);\n    //if (isInShadow) {\n    //\tlightCol *= 0.3;\n    //}\n    \n    // Gets the diffuse lighting\n    // Color function from iq https://www.shadertoy.com/view/Xds3zN\n   \t//vec3 diffuse = 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(iTime*5.0));\n    //vec3 diffuse = vec3(0.992, 0.627, 0.251);\n    vec3 diffuse = vec3(0.663, 0.388, 0.106);\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    float t = raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t >= 0.0) {\n    \tcol = getColor(ro + t * rd);\n    }\n    \n    else {\n        col = vec3(0.9, 0.9, 0.9);\n    }\n    \n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 0.0, 0.0) + vec3(0.0, 1.0, 0.0) * iTime;\n    vec3 rd = normalize(vec3(p, 0.9));\n\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.2,0.2):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Render and output the ray to screen\n    vec3 col = render(ro, rd);\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsB3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 87, 87, 169], [171, 171, 196, 196, 236], [238, 312, 334, 334, 465], [467, 467, 493, 563, 1761], [1763, 1763, 1790, 1790, 1850], [1852, 1852, 1886, 1906, 2481], [2483, 2483, 2507, 2575, 2838], [2840, 2840, 2863, 2897, 3909], [3911, 3911, 3942, 3942, 4153], [4156, 4156, 4213, 4250, 5080]]}
{"id": "wsB3Wh", "name": "tengo calor!!", "author": "bitnenfer", "description": "We are going through a heat wave in Chile and I wanted to make something that looked like some fresh cold water.", "tags": ["raymarching", "water"], "likes": 34, "viewed": 331, "published": "Public", "date": "1548715835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HIT_NONE -1.\n#define HIT_WATER 0.\n#define HIT_OPAQUE 1.\n#define MAX_DIST 10.\n#define EPSILON .001\n#define MIN_DIST EPSILON\n#define RAYMARCH_STEPS 400\n\nconst float uRefraction = 1.33;\nconst float uWaveAmp = 0.051;\nconst float uWaveFreq = 0.1;\nfloat uWaterHeight = 0.75;\nconst float uWaterWidth = 0.988;\nconst float uShape = 1.0;\n\n\nmat2 Rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat Box(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat Sphere(vec3 p, float radius) {\n    return length(p) - radius;\n} \n\nfloat GetNoise(vec3 p) {\n    float time = iTime * 0.005;\n    vec4 noise = texture(iChannel0, (p.xz * 0.01 + time));\n    noise += texture(iChannel0, (p.xz * 0.09+ time));\n    noise += texture(iChannel0, (p.xz * 0.1+ time));\n    float wave = (0.05 * (uWaveAmp * 4.0)) * sin((uWaveFreq * 90.0) * (p.x + p.z *0.5) + iTime * 2.0);\n    wave *= sin(time + p.x * cos(time + p.z)) * 3.0;\n    return wave + length(noise * 0.1) * uWaveAmp;\n}\n\nvec2 GetWater(vec3 p) {    \n    float wave = GetNoise(p);\n    float water = mix(Sphere(p - wave, uWaterWidth * uWaterHeight), Box(p + vec3(0.0, 0.2, 0.0), vec3(uWaterWidth, uWaterHeight + wave, uWaterWidth)), uShape);\n    float block = Box(p + vec3(0.0, -0.85, 0.0), vec3(uWaterWidth + 0.02, 3.0, uWaterWidth + 0.02));\n    \n    water = max(water, block);\n    \n    return vec2(water - 0.015, HIT_WATER);\n}\n\nvec2 GetOpaque(vec3 p) {\n    float balls = Sphere(p + vec3(-0.1, -0.0, 0.0), 0.2);\n    \n    balls = min(balls, Sphere(p + vec3(0.4, -0.1, 0.0), 0.3));\n    \n    balls = min(balls, Box(p + vec3(0.0, 0.17, 0.0), vec3(40.0, 1.0, 40.0)*vec3(1.0, 0.03, 1.0)));\n    \n    balls = min(balls, Box(p + vec3(0.0, 0.0, 0.4), vec3(0.2, 1.3, 0.1)));\n    balls = min(balls, Box(p + vec3(0.4, 0.0, -0.4), vec3(0.1, 1.0, 0.1)));\n        \n    float block = Box(p + vec3(0.0, -0.85, 0.0), vec3(uWaterWidth + 0.02, 1.01, uWaterWidth + 0.02));\n  \n    balls = max(balls, block);\n    \n    //balls = min(balls, p.y + 0.15);\n  \n    return vec2(balls, HIT_OPAQUE);\n}\n\nvec2 MinScene(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec2 GetOpaqueScene(vec3 p) {\n    vec2 balls = GetOpaque(p);\n    return balls;\n}\n\nvec2 GetTransparentScene(vec3 p) {\n    vec2 water = GetWater(p);\n    return water;\n}\n\nvec2 GetScene(vec3 p) {\n    vec2 transparent = GetTransparentScene(p);\n    vec2 opaque = GetOpaqueScene(p);\n    vec2 scene = MinScene(transparent, opaque);\n    \n    return scene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(GetScene(p).x - vec3(\n        GetScene(p - e.yxx).x,\n        GetScene(p - e.xyx).x,\n        GetScene(p - e.xxy).x\n    ));\n}\n\nvec3 GetOpaqueNormal(vec3 p) {\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(GetOpaqueScene(p).x - vec3(\n        GetOpaqueScene(p - e.yxx).x,\n        GetOpaqueScene(p - e.xyx).x,\n        GetOpaqueScene(p - e.xxy).x\n    ));\n}\n\nvec2 RayMarchAll(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; ++i) {\n        vec2 scene = GetScene(ro + rd * t);\n        if (scene.x < MIN_DIST) {\n            return vec2(t, scene.y);\n        }\n        t += scene.x * 0.5;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec2(MAX_DIST, HIT_NONE);\n}\n\nvec2 RayMarchOpaque(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; ++i) {\n        vec2 scene = GetOpaqueScene(ro + rd * t);\n        if (scene.x < MIN_DIST) {\n            return vec2(t, scene.y);\n        }\n        t += scene.x;\n        if (t > MAX_DIST) break;\n    }\n    \n    return vec2(MAX_DIST, HIT_NONE);\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 ShadePBR(vec3 n, vec3 v, vec3 l, vec3 albedo, float roughness, float metallic, out vec3 BRDF, float shadow)\n{\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    vec3 h = normalize(v + l);\n    roughness = roughness * roughness;\n    float NdotL = max(0.0, dot(n, l));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - metallic);\n    vec3 radiance = vec3(5.0, 4.0, 3.0);\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01) * shadow;\n    \n    BRDF = specularBRDF;\n    \n    return (albedo * 0.08) + ((Kd * albedo / 3.14 + specularBRDF) * radiance * (NdotL * shadow));\n}\n\nfloat Shadow(vec3 P, vec3 N, vec3 L, float noise) {\n    \n    float t = 0.01;\n    vec3 rd = L;\n    vec3 ro = P;\n\tfloat shadowContrib = 1.0;\n    for (int i = 0; i < 30; i++)\n    {\n    \tvec2 scene = GetOpaqueScene(ro + rd * t);\n        shadowContrib = min(shadowContrib, 2.*scene.x / t);\n        t += clamp(scene.x, 0.02, 0.1);\n        if (scene.x < EPSILON || t > 0.9) break;\n    }\n    \n    return clamp(shadowContrib, 0.0, 1.0);\n}\n\nvec3 ShadeOpaque(vec3 P, vec3 N, vec3 V, vec3 L) {\n    vec3 P2 = P * 2.0;\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(N, V, L, vec3(1.0, 0.5, 0.2), 0.4, 0.0, brdfRef, Shadow(P, N, L, 0.0));\n    float checker = mod(floor(P2.x) + floor(P2.y) + floor(P2.z), 2.0);\n    float NdotL = max(0.6, dot(N, L));\n    \n    return mix(shade, shade * 0.8, checker);\n}\n\nvec3 ShadeOpaqueInWater(vec3 P, vec3 N, vec3 V, vec3 L) {\n    float noise = GetNoise(P);\n    vec3 P2 = P * 2.0;\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(normalize(0.2 * P + N), V, L, mix(vec3(0.1, 0.2, 0.3), vec3(1.0, 0.5, 0.2), pow((P.y + 0.14) / uWaterHeight, 2.0)), 1.0, 0.0, brdfRef, Shadow(P, N, L, noise * 1.0));\n    float checker = mod(floor(P2.x) + floor(P2.y) + floor(P2.z), 2.0);\n    \n    shade *= 2.0;\n    shade = mix(shade, shade * 0.8, checker);\n    \n    \n    vec2 scene = RayMarchAll(P + N * 0.1, N);\n    vec3 p = (P + N * 0.1) + N * scene.x;\n    \n    shade = mix(shade, shade * 8.2, noise * 7.0);\n    return shade ;\n}\n\nvec3 ShadeTransparent(vec3 P, vec3 N, vec3 V, vec3 L) {\n    vec3 brdfRef;\n    vec3 shade = ShadePBR(N, V, L, vec3(0.0, 0.0, 0.0), 0.09, 0.0, brdfRef, 1.0);\n    \n    vec3 rd = normalize(reflect(-V, N));\n    vec3 ro = P + rd * 0.01;\n    vec2 scene = RayMarchOpaque(ro, rd);\n    if (scene.y > HIT_NONE) {\n        vec3 p = ro + rd * scene.x;\n        vec3 n = GetOpaqueNormal(p);\n        vec3 v = normalize(-rd);\n        vec3 opaque = ShadeOpaque(p, n, v, L);\n        return opaque * 0.5;\n    }\n    return brdfRef;\n}\n\nvec3 GetColor(vec3 ro, vec3 rd, vec3 lightDir, out float dist)\n{\n    vec3 water = vec3(0.0);\n    vec3 color = vec3(0.0);\n    vec2 scene = RayMarchAll(ro, rd);\n\tvec3 V = -normalize(rd);\n\n    dist = scene.x;\n    \n    if (scene.y > HIT_NONE) {\n        vec3 p = ro + rd * dist;\n        vec3 n = GetNormal(p);\n        if (scene.y == HIT_WATER) {\n            water = ShadeTransparent(p, n, V, lightDir);\n            rd = normalize(refract(rd, n, 1.0 / uRefraction));\n            ro = p;\n            scene = RayMarchOpaque(ro, rd);\n            p = ro + rd * scene.x;\n            n = GetOpaqueNormal(p);\n            dist = scene.x;\n            color = ShadeOpaqueInWater(p, n, V, lightDir) + water;\n        } else {\n            color = ShadeOpaque(p, n, V, lightDir);\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 lightDir = normalize(vec3(0.2, 0.1, -0.2));\n    vec3 color = vec3(.0);\n\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * ar;\n    vec3 ro = vec3(uv.x, uv.y + 1.5, -4.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.85, 3.0));\n    \n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    float my = (iMouse.y / iResolution.y * 2.0 - 1.0);\n                \n    uWaterHeight += clamp(my, -0.3, 0.8);\n        \n    ro.xz *= Rotate(mx);\n    rd.xz *= Rotate(mx);\n    \n    vec2 scene = RayMarchAll(ro, rd);\n    float dist = scene.x;\n    \n\tcolor = GetColor(ro, rd, lightDir, dist);\n    \n    color *= 1.0 - (dist / MAX_DIST);\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsB3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 360, 360, 436], [438, 438, 468, 468, 566], [568, 568, 604, 604, 637], [640, 640, 664, 664, 1070], [1072, 1072, 1095, 1095, 1476], [1478, 1478, 1502, 1502, 2117], [2119, 2119, 2150, 2150, 2195], [2197, 2197, 2226, 2226, 2277], [2279, 2279, 2313, 2313, 2363], [2365, 2365, 2388, 2388, 2545], [2547, 2547, 2571, 2571, 2749], [2751, 2751, 2781, 2781, 2983], [2985, 2985, 3021, 3021, 3328], [3330, 3330, 3369, 3369, 3676], [3678, 3678, 3742, 3742, 3944], [3946, 3946, 3987, 3987, 4076], [4078, 4078, 4134, 4134, 4232], [4234, 4234, 4280, 4280, 4373], [4375, 4375, 4489, 4489, 5184], [5186, 5186, 5237, 5237, 5615], [5617, 5617, 5667, 5667, 5968], [5970, 5970, 6027, 6027, 6605], [6607, 6607, 6662, 6662, 7118], [7120, 7120, 7184, 7184, 7915], [7917, 7917, 7972, 7972, 8834]]}
{"id": "WsBGDW", "name": "cloud_0002", "author": "kuma720", "description": "cloud", "tags": ["cloud"], "likes": 9, "viewed": 150, "published": "Public", "date": "1548807895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\n\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = noise(v1 + vec3(0.,0.,0.));\n  float b0 = noise(v1 + vec3(1.,0.,0.));\n  float c0 = noise(v1 + vec3(0.,1.,0.));\n  float d0 = noise(v1 + vec3(1.,1.,0.));\n\n  float a1 = noise(v1 + vec3(0.,0.,1.));\n  float b1 = noise(v1 + vec3(1.,0.,1.));\n  float c1 = noise(v1 + vec3(0.,1.,1.));\n  float d1 = noise(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\n\nfloat fbm(vec3 uv , float f ) {\n  float o = 0.;\n  float n = 1.;\n  \n  for ( int i = 0 ; i < 5 ; ++ i ) {\n    o += pnoise( uv , f ) * n;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o;\n}\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nvec2 sdf(vec3 p) {\n\n  vec3 p2 = p + vec3( iTime * .15 , iTime * -.08 , iTime * -.12 );\n\n  //cloud sphere\n  float cloudPlane = dot( p + vec3(0,-0.4,0) , vec3(0.,1.,0.) );\n  float l0 = length( p + vec3(1.7,-0.15,1.0) ) - 0.7;\n  float l1 = length( p + vec3(-0.8,-0.15,-1.0) ) - 0.7;\n  float l2 = min(l0,l1);\n  float cl = max(l2,-cloudPlane);\n\n  //cloud detail\n  float l4 = fbm( p2 , 5.0 ) - 0.8;\n  float l5 = mix ( cl , l4 , .2 );\n\n  //plane\n  float l6 = dot( p , vec3(0.,1.,0.));\n\n  if ( l5 < l6 ) {\n    return vec2(l5,1);\n  } else {\n    return vec2(l6,2);\n  }\n\n}\n\n\nvec3 createnormal(vec3 p) {\n\n  float e = 0.0001;\n\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ).x - sdf( vec3(p.x-e,p.y,p.z) ).x ,\n    sdf( vec3(p.x,p.y+e,p.z) ).x - sdf( vec3(p.x,p.y-e,p.z) ).x ,\n    sdf( vec3(p.x,p.y,p.z+e) ).x - sdf( vec3(p.x,p.y,p.z-e) ).x\n  ));\n\n}\n\n\nvec3 lightingMaterial00 ( vec3 lightvec , vec3 p ) {\n\n  vec3 normal = createnormal(p);\n  vec3 s = p + normal * 0.01;\n\n  float result = 0.9;\n  float depth = 0.1;\n  float minlight = 0.1;\n\n  for( int I=0; I< 20 ; ++I ) {\n    \n    vec3 p2 = s + lightvec * depth;\n    float len = sdf(p2).x;\n    result = min( result , (len * 2.6 / depth) + minlight ) ;\n    depth += len ;\n\n    if( len < 0.00001 ) {\n      result = minlight;\n      break;\n    }\n\n  }\n\n  return mix( vec3(0.2,0.1,0.9) , vec3( result ), 0.9 );\n\n}\n\n\n\n\n\nvec3 lightingMaterial01 ( vec3 lightvec , vec3 p ) {\n\n  vec3 normal = createnormal(p);\n  vec3 s = p + normal * 0.01;\n\n  float result = 1.;\n  float depth = 0.;\n  float minlight = .1;\n\n  for( int I=0; I< 15 ; ++I ) {\n    \n    vec3 p2 = s + lightvec * depth;\n    float len = sdf(p2).x;\n    result = min( result , len * 4.6 / depth + minlight );\n    depth += len ;\n\n    if( len < 0.001 ) {\n      result = minlight;\n      break;\n    }\n\n  }\n\n  return mix ( vec3( 0.2 , 0.1 , 0.0 ) , vec3 ( result ) , .5 );\n\n}\n\n\nvec4 render( vec2 fragCoord , vec3 eye , vec3 worldDir , float start , float end ) {\n\n  vec3 lightvec = normalize( vec3( 1.0 ,1.2, -0.8) );\n\n  vec3 sky = vec3(0.25,0.4,0.65);\n  vec3 cloud = vec3(0.,0.,0.);\n  vec3 background = sky;\n  float ratio = 1.0;\n\n  float depth = start;\n  for(int I=0;I<200;++I) {\n\n    vec3 p = eye + worldDir * depth;\n    if ( 17. < depth ) {\n      break;\n    }\n\n    vec2 ss = sdf(p);\n    float len = ss.x;\n    int material = 0;\n\n    if( len < 0.01 ) {\n      \n      material = int(ss.y);\n\n      if ( material == 1 ) {\n        ratio = min( ratio , 0.9 );\n        vec3 l = lightingMaterial00( lightvec , p );\n        cloud = mix(cloud , l , ratio);\n        ratio *= .7;\n        if ( ratio < 0.0001 ) {\n          break;\n        }\n        depth += max(len, 0.001 * noise( worldDir * iTime ) + 0.002 );\n      }\n\n      if ( material == 2 ) {\n        vec3 ground = lightingMaterial01( lightvec , p );\n        background = ground;\n        break;\n      }\n\n    } else {\n      depth += max(len, 0.01 );\n    }\n\n  }\n\n\n  //vec3 o = mix ( background , cloud , ( 1. - ratio ) );\n  vec3 o = background + cloud * .9 ; //* (1.0 - ratio);\n  return vec4( o , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .1;\n//    vec3 eye = vec3( sin(t) * 5. , 0.2, cos(t) * 5. );\n\n    vec3 eye = vec3( 5. ,2.5, 4. );\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n   fragColor = render( fragCoord , eye , worldDir , 0. , 1000. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 91], [93, 93, 124, 124, 749], [751, 751, 782, 782, 932], [935, 935, 981, 981, 1171], [1174, 1174, 1237, 1237, 1363], [1366, 1366, 1384, 1384, 1927], [1930, 1930, 1957, 1957, 2210], [2213, 2213, 2265, 2265, 2716], [2722, 2722, 2774, 2774, 3225], [3228, 3228, 3312, 3312, 4396], [4399, 4399, 4456, 4456, 4929]]}
{"id": "wsBGWz", "name": "shutters BW (123 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["short", "onetweet", "golf"], "likes": 1, "viewed": 239, "published": "Public API", "date": "1548589969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wdBGWz\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    int i = int(iTime);\n    vec2 A = abs( 2.*u/iResolution.xy - 1. );\n    A[ i%2 ] < fract(-iTime) ? i++ : i;\n    O += .5 + .5* fract( A[ i % 2 ] ); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 86, 86, 237]]}
{"id": "Wsf3D2", "name": "CSG_shad", "author": "Clemm_ence", "description": "csg", "tags": ["csg"], "likes": 0, "viewed": 199, "published": "Public API", "date": "1547505667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FLT_MAX = 1.0 / 0.0;\nconst int MAX_NB_BOUNCES = 3;\nconst int PIXEL_SAMPLING_SIZE = 25;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int NB_LIGHTS = 2;\n\nint subObjectIdC = 0;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    \n    \nstruct ShadeInfo\n{\n\tvec3 shadeCol;\n    float Ks;\n};\n    \n    \nstruct LightInfo\n{\n\tvec3 pos;\n    vec3 col;\n    float pow;\n};\nLightInfo lights[NB_LIGHTS];\n//parametre camera\nvec3 camPos=vec3(6,4,-5);\n\nconst vec3 camObj = vec3(3,1,-8);\nconst float camFovY = 90.0;\n\n//parametre sphere\n vec3 center = camObj + vec3(0,1,2);\nconst float rayonS = 1.0;\nconst vec3 sphereCol = vec3(1.0,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int      sphereId     = 1;\n\n//parametre lumiere\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\n\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8,10,-12);\nconst float    light1Pow = 0.8;\n\nconst vec3     light2Col     = vec3(1,1,0.5);\t\t// white/yellow\n      vec3     light2Pos     = vec3(3,10,1);\nconst float    light2Pow = 0.5;\n\n\n\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\nconst int antialliazing = 1;\n\n\n//CSG objects parameters\nconst vec3     csgSphere1Pos \t= camObj + vec3(-1.125, 2, 0);\nconst float    csgSphere1Radius = 1.4;\nconst vec3\t   csgSphere2Pos \t= camObj + vec3(1.125, 2, 0);\nconst float\t   csgSphere2Radius = 1.4;\nconst vec3\t   csgSphere3Pos \t= camObj  + vec3(0, 2.5, 0);\nconst float\t   csgSphere3Radius = 0.5;\nconst vec3\t   csgSphere4Pos \t= camObj  + vec3(0, 2.4, -0.5);\nconst float\t   csgSphere4Radius = 0.5;\nconst vec3\t   csgCol1 \t\t\t= vec3(1.0, 0.5, 0.0); //orange\nconst vec3\t   csgCol2 \t\t\t= vec3(0.4, 1.0, 1.0); //light cyan\nconst vec3     csgCol3\t\t\t= vec3(1.0, 0.0, 1.0); //magenta\nconst vec3     csgCol4\t\t\t= vec3(5.0, 5.0, 0.0); //hyper yellow\nconst Material csgMat \t\t\t= Material(0.2, 1.0, 0.1, 90.0);\nconst int \t   csgId\t\t\t= 3;\n\n\n\nfloat raySphere(vec3 rayPos, vec3 rayDir,vec3 center, float rayonS,out vec3 intersecPt, out vec3 normal)\n{\n\tvec3 diff = rayPos - center ; \n     float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - rayonS * rayonS;\n    \n    float d = b*b - 4.0*a*c;\n    \n    \n    if (d >= 0.0)\n    {\n        float sd = sqrt(d);\n    \tfloat t1 = (-b - sd ) / (2.0 * a);\n    \tfloat t2 = (-b + sd ) / (2.0 * a);\n        \n       float dir = 1.0;\n       float t = -1.0;\n        if (t1 > 0.0 )\n          t = t1;\n        else if (t2 > 0.0)\n        {\n        \tt = t2;\n        }else\n            return t;\n        intersecPt = rayPos + t * rayDir;\n        normal     = normalize(intersecPt - center) * dir;\n        \n        return t;\n\n     }\n    return -1.0;\n}\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    float den = dot(planeNormal, rayDir);\n    if (abs(den) <= 0.000001)\n        return -1.0;\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    intersecPt = rayPos + t * rayDir;\n     normal = -sign(den) * planeNormal;\n    \n    return t;\n    \n}\n\nfloat rayCSG(vec3 rayPos, vec3 rayDir, out vec3 interPt, out vec3 normal, out int subObjectId)\n{\n\tvec3 interPt1;\n    vec3 normal1;\n    vec3 interPt2;\n    vec3 normal2;\n    vec3 interPt3;\n    vec3 normal3;\n    vec3 interPt4;\n    vec3 normal4;\n  \n    float dist1 = raySphere(rayPos, rayDir, csgSphere1Pos, csgSphere1Radius, interPt1, normal1);\n    float dist2 = raySphere(rayPos, rayDir, csgSphere2Pos, csgSphere2Radius, interPt2, normal2);\n    float dist3 = raySphere(rayPos, rayDir, csgSphere3Pos, csgSphere3Radius, interPt3, normal3);   \n    float dist4 = raySphere(rayPos, rayDir, csgSphere4Pos, csgSphere4Radius, interPt4, normal4);\n    \n    \n    if (dist1 > 0.0) //intersection s1/s2\n    {\t\n        float dist12 = distance(interPt1, csgSphere2Pos);\n        if (dist12 < csgSphere2Radius){ \n        \tfloat dist14 = distance(interPt1, csgSphere4Pos); // s1 vers s4\n            if (dist14 >csgSphere4Radius){\n            \tinterPt= interPt1;\n                subObjectId = 1;\n                normal = normal1;\n                return dist1;\n            \t}\n            \tfloat dist41 = distance(interPt4, csgSphere1Pos);\n            \tfloat dist42 = distance(interPt4, csgSphere2Pos);\n       \t\t\t \n        \tif ((dist41 < csgSphere2Radius) && (dist42 < csgSphere1Radius ) && (dist4 > 0.0))\n             { \n                interPt= interPt4;\n                subObjectId = 4;\n                normal = normal4;\n                return dist4;\n            }\n                }\n            }\n    \n    if (dist2 > 0.0) //intersection s2/s1\n    {\t\n        float dist21 = distance(interPt2, csgSphere1Pos);\n        if (dist21 < csgSphere1Radius)\n        {\n            float dist24= distance(interPt2, csgSphere4Pos);\n            if  (dist24 > csgSphere4Radius)\n            {\n                interPt= interPt2;\n                subObjectId = 2;\n                normal = normal1;\n                return dist2;\n            }\n            dist24 = distance(interPt4, csgSphere2Pos);\n            float dist14 = distance(interPt4, csgSphere1Pos);\n            if ((dist24 < csgSphere2Radius) && (dist14 < csgSphere1Radius) && (dist4 > 0.0)){\n            \tinterPt = interPt4;\n                 subObjectId = 4;\n                 normal = normal4; \n                 return dist4;\n            }\n                }\n    \n    //intersection s3/s4\n  \n    if (dist3 > 0.0){\n        // distance sphere 3 / origine 4\n    \tfloat dist34 = distance(interPt3, csgSphere4Pos);\n\t\tif (dist34     > csgSphere4Radius)  \n        {\n        \tinterPt = interPt3;\n            subObjectId = 3;\n            normal = normal3; \n            return dist3;\n        }\n        float dist43 = distance( interPt4, csgSphere3Pos);\n            if ((dist43 < csgSphere3Radius) && (dist4 > 0.0))\n            {\n            interPt = interPt4;\n            subObjectId = 4;\n            normal = normal4; \n            return dist4;\n            }\n    \t}\n\t}\nreturn -1.0;\n}\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n \n   float focal = 1.0 / tan(radians(camFovY) / 2.0);\n   vec3 cz = normalize(camObj - camPos);\n     vec3 up = vec3(0,1,0);\n   vec3 cx = normalize(cross(-up, cz));\n   vec3 cy = normalize(cross( cz, cx));\n    \n   vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n   rayPos = camPos;\n   rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n \t float minDist  = FLT_MAX;\n          objectId = skyId;   \n    vec3 intersecS, normalS;\n    \n   //test sphere\n      float distS = raySphere(rayPos, rayDir, center, rayonS, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    //test CSG\n     vec3 intersecC, normalC;\n    float distC =  rayCSG(rayPos, rayDir,intersecC, normalC, subObjectIdC);\n    if ((distC > 0.0) && (distC < minDist))\n    {\n        objectId  =   csgId;\n        minDist   =   distC;\n\t    intersecI =   intersecC;\n    \tnormalI   =   normalC;\n    }\n    \n    //test plane\n     vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n       if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n\n}\n\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n     vec3 axisY  = normalize(cross(planeNormal, axisX));\n    \n     vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n\n}\nvec3 getCSGColorAtPoint(vec3 pt) \n{\n\tif (subObjectIdC == 1)\n        return csgCol1;\n    if (subObjectIdC == 2)\n        return csgCol2;\n    if (subObjectIdC == 3)\n        return csgCol3;\n    if (subObjectIdC == 4)\n        return csgCol4;\n    return vec3(3);\n}\n\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n    else if (objectId == csgId) \n    {\n        objectMat = csgMat;\n        return getCSGColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V, LightInfo lights )\n{\n\n     vec3 ambiant  = objectMat.Ka * ambiantCol;\n \t \n   \n    vec3 diffuse  = objectMat.Kd *  objectCol * lights.col *     max(dot(N,L), 0.)*shadowFactor;\n    vec3 specular = objectMat.Ks *              lights.col * pow(max(dot(R,V), 0.), objectMat.Kn)*shadowFactor;\n     \n    vec3 phongCol = ambiant + diffuse + specular;\n\n    return phongCol;   \n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n\tint object;\n    vec3 inter;\n    vec3 nI;\n    float shadowPoint;\n   \t\n    \n        \n    float intersec =computeNearestIntersection(I, L,object,  inter, nI);\n    if ((intersec < 0.0) || (intersec > Ldist))\n    {\tshadowPoint = 0.5;\n    }else {\n        shadowPoint = 0.0;\n}\nreturn  shadowPoint;\n\n}\n\nvoid AnimeScene(float time)\n{\n \t//animate the sphere position\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    center = camObj + rs * vec3(-sin(as),0.0,cos(as))+vec3(0,1,0);\n    \n    //anime ligth position\n    light1Pos += vec3(0,10.5 +9.5 * cos(time)-10.,0);\n    \n    float targetDist = length(camObj - camPos);\n    camPos -=vec3(0,0,targetDist);\n    camPos += targetDist*vec3(sin(time), max(sin(time*0.5),0.),cos(time));\n}\n\n\n\nvec4 RaytraceAtPixelCoord_RT(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    \n    \n    int objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 color;\n   \n    \n    do\n    {\n        \n        \n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        vec3 color;\n        Material objMat;\n        \n         \n        if (distI <= 0.0) //pt dans le ciel\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0 ; \n            break;\n        }\n    \n      \n        //objets\n        \n        vec3 V =- rayDir;\n        vec3 objColor = getObjectColorAtPoint(objectId, intersecI, objMat);\n         vec3 I = intersecI + normalI*0.01;\n         vec3 RayRefract = 2.0 * normalI * dot(normalI, V) - V;\n            \n         for (int l = 0 ; l < NB_LIGHTS ; l++){   \t\t\n            vec3 L = normalize(lights[l].pos - intersecI);\n            \n           vec3 R = normalize(2.0 * normalI * dot(normalI, L) - L);\n        \n           \n            float Ldist = length(lights[l].pos - I);\n            \n             float shadowFactor = getShadowFactorAtPoint(I,normalI, objMat,L,Ldist);\n             color += computePhongShading(objColor, objMat,  shadowFactor,normalI, L, R, V, lights[l]);\n             \n         }\n            infos[nbBounces].shadeCol= color;\n            infos[nbBounces].Ks = objMat.Ks;\n            \n          rayDir = RayRefract;\n             rayPos = I;\n            \n               nbBounces++;\n            \n           \n        }\n    \n    while (nbBounces < MAX_NB_BOUNCES);\n    vec3 resCol = vec3(0);\n    \n    for (int i =0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces -i].Ks *resCol + infos[nbBounces - i].shadeCol; \n    \n    }\n    \n    return vec4(resCol,1);\n}\n\n\n\nvec2 noise2(vec2 location , vec2 delta)\n{\n\tconst vec2 c= vec2 (12.9898 , 78.233);\n    const float m = 43758.5453;\n    return vec2(fract(sin(dot(location + delta,c))*m),\n                      fract(sin(dot(location+ vec2(delta.y,delta.x),c)) * m));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \t \n    float time = iTime;\n     AnimeScene(time);\n    \n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].pow = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].pow = light2Pow;\n    \n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    int  objectId; \n    vec3 intersecI, normalI;\n   \n    \n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    float pixel = 1.0/iResolution.y;\n    float sousPixel = pixel/float(PIXEL_SAMPLING_GRID_SIZE); \n    vec4 finalColor = vec4(0);\n  \n    \n    if (antialliazing == 0)\n    {\n         for (int i = 0; i < PIXEL_SAMPLING_GRID_SIZE; i++)\n    {\n        \tfor (int j = 0 ; j < PIXEL_SAMPLING_GRID_SIZE; j++)\n        {\n           finalColor +=RaytraceAtPixelCoord_RT(fragCoord + vec2(float(i) * sousPixel, float(j) * sousPixel));\n            \n        }\n    }\n    finalColor /=pow(float(PIXEL_SAMPLING_GRID_SIZE), 2.0);\n    }else {\n        vec2 delta = vec2 (600.0, 5468.265);\n        for (int i= 0; i < PIXEL_SAMPLING_SIZE; i++)\n    {\n            finalColor += RaytraceAtPixelCoord_RT(fragCoord + noise2(fragCoord, delta) * pixel);\n        }\n        finalColor /= float(PIXEL_SAMPLING_SIZE);\n    }\n    \n   \n    fragColor= finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2159, 2438, 2544, 2544, 3236], [3240, 3240, 3380, 3380, 3634], [3636, 3636, 3732, 3732, 6533], [6535, 6535, 6620, 6620, 6975], [6978, 6978, 7127, 7127, 8192], [8196, 8196, 8233, 8233, 8257], [8259, 8259, 8295, 8295, 8661], [8662, 8662, 8697, 8697, 8920], [8924, 8924, 8999, 8999, 9373], [9377, 9377, 9510, 9510, 9859], [9861, 9861, 9948, 9948, 10243], [10245, 10245, 10274, 10306, 10755], [10759, 10759, 10804, 10804, 12640], [12644, 12644, 12685, 12685, 12893], [12897, 12897, 12954, 12954, 14276]]}
{"id": "Wsf3D7", "name": "Cheeseburger", "author": "Xor", "description": "This is a cheeseburger SDF I made in three days for a fun little challenge.\nThe code isn't very organized because of time restraints. Sorry!", "tags": ["cheese", "table", "tomato", "plate", "cheeseburger", "burger", "hamburger", "buns", "lettuce", "beef"], "likes": 27, "viewed": 504, "published": "Public", "date": "1546644505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Cheeseburger\" by Xor (@XorDev)\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t\n\tThis is a cheeseburger SDF I made in three days for a fun little challenge.\n\tThe code isn't very organized because of time restraints. Sorry!\n*/\n\n//Anti-Aliasing level. Use 2, 3 or 4 if you have a better PC.\n#define AA 1.\n//Light direction vector.\n#define DIR normalize(vec3(-2,4,3))\n\n\n//Inspired by iq's smooth minimum function: http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat Smooth(float A, float B, float N)\n{\n \treturn log(exp(A*N)+exp(B*N))/N;   \n}\n//Generic 3D hash function.\nvec3 Hash(vec3 P)\n{\n \treturn fract(sin(P*mat3(45.32,32.42,-41.55,65.35,-43.42,51.55,45.32,29.82,-41.45)*vec3(142.83,253.36,188.64)));\n}\n//Smooth 3D Worley noise.\nfloat Worley(vec3 P)\n{\n    float D = 1.;\n    for(int X = -1;X<=1;X++)\n    for(int Y = -1;Y<=1;Y++)\n    for(int Z = -1;Z<=1;Z++)\n    {\n    \tvec3 F = floor(P+vec3(X,Y,Z));\n        vec3 V = P-F-Hash(F);\n        D = Smooth(D,dot(V,V),-6.);\n    }\n    return D;\n}\n//Heavily modified Worley noise for the Sesame seeds.\nfloat Seed(vec3 P)\n{\n    float D = 1.;\n    for(int X = -1;X<=1;X++)\n    for(int Y = -1;Y<=1;Y++)\n    {\n    \tvec3 F = floor(vec3(P.xy,0)+vec3(X,Y,0));\n        vec3 H = Hash(F)*vec3(1,1,63);\n        vec3 V = mat3(cos(H.z),sin(H.z),0,sin(H.z),-cos(H.z),0,0,0,1)*(P-F-H*.9)*vec3(1.7,1,0);\n        D = min(D,dot(V,V));\n    }\n    return smoothstep(.1*clamp(P.z-3.5,0.,1.),-.01,D);\n}\n//Cheese SDF.\nfloat Cheese(vec3 P)\n{\n    P.z += .19+.1*Smooth(dot(P.xy,P.xy)-3.,0.,10.);\n \treturn (length(max(abs(P)-vec3(1.7,1.7,.01),0.))-.03)*.9;\n}\n//Burger, Plate and table SDF.\nfloat Model(vec3 P)\n{\n    float D = length(P)-2.5;\n    float M = Smooth(length(P.xy)-3.,pow(P.z-Smooth(D,0.,20.)*.7+1.1,2.)-.01,10.);\n    M = min(M,Smooth(P.z+1.2,-abs(mod(P.y+7.,8.)-4.),12.));\n    if (D<.1)\n    {\n    \tvec3 B = vec3(P.xy,max(P.z-.35,0.)*1.6);\n    \tfloat Bun = Smooth(length(B+.05*sin(B.yzx*2.))*.6-1.2,.5-abs(P.z+.1)-.02*B.x*B.x,50.);\n        M = min(M,Smooth(Bun,-1.-P.z,20.));\n    \tM = min(M,Smooth(length(P.xy+.1*sin(B.yx*2.))-2.1,pow(P.z+.03*P.x*P.x,2.)-.04,12.));\n    \tvec3 L = P-vec3(0,0,.26)+vec3(0,0,clamp(length(P.xy)-2.,.0,.2))*\n        \tcos(P.x*5.+sin(P.x*2.+P.y*4.))*sin(P.y*3.+P.x*3.+cos(P.y-P.x*4.));\n    \tM = min(M,Smooth(length(L)-2.3,abs(L.z)-.05,12.)*.8);\n    \tM = min(M,max(length(P)-1.9,abs(P.z+.45-.03*P.y*P.y)-.1));\n    \tM = min(M,Cheese(P));\n        \n        return M;\n    }\n  \t\n\treturn min(D,M);\n}\n//Bump mapped distance function.\nfloat Bump(vec3 P)\n{    \n    float S = .02*Seed(P*5.);\n    float B = .005*max(1.-1.5*abs(P.z),0.)*Worley(P*18.);\n        B += .0004*Worley(P*40.)*step(-.99,P.z-max(length(P.xy)-2.,0.));\n \treturn Model(P)+B*step(.01,Cheese(P))-S;\n}\n//Typical Normal function.\nvec3 Normal(vec3 P)\n{\n\tvec3 N = vec3(-1,1,0)*.001;\n    return normalize(Bump(P+N.xyy)*N.xyy+Bump(P+N.yxy)*N.yxy+Bump(P+N.yyx)*N.yyx+Bump(P+N.xxx)*N.xxx);\n}\n//Burger, plate and table texturing with lighting.\nvec3 Tex(vec3 P,vec3 R)\n{\n    vec3 L = P-vec3(0,0,.26)+vec3(0,0,clamp(length(P.xy)-2.,.0,.2))*\n        cos(P.x*5.+sin(P.x*2.+P.y*4.))*sin(P.y*3.+P.x*3.+cos(P.y-P.x*4.));\n    float T = max(length(P)-1.9,abs(P.z+.45-.03*P.y*P.y)-.1);\n    \n    vec3 N = Normal(P);\n    float W = Worley(P*11.)*(.05+.95*smoothstep(.7,.4,abs(P.z+.04)))*(abs(N.z)*.7+.3);\n    \n    \n \tfloat M = abs(P.z+.03*P.x*P.x)-.3;\n    float D = .2+.8*max(dot(N,DIR),.0)/(1.-min(dot(DIR,P),0.)*exp(4.-2.3*length(cross(DIR,P))));\n    float S = max(dot(reflect(R,N),DIR),0.);\n    \n    vec3 B = vec3(1,.6,.3)*(1.8-smoothstep(.0,1.2,pow(abs(P.z+.1),2.)))\n        +.5*S*S-2.*W+vec3(.5+S*S*S)*Seed(P*5.);\n    vec3 C = mix(B,vec3(.4,.25,.2)-.4*W+.9*S*S*S,step(M,.01));\n    C = mix(C,vec3(.5,.8,.2)-.4*W+.5*S*S,step(abs(L.z),.06));\n    C = mix(C,vec3(1,.6,.1)+S*S,step(Cheese(P),.01));\n    C = mix(C,vec3(1,.2,.1)+S*S,step(T,.01));\n    C = mix(C,vec3(.9)+S*S*S*S,step(P.z-max(length(P.xy)-2.,0.),-.99));\n    C = mix(C,(texture(iChannel0,P.xy/4.).rgb*vec3(.6,.7,.8)+.2),step(P.z,-1.18));\n    \n    return D*C;\n}\n\n//Output the results.\nvoid mainImage( out vec4 Color, in vec2 Coord )\n{\n    vec2 A = vec2(iTime*.2,.2*cos(iTime*.1)+1.8);\n    vec3 X = vec3(cos(A.x)*sin(A.y),sin(A.x)*sin(A.y),cos(A.y)),\n         Y = normalize(cross(X,vec3(0,0,-1))),\n    \t Z = normalize(cross(X,Y));\n    \n    mat3 M = mat3(X,Y,Z);\n    \n    vec3 C = vec3(0);\n    \n    for(float J = 0.;J<AA;J++)\n    for(float K = 0.;K<AA;K++)\n    {\n        vec4 P = vec4(M*vec3(-10,0,2.*cos(A.y)+.4),0);\n        vec3 R = M*vec3(1,(vec2(J,K)/AA+Coord-.5*iResolution.xy)/iResolution.x);\n\n        for(int I = 0;I<200;I++)\n        {\n            float S = Model(P.xyz);\n            P += vec4(R,1)*S;\n            if ((P.w>30.) || (S<.001)) break;\n        }\n\n    \tC += mix(Tex(P.xyz,R),vec3(.9)+.1*dot(DIR,R),clamp(P.w/20.-.5,0.,1.));\n    }\n    Color = vec4(C/AA/AA,1);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3D7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[411, 508, 549, 549, 589], [590, 618, 637, 637, 753], [754, 780, 802, 802, 1037], [1038, 1092, 1112, 1112, 1468], [1469, 1483, 1505, 1505, 1619], [1620, 1651, 1672, 1672, 2489], [2490, 2523, 2543, 2543, 2753], [2754, 2781, 2802, 2802, 2936], [2937, 2988, 3013, 3013, 4052], [4054, 4076, 4125, 4125, 4867]]}
{"id": "Wsf3Df", "name": "Wave effect", "author": "anemolo", "description": "I saw this effect made on javascript canvas and I wanted to give it a shot as a shader. Still trying to understand the math :b\n\nControls:\n1 => Toggle raw wave effect. \nEffect frist found at https://spite.github.io/looper/#2", "tags": ["lineswave"], "likes": 11, "viewed": 248, "published": "Public", "date": "1547610946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel0,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n// Smallest form - 108 chars\n//#define mainImage(o,U)                              \\\n//    vec2 u = 2.* U/iResolution.xy - 1.;             \\\n//    o += sin( 9. / exp( u.x = dot(u,u) )            \\\n//                       * sin( 6.*(u.x - iTime) )   \\\n//                    + u.y * 1e2 )\n\n// Understandable form\nvoid mainImage( out vec4 color, in vec2 cord )\n{\n    // Normalized pixel coordinates (from -1 to 1) on the center\n     vec2 u = 2. * cord/iResolution.xy - 1.;\n    \n    // Storing the dot value in u.x to later use\n    // Second sin is for the wave\n    // u.y * 1e2 are the lines\n    // dot(u,u) equates to distance * distance\n    // 1.5 for the line thickness\n    float wave = (9. / exp(u.x = dot(u,u) ) \n                \t\t\t* sin(6. * (u.x - iTime) ));\n     color = vec4( \n         keyToggle(49)\n         ? wave\n         : 1.5 - sin( wave + u.y * 1e2));\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 102], [392, 415, 463, 528, 969]]}
{"id": "wsf3DM", "name": "Test - Mandelbrot Set", "author": "ikuto", "description": "just trying to draw a mandelbrot set based on iq's article.", "tags": ["mandelbrot"], "likes": 1, "viewed": 315, "published": "Public API", "date": "1547646230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATION 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n\tvec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 c = p + vec2(-0.745, 0.0);\n    vec2 z = vec2(0.0);\n    \n\tint iter;\n    for (iter = 0 ;iter < MAX_ITERATION && length(z) <= 20.0; ++iter) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    \n    //http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n    float smoothIter = float(iter) - log2(log2(dot(z,z))) + 4.0; \n    vec3 color = 0.5 + 0.5*cos(3.0 + smoothIter*0.15 + vec3(0.0,cos(iTime),sin(iTime)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsf3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 82, 82, 620]]}
{"id": "wsf3DX", "name": "tesdty", "author": "Frankie_ST", "description": "zsfdghdfz", "tags": ["test"], "likes": 3, "viewed": 47, "published": "Public", "date": "1547840178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat Circle(vec2 uv, vec2 pos , float r, float blur){\n    float d = length(uv  - pos);\n    \n    return smoothstep(r, r - blur, d);\n}\n\nfloat gearEmpty(vec2 uv, vec2 pos, float scale, float blur){\n \tuv -= pos;\n    uv *= rotate2d(3.0 + iTime);\n    uv /= scale;\n    float a = atan(uv.x, uv.y);\n    \n    float r = length(uv)*2.0;\n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    float step1 = smoothstep(f - blur,f,r);\n    float step2 = smoothstep(f,f+blur,r);;\n    return step1 - step2;\n}\n\nfloat gearFull(vec2 uv, vec2 pos, float scale, float blur){\n \tuv -= pos;\n    uv *= rotate2d(3.0 + iTime);\n    uv /= scale;\n    float a = atan(uv.x, uv.y);\n    \n    float r = length(uv);\n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;    \n    return 1.0 -smoothstep(f,f+blur,r);;\n}\n\nfloat gearFull(vec2 uv, vec2 pos, float scale, float high, float blur){\n \tuv -= pos;\n    //uv *= rotate2d(3.0 + iTime);\n    uv /= scale;\n    float a = atan(uv.x, uv.y);\n    \n    float r = length(uv);\n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2 * high +0.5;    \n    return 1.0 -smoothstep(f,f+blur,r);;\n}\n\nfloat plot (vec2 uv, float pct){    \n  return  smoothstep( pct-0.01, pct, uv.y) -\n          smoothstep( pct, pct+0.01, uv.y);\n}\n\nfloat cosLine(vec2 uv, float pct){\n    uv *= 2.;\n    uv.y -= smoothstep(-0.8, 1.,cos(uv.x*20.0)) * 0.2 ;\n    return plot(uv, pct);\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size, float blur){\n    uv -= p;    \n    uv /= size;\n    float mouth = Circle(vec2(uv.x, uv.y / sin(iTime)), vec2(0.), .3, blur);\n    mouth-= Circle(vec2(uv.x, uv.y / abs(sin(iTime))), vec2(0., .1), .3, blur);\n    \n    float mask = Circle(uv, vec2(.0), .4, blur);\n    mask -= Circle(uv, vec2(-.13, .2), .07, blur);\n    mask -= Circle(uv, vec2(.13, .2), .07, blur);   \n   \n    \n    if(uv.y < 0.05)\n       mask -= mouth;\n    return mask;\n}\n\nfloat Band(float t, float start, float end, float blur){\n \tfloat step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur){\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1 * band2;\n}\n\nfloat Line(vec2 uv, vec2 begin, vec2 end, float width, float blur){\n    uv -= begin;\n \tvec2 div = end - begin;\n    uv *= rotate2d(atan(div.x, div.y));\n    float d = length(div);\n    return Rect(uv, - width/2., width/2., .0, d, blur);        \n}\n\nfloat Wheel(vec2 uv, vec2 pos, float scale, float blur){\n    //gearFull((uv-pos)*rotate2d(3.0 + iTime), vec2(.0), scale, .5, blur)\n \tfloat result = gearFull(uv, pos, scale, .2, blur) - Circle(uv, pos, .45 * scale, blur);\n    for(int i = 0; i < 12; i++)\n        result += Line(uv, pos, vec2(pos.x, pos.y + 0.45* scale) * rotate2d(float(i)*3.14 * 2./12.), .01, blur/5.); \n    return result;\n}\nfloat GearChain(vec2 uv, vec2 pos, float scale, float blur){\n    float result = gearFull(uv, pos, scale, .5, blur) - Circle(uv, pos, .15 * scale, blur);\n    return result;\n}\n\nfloat Chain(vec2 uv){\n    float result = (Circle(uv, vec2(-.1,-.25) , .09, .001) - Circle(uv, vec2(-.1,-.25) , .086, .001))*\n        (1.0 - Circle(uv, vec2(-.15,-.25) , .09, .001));\n    result += Circle(uv, vec2(-.4, -.2) , .03, .001) - Circle(uv, vec2(-.4, -.2) , .026, .001);\n    result *= (1.0 - Circle(uv, vec2(-.38, -.205) , .03, .001));\n    result += Line(uv, vec2(-.1, -.162), vec2(-.4, -.173), .004, .001);\n    result += Line(uv, vec2(-.12, -.335), vec2(-.4, -.23), .004, .001);\n    return result;\n}\n\nfloat Rama(vec2 uv){\n \tfloat result = Line(uv, vec2(-.4, -.2), vec2(-.1,-.25), .02, .001);\n    result += Line(uv, vec2(-.1, .0), vec2(-.4, -.2), .02, .001);\n    result += Line(uv, vec2(-.1, -.25), vec2(-.1, .05), .02, .001);\n    result += Line(uv, vec2(.4, -.2), vec2(.35, .15), .02, .001);\n    result += Line(uv, vec2(-.1, -.25), vec2(.35, .08), .02, .001);\n    result += Line(uv, vec2(-.1, .0), vec2(.35, .08), .02, .001);\n    result += Line(uv, vec2(.3, .13), vec2(.4, .18), .02, .001);\n    result += Line(uv, vec2(-.15, .05), vec2(.0, .05), .02, .001);\n    return result;\n}\n\nvec3 Vechicle(vec2 uv, vec2 pos, float scale, float blur){\n    uv -= pos;\n    uv /= scale;\n    vec2 w_pos1 = vec2(-.4, -.2), w_pos2 = vec2(.4, -.2);\n    \n    float wls = Wheel((uv-w_pos1)*rotate2d(iTime), vec2(.0, .0), .38, .01) +  \n        Wheel((uv-w_pos2)*rotate2d(iTime), vec2(.0, .0), .38, .01);\n        \n    float smile = Smiley(uv, vec2(.0, .3), .2, .01);\n        \n    float rama = Rama(uv);\n    float g_chain1 = GearChain((uv-vec2(-.1, -.25))*rotate2d(iTime), vec2(.0, .0), .15, .01);\n    float g_chain2 = GearChain((uv-vec2(-.4, -.2))*rotate2d(iTime), vec2(.0, .0), .05, .01);\n    float chain = Chain(uv);\n    \n    vec3 result = vec3(1., .0, 1.) * wls*(1.0 - rama);\n    result += vec3(.0, .0, 1.) * rama;\n    result += vec3(1., 1., 1.) * g_chain1;\n    result *= 1.0 - g_chain2;\n    result += vec3(1., 1., 1.) * g_chain2;\n    result *= 1.0 - chain;\n    result += vec3(1., .0, .0) * chain;\n    //result -= vec3(.0, .0, 1.) * (wls*rama);\n    \n    return result;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float d = length(uv);\n    \n    //float smile = Smiley(uv, vec2(-.45, -.1), .5, .01);\n    float smile = Smiley(uv, vec2(-.0, .25), .15, .01);   \n    \n    \n    vec3 result = vec3(1., 1., 1.) * smile;\n    //vec3 result = vec3(1., .0, 1.) * cl;\n    result += Vechicle(uv, vec2(.0), .5, .01);\n    //result += vec3(1., .0, 1.) * line;\n     \n    // Output to screen\n    fragColor = vec4(result,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsf3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [116, 116, 170, 170, 249], [251, 251, 311, 311, 615], [617, 617, 676, 676, 908], [910, 910, 981, 981, 1223], [1225, 1225, 1257, 1257, 1352], [1354, 1354, 1388, 1388, 1486], [1488, 1488, 1542, 1542, 1960], [1962, 1962, 2018, 2018, 2162], [2164, 2164, 2246, 2246, 2369], [2371, 2371, 2438, 2438, 2614], [2616, 2616, 2672, 2746, 3006], [3007, 3007, 3067, 3067, 3180], [3182, 3182, 3203, 3203, 3689], [3691, 3691, 3711, 3711, 4268], [4270, 4270, 4328, 4328, 5239], [5246, 5246, 5303, 5353, 5846]]}
{"id": "Wsf3RS", "name": "new ver for rand generating", "author": "jcyuan", "description": "fix iOS error when generate rand.\nauthor: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/", "tags": ["random", "hash"], "likes": 1, "viewed": 156, "published": "Public", "date": "1546840030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4djSRW use this version please!\n\n#define PI 3.14159265359\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv, float seed ) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot( uv.xy + seed, vec2( a, b ) ), sn = mod( dt, PI );\n    return fract(sin(sn) * c + seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = .5 + .5 * cos(iTime + uv.xyx + vec3(0, 2, 4)) + rand(uv * iTime, 0.);\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 422, 479, 479, 641]]}
{"id": "Wsf3WB", "name": "Transparent sphere and cube", "author": "gest", "description": "experiment", "tags": ["cube", "sphere", "intersect"], "likes": 4, "viewed": 103, "published": "Public", "date": "1547303189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------------------\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\nPlane plane_1 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,1,0));\nPlane plane_2 = Plane(vec3(0.0, 0.0, 0.0), vec3(0,0,1));\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\nSphere sphere_1 = Sphere(vec3(-1.0, 1.5, 1.0), 0.4);\nSphere sphere_2 = Sphere(vec3( 1.0, 1.5, 1.0), 0.4);\nSphere sphere_3 = Sphere(vec3( 0.0, 1.5, 1.0), 0.4);\nSphere sphere_4 = Sphere(vec3( 0.0, 1.5, 2.0), 0.4);\n\t\nstruct Box {\n\tvec3 center;\n\tvec3 size;\n};\nBox box_1 = Box(vec3(-1.0, 1.5, -1.0), vec3(0.4) );\nBox box_2 = Box(vec3( 1.0, 1.5, -1.0), vec3(0.4) );\nBox box_3 = Box(vec3( 0.0, 1.5, -1.0), vec3(0.4) );\nBox box_4 = Box(vec3( 0.0, 1.5, -2.0), vec3(0.4) );\n\nstruct Material {\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n\tfloat shininess;\n\t\n\tfloat reflectivity;\n\tfloat refractivity;\n\tfloat indexRefractive;\n\tbool flagSolid;\n};\n\nconst Material material_sphere_1 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_2 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_3 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_sphere_4 \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\n\nconst Material material_box_1 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.6, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_2 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.6, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_3 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.6), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\nconst Material material_box_4 \t\t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.2, 0.9, 0.8, true  );\n\nconst Material material_plane_1b \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.2, 0.2, 0.2), vec3(1.0), 128.0, 0.5, 0.0, 0.0, false );\nconst Material material_plane_1w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.9, 0.9, 0.9), vec3(1.0), 128.0, 0.0, 0.5, 1.0, true );\n\nconst Material material_plane_2b \t= \tMaterial ( vec3(0.1, 0.0, 0.0), vec3(0.9, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.0, 0.0, true );\nconst Material material_plane_2w \t= \tMaterial ( vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0), 128.0, 0.0, 0.9, 0.95, true );\n\t\nstruct Light {\n\tvec3 position;\n\tvec3 colorAmbient;\n\tvec3 colorDiffuse;\n\tvec3 colorSpecular;\n};\nLight light_0 = Light ( vec3(-10.0, 10.0, 10.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0) );\nLight light_1 = Light ( vec3( 10.0, 10.0, 10.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0) );\n\nMaterial getMaterial (Ray ray) {\n\tMaterial material;\n\tif (ray.object.id == 1) {\n\t\tfloat squareSize = 1.0;\n\t\tvec3 p = mod ( ray.position - plane_1.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s*0.5;\n\t\tfloat h = s*0.5;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_1b;\n\t\t} else {\n\t\t\tmaterial = material_plane_1w;\n\t\t}\n\t} else if (ray.object.id == 2) {\n\t\tfloat squareSize = 0.25;\n\t\tvec3 p = mod ( ray.position - plane_2.center - ray.epsilon, squareSize * 2.0 );\n\t\tfloat s = squareSize;\n\t\tfloat l = s;\n\t\tfloat h = s;\n\t\tif ( ( p.x < l && p.y < l && p.z < l ) ||\n\t\t\t ( p.x > h && p.y < l && p.z > h ) ||\n\t\t\t ( p.x < l && p.y > h && p.z > h ) ||\n\t\t\t ( p.x > h && p.y > h && p.z < l ) ) {\n\t\t\tmaterial = material_plane_2b;\n\t\t} else {\n\t\t\tmaterial = material_plane_2w;\n\t\t}\n\t} else if (ray.object.id == 3) {\n\t\tmaterial = material_sphere_1;\n\t} else if (ray.object.id == 4) {\n\t\tmaterial = material_sphere_2;\n\t} else if (ray.object.id == 5) {\n\t\tmaterial = material_sphere_3;\n\t} else if (ray.object.id == 6) {\n\t\tmaterial = material_sphere_4;\n\t} else if (ray.object.id == 7) {\n\t\tmaterial = material_box_1;\n\t} else if (ray.object.id == 8) {\n\t\tmaterial = material_box_2;\n\t} else if (ray.object.id == 9) {\n\t\tmaterial = material_box_3;\n\t} else if (ray.object.id == 10) {\n\t\tmaterial = material_box_4;\n\t}\n\treturn material;\n}\n\t\n//-----------------------------------------------------------------------------------------\t\n//Пересечение луча со сферой\nfloat intersectSphere(Ray ray, Sphere sphere, inout vec3 normal) {\n\tfloat t0, t1, t;\n\t\n\tvec3 l = sphere.center - ray.origin;\n\tfloat tca = dot(l, ray.direction);\n\tif ( tca < 0.0 ) return ray.far;\n\tfloat d2 = dot (l, l) - (tca * tca);\n\tfloat r2 = sphere.radius*sphere.radius;\n\tif ( d2 > r2 ) return ray.far;\n\tfloat thc = sqrt(r2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\t\t\n\tif ( t0 < 0.0 ) {\n\t\tt = t1;\n\t} else if ( t1 < 0.0 ) {\n\t\tt = t0;\n\t} else {\n\t\tt = min(t0,t1);\n\t}\n\tif (t<0.0) return ray.far;\n\tvec3 p = ray.origin + t * ray.direction;\n\tfloat flagInside = -sign(dot(ray.direction, p - sphere.center));\n\tnormal = normalize ( p - sphere.center ) * flagInside;\n\treturn t;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane(Ray ray, Plane plane, inout vec3 normal) {\n\tfloat det = dot ( plane.normal, ray.direction );\n\tif (abs(det) < ray.epsilon) return ray.far;\n\n\tfloat t = - ( dot ( plane.normal, ray.origin ) + length(plane.center) ) / dot ( plane.normal, ray.direction );\n\t\n\tif ( t < 0.0 ) return ray.far;\n\t\n\tfloat flagInside = -sign(dot(ray.direction, plane.normal));\n\tnormal = plane.normal;\n\tnormal *= flagInside;\n\t\t\n\treturn t;\t\n}\n//Пересечение луча с кубом\nfloat intersectBox(Ray ray, Box box, inout vec3 normal) {\n\t\n\tvec3 minp = box.center - box.size;\n\tvec3 maxp = box.center + box.size;\n\t\n\tfloat tmin = (minp.x - ray.origin.x) / ray.direction.x;\n\tfloat tmax = (maxp.x - ray.origin.x) / ray.direction.x;\n\tif (tmin > tmax) { \n\t\tfloat s = tmin; \n\t\ttmin = tmax; \n\t\ttmax = s; \n\t}\n\tfloat tymin = (minp.y - ray.origin.y) / ray.direction.y;\n\tfloat tymax = (maxp.y - ray.origin.y) / ray.direction.y;\n\tif (tymin > tymax) { \n\t\tfloat s = tymin; \n\t\ttymin = tymax; \n\t\ttymax = s; \n\t}\n\tif ((tmin > tymax) || (tymin > tmax)) return ray.far;\n\tif (tymin > tmin) tmin = tymin;\n\tif (tymax < tmax) tmax = tymax;\n\tfloat tzmin = (minp.z - ray.origin.z) / ray.direction.z;\n\tfloat tzmax = (maxp.z - ray.origin.z) / ray.direction.z;\n\tif (tzmin > tzmax) { \n\t\tfloat s = tzmin; \n\t\ttzmin = tzmax; \n\t\ttzmax = s; \n\t}\n\tif ((tmin > tzmax) || (tzmin > tmax)) return ray.far;\n\tif (tzmin > tmin) tmin = tzmin;\n\tif (tzmax < tmax) tmax = tzmax;\n\t\n\tfloat t;\n\tif ( tmin < ray.epsilon && tmax < ray.epsilon ) return ray.far;\n\tif ( tmin < ray.epsilon ) {\n\t\tt = tmax;\n\t} else if ( tmax < ray.epsilon ) {\n\t\tt = tmin;\n\t} else {\n\t\tt = min(tmin, tmax);\n\t}\n\t\n\tfloat flagInside = 1.;\n\tif ( tmin < ray.epsilon && tmax > ray.epsilon ) flagInside = -1.;\n\t\n\tvec3 p = ray.origin + t * ray.direction;\n\t\n\tif ( abs(p.x - maxp.x) < ray.epsilon ) {\n\t\tnormal = vec3(1,0,0) * flagInside;\n\t} else if ( abs(p.x - minp.x) < ray.epsilon ) {\n\t\tnormal = vec3(-1,0,0) * flagInside;\n\t} else if ( abs(p.y - maxp.y) < ray.epsilon ) {\n\t\tnormal = vec3(0,1,0) * flagInside;\n\t} else if ( abs(p.y - minp.y ) < ray.epsilon ) {\n\t\tnormal = vec3(0,-1,0) * flagInside;\n\t} else if ( abs(p.z - maxp.z ) < ray.epsilon ) {\n\t\tnormal = vec3(0,0,1) * flagInside;\n\t} else {\n\t\tnormal = vec3(0,0,-1) * flagInside;\n\t}\n\treturn t;\n}\n\n//---------------------------------------------------------------------------------\nvoid rayMarch(inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.hit = false;\n\tray.distance = Infinity;\n\tray.position = ray.origin + ray.distance * ray.direction;\n\tray.normal = vec3(0);\n\tray.object.id = -1;\n\n\tSphere sphere;\n\tPlane plane;\n\tBox box;\n\t\n\tfloat d;\n\tvec3 normal;\n\n\t//Горизонтальная поверхность\n\tplane = plane_1;\n\td = intersectPlane ( ray, plane, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 1;\n\t}\n\t\n\t//Вертикальная поверхность\n\tplane = plane_2;\n\td = intersectPlane ( ray, plane, normal );\n\tif (ray.distance > d) {\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tif (p.y>0. && p.y < 1.0 && abs(p.x) < 2.) {\n\t\t\tray.hit \t \t= true;\n\t\t\tray.distance \t= d;\n\t\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\t\tray.normal   \t= normal;\n\t\t\tray.object.id \t= 2;\n\t\t}\n\t}\n\t\n\t//Красная сфера\n\tsphere = sphere_1;\n\tsphere.center.y += sin(u_time * 0.4);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 3;\n\t}\n\t\n\n\t//Зеленая сфера\n\tsphere = sphere_2;\n\tsphere.center.y += cos(u_time * 0.5);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 4;\n\t}\n\t\n\t\n\t//Синяя сфера\n\tsphere = sphere_3;\n\tsphere.center.y += sin(u_time * 0.5);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 5;\n\t}\n/*\n\t//Белая сфера\n\tsphere = sphere_4;\n\tsphere.center.y += cos(u_time * 0.4);\n\td = intersectSphere ( ray, sphere, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 6;\n\t}\n*/\t\n\tbox = box_1;\n\tbox.center.y += cos(u_time * 0.4);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 7;\n\t}\n\n\tbox = box_2;\n\tbox.center.y += sin(u_time * 0.5);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 8;\n\t}\n\n\tbox = box_3;\n\tbox.center.y += cos(u_time * 0.5);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 9;\n\t}\n/*\n\tbox = box_4;\n\tbox.center.y += sin(u_time * 0.4);\n\td = intersectBox ( ray, box, normal );\n\tif (ray.distance > d) {\n\t\tray.hit \t \t= true;\n\t\tray.distance \t= d;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal   \t= normal;\n\t\tray.object.id \t= 10;\n\t}\n*/\t\n}\n\nvec3 lighting(Ray ray, Light lights[2], Material material) {\n\tvec3 col = vec3(0);\n\t\n\tfor (int i=0; i<2; i++) {\n\t\tLight light = lights[i];\n\t\t\n\t\tfloat lightDistance = length(light.position - ray.position);\n\t\t\n\t\t//Тень\n\t\tfloat shadowFactor = 1.0;\n\t\t\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= normalize(light.position - ray.position);\n\t\t\tray1.near \t\t= 0.01;\n\t\t\tray1.far\t\t= lightDistance;\n\t\t}\n\t\trayMarch ( ray1 );\n\t\n\t\t\n\t\tif ( ray1.distance < ray1.far) {\n\t\t\tshadowFactor = clamp(1. - (lightDistance - 3.*ray1.distance) / lightDistance, 0.2, 1.);\n\t\t}\n\t\t\n\t\tfloat distanceAttenuationPower = 0.2;\n\t\tvec3 lightDir \t= normalize(light.position - ray.position);\n\t\tvec3 eyeDir \t= - ray.direction; //normalize ( ray.origin - ray.position );\n\t\tvec3 reflected \t= reflect ( -lightDir, ray.normal );\n\t\n\t\tvec3 color = light.colorAmbient * material.colorAmbient;\n\t\n\t\tcolor += shadowFactor * light.colorDiffuse * material.colorDiffuse * max(dot(ray.normal,lightDir), 0.0);\n\t\tcolor += shadowFactor * light.colorSpecular * material.colorSpecular * pow ( max ( dot(reflected, eyeDir), 0.0) , material.shininess ) * step(1., shadowFactor) ;\t\n\t\tcolor *= min ( 1.0/pow(length(ray.position - ray.origin), distanceAttenuationPower), 1.0);\n\t\n\t\tcol += color/2.;\n\t}\n\t\n\treturn col;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[2]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\t//Цвет фона\n\t\t\tcolor += vec3(0.1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[2]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления сквозь фигуру\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\n\t\t\t//Пересечение луча с границей 2 той же фигуры \n\t\t\trayMarch (ray);\n            \n            if (! material.flagSolid) {\n\n\t\t\t\t\n\t\t\t\tif (ray.hit) {\n\t\t\t\t\t//Достигли границы 2 фигуры\n\t\t\t\t\t//Луч преломления сквозь границу 2 фигуры\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t//Цвет за границей 2 фигуры\n\t\t\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t\t\t\t\n\t\t\t\t\t//Луч отражения от границы 2\n\t\t\t\t\t{\n\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t}\n\t\t\t\t\t//Отражение от границы 2\n\t\t\t\t\trayMarch (ray);\n\t\t\t\t\t\n\t\t\t\t\tif (ray.hit) {\n\t\t\t\t\t\t//Отраженный луч достиг границы 1 фигуры\n\t\t\t\t\t\t//Луч преломления сквозь границу 1 фигуры\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Уменьшаем фактор преломления\n\t\t\t\t\t\tfactorRefract *= material.refractivity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec3 u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2.0 - 1.0;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy -= 0.5;\n    if (u_mouse.xy==vec2(0) ) mouse.xy = vec2(0);\n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n\n        cam.origin  = vec3(0.0, 3.0, 3.0);\n        \t\t\t\t\n\t\tif (mouse.z != 0.0) {\n\t\t\trotate(cam.origin, vec3(1,1,0) * vec3(PI/3. + mouse.y*PI, mouse.x*2.*PI + u_time * 0.2, 0));\n\t\t} else {\n\t\t\trotate(cam.origin, vec3(0,1,0) * u_time * 0.2);            \n\t\t}\t\n\t\t\t\t\t\t\t\t\t\n//        cam.origin  = vec3(0.0, 3.0, 3.0 + mouse.z);\n//        rotate (cam.origin, vec3(1,1,0) * vec3(mouse.y*PI, mouse.x*PI*2. + (mouse.z==0. ? u_time/4. : 0.), 0));\n\n        cam.target  = vec3(0,1,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 1e20;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 1;\n    }\t\n\n    rotate(light_0.position, vec3(0,1,0)*u_time*0.25);\n    rotate(light_1.position, vec3(0,1,1)*u_time*0.25);\n\n    vec3 color = vec3(0);\n\n    Light lights[2];\n    lights[0] = light_0;\n    lights[1] = light_1;\n\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);\n\n    //Гаммакоррекция\n    //\t\t\tcolor = pow(color, vec3(1.0/2.2));\n\n    GL_FragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1670, 1719, 1762, 1826, 2305], [2307, 2429, 2464, 2464, 2478], [2479, 2519, 2562, 2562, 2580], [2581, 2615, 2652, 2652, 2940], [2941, 5764, 5796, 5796, 7248], [7251, 7396, 7462, 7462, 8067], [8068, 8126, 8189, 8189, 8558], [8559, 8607, 8664, 8664, 10388], [10390, 10474, 10504, 10504, 13798], [13800, 13800, 13860, 13860, 15085], [15087, 15117, 15166, 15197, 15795], [15796, 15830, 15879, 15879, 17998], [18000, 18000, 18063, 18063, 19531]]}
{"id": "Wsf3Ws", "name": "Varying Circles", "author": "brentfred", "description": "Messing around with circles", "tags": ["circles"], "likes": 1, "viewed": 81, "published": "Public", "date": "1547752562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 BLUE = vec3(0.0, 0.0, 1.0);\n\nconst float THICK = 50.0;\n\nfloat circle(in float radius, in float thickness, float dist) {\n \treturn smoothstep(radius - thickness/2.0, radius, dist) \n        \t- smoothstep(radius, radius + thickness/2.0, dist);   \n}\n\nfloat radiusFromTime(in float t, in float speedMod) {\n \treturn mod(t*speedMod, iResolution.y);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 CENTER = vec2(iResolution.xy/2.0);\n    float dist = distance(CENTER, fragCoord);\n    \n    float radiusR = radiusFromTime(iTime, 100.0);\n    float radiusG = radiusFromTime(iTime, 30.0);\n    float radiusB = radiusFromTime(iTime, 25.0);\n    \n    vec3 color = vec3(0.0);\n    color += RED * circle(radiusR, THICK, dist);\n    color += GREEN * circle(radiusG, THICK, dist);\n    color += BLUE * circle(radiusB, THICK, dist);\n        \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 208, 208, 333], [335, 335, 388, 388, 434], [436, 436, 493, 493, 964]]}
{"id": "Wsf3z2", "name": "First Gen Pokeballs", "author": "bitnenfer", "description": "I've added all  the first gen pokeballs. To view them you can just use the mouse Y coordinate to scroll through them.\nIt has Poke Ball, Safari Ball, Great Ball, Ultra Ball and Master Ball.", "tags": ["raymarching", "pokeball", "pbr", "pokemon"], "likes": 18, "viewed": 498, "published": "Public", "date": "1546822799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.iquilezles.org/www/articles/morenoise/morenoise.htm\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//https://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n    float f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values      \n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n    return vec4( a, d );\n}\n\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Hit\n{\n    float dist;\n    Material material;\n};\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\n#define EPSILON 0.001\n#define MAX_DIST 10.0\n#define MIN_DIST EPSILON\n#define PI 3.14159265359\n\nmat2 rot(float r) { \n    return mat2(\n        cos(r), sin(r),\n        -sin(r), cos(r)\n    );\n}\n\nfloat sdfSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdfBox(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat pokeBallTop(vec3 p)\n{\n    float s = sdfSphere(p, 0.5);\n    float b = sdfBox(p + vec3(0.0, 0.47, 0.0), vec3(0.6, 0.5, 0.6));\n    return max(s, -b);\n}\n\nfloat pokeBallBottom(vec3 p)\n{\n    float s = sdfSphere(p, 0.5);\n    float b = sdfBox(p + vec3(0.0, -0.47, 0.0), vec3(0.6, 0.5, 0.6));\n    return max(s, -b);\n}\n\nfloat pokeBallButtonCutout(vec3 p)\n{\n    p.z += 0.5;\n    p.yz *= rot(3.14/2.0);\n    float cy = sdCappedCylinder(p, vec2(0.13));\n    return cy;\n}\n\nfloat btnDist = 0.0;\nfloat pokeBallButton(vec3 p)\n{\n    vec3 p0 = p;\n    p0.z += 0.47;\n    p0.yz *= rot(3.14/2.0);\n    float cy0 = sdCappedCylinder(p0, vec2(0.1, 0.01));\n\n    vec3 p1 = p;\n    p1.z += 0.49;\n    p1.yz *= rot(3.14/2.0);\n    float cy1 = sdCappedCylinder(p1, vec2(0.06, 0.01));\n    \n    float c = sdfSphere(p + vec3(0.0, 0.0, 0.585), 0.1);\n    \n    float d = min(cy0, max(cy1, -c));\n    btnDist = 0.01 / (d * d);\n    return d;\n}\n\n\nMaterial mixMaterial(Material a, Material b, float s)\n{\n    return Material(\n        mix(a.albedo, b.albedo, s),\n        mix(a.roughness, b.roughness, s),\n        mix(a.metallic, b.metallic, s)\n    );\n}\n\nHit minHit(Hit a, Hit b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nHit interHit(Hit a, Hit b)\n{\n    if (a.dist > b.dist) return a;\n    return b;\n}\n\nfloat noise = 0.0;\nfloat noise2 = 0.0;\nfloat noise3 = 0.0;\nfloat noise4 = 0.0;\nfloat ballRot = 0.0;\nfloat ballOffset = 0.0;\nfloat wave = 0.0;\n\nHit pokeBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    float noiseDist = 1.0 - clamp((p.y * 2.8), 0.0, 1.0);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(1.0, 0.01, 0.01), 0.6, 0.7), \n        Material(vec3(0.7, 0.8, 1.0), 0.0, 1.0),\n        noiseDist * clamp(1.0 - pow(noise-0.01, 2.5), 0.0, 1.0)\n    ));\n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.0), 0.1, 1.0),\n        pow((1.0 - noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.6, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise3\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(15.0, 1.0, 1.0) * 0.5 + abs(wave), 0.1, 0.1));\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nHit safariBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        mixMaterial(\n            Material(vec3(0.2, 1.9, 0.2), 0.6, 0.7), \n            Material(vec3(0.0, 0.1, 0.0), 0.6, 0.7),\n            noise4\n        ),\n        Material(vec3(0.2, 0.2, 0.0), 0.6, 0.7),\n        pow(noise2, 10.0) * .5\n    ));\n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.0), 0.1, 1.0),\n        pow((1.0 - noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n\n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nHit ultraBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist = 1.0 - clamp((p.y * 2.5), 0.0, 1.0);\n    float topI = sdfBox(p + vec3(0.25, -0.53, 0.0), vec3(0.1, 0.5, 0.5));\n    \n    topI = min(topI, sdfBox(p + vec3(-0.25, -0.53, 0.0), vec3(0.1, 0.5, 0.5)));\n    topI = min(topI, sdfBox(p + vec3(0.0, -0.53, 0.0), vec3(0.2, 0.5, 0.15)));\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.0, 0.0, 0.0), 1.0, 1.), \n        Material(vec3(1.0), 0.1, 1.0),\n        pow(1.0 - noise, 4.0) * noiseDist\n    ));\n    \n    Hit topIHit = Hit(topI, mixMaterial(\n        Material(vec3(1.0, 1.0, 0.0), 0.1, 0.0),\n        topHit.material,\n        pow(noise2, 40.5)\n    ));\n    \n    Hit topHitI = interHit(topHit, topIHit);\n    topHitI.material = topIHit.material;\n    \n    topHit = minHit(topHit, topHitI);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.9, 0.1),\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.1),\n        1.0 - noise2\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n\n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\n//btnDist = 0.01 / (d * d);\nfloat gbRustContrib = 0.0;\nHit greatBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    \n    vec3 p1 = p; \n    vec3 p2 = p; \n    p1.xy *= rot(3.14 / 6.5);\n    p2.xy *= rot(-3.14 / 6.5);\n    \n    float topI = length(vec3(p1.x * 3.0, p1.y * 1.7, p1.z * 1.1) + vec3(0.25, -0.4, 0.0)) - 0.5;\n    \n    topI = min(topI, length(vec3(p2.x * 3.0, p2.y * 1.7, p2.z * 1.1) + vec3(-0.25, -0.4, 0.0)) - 0.5);\n    \n    gbRustContrib = 0.01 / (topI * 0.5);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.001, 0.001, 2.2), 0.6, 0.7), \n        Material(vec3(1.0), 0.1, 1.0),\n        1.0 - (noise2 * pow(noise, 0.1))\n    ));\n    \n    Hit topIHit = Hit(topI, \n        Material(vec3(1.0, 0.0, 0.0), 0.2, 0.8));\n        \n    topHit = minHit(topHit, topIHit);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.2, 0.0),\n        Material(vec3(0.7, 0.8, 1.0), 0.9, 0.0),\n        1.0 - noise2\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(1.0), 0.1, 0.1));\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nfloat mbRustContrib0 = 0.0;\nHit masterBall(vec3 p)\n{\n    float top = pokeBallTop(p);\n    float bottom = pokeBallBottom(p);\n    float inner = sdfSphere(p, 0.48);\n    float buttonCutout = pokeBallButtonCutout(p);\n    float button = pokeBallButton(p);\n    float noiseDist2 = 1.0 - clamp(((1.0 - normalize(p).y) * 0.6), 0.0, 1.0);\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    p1.xy *= rot(3.14 / 4.0);\n    float topI = length(vec3(p1.x, p1.y * 1.6, p1.z ) + vec3(0.0, -0.6, 0.05)) - 0.28;\n    p2.xy *= rot(-3.14 / 4.0);\n    \n    topI = min(topI, length(vec3(p2.x, p2.y * 1.6, p2.z ) + vec3(0.0, -0.6, 0.05)) - 0.28);\n    \n    mbRustContrib0 = 0.01 / (topI * 0.5);\n    \n    top = max(top, -buttonCutout);\n    bottom = max(bottom, -buttonCutout);\n    \n    Hit topHit = Hit(top, mixMaterial(\n        Material(vec3(0.1, 0.2, 1.0), 0.1, 1.0), \n        Material(vec3(0.5, 0.0, 1.0), 0.9, 0.0),\n        pow(clamp((pow(noise2, 0.05) * pow(noise, 0.3)), 0.0, 1.0), 20.5)\n    ));\n    \n    Hit topIHit = Hit(topI, Material(vec3(1.3, 0.1, 0.5), 0.1 + noise4 * 0.3, 0.9));\n    \n    topHit = minHit(topHit, topIHit);\n    \n    Hit bottomHit = Hit(bottom, mixMaterial(\n        Material(vec3(1.0, 1.0, 1.0), 0.6, 0.0),\n        Material(vec3(0.0, 0.0, 0.0), 0.1, 1.0),\n        pow((noise3) * pow(noiseDist2, 1.5), 1.0 - noiseDist2)\n    ));\n    Hit innerHit = Hit(inner, mixMaterial(\n        Material(vec3(0.02, 0.02, 0.02), 0.3, 0.0),\n        Material(vec3(0.02, 0.02, 0.02), 0.1, 1.0),\n        noise2\n    ));\n    \n    Hit buttonHit = Hit(button, Material(vec3(15.0, 1.0, 1.0) * 0.5 + abs(wave), 0.1, 0.1));\n    \n    vec3 P = p + vec3(0.0, -0.15, 0.3);\n    P *= 1.5;\n    vec3 P0 = vec3(P.x * 2.0, P.y, P.z) + vec3(0.31, 0.0, 0.0);\n    vec3 P1 = vec3(P.x * 2.0, P.y, P.z) - vec3(0.31, 0.0, 0.0);\n    vec3 mP0 = P0;\n    vec3 mP1 = P0 + vec3(-.205, -0.18, 0.0);\n    vec3 mP2 = P1;\n    vec3 mP3 = P1  + vec3(.205, -0.18, 0.0);\n    \n    mP0.yx *= rot(PI /7.0);\n    mP1.yx *= rot(-PI / 3.);\n\n    mP2.yx *= rot(-PI /7.0);\n    mP3.yx *= rot(PI / 3.);\n\n    float M = sdfBox(mP0, vec3(0.05, 0.3, 0.4));\n    M = min(M, sdfBox(mP1, vec3(0.05, 0.15, 0.4)));\n    \n    M = min(M, sdfBox(mP2, vec3(0.05, 0.3, 0.4)));\n    M = min(M, sdfBox(mP3, vec3(0.05, 0.15, 0.4)));\n    \n    M = max(M, -sdfBox(P + vec3(0.0, 0.25, 0.0), vec3(0.5, 0.25, 0.5)));\n    \n    Hit hitM = Hit(M, Material(vec3(1.0), 0.1, 0.2));\n    \n    Hit BM = interHit(hitM, topHit);\n    \n    BM.material = hitM.material;\n    \n    topHit = minHit(topHit, BM);\n    \n    return minHit(topHit, minHit(bottomHit, minHit(innerHit, buttonHit)));\n}\n\nfloat ballID = .0;\nHit scene(vec3 p)\n{\n    Hit scene = Hit(p.y + 0.5, Material(vec3(0.0), 0.9, 0.0));\n    \n    p.x += ballOffset;\n    p.zx *= rot(0.4);\n    p.xy *= rot(ballRot);\n    \n    if (ballID == 1.0)\n        scene = minHit(scene, greatBall(p));\n    else if (ballID == 2.0)\n        scene = minHit(scene, safariBall(p));\n    else if (ballID == 3.0)\n        scene = minHit(scene, ultraBall(p));\n    else if (ballID == 4.0)\n        scene = minHit(scene, masterBall(p));\n    else\n        scene = minHit(scene, pokeBall(p));\n   \n    \n    return scene;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(scene(p).dist - vec3(\n        scene(p - e.yxx).dist,\n        scene(p - e.xyx).dist,\n        scene(p - e.xxy).dist\n    ));\n}\n\nHit raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 200; ++i)\n    {\n        vec3 p = ro + rd * t;\n        Hit d = scene(p);\n        if (d.dist < EPSILON)\n        {\n            vec3 cp = p;\n            cp.x += ballOffset;\n            cp.zx *=rot(0.4);\n            cp.xy *= rot(ballRot);\n            noise3 = clamp(length(fbmd(vec3(cp.x * 4.0, cp.y, cp.z * 4.0) * 0.5)), 0.0, 1.0);\n            float noiseDist = clamp((cp.y * 15.5 * noise3), 0.0, 1.0);\n            noise = noiseDist * noise3;\n            noise2 = clamp(length(fbmd(cp) * 1.2), 0.0, 1.0);\n            if (ballID == 1.0)\n            {\n                noise2 = clamp(1.0 - (noise2 * gbRustContrib * 0.5), 0.5, 1.0) * noise2;\n            }\n            else if (ballID == 2.0)\n            {\n                noise4 = clamp(length(fbmd(cp * 0.8)), 0.0, 1.0);\n                noise2 = clamp(length(noise2 * fbmd(cp)), 0.0, 1.0);\n            }\n            else if (ballID == 4.0)\n            {\n                noise4 = clamp(pow(length(fbmd(cp) * 0.9), 30.0), 0.0, 1.0);\n                noise2 = clamp(1.0 - (noise2 * mbRustContrib0 * 1.), 0.4, 1.0);\n            }\n            d = scene(p);\n            return Hit(t, d.material);\n        }\n        t += d.dist * .7;\n        if (t > MAX_DIST) break;\n    }\n    return Hit(MAX_DIST, Material(vec3(0.0), 0.0, 0.0));\n}\n\nfloat NormalDistributionFunction_GGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = PI * (denom * denom);\n    return a2 / denom;\n}\n\nfloat Geometry_GGX(vec3 n, vec3 v, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    float NdotV = max(0.0, dot(n, v));\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat Geometry_Smith(vec3 n, vec3 v, vec3 l, float a)\n{\n    float g1 = Geometry_GGX(n, l, a);\n    float g2 = Geometry_GGX(n, v, a);\n    return g1 * g2;\n}\n\nvec3 Fresnel_Schlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 PBR(vec3 n, vec3 v, DirLight l, in Material material)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float D = NormalDistributionFunction_GGXTR(n, h, roughness);\n    vec3 F = Fresnel_Schlick(v, h, F0);\n    float G = Geometry_Smith(n, v, l.dir, roughness);\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, EPSILON);\n    \n    return (material.albedo * 0.03) + ((Kd * material.albedo / PI + specularBRDF) * radiance * NdotL);\n}\n\nfloat opShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    Material material;\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = scene( ro + rd * t).dist;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.002, 0.010 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat opAO(in vec3 p, in vec3 n)\n{\n    float value = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        float stepSize = 0.05;\n        float dist = scene(p + n * stepSize).dist;\n        value += (stepSize - dist) * s;\n        s *=0.8;\n    }\n    value = value;\n    return clamp(sqrt((0.8 - value) * sqrt(1.0)), -1.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    wave = sin(iTime * 3.0);\n    ballRot = 0.3 + sin(iTime * 10.0 + sin(iTime * 2.1) * PI) * 0.2;\n    ballOffset = ballRot * 0.3;\n    DirLight lights[3];\n\n    lights[0] = DirLight(normalize(vec3(0.3, 0.4, -0.6)), vec3(2.0, 2.0, 3.4));\n    lights[1] = DirLight(normalize(vec3(-0.9, 0.2, -0.6)), vec3(2.9, 2.6, 2.0));\n    lights[2] = DirLight(normalize(vec3(0.9, 0.6, -0.6)), vec3(0.3, 4.6, 2.0));\n\n    vec3 color = vec3(1.0);\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * ar;\n    vec3 ro = vec3(EPSILON, EPSILON, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    float my = -(iMouse.y / iResolution.y * 2.0 - 1.0) * 3.14;\n    \n    ballID = floor((iMouse.y / iResolution.y) * 5.0);\n\n    if (iMouse.z <= 0.0)\n    {\n        //ro.xz *= rot(iTime * 0.5);\n        //rd.xz *= rot(iTime * 0.5);\n    }\n    else\n    {\n        ro.xz *= rot(mx);\n        rd.xz *= rot(mx);\n    }\n\n    Hit hit = raymarch(ro, rd);\n\n    if (hit.dist < MAX_DIST)\n    {\n        vec3 p = ro + rd * hit.dist;\n        vec3 n = norm(p);\n        vec3 v = normalize(-rd);\n        color = vec3(0.01, 0.01, 0.02);\n\n        for (int i = 0; i < 3; ++i)\n        {\n            color += PBR(n, v, lights[i], hit.material);\n\n            vec3 d = lights[i].dir;\n            vec3 o = p + d * 0.1;\n\n            color *= 0.5 + opShadow(o, d, 0.0, 10.5) * 0.5;\n\n        }\n\n        color *= pow(opAO(p, n), 5.0);\n\n    }\n    \n    color = mix(color, vec3(0.01, 0.01, 0.02), clamp(pow(hit.dist / 10.0, 2.3), 0.0, 1.0));\n\n    color += vec3(0.4, 0.01,0.01) * btnDist * abs(wave);\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 89, 89, 125], [127, 373, 399, 399, 1243], [1245, 1245, 1269, 1269, 1704], [1990, 1990, 2009, 2009, 2084], [2086, 2086, 2120, 2120, 2148], [2150, 2150, 2180, 2180, 2275], [2277, 2277, 2319, 2319, 2418], [2420, 2420, 2447, 2447, 2574], [2576, 2576, 2606, 2606, 2734], [2736, 2736, 2772, 2772, 2880], [2903, 2903, 2933, 2933, 3322], [3325, 3325, 3380, 3380, 3527], [3529, 3529, 3555, 3555, 3606], [3608, 3608, 3636, 3636, 3687], [3832, 3832, 3854, 3854, 5049], [5051, 5051, 5075, 5075, 6242], [6244, 6244, 6267, 6267, 7804], [7806, 7861, 7884, 7884, 9334], [9364, 9364, 9388, 9388, 11901], [11922, 11922, 11941, 11941, 12456], [12458, 12458, 12477, 12477, 12655], [12657, 12657, 12689, 12689, 14000], [14002, 14002, 14067, 14067, 14267], [14269, 14269, 14314, 14314, 14442], [14444, 14444, 14499, 14499, 14597], [14599, 14599, 14646, 14646, 14739], [14741, 14741, 14801, 14801, 15515], [15517, 15517, 15588, 15588, 15889], [15891, 15891, 15925, 15925, 16233], [16235, 16235, 16290, 16290, 18104]]}
{"id": "Wsf3zl", "name": "[TWITCH] MC Esher vs DJ Confused", "author": "evvvvil", "description": "\"MC Esher versus DJ Confused Domain\" - Shader showdown practice session 003.\nLive coded on Twitch in 25 minutes from memory.\nPracticing live on TWITCH every Tuesdays around 20:30 UK time.\nhttps://www.twitch.tv/evvvvil_", "tags": ["time", "demoscene", "square", "limit", "live", "battle", "shadershowdown", "mc", "pole", "coding", "twitch", "showdown", "esher", "confused", "perpendicular"], "likes": 13, "viewed": 954, "published": "Public API", "date": "1547143516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\"MC Esher versus DJ Confused Domain\" - Shader Showdown practice session 005\n\n////////////////////////////////////////\n// WHAT THE FUCK IS THE SHADER SHOWDOWN?\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coder battle for 25 minutes making a shader from memory on stage. \n// The audience votes for the winner by making noise or by voting on their phone.\n// Winner goes through to the next round until the final where champion is crowned.\n// Live coding shader software used is BONZOMATIC made by Gargaj from Conspiracy:\n// https://github.com/Gargaj/Bonzomatic\n\n// Every tuesdays around 20:00 UK time I practise live on TWITCH.\n// This is the result of session 003. \n// Theme of the day was: MC Esher feat. DJ Confused Domain\n\n// COME SEE LIVE CODING EVERY TUESDAYS HERE: https://www.twitch.tv/evvvvil_\n\n// evvvvil / DESiRE demogroup\n\nvec2 sc,e=vec2(.00035,-.00035);float t,tt;vec3 np;\n\n//Cheap box function bullshit, distilling some of IQ's brain so I can play god\nfloat mx(vec3 p){return max(max(p.x,p.y),p.z);}\nfloat bo(vec3 p,vec3 r){return mx(abs(p)-r);}\n\n//Simple 2d rotate function, nothing to see here, move along, find the shiny piece of candy\nmat2 r2(float r) {return mat2(cos(r),sin(r),-sin(r),cos(r));}\n\n//Fucking bits function which make the the fucking bit/piece:\n//Essentially the piece is some stairs + walls around + poles nearly as long as my dick\nvec2 fb( vec3 p )\n{\n    p.xz*=r2(0.785*(1.+2.*clamp(sin(tt*.5),-.5,.5)));\n    p.xy*=r2(0.785*(1.+2.*clamp(sin(tt*.5),-.5,.5)));\n    vec2 h,t=vec2(1000,5);\n    for(int i=0;i<7;i++){\n        t.x=min(t.x,bo(p+vec3(0,0.2*float(i),0.4*float(i)),vec3(1,.1,0.2)));\n    }\n    h=vec2(bo(abs(p-vec3(0,-.6,-1.3))-vec3(1,0,0),vec3(0.2,.8,1.6)),3);\n    h.x=min(h.x,bo(abs(p-vec3(0,0,-1.4))-vec3(1,0,1),vec3(0.1,6,0.1)));\n    t.x=min(t.x,bo(abs(p-vec3(0,-.3,-1.4))-vec3(1,abs(sin(tt*.66))*6.,1),vec3(.15)));\n    t=(t.x<h.x)?t:h;\n    return t;\n}\n\n//Map function / scene / Where the geometry is made. This fucker is centre stage broski\nvec2 mp( vec3 p )\n{\n  p.yz*=r2(0.785*clamp(cos(tt*0.5),-.25,.25)*4.);\n  p.z=mod(p.z+tt*6.3,40.)-20.;\n  //np=new position. We we symetry clone the fucker, rotate it, shift the bitch, then rotate again till it fucking screams\n  np=p;\n  for(int i=0;i<5;i++){\n      np=abs(np)-vec3(3.9+clamp(sin(tt*.5),-.5,.5),3.7,2);\n      np.xy*=r2(.785*float(i)*2.);\n      np-=vec3(-2,1,2.5);\n      np.xz*=r2(.785*float(i)*3.);\n  }\n  vec2 t=fb(np);\n  return t;\n}\n\n//Main raymarching loop with material ID flex\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>60.) break;\n    t.x+=h.x;\n    //This extra line passes the material id\n    t.y=h.y;\n  }\n  if(t.x>60.) t.x=0.;\n  return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1);//Boilerplate code building uvs by default in BONZOMATIC\n    //Modulo time because I am god and I fucking decide how long this world lives (not really just stops it all getting fucking noisy)  \n    tt=mod(iTime,100.);\n    //Camera simple bullshit thing ro=ray origin, rd=ray direction, co=color, fo=fog colour, ld=light direction\n    vec3 ro=vec3(0,0,0),\n        cw=normalize(vec3(cos(tt)*2.,5.,sin(tt*.25)*15.)-ro),\n        cu=normalize(cross(cw,vec3(0,1,0))),\n        cv=normalize(cross(cu,cw)),\n        rd=normalize(mat3(cu,cv,cw)*vec3(uv,.5)),co,fo,ld=vec3(.3,.5,-.5);\n    //Setting up default background colour and fog colour\n    vec3 bk=vec3(.5)*(1.-(length(uv)-.2));co=fo=bk;\n    //Grabbing the fucking scene by shooting fuckin' rays, because I am god and I'm the kind of god that shoots fucking rays from his eyes\n    sc=tr(ro,rd);\n    //Stick scene geometry result in this shorter one char variable. Fast and fucking bulbous, get me?\n    t=sc.x;  \n  if(t>0.){\n    //We hit some geometry so let's get the current position (po) and build some normals (no). Get building broh, grab a fucking shovel\n    vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yxy*mp(po+e.yxy).x+e.yyx*mp(po+e.yyx).x+e.xxx*mp(po+e.xxx).x),\n    \n    //LIGHTING MICRO ENGINE BROSKI \n        \n    //Default albedo is yellow because you're still acting like a mango (al=albedo)\n    al=vec3(1,.5,0);    \n    //Yo different material id? No way broski, change the fucking colours then broh! (al=albedo)\n    if(sc.y<5.)al=vec3(.01*ceil(cos(np))+ceil(sin(np.x*1.5)));\n    //dif = diffuse because I dont have time to cook torrance\n    float dif=max(0.,dot(no,ld)),\n    //ao = ambient occlusion, aor = ambient occlusion range\n    aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),\n    //spo=specular power, yeah it's dumb as it's 1, but if I had had time to type in noise function this would be a gloss map. Get over it broski\n    spo=1.,\n    //Fresnel blends the geometry in the background with some sort of gradient edge detection colouring mother fucker\n    fresnel=pow(1.+dot(no,rd),4.);\n    //Fake sub surface fucking scattering, sort of reverse ambient occlusion trick from tekf, big up tekf! https://www.shadertoy.com/view/lslXRj\n    vec3 sss=vec3(.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),\n    //spec=specular again if had had time to type noise function this would be better\n    spec=vec3(1)*pow(max(0.,dot(no,normalize(ld-rd))),spo)*spo/32.;\n    //Ultimate final lighting result\n    co=mix(spec+al*(0.8*ao+0.2)*(dif+sss),bk,fresnel);\n    //Add some fucking fog to blend it even more. Don't get even broh, get soft\n    co=mix(co,fo,1.-exp(-.00003*t*t*t));\n  }\n  //Add some sort of tone mapping for cheap byte sized fuckers (not really god in the end then, hey? just some cheap byte sized fucker)\n  fragColor = vec4(pow(co,vec3(0.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsf3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1008, 1087, 1104, 1104, 1134], [1135, 1135, 1159, 1159, 1180], [1182, 1274, 1292, 1292, 1335], [1337, 1487, 1506, 1506, 2017], [2019, 2107, 2126, 2126, 2552], [2554, 2600, 2629, 2629, 2843], [2845, 2845, 2902, 2902, 5874]]}
{"id": "wsfGDf", "name": "practice-04", "author": "kiyamada96", "description": "day3-2", "tags": ["flower"], "likes": 1, "viewed": 78, "published": "Public", "date": "1547648297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);   \n    float u=abs(sin((atan(p.y,p.x)-length(p)+iTime*0.3)*10.0)*0.5)+0.2;\n    float t=u-length(p);\n    fragColor = vec4(smoothstep(1.5,0.,abs(t)/fwidth(t)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 295]]}
{"id": "WsfGDM", "name": "Parallax starfield", "author": "dax105", "description": "Starfield 2D game background", "tags": ["stars", "starfield"], "likes": 5, "viewed": 465, "published": "Public", "date": "1546439375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original by Alexander Lemke, 2015\n// Voronoi function based on function from iq\n// Simplified as a space background for games by dax105, 2018\n\n//#define SHOW_CELLS\n//#define USE_VORONOI\n#define STAR_LAYER_COUNT 10\n\nvec2 hash(in vec2 p) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat noise(in vec2 p) {\n    #ifdef USE_VORONOI\n    \n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j) {\n        for(int i = -1; i <= 1; ++i) {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash22(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    return md;\n    \n    #else\n    \n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    float md = 1.0;\n\n    // Scale a bit to move from cell edges\n    vec2 o = hash22(n)*0.96 + 0.02;\n\n    vec2 r = o - f;\n    float d = dot(r, r);\n\n    md = min(d, md);\n\n    return md;\n    \n    #endif\n}\n\nvec3 starfield(vec2 samplePosition, float threshold) {\n    float starValue = noise(samplePosition);\n    \n    float power = max(1.0 - (starValue / threshold), 0.0);\n    power = power * power * power;\n    \n    #ifdef SHOW_CELLS\n    power += starValue;\n    #endif\n    \n    return vec3(power);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float maxResolution = max(iResolution.x, iResolution.y);\n    \n\tvec3 finalColor;\n    vec2 sCoord = (fragCoord.xy / maxResolution)*5.0;\n    vec2 pos = vec2(iTime*5.0, sin(iTime)*5.0);\n    \n    // Add starfields\n    for (int i = 1; i <= STAR_LAYER_COUNT; i++) {\n        float fi = float(i);\n        float inv = sqrt(1.0/fi);\n    \tfinalColor += starfield((sCoord + vec2(fi*100.0, -fi*50.0)) * (1.0 + fi * 0.2) + pos, 0.0005)*inv;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 218, 240, 240, 330], [332, 332, 353, 353, 486], [488, 488, 512, 512, 1260], [1262, 1262, 1316, 1316, 1553], [1556, 1556, 1613, 1613, 2095]]}
{"id": "wsfGRB", "name": "Pionowy ruch piłeczki adekwatnie", "author": "paweljagodzinski", "description": "Shader tworzy siatkę, po której porusza się piłeczka w osi pionowej. Ruch ten jest adekwatny do ruchu prostej przecinającej piłeczkę. ", "tags": ["ruchpileczkipoosi"], "likes": 0, "viewed": 64, "published": "Public", "date": "1546704473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Pionowy ruch piłeczki adekwatnie do poziomego ruchu prostej\n//Ustalenie wartości zmiennych globalnych\nvec3 white = vec3(1.0, 1.0, 1.0); //Kolor tła\nfloat gridwidth = 2.0; //Szerokość kratki\nfloat gridgap = 40.0; // odległość między kratkami\nfloat PI = 3.1415; //Liczba PI\nfloat linewidth = 3.0; //Szerokość linii przesuwanej\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixel = white; //domyślne ustawienie pikseli na biało\n    vec3 col2 = vec3(0.2, 0.7, 1.0);\n    vec3 col3 = vec3(0.2, 1.0, 0.2);\n    vec3 col4 = vec3(0.0, 0.0, 0.0);\n    vec3 col5 = vec3(1.0, 0.0, 0.0);\n    float time = iTime;\n    vec2 zero = iResolution.xy / 2.0; //wyśrodkowanie układu współrzędnych\n    //Środek układu przypisanego do linii, który przesuwa się w czasie\n    vec2 floatingzero = vec2((mod(time, 4.0)-2.0<0.0)?(iResolution.x / 2.0 - mod(time*200.0, 20.0*gridgap)+5.0*gridgap):((iResolution.x - 40.0*gridgap) / 2.0 + mod(time*200.0, 20.0*gridgap)+5.0*gridgap), iResolution.y/2.0);\n    //pozycja piłeczki\n    vec2 ballpoz = vec2(zero.x, zero.y+((mod(time, 4.0)-2.0)<=0.0?gridgap*-5.0+mod(time, 2.0)*gridgap*5.0:gridgap*5.0-mod(time, 2.0)*gridgap*5.0));\n    //Rysowanie linii poziomych\n    if (mod(abs(zero.x-fragCoord.x)+gridwidth/2.0, gridgap)<gridwidth) if (zero.x - fragCoord.x < 5.0 && zero.x - fragCoord.x > -5.0) pixel = col5; else pixel = col2;\n    //rysowanie linii pionowych\n    if (mod(abs(zero.y-fragCoord.y)+gridwidth/2.0, gridgap)<gridwidth) if (zero.y - fragCoord.y < 5.0 && zero.y - fragCoord.y > -5.0) pixel = col5; else pixel = col2;\n    //Miejscowienie piłeczki\n    if (length(ballpoz - fragCoord) < 10.0) pixel = col3;\n    //miejscowienie górnej połowy linii\n    if (((fragCoord.x-floatingzero.x+3.0)/(fragCoord.y-floatingzero.y) <= 1.0)&& floatingzero.x-fragCoord.x >= 0.0 && floatingzero.y-fragCoord.y >= 0.0&&(fragCoord.x-floatingzero.x-3.0)/(fragCoord.y-floatingzero.y)>=1.0)\n               pixel = col4;\n    //miejscowienie dolnej połowy linii\n    if (((fragCoord.x-floatingzero.x-3.0)/(fragCoord.y-floatingzero.y)<=1.0)&&floatingzero.x-fragCoord.x<=0.0 && floatingzero.y-fragCoord.y<=0.0&&(fragCoord.x-floatingzero.x+3.0)/(fragCoord.y-floatingzero.y)>=1.0)\n            pixel = col4;\n    //rysowanie\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 338, 395, 395, 2294]]}
{"id": "WsfGRX", "name": "Line And Circle Test", "author": "ZzEeRO", "description": "Line And Circle Test", "tags": ["2d"], "likes": 4, "viewed": 611, "published": "Public API", "date": "1546931144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _BackgroundColor vec4(1.0,1.0,1.0,1.0)\n#define _LineColor vec3(0.0,0.0,0.0)\n#define _LineWidth 5.0\n#define _AA 1.0\n#define _CircleRadius1 45.0\n#define _CircleRadius2 90.0\n#define _CirclePos1 vec2(0.15,1.0)\n#define _CirclePos2 vec2(0.85,1.0)\n#define _CircleColor1 vec3(1.0,0.0,0.0)\n#define _CircleColor2 vec3(0.0,1.0,0.0)\n\nvec4 drawCircle(vec2 pos, vec2 center, float radius, vec3 color, float antialiasing) {\n\t\t\tfloat distance = length(pos - center) - radius;\n\t\t\tfloat threshod = smoothstep(0.0, antialiasing, distance);\n\t\t\treturn vec4(color, 1.0 - threshod);\n\t\t}\n\nvec4 drawLine(vec2 pos, vec2 point1, vec2 point2, float width, vec3 color, float antialiasing) {\n\t\t\tfloat k = (point1.y - point2.y) / (point1.x - point2.x);\n\t\t\tfloat b = point1.y - k * point1.x;\n\t\t\tfloat distance = abs(k*pos.x - pos.y + b) / sqrt(k*k + 1.0);\n\t\t\tfloat threshod = smoothstep(width / 2.0, width / 2.0 + antialiasing, distance);\n\t\t\treturn vec4(color, 1.0 - threshod);\n\t\t}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos=fragCoord;\n    float circleRadius1=_CircleRadius1*smoothstep(-1.0,1.0,sin(iTime));\n    float circleRadius2=_CircleRadius2*smoothstep(-1.0,1.0,sin(iTime+90.0));\n    vec2 circlePos1=vec2(_CirclePos1.x,_CirclePos1.y*smoothstep(-1.0,1.0,sin(iTime)));\n    vec2 circlePos2=vec2(_CirclePos2.x,_CirclePos2.y*smoothstep(-1.0,1.0,sin(iTime+90.0)));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 backgroundColor=vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec3 circleColor1=vec3(0.5+0.5*sin(iTime),uv);\n    vec3 circleColor2=vec3(uv.x,0.5+0.5*sin(iTime),uv.y);\n    \n    vec4 linePic=drawLine(fragCoord,circlePos1*iResolution.xy,circlePos2*iResolution.xy,_LineWidth,_LineColor,_AA);\n    vec4 circlePic1=drawCircle(fragCoord,circlePos1*iResolution.xy,circleRadius1,circleColor1,_AA);\n    vec4 circlePic2=drawCircle(fragCoord,circlePos2*iResolution.xy,circleRadius2,circleColor2,_AA);\n    vec4 layer1=mix(backgroundColor,linePic,linePic.a);\n    vec4 layer2=mix(layer1,circlePic1,circlePic1.a);\n    vec4 layer3=mix(layer2,circlePic2,circlePic2.a);\n    fragColor=layer3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 330, 416, 416, 571], [573, 573, 669, 669, 957], [958, 958, 1015, 1015, 2091]]}
{"id": "wsfGWj", "name": "Circles mathoverflow", "author": "vchizhov", "description": "For a mathoverflow question.", "tags": ["2d", "circles"], "likes": 0, "viewed": 347, "published": "Public API", "date": "1547498545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv-1.0;\n    uv *= vec2(iResolution.x/iResolution.y,1.0);\n\n    const uint n = 8u;\n    float R = 0.5;// + 0.3*sin(0.5*iTime);\n    float r = 0.13 + 0.1*sin(iTime);\n    \n    vec2 bigCircleCenter = vec2(0);\n    \n    vec3 col = vec3(1.0);\n    if(dot(uv-bigCircleCenter,uv-bigCircleCenter)<R*R)\n        col = vec3(0.0,0.0,1.0);\n    else\n    {\n        float delta = 2.0*PI/float(n);\n        float phi = iTime;\n        for(uint i=0u;i<n;++i)\n        {\n            vec2 smallCircleCenter = (R+r)*\n                vec2(cos(delta*float(i)+phi),\n                     sin(delta*float(i)+phi));\n            if(dot(uv-smallCircleCenter,uv-smallCircleCenter)<r*r)\n            {\n                col = hash3(i);\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 69, 112, 295], [297, 297, 354, 404, 1238]]}
{"id": "wsj3RR", "name": "Radial Tendrils", "author": "parameterized", "description": "radial tendrils", "tags": ["2d"], "likes": 4, "viewed": 295, "published": "Public API", "date": "1548019175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float M_PI = 3.1415926535897932384626433832795;\n\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    uv -= iResolution.xy*0.5;\n    uv /= min(iResolution.x, iResolution.y)*0.5;\n    \n    vec3 col = vec3(1.0);\n    \n    uv *= (sin(iTime/4.0)*0.5+0.5)*8.0 + 1.0;\n    float d = length(uv);\n    float angle = atan(uv.y, uv.x);\n    angle += snoise(vec3(uv.x/4.0, uv.y/4.0, iTime))/d/4.0;\n    if (distance(mod(angle/(2.0*M_PI)*8.0, 1.0), 0.5) < 0.2/pow(d, 1.5)) {\n        col = vec3(0.0);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsj3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 78, 78, 115], [116, 116, 143, 143, 191], [193, 193, 214, 214, 2050], [2053, 2053, 2110, 2110, 2560]]}
{"id": "WsjGRR", "name": "Street Fighter 2:Ken", "author": "yasuo", "description": "It's very an experiment. A SNES rendering is pretty tough... I couldn't achieve whole things. It's the only one of the animation part. ", "tags": ["game", "snes"], "likes": 7, "viewed": 357, "published": "Public API", "date": "1547968087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define getBit(num,bit)float( num>>bit & 1)\n\nint[] hadou0A = int[](50331712,58721216,58721152,50332416,0,0,0,0,0,0,0,0,0,0,0,0,0,131072,458752,25673728,53379072,23429120,122880,53002240,22593536,20447232,18612224,9371648,1245184,2031616,983040,655360);\nint[] hadou0B = int[](8389504,1024,1024,8390656,4203008,2097664,2115072,51408896,59804672,17907712,18122752,25755648,1966080,10371072,27230208,11304960,1572864,23396352,1572864,0,9502720,110772224,98041856,13901824,44179456,114688,65536,2097152,786432,0,0,0);\nint[] hadou0C = int[](48,0,0,1024,58727680,62930176,62928896,14683136,6320128,14727168,14905344,7794688,31580160,23166976,6291456,22216704,31916032,9961472,31457280,7864320,4210688,0,36044800,196608,327680,12976128,14843904,5242880,6291456,2097152,1048576,262144);\nint[] hadou1A = int[](41943248,50332608,117440896,128,0,0,0,0,0,0,0,0,0,0,0,0,229376,491520,3596288,3264512,2682880,2125824,1310720,393216,262144,32768,114688,544768,221184,122880,32768,0);\nint[] hadou1B = int[](288,0,8388608,2097664,33556480,33556480,21499904,6144,2368768,50176,2293760,4751360,8356352,6177792,3575808,4161536,3686400,1073152,528384,786432,1376256,1703936,20480,0,114688,606208,655360,32768,0,0,0,0);\nint[] hadou1C = int[](83886592,67108864,4194816,62914816,32507648,32507776,11538304,16254848,14162432,8141568,6094592,3636736,31744,2209792,4808704,4210688,262144,2621440,65536,141312,133120,362496,763904,653312,669696,401408,262144,466944,36864,0,16384,0);\nint[] hadou2A = int[](75497968,117440992,117440704,117440704,50331712,50331648,0,0,0,0,0,0,0,0,0,0,0,7,4,7,114,13304,16355,16379,15923,2816,1827,3040,768,768,0,0);\nint[] hadou2B = int[](16777216,16,256,8388608,67109024,67633440,786816,8,2168192,3151624,1102984,15680,564232,333312,138880,140800,32262,16768,33155,1208,59660,2048,32796,32772,32900,12423,128,0,0,0,0,0);\nint[] hadou2C = int[](33554440,0,0,6291456,15728640,15728848,15728752,16646384,6160504,1016048,994160,1032888,484336,190944,123136,120832,98560,48640,32256,64320,5760,50176,16384,16384,16648,17472,14400,1024,128,0,0,0);\n\nvec3 idleColA = vec3(0.9411765, 0.7529412, 0.0);\nvec3 idleColB = vec3(0.0);\nvec3 idleColC = vec3(0.972549, 0.282353, 0);\n\nint[] fire0A = int[](0,496,7180,2146,12418,24832,57793,24641,8193,5152,2050,3596,496,0);\nint[] fire0B = int[](0,0,496,5000,1608,1661,3614,4030,1022,972,392,128,0,0);\nint[] fire0C = int[](0,0,512,1044,2356,6274,4128,4096,7168,2066,1652,368,0,0);\nint[] fire1A = int[](160,16,34,0,1026,385,2112,64,1153,512,1058,2,512,32);\nint[] fire1B = int[](0,480,28,1008,972,1598,1566,1982,574,396,988,20,224,0);\nint[] fire1C = int[](320,524,960,1038,48,6208,417,2049,2368,114,0,1000,284,192);\n\nvec3 fireColA = vec3(0, 0.4392157, 0.7529412);\nvec3 fireColB = vec3(1.0);\nvec3 fireColC = vec3(0.3686275, 0.7098039, 0.9529412);\n\nint[] floorA = int[](939524096,939524096,805306368,805306368,939524096,939524096,939524096,805306368,805306368,939524096,939524096,939524096,939524096,939524096,805306368,805306368,805306368,805306368,939524096,939524096);\nint[] floorB = int[](111444074,41238550,97812560,111755346,94642184,78774308,111476744,89146424,80020617,124404082,111004885,133908981,123711487,134208494,62119934,62652414,33553911,49741695,44936421,19511915);\nint[] floorC = int[](22773653,92979177,170622895,156680109,39575543,55443419,22740983,179289031,188414838,9813645,23212842,308746,10506240,9233,206315521,205783041,234881544,218693760,89281306,114705812);\nvec3 floorColA = vec3(0.3882353, 0.2392157, 0.1647059);\nvec3 floorColB = vec3(0.5921569, 0.454902, 0.282353);\nvec3 floorColC = vec3(0.8392157, 0.7098039, 0.5803922);\n\nint[] cloudA = int[](0,0,0,0,0,0,0,0,16779504,244844420,268034048,41476112,458752,1024,0,0,0,0,0,0,0,0,0);\nint[] cloudB = int[](0,0,0,0,0,0,0,0,32768,104568,397276,466912,3840,0,0,0,0,0,0,0,0,0,0);\nint[] cloudC = int[](0,0,0,0,0,0,0,224,16742156,23486467,268439587,226492428,41480384,1018624,197632,0,0,0,0,0,0,0,0);\nvec3 cloudColA = vec3(0.8313726, 0.8980392, 0.9490196);\nvec3 cloudColB = vec3(0.7176471, 0.8392157, 0.945098);\nvec3 cloudColC = vec3(1.0);\n\nint[] consA = int[](2147483640,14,2147483647,3,98305,180224,942080,278528,0,0,0,0,0);\nint[] consB = int[](0,2147483632,0,2013266044,1879048194,1073741824,992,125829376,532681728,945836032,808558592,0,0);\nint[] consC = int[](0,0,0,134217600,268337148,1073561596,2146540544,2021375488,1614800896,2072576,933888,2031616,1572864);\nvec3 consColA = vec3(1.0);\nvec3 consColB = vec3(0.0);\nvec3 consColC = vec3(0.7686275, 0.145098, 0.1607843);\n\nint[] fontLA = int[](52568711,2097155,62914831,62926983,1183489,52490887,52441735,125829121,52441735,53014663,16777487,-1995435761,553652503);\nint[] fontLB = int[](314480,69936,32496,68720,4112,68720,85104,65808,85104,68720,1275632,157424,9952);\nint[] fontLC = int[](2093481984,319815680,2080440320,2080505856,19193856,-53608448,2093907968,2013270016,2093383680,2093350912,-161218560,1986330624,-965263360);\nint[] fontRA = int[](688984382,1145324590,689094687,689082686,572658463,771920190,695374142,421807180,689148222,689017150,-1823980897,758431806,26286407);\nint[] fontRB = int[](2516672,8947904,262368,2909888,322784,812736,272064,4229248,2909888,2385600,8424544,33555136,2549296);\nint[] fontRC = int[](-968884224,-2013265920,-966262784,-968884224,-859308032,-1073741824,-972537856,-427294720,-968884224,-968228864,1811939328,-1073217536,1984430080);\nvec3 fontColA = vec3(0, 0, 0.1294118);\nvec3 fontColB = vec3(0.9058824, 0.509804, 0);\nvec3 fontColC = vec3(0.9058824, 0.7647059, 0);\n\n\n// 3 colors limited\nfloat getBitColor(int numA,int numB,int numC,int bit)\n{\n    return float(numA >> bit & 1)+(float(numB >> bit & 1)*2.0) + (float(numC >> bit & 1) * 3.0);\n}\n\nvoid SpriteFonts(inout vec3 col, int colA, int colB, int colC, vec3 col0, vec3 col1, vec3 col2, vec2 uv, in vec2 p, float w, float h)\n{  \n    p = floor(uv-p);\n\tfloat bounds = float(all(lessThan(p,vec2(w,h))) && all(greaterThanEqual(p,vec2(0,0))));\n\tint bit = int(((w-1.0) - p.x)+w*p.y);\n    float d = getBitColor(colA,colB,colC,bit) * bounds;\n    col = mix(col,d == 1.0?col0:d == 2.0?col1:d == 3.0?col2:col,clamp(d, 0.0, 1.0) );\n}\n\nfloat SpriteNxN(int sprite, vec2 uv, vec2 p, int wmax)\n{\n    p = floor(uv-p);\n\tfloat bounds = float(all(lessThan(p,vec2(wmax,1))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn getBit(sprite,int((float(wmax-1) - p.x)+p.y)) * bounds;\n}\n\nvec3 KenHadouken(int frame, inout vec3 col, vec2 uv, in vec2 p) {\n    int w = 27;\n    float h = 1.0;\n\t\n    int len = 32;\n    int ind = 0;\n    float dc = SpriteNxN(frame == 0 ? hadou0A[ind]:frame == 1 ? hadou1A[ind]:frame == 2 ? hadou2A[ind]:hadou0A[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? hadou0A[i]:frame == 1 ? hadou1A[i]:frame == 2 ? hadou2A[i]:hadou0A[i],uv,p,w);\n    }\n    col = mix(col,idleColA,dc );\n\n    p.y -= 31.0;\n    dc = SpriteNxN(frame == 0 ? hadou0B[ind]:frame == 1 ? hadou1B[ind]:frame == 2 ? hadou2B[ind]:hadou0B[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? hadou0B[i]:frame == 1 ? hadou1B[i]:frame == 2 ? hadou2B[i]:hadou0B[i],uv,p,w);\n    }\n    col = mix(col,idleColB,dc );\n\n    p.y -= 31.0;\n    dc = SpriteNxN(frame == 0 ? hadou0C[ind]:frame == 1 ? hadou1C[ind]:frame == 2 ? hadou2C[ind]:hadou0C[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? hadou0C[i]:frame == 1 ? hadou1C[i]:frame == 2 ? hadou2C[i]:hadou0C[i],uv,p,w);\n    }\n    col = mix(col,idleColC,dc );\n\n    return col;\n}\n\nvec3 Fire(inout vec3 col, vec2 uv, in vec2 p) {\n    int w = 17;\n    float h = 1.0;\n\t\n    float t = mod(iTime*6.0,8.0);\n    int frame = int(mod(iTime*5.0,2.0));\n\t\n    int len = 14;\n    int ind = 0;\n    float dc = SpriteNxN(frame == 0 ? fire0A[ind]:frame == 1 ? fire1A[ind]:fire0A[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? fire0A[i]:frame == 1 ? fire1A[i]:fire0A[i],uv,p,w);\n    }\n    col = mix(col,fireColA,dc );\n\n    p.y -= 13.0;\n    dc = SpriteNxN(frame == 0 ? fire0B[ind]:frame == 1 ? fire1B[ind]:fire0B[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? fire0B[i]:frame == 1 ? fire1B[i]:fire0B[i],uv,p,w);\n    }\n    col = mix(col,fireColB,dc );\n\n    p.y -= 13.0;\n    dc = SpriteNxN(frame == 0 ? fire0C[ind]:frame == 1 ? fire1C[ind]:fire0C[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(frame == 0 ? fire0C[i]:frame == 1 ? fire1C[i]:fire0C[i],uv,p,w);\n    }\n    col = mix(col,fireColC,dc );\n\n    return col;\n}\n\nvec3 Floor(inout vec3 col, vec2 uv, in vec2 p) {\n    int w = 30;\n    float h = 1.0;\n\t\n    int len = 20;\n    int ind = 0;\n    float brightness = 0.5;\n    float dc = SpriteNxN(floorA[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(floorA[i],uv,p,w);\n    }\n    col = mix(col,floorColA*brightness,dc );\n\n    p.y -= 19.0;\n    dc = SpriteNxN(floorB[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(floorB[i],uv,p,w);\n    }\n    col = mix(col,floorColB*brightness,dc );\n\n    p.y -= 19.0;\n    dc = SpriteNxN(floorC[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(floorC[i],uv,p,w);\n    }\n    col = mix(col,floorColC*brightness,dc );\n\n    return col;\n}\n\nvec3 Cloud(inout vec3 col, vec2 uv, in vec2 p) {\n    int w = 30;\n    float h = 1.0;\n\t\n    int len = 20;\n    int ind = 0;\n    float brightness = 0.9;\n    float dc = SpriteNxN(cloudA[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(cloudA[i],uv,p,w);\n    }\n    col = mix(col,cloudColA*brightness,dc );\n\n    p.y -= 19.0;\n    dc = SpriteNxN(cloudB[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(cloudB[i],uv,p,w);\n    }\n    col = mix(col,cloudColB*brightness,dc );\n\n    p.y -= 19.0;\n    dc = SpriteNxN(cloudC[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(cloudC[i],uv,p,w);\n    }\n    col = mix(col,cloudColC*brightness,dc );\n\n    return col;\n}\n\nvec3 Cons(inout vec3 col, vec2 uv, in vec2 p) {\n    int w = 31;\n    float h = 1.0;\n\t\n    int len = 13;\n    int ind = 0;\n    float brightness = 0.3;\n    float dc = SpriteNxN(consA[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(consA[i],uv,p,w);\n    }\n    col = mix(col,consColA*brightness,dc );\n\n    p.y -= 12.0;\n    dc = SpriteNxN(consB[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(consB[i],uv,p,w);\n    }\n    col = mix(col,consColB*brightness,dc );\n\n    p.y -= 12.0;\n    dc = SpriteNxN(consC[ind],uv,p,w);\n    for(int i = 1; i<len; i++){\n        p.y += 1.0; dc += SpriteNxN(consC[i],uv,p,w);\n    }\n    col = mix(col,consColC*brightness,dc );\n\n    return col;\n}\n\nvoid DrawKen(inout vec3 col, vec2 uv, in vec2 p) {\n    float t = mod(iTime*3.0,8.0);\n    int frame = t<2.0?int(t):2;\n    col = KenHadouken(frame,col,uv,vec2(0,0)+p);\n}\n\n// 8x8 streetfighter font\nvoid font(int num, inout vec3 col, vec2 uv, in vec2 p){\n    float w = 4.0, h = 8.0;\n    SpriteFonts(col, fontLA[num], fontLB[num], fontLC[num],fontColA,fontColB,fontColC,uv,p,w, h);\n    SpriteFonts(col, fontRA[num], fontRB[num], fontRC[num],fontColA,fontColB,fontColC,uv,p+vec2(w,0),w, h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1.0);\n\tvec2 uv = ( fragCoord.xy /iResolution.xy ) * vec2(128,64);\n    vec2 uvRef = uv;\n\n    // bg+floor\n    if(uv.y>=18.0){\n        col = vec3(149.0/255.0, 40.0/255.0, 0.0);\n\n        uvRef = ( fragCoord.xy /iResolution.xy ) * vec2(256,128);\n        uvRef.x -= iTime*5.0;\n        uvRef.x = mod(uvRef.x,32.0);\n        uvRef.y = mod(uvRef.y,14.0);\n        col = Cons(col,uvRef,vec2(0,0));\n        uvRef = uv;\n        \n        uvRef.x += iTime*2.0;\n        uvRef.x = mod(uvRef.x,50.0);\n        col = Cloud(col,uvRef,vec2(0,40));\n        uvRef = uv;\n        \n\t\tif(uv.y>=18.0 && uv.y<23.0){\n        \tcol = mix(col,vec3(139.0/255.0, 30.0/255.0, 0.0),0.8 );\n\t\t}\n        \n    } else {\n        uvRef.x = mod(uvRef.x,30.0);\n        uvRef.y = mod(uvRef.y,20.0);\n        col = Floor(col,uvRef,vec2(0,0));\n        uvRef = uv;\n    }\n    \n    DrawKen(col,uv,vec2(5,5));   \n\n    float scene = mod(iTime*3.0,8.0);\n    if(scene>=2.0){\n    \tcol = Fire(col,uv,vec2(30.0+((scene-2.0)/6.0)*118.0,20));\n    }\n\n\tfont(int(mod(iTime,10.0)),col,uv,vec2(56,51));\n    font(int(mod(iTime*10.0,10.0)),col,uv,vec2(64,51));\n    \n    uv = ( fragCoord.xy /iResolution.xy ) * vec2(256,128);\n    font(10,col,uv,vec2(10,110));\n    font(11,col,uv,vec2(18,110));\n    font(12,col,uv,vec2(26,110));\n    \n    // results\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5465, 5485, 5540, 5540, 5639], [5641, 5641, 5776, 5776, 6071], [6073, 6073, 6129, 6129, 6308], [6310, 6310, 6375, 6375, 7462], [7464, 7464, 7511, 7511, 8507], [8509, 8509, 8557, 8557, 9252], [9254, 9254, 9302, 9302, 9997], [9999, 9999, 10046, 10046, 10732], [10734, 10734, 10784, 10784, 10901], [10903, 10929, 10984, 10984, 11220], [11222, 11222, 11279, 11279, 12608]]}
{"id": "wsjGRw", "name": "Anime background", "author": "mmerchante", "description": "A mix of anime speed lines and an electric shock. Had to change the source song!", "tags": ["2d", "lines", "animated", "speed", "anime", "hero", "graphic", "speedlines"], "likes": 26, "viewed": 690, "published": "Public", "date": "1548480823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quick and dirty line experiment to generate electric bolts :)\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nfloat R1seq(int n)\n{\n\treturn fract(float(n) * 0.618033988749894848204586834365641218413556121186522017520);\n}\n\nvec2 R2seq(int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\n// modified iq's segment: https://www.shadertoy.com/view/ldj3Wh\nvec2 Line(vec2 a, vec2 b, vec2 p, vec2 identity, float sa, float sb)\n{\n    vec2 pa = p - a;\n    vec2 pb = p - b;\n\tvec2 ba = b - a;\n\tfloat t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);    \n    vec2 pp = a + ba * t;\n    vec2 y = vec2(-identity.y, identity.x);\n    float cutoff = max(dot(pb, identity), dot(pa, -identity));\n    float s = mix(sa, sb, t);\n    return vec2(max(cutoff - .005, abs(dot(y, p - pp)) - s), t);\n}\n\nfloat Rythm(float x)\n{\n    x = x * 6.28318 * 10.0 / 60.0;\n\tx = smoothstep(-1.0, 1.0, sin(x));\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\tx = smoothstep(0.0, 1.0, x);\n\treturn x;\n}\n\nvec3 Background(vec2 uv, vec2 baseDir, float time)\n{\n    uv = uv * vec2(.75, .75) + vec2(-.0, .0);\n\tvec3 result = vec3(0.91, 0.56, 0.02);\n    \n    vec2 n = vec2(-baseDir.y, baseDir.x);\n    \n    result = mix(result, vec3(1.0) - result, Rythm(time));\n    \n    float lines = texture(iChannel0, vec2(uv.x - uv.y) + vec2(time * 1.35, 0.0)).r;\n    result += lines * lines * .75 + lines * lines * lines * .35;    \n    result *= smoothstep(.5, .0, abs(dot(uv, n)));\n    \n    return result * 1.25;\n}\n\nvec3 Magic(float leadTime, vec3 baseColor, vec2 uv, vec2 baseDir, float time, float spread, float freq, float intensity)\n{\n    int frame = iFrame / 12;\n    \n    float speed = -1.5 - ((Rythm(time)) * .5 + .5) * 2.0;\n    //speed *= .2;\n    vec2 dir = normalize(baseDir);\n    \n    \n    uv -= dir * mix(.1, .3, Rythm(time));\n    \n    vec2 normal = vec2(-dir.y, dir.x);\n    \n    vec2 baseOffset = dir * speed * floor(float(iFrame) / 24.0);\n    \n    vec2 p = uv;\n    p += dir * speed * (float(iFrame) / 24.0);\n    p -= R2seq(int(floor(float(iFrame)/3.0))) * .05;\n    p += normal * sin(time * 12.0) * .05;\n            \n    float ray = 0.0;\n\tfloat glow = 0.0;\n    \n    p += (texture(iChannel1, p * .015 + leadTime * .25).xy * 2.0 - 1.0) * .1;\n    \n    float leadIntro = mix(.3, .015, smoothstep(10.0, 14.0, time));\n    \n    float leadingTime = 1.0 - smoothstep(leadTime - .5, leadTime, time);\n    float distanceToLead = dot(uv - .5, dir) - leadingTime * 2.0 - leadIntro;\n    float leadingMask = smoothstep(-.85, -.0, distanceToLead);\n    \n    p += leadingMask * (texture(iChannel1, vec2(time * .01 + leadTime * .35)).xy * 2.0 - 1.0) * .35;\n    \n    float sizeIntro = smoothstep(13.85, 14.15, time);\n    spread *= leadingMask * (1.0 - Rythm(time) * .75) * sizeIntro;\n    \n    for(int i = -12; i < 10; i++)\n    {\n\t\tfloat offsetA = R1seq(i+frame) * 2.0 - 1.0;\n        float offsetB = R1seq(i+frame+1) * 2.0 - 1.0;\n        \n        vec2 a = baseOffset + dir * float(i) * freq + normal * offsetA * spread;\n        vec2 b = baseOffset + dir * float(i+1) * freq + normal * offsetB * spread;\n        \n        float sa = mix(.05, 3.0 * intensity, R1seq(frame*7+i-1)) * .005;\n        float sb = mix(.05, 3.0 * intensity, R1seq(frame*7+i)) * .005;\n        \n        vec2 l = Line(a, b, p, dir, sa, sb);\n        float d = .025 * leadingMask;\n\t\t\n        ray += smoothstep(d, d * .75 - .0001, l.x);\n        glow += .5 * leadingMask * smoothstep(d * 20.0, d, l.x);\n    }\n\n    ray = clamp(ray, 0.0, 1.0);\n    return baseColor * (1.0 + glow * (Rythm(time * 16.0) * .05 + .025)) + vec3(ray) * intensity * leadingMask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = -.25 + floor(iTime * 1.1 * 24.0) / 24.0;\n    float intro = smoothstep(12.85, 13.15, time);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y -= .075;\n    uv.x -= sin(time*4.0) * .2;\n    \n    vec2 baseDir = normalize(vec2(.57, .45));\n    \n    vec3 col = Background(uv, baseDir, time) * intro;\n    \n    float spread = .35 + (sin(time * 10.0) * .5 + .5);\n    float freq = .6 - (sin(time * 4.0) * .5 + .5) * .2;\n    \n    \n    float offset = 1.0 - (smoothstep(5.0, 7.0, time) * smoothstep( 14.0, 13.0, time));\n    \n    spread *= offset;\n    \n   \tcol = Magic(.5, col, uv + vec2(.4, .1) * offset, baseDir, time, .2, .35, 1.0 - intro * .5);\n    col = Magic(3.0, col, uv + vec2(.2, .0) * offset, baseDir, time, .05, .15, .55 + intro * .3);\n\tcol = Magic(8.0, col, uv + vec2(.2, -.25) * offset, baseDir, time, .05, .15, .35 + intro * .3);\n    col = Magic(10.0, col, uv + vec2(-.15, -.35) * offset, baseDir, time, .04, .05, .75 + intro * .3);\n    col = Magic(11.0, col, uv + vec2(-.3, -.15) * offset, baseDir, time, .04, .05, .75 + intro * .3);\n    col = Magic(12.0, col, uv, baseDir, time, spread * .75, freq, 1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 152, 172, 172, 261], [263, 263, 282, 282, 437], [439, 503, 573, 573, 918], [920, 920, 942, 942, 1146], [1148, 1148, 1200, 1200, 1638], [1640, 1640, 1762, 1762, 3732], [3734, 3734, 3791, 3791, 4951]]}
{"id": "WsjGRz", "name": "fbm and domain wraping", "author": "Eseris", "description": "This is a practice of fractal brownian motion and domain wraping.\nThe fbm is applied on a basic 2D noise and domain wraping corresponds to 3 pass on the fbm.", "tags": ["noise", "fbm", "palette", "domainwraping"], "likes": 2, "viewed": 355, "published": "Public API", "date": "1547995546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define DEBUG_PALETTE\n\nfloat hash21(vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 uv) {\n\tvec2 f = fract(uv);\n\tvec2 i = floor(uv);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash21(i), hash21(i + vec2(1,0)), f.x),\n\t\tmix(hash21(i + vec2(0,1)), hash21(i + vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 uv) {\n\tfloat freq = 2.;\n\tfloat amp = .5;\n\tfloat gain = .54;\n\tfloat v = 0.;\n\tfor(int i = 0; i < 6; ++i) {\n\t\tv += amp * noise(uv);\n\t\tamp *= gain;\n\t\tuv *= freq;\n\t}\n\treturn v;\n}\n\nfloat fbmPattern(vec2 p, out vec2 q, out vec2 r) {\n\tfloat qCoef = 2.;\n\tfloat rCoef = 3.;\n\tq.x = fbm(p             + .0  * iTime);\n\tq.y = fbm(p             - .02 * iTime + vec2(10., 7.36));\n\tr.x = fbm(p + qCoef * q + .1  * iTime + vec2(5., 3.));\n\tr.y = fbm(p + qCoef * q - .07 * iTime + vec2(10., 7.36));\n\treturn fbm(p + rCoef * r + .1 * iTime);\n}\n\nvec3 basePalette(float t) {\n\treturn .5 + .6 * cos(6.283185 * (-t + vec3(.0, .1, .2) - .2));\n}\n\nvec3 smokePalette(float t) {\n\treturn vec3(.6, .5, .5) \n\t\t+ .5 * cos(6.283185 * (-vec3(1., 1., .5) * t + vec3(.2, .15, -.1) - .2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.yy;\n\n\tfloat scale = 5.;\n\tvec3 col = vec3(.1);\n\tfloat n;\n\n\tvec2 q;\n\tvec2 r;\n\tn = fbmPattern(scale * uv, q, r);\n\tvec3 baseCol = basePalette(r.x);\n\tvec3 smokeCol = smokePalette(n);\n\n\tcol = mix(baseCol, smokeCol, pow(q.y, 1.3));\n\n#ifdef DEBUG_PALETTE\n    float x = fragCoord.x / iResolution.x;\n\tcol = mix(col, basePalette(x), step(abs(uv.y - .03), .02));\n\tcol = mix(col, smokePalette(x), step(abs(uv.y - .08), .02));\n#endif\n\n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 48, 48, 120], [122, 122, 144, 144, 339], [341, 341, 361, 361, 529], [531, 531, 581, 581, 877], [879, 879, 906, 906, 972], [974, 974, 1002, 1002, 1106], [1108, 1108, 1163, 1163, 1646]]}
{"id": "wsl3RS", "name": "Spiral Flash Offset", "author": "Del", "description": "spiral", "tags": ["spiral", "flash", "offset"], "likes": 12, "viewed": 351, "published": "Public API", "date": "1546749901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n\nfloat TimerInOut(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\n\nvec2 spiral(vec2 uv,float zoom, float len, float offset)\n{\n    float d = length(uv) * zoom;\n    \n    float trip = TimerInOut(vec4(mod(iTime,60.0),15.0,45.0,1.0));\n    float m = 0.4+sin(iTime+uv.y+uv.x)*0.5;\n    d*=(1.0-(m*trip));\n    \n    d=log(d);\n    uv = rot(uv,sin(d*offset)+d*5.0);\n\tfloat v = 1.0-sdUnevenCapsule(uv,vec2(0.0,0.0),vec2(0.4*len,0.0),0.0,0.4*len)*14.0;\n    float l = d;   \n    return vec2(v,l);\t// distx , disty\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float t = fract(iTime*0.4)*6.0;\n    \n    float offset = 25.0 * TimerInOut( vec4(mod(iTime,9.6),1.0, 7.2, 0.8));\n    \n\tvec2 dist = spiral(uv,1.0,t,offset);\n    float v = dist.x;\n    float l = dist.y;\n    \n\tv = smoothstep(0.5-0.1,0.5+0.1,v);\n    //vec3 col = vec3(v*1.0-l/t);\n    \n    vec3 col = mix(vec3(0.0,0.0,0.2),vec3(1.0,0.6,0.5),v*1.0-l/t);\n    \n \tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsl3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 117], [120, 120, 154, 154, 182], [184, 184, 270, 270, 757], [760, 760, 786, 786, 858], [860, 860, 918, 918, 1292], [1295, 1295, 1352, 1352, 1922]]}
{"id": "Wsl3zN", "name": "multiple source of light", "author": "caudya", "description": "sgg", "tags": ["multiple"], "likes": 0, "viewed": 128, "published": "Public", "date": "1547317033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient, indice de réfraction\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 90.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\n//vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nvec3 spherePos = cameraTarget + 2.0 * vec3(0.0, 0.0, 1.0) + vec3(0, 1, 0);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t// white\nconst vec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.1/*Ka*/, 1.0/*Kd*/, 0.3/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec4 \t   ambiantColor = vec4(0.0, 0.0, 1.0, 1.0);\t\t// blue\n\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nconst vec3     lightPos     = vec3(8, 10, -12);\nconst float\t   lightPow     = 0.8;\n\nconst vec3\t   light2Col    = vec3(1,1,0.5);\nconst vec3     light2Pos    = vec3(3,10,1);\nconst float    light2Pow    = 0.5;\n\n\nconst int NB_LIGHTS = 2;\n\nconst float eps = 0.01;\n\n//Light struct\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n\nLightInfo lights[NB_LIGHTS];\n    \n//########################################################################################\n//value for grid\n//boo est vraie alors on prend PIXEL_SAMPLING_GRID_SIZE sinon on choisit PIXEL_SAMPLING_RANDOM \nbool boo = true;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_RANDOM = 20;\n\n\n\nstruct ShadeInfo\n{\n    vec3 shadedcol;\n    float Ks;\n};\n\nconst int MAX_NB_BOUNCES = 3;\n\n\n    \n//##############################################################################################\n    \n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n \n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n\n        // As we found the value of t, we can insert it into equation (1) to find\n        // the position of the first intersection point encountered along the ray.\n        intersecPt = rayPos + t * rayDir;\n\n        // Then, we can use the property of a sphere that the infinite line along the\n        // normal vector to a point on the sphere is passing through the center of the\n        // sphere.\n        // Then, we need to reverse the vector direction if the intersection point is\n        // seen from inside the sphere.\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n    // As we found the value of t, we can insert it into equation (1) to find\n    // the position of the first intersection point encountered along the ray.\n    intersecPt = rayPos + t * rayDir;\n    \n    // NOTE: The normal to be returned has to be pointing 'towards' the rayPos position.\n    //       So, the angle between the ray direction and the normal must > 90°, so the\n    //       dot-product should be negative.\n    //       This can be expressed by taking the 'sign' of den\n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    // Compute camera three main axis (X,Y,Z) expressed in world space\n    //\n    //  NOTES: - First, we compute the Z camera unit vector that goes from the camera position\n    //           and look toward the camera target.\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    //         - Finally, we can find the true cy by applying: cy = cross-product(cz, cx)\n\n    vec3 cy = normalize(cross( cz, cx));\n\n\n    // by the same value: iResolution.y\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n\n    //origine du rayon, la caméra\n    rayPos = cameraPos;\n    \n    //direction du rayon\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// trouve l'intersection la plus proche qu'à le rayon avec les objets\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, in int incId,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    // As the plane is textured with a checkboard pattern, we need to define\n    // a 'texture coordinate frame'.\n\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowAtPoint(in vec3 I, in vec3 normalI, in Material objectMat, in vec3 L, in float Ldist, LightInfo li)\n{\n    int object;\n    vec3 vec1, vec;\n    float dist = computeNearestIntersection(I, L, -1, object, vec1, vec);\n    if (dist<Ldist && dist>0.0) {\n        return 0.5;\n    } else {\n        return 1.0;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(in vec3 objectCol, in Material objectMat, in vec3 N, in vec3 L, in vec3 R, in vec3 V, in float shadowFactor, in LightInfo li)\n{    \n    vec3 ambiant  = objectMat.Ka * ambiantColor.rgb /  float(NB_LIGHTS);\n    vec3 diffuse  = objectMat.Kd *  objectCol * li.col * li.power *  max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *  li.col * li.power * ((dot(N, L) > 0.0) ? 1.0 : 0.0) * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + shadowFactor*diffuse + shadowFactor*specular;\n    \n    //vec3 phongCol = shadowFactor*diffuse + shadowFactor*specular;\n\n    return phongCol;\n}\n\n//##############################################################################################\n\nvec4 RaycastAtPixelCoord(vec2 pixCoord) \n{\n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir); \n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    \n    int nbBounces = 0;\n    \n    // Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    \n    vec3 RayRefr;\n    vec3 spec;\n    \n    vec3 ambiant;\n        \n    do\n    {\t\n        \n    \tfloat distI = computeNearestIntersection(rayPos, rayDir, -1, objectId, intersecI, normalI);\n    \n    \t// Apply the shading to the points that are on the sphere surface and seen by the camera\n    \tif (distI <= 0.0)\n    \t{\n            \n            infos[nbBounces].shadedcol = skyCol;\n        \tinfos[nbBounces].Ks = 0.0;\n            nbBounces++;\n        \tbreak;\n            \n        }\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        \n        infos[nbBounces].shadedcol = vec3(0);\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n        //ambiant = computeAmbiant(objectMat);\n       \n        \n        infos[nbBounces].Ks = objectMat.Ks;\n        \n        // unit-vector going from the surface point toward the camera \n       \tvec3 V = -rayDir;\n        \n        vec3 I = intersecI + normalI*eps;\n        \n        for (int l=0; l< NB_LIGHTS; l++)\n        {\n            \n        \n        \t// unit-vector going from the surface point toward the light\n\t    \tvec3 L = normalize(lights[l].pos - intersecI);\n        \n        \t// unit-vector of the reflection direction of the light at the surface point\n    \t\tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n\n        \n        \tfloat Ldist = distance(lights[l].pos,intersecI);\n            \n        \n        \tfloat shadowfactor = getShadowAtPoint(I, normalI, objectMat, L, Ldist, lights[l]);\n        \n        \t// Apply the Phong shading to compute the color\n        \t// of the surface point as seen from the camera\n               \n            infos[nbBounces].shadedcol += computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor, lights[l]);;\n        \t\n        }\n        \n        RayRefr = 2.0 * normalI * dot(normalI, V) - V;\n        \n\t\trayDir = RayRefr;\n        \n        rayPos = I;\n        \n        \n        //bounce from the surface towards the reflect direction of the ray\n        \n        \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for (int i=0; i<=nbBounces; i++)\n    {\n        resCol = infos[nbBounces-i].Ks*resCol + infos[nbBounces-i].shadedcol;\n    }\n    \n    //resCol = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V, shadowfactor), 1);\n    \n    return vec4(resCol, 1);\n \n    //return vec4(computePhongShading(resCol, objectMat, normalI, L, R, V, shadowfactor), 1);; \n}\n\n\n//##############################################################################################\n\nvec2 noise2(vec2 location, vec2 delta) \n{\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        \n\t);\n}\n\nvoid animateScene(in float time) {\n    //animate the sphere position\n\tconst float pi = 3.1415926535;\n\tconst float rs = 2.0;\n\tconst float spr = 5.0;\n\tfloat as = 2.0*pi * time /spr;\n\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0, 1, 0);\n    \n    lights[0].pos += vec3(0.0, 10.5 + 9.5 * cos(time) - 10.0, 0.0);\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist * vec3(sin(time), max(sin(time*0.5), 0.0), cos(time));\n    \n}\n\n//##############################################################################################\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    lights[0].pos = lightPos;\n    lights[0].col = lightCol;\n    lights[0].power = lightPow;\n    \n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n    \n    vec4 moy = vec4(0);\n     \n    animateScene(0.0);\n \n    \n    if (boo == true) {\n    for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n    {\n        \n        for (int j=0; j<PIXEL_SAMPLING_GRID_SIZE; j++)\n        {    \n            moy += RaycastAtPixelCoord(fragCoord+vec2(float(i)/float(PIXEL_SAMPLING_GRID_SIZE), float(j)/float(PIXEL_SAMPLING_GRID_SIZE))); \n    \t\t\n        }\n    }\n        \n    } else {\n        for (int i=0; i<PIXEL_SAMPLING_RANDOM ; i++)\n            moy += RaycastAtPixelCoord(fragCoord+noise2(vec2(i),vec2(10000))); \n    }\n    \n    if (boo == true) {\n        fragColor = moy/float(PIXEL_SAMPLING_GRID_SIZE*PIXEL_SAMPLING_GRID_SIZE);\n    } else {\n    \tfragColor = moy/float(PIXEL_SAMPLING_RANDOM);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsl3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2393, 2496, 2641, 2641, 3909], [4009, 4053, 4193, 4193, 5072], [5074, 5172, 5257, 5257, 6121], [6221, 6292, 6455, 6532, 7470], [7472, 7570, 7607, 7607, 7631], [7731, 7775, 7811, 7925, 8567], [8569, 8667, 8742, 8742, 9004], [9006, 9104, 9220, 9220, 9425], [9427, 9525, 9677, 9677, 10148], [10150, 10248, 10290, 10362, 13221], [13224, 13322, 13363, 13363, 13585], [13587, 13587, 13621, 13655, 14115], [14117, 14220, 14277, 14277, 15206]]}
{"id": "WslGWf", "name": "Laserbeam", "author": "KaiBowers", "description": "3 \"stacked \"circles\" : R, G & B", "tags": ["circles", "lazer"], "likes": 6, "viewed": 141, "published": "Public", "date": "1547669039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 uv = fragCoord/iResolution.xy;   \n    float px = (abs(uv.x - 0.5f));\n    float py = (abs(uv.y - 0.5f)) * (iResolution.y / iResolution.x);\n    \n    float k = pow(px, 2.f) + pow(py, 2.f);\n        \n    k = sqrt(k);\n    \n    float p = iTime * 5.f;\n    \n    vec3 col = vec3(\n    sin(k * 0100.f - p),\n    sin(k * 0030.f - p),\n    sin(k * 0700.f - p));\n    \n    fragColor = vec4(col,1.0);\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 469]]}
{"id": "wsS3Dh", "name": "SlickTunnel", "author": "felipunkerito", "description": "I've coded this on my phone, so why not port it to Shadertoy.", "tags": ["3d", "ray", "sdf", "marching"], "likes": 6, "viewed": 320, "published": "Public API", "date": "1548728598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS  512\n#define FAR    10.\n#define EPS   1e-3\n// Uncomment for a hexagon, rather than a box.\n//#define HEX\n\nmat2 rot( float a )\n{\n\n\treturn mat2( cos( a ), -sin( a ),\n\t\t         sin( a ),  cos( a )\n\t\t        );\n\n}\n\nvec3 twiZ( vec3 p, float f )\n{\n\n    float a = p.z * 1.2 * f;\n\n    p.yx = cos( a ) * p.yx + sin( a ) * vec2( -p.x, p.y );\n\n    return p;\n\n}\n\nfloat vmax(vec2 v)\n{\n\n\treturn max(v.x, v.y);\n\n}\n\nfloat fBox2Cheap(vec2 p, vec2 b)\n{\n\n \treturn vmax(abs(p)-b);\n\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n\n\tconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2( length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x), p.z-h.y );\n\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\n}\n\nfloat path( float z )\n{\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\treturn ( 1.5 * sin( z ) * 1.2 * cos( z ) );\n\n}\n\nvec2 map( vec3 p )\n{\n\n    vec2 spe = vec2( length( p -\n                            vec3( 0.3 * -path( p.z ),\n                                 0,\n                                 1.5 + iTime\n                                )\n                           ) - 0.2, 0.0 );\n\n    vec3 tem = p;\n\n    p.x += path( p.z );\n    tem.x += path( p.z );\n    tem = twiZ( p, 1.0 );\n\n    float hex = sdHexPrism( tem, vec2( 1, iTime + 8.7 ) );\n\n    float box = fBox2Cheap( p.xy, vec2( 3 ) );\n    float boxO = fBox2Cheap( tem.xy, vec2( 1 ) );\n\n\n    #ifdef HEX\n    vec2 tun = vec2 ( max( -hex, box ), 1.0 );\n    \n    #else\n    vec2 tun = vec2 ( max( -boxO, box ), 1.0 );\n    \n    #endif\n\n    if( spe.x < tun.x ) tun = spe;\n\n    return tun;\n\n}\n\nvec3 norm( vec3 p )\n{\n\n\tvec2 e = vec2( 1e-3, 0 );\n\n\treturn normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n\t\t                      map( p + e.yxy ).x - map( p - e.yxy ).x,\n\t\t                      map( p + e.yyx ).x - map( p - e.yyx ).x\n\t\t                    )\n\t\t              );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n\tfloat t = 0.0;\n\n\tfor( int i = 0; i < STEPS; ++i )\n\t{\n\n\t\tvec3 p = ro + rd * t, pO = vec3( 0 ), \n        roO = vec3( 0 ), rdO = vec3( 0 );\n        float tO = 0.0;\n\n        vec3 n = norm( p );\n        \n\t\td = 0.5 * map( p ).x;\n\n\t\tif( d < EPS || t > FAR ) break;\n\n\t\tt += d;\n\n\t}\n\n\treturn t;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd )\n{\n\n\tfloat d = 0.0, t = ray( ro, rd, d );\n\n\tvec3 p = ro + rd * t;\n\tvec3 n = norm( p );\n\tvec3 lig = normalize( vec3( 0, 0, -iTime - 1.1 ) );\n    lig.x -= 0.3 * path( lig.z );\n    lig = normalize( lig );\n    vec3 ref = reflect( rd, n );\n\n\tfloat amb = 0.5 + 0.5 * n.y;\n    float nam = 0.5 + 0.5 * -n.y;\n\tfloat dif = max( 0.0, dot( lig, n ) );\n\tfloat spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n\n\tvec3 col = vec3( 0 );\n    col += 0.1 * nam;\n\tcol += 0.1 * amb;\n\tcol += 0.2 * dif;\n\tcol += 1.0 * spe;\n    \n    if( map( p ).y == 0.0 )\n    col.r += 0.2;\n    \n    col += 1.0 * 0.025 * t * t;\n    \n    col *= sqrt( col );\n\n\treturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.y;\n\n    vec3 ro = vec3( 0, 0, 0.9 + iTime );\n    ro = twiZ( ro, 1.0 );\n    ro.x -= 0.3 * path( ro.z );\n\n    vec3 rd = normalize( vec3( uv, 1 ) );\n    rd = twiZ( rd, 1.0 );\n    rd.x -= 0.3 * path( ro.y);\n\n    float d = 0.0, t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n\n    vec3 col = d < EPS ? sha( ro, rd ) : vec3( 1 );\n        \n    //if( map( p ).y == 0.0 )\n    for( int j = 0; j < 5; ++j )\n    {\n\n        p += ro * 1e-5;\n        ro = p + rd;\n        rd = ( reflect( rd, n ) );\n        \n        if( d < EPS ) col += 0.25 * sha( ro, rd );\n        \n    \n    }\n\n\n    fragColor = vec4( col, 1 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3Dh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 119, 140, 140, 223], [225, 225, 255, 255, 363], [365, 365, 385, 385, 412], [414, 414, 448, 448, 477], [479, 479, 515, 515, 784], [786, 786, 809, 809, 900], [902, 902, 922, 922, 1621], [1623, 1623, 1644, 1644, 1914], [1916, 1916, 1960, 1960, 2250], [2252, 2252, 2282, 2282, 2918], [2920, 2920, 2977, 2977, 3711]]}
{"id": "Wss3DS", "name": "shake your booty", "author": "bpaf", "description": "= shaken", "tags": ["booty"], "likes": 2, "viewed": 56, "published": "Public", "date": "1547392926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589;\nfloat mmod(float a, float b) { return a - floor(a/b); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c1 = vec2(0.5,0.5);\n    float n = 0.0 + 1.0*sin(2.0*pi*mmod(iTime,1.0));\n    float a = 3.0*mod(length(uv.x-0.5),0.3);\n    float b = 3.0*mod(length(uv.y-0.5),0.3);\n    vec3 col = vec3(0,1,0) * ( cos(pi * 15.0 * a + cos(2.0 * pi * n*n)) * sin(pi * 15.0 * b + sin(2.0 * pi * n*n)) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wss3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 88], [89, 89, 146, 146, 507]]}
{"id": "wss3RS", "name": "voroni goop", "author": "caseymacneil", "description": "A simple modification to make a rounded voroni. Idk if this would be classified as meta balls, since none of the balls are actually melding together, so its voroni goop! I used https://thebookofshaders.com/12/ as a reference for this shader", "tags": ["2d", "noise", "random", "voroni"], "likes": 5, "viewed": 118, "published": "Public", "date": "1546757092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// play with this value!\n#define ROUNDNESS 2.\n\nfloat rand(vec2 value)\n{\n\treturn fract(sin(dot(value, vec2(23.1245,87.2980))) * 5387.58135649);\n}\n\nvec2 rand2d(vec2 value)\n{\n\treturn fract(sin(vec2(dot(value, vec2(23.1245,87.2980)), dot(value, vec2(127.5123,39.183)))) * 5387.58135649);\n}\n\nvec3 voroni(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec3 col = (fuv).xyy;\n    float mdist = 1.;\n    // used to render center point\n    float cmdist = 1.;\n    vec2 p;\n    vec2 sp;\n    // get neighbour tiles\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 n = vec2(float(x),float(y));\n            \n            p = rand2d(iuv + n);\n            \n            // animate\n            p.y = 0.5 + 0.5*sin(iTime + 5.*p.y);\n            p.x = 0.5 + 0.5*cos(iTime + 5.*p.x);\n            \n            vec2 diff = n + p - fuv;\n            float dist = length(diff);\n            \n            // \n            mdist = pow(mdist, ROUNDNESS);\n            \n            if(dist < mdist)\n            {\n            \tmdist = min(mdist,dist);\n                cmdist = min(cmdist,dist);\n                sp = p;\n            }\n        }\n    }\n    return vec3(length(sp)) + (1.-step(0.02,cmdist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 vFontSize = vec2(8.0, 15.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //scale\n    vec2 p = fragCoord * .01;\n    p += 1.0;\n    \n    vec3 col = voroni(p);\n    \n    // make pretty :)\n    col.r *= uv.x;\n    col.g *= .8 * 1.-uv.x;\n    col = pow(col,vec3(2.2));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wss3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 71, 71, 144], [146, 146, 171, 171, 285], [287, 287, 309, 309, 1239], [1241, 1241, 1298, 1298, 1624]]}
{"id": "WsS3W1", "name": "MCG: fractals", "author": "tale3d", "description": "In this lecture we discuss fractals. ", "tags": ["mandelbrot", "fractals", "teachingmaterial"], "likes": 0, "viewed": 46, "published": "Public", "date": "1548698654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//Here goes the main function, which is applied for every pixel in our window\n//It takes the pixel coordinates as an argument\n//And returns the colour of the given pixel.\n//Below we see how we can define our shape by using mathemaica sn code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n    \n    //We are going to map pixel coordinates from [-1,1] to \n    //[central point - size, central point + size]\n    //\n    //The size is time-dependent, so graphically we xoom around centre point.\n    //\n    //The central point is pre-defined in the code to be at the \"edge\" of the set.\n    //You can also try some other ones, like \n    //(-0.745, 0.113)\n    //(0.013, 0.655)\n    //(-0.745, 0.186)\n    //(-1.41, 0.0)\n    \n    float centre_x = -1.41;\n    float centre_y = 0.0;\n\n    //Below we define the size of our area\n    //Some explanations: cos(iTime) creates time-dependent oscillations between -1 and 1\n    //1.0-cos maps that wave to [0,2]\n    //pow(0.003, 1.0-cos) create wave between 0.00009 (which is 0.003^2) and 1.0 (0.003^0)\n    //So eventually by using continuous time variable we oscillate between 1 and 0.00009\n    //\n    //You can try to have something smaller than 0.003, but eventually you hit the floating point limit\n    float zooming_ratio = pow(.003,1.-cos(0.2*iTime));\n    \n    //Finally we map from [-1,1] to [centre_x-zoom, centre_x+zoom]\n    //Position px and py are from the given pixel\n    float cx = centre_x + c.x*zooming_ratio;\n    float cy = centre_y + c.y*zooming_ratio;\n    \n    //z_0 = c\n    //I could use vec2 to pack complex number, but we have not discussed vectors yet.\n    //Instead real part and imaginary part have their own variables\n    float z_re = cx;\n    float z_im = cy;\n    \n\tfloat n = 0.; //iteration number\n \n    vec3 colour = vec3(0.0, 0.0, 0.0); //default colour in this shader is black \n\n    //we have 256 iterations maximum\n    for(int i = 0; i < 256; i++)\n    {\n        //z_n+1 = z_n^2 + c\n        //recall that (a+bi)(c+di) = (ac-bd)+(ad+bc)i\n        //therefore z*z = (z_re*z_re - z_im*z_im) + (z_re*z_im + z_re*z_im)i\n\n        //z*z\n        float zn_re = z_re*z_re - z_im*z_im;\n        float zn_im = 2.0*z_re*z_im;\n\n        //z*z+c\n        zn_re += cx;\n        zn_im += cy;\n        \n        n++;\n        \n        //if the modulus of the point greater than 2, the point is not in Mandelbrot set anymore, stop\n        if(sqrt(zn_re*zn_re+zn_im*zn_im)>2.0)\n        {\n            //assign colour to the pixel given the iteration number\n            //f denotes how many \"palettes\" we have\n            float pn = 10.;\n            //use trigonometry to have rather nice set of \n        \tcolour = vec3(sin(n/pn),cos(n/pn),1.0-sin(n/pn));\n            break;\n        }\n        z_re = zn_re;\n        z_im = zn_im;\n    }\n    \n\tfragColor = vec4(colour,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsS3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 245, 302, 649, 3496]]}
{"id": "wsS3Wz", "name": "many boxes", "author": "abje", "description": "a fork of iq's [url=https://www.shadertoy.com/view/4tKBWy]Boxes traced[/url] without a stack.", "tags": ["3d", "bvh"], "likes": 4, "viewed": 368, "published": "Public API", "date": "1548597945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fork of iq's Boxes traced\n//https://www.shadertoy.com/view/4tKBWy\n\n#define LEVELS 14\n#define STEPS 3000\n#define FAR 100.0\n\n#define ZERO min(0,iFrame)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvec2  hash2( float n ) { return fract(sin(vec2(n,n+3.0))*vec2(43758.5453123,22578.1459123)); }\nfloat hash2( vec2 x )  { return fract(sin(dot(x,vec2(12.353,31.71))*43758.5453123)); }\n\n//https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid random(out vec3 dcen, out vec3 drad, in int id, in int level) {\n    dcen = hash(uvec3(id,level,uint(iMouse.x))).xyz;\n    drad = hash(uvec3(id,level,uint(iMouse.y))).xyz;\n    drad = drad*0.4+0.5;\n}\n\nvoid generate(inout vec3 cen, inout vec3 rad, in int id, in int level) {\n    vec3 dcen;\n    vec3 drad;\n\n    random(dcen,drad, id, level);\n\n    vec3 dp = dcen*2.0-1.0;\n\n    vec3 ncen = cen;\n    vec3 nrad = rad;\n    nrad = nrad*drad;\n    ncen += dp*(rad-nrad);\n\n    rad = nrad;\n    cen = ncen;\n}\n\nvoid backgenerate(inout vec3 cen, inout vec3 rad, in int id, in int level) {\n    vec3 dcen;\n    vec3 drad;\n\n    random(dcen,drad, id, level);\n\n    vec3 dp = dcen*2.0-1.0;\n\n    vec3 pcen = cen;\n    vec3 prad = rad;\n    prad = rad/drad;\n    pcen -= dp*(prad-rad);\n\n    rad = prad;\n    cen = pcen;\n}\n\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in vec3 cen, in vec3 rad, out vec3 nor) \n{\n    vec3 n = ird*(cen-ro);\n    vec3 k = abs(ird)*rad;\n\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n    float tN = max(max( t1.x, t1.y ),t1.z);\n    float tF = min(min( t2.x, t2.y ),t2.z);\n\n    if( tN > tF || tF < 0.0) return vec2(-1.0);\n\n    nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nbool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in vec3 cen, in vec3 rad ) \n{\n    vec3 n = ird*(cen-ro);\n    vec3 k = abs(ird)*rad;\n\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    return tN<tF && tF>0.0;\n}\n\nvec3 ibox = vec3(2,1,2);\n\nvec3 cityIntersect( in vec3 ro, in vec3 rd, in vec3 ird, inout float tmax, out int id2, out int i)\n{\n    vec3 res = vec3(-1.0);\n    vec3 cen = vec3(0);\n    vec3 rad = ibox;\n    int level = 0;\n    int id = 0;\n\n    bool subdivide = true;\n\n    for( i=ZERO; i<STEPS; i++ )\n    {\n        if (subdivide) {\n            vec3 nor;\n            vec2 tmp = boxIntersect( ro, rd, ird, cen, rad, nor);\n\n            // intersect node\n            if( tmp.y>0.0 && tmp.x < tmax)\n            {\n                // if leaf\n                if(level == LEVELS)\n                {\n                    tmax = tmp.x;\n                    res = nor;\n                    id2 = id;\n\n                    subdivide = false;\n                }\n                // else, test a child node of even id number\n                else\n                {\n\n                    level++;\n                    //even id number\n                    id *= 2;\n                    generate(cen,rad,id,level);\n                }\n            }\n            // pop next node from the stack\n            else\n            {\n                subdivide = false;\n            }\n        } else {\n            if (level == 0) {\n                break;\n            }\n            //going up nodes until there is an untested node,\n            //if the id number is even id+1 is not tested,\n            //if level is 0 every node is tested, and the ray hasn't hit anything\n            if (id/2*2 != id) {\n\n                backgenerate(cen,rad,id,level);\n\n                id/=2;\n                level--;\n            } else {\n                backgenerate(cen,rad,id,level);\n                //uneven id number\n                id++;\n                generate(cen,rad,id,level);\n                subdivide = true;\n            }\n        }\n    }\n\n    return res;\n}\n\nbool cityIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird )\n{\n    bool res = false;\n\n    // start with the root\n    vec3 cen = vec3(0);\n    vec3 rad = ibox;\n    int level = 0;\n    int id = 0;\n\n    bool subdivide = true;\n    \n    for( int i=ZERO; i<STEPS; i++ )\n    {\n        // intersect node\n        if (subdivide) {\n        if( boxIntersectAny( ro, rd, ird, cen, rad ) )\n        {\n            // if leaf\n            if( level == LEVELS )\n            {\n                res = true;\n                break;\n            }\n            // else, generate child of even id\n            else\n            {\n                level++;\n                //even id number\n                id *= 2;\n                generate(cen,rad,id,level);\n            }\n        }\n        // pop next node from the stack\n        else\n        {\n            subdivide = false;\n        }\n        } else {\n            if (level == 0) {\n                break;\n            }\n            //going up nodes until there is an untested node,\n            //if the id number is even id+1 is not tested,\n            //if level is 0 every node is tested, and the ray hasn't hit anything\n            if (id/2*2 != id) {\n\n                backgenerate(cen,rad,id,level);\n\n                id/=2;\n                level--;\n            } else {\n                backgenerate(cen,rad,id,level);\n                //uneven id number\n                id++;\n                generate(cen,rad,id,level);\n                subdivide = true;\n            }\n        }\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    float seed = texelFetch( iChannel2, ivec2(fragCoord)&255, 0 ).x;\n\n    float t = iTime*0.2;\n\n    vec3 ro = vec3(-sin(t),0.5,-cos(t));\n    vec3 rd = normalize(vec3(uv,1));\n    rd.yz *= rot(-0.7);\n    rd.xz *= rot(t);\n    vec3 ird = 1.0/rd;\n\n    float tmin = FAR;\n    int id;\n    int i;\n    vec3 res = cityIntersect( ro, rd, ird, tmin, id,i);\n    \n    vec3 col= vec3(0);\n    if (tmin < FAR) {\n\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = res;\n\n        //random color, based on box id\n        col = hash(uvec3(id,ZERO,ZERO));\n\n        //direction to light\n        vec3 light = normalize(vec3(1));\n\n        float diffuse = clamp(dot(nor,light),0.2,1.0);\n\n        //shadow\n        if (cityIntersectAny(pos+nor*0.01,light,1.0/light)) {\n            diffuse = 0.2;\n        }\n\n        col *= diffuse;\n\n    } else {\n        //some random background\n        col += clamp(dot(rd,normalize(vec3( 1.0, 0.5,-0.7))),0.0,1.0)*vec3(0.8,0.3,0.4);\n        col += clamp(dot(rd,normalize(vec3(-1.0, 0.8,-0.1))),0.0,1.0)*vec3(0.2,0.9,0.4);\n        col += clamp(dot(rd,normalize(vec3( 0.0,-0.3, 0.9))),0.0,1.0)*vec3(0.8,0.6,0.4);\n        col += clamp(dot(rd,normalize(vec3( 0.0,-0.3,-0.9))),0.0,1.0)*vec3(0.8,0.3,0.8);\n        col *= 0.5;\n        col += 0.2;\n    }\n    fragColor = vec4(col, 1);\n\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 243, 243, 313], [314, 314, 338, 338, 400], [402, 481, 503, 503, 632], [634, 634, 702, 702, 835], [837, 837, 909, 909, 1130], [1132, 1132, 1208, 1208, 1428], [1430, 1430, 1528, 1528, 1855], [1857, 1857, 1945, 1945, 2168], [2196, 2196, 2296, 2296, 3975], [3977, 3977, 4039, 4039, 5499], [5501, 5501, 5558, 5608, 6987]]}
{"id": "wss3zB", "name": "Spiral Offset 2", "author": "Del", "description": "Various trippy modifiers applied to a simple spiral over time... enjoy.\nPress left mouse button to see the active blend mods...", "tags": ["spiral", "trippy", "offset"], "likes": 15, "viewed": 477, "published": "Public API", "date": "1546793775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spiral Offset II - Del 06/01/2018\n// watch fullscreen, params have been tweaked to overlap and never loop... :)\n// keep watching... :)\n// added a rainbow flavour at 100 seconds :)\n// added some more mods, added mod viewer with left mouse\n\n#define TAU 6.283185\n\nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n\n// IQ UnevenCapsule distance func\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat TimerInOut(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\nfloat Stime(float scale)\n{\n    return fract(iTime*scale)*TAU;\n}\nfloat Mtime(float mval)\n{\n    return mod(iTime,mval);\n}\n\n// Trippy spiral calc - Del 06/01/2018\nvec2 spiral(vec2 uv,float zoom, float len, float offset,vec2 capoff, float trip, float scount,float rmod)\n{\n    float d = length(uv) * zoom;\n    d=log(d*trip);\n    uv = rot(uv,sin(d*offset)+d*scount*rmod);\n\tfloat v = 1.0-sdUnevenCapsule(uv,vec2(0.0,0.0)+capoff,vec2(0.4*len,0.0)+capoff,0.0,0.4*len)*14.0;\n    return vec2(v,d);\t// dx , dy\n}\n\nvec2 directionalWaveNormal(vec2 p, float amp, vec2 dir, float freq, float speed, float time, float k)\n{\t\n\tfloat a = dot(p, dir) * freq + time * speed;\n\tfloat b = 0.5 * k * freq * amp * pow((sin(a) + 1.0) * 0.5, k) * cos(a);\n\treturn vec2(dir.x * b, dir.y * b);\n}\n\nvec3 summedWaveNormal(vec2 p)\n{\n    float time = iTime;\n\tvec2 sum = vec2(0.0);\n\tsum += directionalWaveNormal(p, 0.5, normalize(vec2(1, 1)), 5.0, 1.5, time, 1.0);\n\tsum += directionalWaveNormal(p, 0.25,normalize(vec2(1.4, 1.0)), 11.0, 2.4, time, 1.5);\n\tsum += directionalWaveNormal(p, 0.125, normalize(vec2(-0.8, -1.0)), 10.0, 2.0, time, 2.0);\n\tsum += directionalWaveNormal(p, 0.0625, normalize(vec2(1.3, 1.0)), 15.0, 4.0, time, 2.2);\n\tsum += directionalWaveNormal(p, 0.03125, normalize(vec2(-1.7, -1.0)), 5.0, 1.8, time, 3.0);\n\treturn normalize(vec3(-sum.x, -sum.y, 1.0));\n}\nvec3 background(vec2 p)\n{\n\tvec3 normal = summedWaveNormal(p);\n\tvec3 c = mix(vec3(0.1, 0.15, 0.1), vec3(0.2, 0.25, 0.4),  dot(normal, normalize(vec3(0.2, 0.2, 0.5))) * 0.5 + 0.5);\n\tc = mix(c, vec3(0.7, 0.9, 1.0), pow(dot(normal, normalize(vec3(-0.4, 0.1, 1.0))) * 0.5 + 0.5, 2.0));\n\tc = mix(c, vec3(0.95, 0.98, 1.0), pow(dot(normal, normalize(vec3(-0.1, -0.3, 0.5))) * 0.5 + 0.5, 10.0));\n    return clamp(c,0.0,1.0);\n}\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.y-=time*2./scale;\n    //uv.x += time*0.2;\n    uv.x+=sin(uv.y+time*.95)*0.025;\t///scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head,float d)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    vec3 scol = vec3(clamp(c*0.3,0.0,0.3));\n    return scol;\n}\n\nvec3 checks(vec2 p)\n{\n    float d = length(p);\n    float head = 1.0-length(p);\n    d+=(0.5+sin(iTime*2.0)*0.5)*0.25;\n    p *= 0.25;\n    return Bubbles(p*(d+0.5), head,d);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Create some blends over time...\n    float t1 = TimerInOut(vec4(Mtime(9.6),1.0, 7.2, 1.8));\n    float t2 = TimerInOut(vec4(Mtime(12.0),1.0, 9.0, 1.5));\n    float t3 = TimerInOut(vec4(Mtime(21.0),6.0, 14.2, 2.8));\n    float t4 = TimerInOut(vec4(Mtime(60.0),15.0,45.0,1.0));\n    float t5 = TimerInOut(vec4(Mtime(85.0),57.0, 67.0, 3.1));\n    float t6 = TimerInOut(vec4(Mtime(123.0),77.0,101.0,10.0));\n    float t7 = TimerInOut(vec4(Mtime(50.0),28.0,45.0,3.5));\n    float t8 = TimerInOut(vec4(Mtime(20.0),1.0,13.0,3.1));\n    float t9 = TimerInOut(vec4(Mtime(200.0),100.0,159.0,0.5));\n    float t10 = TimerInOut(vec4(Mtime(45.0),21.0,31.0,0.75));\n    float t11 = TimerInOut(vec4(Mtime(30.0),7.0,11.0,0.75));\n    \n    // various spiral modifiers applied over time\n    float t = Stime(0.4);\n    float offset = 25.0 * t1;\n\tfloat zoom = 1.0 + (sin(Stime(0.17))*0.5) * t2;\n    vec2 capoff = vec2(sin(uv.y*4.0+Stime(0.125))*0.25, sin(uv.x*2.0+Stime(0.25))*0.75) * t3;\n    float m = 0.48+sin(Stime(0.15)+uv.y+uv.x)*0.5;\n    float trip = 1.0-(m*t4);\n    float scmod = sin(Stime(0.176));\n    float scount = 5.0+((3.0+(scmod*5.0))*t5);\n\n    float rmod = mix (1.0,sin(Stime(0.1))*2.5,t11);\n\n    // debug... (disable effects)\n    //scount = 5.0;\n    //offset=0.0;\n    //zoom = 1.0;\n    //trip = 1.0;\n    //capoff = vec2(0.0);\n    \n\tvec2 dist = spiral(uv, zoom, t, offset, capoff, trip, scount,rmod);\n    \n    float distmod = 0.49+sin(dist.x*0.34+dist.y*1.6+sin(Stime(.1)))*0.5;\n    dist.x = mix(dist.x, dist.x*distmod, t10);\n    \n//\tfloat v2 = smoothstep(0.5-0.1,0.5+0.1,dist.x);\n//\tfloat v2 = smoothstep(0.0,0.5,dist.x);\n\tfloat v2 = smoothstep(0.0, 1.5*fwidth(dist.x-0.5), dist.x-0.5);\n    \n\tfloat v = mix(v2,clamp(dist.x,0.0,3.0), t6);\n    //vec3 col = vec3(v*1.0-l/t);\n    vec3 col1 = checks(uv);\t////vec3(0.0,0.0,0.2);\n    vec3 col2 = vec3(1.0,0.6,0.5);\n    \n    // rainbow flavour...\n\tcol2 = mix(col2,hsv2rgb_smooth(vec3(fract(iTime*0.2)+dist.x*0.09+dist.y*0.2,0.8,clamp(v,0.35,1.0)))*0.7,t9);\n    \n    vec3 col3 = background(uv);\t//vec3(0.5,0.7,0.5);\n    col1 = mix(col1,col3*0.3, t7);\n    col2 = mix(col2,col3*0.9, t8);\n    //vec3 col = mix(col1,col2,v*1.0-dist.y/t);\n\n    float finalblend = clamp(v*1.0-dist.y/t,0.0,5.0);\n    vec3 col = mix(col1,col2,finalblend);\n\n    // vignette\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    // utter hack, overlay some coloured circles to show active mods... :)\n    if (iMouse.z>0.5)\n    {\n        uv.xy += 0.05;\n        float c = pMod1(uv.y,0.1);\n        if (c<-3.0)\n        {\n            uv.x -= 0.3;\n            c = pMod1(uv.x,0.1);\n            if (c>=-8.0)\n            {\n                float dd = length(uv)*2.0;\n                dd = 1.0-smoothstep(0.0,0.1,dd);\n                vec3 cf = vec3(0.0);\n                vec3 cc = hsv2rgb_smooth( vec3((c+8.0)/12.0,1.0,dd));\n                if (c<-7.0) cf = cc*t1;\n                else if (c<-6.0) cf = cc*t2;\n                else if (c<-5.0) cf = cc*t3;\n                else if (c<-4.0) cf = cc*t4;\n                else if (c<-3.0) cf = cc*t5;\n                else if (c<-2.0) cf = cc*t6;\n                else if (c<-1.0) cf = cc*t7;\n                else if (c<-0.0) cf = cc*t8;\n                else if (c<1.0) cf = cc*t9;\n                else if (c<2.0) cf = cc*t10;\n                else if (c<3.0) cf = cc*t11;\n                float _mm = smoothstep(0.0,0.1,length(cf)-0.2);\n                col = mix(col,cf,_mm);\n           \t}\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wss3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 264, 295, 295, 381], [383, 417, 451, 451, 479], [480, 480, 566, 566, 1053], [1055, 1055, 1081, 1081, 1153], [1154, 1154, 1180, 1180, 1217], [1218, 1218, 1243, 1243, 1273], [1275, 1314, 1421, 1421, 1653], [1655, 1655, 1758, 1758, 1916], [1918, 1918, 1949, 1949, 2491], [2492, 2492, 2517, 2517, 2909], [2911, 2911, 2943, 2943, 3310], [3312, 3312, 3354, 3354, 3549], [3551, 3551, 3572, 3572, 3723], [3725, 3725, 3759, 3759, 3937], [3939, 3939, 3979, 3979, 4100], [4102, 4102, 4159, 4159, 7767]]}
{"id": "wsS3zw", "name": "Raytracing Ghosting Option", "author": "HenrikH", "description": "Work in Progress\n\nI am trying to implement an easy to understand Raytracer with some extra features.", "tags": ["whittedraytracing"], "likes": 6, "viewed": 128, "published": "Public", "date": "1548444220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Movement Speed\n#define Raybounces 5\n\n//Camera\n#define CamPosition vec3(-10.0, 5.0,  -2)\n#define LookPosition vec3(-1.0, 3.0, -2)\n#define exposure 0.01\n#define gamma 2.2\n#define Zoom 1.5\n#define MovementSpeed 0.5\n\n//Environment\n#define ambientintensity .2\n#define ambientColor vec3(255, 204, 255)\n\n//Light\n#define lightintensity 100.0\n#define lightcolor vec3(1.0)\n#define StaticLightPos vec3(0.0,10.0,0.0)\n\n//AntiAliasing\n#define OverSampling 2 \t\t\t//each step results in 4 Samples per Pixel\n#define AntiAliasing false\t\t//true for extra Samplex per Pixel\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light \n{\n    vec3 Position;\n    vec3 color;\n};\n    \nstruct Material \n{\n    vec3 color;\n    float diffuse;\n    float specular;\n    bool ghost;    //Object only Visible by Reflections\n};  \n\nstruct Intersect\n{\n    float len;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n    \nstruct Plane \n{\n    vec3 normal;\n    Material material;\n};\n\nSphere spheres[] = Sphere[4](\n        Sphere(2.0, vec3(-6.0, 3.0, -6), Material(vec3(1, 1, 1.0), 1.0, 0.5, false)), //Silver\n        Sphere(2.0, vec3(-5.0, 3.0, 4), Material(vec3(1, 0.0, 0.2), 1.0, 0.5, false)), //Red\n        Sphere(3.0, vec3( 5.0, 3.0, 5), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0, false)), //Blue\n    \tSphere(2.5, vec3( 0.0, 3.0, 0), Material(vec3(0.0, 1.0, 0.3), 0.5, 0.5, true)) //Green\n    );  \n    \n// To Spawn newRays in front of Faces\nconst float epsilon = 0.02;\n\n//Camera Set up\nconst vec3 ambient = ambientColor * ambientintensity / gamma;\n\n\n//intersectof distance zero to represent a miss.\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0,false));\n\n\nLight getLight()\n{\n    vec3 LightPos = StaticLightPos;\n\t//LightPos.xz += vec2(sin(iTime),cos(iTime))*5.0;    //LightMovement\n\tLight light = Light(LightPos, lightcolor * lightintensity);\n    return light;\n}\n\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\n\nIntersect trace(Ray ray, int bouncecounter) \n{\n    Intersect PlaneIntersection;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(.5, .5, .5), 1.0, 0.0, false)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { PlaneIntersection = plane; }\n    \n    Intersect SphereIntersection;\n    \n    for (int i = 0; i < spheres.length(); i++) \n    {\n         if(bouncecounter>=1) // reflecdet rays\n         {\n                Intersect sphere = intersect(ray, spheres[i]);\n            \tif (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n                \tif(sphere.len < SphereIntersection.len || SphereIntersection.len == miss.len) //Chicking if Sphere is the Closest Sphere if nothing was Hit before it is\n                    {\n                        SphereIntersection = sphere;\n                    }\n         }\n        else //normal rays\n        {\n            if(spheres[i].material.ghost != true) //Ignore Ghosts\n            {\n                Intersect sphere = intersect(ray, spheres[i]);\n                if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n                    if(sphere.len < SphereIntersection.len || SphereIntersection.len == miss.len)//Chicking if Sphere is the Closest Sphere if nothing was Hit before it is\n                    {\n                        SphereIntersection = sphere;\n                    }\n            }  \n\n        }     \n    }\n    \n    Intersect intersection = PlaneIntersection;\n    \n    if(SphereIntersection != miss)\n    {\n            if(SphereIntersection.len < PlaneIntersection.len || PlaneIntersection==miss)\n            {\n                intersection = SphereIntersection;\n            }  \n    }    \n    return intersection;\n}\n\nvec3 Tracing(Ray ray) {    \n    vec3 fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    Light light = getLight();\n    \n\n  for (int i = 0; i <= Raybounces; ++i) \n  {      \n    Intersect hit = trace(ray, i);   \n        \n    if(hit != miss)\n    {\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0)\n        {\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;  \n            \n            //return mask;\n\n            vec3 Hitpoint = ray.origin + hit.len * ray.direction;\n            vec3 DirToLight = normalize(light.Position - Hitpoint);\n            Ray Shadowray = Ray(Hitpoint + DirToLight*2.0, DirToLight);\n            \n            Intersect shadowhit = trace(Shadowray, i);        \n            if (shadowhit == miss) //nichtImSchatten\n            {         \n                color += (clamp(dot(hit.normal, DirToLight), 0.0, 1.0) * light.color\n                    * hit.material.color.rgb * hit.material.diffuse\n                    * (1.0 - fresnel) * mask / fresnel);         \n            }    \n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(Hitpoint + epsilon * reflection, reflection);\n        }\n\n    }\n    else\n    {\n      color += mask * (ambient); break;\n    }\n        \n  } \n    return color;\n}\n\nvec3 RenderColor(in vec2 fragCoord)\n{\n    //Uv Space\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/ iResolution.y;\n    \n    //CamMovement\n    vec3 newCamPos = CamPosition;\n    newCamPos.xz +=  vec2(sin(iTime*MovementSpeed),cos(iTime*MovementSpeed))* 30.;\n    \n    //NewCoordinates\n    vec3 ForwardVec = normalize(LookPosition-newCamPos);\n    vec3 RightVec = cross(vec3(0.,1.,0.), ForwardVec);\n    vec3 UpVec = cross(ForwardVec,RightVec);\n    vec3 Centerpoint = newCamPos+ ForwardVec*Zoom;\n    \n    vec3 Color;\n \n    //TraceRays   \n    vec3 ImagePoint = Centerpoint -uv.x*RightVec + uv.y*UpVec;    \n    vec3 Raydirection = ImagePoint-newCamPos;\n    Raydirection = normalize(Raydirection);\n\n    Ray ray = Ray(newCamPos, Raydirection);\n    Color += pow(Tracing(ray) * exposure, vec3(1.0 / gamma));\n\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 OversampleCol = vec3(0.);\n\n    if (AntiAliasing)\n    {\n        float SamplingRange = .4;\n        \n         for (int i = 1; i <= OverSampling; ++i) \n  \t\t {\n             float ExtraCoord = SamplingRange/float(i);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(ExtraCoord,ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(ExtraCoord,-ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(-ExtraCoord,ExtraCoord)),0.,1.);\n             OversampleCol += clamp(RenderColor(fragCoord + vec2(-ExtraCoord,-ExtraCoord)),0.,1.);\n         }       \n        OversampleCol /= float(OverSampling)*4.;\n    }\n    else\n    {\n        OversampleCol += RenderColor(fragCoord);\n    }\n\n    fragColor = vec4(OversampleCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsS3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1598, 1736, 1754, 1754, 1941], [1943, 1943, 1988, 2028, 2478], [2480, 2480, 2523, 2523, 2697], [2700, 2700, 2746, 2746, 4445], [4447, 4447, 4470, 4470, 5916], [5918, 5918, 5955, 5970, 6773], [6775, 6775, 6832, 6832, 7632]]}
{"id": "Wss3zX", "name": "Koch Snowflake", "author": "Jamesika", "description": "Koch Snowflake.\n------------------------2019/1/10 Fixed-----------------------------\nLoop index must be constant in Edge browser.", "tags": ["snowflake", "koch"], "likes": 10, "viewed": 470, "published": "Public API", "date": "1547050270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nvec2 ToPolar(vec2 pos)\n{\n   \tfloat r = length(pos);\n    // a (0, 2*PI)\n    float a = atan(-pos.y,-pos.x)+PI;\n    return vec2(r,a);\n}\n\nvec2 Rotate(vec2 pos, float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*pos;\n}\n\n// ====================== Drawing Shapes ===========================\nfloat Circle(vec2 center, vec2 pos, float radius)\n{\n    vec2 dir = pos - center;\n    return step(dot(dir,dir),pow(radius,2.0));\n}\n\nfloat Triangle(vec2 center, vec2 pos, float radius)\n{\n    vec2 dir = pos - center;\n    \n    //return step(-radius,dir.y)*\n    //    step(dir.y, sqrt(3.0)*dir.x+2.0*radius)*\n    //    step(dir.y, -sqrt(3.0)*dir.x+2.0*radius);\n    \n    return step(\n        0.0,\n        min(dir.y + radius,\n            min(- dir.y + sqrt(3.0)*dir.x+2.0*radius,\n                - dir.y - sqrt(3.0)*dir.x+2.0*radius)));\n}\n\nfloat Hexagram(vec2 center, vec2 pos, float radius)\n{\n\tfloat t1 = Triangle(center, pos, radius);\n    \n    pos = center + Rotate(pos-center,PI);\n    \n    float t2 = Triangle(center, pos, radius);\n    return max(t1,t2);\n}\n\nfloat Skeleton(vec2 center, vec2 pos, float radius)\n{\n\tvec2 polar = ToPolar(pos - center);\n\t\n    // vertical skeleton\n    float width = 0.13*radius;\n    vec2 dir = Rotate(pos-center, round((polar.y-PI/2.0)/(PI/3.0))*(PI/3.0));\n    float ver = mix(0.0,1.0,1.0-clamp(abs(dir.x)/width,0.0,1.0));\n    ver = ver - mod(ver,0.25);\n    ver *= step(polar.x,radius);\n\n    // horizontal skeleton\n    dir.x = abs(dir.x);\n    dir = Rotate(dir,-PI/6.0);\n    float hor = clamp(dir.y/radius,0.0,1.0);\n    hor = fract(hor*4.0);\n    hor = 1.0 - abs(hor*2.0 - 1.0);\n    hor = hor - mod(hor,0.25);\n    \n    return max(ver, hor);\n}\n\nfloat DrawShape(vec2 center, vec2 pos, float radius)\n{\n    float shapeRatio = sin(iTime*0.7)*0.5+0.5;\n    return\n\t\tmix(Skeleton(center, pos, radius),\n            Hexagram(center, pos, radius),\n            shapeRatio);\n}\n\n// ================================================================\n\nfloat Koch(vec2 pos)\n{\n    const int n = 4;\n    \n    float radius = 100.0;\n    vec2 center = vec2(0.0);\n    \n    float c = DrawShape(center,pos,radius);\n    \n\tfor(int i = 0;i<n;i++)\n    {\n        vec2 localPos = pos - center;\n        float polarAngle = atan(-localPos.y,-localPos.x) + PI;\n        float index = floor(polarAngle/(PI/3.0))+0.5;\n        center += (radius*4.0/3.0)*vec2(cos(index*PI/3.0),sin(index*PI/3.0));\n        radius /= 3.0;\n        c += DrawShape(center,pos,radius);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = 350.0*(2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float t = iTime;\n    // rotate & scale\n    pos = Rotate(pos,iTime*0.4)*(1.0+0.2*sin(t));\n    // alpha\n   \tfloat c = Koch(pos)*(sin(iTime)*0.2+0.35);\n    \n    // color it\n    vec3 col = \n        vec3(0.1,0.15,0.2)*pow(1.5-length(uv-vec2(0.5)),2.0) + \n        vec3(0.4,0.8,0.88)*c;\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wss3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 156], [158, 158, 194, 194, 263], [265, 334, 385, 385, 463], [465, 465, 518, 518, 865], [867, 867, 920, 920, 1086], [1088, 1088, 1141, 1141, 1698], [1700, 1700, 1754, 1754, 1919], [1921, 1990, 2012, 2012, 2498], [2500, 2500, 2557, 2557, 2993]]}
{"id": "WssGDS", "name": "unz", "author": "bpaf", "description": "a pulse", "tags": ["pulse"], "likes": 4, "viewed": 161, "published": "Public", "date": "1547391039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589;\nfloat mmod(float a, float b) { return a - floor(a/b); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c1 = vec2(0.5,0.5);\n    float n = 3.0*mmod(iTime,1.0);\n    float a = cos(length(uv - c1) * 6.0 * n * 2.0 * pi) * sin(length(uv - c1) * 4.0 * (n+1.0) * 2.0 * pi);\n    vec3 col = vec3(0,1,0) * a;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 88], [89, 89, 146, 146, 420]]}
{"id": "wssGRS", "name": "Spiral Flash", "author": "Del", "description": "spiral fx", "tags": ["2d", "spiral", "flash"], "likes": 9, "viewed": 321, "published": "Public API", "date": "1546748274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\n\nvec2 spiral(vec2 uv,float zoom, float len)\n{\n    float d = length(uv) * zoom;\n    d=log(d);\n    uv = rot(uv,d*5.0);\n\tfloat v = 1.0-sdUnevenCapsule(uv,vec2(0.0,0.0),vec2(0.4*len,0.0),0.0,0.4*len)*14.0;\n    float l = d;   \n    return vec2(v,l);\t// distx , disty\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float t = fract(iTime*0.4)*6.0;\n    \n\tvec2 dist = spiral(uv,1.0,t);\n    float v = dist.x;\n    float l = dist.y;\n    \n\tv = smoothstep(0.5-0.1,0.5+0.1,v);\n    //vec3 col = vec3(v*1.0-l/t);\n    \n    vec3 col = mix(vec3(0.0,0.0,0.2),vec3(1.0,0.6,0.5),v*1.0-l/t);\n    \n \tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 117], [118, 118, 152, 152, 180], [182, 182, 268, 268, 755], [758, 758, 802, 802, 1019], [1022, 1022, 1079, 1079, 1562]]}
{"id": "wsSGRw", "name": "Raytracing Reflections Demo", "author": "mrsaturn", "description": "Quick and simple reflections + shadows!", "tags": ["reflection", "raytrace"], "likes": 1, "viewed": 364, "published": "Public API", "date": "1548408980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// setup\n/////////////////////////////////////////////////////////////////\nconst vec3 CAMERA_POS = vec3(0, 0, 2.0);\nconst vec3 FORWARD = vec3(0.0, 0.0, -1.0);\nconst vec3 RIGHT = normalize(cross(vec3(0.0, 1.0, 0.0), FORWARD));\nconst vec3 UP = normalize(cross(FORWARD, RIGHT));\nconst mat3 CAMERA_MATRIX = mat3(RIGHT, UP, FORWARD);\nconst float FOV = 5.5;\n\nconst float LIGHT_INTENSITY = 1.0;\nconst float SHADOW_FACTOR = 0.3;\nconst float BIAS = 0.05;\nconst float LIGHT_MOVE_FACTOR = 0.2;\n\nstruct Material\n{\n    vec3 color;\n};\n    \nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material mat;\n};\n    \nconst Material RED = Material(vec3(1.0, 0.0, 0.0));\nconst Material GREEN = Material(vec3(0.0, 1.0, 0.0));\nconst Material BLUE = Material(vec3(0.0, 0.0, 1.0));\nconst Material PURPLE = Material(vec3(1.0, 0.0, 1.0));\nconst Material WHITE = Material(vec3(1.0, 1.0, 1.0));\n\nSphere SPHERES[] = Sphere[]\n(\n    Sphere(vec3(-1.0, 0.0, -5.0), 0.5, RED),\n    Sphere(vec3(0.2, 0.0, -5.0), 0.4, GREEN),\n    Sphere(vec3(0.8, 0.0, -5.0), 0.3, BLUE),\n    Sphere(vec3(1.5, 0.0, -5.0), 0.2, PURPLE),\n    Sphere(vec3(0.0, 0.0, -7.0), 1.2, WHITE)\n);\n\nstruct IResult\n{\n    bool iIntersected;\n    vec3 iPoint;\n    vec3 iNormal;\n};\n/////////////////////////////////////////////////////////////////\n\n// get a direction ray in world-space\nvec3 rayDir(vec2 coord)\n{\n    return normalize(CAMERA_MATRIX * vec3(coord, FOV));\n}\n\n// test ray-sphere intersection\nIResult sphereIntersect(vec3 start, vec3 dir, Sphere s)\n{\n    vec3 m = start - s.position;\n    float b = dot(m, dir); \n\tfloat c = dot(m, m) - s.radius * s.radius;\n    \n    if (c > 0.0f && b > 0.0f)\n        return IResult(false, vec3(0.0), vec3(0.0));\n    \n\tfloat discr = b * b - c;\n    \n    if (discr < 0.0f)\n\t\treturn IResult(false, vec3(0.0), vec3(0.0));\n    \n    float t = -b - sqrt(discr);\n    if (t < 0.0)\n        t = 0.0;\n    \n    vec3 ipoint = start + t * dir;\n    \n    return IResult(true, ipoint, normalize(ipoint - s.position));\n}\n\n// test for rs-intersection, run reflection test, run shadow test\nvec3 rayTrace(const vec3 dir, vec3 light_pos)\n{\n    for (int i = 0; i < SPHERES.length(); ++i)\n    {\n        IResult result = sphereIntersect(CAMERA_POS, dir, SPHERES[i]);\n        \n        if (result.iIntersected)\n        {\n            vec3 indirect = vec3(0.0);\n            float shadow = 1.0;\n            vec3 ldir = -normalize(light_pos);\n            vec3 from_light = normalize(result.iPoint - light_pos);\n            \n            for (int j = 0; j < SPHERES.length(); ++j)\n            {   \n            \tIResult result2 = sphereIntersect(result.iPoint + result.iNormal * BIAS, result.iNormal, SPHERES[j]);\n                \n                if (result2.iIntersected)\n                    indirect += LIGHT_INTENSITY * max(dot(ldir, result2.iNormal), 0.0) * SPHERES[j].mat.color;\n            }\n            \n            for (int j = 0; j < SPHERES.length(); ++j)\n            {\n            \tIResult result2 = sphereIntersect(result.iPoint + from_light * BIAS, from_light, SPHERES[j]);\n                \n                if (result2.iIntersected)\n                    shadow -= SHADOW_FACTOR;\n            }\n            \n            if (shadow < 0.0)\n                shadow = 0.0;\n            \n            return (indirect + SPHERES[i].mat.color) * shadow * LIGHT_INTENSITY * max(dot(ldir, result.iNormal), 0.0);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n// move spheres up and down\nvoid animateSpherePositions()\n{\n    for (int i = 0; i < SPHERES.length() - 1; ++i)\n    {\n     \tSPHERES[i].position.y = cos(sin(SPHERES[i].position.x)) + sin(iTime * (float(i) + 0.2)) - 0.8;   \n    }\n}\n\n// move light around the scene\nvec3 animateLight()\n{\n    float factor = iTime * LIGHT_MOVE_FACTOR;\n    float circleX = sin(factor);\n    float circleZ = cos(factor);\n \treturn 50.0 * vec3(circleX, 0.0, circleZ);\n}\n\n// output pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 dir = rayDir(coord);\n    \n    animateSpherePositions();\n    \n    const vec3 gamma = vec3(0.454545);\n    fragColor = vec4(pow(rayTrace(dir, animateLight()), gamma), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1281, 1319, 1344, 1344, 1402], [1404, 1436, 1493, 1493, 1975], [1977, 2043, 2090, 2090, 3393], [3395, 3423, 3454, 3454, 3623], [3625, 3656, 3677, 3677, 3836], [3838, 3854, 3911, 3911, 4161]]}
{"id": "WsSGzh", "name": "Marble Fantasies Colored", "author": "tholzer", "description": "Stereo variant of [url]https://www.shadertoy.com/view/tdXGWM[/url].\nUse mouse to rotate marble.\ntoggle keys: a, f, r, s  see header!", "tags": ["3d", "transparency", "sphere", "antialiasing", "raytrace", "satiny"], "likes": 8, "viewed": 184, "published": "Public", "date": "1548068544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Originally created by S. Guillitte 2015\n\n//---------------------------------------------------------\n// keys: a  sphere pattern animation\n//       f  show sphere reflections\n//       r  rotation scene\n//       s  cross eye stereo view\n//---------------------------------------------------------\n// shadertoy defines\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n//---------------------------------------------------------\n// get javascript keycode: http://keycode.info/\n//----------------------------------------------------------\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n//----------------------------------------------------------\nbool ReadKey(int key, bool toggle)\n{\n  return 0.5 < texture(iChannel3\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n\n//---------------------------------------------------------\n// global settings\n//---------------------------------------------------------\nbool animate_pattern = false;    // a\nbool show_reflections = false;   // f\nbool rotation_scene = true;      // r\nbool cross_eye_view = true;      // v\n//---------------------------------------------------------\nvoid keyInput()\n{\n  if (iFrame > 9)\n  {\n    animate_pattern   = !ReadKey(KEY_A, true);\n    show_reflections  = !ReadKey(KEY_F, true);\n    rotation_scene    = !ReadKey(KEY_R, true);\n    cross_eye_view    = !ReadKey(KEY_S, true);\n  }\n}\n//---------------------------------------------------------\n// here some values to play for you ...\n\n#define MAP_OCTAVE 7\n#define BACK_COLOR vec3(0.4, 0.05, 0.05)\n#define INNER_COLOR vec3(0.2, 0.2, 0.6)\n#define GLAS_COLOR vec3(0.5, 0.5, 0.9)\n\n\n\n\n\n\n\n\n//---------------------------------------------------------\n//Play with the detail level, change it!\n#define DETAIL 5\n\n//also play with this one. Fixed it so that the marble doesn't go dark when this is small.\n#define INNER_DEPTH 64\n\n//play with these too you can try changes in the range of 1s, 10s or 100s\n//but keep a decimal point on it or it won't compile\n#define COLOR_CONTRAST 45.0\n#define MILKY_LIGHT 80.0\n\n//not exactly opacity.. in this model the \"subtractive\" colors are actually adding light, but light can \n//have negative colors... Yeah it's not a realistic model. I did it by mistake, but it looks cool. \n\n//0 is color is additive\n//1 is color is kind of subtractive\n#define OPACITY_OF_COLOR 1.0\n\nfloat zoom=1.;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n//---------------------------------------------------------\nvec3 map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < DETAIL; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)))+.02;\n        \n\t}\n\treturn res*COLOR_CONTRAST*0.013*(normalize(p)+(1.0-OPACITY_OF_COLOR)*vec3(1.0));\n}\n//---------------------------------------------------------\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    if (animate_pattern)\n      dt = 0.02 + 0.01*cos(time*0.5);\n     \n    vec3 col= vec3(0.);\n    vec3 c = vec3( 0.);\n    for( int i=0; i<INNER_DEPTH; i++ )\n\t{\n        t+=dt*exp(-2.*length(c));\n        if(t>tminmax.y)break;\n        //vec3 pos = ro+t*rd;\n        vec3 pos = refract( ro, (ro+t*rd)/.7,-.012);\n        c = map(pos);//map(ro+t*rd);               \n        \n        float gr= MILKY_LIGHT*0.02/float(INNER_DEPTH);//.01*(2.0-float(i)/64.0);\n        \n        col = .99*col+ .08*c+vec3(gr);//vec3(c*c, c, c*c*c);//green\t\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n    }    \n    return col;\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    keyInput();\n\n    vec2 uv = 2.0*(fragCoord.xy / resolution.xy) - 1.0;\n    uv.x *= resolution.x / resolution.y;\n    vec2 m = vec2(-0.5);\n//    if( mouse.z > 0.0 )   // mouse pressed?\n\tm = mouse.xy / resolution.xy * 3.14;\n//    m += mouse.xy * 3.14;    // use on glslsandbox.com\n\n    float eye = 0.1;\n    float radius = 1.4;\n\n    if (cross_eye_view)     // stereo view ?\n    {\n      radius = 1.0;\n      if (uv.x > 0.)\n      {\n        uv.x -= 0.8;\n        eye = -0.1;\n      } else {\n        uv.x += 0.8;\n        eye = +0.1;\n      }\n    }\n\n    // camera\n    vec3 ro = vec3(6,0,0);   // origin\n    ro.y += eye;\n    ro.yz *= rot(m.y);\n    ro.xz *= rot(m.x);\n    if (rotation_scene)\n      ro.xz *= rot(0.07*time);\n\n    vec3 ta = vec3( 0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 4.0*ww );\n\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,radius) );\n\n    // sound animation\n//\tfloat fft  = texture( iChannel0, vec2(p.x+22.,0.25) ).x;\n//  float wave = texture( iChannel0, vec2(p.x,0.75) ).x;\n//  tmm += 0.6*wave + fft;\n\n    // raymarch\n    vec3 col = raymarch(ro,rd,tmm);  // get sphere Color\n\n    const float taa = 6.3;     // antialiasing limit\n    float aa = (2.2*(tmm.x - taa));\n    if ((tmm.x < 0.0) || (tmm.x > taa))\n    {\n        vec3 bgCol = BACK_COLOR * map(rd);   // background color\n        if (tmm.x > taa)\n    \t{\n\t        //bgCol = vec3(9.0, 5.0, 0.0);   // for testing antialiasing\n            col = mix( col, bgCol, aa);      // do antialasing\n        }\n        else col = bgCol;        // set pure background color\n    }\n\n    if (tmm.x > 0.0)             // add sphere reflection ?\n    {\n        vec3 nor = reflect(rd, (ro+tmm.x*rd) * 0.5);  // sphere normal\n        float fre = pow(0.3+ clamp(dot(nor,rd), 0.0, 1.0), 3. )*1.3;\n        // add reflecting color\n        col += GLAS_COLOR * fre * 0.1 *(1.0-aa);   // add some solid glas\n        if (show_reflections)\n\t      col += BACK_COLOR * map(nor) * fre * 0.3 *(1.0-aa);\n    }\n\n    // shade\n    col = 0.5 *(log(1.0 + col));\n    col = clamp(col, 0., 1.0);\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSGzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1219, 1280, 1316, 1316, 1413], [1415, 1766, 1783, 1783, 1999], [2871, 2979, 3009, 3009, 3064], [3065, 3065, 3087, 3087, 3136], [3139, 3139, 3158, 3158, 3205], [3207, 3207, 3269, 3269, 3455], [3456, 3516, 3537, 3537, 3830], [3831, 3891, 3943, 3943, 4598], [4600, 4660, 4717, 4717, 6908]]}
{"id": "wsSGzm", "name": "RayMarcher-alima", "author": "aliman2018", "description": "raymarch based shader", "tags": ["raymarch"], "likes": 1, "viewed": 49, "published": "Public", "date": "1548584236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST 0.0001\n#define ROT_SPEED 0.\n\n\nstruct Sphere{\n    vec4 s;\n    vec4 color;\n    float reflectiveness;\n};\n    \nstruct Plane{\n \tvec4 p;\n    vec4 color;\n    float reflectiveness;\n};\n    \nstruct Torus{\n \tvec3 t;\n    vec2 r;\n    vec3 d;\n    vec4 color;\n    float reflectiveness;\n};   \n    \nstruct Cube{\n    vec4 c;\n    vec3 d;\n    vec4 color;\n    float reflectiveness;\n};\nSphere sp = Sphere(vec4(0., 1., -6., 1), vec4(1., 0., 0., 1.), 0.);\nPlane pl = Plane(normalize(vec4(0., 1., 0., 0.)), vec4(1., 1., 0., 0.), 0.);\nTorus tr = Torus(vec3(0., 1., -6.), vec2(1., .4), vec3(0., 1., 0.), vec4(0., 1., 1., 1.), 0.);\nCube cb = Cube(vec4(3, 1, -6, 1), vec3(0, 1, 0), vec4(0, 1, 0, 1), 0.);\n\nfloat sdSphere(vec3 p, Sphere _sp){\n \treturn (length(p-_sp.s.xyz)-_sp.s.w);   \n}\n\nfloat sdPlane(vec3 p, Plane _pl){\n    float d = dot(p, _pl.p.xyz)-_pl.p.w;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, Torus _tr){\n    float dxz = length(p.xz-_tr.t.xz)-_tr.r.x;\n    float dxyz = length(vec2(dxz, p.y-_tr.t.y))-_tr.r.y;\n    return dxyz;\n    \n}\n\nfloat sdCube(vec3 p, Cube _cb){\n    vec3 dif = abs(_cb.c.xyz-p);\n    return length(max(vec3(0), dif-_cb.c.w));\n}\n\nfloat sdIntersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat sdUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat sdDifference(float d1, float d2){\n    return max(d1, -d2);\n}\nfloat getDist(vec3 p){\n\tfloat sD = sdSphere(p, sp);\n    float pD = sdPlane(p, pl);\n    float tD = sdTorus(p, tr);\n    float cD = sdCube(p, cb);\n    float _min = sD;\n    _min = sdDifference(sD, tD);\n    _min = sdUnion(_min, pD);\n    _min = min(_min, cD);\n    return _min;\n}\n\nfloat rayMarch(vec3 d, vec3 o){\n \tvec3 p = o;\n    float dO = 0.;\n    float dist;\n    for(int i = 0; i < MAX_STEPS; i++){\n        dist = getDist(p);\n    \tdO += dist; \n        p = o + d*dO;\n        if(dO > MAX_DIST || dist < SURF_DIST){\n            break;\n        }\n    }\n\treturn dO;\n}\n\nvec3 getNormal(vec3 p){\n    \n    vec2 dd = vec2(SURF_DIST, 0);\n    float d = getDist(p);\n    float dx = getDist(p-dd.xyy);\n    float dy = getDist(p-dd.yxy);\n    float dz = getDist(p-dd.yyx);\n    return normalize(d-vec3(dx, dy, dz));\n\t\n    \n}\n\nvec4 getCol(vec3 p){\n    float sd = abs(sdSphere(p, sp));\n    float pd = abs(sdPlane(p, pl));\n    float td = abs(sdTorus(p, tr));\n    float cd = sdCube(p, cb);\n    float _min = min(sd, pd);\n    _min = min(_min, td);\n    _min = min(_min, cd);\n    if(_min == sd) return sp.color;\n    if(_min == pd) return pl.color;\n    if(_min == td) return tr.color;\n    if(_min == cd) return cb.color;\n    \n    \n    \n    return vec4(1, 1, 0, 1);\n}\n\nvec4 getLight(vec3 p){\n    vec3 norm = getNormal(p);\n    p += norm*SURF_DIST*2.;\n    vec3 lightPos = vec3(10.*sin(iTime), 7, 10.*cos(iTime));\n    float distToLight = length(p-lightPos);\n    vec3 dirToLight = normalize(lightPos-p);\n    float dist = rayMarch(dirToLight, p);\n    float diff = mix(.1, 1., clamp(dot(dirToLight, norm), 0., 1.));\n    \n    vec4 col = getCol(p);\n    \n    if(dist < distToLight){\n        return col*0.1;\n    }else{\n        return col*diff;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y/1.;\n    vec3 camDir = vec3(sin(iTime*ROT_SPEED), 0., -cos(iTime*ROT_SPEED));\n    vec3 camPos = vec3(0, 2, 0.);\n    \n    vec3 px = vec3(-camDir.z, 0, camDir.x)*uv.x;\n    vec3 py = vec3(0, 1, 0)*uv.y;\n    \n    \n    \n    vec3 rD = normalize(camDir+px+py);\n    vec3 rO = camPos;\n    \n    float dist = rayMarch(rD, rO);\n    vec3 p = rO + rD*dist;\n    vec4 col = vec4(0);\n    if(dist < MAX_DIST){\n        col = vec4(getLight(p));\n    }\n\t//col = vec4(vec3(sdCube(p, vec4(-5, 1, -6, 1))/20.), 1.);\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[740, 740, 775, 775, 820], [822, 822, 855, 855, 917], [919, 919, 952, 952, 1080], [1082, 1082, 1113, 1113, 1194], [1196, 1196, 1235, 1235, 1261], [1263, 1263, 1297, 1297, 1323], [1325, 1325, 1364, 1364, 1391], [1392, 1392, 1414, 1414, 1664], [1666, 1666, 1697, 1697, 1949], [1951, 1951, 1974, 1974, 2192], [2194, 2194, 2214, 2214, 2625], [2627, 2627, 2649, 2649, 3104], [3106, 3106, 3163, 3213, 3790]]}
{"id": "wsSGzz", "name": "evankh_Mandelbrot", "author": "evankh", "description": "A basic Mandelbrot set zoom, the \"Hello world\" of shaders.", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 94, "published": "Public", "date": "1547942988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float boundary = 7.0;\t// Defines the boundary beyond which a point is considered to have escaped; almost completely irrelvant but artifacts occur less than ~5.0\nint iterations = 500;\t// The maximum number of iterations to perform on a given point\nfloat zoomspeed = 0.5;\t// Initial zoom level at t = 0.0\nvec2 zoomcenter = vec2(-0.7335185, 0.197);\t// The point to zoom in on\n\n// The set of colors that define the gradient\nvec3[] colors = vec3[](vec3(1.0,0.0,0.0), vec3(1.0,1.0,0.0), vec3(0.0,1.0,0.0), vec3(0.0,1.0,1.0), vec3(0.0,0.0,1.0), vec3(1.0, 0.0, 1.0));\n\n// Multiply two vec2's like they're complex numbers\nvec2 cpx_mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n// Sample a gradient\nvec3 color_ramp(float fac, vec3[6] colors, bool repeat) {\n    if (repeat) fac = mod(fac, 6.0);\n    else fac = clamp(fac, 0.0, 5.0);\n    return mix(colors[int(fac)], colors[(int(fac) + 1) % 6], fract(fac));\n}\n\nvec3 fractal(vec2 c) {\n    // Zoom mechanics\n    float zoomlevel = exp(-iTime * zoomspeed);\n    c *= zoomlevel;\n    c += zoomcenter;\n    int maxiter = int(iTime / zoomspeed) + iterations;\n    \n    // Algorithm iteration with early exit for efficiency\n    int i = 0;\n    vec2 f = vec2(0.0);\n    while (i < maxiter && length(f) < boundary) {\n        i++;\n        f = cpx_mul(f, f) + c;\n    }\n    \n    // Color according to escape time\n    if (length(f) < boundary)\n        // Point is still bounded\n        return vec3(0.0);\n    else {\n        // Point has diverged beyond the specified boundary\n    \tfloat smoothfac = float(i + 1) - log(log(length(f))) / log(2.0);\n        return color_ramp(smoothfac - iTime, colors, true);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord;\n    vec2 uv2 = fragCoord + vec2(0.5, 0.0);\t// 4xAA\n    vec2 uv3 = fragCoord + vec2(0.0, 0.5);\n    vec2 uv4 = fragCoord + vec2(0.5);\n    vec2 c1 = uv1 / iResolution.yy - vec2(1.0, 0.5);\t// Centers the set in the window\n    vec2 c2 = uv2 / iResolution.yy - vec2(1.0, 0.5);\n    vec2 c3 = uv3 / iResolution.yy - vec2(1.0, 0.5);\n    vec2 c4 = uv4 / iResolution.yy - vec2(1.0, 0.5);\n    \n    fragColor.rgb = fractal(c1);\n    fragColor.rgb += fractal(c2);\n    fragColor.rgb += fractal(c3);\n    fragColor.rgb += fractal(c4);\n    fragColor.rgb /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 613, 643, 643, 696], [698, 719, 776, 776, 926], [928, 928, 950, 972, 1659], [1661, 1661, 1718, 1718, 2289]]}
{"id": "wsX3DB", "name": "Line overlap ", "author": "anemolo", "description": "Idea from Thom Yorke - The Eraser. Might make something similar soon\n\nControls:\n1 => toggle to see singular lines\n2 => toggle to see masking funciton", "tags": ["lines"], "likes": 2, "viewed": 91, "published": "Public", "date": "1547371808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n// Props to FabriceNeyret2 for this antialiasing function :)\n#define S(v) smoothstep(0.,1.5*fwidth(v), v )\n\n// keyToggle Stolen from https://www.shadertoy.com/view/Xsl3zX :b\n// Don't know how it works, might have to look into it later.\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel0,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec3 color = vec3(0.0);\n\n    // To move the cross we move the space\n\n    // Add the shape on the foreground\n    // Add  0.1 + sin(u_time) * 0.2) to move displacement\n    // Add u_time to displament sin for x movement\n    float yDisplacement = sin(st.x * PI * 2. + PI* iTime *2.)*(0.1 + sin(iTime*2.+PI) * 0.05) ;\n    st.y -= yDisplacement;\n    float freq = 19.;\n    // front wave\n    vec3 frontWave = vec3(S(sin(st.y * PI * freq) * 0.5+0.5 -0.5));\n    color = frontWave;\n    // Initially this sin function is a screen long. And to move into place, we just move it by the frequency \n    // PI * 1./14. Allways multiplied by PI because that's what sin uses\n    float lines = min(freq, 5.);\n    // Hidden has to be before the reset because we need it with the displacement\n    float mask = S(sin(st.y * PI + PI * 1./freq * lines)*0.5+0.5-0.5);\n    // Multiply by mask to eliminate everything outside of the white part of the mask\n    color *= mask;\n    // Reset y displacement\n    // So it doesnt affect the backWave\n    st.y += yDisplacement;\n    \n    //  Fisrt part of mult is for the wave itself.\n    // Second part is for how strong the wave is.\n    float xDisplacement = sin(st.y * PI * 2. + iTime * PI *2.)*(0.1 + sin(iTime*2.) *0.);\n    // xDisplacement = 600.5;\n    st.x -= xDisplacement;\n    // u_time here moves x axis. But dont need it because we have xDisplacement\n\tvec3 backWave = vec3(S(sin(st.x * PI * freq) * 0.5+0.5- 0.5));\n    // Multiply by the reverse mask to only add that part of the wave\n\tcolor += backWave * (1. - mask);\n    // Keyboard controls\n    // Look at the different parts of this shader\n    if (keyToggle(49)) { \n        color = frontWave * smoothstep(-0.05,0.05,sin(iTime* 1.5)) + backWave * smoothstep(-0.05,0.05,sin(iTime *1.5 + PI));\n    }\n\tif (keyToggle(50)) color = vec3(mask);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsX3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 307, 335, 335, 408], [411, 411, 468, 518, 2441]]}
{"id": "wsX3Rj", "name": "Meta Pool Flag", "author": "caseymacneil", "description": "accidentally made this when messing around with my other shader https://www.shadertoy.com/view/wss3RS", "tags": ["2d", "noise", "random", "voroni"], "likes": 3, "viewed": 69, "published": "Public", "date": "1546825157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 value)\n{\n\treturn fract(sin(dot(value, vec2(23.1245,87.2980))) * 5387.58135649);\n}\n\nvec2 rand2d(vec2 value)\n{\n\treturn fract(sin(vec2(dot(value, vec2(23.1245,87.2980)), dot(value, vec2(127.5123,39.183)))) * 5387.58135649);\n}\n\nvec3 voroni(vec2 uv)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec3 col = (fuv).xyy;\n    float mdist = 1.;\n    vec2 p;\n    vec2 sp;\n    // get neighbour tiles\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 n = vec2(float(x),float(y));\n            \n            p = rand2d(iuv + n);\n            \n            // animate\n            p.y = 0.5 + 0.5*sin(iTime + 5.*p.y);\n            p.x = 0.5 + 0.5*cos(iTime + 5.*p.x);\n            \n            vec2 diff = n + p - fuv;\n            float dist = length(diff);\n            \n            // \n            \n            if(dist < mdist)\n            {\n            \tmdist = min(mdist,dist);\n                sp = p;\n            }\n        }\n    }\n    return vec3(round(mdist/mod(fuv.y,0.01)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 vFontSize = vec2(8.0, 15.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //scale\n    vec2 p = uv * (iResolution.xy / 100.0);\n    p += 1.0;\n    \n    vec3 col = voroni(p);\n    \n    // make pretty :)\n    col.r *= uv.x - 0.2;\n    col.g *= .8 * 1.-uv.x;\n    col = pow(col,vec3(4.2));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [99, 99, 124, 124, 238], [240, 240, 262, 262, 1041], [1043, 1043, 1100, 1100, 1446]]}
{"id": "wsX3Wj", "name": "Trippy Pattern", "author": "brentfred", "description": "Trippy Pattern based on the pseudocode from the Wallpaper algorithm from 'The New Turing Omnibus' Chapter 1.", "tags": ["pattern"], "likes": 2, "viewed": 80, "published": "Public", "date": "1547508600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float side = 70.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Algorithm from 'The New Turing Omnibus' Ch 1 Wallpaper.\n\tvec2 p = vec2(iTime/100.0) + fragCoord*(side/100.0);\n    float c = round(dot(p, p));\n    \n    fragColor = (mod(c, 2.0) > 0.0001) ? vec4(0.0) : vec4(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsX3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 145, 302]]}
{"id": "WsX3zX", "name": "Warping Marble", "author": "Elyxian", "description": "A simple experiment with raytracing. The distance field is a union between a sphere and a perlin noise field moving towards the camera. The mouse can be used to rotate the camera.", "tags": ["raytracing", "perlin"], "likes": 6, "viewed": 215, "published": "Public", "date": "1546948283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Returns the matrix that rotates a given point by 'a' radians\n\nmat2 mm2(in float a) {\n    \n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n\n}\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// 3D Perlin Noise Implementation\n\nvec3 fade3(vec3 t) {\n\treturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nvec3 getGradient3D(vec3 p) {\n\treturn normalize(-1.0 + 2.0 * hash33(p));\n}\n\nfloat perlin3D(vec3 p) {\n\t\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = fade3(f);\n    \n    float value000 = dot(getGradient3D(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat value100 = dot(getGradient3D(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat value010 = dot(getGradient3D(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat value110 = dot(getGradient3D(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat value001 = dot(getGradient3D(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat value101 = dot(getGradient3D(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat value011 = dot(getGradient3D(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat value111 = dot(getGradient3D(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\treturn mix(\n\t\tmix(\n\t\t\tmix(value000, value100, u.x),\n\t\t\tmix(value010, value110, u.x),\n\t\t\tu.y),\n\t\tmix(\n\t\t\tmix(value001, value101, u.x),\n\t\t\tmix(value011, value111, u.x),\n\t\t\tu.y),\n\t\tu.z);\n\n}\n\n// The distance field\nfloat map(vec3 pos) {\n    \n    vec3 offset = vec3(1.5, 0.0, iTime);\n    float noise1 = 0.05 * perlin3D(10.0 * pos + offset);\n    float noise2 = length(pos) - 1.0;\n        \n    return max(noise1, noise2);\n    \n    // Iq style smooth union (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n    //float k = 0.05;\n    //float h = clamp(0.5 - 0.5*(noise2-noise1)/k, 0.0, 1.0);\n    //return mix(noise2, noise1, h) + k*h*(1.0-h);\n    \n}\n\n\n// The colour at a given position\nvec3 getBaseCol(vec3 pos) {\n    return vec3(1.0, 1.0, 1.0) * (0.5 + 0.5 * sin(length(pos * 10.0)));\n}\n\n// Determines the output colour of the surface at a given position using simple normal-based lighting\nvec3 renderSurface(vec3 pos) {\n\t\n    vec2 eps = vec2(0.00, 0.01);\n    \n    float ambientIntensity = 0.1;\n    vec3 lightDir = normalize(vec3(sin(iTime * 0.3), -0.3, 0.2));\n    \n    vec3 normal = normalize(vec3(\n    \tmap(pos + eps.yxx) - map(pos - eps.yxx),\n\t\tmap(pos + eps.xyx) - map(pos - eps.xyx),\n\t\tmap(pos + eps.xxy) - map(pos - eps.xxy)\n    ));\n    \n    vec3 baseColor = getBaseCol(pos);\n    \n    float diffuse = ambientIntensity + max(dot(-lightDir, normal), 0.0);\n    return baseColor * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ps = uv - 0.5;\n    ps.x *= iResolution.x/iResolution.y;\n    \n    // Gets the direction of the ray and the origin\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(ps, 0.7));\n\t\n    // Rotates the ray depending on the mouse position. I lifted this from\n    // https://www.shadertoy.com/view/XtGGRt, but it seems to be the common approach\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0,0.0):mo; // Default position of camera\n    mo.x *= iResolution.x/iResolution.y;\n    mo *= 3.0;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x);\n    \n    // Raymarch\n    float t = 0.0;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float eps = 0.001;\n    int iterations = 60;\n    \n    for (int i = 0; i < iterations; i++) {\n    \t\n       \tvec3 ps = ro + t * rd;\n        float d = abs(map(ps));\n        \n        if (d < eps) {\n            col = renderSurface(ps);\n            break;\n        }\n        \n        t += d;\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsX3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 87, 87, 169], [171, 245, 267, 267, 398], [400, 435, 455, 455, 494], [496, 496, 524, 524, 569], [571, 571, 595, 595, 1567], [1569, 1591, 1612, 1612, 2044], [2047, 2081, 2108, 2108, 2182], [2184, 2286, 2316, 2316, 2789], [2791, 2791, 2848, 2885, 3951]]}
{"id": "WsXGD2", "name": "Jellyfishy", "author": "pthextract", "description": "Shaping the ball", "tags": ["ballshape"], "likes": 5, "viewed": 154, "published": "Public", "date": "1547501630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 6.2832\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec2 r=iResolution.xy;\n    i/=r;i-=.5;i.x*=r.x/r.y;\n   o-=o;\n\n    float my=0.;float x,xx,z,yf;\n    vec2 pos;vec3 o3d ;\n    vec3 p3d;\n\n    for (float y=0.001;y<31.;y+=mod(floor(iTime/6.),10.)+1.)\n    {  my=y;\n     x=0.;\n    if (y>18.)my=18.;\n      if (y>18.1)x=pi/36.;\n     if (y>24.1)x=0.;\n     \n    for (;x<pi-.01;x+=pi/my)\n    {\n       \n      xx=mod(x+.3*cos(iTime),pi);\n        //x=xx;\n    z=(pi/360.)*y*(1.5+cos(2.*iTime));\n    yf=cos(z);\n     z=.5*sin(z);\n     o3d=vec3(0,0,2.1+.5*cos(2.*iTime));\n        \n   \n    pos=.05*yf*y*vec2(cos(xx),sin(xx));\n    p3d=vec3(pos,z); \n    p3d+=o3d;\n    p3d.x+=cos(iTime);\n    p3d.y+=.2*sin(pi/2.+iTime*2.);\n       \n    p3d.xy/=p3d.z;\n                 \n    o+=vec4((.001/((p3d.z-1.2)*1.))/length(i-p3d.xy));\n    }}\n    o.b+=.2;   \n    o.r-=.4;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 60, 60, 851]]}
{"id": "wsXGDf", "name": "Triangle Interpolation Algos", "author": "antl", "description": "This is a shader that implements different triangle interpolation variants.\nThe list is not exhaustive.\n\nThese algorithms are intentionally not optimized in order to remain close to their underlying reasonings.", "tags": ["triangle", "intersection", "interpolation", "algorithm"], "likes": 10, "viewed": 174, "published": "Public", "date": "1547647899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 1 :\n// 1) For each segment, check if the point is on the right or left side.\n// 2) If the point is on the same side for all the segments, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 edgeSide(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    vec3 N_AB = cross(B-A, N); // Normal to AB vector\n    vec3 N_BC = cross(C-B, N); // Normal to BC vector\n    vec3 N_CA = cross(A-C, N); // Normal to CA vector\n    \n    float dir_N_AB = dot(I-A, N_AB);\n    float dir_N_BC = dot(I-B, N_BC);\n    float dir_N_CA = dot(I-C, N_CA);\n    \n    bool all_positive = (dir_N_AB >= 0.0) && (dir_N_BC >= 0.0) && (dir_N_CA >= 0.0);\n    bool all_negative = (dir_N_AB <= 0.0) && (dir_N_BC <= 0.0) && (dir_N_CA <= 0.0);\n    isIn = all_positive || all_negative;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = dot(I-B, N_BC); // Orthogonal distance from I to BC\n        float b = dot(I-C, N_CA); // Orthogonal distance from I to CA\n        float c = dot(I-A, N_AB); // Orthogonal distance from I to AB\n        \n        float sum = a+b+c;\n        a /= sum;\n        b /= sum;\n        c /= sum;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 2 :\n// 1) Form 4 triangles from your point I : AIB, BIC, CIA and ABC.\n// 2) Compute the areas. [formula: area(XYZ)=0.5*length(cross(Y-X,Z-X))]\n// 2) If area(AIB)+area(BIC)+area(CIA)=area(ABC), the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 areas(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float areaAIB = 0.5*length(cross(I-A, B-A));\n    float areaBIC = 0.5*length(cross(I-B, C-B));\n    float areaCIA = 0.5*length(cross(I-C, A-C));\n    float areaABC = 0.5*length(cross(B-A, C-A));\n    \n    isIn = abs((areaAIB+areaBIC+areaCIA)-areaABC) < 0.001;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = areaBIC/areaABC;\n        float b = areaCIA/areaABC;\n        float c = areaAIB/areaABC;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 3 :\n// 1) Form 3 triangles from your point I : AIB, BIC and CIA.\n// 2) Compute the signed areas. [formula: signedArea(XYZ)=dot(0.5*(cross(Y-X,Z-X)),N), with N the triangle's normal]\n// 2) If the signs are all the same, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 areasSigned(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float signedAreaAIB = dot(0.5*(cross(I-A, B-A)),N);\n    float signedAreaBIC = dot(0.5*(cross(I-B, C-B)),N);\n    float signedAreaCIA = dot(0.5*(cross(I-C, A-C)),N);\n    \n    bool all_positive = (signedAreaAIB >= 0.0) && (signedAreaBIC >= 0.0) && (signedAreaCIA >= 0.0);\n    bool all_negative = (signedAreaAIB <= 0.0) && (signedAreaBIC <= 0.0) && (signedAreaCIA <= 0.0);\n    isIn = all_positive || all_negative;\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float areaABC = 0.5*length(cross(B-A, C-A));\n        \n        float a = abs(signedAreaBIC)/areaABC;\n        float b = abs(signedAreaCIA)/areaABC;\n        float c = abs(signedAreaAIB)/areaABC;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Method 4 :\n// 1) Rewrite the point, I, as (I-A)=u*(B-A)+v*(C-A). [which is also I=(1-u-v)*A+u*B+v*C, barycentric coordinates]\n// 2) Compute u and v. [to get u, first cross product the equation with (C-A), then project along the face normal N; then similarly to get v]\n// 2) If u and v are in [0,1] and u+v<=1, the point is inside the triangle.\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 uvCoord(in vec3 A, in vec3 B, in vec3 C, in vec3 I, inout bool isIn)\n{\n    vec3 col;\n    isIn = false;\n    \n    vec3 N = normalize(cross(B-A, C-A));\n    \n    // Check if the point is in the triangle /////////////////////////////////////////\n    float u = dot(cross(I-A,C-A),N)/dot(cross(B-A,C-A),N);\n    float v = dot(cross(I-A,B-A),N)/dot(cross(C-A,B-A),N);\n    \n    isIn = (u >= 0.0) && (v >= 0.0) && (u+v <= 1.0);\n    \n    // Color interpolation ///////////////////////////////////////////////////////////\n    if (isIn)\n    {\n        float a = 1.0-u-v;\n        float b = u;\n        float c = v;\n        \n     \tcol = vec3(a,b,c);\n    }\n    \n\treturn col;\n}\n\n\n\n\n\n\n\n\n\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// //////////////////////////////////////////////////////////////////////////////////////////////////////\n// Help functions, for text and drawing /////////////////////////////////////////////////////////////////\n#define C(c) U.x-=0.5; T += (U.x<0.0||U.x>1.0||U.y<0.0||U.y>1.0) ? vec4(0) : textureGrad(iChannel3, U/16.0 + fract(vec2(c, 15-c/16)/16.0), dFdx(U/16.0), dFdy(U/16.0))\n#define initMsg vec4 T = vec4(0); U.x+=0.5;\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\n// Write \"Edge Side\"\nfloat string_Method1(vec2 U) {\n    initMsg;\n    C(69);C(100);C(103);C(101);\n    C(32);\n    C(83);C(105);C(100);C(101);\n    endMsg;\n}\n\n// Write \"Areas\"\nfloat string_Method2(vec2 U) {\n    initMsg;\n    C(65);C(114);C(101);C(97);C(115);\n    endMsg;\n}\n\n// Write \"Signed Areas\"\nfloat string_Method3(vec2 U) {\n    initMsg;\n    C(83);C(105);C(103);C(110);C(101);C(100);\n    C(32);\n    C(65);C(114);C(101);C(97);C(115);\n    endMsg;\n}\n\n// Write \"Barycentric UV Coordinates\"\nfloat string_Method4(vec2 U) {\n    initMsg;\n    C(66);C(97);C(114);C(121);C(99);C(101);C(110);C(116);C(114);C(105);C(99);\n    C(32);\n    C(85);C(86);\n    C(32);\n    C(67);C(111);C(111);C(114);C(100);C(105);C(110);C(97);C(116);C(101);C(115);\n    endMsg;\n}\n\n// Write \"A\"\nfloat string_A(vec2 U) {\n    initMsg;\n    C(65);\n    endMsg;\n}\n\n// Write \"B\"\nfloat string_B(vec2 U) {\n    initMsg;\n    C(66);\n    endMsg;\n}\n\n// Write \"C\"\nfloat string_C(vec2 U) {\n    initMsg;\n    C(67);\n    endMsg;\n}\n\n// Draw a point\nvec3 drawPoint(in vec3 X, in vec3 I, in float radius, in vec3 color)\n{\n    if (length(I-X) <= radius)\n    {\n        if (int(floor(length(I-X)/radius*3.0))%2 == 0)\n        {\n        \treturn color;\n        }\n    }\n\treturn vec3(0.0);\n}\n\n\n\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 I = vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y*1.5, 1.0);\n    \n    // Triangle definition\n    float m = 0.5;\n\tvec3 A = vec3(cos(iTime*m + vec2(0.0,2.00) + 0.0), 1.0);\n    vec3 B = vec3(cos(iTime*m + vec2(0.0,1.50) + 1.5), 1.0);\n\tvec3 C = vec3(cos(iTime*m + vec2(0.0,3.00) + 4.0), 1.0);\n    \n    // Mouse manipulation\n    if (iMouse.z>=1.0)\n    {\n        vec3 Click = vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y*1.5, 1.0);\n        A = Click;\n    }\n    \n    // Interpolation in the triangle, according to a given method\n    float method = mod(floor(iTime/5.0), 4.0)+1.0;\n    bool isIn;\n    vec3 col;\n    if (method==1.0)\n    {\n    \tcol = edgeSide(A,B,C,I,isIn);\n        col = max(col,string_Method1(fragCoord.xy*0.02));\n    }\n    else if (method==2.0)\n    {\n    \tcol = areas(A,B,C,I,isIn);\n        col = max(col,string_Method2(fragCoord.xy*0.02));\n    }\n    else if (method==3.0)\n    {\n    \tcol = areasSigned(A,B,C,I,isIn);\n        col = max(col,string_Method3(fragCoord.xy*0.02));\n    }\n    else if (method==4.0)\n    {\n    \tcol = uvCoord(A,B,C,I,isIn);\n        col = max(col,string_Method4(fragCoord.xy*0.02));\n    }\n\n    // Draw the vertices\n    if (!isIn)\n    {\n        col = max(col,drawPoint(A,I,0.07,vec3(1.0,0.0,0.0)));\n    \tcol = max(col,drawPoint(B,I,0.07,vec3(0.0,1.0,0.0)));\n    \tcol = max(col,drawPoint(C,I,0.07,vec3(0.0,0.0,1.0)));\n    }\n    \n    // Draw the labels\n    vec3 pA = A+0.2*normalize(normalize(A-B)+normalize(A-C));\n    vec3 pB = B+0.2*normalize(normalize(B-C)+normalize(B-A));\n    vec3 pC = C+0.2*normalize(normalize(C-A)+normalize(C-B));\n    \n    col = max(col,vec3(string_A((I.xy-pA.xy)*5.0+0.5),0.0,0.0));\n    col = max(col,vec3(0.0,string_B((I.xy-pB.xy)*5.0+0.5),0.0));\n    col = max(col,vec3(0.0,0.0,string_C((I.xy-pC.xy)*5.0+0.5)));\n\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 606, 682, 682, 1818], [1820, 2481, 2554, 2554, 3261], [3263, 3950, 4029, 4029, 4985], [4987, 5758, 5833, 5833, 6420], [7011, 7032, 7062, 7062, 7164], [7166, 7183, 7213, 7213, 7278], [7280, 7304, 7334, 7334, 7456], [7458, 7496, 7526, 7526, 7750], [7752, 7765, 7789, 7789, 7827], [7829, 7842, 7866, 7866, 7904], [7906, 7919, 7943, 7943, 7981], [7983, 7999, 8069, 8069, 8231], [8242, 8242, 8298, 8298, 10124]]}
{"id": "wsXGDs", "name": "fractal test 2D", "author": "gaz", "description": "2d", "tags": ["2d", "fractal"], "likes": 4, "viewed": 331, "published": "Public", "date": "1547784186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XlfGRj\n\n#define param 0.63\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p *= 4.0;\n\tp = mod(p,4.0)-2.0;\n    //p = abs(p);\n    \n     \n    for(int i=0; i<4; i++)\n    {\n        // the magic formula by Kali.\n    \tp = abs(p)/dot(p,p)-param; \n        //p = pow(abs(p), vec2(sin(iTime*0.5)*0.2+1.1))/dot(p,p)-param; \n    \tp *= 2.0;\n    }\n    p /= 2.0;\n    \n    float de = abs(dot(p,vec2(cos(iTime),sin(iTime))));\n \tfragColor = vec4(vec3(de),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 119, 119, 554]]}
{"id": "wsXGW4", "name": "panspermia", "author": "morisil", "description": "I am progressing in not so intelligent design of my artificial life forms, originally designed here https://www.desmos.com/calculator/nicecpjqpq", "tags": ["experiment", "organic", "weird", "polar", "movement", "bio"], "likes": 0, "viewed": 226, "published": "Public API", "date": "1547334496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = acos(-1.);\n\nconst float SCALE = 2.;\n\nconst float SPEED = .5;\n\nconst float SEGMENT_SMOOTHING = .05;\n\nconst float THINNESS = 6.;\n\nconst float SEGMENTS = 20.;\n\nconst float SEGMENT_FLUCTUATION = 4.;\n\nconst float SEGMENT_FLUCTUATOIN_SPEED = 1.;\n\nvoid mainImage(\n    out vec4 fragColor,\n    in vec2 fragCoord\n) {\n    vec2 pixel = vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float r = length(pixel) * SCALE;  // radius\n    float a = atan(pixel.y, pixel.x); // angle\n    \n    float segmentFactor = PI / (\n        SEGMENTS\n        + sin(iTime * SEGMENT_FLUCTUATOIN_SPEED)\n        * SEGMENT_FLUCTUATION\n    );\n    float segmentComponent = mod(sin(a), segmentFactor);\n    float f =\n        (1. - (sin(a) * sin(a - iTime * SPEED) * sin(a + iTime * SPEED)))\n        *\n        (1. /\n         \tsqrt(\n            \t(sin(a) * sin(a))\n            \t+ (THINNESS * cos(a) * cos(a))\n        \t)\n        )\n        + .3 * sin(a)\n        + segmentComponent\n          * smoothstep(\n              segmentFactor,\n              segmentFactor - SEGMENT_SMOOTHING,\n              segmentComponent\n          )  \n          * 0.5;\n    \n    float bodyIntensity = pow(r / f, 5.);\n\tfragColor = vec4(\n        1. - (1.0 - smoothstep(f, f + 0.03, r)) * bodyIntensity,\n        1. - (1.1 - smoothstep(f, f + 0.02, r)) * bodyIntensity,\n        1. - (1.2 - smoothstep(f, f + 0.01, r)) * bodyIntensity,\n        1.\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 323, 323, 1415]]}
{"id": "wsXGWX", "name": "Ray Marching - 002", "author": "catafest", "description": "code from https://www.youtube.com/watch?v=Ff0jJyyiVyw", "tags": ["raymarching", "shader"], "likes": 2, "viewed": 484, "published": "Public API", "date": "1547611757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat add_Capsule(vec3 p,vec3 a,vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot( ab, ap ) / dot( ab, ab);\n    t = clamp (t,0.,1.);\n    vec3 c = a +t*ab;\n    float d = length(p -c) - r ;\n    return d;\n\n}\n\nfloat add_Torus(vec3 p,vec2 r){\n\tfloat x = length (p.xz) -r.x;\n    return length(vec2(x, p.y)) - r.y;\n\n}\n\nfloat add_Box(vec3 p, vec3 s){\n\n\treturn length(max(abs(p)-s,0.));\n}\n\n\nfloat add_Cylinder(vec3 p,vec3 a,vec3 b, float r){\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot( ab, ap ) / dot( ab, ab);\n    //t = clamp (t,0.,1.);\n    vec3 c = a +t*ab;\n    float x = length(p -c) - r ;\n    float y = (abs(t - 0.5) - 0.5)*length(ab);\n    float e = length(max(vec2 (x,y), 0.0));\n    // fix the shape with interior smooth\n    float i = min(max(x,y), 0.0);\n    return e+i;\n}\n\nfloat GetDist(vec3 p){\n\tvec4 s = vec4(0, 1, 6, 1);\n    float sphereDist = length (p - s.xyz)-s.w;\n    float planeDist = p.y;\n    // capsule distance\n    float cd = add_Capsule (p, vec3(0,1,3), vec3(0,2,3), 0.2);\n    float td = add_Torus(p - vec3(0,0.5,4), vec2(1, 0.2));\n    float bd = add_Box(p - vec3(-2,.5,6), vec3(.5));\n    float cyld = add_Cylinder (p, vec3(1.5,0.3,3), vec3(3,0.3,5), 0.2);\n    // add capsule object \n    float d = min (cd, planeDist);\n    // add torus object \n    d = min(d, td);\n    // add box object \n    d = min(d, bd);\n    // add cylinder object\n    d = min(d, cyld);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i=0; i< MAX_STEPS; i++){\n        vec3 p = ro +rd*dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if (dO>MAX_DIST || ds<SURF_DIST) break;\n        }\n    return dO; \n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    //\n    vec3 n = d - vec3(\n       //p -vec3(.01,0,0) GLSL is that the properties can be combined in any order you want,\n       //which makes it easy to cast and mix values and is called swizzle.\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (0, 5, 6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if (d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates to 0 with a resolution of 5 \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t// Set color to black\n    vec3 col = vec3(0);\n    // position of camera 1.4\n    vec3 ro = vec3(0, 1.7, 0);\n    // position of camera uv.y - .18\n    vec3 rd = normalize(vec3 (uv.x, uv.y - .18, 1));\n\n    float d = RayMarch(ro,rd);\n    // set point light long d \n    vec3 p = ro + rd * d;\n    // dif is difuse\n    float dif = GetLight(p);\n        \n    //d/=6.;\n    //col = vec3(d);\n    col = vec3 (dif);\n    \n    // Send output to color named col to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 116, 116, 295], [297, 297, 328, 328, 401], [403, 403, 433, 433, 470], [473, 473, 523, 523, 869], [871, 871, 893, 893, 1481], [1483, 1483, 1516, 1516, 1726], [1728, 1728, 1751, 1751, 2110], [2112, 2112, 2135, 2135, 2428], [2430, 2430, 2487, 2552, 3099]]}
{"id": "WsXGz2", "name": "2D SDF Render", "author": "caseymacneil", "description": "Made using https://www.shadertoy.com/view/4lKyDD as a reference to better my understanding on SDF's", "tags": ["2d", "raymarching", "sdf"], "likes": 4, "viewed": 225, "published": "Public", "date": "1546812900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat border(vec2 p)\n{\n    vec2 R = iResolution.xy;\n\treturn min(p.x,min(p.y,min(R.x-p.x,R.y-p.y)));\n}\n\nfloat map(vec2 p)\n{\n\treturn min(min(sdCircle(( iResolution.xy/2.) + vec2(200.,200.) - p,50.0),border(p)), sdCircle(( iResolution.xy/2.) + vec2(-100.,-100.) - p,20.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sp = fragCoord;\n\tvec3 col = vec3(0.0);\n\t\n    vec2 ro = iResolution.xy/2.;\n    \n    vec2 rd = vec2(cos(iTime * .1),sin(iTime * .1));\n    // mouse input\n    rd = iMouse.z < .001 ? rd : normalize(iMouse.xy - ro);\n    \n    // position on the ray\n    vec2 pos = ro;\n    \n    float t = 5.0;\n    \n    int i;\n    for(i=0; i < 60 && t > 0.1;i++)\n    {\n    \tvec2 pPos = pos;\n        float pT = t;\n        \n        pos = pos + t*rd;\n        \n        t = map(pos);\n        \n        // current ray circle distance\n        float rcd = sdCircle(sp-pPos,pT);\n        \n        col = mix(vec3(1.0),col,smoothstep(rcd,0.,2.));\n        col = mix(vec3(1.0),col,smoothstep(-rcd,-2.,0.));\n        \n        // draw center\n        float dist = sdCircle(sp-pPos,5.0);\n        col = mix(vec3(1.0,0.,0.),col,smoothstep(dist,0.,2.));\n        col = mix(vec3(1.0,0.,0.),col,smoothstep(-dist,-2.,0.));\n        \n        // hard lines\n        //col = round(col);\n    }\n    \n    \n    col = mix(vec3(0.,0.,1.),col,smoothstep(map(sp),0.,2.));\n    col = mix(vec3(0.,0.,1.),col,smoothstep(-map(sp),-2.,0.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 58], [60, 60, 82, 82, 161], [163, 163, 182, 182, 332], [334, 334, 391, 391, 1531]]}
{"id": "WsXGzj", "name": "double vs single precision", "author": "JoshScholar", "description": " jesosk's simple-mandelbrot with a double precision library plugged in.  Single precision on the bottom. \n\nNote, the weird coding with the use of mix was to keep overly zealous compilers from optimizing the operations into orders which lose precision. ", "tags": ["math", "mandelbrot"], "likes": 3, "viewed": 521, "published": "Public", "date": "1546795570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n\t//\n\t// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n\t// Substract: res = ds_add(a, b) => res = a + b\nfloat times_frc(float a, float b) {\n  return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat plus_frc(float a, float b) {\n  return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat minus_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\n// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)\n//\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n// Substract: res = ds_add(a, b) => res = a + b\nvec2 add (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = plus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Substract: res = ds_sub(a, b) => res = a - b\nvec2 sub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = minus_frc(dsa.x, dsb.x);\n  e = minus_frc(t1, dsa.x);\n  t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat cmp(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 mul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = times_frc(dsa.x, split);\n  conb = times_frc(dsb.x, split);\n  a1 = minus_frc(cona, minus_frc(cona, dsa.x));\n  b1 = minus_frc(conb, minus_frc(conb, dsb.x));\n  a2 = minus_frc(dsa.x, a1);\n  b2 = minus_frc(dsb.x, b1);\n\n  c11 = times_frc(dsa.x, dsb.x);\n  c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));\n\n  c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));\n\n  t1 = plus_frc(c11, c2);\n  e = minus_frc(t1, c11);\n  t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);\n\n  dsc.x = plus_frc(t1, t2);\n  dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));\n\n  return dsc;\n}\n\n// create double-single number from float\nvec2 set(float a) {\n  return vec2(a, 0.0);\n}\n\nfloat rand(vec2 co) {\n  // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 complexMul(vec2 a, vec2 b) {\n  return vec2(a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\n// double complex multiplication\nvec4 dcMul(vec4 a, vec4 b) {\n  return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));\n}\n\nvec4 dcAdd(vec4 a, vec4 b) {\n  return vec4(add(a.xy,b.xy),add(a.zw,b.zw));\n}\n\n// Length of double complex\nvec2 dcLength(vec4 a) {\n  return add(mul(a.xy,a.xy),mul(a.zw,a.zw));\n}\n\nvec4 dcSet(vec2 a) {\n  return vec4(a.x,0.,a.y,0.);\n}\n\nvec4 dcSet(vec2 a, vec2 ad) {\n  return vec4(a.x, ad.x,a.y,ad.y);\n}\n\n// Multiply double-complex with double\nvec4 dcMul(vec4 a, vec2 b) {\n  return vec4(mul(a.xy,b),mul(a.wz,b));\n}\n\n\tvec4 dcSub(vec4 a, vec4 b) {\n\t\treturn vec4(sub(a.xy,b.xy),sub(a.zw,b.zw));\n\t}\n\t\n\t\nfloat PI = 3.14159265358979323846264;\n\nfloat scale = 2.0;\n//known deep coord\n//-1.74995768370609350360221450607069970727110579726252077930242837820286008082972804887218672784431700831100544507655659531379747541999999995\n//0.00000000000000000278793706563379402178294753790944364927085054500163081379043930650189386849765202169477470552201325772332454726999999995\n// -1.401,155,189,098,919,8\n\n//Hmm this way of breaking up numbers isn't really right\n//Needs a string to double representation routine\nvec4 offset = vec4(-1.749958,1e-6 - 6.837060935e-7, 2.787937e-18,0.65633794e-24);\n//vec4 offset = vec4(-1.4011551,8.90989198e-8, 0.0,0.0);\n\nconst int max_iterations = 1500;\nconst int max_colors = 50;\nconst float color_scale = 2.0;\nconst float inverse_max_colors = 1.0 / float(max_colors);\n\nconst int P = 2;\nconst float threshold = 200000.0;\n\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n\nvec4 color_ramp(int i) {\n    // Running the index through cos creates a continous ramp.\n    float normalized_mod = mod(float(i), float(max_colors)) * inverse_max_colors;\n\tfloat normalized_cos = (cos(normalized_mod * 2.0 * PI) + 1.0) * 0.5;\n    i = int(float(max_colors) * normalized_cos);\n\n    float factor = float(i) / float(max_colors);\n    float inverse_factor = 1.0 - factor;\n    // An arbritrary ramp of colors\n    return vec4(sqrt(sqrt(factor)), factor, inverse_factor * 0.5, 1.0);\n}\n\nvec4 color_from_ramp(int i, float f) {\n\tvec4 first = color_ramp(i);\n\tvec4 second = color_ramp(i + 1);\n    return first * (1.0 - f) + second * f;\n}\n\nvec4 color_from_iteration(vec4 z, int i) {\n    // Continuous coloring\n    vec2 len=dcLength(z);\n    float s = float(i) + log2(log(threshold)) - log2(log(len.x+len.y));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\nvec4 single_color_from_iteration(vec2 z, int i) {\n    // Continuous coloring\n    float s = float(i) + log2(log(threshold)) - log2(log(length(z)));\n    s *= color_scale;\n    int first = int(floor(s));\n    return color_from_ramp(first, s - float(first));\n}\n\nvec3 single_fractal(vec2 fragCoord)\n{\n\tvec2 c = vec2(\n        (fragCoord.x / iResolution.x) * 3.5 - 2.5,\n        (fragCoord.y / iResolution.y) * 2.0 - 1.0\n    );\n\n    c *= (scale / exp(iTime * 0.2));\n    c += vec2(offset.x,offset.z);\n\n    vec2 z = vec2(0.0, 0.0);\n    int final_i;\n    for (int i = 0; i < max_iterations; i++) {\n        final_i = i;\n\n        if (length(z) >= threshold) {\n            break;\n        }\n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = cx_mul(z, z) + c;\n    }\n\n\treturn single_color_from_iteration(z, final_i).rgb;\n}\nvec3 double_fractal( vec2 fragCoord)\n{\n    vec2 Threshold = set(threshold);\n    float scaletemp= (scale / exp(iTime * 0.2));\n\tvec4 c = vec4(\n        set((fragCoord.x / iResolution.x) * 3.5*scaletemp),\n        set((fragCoord.y / iResolution.y) * 2.0*scaletemp)\n    );\n\n    c = dcSub(dcAdd(c,offset),vec4(set(2.5*scaletemp),set(scaletemp)));\n\n\n    vec4 z = vec4(0.0, 0.0, 0.0, 0.0);\n    int final_i;\n    for (int i = 0; i < max_iterations; i++) {\n        final_i = i;\n\n        if (cmp(dcLength(z), Threshold)>0.) { break; } \n\n        // z^P + c, P = 2  gives us  z^2 + c\n        z = dcAdd(dcMul(z, z), c);\n    }\n\n\treturn color_from_iteration(z, final_i).rgb;\n}\nvec3 fractal( vec2 fragCoord)\n{\n    if (fragCoord.y<iResolution.y*.5) return single_fractal(fragCoord);\n    return double_fractal(fragCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfragColor.rgb  = fractal( fragCoord + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 244, 279, 279, 329], [331, 331, 365, 365, 413], [415, 415, 450, 450, 498], [500, 740, 771, 771, 1061], [1063, 1111, 1142, 1142, 1451], [1453, 1542, 1573, 1573, 1758], [1760, 1807, 1838, 1838, 2654], [2656, 2698, 2717, 2717, 2742], [2744, 2744, 2765, 2839, 2909], [2911, 2911, 2944, 2944, 3001], [3003, 3036, 3064, 3064, 3152], [3154, 3154, 3182, 3182, 3230], [3232, 3260, 3283, 3283, 3330], [3332, 3332, 3352, 3352, 3384], [3386, 3386, 3415, 3415, 3452], [3454, 3493, 3521, 3521, 3563], [3566, 3566, 3594, 3594, 3643], [4228, 4550, 4574, 4637, 5039], [5041, 5041, 5079, 5079, 5187], [5189, 5189, 5231, 5258, 5464], [5466, 5466, 5515, 5542, 5720], [5722, 5722, 5759, 5759, 6276], [6277, 6277, 6315, 6315, 6935], [6936, 6936, 6967, 6967, 7079], [7082, 7082, 7139, 7139, 7378]]}
{"id": "XsjBRm", "name": "Candle Doodle", "author": "BigWIngs", "description": "Candle flames seem to be all the rage lately. I had this candle doodle lying around from the shadertoy compo two years ago. Code is a mess but I thought it'd make a nice addition to all the flames we are seeing lately.", "tags": ["flame", "candle"], "likes": 67, "viewed": 3100, "published": "Public", "date": "1547047095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Candle by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Code is horrible. This was used as a scratchpad for this effect:\n// https://www.shadertoy.com/view/MsSBD1\n//\n// Use these to change the effect\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 10.\n#define RAY_PRECISION 0.01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n#define CANDLE_HEIGHT 10.\n#define FLAMECOL vec3(.99, .6, .35)\n#define FLAMEBLUE vec3(.1, .1, 1.)\n#define CANDLECOL  vec3(.2, .5, .2)\n\n#define BG_STEPS 20.\n#define BOKEH_SIZE .04\n\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 m; // mouse\n\nvec3 bg; // global background color\n\nfloat N( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N(x + y*23414.324); }\nfloat LN(float x) {return mix(N(floor(x)), N(floor(x+1.)), fract(x));}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\n\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float b;\t// bump\n    float m; \t// material\n    float f;\t// flame\n    float w;\t// distance to wick\n    float fd;\t// distance to flame\n    float t;\n    float s; // closest flame pass\n    float sd;\n    vec2 uv;\n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return sat(t-a)/(b-a); }\nfloat remap(float a, float b, float c, float d, float t) { return sat((b-a)/(t-a)) * (d-c) +c; }\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/rect.zw;\n}\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nvec2 smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\n\nvec2 smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn vec2(mix( a, b, h ) + k*h*(1.0-h), h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opCheapBend( vec3 p, float strength )\n{\n    float c = cos(strength*p.y);\n    float s = sin(strength*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\nfloat CB_Dist(rc q, vec3 rd) {\t\t\t\t\t\t// returns the distance, along the ray, to the next cell boundary\n\t vec3 rC = ((2.*step(0., rd)-1.)*q.h-q.p)/rd;\t// ray to cell boundary\n     return min(min(rC.x, rC.y), rC.z)+.01;\t\t\t// distance to cell just past boundary\n}\n\nvec3 background(vec3 r) {\n\tfloat x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = vec3(0.);\n    \n    return col;\n}\n\n// From http://mercury.sexy/hg_sdf\nvec3 pModPolar(inout vec3 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.z, p.x) + angle/2.;\n\tfloat r = length(p.xz);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec3(cos(a)*r, p.y, sin(a)*r);\n\n\treturn p;\n}\n\nde map( vec3 p ) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    de o;\n    o.m = 1.;\n    \n    float t = iTime;\n    \n    \n    p.y += (sin(p.x*10.)*sin(p.y*12.))*.01;\n   \tfloat outside = sdCappedCylinder(p+vec3(0., 2., 0.), vec2(.75, 2.))-.1;\n    float inside = sdCappedCylinder(p-vec3(0., 2., 0.), vec2(.45, 2.))-.3;\n    \n    vec2 candle = smax(outside, -inside, .1);\n    \n    vec3 q = p+vec3(0., .15, 0.);\n    q = opCheapBend(q+vec3(0., 0.2, 0.)*0., 1.);\n    \n    float angle = atan(q.x, q.z);\n    \n    q.xz *= 1.-abs(sin(angle*twopi+q.y*40.))*.02*S(.1, .2, q.y);\n    q.xz *= 1.-S(.2, .0, q.y)*.2;\n    float wick = sdCappedCylinder(q+vec3(0., 0.1, 0.), vec2(.01, .7))-.05;\n    \n    vec2 d = smin(candle.x, wick, .2);\n    \n    o.uv = vec2(angle, q.y);\n    o.t = d.y;\n    o.d = d.x*.8;\n    o.w = wick;\n    \n    return o;\n}\n\nde fmap( vec3 p, float n ) {\n    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id\n    float t = iTime*2.;\n    \n    de o;\n    o.m = 1.;\n    \n    p.z *= 1.5;\n    \n    float spikes = pow(abs(sin(p.x*50.+t*2.)), 5.);\n    spikes *= pow(abs(sin(p.x*-30.+t*1.)), 5.);\n    p.y += spikes*.1*S(1.5, 3., p.y);\n    \n    \n    vec3 q = opCheapBend(p+vec3(0., 0.2, 0.), 1.);\n    \n    float wick = sdCappedCylinder(q+vec3(0., 0.1, 0.), vec2(.01, .7))-.01;\n    float d = wick;\n    float flame = wick;\n    \n    float t2 = t*.2;\n    float top = 2.5-n*n;\n    for(float i=0.; i<1.; i+=1./20.) {\n        \n        float y = mix(.3, top, i);\n        float x = pow(abs(sin(y-t*2.)), 2.)*.1*n*p.y*n*n*n;\n        \n        float size = mix(.1, .05, i*i);\n        float smth = mix(.4, .1, i);\n    \tflame = smin(flame, sdSphere(p, vec3(x-.12, y, .0), size), smth).x;\n    }\n    \n    d = min(d, flame);\n    \n    d = max(d, -sdSphere(p, vec3(-.2, -.5, .0), .5)); \n    o.d = d/1.5;\n    \n    return o;\n    \n}\n\nde castRay( ray r, float n ) {\n    \n    float dmin = 1.0;\n    float dmax = 100.0;\n    \n\tfloat precis = RAY_PRECISION;\n    \n    de o;\n    o.d = dmin;\n    o.m = -1.0;\n    o.w = 1000.;\n    o.s = 1000.;\n    \n    de res;\n    \n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    \n        res = map( r.o+r.d*o.d );\n        if( res.d<precis || o.d>dmax ) break;\n        \n        float d = o.d;\n        float w = o.w;\n        o = res;\n        if(w<o.w) o.w = w;\n        \n        o.d += d;\n    }\n    \n    if( o.d>dmax ) o.m=-1.0;\n    o.s = 1000.;\n    o.fd = 0.;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    res = fmap( r.o+r.d*o.fd, n );\n        if( res.d<precis || o.fd>dmax ) break;\n        if(res.d<o.s) {\n            o.s = res.d;\n            o.sd = o.fd;\n        }\n        \n        o.fd += res.d;\n    }\n    \n    if(res.d<precis)\n        o.f=1.;\n    \n    return o;\n}\n\nvec3 Background(ray r) {\n    \n    float t = iTime;\n    \n\tfloat x = atan(r.d.x, r.d.z);\n    float y = dot(vec3(0,1,0), r.d);\n    \n    float d = 4.1;\n        \n    vec2 size = vec2(3);\n    vec2 h = size / 2.;\n    \n    float blur = .3;\n    \n    vec3 col = vec3(0);\n    \n    for(float i=0.; i<BG_STEPS; i++) {\n    \tvec3 p = r.o + r.d*d;\n    \t\t\t\t\t\t\n    \tvec2 id = floor(p.xz/size);\t\t\t\t\t\t\t\t// used to give a unique id to each cell\n   \t\t\n        vec3 q = p;\n        \n        q.xz = mod(p.xz, size)-h;\t\t\t\t\t\t\t\t// make grid of flames\n        \n        vec3 cP = vec3(0, N21(id)*4.-2., 0);\n        \n        float dRayFlame = DistLine(q, r.d, cP);\t\t\t\t\t\t// closest ray, point dist\n        \n        float dOriFlame = d + length(cP-p);\t\t// approximate distance from ray origin to flame \n        float bSize = dRayFlame/dOriFlame;\n        vec3 flame = FLAMECOL;\n        flame *= S(BOKEH_SIZE, BOKEH_SIZE-BOKEH_SIZE*blur, bSize);\n        \n        flame *= 200.;\n        flame /= (dOriFlame*dOriFlame);\n        float flicker = LN(t+id.x*100.+id.y*345.);\n        //flicker = mix(.3, 1., S(.2, .5, flicker));\n        flame *= 1.-flicker*flicker*.7;\n        \n        if(length(id)>2.)\n        col += flame;\n        \n        // step to the next cell\n        vec2 rC = ((2.*step(0., r.d.xz)-1.)*h-q.xz)/r.d.xz;\t\t// ray to cell boundary\n        float dC = min(rC.x, rC.y)+.01;\n        \n        d += dC;\n    }\n    \n    \n    return col;\n}\n\nvec3 calcNormal( de o )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy).d - map(o.pos-eps.xyy).d,\n\t    map(o.pos+eps.yxy).d - map(o.pos-eps.yxy).d,\n\t    map(o.pos+eps.yyx).d - map(o.pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nvec3 FlameNormal( vec3 p, float n )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fmap(p+eps.xyy, n).d - fmap(p-eps.xyy, n).d,\n\t    fmap(p+eps.yxy, n).d - fmap(p-eps.yxy, n).d,\n\t    fmap(p+eps.yyx, n).d - fmap(p-eps.yyx, n).d );\n\treturn normalize(nor);\n}\n\nde GetShadingBasics(de o, ray r) {\n    o.pos = r.o + o.d*r.d;\n    o.nor = calcNormal( o );\n    o.fresnel = dot(o.nor, r.d);\n    \n    return o;\n}\n\n\n\nvec4 render( vec2 uv, ray camRay, float n ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(camRay, n);\n    col = Background(camRay);\n    \n    if(o.m>0.) {\n        o = GetShadingBasics(o, camRay);\n        vec3 p = o.pos;\n        float angle = atan(p.x, p.z);\n        \n        float inside = S(.9, .5, length(o.pos.xz));\n        float dif = dot(o.nor, camRay.d)*.5+.5;\n        float sss = S((n*n)*.2-1.5, -.0, p.y)*3.;\n        sss += sin(angle*15.)*.05;\n        sss *= (1.-inside);\n        dif = max(dif, sss);\n        \n        col = vec3(.3, .3, .4)*dif;\n        \n        \n        vec3 fv = vec3(0., 3., 0.)-o.pos;\n        float fd = length(fv);\n        float flame = sat(dot(o.nor, fv/fd)/(fd*fd));\n        col += flame*10.*mix(FLAMECOL, vec3(1.), .5);\n        \n        \n        vec3 candleCol = mix(CANDLECOL, vec3(1.), inside);\n       \n        \n        vec3 wickCol = mix(candleCol, vec3(.2), S(.1, .2, o.uv.y));\n        col *= mix(wickCol, candleCol, o.t);\n        \n        col += FLAMECOL*(1.-o.t)*S(.3, .8, o.uv.y)*2.;\n       \n        \n        vec3 r = reflect(camRay.d, o.nor);\n        \n        float ref = sat(dot(r, fv/fd));\n        col += FLAMECOL*2.*pow(ref, inside*50.+4.)*o.t;\n        \n    }\n    \n    if(o.f>0.&&o.fd<o.d) {\n        vec3 p = camRay.o+camRay.d*o.fd;\n        vec3 n = FlameNormal(p, n);\n        float fresnel = sat(dot(n, -camRay.d));\n        float flame = 1.;//fresnel;\n        \n        float wd = DistLine(camRay.o, camRay.d, vec3(-.3, .25, 0.));\n       wd = o.w;\n        \n        flame *= S(-.1, .8, p.y);\n        flame *= mix(1., .1, S(.85, .0, wd)*pow(abs(fresnel), 5.));\n        \n       flame *= S(3.5, 1., p.y);\n       flame *= S(2.5, 2., p.y);\n       \n        float bottomFade = S(.05, .2, p.y);\n        col = mix(col, FLAMECOL*3., flame*fresnel*bottomFade);\n        float blue = S(.4, -.0, p.y);\n       blue *= S(.7, .3, fresnel*fresnel);\n        col += FLAMEBLUE*blue*bottomFade;\n    }\n    \n    vec3 p = camRay.o + camRay.d*o.sd;\n    float y = p.y-1.;\n    float gw = sat(1.-y*y);\n    gw*=gw;\n    float glow = S(.25*gw, 0., o.s)*.5;\n    glow*=glow;\n    //glow *= S(.0, .5, p.y);\n    //glow *= S(2.5, 1., p.y);\n    \n    col = max(col, glow*FLAMECOL);\n\n    \n    return vec4( col, o.m );\n}\n\nvec4 Flame(vec2 uv, vec2 p) {\n    uv.x-=.5;\n    p.x -= .5;\n    \n    vec3 col = vec3(.99, .6, .35);\t// main color\n    vec3 blue =  vec3(.1, .1, 1.);  // flame blue\n    \n    float alpha = 1.;\n    \n    p.x *= S(.0, p.y, uv.y);\n   \n    vec2 top = p;\n    vec2 bottom = vec2(0., .15);\n    float bl = length(bottom-uv);\n    vec2 v = top-bottom;\n    float vl = length(v);\n    v /= vl;\n    \n    float fy = clamp(dot(uv-bottom, v), 0., vl);\n    vec2 cp = bottom + fy * v;\n    \n    float fx = length(cp-uv);\n    fy /= vl;\n    \n    float fw = mix(.13, .03, fy*fy);\n    //fw *= mix(.5, 1., vl);\n    \n    \n    col.b = bl;\n    col.r = fx/fw;\n    col.g = fy;\n    \n    fx /= fw;\n    \n    \n    float d = S(1., .9, fx);\n    \n    //col = vec3(.99, .6, .35)*(1.+fy);\n    \n    col *= d; \n    \n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv )\n{\n    float t = iTime;\n    uv = (2.*uv - (o.xy=iResolution.xy) ) / o.y ;  \t// -1 <> 1\n   \tm = iMouse.xy/iResolution.xy;\t\t\t\t\t// 0 <> 1\n    \n    float turn = (.1-m.x)*twopi+t*twopi/8.;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(\t  c,  0., s,\n                   \t\t  0., 1., 0.,\n                   \t\t  s,  0., -c);\n    \n    vec3 lookAt = vec3(0., .8, 0.);\n    float dist = 6.;\n    float y = .4;//INVERTMOUSE*dist*sin((m.y*pi));\n    vec3 pos = vec3(0., y, -dist)*rotX;\n   \t\n    CameraSetup(uv, pos, lookAt, 3.);\n    \n    bg = background(cam.ray.d);\n\t\n    t *= twopi;\n    float t2 = t;\n    float n = mix(N(floor(t2)), N(floor(t2+1.)), fract(t2));\n    \n    vec4 info = render(uv, cam.ray, n);\n   \n    \n\n    o = vec4(info.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1005, 1033, 1053, 1053, 1087], [1088, 1088, 1116, 1116, 1145], [1146, 1146, 1165, 1165, 1216], [1218, 1218, 1237, 1237, 1372], [1375, 1375, 1394, 1430, 1602], [2916, 2916, 2983, 2983, 3479], [3481, 3481, 3523, 3523, 3548], [3549, 3549, 3607, 3607, 3645], [3647, 3647, 3689, 3689, 3724], [3726, 3726, 3759, 3759, 3791], [3793, 3859, 3899, 3899, 4001], [4003, 4003, 4043, 4043, 4141], [4143, 4143, 4188, 4188, 4214], [4216, 4216, 4268, 4268, 4395], [4397, 4397, 4439, 4439, 4538], [4540, 4540, 4584, 4584, 4728], [4735, 4735, 4767, 4767, 4915], [4917, 4917, 4947, 5018, 5176], [5178, 5178, 5203, 5203, 5361], [5363, 5398, 5458, 5458, 5668], [5670, 5670, 5688, 5769, 6529], [6531, 6531, 6559, 6640, 7532], [7534, 7534, 7564, 7564, 8392], [8394, 8394, 8418, 8418, 9804], [9806, 9806, 9831, 9831, 10064], [10066, 10066, 10103, 10103, 10336], [10338, 10338, 10372, 10372, 10482], [10486, 10486, 10531, 10554, 12734], [12736, 12736, 12765, 12765, 13537], [13539, 13539, 13581, 13581, 14333]]}
{"id": "XtyBDD", "name": "Ribbon Shell Sculpture", "author": "WB", "description": "Raymarched sphere made of gradient noise that resembles some sort of abstract sculputre. Move mouse left/right to change thickness and up/down to change noise frequency.", "tags": ["raymarching", "noise", "implicitsurface"], "likes": 13, "viewed": 220, "published": "Public", "date": "1546313480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 256\n#define MIN_DIST 0.02\n#define _FoV 45.0\n#define _Epsilon 0.05\n\nconst vec3 _Center = vec3(0.0);\nconst float _Radius = 1.0;\nconst float _TextureScale = 0.5;\nconst float _SpecularExp = 50.0;\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center - pos) - radius;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//X-axis rotation matrix\nvec3 rotateX(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(1.0, 0.0, 0.0,\n        \t\t\t0.0, cosTheta, -sinTheta,\n    \t\t\t    0.0, sinTheta, cosTheta);\n    \n    return rot * p;\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//Fractal (pink) noise function S(f) ∝ 1/f^α, {0 <= α <=2}\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    for (int i = 1; i < octaves; i++)\n    {\n        val += noise(seed * freq * float(i)) / (pow(float(i), lac));\n    }\n\n    return val;\n}\n\nfloat map(vec3 pos)\n{   \n    float mX = iMouse.x/iResolution.x;\n    float thickness = mix(0.5, 0.9999, mX);\n    float mY = iMouse.y/iResolution.y;\n    float freq = mix(8.0, 1.0, mY);\n    float d1 = sdSphere(pos, _Center, _Radius);\n    float d2 = -sdSphere(pos, _Center, _Radius * thickness);\n    float df = max(d1, d2);\n    df = max(df, abs(noise(pos*freq)));\n    //df += cos(pos.y*16.0)/48.0;\n    //df += cos(pos.x*16.0)/48.0;\n    //df += cos(pos.z*16.0)/48.0;\n    \n    return df;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = map(pos);\n        \n        if (dist <= MIN_DIST)\n        {\n            return pos;\n        }\n        \n        pos += dir * dist * _Epsilon;\n    }\n    \n    return vec3(0.0);\n}\n    \n//Approximate surface normal using central difference\nvec3 calculateNormal(vec3 p)\n{\n    const float eps = 0.01;\n\n    return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n                          map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n                          map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    int i = 0;\n    float t = mint;\n    for(int i = 0; i < 64; i++)\n    {\n        if (t >= maxt)\n            break;\n        \n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n//Tri-planar texture mapping\nvec3 triPlanar(vec3 p, vec3 n, float k)\n{\n    vec2 xUV = p.zy/_TextureScale;\n    vec2 yUV = p.xz/_TextureScale;\n    vec2 zUV = p.xy/_TextureScale;\n    \n    vec3 colX = texture(iChannel0, xUV).rgb;\n    vec3 colY = texture(iChannel0, yUV).rgb;\n    vec3 colZ = texture(iChannel0, zUV).rgb;\n    \n    vec3 blend = pow(abs(n),vec3(k));\n    blend = blend/(blend.x + blend.y + blend.z);\n    \n    return colX * blend.x + colY * blend.y + colZ * blend.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0);\n        \n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    rayDir = rotateY(rayDir, iTime * 0.2);\n    rayOrigin = rotateY(rayOrigin, iTime * 0.2);\n    //rayDir = rotateX(rayDir, iTime * 0.1);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 start, end;\n    \n    if(raycastSphere(rayOrigin, rayDir, start, end, _Center, _Radius))\n    {\n        vec3 sp = raymarch(start, rayDir);\n\n        vec3 n = calculateNormal(sp);\n\n        vec3 r = rayOrigin - sp;\n        float atten = 1.0/dot(r,r);\n        \n        float nl = dot(n, -rayDir);\n        \n        vec3 h = (n-rayDir)/length(n-rayDir);     \n        float spec = pow(max(dot(n, h), 0.0), _SpecularExp) * max(0.0, nl);\n        \n        col = triPlanar(sp, n, 2.0); \n        \n        float d = length(r);\n       \tfloat shadow = softShadow(sp, -rayDir, 0.0001, d, 16.0);\n\n        //Lighting\n        //float flicker = ((1.0 + sin(iTime*2.0)/2.0) + (1.0 + sin(iTime*10.0)/4.0) + (1.0+sin(iTime*25.0)/8.0))*0.5;\n        col = vec3(0.1, 0.1,0.2) + col * (nl + spec) * atten * shadow * 15.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyBDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 264, 264, 308], [310, 310, 343, 343, 374], [376, 402, 488, 488, 942], [944, 969, 1000, 1000, 1194], [1196, 1221, 1252, 1252, 1446], [1448, 1470, 1491, 1491, 1660], [1662, 1662, 1688, 1688, 2513], [2515, 2578, 2636, 2636, 2789], [2791, 2791, 2812, 2812, 3274], [3276, 3276, 3311, 3311, 3552], [3558, 3612, 3642, 3642, 3912], [3914, 3914, 3984, 3984, 4282], [4284, 4313, 4354, 4354, 4759], [4761, 4761, 4818, 4818, 6168]]}
