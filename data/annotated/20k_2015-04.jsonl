{"id": "4l23WR", "name": "Nat's Perlin Noise Shader", "author": "NattyBumppo", "description": "My attempt at making Perlin noise.", "tags": ["procedural", "perlin"], "likes": 1, "viewed": 193, "date": "1428116480", "time_retrieved": "2024-06-20T18:19:27.897559", "image_code": "// Number of cells in a row/column\nint numCellsHorizontal = 100;\nint numCellsVertical = 80;\n\n// Cell dimensions\nfloat cellWidth;\nfloat cellHeight;\n\n// Turns on a mode where negative noise values\n// are always high rather than low\nbool stainedGlassMode = false;\n\n// Turns on a mode where the colors \"breathe\" by\n// the negative noise values going up and down\nbool glowMode = true;\n\n// Turns on a mode where the colors cycle\nbool cycleMode = true;\n\n// Turns on a mode where the noise moves slightly\nbool lifeMode = false;\n\n// Turns on interpolation via a quintic smoothing function\nbool smoothQuinticMode = false;\n\n// Turns on cosine interpolation\nbool coserpMode = true;\n\n// Frequency of cycling in cycle mode\nfloat redCycleFreq = 0.4;\nfloat greenCycleFreq = 0.2;\nfloat blueCycleFreq = 0.25;\n\nfloat gradOffset = 1.0;\n\n// This generates a pseudorandom number based on the seed, which is the\n// cell row and column (so that corner points have consistent gradients in\n// each of the cells in which they're present).\n// Adapted from\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfloat rand(vec2 seed)\n{\n    // Augmenting the values by a small delta\n    // gets rid of a bug where zero seeds will result\n    // in a random number of zero\n    seed.x += 0.23434;\n    seed.y += 0.12424;\n       \n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(seed.xy, vec2(a,b));\n    highp float sn = mod(dt, 3.14159);\n    highp float fractionalPart = fract(sin(sn) * c);\n    \n    // A little fix for the terrible power of zero\n    if (fractionalPart == 0.0)\n    {\n        fractionalPart = 3.14159;    \n    }\n    \n    // Add a random-ish sign, too\n    float sign;\n    if (fractionalPart < 0.5)\n    {\n        sign = 1.0;\n    }\n    else\n    {\n        sign = -1.0;\n    }\n    \n    return fractionalPart * sign;\n}\n\n// Given a screen coordinate, returns which row it's in\nint getCellRow(vec2 uv)\n{\n    return int(floor(float(numCellsVertical) * (float(uv.y) / float(iResolution.y))));\n}\n\n// Given a screen coordinate, returns which column it's in\nint getCellCol(vec2 uv)\n{\n    return int(floor(float(numCellsHorizontal) * (float(uv.x) / float(iResolution.x))));    \n}\n\n// Get a pseudo-random gradient vector, based on the current fragment\n// coordinates and the local cell coordinates of the grid coordinate\n// in question.\nvec2 getGradient(vec2 uv, vec2 xy)\n{\n    // Find which cell we're in\n    int cellRow = getCellRow(uv);\n    int cellCol = getCellCol(uv);\n\n;\n    \n    // Fix edges, in order to make sure that the gradient\n    // at x=1.0 for one cell is the same as the gradient\n    // for the cell to the left at x=-1.0, etc.\n    if (xy.x == 1.0)\n    {\n        cellCol++;\n    }\n    if (xy.y == 1.0)\n    {\n        cellRow++;\n    }\n\n    // Get random offset for gradient magnitude\n    // that depends on elapsed time and cell position\n    gradOffset = rand(vec2(cellCol, cellRow)*2.0) * cos(iTime * 0.1);\n    \n    // Get a pseudo-random choice for a gradient, taking into account\n    // the position of the cell, and the fact that we want one point\n    // to have the same value when serving as a corner for multiple cells\n    float gradientX = rand(vec2(cellRow, cellCol));\n    float gradientY = rand(vec2(cellCol, cellRow));\n\n    if (lifeMode)\n    {\n        gradientX += gradOffset;   \n        gradientY += gradOffset;\n    }\n    \n    vec2 gradient = vec2(gradientX, gradientY);\n    gradient = normalize(gradient);\n    \n    return gradient;\n}\n\n// Uses a smoothed quintic interpolation (using an ease function)\n// to output the interpolated value, where weight ranges from\n// 0.0 to 1.0.\nfloat smoothQuintic(float startPoint, float endPoint, float weight)\n{    \n    // Get the value that would be produced with regular linear interpolation\n    float diff = endPoint - startPoint;\n    float linVal = startPoint + weight * diff;\n    \n    // Get the equivalent value from the ease function\n    float smoothedVal;\n    if (linVal < 0.0)\n    {\n        linVal *= -1.0;\n        smoothedVal = -(6.0 * pow(linVal, 5.0) - 15.0 * pow(linVal, 4.0) + 10.0 * pow(linVal, 3.0));\n    }\n    else\n    {\n        smoothedVal = 6.0 * pow(linVal, 5.0) - 15.0 * pow(linVal, 4.0) + 10.0 * pow(linVal, 3.0);\n    }\n    \n    return smoothedVal;\n}\n\n// Linear interpolation\nfloat lerp(float startPoint, float endPoint, float weight)\n{\n    float diff = endPoint - startPoint;\n    float linVal = startPoint + weight * diff;\n\n    return linVal;\n}\n\n\n// Cosine interpolation\nfloat coserp(float startPoint, float endPoint, float weight)\n{\n\n    float cosWeight = (1.0 - cos(weight * 3.14159)) * 0.5;\n    \n    return startPoint * (1.0 - cosWeight) + endPoint * cosWeight;\n}\n\n// Finds the Perlin weight at a given coordinate\nfloat getPerlinWeight(vec2 uv)\n{\n    // First get the gradient values for each corner of the cell\n    vec2 grad0 = getGradient(uv, vec2(-1.0, -1.0));\n    vec2 grad1 = getGradient(uv, vec2(-1.0, 1.0));\n    vec2 grad2 = getGradient(uv, vec2(1.0, -1.0));\n    vec2 grad3 = getGradient(uv, vec2(1.0, 1.0));\n    \n    // Let's also get the absolute coordinates of each cell corner,\n    // to make calculating the distance easier\n    vec2 pos0 = vec2(float(getCellCol(uv)) * cellWidth, float(getCellRow(uv)) * cellHeight);\n    vec2 pos1 = vec2(float(getCellCol(uv)) * cellWidth, float(getCellRow(uv)+1) * cellHeight);\n    vec2 pos2 = vec2(float(getCellCol(uv)+1) * cellWidth, float(getCellRow(uv)) * cellHeight);\n    vec2 pos3 = vec2(float(getCellCol(uv)+1) * cellWidth, float(getCellRow(uv)+1) * cellHeight);\n    \n    vec2 distVec0 = vec2((uv.x - pos0.x) / cellWidth, (uv.y - pos0.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec1 = vec2((uv.x - pos1.x) / cellWidth, (uv.y - pos1.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec2 = vec2((uv.x - pos2.x) / cellWidth, (uv.y - pos2.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec3 = vec2((uv.x - pos3.x) / cellWidth, (uv.y - pos3.y) / cellHeight) / sqrt(2.0);\n\n    // Now, find the influence of each cell corner by taking the dot product of the\n    // distance and the gradient\n    float influence0 = dot(grad0, distVec0);\n    float influence1 = dot(grad1, distVec1);\n    float influence2 = dot(grad2, distVec2);\n    float influence3 = dot(grad3, distVec3);\n    \n    // One more thing we need: the position of this fragment in its cell's coordinates\n    vec2 uvCell;\n    uvCell.x = (float(uv.x) - float(getCellCol(uv)) * cellWidth) / cellWidth;\n    uvCell.y = (float(uv.y) - float(getCellRow(uv)) * cellHeight) / cellHeight;\n    \n    // Now, interpolate to get a weighted average of this particular\n    // point's value going both horizontally and vertically\n    float topWeight, bottomWeight, weight;\n    if (smoothQuinticMode)\n    {\n        // Perform higher-order interpolation\n        topWeight = smoothQuintic(influence1, influence3, uvCell.x);\n        bottomWeight = smoothQuintic(influence0, influence2, uvCell.x);\n        weight = smoothQuintic(bottomWeight, topWeight, uvCell.y);        \n    }\n    else if (coserpMode)\n    {\n        // Perform cosine interpolation\n        topWeight = coserp(influence1, influence3, uvCell.x);\n        bottomWeight = coserp(influence0, influence2, uvCell.x);\n        weight = coserp(bottomWeight, topWeight, uvCell.y);            \n    }\n    else\n    {\n        // Perform regular linear interpolation\n        topWeight = lerp(influence1, influence3, uvCell.x);\n        bottomWeight = lerp(influence0, influence2, uvCell.x);\n        weight = lerp(bottomWeight, topWeight, uvCell.y);        \n    }\n\n    \n    return weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    cellWidth = float(iResolution.x) / float(numCellsHorizontal);\n    cellHeight = float(iResolution.y) / float(numCellsVertical);\n    \n    float intensity = getPerlinWeight(fragCoord.xy);\n    \n    // The intensity value will be between -1 and 1; let's\n    // display these two cases using [0.0, 0.5] for negative\n    // and [0.5, 1.0] for positive\n    if (intensity < 0.0)\n    {\n        if (stainedGlassMode)\n        {\n            // Display the negative intensities as bright,\n            // starting at 0.5 intensity\n            intensity = 0.5 - 0.5 * intensity;\n        }\n        else if (glowMode)\n        {\n            // Make the negative intensities cycle\n            // from no intensity to stainedGlass intensity\n            intensity = 0.5 + 0.5 * cos(iTime) * intensity;\n        }\n        else\n        {\n            // Regular display\n            intensity = 0.5 + 0.5 * intensity;\n        }\n    }\n    else\n    {\n        intensity =  0.5 + 0.5 * intensity;\n    }\n    \n    if (cycleMode)\n    {\n        float redWeight = 0.5 + 0.5 * sin(redCycleFreq*iTime);\n        float greenWeight = 0.5 + 0.5 * sin(greenCycleFreq*iTime + 3.14159 / 4.0);\n        float blueWeight = 0.5 + 0.5 * sin(blueCycleFreq*iTime + 3.14159 / 2.0);\n        \n        fragColor = vec4(redWeight * intensity, greenWeight * intensity, blueWeight * intensity, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, intensity, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l23WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l23zy", "name": "SoftShadowTest", "author": "dila", "description": "Testing soft shadows. Use the mouse to rotate. See the code for a few hints.\nThe technique is described here http://iquilezles.org/www/articles/rmshadows/rmshadows.htm", "tags": ["test", "shadow", "soft"], "likes": 36, "viewed": 867, "date": "1430249457", "time_retrieved": "2024-06-20T18:19:27.897559", "image_code": "const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sphereDistance(vec3 pos)\n{\n\treturn length(pos) - 0.6;   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\n\nfloat planeDistance(vec3 pos)\n{\n\tvec3 origin = vec3(0.0, -0.5, 0.0);\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 delta = pos - origin;\n    float prod = dot(delta, normal);\n    return prod;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 rpos = (pos - vec3(0.0,0.5,0.0));\n    rpos *= zrot(iTime) * xrot(pi*0.25) * yrot(pi*0.25+iTime);\n    \n    float cube = sdBox(rpos, vec3(0.5));\n    \n    float acut = sdBox(rpos, vec3(1.0, 0.25, 0.25));\n    float bcut = sdBox(rpos, vec3(0.25, 1.0, 0.25));\n    float ccut = sdBox(rpos, vec3(0.25, 0.25, 1.0));\n    \n    float carve = min(acut, min(bcut, ccut));\n    \n\tfloat x = max(-carve, cube);\n    \n\treturn min(x, planeDistance(pos));\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    vec3 n = vec3(0.0);\n    n.x = map(p+o) - map(p-o);\n    n.y = map(p+o.zxy) - map(p-o.zyx);\n    n.z = map(p+o.yzx) - map(p-o.yzx);\n    return normalize(n);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 pos = o + r * t;\n        float d = map(pos);\n        t += d;\n    }\n    return t;\n}\n\nvec2 ltrace(vec3 o, vec3 r)\n{\n    /* http://iquilezles.org/www/articles/rmshadows/rmshadows.htm */\n    float t = 0.0;\n    float md = 1000.0;\n    float lt = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 pos = o + r * t;\n        float d = map(pos);\n        md = min(md, 16.0*d/t);\n        t += min(d, 0.1); /* <-- you need to clamp the distance for it to work :) */\n    }\n    return vec2(t,clamp(md,0.0,1.0));\n}\n\nfloat light(vec3 world, vec3 sn, vec3 lpos)\n{\n    vec3 ldel = world + sn * 0.01 - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    vec2 lt = ltrace(lpos, ldel);\n    float lm = 1.0;\n    if (lt.x < ldist) {\n        lm = lt.y;\n    }\n    float lp = max(dot(ldel, -sn), 0.0);\n    float fl = lp * lm / (1.0 + ldist * ldist * 0.1);\n    return fl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.3));\n    ray *= xrot(pi*0.27);\n    \n    mat3 rotr = mat3(1.0);//yrot(iTime);\n    if (iMouse.z >= 1.0) {\n        vec2 mp = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n\t\trotr = xrot(-mp.y) * yrot(-mp.x*3.0);\n    }\n    \n    ray *= rotr;\n    vec3 origin = vec3(0.0, 0.0, -1.4) * rotr;\n    origin.y += 2.0;\n    \n\tfloat t = trace(origin, ray);\n    vec3 world = origin + ray * t;\n    vec3 sn = normal(world);\n    float fd = map(world);\n    \n\tfloat la = light(world, sn, vec3(-1.0, 3.0, 0.0));\n    float lb = light(world, sn, vec3(1.0, 3.0, 0.0));\n\n    float fog = 1.0 / (1.0 + t * t * 0.01 + fd * 5.0);\n    \n    vec3 diff = vec3(1.0, 1.0, 1.0) * 0.1;\n    float dp = max(dot(ray,-sn),0.0);\n    \n    vec3 rc = diff * dp;\n    rc += la * vec3(1.0, 0.5, 0.3);\n    rc += lb * vec3(0.0, 0.5, 0.7);\n    rc *= fog;\n\tfragColor = vec4(rc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l23zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l2GDm", "name": "Squircle landscape", "author": "pixelzealot", "description": "A scrolling landscape filled with every changing squircles and driven by music and some noise. Sun/moon cycle too because.", "tags": ["landscape", "squircle", "timeofday"], "likes": 6, "viewed": 211, "date": "1429692307", "time_retrieved": "2024-06-20T18:19:27.903448", "image_code": "#define DEBUG 1\n\n\nmat2 rotate2D(float angle)\n{\n   \tfloat cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    \n    return mat2(\n        vec2(cosTheta, sinTheta), \n        vec2(-sinTheta, cosTheta));\n}\n\n// Noise shamlessly storen from iq\nfloat noise(vec3 x) \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nfloat fbm(vec2 p)\n{\n\tp += vec2(1.0,0.1) * iTime*0.5;\n    \n    float f;\n    f  = 0.5000 * noise(p); p = p * 2.02;\n    f += 0.2500 * noise(p); p = p * 2.03;\n    f += 0.1250 * noise(p); p = p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\n// Sun\nfloat f(vec2 p, vec2 centre, float radius, float power)\n{\n    vec3 a = vec3(p, radius);\n    vec3 b = vec3(centre, 0.0);\n    return dot(pow(abs(a-b), vec3(power)), vec3(1.0, 1.0, -1.0));\n}\n\nvec2 grad(in vec2 x, vec2 centre, float radius, float power)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy, centre, radius, power) - f(x-h.xy, centre, radius, power),\n                 f(x+h.yx, centre, radius, power) - f(x-h.yx, centre, radius, power) ) / (2.0*h.x);\n}\n\n// Get sound frequency at a particular column at a particular sample in the column\nfloat getFreqOfColumn(float column, float s, float numSamples, vec2 grid)\n{\n    float sampleWidth = 1.0/numSamples;\n    float offset = (s-1.0) / (numSamples-1.0);\n    \n    float samplePos = column + (offset) / grid.x;\n\tsamplePos = mod(samplePos * 0.5, 1.0);\n    return texture(iChannel1, vec2(samplePos, 0.25)).x;\n}\n\nfloat squircle(vec2 uv, vec2 pos, float radius, float power)\n{\n\tfloat v = f(uv, pos, radius, power);\n    vec2  g = grad(uv, pos, radius, power);\n    float de = v / length(g);            \n    return de;\n}\n\nvoid addTC(in vec2 fragCoord, inout vec3 col, out float dayNightMult)\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= aspect;\n        \n    float gridSize = 30.0;\n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;    \n\n    mat2 rotMat = rotate2D(iTime*0.25);\n    \n    vec2 sunPosition = rotMat * vec2(0.75, 0.0);\n    sunPosition += vec2(0.5*aspect, 0.1);\n    float sunMult = 1.0 - clamp(sunPosition.y-0.2, 0.0, 0.5);\n    float sun = squircle(uv, sunPosition, 0.1, 4.0 * sunMult);\n    \n    float sunBloom = squircle(uv, sunPosition, 0.3 * sunMult, 4.0 * sunMult)*2.0;\n    \n    vec3 sunColor = mix(vec3(1.0, 1.0, 0.5)*1.2, vec3(1.0, 0.4, 0.1), sunMult);\n    \n    vec2 moonPosition = rotMat * vec2(-0.75, -0.1);\n    moonPosition += vec2(0.5*aspect, 0.1);\n    \n    float moon0 = squircle(uv, moonPosition, 0.1, 2.0);\n    float moon1 = squircle(uv, moonPosition + vec2(0.08, 0), 0.12, 2.0);\n    float moon = max(moon0, -moon1);\n    vec3 moonColor = vec3(1.0, 1.0, 1.0);\n    \n    dayNightMult = clamp((sunPosition.y + 0.1) / 0.7, 0.0, 1.0);\n        \n    col = mix(vec3(0.01, 0.01, 0.1), col, dayNightMult); // Do sky\n    \n    sunColor = mix(col, sunColor, dayNightMult);\n    \n    col = mix(col, mix(sunColor, col, 0.5), 1.0 - smoothstep(0.0, 1.5/iResolution.x, sunBloom)); // Do sun bloom\n    col = mix(col, sunColor, 1.0 - smoothstep(0.0, 1.5/iResolution.x, sun)); // Do sun\n    \n    col = mix(col, mix(moonColor, col, 0.5), 1.0 - smoothstep(0.01, 0.02, moon)); // Do moon bloom\n    col = mix(col, moonColor, 1.0 - smoothstep(0.0, 1.5/iResolution.x, moon)); // Do moon\n    \n}\n\nvoid terrainLayer(\n    inout vec3 col, \n    in vec2 uv, \n    in float gridSize, \n    in float heightOffset, \n    in float radiusAdjust, \n    in vec2 freqAdjust,\n    in vec4 tintColor,\n    in float dayNightMult)\n{\n    float aspect = (iResolution.x / iResolution.y);\n    \n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;\n    \n    float s0 = max(0.0, freqAdjust.x + getFreqOfColumn(coord.x, 1.0, 5.0, grid) * freqAdjust.y);\n    float s1 = max(0.0, freqAdjust.x + getFreqOfColumn(coord.x, 5.0, 5.0, grid) * freqAdjust.y);\n\n\tfloat n0 = fbm(vec2(coord.x, s0));\n    float n1 = fbm(vec2(coord.x + 1.0/grid.x, s1));\n\n    s0 = s0 + (n0 - 0.5);\n    s1 = s1 + (n1 - 0.5);\n    \n    float xx = abs(uv.x - coord.x) * grid.x;\n    float ySlope = mix(s0, s1, xx);\n    \n    float slopeOffset = (heightOffset+0.1)/grid.y;\n\n    #if 0\n    if (abs(uv.y - (ySlope + slopeOffset)) < 1.0/iResolution.y)\n    {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    float ySlope0 = mix(s0 + (n0 - 0.5), s1 + (n1 - 0.5), xx);\n    \n    if (abs(uv.y - (ySlope0 + slopeOffset)) < 1.0/iResolution.y)\n    {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n\t#endif\n    \n    // The actual line so it all joins nicely\n    if (uv.y < ySlope + slopeOffset)\n    {\n        float colAdjust = (coord.y - 0.0) * 0.75;\n        \n        // The background ground colour\n        col = (vec3(0.584, 0.271, 0.012) - colAdjust);\n        col = mix(col, tintColor.rgb, tintColor.a);\n        col *= mix(vec3(0.4, 0.4, 0.6), vec3(1.0), dayNightMult);\n    }\n    \n    float columnHeight = coord.y + (1.0/grid.y);\n    \n    // Space for a squircle\n\tif (columnHeight < (s0 + slopeOffset) && columnHeight < (s1 + slopeOffset))\n\t{\n        vec2 ab = uv;\n        \n \t\tvec2 c = 1.0 / grid;\n    \tvec2 p = mod(ab, c) - c*0.5;\n        p.y /= aspect;\n        \n        float powerAdjust = max(s0, s1);\n\n        float radius = (0.008 + 0.006 * powerAdjust) * radiusAdjust;\n\t    float power = 1.0 + 3.0 * powerAdjust;\n\n        float de = squircle(p, vec2(0.0), radius, power);\n        \n        float edge = (1.54 / radiusAdjust) / iResolution.x;\n        float darken = smoothstep(0.0, edge, abs(de));\n        \n        float colAdjust = (columnHeight - 0.1) * 0.5;\n        \n        // Inner colour + border\n        vec3 border = (vec3(0.584, 0.271, 0.012)*0.9 - colAdjust) * darken;\n        border = mix(border, tintColor.rgb, tintColor.a);\n\t\tcol = mix(col, border, 1.0 - smoothstep(0.0, edge, de));\n\t}    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(0,0,0);\n    float dayNightMult = -1.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = uv.x + iTime*0.1;\n    \n    float gridSize = 30.0;\n    vec2 grid = vec2(gridSize, ceil(gridSize / aspect));\n    vec2 coord = floor(uv * grid) / grid;\n    \n    // Sky blue\n    col = mix(vec3(0.529, 0.808, 0.98), vec3(0.529, 0.808, 0.98) * 0.6, coord.y);\n    \n\taddTC(fragCoord, col, dayNightMult);\n\n    vec2 uv0 = uv + vec2(iTime * 0.1, 0.0) + vec2(12.34, 0.0);\n    terrainLayer(\n        col, \n        uv0, \n        60.0, \n        12.0, \n        0.5, \n        vec2(0.00, 0.2), \n        vec4(0.0, 0.0, 0.0, 0.4), \n        dayNightMult);\n    \n    vec2 uv1 = uv + vec2(iTime * 0.4, 0.0);\n    terrainLayer(\n        col, \n        uv1, \n        30.0, \n        4.0, \n        1.0, \n        vec2(0.0, 0.77), \n        vec4(1.0, 1.0, 1.0, 0.0), \n        dayNightMult);\n\n    \n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2GDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l2GDR", "name": "simple smooth plasma", "author": "igore", "description": "Smooth plasma", "tags": ["procedural", "2d", "plasma", "acid"], "likes": 9, "viewed": 315, "date": "1428134379", "time_retrieved": "2024-06-20T18:19:27.903448", "image_code": "const float TWOPI = 6.28318530718;\nconst vec3 one = vec3(1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime * 0.33;\n    vec2 uv = -fragCoord / iResolution.xy;\n\n    vec2 p0 = uv - vec2(0.5 + 0.5 * sin(1.4 * TWOPI * uv.x + 2.8 * time), 0.5);\n    \n    vec3 wave = vec3(\n        0.5 * (cos(sqrt(dot(p0, p0)) * 5.6) + 1.0),\n        cos(4.62 * dot(uv, uv) + time),\n        cos(distance(uv, vec2(1.6 * cos(time * 2.0), 1.0 * sin(time * 1.7))) * 1.3)\n    );\n    \n    float color = dot(wave, one) / 16.6;\n\n    fragColor = vec4(\n        0.5 * (sin(TWOPI * color + time * 3.45) + 1.0),\n        0.5 * (sin(TWOPI * color + time * 3.15) + 1.0),\n        0.4 * (sin(TWOPI * color + time * 1.26) + 1.0),\n        1.0\n\t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2GDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l2GWm", "name": "Quincunx Anti Aliasing", "author": "demofox", "description": "Quincunx Anti Aliasing on left, no antialiasing on right.  In real quincunx anti aliasing, you would render the scene twice so that \"corner samples\" could be shared to make rendering more efficient.", "tags": ["aa", "quincunx"], "likes": 12, "viewed": 3094, "date": "1429676480", "time_retrieved": "2024-06-20T18:19:28.594549", "image_code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\nMore info here:\nhttp://blog.demofox.org/2015/04/22/quincunx-antialiasing/\n\nQuincunx anti aliasing works by using 5 samples per pixel in the following configuration:\n\n  B        C\n  *--------*\n  |   A    |\n  |   *    |\n  |        |\n  *--------*\n  D        E\n\nA is the center of the pixel that you would normally draw.  It has a weight of 1/2.\n\nB,C,D,E are offset from the center by half a pixel and each having a weighting of 1/8.\n\nThe weights of all the samples add up to 1.0 but the center has the heaviest contribution to the final image.\n\nIn shadertoy, quincunx AA means that you have to do 5 times as much rendering per pixel, but\nin real rendering situations, you can achieve quincunx by doing two full screen renders.\n\nThe first render renders the screen with an offset of half a pixel (-0.5,-0.5) and the second render\nuses the results of that first render to get the corner pixels to mix into the center pixel.\n\nThe benefit of doing this is that those corner pixels can be shared by all the pixels that use them\nwhich makes it so you are basically doing 2x super sampling AA, but you get benefits closer to 5x!\n\n*/\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n// camera wander: sin(time) controls magnitude, time controls angle\nfloat cameraAngle = iTime * 0.32;\nfloat cameraMag = sin(iTime*0.89) * 0.25 +1.0;\n\nvec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n// aspect ratio correction\nvec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\nfloat g_arcorrection = resolution.x / resolution.y;\n\n// image zoom, defined by time\nfloat g_scale = (sin(iTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w/2.0)&&(abs(pos.y-(_y)) < _h/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    // thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    // textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture(iChannel3, pos).xyz);\n    \n    // spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iTime, vec3(0.0, 0.0, 1.0));\n    \n    // concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    // untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    // grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord)\n{\n    vec2 ret = ((coord / resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelColor;\n    \n    // draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    // right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy));\n\t}\n\t// left side = quincunx rendering\n\telse\n    {\n\t\tpixelColor =  GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.0, 0.0))) / 2.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.5, 0.5))) / 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.5,-0.5))) / 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-0.5,-0.5))) / 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-0.5, 0.5))) / 8.0;\t\n\t}\t\t\n\t\n    // write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2GWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lB3D1", "name": "Glass with caustic", "author": "andregc", "description": "Experiment with caustics. Fork of https://www.shadertoy.com/view/XljGWR. But here less number of reflection/refraction rays are used as shader craches with bug number of rays. If you card is enough power you can set \"calcRecursion\" define to bigger values", "tags": ["raytracing", "raymarching", "reflection", "refraction", "glass", "caustic"], "likes": 51, "viewed": 3879, "date": "1428451730", "time_retrieved": "2024-06-20T18:19:30.582452", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Forked from https://www.shadertoy.com/view/XljGWR\n// Distance function, camera setup and base for raymarching from iq's // https://www.shadertoy.com/view/Xds3zN\n\n\n#define OBJECT_MAP_FUNCTION map1\n\n#define calcRecursion rec3 // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.001\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.001\n#define ID_GLASS_WALL 2.000\n#define ETA 0.85\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 0.1\n#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n\n#define SURFACE_COLOR vec3(0.8,1.,0.9)\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(0.6+0.4*noise(p.xz*30. + p.yz*23.))\n vec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n    \n    \n//-------------------------------------------------------------------------------\n//  https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 d = abs(p) - b;\n   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n   return (length(p)-r);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return abs(length(max(abs(p)-b,0.0))-r);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n   \n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opS(  vec3 d1, vec3 d2 )\n{\n    return -d1.x>d2.x ? d2: d1;\n}\n\n//-------------------------------------------------------------------------------\n\n\n\nvec3 map1(in vec3 pos) {\n    vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.49,-0.4), vec2(0.3,0.5))), ID_GLASS_WALL, ETA);\n    res = opU(res, vec3(sdSphere(pos-vec3(0.,0.31,0.4),0.3),ID_GLASS_WALL, ETA));\n  //  res = opU(res, vec3(sdTorus(pos.yxz-vec3(0.3,0.,-0.7),vec2(0.2,0.1)),ID_GLASS_WALL, ETA));\n    res.x =abs(res.x);\n   \n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\treturn opU(res, OBJECT_MAP_FUNCTION(pos));    \n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n}\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.000;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n    \n    p+=rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\n//-------------------------------------------------------------------------------\n\n\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {\n     vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j) {\n\n        CP cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= SURFACE_COLOR;//*(abs(dot(rd, cp.normal)));\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n     float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n     return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray) {\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n\tvec3 VY = normalize(cross(ld, VX));     \n    vec3 c = vec3(0);\n    \n    const int N =3;\n    p += ray.cp.normal*DIST_EPSILON;\n   \n    for(int i = 0; i < N;++i) {\n        \n        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));\n        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));\n\n        vec3 rd = ld+(VX*(n1-0.5)+VY*(n2-0.5))*0.1;\n       // rd = ld;\n        rd = normalize(rd);\n\n \t\tvec3 cl = refractCaustic(p, rd, ld, ray.eta);\n        \n      \tc += cl* dot(rd,ray.cp.normal);\n    }\n    return c*3./float(N);\n}\n\n// lightning is based on https://www.shadertoy.com/view/Xds3zN\nvec3 getFloorColor(in Ray ray) {\n    \n    vec3 col = vec3(0);\n    vec3 pos = ray.cp.p;\n    vec3 ref = reflect( ray.rd, ray.cp.normal );\n    \n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    col = 0.4 + 0.1*f*vec3(1.0);\n\n    float dif = clamp( dot( ray.cp.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    // exclude branching\n    col *= (ID_GLASS_WALL-ray.cp.mat);\n\n    return col;\n}\n    \n\nvec3 getColor(in Ray ray) {\n\n    vec3 p = ray.cp.p ;// can be used by SURFACE_COLOR define\n    vec3 c1 = ray.col * SURFACE_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    // exclude branching\n    return mix(c2, c1, ray.cp.mat - ID_FLOOR);\n\n}    \n\n//-------------------------------------------------------------------------------\n\n\nvec3 getRayColor(Ray ray) {\n\n\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n//\tfresnel = mix(0.1, 1., 1.0-abs(cs));\n    float r = ray.cp.mat - ID_FLOOR;\n     vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n    \n// set of \"recursion\" functions\n\nvoid rec1(inout Ray ray) {\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    \n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec3(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec4(r1);\n    ray.col += getRayColor(r1);\n    // use first level of relfection rays only to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec5(r1);\n    ray.col += getRayColor(r1);\n    \n    // use only first level of relfection to improve performance\n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n\treturn ray.col;\n    \n}\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    // this strange construction is used to define initial view angle\n    // simple \"IF\" condition can work incorrectly on weak GPU \n    // (at least on one of tested computers_\n    mo = mix(vec2(0.6,0.3),mo, sign(mo.x+mo.y));\n\n\n    mo.y+=0.02;\n\tmo.y *=1.57;\n    float time =0.;//sin(iTime);//iTime*0.1;;\n\tmo.x*=10.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(time + mo.x)*X, Y, X*sin(time + mo.x) )*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta,0. );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lB3Ry", "name": "Trace proto1", "author": "luutifa", "description": "Why does the sphere think it's in shadow all the time???\nAlso all other suggestions would be highly appreciated.", "tags": ["raytracing", "pleasehelp"], "likes": 1, "viewed": 138, "date": "1429801995", "time_retrieved": "2024-06-20T18:19:30.582452", "image_code": "precision highp float;\n\n#define RADIUS 3.0\n#define PI 3.14159265\n#define EPSILON 0.001\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n\nvec3 amigaTexture(vec2 pos, float n) {\n    float l = clamp(sin(pos.x*n)*sin(pos.y*n)*10000.0, 0.0, 1.0);\n    return vec3(1.0, 0.0, 0.0)*l+(vec3(1.0, 1.0, 1.0)*(1.0-l));\n}\n\nfloat getTunnelDist(vec3 origin, vec3 direction) {\n    float a = direction.x*direction.x + direction.y*direction.y;\n    float b = 2.0*(origin.x*direction.x + origin.y*direction.y);\n    float c = origin.x*origin.x + origin.y*origin.y - RADIUS*RADIUS;\n    float disc = b*b - 4.0*a*c;\n    float t = 0.0;\n    /*if (disc < 0.0)\n        return 1000000.0;\n    else if (disc < EPSILON)\n        return -b/(2.0*a);\n    else*/\n        return /*min(*/(-b+sqrt(disc))/(2.0*a)/*, (-b-sqrt(disc))/(2.0*a))*/;\n    //We're only interested in positive z intersections so this is OK, I guess.\n}\n\nfloat getBoxDist(vec3 origin, vec3 direction) {\n    return 0.;\n}\n\nfloat getSphereDist(vec3 origin, vec3 direction, vec3 pos, float r) {\n    float a = direction.x*direction.x + direction.y*direction.y + direction.z*direction.z;\n    float b = 2.0 * (direction.x * (origin.x - pos.x) + direction.y * (origin.y - pos.y) + direction.z * (origin.z - pos.z));\n    float c = (origin.x - pos.x)*(origin.x - pos.x) + (origin.y - pos.y)*(origin.y - pos.y) + (origin.z - pos.z)*(origin.z - pos.z) - r*r;\n    float disc = b*b - 4.0*a*c;\n    if (disc<0.0)\n        return 1000000.0;\n    if (disc<EPSILON)\n        return -b/(2.0*a);\n    else\n        return min((-b+sqrt(disc))/(2.0*a), (-b-sqrt(disc))/(2.0*a));\n}\n\nvec3 sphereCenter = vec3(0.0, 0.0, 6.0+iTime);\n\nfloat render(vec3 origin, vec3 direction) {\n    return min(\n    \tgetTunnelDist(origin, direction),\n    \tgetSphereDist(origin, direction, sphereCenter, 0.8)\n    );\n}\n\nvec3 scene(vec3 origin, vec3 direction, out vec3 normal, out vec2 uv) { //Does depth testing\n    float tunnel = getTunnelDist(origin, direction);\n    float sphere = getSphereDist(origin, direction, sphereCenter, 0.8);\n    \n    vec3 pos = vec3(0.0);\n    if (tunnel < sphere) {\n    \tpos = origin + tunnel*direction;\n        normal = normalize(vec3(vec2(0.0), pos.z)-pos);\n        uv = vec2(atan(pos.y, pos.x), pos.z * 0.4);\n    } else {\n        pos = origin + sphere*direction;\n        normal = normalize(pos-sphereCenter);\n        uv = pos.xy-sphereCenter.xy;\n    }\n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenPos = fragCoord.xy / iResolution.yy - vec2(0.5) - vec2(((iResolution.x - iResolution.y)/iResolution.y)/2.0, 0.0);\n    \n    vec3 light1 = vec3(sin(iTime)*2.0, cos(iTime*0.1)*2.0, 4.0+iTime-sin(iTime*0.22)*3.0);\n    vec3 cam = vec3(sin(iTime*0.3), cos(iTime*0.4), iTime);\n    vec3 rayDir = getXRotMat(-cos(iTime*0.6)*0.2) * getYRotMat(-sin(iTime*0.6)*0.2) * normalize(vec3(screenPos, 1.0));\n    \n    vec3 normal;\n    vec2 uv;\n    vec3 pos = scene(cam, rayDir, normal, uv);\n\n    vec3 shadowDir = normalize(light1-pos);\n    vec3 shadowPos = pos + render(pos+shadowDir*EPSILON, shadowDir)*shadowDir;\n    float shadow = 1.0;\n    if (length(shadowPos-pos)-EPSILON < length(light1-pos))\n        shadow = 0.0;\n    \n    float light = (1./length(pos-light1))\n        * max(dot(normal, -normalize(pos-light1)), 0.0);\n    light *= shadow;\n\n    fragColor = vec4(light*amigaTexture(uv, 6.0), 1.0);\n    //gl_FragColor = vec4(light*texture(iChannel0, uv/PI).rgb, 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lBGWD", "name": "Particle Experiment 3", "author": "aiekick", "description": "Mouse.x => particle duration\nMouse.y => Zoom", "tags": ["experiment", "3", "particle"], "likes": 8, "viewed": 1234, "date": "1428927707", "time_retrieved": "2024-06-20T18:19:30.582452", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+5.;\n        \n    // vars\n    float z = 1.;\n    \n    const int n = 200; // particle count\n    \n    vec3 startColor = normalize(vec3(1.,0.,0.));\n    vec3 endColor = normalize(vec3(1.,sin(t)*.5+.5,cos(t)*.5+.5));\n    \n    float startRadius = 0.3;\n    float endRadius = 0.8;\n    \n    float power = 0.5;\n    float duration = 0.9;\n    \n    vec2 \n        s = iResolution.xy,\n\t\tv = z*(2.*fragCoord.xy-s)/s.y;\n    \n    // Mouse axis y => zoom\n    if(iMouse.z>0.) v *= iMouse.y/s.y * 20.;\n    \n    // Mouse axis x => duration\n    if(iMouse.z>0.) duration = iMouse.x/s.x * 10.;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 pm = v.yx*2.8;\n    \n    float dMax = duration;\n    \n    float mb = 0.;\n    float mbRadius = 0.;\n    float sum = 0.;\n    for(int i=0;i<n;i++)\n    {\n        float d = fract(t*power+48934.4238*sin(float(i)*692.7398))*duration;\n    \tfloat a = 6.28*float(i)/float(n);\n         \n        float x = d*cos(a);\n        float y = d*sin(a);\n        \n        float distRatio = d/dMax;\n        \n        mbRadius = mix(startRadius, endRadius, distRatio); \n        \n        v = mod(v,pm) - 0.5*pm;\n        \n        vec2 p = v - vec2(x,y);\n    \t\n        p = mod(p,pm) - 0.5*pm;\n        \n        mb = mbRadius/dot(p,p);\n    \t\n        sum += mb;\n        \n        col = mix(col, mix(startColor, endColor, distRatio), mb/sum);\n    }\n    \n    sum /= float(n);\n    \n    col = normalize(col) * sum;\n    \n    sum = clamp(sum, 0., .4);\n    \n    vec3 tex = vec3(1.);\n     \n    col *= smoothstep(tex, vec3(0.), vec3(sum));\n        \n\tfragColor.rgb = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lj3zy", "name": "Meta Experiment 8", "author": "aiekick", "description": "Each cells is a similar 2d metaball code\nClick on cell and keep down to see in full size", "tags": ["experiment", "meta", "8"], "likes": 15, "viewed": 1263, "date": "1430075238", "time_retrieved": "2024-06-20T18:19:30.588497", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 gridSize = vec2(4.,3.);//grid size (columns, rows)\n    \nvec2 s,g,h,m;\nfloat z,t;\n   \t\nfloat e0(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv * vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a;\n   \treturn 0.3/dot(uvSin.xyxy,uvSin.yxxy);\n}\nfloat e1(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a;\n   \treturn 0.3/dot(uvSin.xyxy,uvSin.yxxy);\n}\nfloat e2(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a;\n   \treturn 0.3/dot(uvSin,uvSin);\n}\nfloat e3(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a;\n   \treturn 0.3/dot(uvSin.xy,uvSin.yx);\n}\nfloat e4(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a;\n   \treturn 0.3/dot(uvSin.xx,uvSin.yx);\n}\nfloat e5(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y/p-t),sin(uv.x*p-t))/a/a;\n    return 0.3/dot(uvSin.xy,uvSin.yy);\n}\nfloat e6(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t),sin(uv.x/p-t))/a/p;\n    return 0.3/dot(uvSin.xxyx,uvSin.xyxx);\n}\nfloat e7(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.2/dot(uv,uv) * vec2(cos(uv.y*p-t)*p/a,sin(uv.x*p))*a;\n   \treturn dot(uvSin,uvSin)/1.2;\n}\nfloat e8(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.2/dot(uv,uv.xx) * vec2(cos(uv.y*p-t)*p/a,sin(uv.x*p))*a;\n   \treturn dot(uvSin,uvSin)/(p*p*0.25);\n}\nfloat e9(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.3/dot(uv.xyyx,uv.yxxy) * vec2(cos(uv.y*p-t)/p,sin(uv.x*p-t)*p)/a;\n   \treturn dot(uvSin.xyxy,uvSin.yxxy)/1.2;\n}\nfloat e10(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.3/dot(uv.xxy,uv.yxx) / vec2(cos(uv.y*p)*p,sin(uv.x*p-t)/p)/a;\n   \treturn 0.3/dot(uvSin,uvSin/p);\n}\nfloat e11(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv / vec2(cos(uv.y*p-t),sin(uv.x*p-t))*a/p;\n   \treturn 0.1/dot(uvSin,uvSin);\n}\nfloat EncID(vec2 s, vec2 h, vec2 sz) // encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\nvec2 DecID(float id, vec2 sz) // decode id to coord // id:cellId / sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)/sz.x;\n    return vec2(cx,cy);\n}\nvec3 getcell(vec2 s, vec2 h, vec2 sz) // return id / uv\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s/sz;\n    float ratio = size.x/size.y;\n    vec2 uv = (2.*(h)-size)/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    z = 3.;\n    t = iTime*5.;\n    s = iResolution.xy;\n    h = fragCoord.xy;\n    g = z*(2.*h-s)/s.y;\n    m = iMouse.xy;\n    \n    float d=0.;\n    vec3 cell = getcell(s,h,gridSize);\n    if(iMouse.z>0.) {cell.x = EncID(s,m,gridSize);cell.yz = g;}\n    \n    if (cell.x == 0.) d = e0(cell.yz, 1.5, 10., t);\n    else if (cell.x == 1.) d = e1(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 2.) d = e2(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 3.) d = e3(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 4.) d = e4(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 5.) d = e5(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 6.) d = e6(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 7.) d = e7(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 8.) d = e8(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 9.) d = e9(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 10.) d = e10(cell.yz, 1.5, 10., t);\n   \telse if (cell.x == 11.) d = e11(cell.yz, 1.5, 10., t);\n   \t \n    vec3 c = vec3(mix(1./d, d, 1.),mix(1./d, d, 3.),mix(1./d, d, 5.));\n    \n    fragColor.rgb = c;\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lj3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ljGD1", "name": "Waves Remix", "author": "ADOB", "description": "simple audio visualizer (also pretty without audio) based upon \"waves\" by bonniem, with added travelling pulse effect, color cycling, and of course, the requested audio sensitivity. Each wave is particularly responsive to a specific range of frequencies.", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "sounds"], "likes": 131, "viewed": 17918, "date": "1428650127", "time_retrieved": "2024-06-20T18:19:30.588497", "image_code": "float squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lS3RV", "name": "inflating squircle", "author": "binnie", "description": "squircle de noob", "tags": ["noob", "squircle"], "likes": 4, "viewed": 1240, "date": "1430229502", "time_retrieved": "2024-06-20T18:19:30.588497", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    // vec2 uv = -0.25 + 2.5 * q;\n\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tvec3 color = vec3(0.780, 0.082, 0.522);\n\n    vec2 pos = vec2(0.0,0.0);\n    \n    // True squircle (http://en.m.wikipedia.org/wiki/Squircle)\n    // (x-a)^4 + (y-b)^4 = r^4\n    float power = 1.0 + 1.0*(1.05+cos(iTime*2.0));\n    float radius =1.0;\n    float dist = pow(abs(uv.x-pos.x),power) + pow(abs(uv.y - pos.y),power);\n   \n\tif( dist > pow(radius,power))\n    {\n    \tcolor = vec3(0.580, 0.000, 0.827);\n    }\n\n    fragColor = vec4(color,1); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ls3zM", "name": "Manta Ray", "author": "dakrunch", "description": "v2.0: \nImproving the distance functions (tail still todo)\nWorked on the anatomy.\nAdded gills.\nNeed to work on tracing the wings more efficiently.", "tags": ["procedural"], "likes": 99, "viewed": 12861, "date": "1428189012", "time_retrieved": "2024-06-20T18:19:32.691916", "image_code": "// version 2.0 = new anatomy, improved distance functions\n// version 1.5 = trying to make the water surface and the sea floor more interesting\n// version 1.3 = changed wing primitives and adding front flaps\n// version 1.2 = working on improving the shape\n// version 1.1 = multiple mantas. Added scattering attributes\n// Version 1.0 = creation. Added a background. Single manta swim loop\n\n\nconst vec3 sun = vec3(-0.6, 0.4,-0.3);\nconst vec3 lightDir = normalize(vec3(.1,.7, .2));\n\nfloat time;\n\n#define csb(f, con, sat, bri) mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), f*bri)), f*bri, sat), con)\n#define MATERIAL_DEBUG 2.0\n#define MATERIAL_SKIN 1.0\n#define MATERIAL_NONE 0.0\n\n// Quality modifiers\n#define SPACING 3.5\n#define BBSIZE 1.75\n#define MAXDIST 40.\n#define MAXSTEPS 300\n#define TRACEMULT .3\n\n// debug\n#define DEBUG 0\n\n//--------------------------------------------------------------------------------------\n// Utilities.\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 Rotate_Y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nfloat softMin(float a, float b, float k)\n{\n    // Inigo's soft min implementation\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    // calculate deformed radius, not exact but fast estimate\n    float smallestSize = min(min(r.x,r.y),r.z);\n    vec3 deformedP = p/r;\n    float d = length(deformedP) - 1.0;\n    // renormalize - ish\n   \treturn d * smallestSize;\n}\n\nfloat wings(in vec3 p) \n{   \n    vec3 r = vec3(1.5, 0.15, 0.55);\n    float smallestSize = min(min(r.x,r.y),r.z);\n    \n    // scale and position\n    vec3 dp = p/r;\n    dp.z -= dp.x*dp.x*0.8; //bend backward\n    dp.z -= (dp.x-0.6)*(dp.x-0.5);\n    dp.y -= 0.6; // lift up\n    \n    // shape\n    float d = (dp.y*dp.y + dp.z*dp.z);\n    d += abs(dp.x);\n    d -= 1.0; // radius\n    \n    return d * smallestSize;\n}\n\nfloat mantabody(in vec3 p)\n{\n    // body\n    float d = sdEllipsoid(p, vec3(0.4,0.3,0.8));\n    \n    // wings\n    if (p.z < 1.0 && p.z > -1.4 &&\n       \tp.y < 1.0 && p.y > -0.2) \n    {\n    \td = softMin(d, wings(p), 0.4);\n    }\n    \n    vec3 flapsP;\n    vec3 flapsScale;\n    \n    // bottom flaps\n    if (p.x < 1.0 && \n        p.z < -0.2 && p.z > -1.4 &&\n       \tp.y < 0.2 && p.y > -0.2) \n    {\n        flapsP = p;\n    \tflapsP += vec3(-0.5-p.z*0.2,0.3-p.x*0.5,1.0-p.x*0.2);\n\t    flapsScale = vec3(.09,.08,.25);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.2);\n    }\n    \n    // dorsal fin\n    if (p.x < 0.2 && \n        p.z > 0.3 && p.z < 1.0 &&\n       \tp.y > 0.1 && p.y < 0.5) \n    {\n\t    flapsP = p;\n    \tflapsP += vec3(0.,-0.15- 0.2*p.z,-0.7);\n\t    flapsScale = vec3(.03,.1,.2);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.15);\n    }\n    \n    // tail\n    if (p.z>0.0) {    \n\t    float taild = length(p.xy);\n    \td = softMin(d,taild,0.1);\n        d = max(d, smoothstep(2.3,2.5,p.z));\n    }\n    \n    \n    return d;\n}\n\nfloat GetMantaScale(in float rowId, in float columnId)\n{\n    // randomized scale factor based on cell\n\treturn 0.6 + 0.6*hash(7.*rowId + 11.* columnId);\n}\n\n\nfloat animatedManta(in vec3 p, in float rowId, in float columnId) \n{   \n    float size = GetMantaScale(rowId, columnId);\n    \n    // animate\n    float timeloop = time * 2.5 / (size-0.25) + // loop speed\n        hash(rowId+3.*columnId) * 10.; // random offset\n    p.y+= -sin(timeloop-0.5)*.25 * size;\n    p.y+= sin(time*0.5 + hash(37.*rowId+11.*columnId)*17.) * 2.5;\n    \n \tvec3 mantap = p/size;\n    mantap.x = abs(mantap.x);    \n \n    float animation = sin(timeloop-3. - 1.3*mantap.z);\n    float animationAmount = pow(mantap.x,1.5);\n    // cap max deformation to reduce ray marching aliasing on wings\n    animationAmount = min(animationAmount, 2.5); \n    mantap.y += animation * (0.3*animationAmount + 0.15);\n    \n    float d = mantabody(mantap);\n    \n    return d*size;\n}\n\n\n//--------------------------------------------------------------------------------------\nvec2 Scene(vec3 p, in int includeNeighbors, in int debug)\n{\n    p.z+= time;\n\tfloat mat = MATERIAL_SKIN;\n    \n    // Repeat\n    vec3 loopP = p;\n    loopP.x = mod(loopP.x+BBSIZE, SPACING)-BBSIZE;\n    loopP.z = mod(loopP.z+BBSIZE, SPACING)-BBSIZE;\n\n    //scramble\n    float rowId = floor((p.x+ BBSIZE)/SPACING);\n    float columnId = floor((p.z+ BBSIZE)/SPACING);\n    \n    float d = animatedManta(loopP, rowId, columnId);\n    // careful about BB edges!\n    if (includeNeighbors == 1) \n    {\n        d = min(d, BBSIZE+0.1-abs(loopP.x));\n        d = min(d, BBSIZE+0.1-abs(loopP.z));\n    }\n    \n    \n    if (debug == 1) \n    {\n        float planeD = abs(p.y - 2.*sin(time));\n        \n        d = planeD;\n        mat = MATERIAL_DEBUG;\n    }\n\n    // x: distance, \n    // y: material type\n\treturn vec2(d, mat);\n}\n\n//--------------------------------------------------------------------------------------\nvec4 Trace(vec3 rayOrigin, vec3 rayDirection, out float hit)\n{\n\tconst float minStep = 0.005;\n    hit = 0.0;\n\t\n    vec2 ret = vec2(0.0, 0.0);\n    vec3 pos = rayOrigin;\n\tfloat dist = 0.0;\n    for(int i=0; i < MAXSTEPS; i++){\n\t\tif (hit == 0.0 && dist < MAXDIST && pos.y<10.0 && pos.y > -10.0 )\n        {\n            pos = rayOrigin + dist * rayDirection;\n            \n            // ret.x: distance, \n            // ret.y: material type\n            ret = Scene(pos, 1, DEBUG);\n            \n            if (ret.x < 0.01)\n                hit = ret.y;\n\n            // increment\n            if (ret.y >= 2.0)\n                dist += ret.x * 10.0;\n            else \n            {\n            \tfloat increment = ret.x*TRACEMULT;\n                increment = max(minStep, increment);\n                dist += increment;\n            }\n        }\n    }\n    return vec4(pos, ret.y);\n}\n\n//--------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n    // compute analytic normal\n\tvec3 eps = vec3(0.0001,0.0,0.0);\n\treturn normalize(vec3(Scene(p+eps.xyy,0, 0).x-Scene(p-eps.xyy,0, 0).x,\n\t\t\t\t\t\t  Scene(p+eps.yxy,0, 0).x-Scene(p-eps.yxy,0, 0).x,\n\t\t\t\t\t\t  Scene(p+eps.yyx,0, 0).x-Scene(p-eps.yyx,0, 0).x ));\n}\n\n//--------------------------------------------------------------------------------------\nvec3 GetColour(vec4 p, vec3 n, vec3 org, vec3 dir)\n{\n    // given a closest sample (raymarch hit), compute the color\n    \n    vec3 localP = vec3(p) + vec3(0.,0.,time);\n    vec3 loopP = localP;\n    loopP.x = mod(loopP.x+BBSIZE, SPACING)-BBSIZE;\n    loopP.z = mod(loopP.z+BBSIZE, SPACING)-BBSIZE; \n\n    //scramble\n    float rowId = floor((localP.x+0.5*SPACING)/SPACING);\n    float columnId = floor((localP.z+0.5*SPACING)/SPACING);\n    float size = GetMantaScale(rowId, columnId);\n    vec2 coord = loopP.xz;\n    loopP/=size;\n    \n\tvec3 colour = vec3(0.0);\n\tif (p.w < 1.5)\n    {\n\t\tfloat v = clamp(-(n.y-.1)*6.2, 0.3, 1.0);\n\t\tv+=.35;\n\t\tcolour = vec3(v*.8, v*.9, v*1.0);\n\t}\n    \n    // upper side of the body\n    vec3 colorUp = colour;\n    if (n.y < 0.4) \n    {    \n\t    float stainsUp = texture(iChannel1, coord).x;\n    \tstainsUp *= stainsUp * 2.;\n\t    stainsUp = 1.-stainsUp;\n\t\tstainsUp += smoothstep(2.,-2.,loopP.z);\n\t    stainsUp = clamp(stainsUp, 0., 1.);\n        \n        float gillsV = loopP.z*60.;\n        float gillsU = abs(loopP.x*0.7);\n        float maskV = (loopP.z+0.1*size)*1.2;\n        gillsV += gillsU*16.0; //bend\n        float mask = 1.5-(10.0*gillsU*gillsU)-(10.0*maskV*maskV);\n        mask *= min(gillsU*10., 1.0);\n        mask = clamp(mask, 0.0, 1.0);\n        float gills = 1.1 + sin(gillsV)*0.6;\n        gills = clamp(gills, 0.1, 1.0);\n        gills = mix(1.0, gills, mask);\n        stainsUp *= gills;\n        \n    \tcolorUp *= stainsUp;\n    }\n    \n    // lower side of the body\n    vec3 colorDown = colour;\n    if (n.y > -0.4)\n    {\n    \tfloat stainsDown = texture(iChannel1, coord*0.4).x;\n\t    stainsDown *= stainsDown;\n\t    stainsDown = clamp(stainsDown, 0., 1.);\n        \n    \tcolorDown *= vec3(stainsDown);\n    }\n    \n    // note the overlap: we don't want a hard edge.\n    colour = mix(colorUp, colorDown, smoothstep(-0.4,0.4,n.y));   \n\n    \n    // Projected animated caustics on skin\n    vec2 wat = p.xz*1.;\n    wat +=  (texture(iChannel0, (wat*5.0+time*.04)*.1, 3.0).z -\n             texture(iChannel0, wat*.3-time*.03, 2.0).y) * .4;\n    float causticLight = texture(iChannel0, wat* .04, 0.0).x;\n    causticLight = pow(max(0.0, causticLight-.2), 1.0) * 20. * smoothstep(-5.,3.,p.y);\n    colour *= vec3(1.0) + vec3(causticLight*.5, causticLight, causticLight)*max(n.y, 0.0); \n    \n    // shadow\n    float diff = dot(n,lightDir);\n    \n    // individual top/down ambient lighting, no shadow\n    vec3 brightLight = vec3(0.7,0.7,0.8);\n    vec3 shade = vec3(0.12,0.15,0.22);\n    colour *= mix(shade,brightLight,max(diff*0.5+0.5,0.0));\n    \n    return colour;\n}\n\n\n//--------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime+32.2;\n    \n\tvec3 col;\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - vec2(.5);\n\tuv.x*=iResolution.x/iResolution.y;\n\tvec3 dir = normalize(vec3(uv, -1.0));\n\t\n    vec3 pos = (sin(time*0.14)*2.+4.5)*vec3(sin(time*.5), 0.0, cos(time*.5));\n    pos.z -= time;\n    pos.y += 0.7 * sin(time * 0.2);\n    float rot = -time*0.5;\n\tdir = Rotate_Y(dir, rot);\n\n    // Sun...\n\tfloat i = max(0.0, 1./(length(sun-dir)+1.0));\n\tcol = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8)) * 1.3;\n\t\n\t// Water depth colour...\n\tcol = mix(col, vec3(0.0, .25, .45), ((1.0-uv.y)*.45) * 1.8);\n\t\n    float d;\n\tif (uv.y >= 0.0)\n\t{\n\t\t// Add water ripples...\n        d = (3.0-pos.y) / -uv.y;\n\t\t\n        vec2 wat = (dir * d).xz-pos.xz;\n        d += 1.*sin(wat.x + time);\n        wat = (dir * d).xz-pos.xz;\n        wat = wat * 0.1 + 0.2* texture(iChannel0, wat, 0.0).xy;\n        \n\t\ti = texture(iChannel3, wat, 0.0).x;\n        \n\t\tcol += vec3(i) * max(2./-d, 0.0);\n\t}\n\telse\t\t\n\t{\n\t\t// The floor comes and goes, very slow animation\n\t\td = (-3.0-pos.y) / uv.y;\n\t\tvec2 coord = pos.xz+(dir.xz * d);\n\t\tvec3 sand = texture(iChannel3, coord* .1).rgb * 1.5  + \n\t\t\t\t\ttexture(iChannel3, coord* .23).rgb;\n        sand *= 0.5;\n\t\t\n\t\tfloat f = ((-uv.y-0.3 +sin(time*0.1)*0.2)*2.45) * .4;\n\t\tf = clamp(f, 0.0, 1.0);\n\t\t\n\t\tcol = mix(col, sand, f);\n\t}\n\n\tfloat hit = 0.0;\n\tvec4 loc = Trace(pos, dir, hit);\n    float material = loc.w;\n\tif (hit > 0.0)\n\t{\n        if (material == MATERIAL_DEBUG) \n        {\n            col = vec3(1.,0.,0.0);\n            vec2 ret = Scene(loc.xyz, 0, 0);\n            float d = ret.x;\n            col = vec3(mod(d,1.0), mod(d*10.0,1.0), 0.0);\n        } \n        else \n        {    \n            vec3 norm = GetNormal(loc.xyz);\n            vec3 foundColor = GetColour(loc, norm, pos, dir);\n            vec3 backgroundColor = col;\n\n            // light properties: \n\t\t    // the facefoward element computes an emulated \"fuzz\" lobe,\n    \t\t// a thin scattery effect mimicking the mucous protection on the skin\n            float facing = -dot(norm,dir);\n            float upfacing = clamp(norm.y, 0.,1.);\n            float fresnel = 1.0-facing;\n            fresnel = clamp(pow(fresnel, 1.0), 0.0,1.0);\n            foundColor = mix(foundColor, backgroundColor*2.0, 0.5 * (0.5 + upfacing*upfacing) * fresnel);\n\n            // atmos\n            float dis = length(pos-loc.xyz);\n            float fogAmount = clamp(max((dis-.5),0.0)/MAXDIST, 0.0, 1.0);\n\n            col = mix(foundColor, backgroundColor, fogAmount );\n        }\n\t}\n\t\n    // Minor color grading\n    // Contrast, saturation and brightness...\n\tcol = csb(col, 1.1, 1.05, 1.22);\n\tfragColor = vec4(col, 10);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ls3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lS3zV", "name": "Wavessss", "author": "gravis", "description": "many wav", "tags": ["waves"], "likes": 3, "viewed": 194, "date": "1430252214", "time_retrieved": "2024-06-20T18:19:32.770506", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float amp = 8.0;\n    float freq = 2.0; //* abs(sin(iTime));\n    float slide = 1.0 - iTime * 1.0;\n    float xx = 1.0 - abs((fragCoord.y / iResolution.x - .3) * amp - sin((fragCoord.x / iResolution.x - slide) * freq));\n    float xz = 1.0 - abs((fragCoord.y / iResolution.x - .3) * amp - sin((fragCoord.x / iResolution.x - 1.0 - slide * -.5) * freq));\n    float xr = 1.0 - abs((fragCoord.y / iResolution.x - .3) * amp - sin((fragCoord.x / iResolution.x - 2.4 - slide * 1.9) * freq));\n\tfragColor.b = xz;\n    fragColor.r = xx;\n    fragColor.g = xr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lSGDh", "name": "Colors Port", "author": "shaktool", "description": "Colors Port", "tags": ["colorsport"], "likes": 1, "viewed": 100, "date": "1428368737", "time_retrieved": "2024-06-20T18:19:32.770506", "image_code": "float WIDTH = iResolution.x;\nfloat HEIGHT = iResolution.y;\nfloat offset = iTime * 60.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x;\n\tfloat y = HEIGHT - fragCoord.y;\n\t\n\t\n    float red   = x;\n\tfloat green = y + offset;\n\tfloat blue  = x + y;\n\t\n    \n\tfragColor = fract(vec4(red, green, blue, 255.0) / 255.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4lSGRV", "name": "3d Primitives animated", "author": "tholzer", "description": "A set of animated 3d primitives and combined objects.\nUse mouse to rotate scene or set ROTATE_SCENE = true.\nOriginal shader created by Inigo Quilez!\n", "tags": ["procedural", "3d", "raymarching", "primitives"], "likes": 16, "viewed": 1663, "date": "1430216073", "time_retrieved": "2024-06-20T18:19:36.740581", "image_code": "\n//---------------------------------------------------------\n// Shader:   3dPrimitivesAnim.glsl\n//\n//  v1.1   4/2015  animation added to original\n//  v1.2  12/2016  using new objects\n//  v1.3  11/2018  antialasing added, see AA\n//  v1.4  12/2018  icosahedron & dodecahedron added\n//  v1.5   2/2019  mainImage & calcNormal adaption\n//  v1.6   5/2019  reformated\n//\n// tags:     3d, primitives, procedural, raymarching, animated\n//\n// see also:\n//   original:     https://www.shadertoy.com/view/Xds3zN   IQ, colored\n//   gray scaled:  http://glslsandbox.com/e#20839\n//   transparent:  https://www.shadertoy.com/view/tdsXRn\n//   sdSuperprim:  https://www.shadertoy.com/view/Xdy3Rm\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// A list of useful distance function to simple primitives (animated),\n// and examples on how to do some interesting boolean operations,\n// repetitions and displacements you'll finder under\n//   http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\n\n// Btw. Can fps be increased by checking first if we are\n//      intersecting an circumsphere first?\n//      This means 1. raytracing 2. rayMarching.\n\n#define AA 2   // make this 1 if your machine is too slow\n\n#define ANIMATE_OBJECTS true\n\n//#define ROTATE_SCENE true\n#define ROTATE_SCENE false\n\n#define flag true\n\n#define PI 3.14159265359\n\nfloat time = 0.0;\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n\n//---------------------------------------------------------\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//---------------------------------------------------------\n// distance functions - distance operations - domain operations\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\nfloat length2( vec2 p )  // sqrt(x^2+y^2)\n{\n  return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )  // (x^6+y^6)^(1/6)\n{\n  p = p*p*p;\n  p = p*p;\n  return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )  // (x^8+y^8)^(1/8)\n{\n  p = p*p;\n  p = p*p;\n  p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\n\n//---------------------------------------------------------\n// distance operations\n//---------------------------------------------------------\n#define opUnion(a,b)      min(a,b)\n#define opIntersect(a,b)  max(a,b)\n#define opDifference(a,b) max(a,-b)\n#define opSubstraction(a,b) max(-a,b)\n#define opExklusiveOr(a,b)  min(max(-a,b),max(-b,a))\n\n// Union: d1 + d2\nvec2 opU( in vec2 d1, in vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------------------\n// domain operations\n//---------------------------------------------------------\n\n// Repetition x,y,z:\n// vec3 opRepeat (vec3 p, vec3 c)  {  return mod(p, c)-0.5*c;   }\n#define opRepeat(p,c) (mod(p,c)-0.5*c)\n\n//---------------------------------------------------------\n// domain deformations: p=position\n//---------------------------------------------------------\n// Twist: angle = twist angle\nvec3 opTwist (vec3 p, float angle)\n{\n  float c = cos(10.0*p.y + angle);\n  float s = sin(10.0*p.y + angle);\n  mat2  m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\n//---------------------------------------------------------\n//  3d primitives: p = position\n//---------------------------------------------------------\n\nfloat sdPlane1 (vec3 p)\n{\n  return p.y;\n}\n\nfloat sdPlane (vec3 p, vec4 n)  // n must be normalized\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p) - radius;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    //old: return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Egg1:  \nfloat sdEgg1(in vec3 p, float radius)\n{\n  p.y = 0.8*p.y + 0.15 * pow(1.9*dot(p.xz, p.xz), 0.65);\n  return length(p) - radius;\n}\n\n// Egg2:  https://www.shadertoy.com/view/lsXSWf\nfloat sdEgg2(vec3 p, float r)\n{\n    p.y -= r*0.5;\n    p.y *= 0.8;\n    return length(p) - 1.7 * r * cos(p.y + 1.36);\n}\n\n// Egg3:  https://www.shadertoy.com/view/tttBDS\nfloat sdRoundCone_Egg(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // distance to 2 spheres\n    float pa = length(p - a);\n    float pb = length(p - b);\n    \n    // get fraction\n    float fa = pa/(pa+pb);\n    float fb = pb/(pa+pb);\n    \n    // get distance point\n    vec3 ps = a + (b - a) * fa;\n    return length (p - ps) - (r2 * fa + r1 * fb);\n}\n\n// signed box: b=size\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// unsigned box: b=size\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// unsigned rounded box: b=size, r=round radius\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b, 0.0))-r;\n}\n\n// Torus:  t.x = torus radius,  t.y = ring radius\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x, p.y);\n  return length8(q) - t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x, p.y);\n  return length8(q)-t.y;\n}\n\n// Capsule:  a,b = end points, r = cylinder radius\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// Triangle prism:  base radius, prism height\nfloat sdTrianglePrism( vec3 p, float radius, float height )\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max(q.x*0.866025 +p.y*0.5, -p.y) - radius*0.5);\n  #else\n    float d1 = q.z-height;\n    float d2 = max(q.x*0.866025+p.y*0.5, -p.y) - radius*0.5;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n  #endif\n}\n\n// Hexagonal Prism:  base radius, prism height\nfloat sdHexagonalPrism( vec3 p, float radius, float height)\n{\n  vec3 q = abs(p);\n  #ifdef flag\n    return max(q.z-height, max((q.x*0.866025 +q.y*0.5), q.y) - radius);\n  #else\n    float d1 = q.z-heighty;\n    float d2 = max((q.x*0.866025 +q.y*0.5), q.y)-radius;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Cylinder: h.x=radius, h.y=height\nfloat sdCylinder(in vec3 p, in vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Cylinder: h=dimension, h.y=height\nfloat sdCylinder (in vec3 p, in vec3 h)\n{\n  return length(p.xz - h.xy) - h.z;\n}\n\n// Cylinder6: h.xy = base rectangle size, h.z=height\nfloat sdCylinder6 (in vec3 p, in vec3 h)\n{\n  return max( length6(p.xz) - h.x, abs(p.y) - h.z );\n}\n\n// Cone: c=dimension\nfloat sdCone (in vec3 p, in vec3 c)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  #if 0\n    return max( max( dot(q, c.xy), p.y), -p.y -c.z );\n  #else\n    float d1 = -p.y - c.z;\n    float d2 = max( dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n  #endif\n}\n\n// Dodecahedron: radius = circumsphere radius\nfloat sdDodecahedron(vec3 p, float radius)\n{\n  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n  const vec3 n = normalize(vec3(phi,1,0));\n\n  p = abs(p / radius);\n  float a = dot(p, n.xyz);\n  float b = dot(p, n.zxy);\n  float c = dot(p, n.yzx);\n  return (max(max(a,b),c)-n.x) * radius;\n}\n\n// Icosahedron: radius = circumsphere radius\nfloat sdIcosahedron(vec3 p, float radius)\n{\n  const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n  const vec3 n1 = normalize(vec3(q,1,0));\n  const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n  p = abs(p / radius);\n  float a = dot(p, n1.xyz);\n  float b = dot(p, n1.zxy);\n  float c = dot(p, n1.yzx);\n  float d = dot(p, n2) - n1.x;\n  return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n\nfloat sdIcosDodecaStar(vec3 p, float radius)\n{\n  return min(sdDodecahedron(p,radius),  sdIcosahedron(p.zyx,radius));\n}\n\n// 4-sided Pyramid:  h = (cos a, sin a, height)\nfloat sdPyramid4(vec3 p, vec3 h )\n{\n  // Tetrahedron = Octahedron - Cube\n  float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n\n  float d = 0.0;\n  d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n  d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n  float octa = d - h.z;\n  return max(-box,octa); // subtraction\n}\n\n// https://www.shadertoy.com/view/lsBGzG\nfloat sdPyramid( vec3 p, float h)\n{\n  vec3 q=abs(p);\n  return max(-p.y, (q.x +q.y +q.z -h)/3.0 );\n}\n\n\n//=== Additional shapes ===\n\n//---------------------------------------------------------\nfloat sdWaveSphere(vec3 p, float radius, int waves, float waveSize)\n{\n  //bounding Sphere\n  float d = length(p) - radius*2.2;\n  if(d > 0.0) return 0.2;\n\n  // deformation of radius\n//d = waveSize * (radius - abs(p.y));\n  d = waveSize * (radius*radius-(p.y*p.y));\n  radius += d * cos(atan(p.x,p.z) * float(waves));\n  return 0.5*(length(p) - radius);\n}\n//---------------------------------------------------------\nfloat sdBlob (in vec3 pos, in float r)\n{\n  vec3 v1 = pos * 6.0;\n  return 0.05*(r + 0.5* (length(dot(v1, v1)) -0.51*(cos(4.*v1.x) +cos(4.*v1.y) +cos(4.*v1.z))));\n}\n\n//---------------------------------------------------------\n// 3d cross: s=cross size\n//---------------------------------------------------------\nfloat sdCross( in vec3 p, in float s)\n{\n  float da = max (abs(p.x), abs(p.y));\n  float db = max (abs(p.y), abs(p.z));\n  float dc = max (abs(p.z), abs(p.x));\n  return min(da,min(db,dc)) - s;\n}\n//---------------------------------------------------------\n// 3d CrossInSphere: r=sphere radius, s=cross size\n//---------------------------------------------------------\nfloat CrossInSphere( in vec3 p, in float r, in float s )\n{\n  float d1 =  sdCross(p, s);  // cross\n  float d2 = length(p) - r;   // sphere\n  return max (d1,d2);         // intersection\n}\n//---------------------------------------------------------\n// sphere cutted out from a rounded box\n//---------------------------------------------------------\nfloat sdBoxMinusSphere( in vec3 pos, in float radius)\n{\n  return opDifference (udRoundBox(pos, vec3(0.15), 0.05)\n                      ,sdSphere(  pos, radius - 0.012 + 0.02*sinTime));\n}\n//---------------------------------------------------------\n// rack-wheel with holes\n//---------------------------------------------------------\nfloat sdRackWheel( in vec3 pos)\n{\n  return opDifference(sdTorus82(pos, vec2(0.20, 0.1)),\n    sdCylinder (opRepeat (vec3 (atan(pos.x, pos.z)/6.2831 + 0.1*aTime\n                               ,pos.y\n                               ,0.02+0.5*length(pos))\n                         ,vec3(0.05, 1.0, 0.05))\n               ,vec2(0.02, 0.6)));\n}\n//---------------------------------------------------------\nfloat sdBallyBall( in vec3 pos)\n{\n  return 0.7 * sdSphere(pos, 0.2 )\n    + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y + 8.0*aTime)*sin(50.0*pos.z);\n}\n//---------------------------------------------------------\nfloat sdTwistedTorus( in vec3 pos, float angle)\n{\n  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.20, 0.05));\n}\n//---------------------------------------------------------\n// render object positions\n\nconst vec3 p01 = vec3(-2.0, 0.25, -2.0);\nconst vec3 p02 = vec3(-1.0, 0.25, -2.0);\nconst vec3 p03 = vec3( 0.0, 0.25, -2.0);\nconst vec3 p04 = vec3( 1.0, 0.25, -2.0);\nconst vec3 p05 = vec3( 2.0, 0.20, -2.0);\n\nconst vec3 p11 = vec3(-2.0, 0.25, -1.0);\nconst vec3 p12 = vec3(-1.0, 0.50, -1.0);\nconst vec3 p13 = vec3( 0.0, 0.25, -1.0);\nconst vec3 p14 = vec3( 1.0, 0.25, -1.0);\nconst vec3 p15 = vec3( 2.0, 0.25, -1.0);\n\nconst vec3 p21 = vec3(-2.0, 0.20, 0.0);\nconst vec3 p22 = vec3(-1.0, 0.20, 0.0);\nconst vec3 p23 = vec3( 0.0, 0.25, 0.0);\nconst vec3 p24 = vec3( 1.0, 0.25, 0.0);\nconst vec3 p25 = vec3( 2.0, 0.25, 0.0);\n\nconst vec3 p31 = vec3(-2.0, 0.20, 1.0);\nconst vec3 p32 = vec3(-1.0, 0.25, 1.0);\nconst vec3 p33 = vec3( 0.0, 0.25, 1.0);\nconst vec3 p34 = vec3( 1.0, 0.25, 1.0);\nconst vec3 p35 = vec3( 2.0, 0.25, 1.0);\n\nconst vec3 p41 = vec3(-2.0, 0.25, 2.0);\nconst vec3 p42 = vec3(-1.0, 0.25, 2.0);\nconst vec3 p43 = vec3( 0.0, 0.25, 2.0);\nconst vec3 p44 = vec3( 1.0, 0.25, 2.0);\nconst vec3 p45 = vec3( 2.0, 0.30, 2.0);\n\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n\n//vec2 res = vec2 (sdPlane1(pos), 1.0);\n  vec2 res = vec2 (sdPlane(pos, vec4(0,1,0,0)), 1.0);\n\n  //---0---\n\n  res = opU(res, vec2( sdWaveSphere ( pos-p01, 0.18 , 10, sinTime*0.4), 99));\n\n                                    r1 = rotateY (pos-p02, aTime*0.5);\n  res = opU(res, vec2( sdDodecahedron(r1, 0.2), 55));\n\n                                    r1 = rotateX (pos-p03, sinTime*0.8);\n  res = opU(res, vec2( sdIcosDodecaStar(r1, 0.18), 177));\n\n                                    r1 = rotateZ (pos-p04, sinTime*0.8);\n  res = opU(res, vec2( sdIcosahedron(r1, 0.16), 222));\n\n                                    float h1 = 0.2 + 0.1 * abs(sinTime);\n//  res = opU(res, vec2( sdPyramid4  (pos-p05, vec3(0.8,0.6,h1) ), 8));\n  res = opU(res, vec2( sdPyramid  (pos-p05, h1 ), 8));\n\n  //---1---\n                                    r1 = rotateY (pos-p11, aTime*0.5);\n  res = opU(res, vec2( sdTrianglePrism( r1, 0.1*sinTime + 0.25, 0.05 ), 44));\n\n                                    r1 = rotateX (pos-p12, sinTime*0.8);\n  res = opU(res, vec2( sdCone      (r1, vec3(0.8, 0.5+0.2*sinTime, 0.3)), 222));\n\n  res = opU(res, vec2( sdBlob      (pos-p13, -0.5 - 0.45*sinTime ), 244));\n\n                                    h1 = 0.2 + 0.06 * sinTime;\n  res = opU(res, vec2( sdCylinder  (pos-p14, vec2(0.1, h1) ), 130));\n\n               vec3 a = vec3( 0.1, 0.0, 0.0);  float sr1 = 0.1+0.05*sinTime;\n               vec3 b = vec3(-0.1, 0.3, 0.1);  float sr2 = 0.05;\n  res = opU(res, vec2( sdRoundCone( pos-p15, a,b, sr1,sr2), 51.7));\n\n  //---2---\n\n  res = opU(res, vec2( CrossInSphere ( pos-p21, 0.2+0.05*sinTime, 0.05), 51));\n\n                                    r1 = p22 + rotateY (vec3(-0.22, 0, 0), aTime);\n                                    r2 = p22 - rotateY (vec3(-0.22, 0, 0), aTime);\n  res = opU(res, vec2( sdCapsule   (pos, r1, r2, 0.1), 32));\n\n                                    r1 = vec3( 0.0, 0.1 + 0.1 * sinTime, 0.0);\n  res = opU(res, vec2( sdSphere    (pos-p23-r1, 0.25), 111));\n\n  res = opU(res, vec2( sdBox       (pos-p24, vec3(0.20)), 3));\n\n  res = opU(res, vec2( sdEgg1      (pos-p24-r1, 0.21), 47));\n\n  res = opU(res, vec2( sdEgg2      (pos-p25, 0.18+h1), 47));\n\n  //---3---\n  res = opU(res, vec2( sdBoxMinusSphere (pos-p31, 0.25), 13));\n\n                                    r1 = rotateX (pos-p32, aTime*0.5);\n  res = opU(res, vec2( sdHexagonalPrism ( r1, 0.25, 0.05 ), 17.0));\n\n                                    r1 = rotateX (pos-p33, sinTime*1.2);\n                                    r1 = rotateZ (r1, aTime*2.0);\n  res = opU(res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0));\n\n  res = opU(res, vec2( udRoundBox(  pos-p34, vec3(0.12), 0.05+0.05*+sinTime), 77));\n\n  res = opU(res, vec2( sdBallyBall ( pos-p35), 65.0));\n\n  //---4---\n\n  res = opU(res, vec2( sdTwistedTorus( pos-p41, 6.0*sinTime ), 46.7));\n\n                                    r1 = rotateY (pos-p42, aTime*0.25);\n  res = opU(res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0));\n\n  res = opU(res, vec2( sdTorus82(   pos-p43, vec2(0.20-0.05*sinTime, 0.05)), 77.0));\n\n  res = opU(res, vec2( sdRackWheel( pos-p44 ), 51));\n\n                                    r1 = rotateY (pos-p45, aTime*0.25);\n  res = opU(res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12));\n\n  return res;   // return x=distance, y=color id\n}\n\n//---------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 0.5;   // min & max ray distances\n  float tmax = 12.0;\n\n  #if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n  #endif\n\n  float t = tmin;\n  float m = -1.0;\n  for( int i=0; i<64; i++ )\n  {\n    float precis = 0.0004*t;\n    vec2 res = map( ro+rd*t );\n    if( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n    if( t>tmax ) m=-1.0;\n  return vec2( t, m );\n  // return t=distance, m=material\n}\n\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//---------------------------------------------------------\n#define ZERO (min(iFrame,0))\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n//---------------------------------------------------------\nvec3 calcNormal( in vec3 pos )   // get surface normal\n{\n    const vec2 e = vec2(0.0003,-0.0003);\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n//---------------------------------------------------------\n// https://en.wikipedia.org/wiki/Ambient_occlusion\n// https://de.wikipedia.org/wiki/Umgebungsverdeckung\n//---------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )  // get ambient occlusion\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<4; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n//---------------------------------------------------------\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\nfloat HexagonalGrid (in vec2 position\n                    ,in float gridSize\n                    ,in float gridThickness)\n{\n  vec2 pos = position / gridSize;\n  pos.x *= 0.57735 * 2.0;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*1.5 + pos.y, pos.y*2.0) - 1.0);\n  return smoothstep(0.0, gridThickness, d);\n}\n//---------------------------------------------------------\nconst vec3 skyColor   = vec3(0.7, 0.9, 1.0);\nconst vec3 planeColor = vec3(0.8, 0.7, 0.6);\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n  vec3 col = skyColor;\n\n  vec2 res = castRay(ro, rd);\n\n  float t = res.x;  // t = distance\n  float m = res.y;  // m = precision\n  if ( m > 0.0 )    // intersection ?\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material color\n    col = 0.45 + 0.35*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m == 1.0 )  // ground plane ?\n    {\n//    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0); // simple checkers\n//    float f = checkersGradBox( 5.0*pos.xz );\n//    col = 0.3 + f*vec3(0.1);\n      float f = HexagonalGrid (4.*pos.xz, 0.8, 0.2);\n      col = 0.2 + 0.2*f*planeColor;\n    }\n\n    // lighting\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.2, 0.2, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n    dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                     dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 1.40*dif*vec3(1.00,0.80,0.55);\n    lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n    lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\tcol = col*lin;\n\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t));\n  }\n  return vec3( clamp(col, 0.0, 1.0) );\n}\n//---------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime;\n    float rtime = ROTATE_SCENE ? 0.1*time : 0.0;\n    aTime = ANIMATE_OBJECTS ? iTime : 0.0;\n    sinTime = sin(aTime);\n\n    // camera\n    float mx = 2.0 * PI * mo.x;  // mouse.x rotation\n    vec3 ta = vec3( 0.0, -0.1, 0.0 );  // target position\n    vec3 ro = vec3( 4.0*cos(rtime + mx)\n                  , 1.5 + 2.0*mo.y\n                  , 4.2*sin(rtime + mx) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": "4lXGD4", "previewfilepath": "https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/grizzogor/alkis-livathinos-dearest-hue", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t23DD", "name": "snowflake pattern", "author": "Lio", "description": "Experiment with a kaleidoscope pattern. :)", "tags": ["pattern", "snowflake"], "likes": 8, "viewed": 422, "date": "1429158216", "time_retrieved": "2024-06-20T18:19:36.740581", "image_code": "#define time  iTime\n#define R iResolution.xy\nvoid mainImage( out vec4 fragC, in vec2 fC)\n{\n\n//   vec2 pos = (fragCoord.xy/R.xy) * 8. - 4.; \n   vec2 pos = (fC.xy/R.xy) * 10. - 5.; \n    pos.x *= R.x / R.y;\n    float s = .25, f = .0, k = f;\n    vec3 p = vec3(pos, sin(time * .4) * .5 - .5)* s;    \n        \n    for( int i=0; i< 10; i++ )\n    {\n           p = abs(p)/dot(p,p)- 1.65;\n           k = length(p) ;\n           p = p*k+k;\n   }\n   \n   f = dot(p,p)* s;\n   fragC= vec4(f*.5, f *1.2, f * 5., 1.);;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t23DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t23Dh", "name": "Run Game Demo", "author": "yasuo", "description": "My first raytracing game demo.", "tags": ["game"], "likes": 5, "viewed": 262, "date": "1428597581", "time_retrieved": "2024-06-20T18:19:37.437607", "image_code": "#define SPEED 5.0\n\n\t\tfloat c_0 = 31599.0;\n\t\tfloat c_1 = 9362.0;\n\t\tfloat c_2 = 29671.0;\n\t\tfloat c_3 = 29391.0;\n\t\tfloat c_4 = 23497.0;\n\t\tfloat c_5 = 31183.0;\n\t\tfloat c_6 = 31215.0;\n\t\tfloat c_7 = 29257.0;\n\t\tfloat c_8 = 31727.0;\n\t\tfloat c_9 = 31695.0;\n\n\t\tfloat c_x = 23213.0;\n\t\tfloat c_y = 23186.0;\n\t\tfloat c_colon = 1040.0;\n\n\t\tvec2 rot(vec2 p, float a) {\n\t\t\treturn vec2(\n\t\t\t\tcos(a) * p.x - sin(a) * p.y,\n\t\t\t\tsin(a) * p.x + cos(a) * p.y);\n\t\t}\n\n\t\tfloat noise(float x) {\n\t\t\treturn fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n\t\t}\n\n\t\tfloat sdBox( vec3 p, vec3 b )\n\t\t{\n\t\t  vec3 d = abs(p) - b;\n\t\t  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\n\t\t// https://www.shadertoy.com/view/Xlj3Rm\n\t\tvec3 wave(vec2 uv, \n\t\t              float frequency, float amplitude, float shift, float offset,\n\t\t              vec3 color, float width, float exponent)\n\t\t{\n\t\t    float angle = iTime * 12.0 * frequency + ((iTime*0.01)*shift + uv.x) * 3.2831852;\n\t\t    \n\t\t    float y = sin(angle) * amplitude + offset;\n\t\t    \n\t\t    float scale = pow(smoothstep(width * 3.0, 0.01, distance(y+0.4, uv.y)), exponent);\n\t\t    \n\t\t    return color * scale;\n\t\t}\n\n\t\tfloat map(vec3 p) {\n\t\t\tfloat t = 100.0;\n\t\t\tfloat w = 0.0;\n\n\t\t\tfloat n = floor(p.z/0.5);\n\t\t\t\n\t\t\tvec3 oldp = p;\n\t\t\tp.z = mod(p.z, 0.5)-0.25;\n\t\t\tp.y += noise(n)*1.0+sin(iTime*2.0)*0.1;\n\t\t\tp.x += noise(n)*1.0-0.5;\n\t\t\t\n\t\t\tw = sdBox(p,vec3(0.15, 0.15, 0.15));\n\t\t\tt = min(t, w);\n\n        \tw = 0.1 + dot(oldp, vec3(0, 0.0, 0));\n        \tt = min(t, w);\n\n\t\t\treturn t;\n\t\t}\n\n\t\t// this code from GLSL sandbox\n\t\t//returns 0/1 based on the state of the given bit in the given number\n\t\tfloat getBit(float num,float bit)\n\t\t{\n\t\t\tnum = floor(num);\n\t\t\tbit = floor(bit);\n\t\t\t\n\t\t\treturn float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n\t\t}\n\n\t\tfloat Sprite3x5(float sprite,vec2 p)\n\t\t{\n\t\t\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\t\t\t\n\t\t\treturn getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n\t\t}\n\n\t\tfloat Digit(float num,vec2 p)\n\t\t{\n\t\t\tnum = mod(floor(num),10.0);\n\t\t\t\n\t\t\tif(num == 0.0) return Sprite3x5(c_0,p);\n\t\t\tif(num == 1.0) return Sprite3x5(c_1,p);\n\t\t\tif(num == 2.0) return Sprite3x5(c_2,p);\n\t\t\tif(num == 3.0) return Sprite3x5(c_3,p);\n\t\t\tif(num == 4.0) return Sprite3x5(c_4,p);\n\t\t\tif(num == 5.0) return Sprite3x5(c_5,p);\n\t\t\tif(num == 6.0) return Sprite3x5(c_6,p);\n\t\t\tif(num == 7.0) return Sprite3x5(c_7,p);\n\t\t\tif(num == 8.0) return Sprite3x5(c_8,p);\n\t\t\tif(num == 9.0) return Sprite3x5(c_9,p);\n\t\t\t\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\t\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\n\t\t\t// GAME DEMO MAIN\n\t\t\tfloat aspect = iResolution.x / iResolution.y;\n\t\t\tvec3  dir = normalize(vec3(uv * vec2(aspect, 1.0), 1.0));\n\t\t\t\n\t\t\tdir.yz = rot(dir.yz, 0.3);\n\t\t\tvec3 pos = vec3(0.0, 0.5, iTime*SPEED);\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\tfor(int i = 0 ; i < 50; i++) {\n\t\t\t\tfloat temp = map(t * dir + pos);\n\t\t\t\tif(temp < 0.01) break;\n\t\t\t\tt += temp * 1.0;\n\t\t\t}\n\t\t\t\n\t\t\tvec3 ip = pos + dir * t;\n\t\t\tvec4 cl = vec4(t * 0.01) * map(ip - 0.02) + t * 0.3;\n\n\t\t\t// UI\n\t\t\tuv = ( fragCoord.xy /iResolution.xy ) * vec2(64,32);\n\t\t\tvec2 cpos = vec2(1.0);\n\t\t\tfloat dc = Digit(fract(iTime)*10.0,floor(uv-cpos));\n\t\t\tcpos.x += 3.5;\n\t\t\tdc += Digit(fract(iTime)*30.0,floor(uv-cpos));\n\t\t\tcpos.x += 3.5;\n\t\t\tdc += Digit(fract(iTime)*60.0,floor(uv-cpos));\n\t\t\tcpos.x += 3.5;\n\t\t\tdc += Digit(fract(iTime)*100.0,floor(uv-cpos));\n\n\t\t\tvec3 cl2 = vec3(dc)*vec3(1,1,1);\n\n\t\t\tuv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t\t\tcl2 += wave(uv, 0.55, 0.25, 0.0, 0.2, vec3(1.0, 1.0, 1.0), 0.03, 15.0);\n\t\t\tcl2 += wave(uv, 0.78, 0.17, 0.0, 0.5, vec3(1.0, 1.0, 1.0), 0.05, 15.0);\n\t\t\tcl2 += wave(uv, 0.68, 0.05, 0.0, 0.3, vec3(1.0, 1.0, 1.0), 0.07, 15.0);\n\n\t\t\tfragColor = cl-vec4(cl2,1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t23Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t23Dz", "name": "Spirit", "author": "Eddh", "description": "I made something like a spirit, inspired a bit by wisps from warcraft3. It looked totally different on my computer though. I had to change it a lot to get something half correct. It's still not as good as on my computer :(", "tags": ["coherentnoise"], "likes": 3, "viewed": 233, "date": "1428246773", "time_retrieved": "2024-06-20T18:19:37.801271", "image_code": "//the code is probably a mess, sorry\n\n//noise and hash function from iq if I remember correctly\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 p, float gain, float lacunarity){\n\tfloat val = noise(p);\n\tfloat current;\n\tfloat f = lacunarity;\n\tfor(int i=0 ; i<7 ; i++){\n\t\tcurrent =  noise((p+vec2(0, 0.3*iTime))*f)*gain;\n\t\tval += current;\n\t\t\n\t\tf*= lacunarity;\n\t}\n\t\t\tval*=(val+1.0)*(val+1.0);\n\treturn abs(val);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 center = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n\tfloat nX = fragCoord.x/iResolution.x;\n\tfloat nY = fragCoord.y/iResolution.y;\n\tfloat dx = abs(nX-center.x);\n\tfloat dy = abs(nY-center.y);\n\tfloat x = nX-center.x;\n\tfloat y = nY-center.y;\n\tfloat tmpy;\n\tif(y > 0.0)\n\t\ttmpy = (1.0-y)*(1.0-y);\n\telse\n\t\ttmpy = sqrt(-y+1.0);\n\t\t//tmpy = (1-y)*(1-y);\n\tfloat trueDistFromCenter = length(vec2(dx*2.0, nY-center.y-0.20));\n\tfloat distFromCenter = length(vec2( dx*tmpy*2.0,\n\t\t\t\t\t\t\t\t\t\ty*0.5))*2.0;\n\t\n\tfloat val = fbm(vec2(x*7.0*tmpy, y*2.0 + 0.6*iTime), 0.6, 1.83);\n\t//val*=val;\n\tif(val < 0.0)\n\t\tval =val*0.5;\n\t\tval/= distFromCenter*50.0;\n\tval = 0.03/(trueDistFromCenter*0.8) + 10.0*val/(trueDistFromCenter*50.0)*0.3/(trueDistFromCenter*5.0);\n\tfloat val2 = val*0.7-0.1;\n\tfloat red = 0.15*fragCoord.x/iResolution.x + 0.05*sin(iTime)+ val2*val2*val2*val2*val2*3.0-0.1;\n\tfloat green = 0.15*fragCoord.y/iResolution.y + val*val*val - 0.1;\n\tfloat blue = val*val*val*5.0 -0.1;\n\t\n\t\t\n\t\n\tfragColor = vec4(red, green , blue , 1.0);\n\t//outColor = vec4(val, 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t23Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4t2Gzy", "name": "Strange place", "author": "erucipe", "description": "noise, voronoi, smoothmin, terrain and pinkish sky", "tags": ["terrain"], "likes": 11, "viewed": 289, "date": "1430045682", "time_retrieved": "2024-06-20T18:19:37.801271", "image_code": "const float pi = 3.141592653589793;\n\nfloat hash2(vec2 p) {\n    return fract(sin(p.x * 15.73 + p.y * 35.29) * 43758.29);    \n}\n\nfloat shash2(vec2 p) {\n    return hash2(p) * 2.0 - 1.0;\n}\n\nvec2 hash22(vec2 p) {\n    return fract(sin(mat2(15.23, 35.76, 75.48, 153.69) * p) * 43758.29);\n}\n\nfloat noise2(vec2 p) {\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0 - 2.0*f);\n    \n    float lt = hash2(g + vec2(0.0, 1.0));\n    float rt = hash2(g + vec2(1.0, 1.0));\n    float lb = hash2(g + vec2(0.0, 0.0));\n    float rb = hash2(g + vec2(1.0, 0.0));\n    \n    float t = mix(lt, rt, f.x);\n    float b = mix(lb, rb, f.x);\n    return mix(b, t, f.y);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp((b - a) / k * 0.5 + 0.5, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * ( 1.0 - h);\n}\n\nfloat voronoi(vec2 p) {\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    float d = 1000.0;\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 b = vec2(i, j);\n            d = smin(d, length(hash22(g + b) + b - f), 0.2);\n        }\n    }\n    return d;\n}\n\nfloat pulse(float d, float w, float k) {\n    return smoothstep(w + k, w, d) - smoothstep(-w, -w - k, d);\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y - 0.2 * voronoi(p.xz * 2.0) + 2.0 * noise2(p.xz);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float r = p.y + 0.5;\n    float d = sdPlane(p) * 0.5;\n    d = smin(d, r, 0.1);\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(-1.0, 1.0) * 0.0001;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yxy * map(p + e.yxy) +\n        e.yyx * map(p + e.yyx) +\n        e.xxx * map(p + e.xxx)\n    );\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t);\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.0, 3.0 - iTime);\n    vec3 ta = vec3(0.0, 0.5, 0.0 - iTime);\n    vec3 cw = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(p.x * cu + p.y * cv + 3.0 * cw);\n    \n    float e = 0.0001;\n    float t = 0.0;\n    float h = e * 2.0;\n    for(int i = 0; i < 60; i++) {\n        if(h < e || t > 20.0) continue;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    \n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(0.0, 0.5, -1.0));\n    float dif = dot(nor, lig);\n    float fre = dot(nor, rd) + 1.0;\n    float fog = clamp(exp(-1.0 * (t - 15.0)), 0.0, 1.0);\n    float sh = 0.2 + 0.8 * clamp(softshadow(pos, lig, 0.02, 20.0, 7.0), 0.0, 1.0);\n    float j = sin(noise2(pos.xz) * 3.141592 + iTime * 0.1);\n    vec3 col = vec3(0.0, cos(j * 3.141592 * 2.0) * 0.5 + 0.5, sin(j * 3.141592 * 20.0) * 0.5) * dif + fre * 0.3;\n    col *= sh;\n    col += fre * 0.2;\n    vec3 sun = vec3(1.0, 1.0, 0.0) * 0.3 / length(p.xy - vec2(0.0, 0.25));\n    vec3 bg = vec3(0.8, 0.8 - (p.y * 0.5 + 0.5) * 0.7, 0.7) + sun;\n\t\n    col = mix(bg, col, fog);\n    if(t > 20.0) col = bg;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4t2Gzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tB3RG", "name": "ngEyeWarp0", "author": "netgrind", "description": "stare into the center of the screen for at least ten seconds (the longer the better) then look away\n\nchange define WARP to 0 for a hyper symmetric experience\n\nbased off of part of Illustrated Equations by sben - https://www.shadertoy.com/view/MtBGDW", "tags": ["blackandwhite", "trippy", "lsd", "white", "black", "netgrind", "eyewarp"], "likes": 6, "viewed": 1411, "date": "1429774164", "time_retrieved": "2024-06-20T18:19:37.801271", "image_code": "//based off of part of Illustrated Equations by sben - https://www.shadertoy.com/view/MtBGDW\n//stare into the center of the screen for at least ten seconds (the longer the better) then look away\n\n//change define WARP to 0 for a hyper symmetric experience\n#define BLUR 3\n#define WARP 1\n\nvec2 wolfFaceEQ(vec3 p, float t){\n\tvec2 fx = p.xy;\n\tp=(abs(p*2.0));\n\tconst float j=float(15);\n\tvec2 ab = vec2(2.0-p.x);\n\tfor(float i=0.0; i<j; i++){\n\t\tab+=(p.xy)-cos(length(p));\n\t\tp.y+=sin(ab.x-p.z)*0.5;\n\t\tp.x+=sin(ab.y+t)*0.5;\n\t\tp-=(p.x+p.y)*(sin(t)*.001+.97);\n\t\tp+=(fx.y+cos(fx.x));\n\t\t//ab += vec2(p.y);\n\t}\n\tp/=10.;\n\tfx.x=(p.x+p.x+p.y);\n\treturn fx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.y*=1.1;\n    uv.y = abs(uv.y);\n    uv.x+=tan(uv.y)*float(WARP);\n    uv.y+=iTime*.1;\n    uv.y = abs(mod(uv.y,1.8)-.9);\n    uv.y+=sin(iTime*.1)*.1+.1;\n    //uv.y = sin(uv.y*2.)*.5+.5;\n    //uv.x = mod(uv.x+.2,.4)-.2;\n    \n    vec3 c = vec3(0.0);\n   \n    \n    for(int i = 0; i<BLUR; i++){\n        c += wolfFaceEQ(vec3(uv.xy,5.)*30., iTime-.05*float(i)).xyx; \n    }\n    c/= float(BLUR);\n    \n    c.x = pow(c.x,2.);\n\tfragColor = vec4(c.xxx,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tBGWR", "name": "living marble", "author": "diviaki", "description": "animated marble texture inspired by http://lodev.org/cgtutor/randomnoise.html", "tags": ["procedural", "texture"], "likes": 23, "viewed": 561, "date": "1427839789", "time_retrieved": "2024-06-20T18:19:38.134362", "image_code": "//#define SLOWMOTION\n//#define MOD_KazimirO\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\n#ifdef MOD_KazimirO\n    return -1.0 + 2.0*fract(sin(h)*0.0437585453123*iTime);\n#else\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n#endif\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat t( in vec2 coord )\n{\n    float\n     value = noise(coord / 64.) * 64.;\n    value += noise(coord / 32.) * 32.;\n    value += noise(coord / 16.) * 16.;\n    value += noise(coord / 8.) * 8.;\n    value += noise(coord / 4.) * 4.;\n    value += noise(coord / 2.) * 2.;\n    value += noise(coord);\n    value += noise(coord / .5) * .5;\n    value += noise(coord / .25) * .25;\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timeScale=\n    #ifdef SLOWMOTION\n        0.1;\n    #else\n        1.0;\n    #endif\n\tvec2 zoomCoord=fragCoord*.1;\n    float v=0.5+0.5*sin(zoomCoord.x+zoomCoord.y+t(zoomCoord+iTime*timeScale));\n\tfragColor = vec4(v+.1,v,v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tBGWw", "name": "Rasen no Yami", "author": "reuben364", "description": "Darkness of the Spiral", "tags": ["chuunibyou"], "likes": 2, "viewed": 103, "date": "1429272770", "time_retrieved": "2024-06-20T18:19:38.298222", "image_code": "#define time (iTime*1000.)\n#define resolution (iResolution.xy)\n\n#define PI 3.1415\nmat2 rotate(float theta) {\n\treturn mat2(\n\t\tcos(theta), -sin(theta),\n\t\tsin(theta), cos(theta)\n\t);\n}\n\nfloat grid(vec2 pos) {\n\tvec2 val = sin(pos);\n\treturn max(val.x, val.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = fragCoord / resolution;\n\tpos-=.5;\n\tvec2 spiralPos = rotate(sin(time/1000.)*length(pos))*pos;\n\tspiralPos*=100.;\n\tfloat mul = min(1.+sin(time/500.+length(pos)),1.);\n\tfragColor = mix(vec4(.5,0,0,0),mul*vec4(0,.5,0,0),grid(spiralPos));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tBGzy", "name": "testShaderTsuba", "author": "Tsubaki", "description": "test", "tags": ["test"], "likes": 3, "viewed": 137, "date": "1429804485", "time_retrieved": "2024-06-20T18:19:39.589153", "image_code": "// Rotation ------------------------------------------------------------\n \n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Noise ------------------------------------------------------------\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n \nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n \n//fonction de bruit sur 4 octaves\nfloat bruit(in vec3 p, in float frequence)\n{\n    float f;\n    vec3 q = frequence*p;\n    f  = 0.7000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    f /= 0.5+0.25+0.125+0.0625;\n    return f;\n}\n\n// Couleur ------------------------------------------------------------\nconst vec3 red=vec3(0.4,0.137,0.047);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 blue=vec3(0.0,0.0,1.0);\nconst vec3 black = vec3(0.0,0.0,0.0);\nconst vec3 white = vec3(1.0,1.0,1.0);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 greyWhite = vec3(0.7,0.7,0.7);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 salmon = vec3(0.835,0.611,0.482);\nconst vec3 redSalmon = vec3(1,0.611,0.482); \nconst vec3 bleuCiel = vec3(0.0,0.4,1.0);\nconst vec3 bois1 = vec3(252.0/255.0, 221.0/255.0, 175.0/255.0);\nconst vec3 bois2 = vec3(0.674, 0.560, 0.388);\nconst vec3 green = vec3(0.0,0.8,0.0);\nconst vec3 darkGreen = vec3(0.0,0.3,0.0);\n\n// Texture ------------------------------------------------------------\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return salmon;\n}\n\nvec3 rouille(in vec3 p,in vec3 n)\n{\n    float f = bruit(p, 10.0);\n    float seuil=0.65;\n\tif(f > seuil)\n    {\n        return mix(red,yellow,(f-seuil)/(1.0-seuil));\n    }\n    else\n    {\n        return mix(grey2,grey,f/seuil);\n    }   \n}\n\nvec3 granite(in vec3 p, in vec3 n)\n{\n    float f = bruit(p, 100.0);\n    float g = bruit(p, 50.0);\n    \n    float seuilGrey2 = 0.62;\n    float seuilGrey = 0.5;\n    \n    if (f > seuilGrey2)\n    {\n        if(g> seuilGrey)\n        {\n            return grey2; \n        }\n    \telse\n        {\n        \treturn grey;\n        }\n    } else {\n    \treturn mix(redSalmon,salmon, f);    \n    }   \n}\n\nvec3 boisIrregulier(in vec3 p, in vec3 n)\n{\n    float noiseValue = 0.8*noise(3.0*p);\n    noiseValue += 0.2*noise(10.0*p);\n    \n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    \n    float val=pow(mod(8.0*(sqrt(dot(pa,pa))*0.9+noiseValue*0.1),1.0),2.0);\n    float v=0.6*(1.0+cos(val));\n    return mix(bois2,bois1,v);\n}\n\nvec3 bois(in vec3 p, in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.6*(1.0+cos(pow(mod(10.0*sqrt(dot(pa,pa)),1.0),2.0)));\n    return mix(bois2,bois1,v);\n}\n\nvec3 marbre(in vec3 p, in vec3 n)\n{\n    float f = bruit(p, 8.0);\n    float seuil=0.6;\n    \n    if(f > seuil)\n    {\n        return mix(grey,white,f);\n    }\n    else if (f > seuil-0.03)\n    {\n        return grey;\n    }\n    else \n    {\n        return mix(grey,white,2.0*seuil-f);\n    }\n}\n\nvec3 terre(in vec3 p, in vec3 n)\n{\n    \n    float f = bruit(p, 5.0);\n    float seuil=0.65;\n\tif(f > seuil)\n    {\n        return mix(darkGreen,green,(f-seuil)/(1.0-seuil));\n    }\n    else\n    {\n        return bleuCiel;\n    }   \n}\n\nvec3 terreNuage(in vec3 p, in vec3 n)\n{\n    float f = bruit(p, 3.5);\n    float seuil = 0.55;\n    if(f < seuil)\n    {\n        return terre(p,n);\n    }\n    else\n    {\n        return mix(terre(p,n),white,(f-seuil)/(1.0-seuil));\n    }\n}\n\n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.6*(1.0+cos(500.0*sqrt(dot(pa,pa))));\n    return mix(red,yellow,v);\n}\n \n// Objects --------------------------------------------------------------\n \n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n    vec3 oc = o-c;\n   \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n      \n    if (t<=0.0) return false;\n   \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n   \n    // Normal\n    n=(o+t*d-c)/r;\n \n   return true;\n}\n \n// Lighting -------------------------------------------------------------\n \n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n \n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n \n    vec3 l = normalize(lightPos - p);\n \n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)*dot(n, l));\n \n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*terreNuage(p,n)*diff*lightColor;\n \n    return c;\n}\n \n// Vignetting    \n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n    return c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n\n// Main -----------------------------------------------------------------\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n   \n    // Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    vec3 d = normalize(vec3(uv, 1.0));\n               \n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n   \n    vec3 n;\n    float t;\n   \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {         \n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tjGRK", "name": "Untitled #3", "author": "kindofsleepy", "description": "Blobs and lighting", "tags": ["2d"], "likes": 0, "viewed": 143, "date": "1430358403", "time_retrieved": "2024-06-20T18:19:40.407472", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define POINTS 25.0\n#define RADIUS 500.0\n#define BRIGHTNESS 0.45\n#define COLOR vec3(1.0, 1.0, 0.0)\n#define SMOOTHNESS 40.0\n#define PI 3.14149\n#define LAG_A 0.325\n#define LAG_B 0.825\n#define LAG_C 0.825\nvec2 uv = gl_FragCoord.xy;\nvec4 fragCoord = gl_FragCoord;\nvec2 rand22(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// i just faked the vec3 version frin the one above by adding random numbers, no idea if it's \"correct\"\nvec3 rand33(in vec3 p)\n{\n\treturn fract(vec3(sin(p.x * 591.32 + p.y * 154.077 + p.z * 712.223 ), cos(p.x * 391.32 + p.y * 49.077 + p.z * 401.326), cos (p.x * 1010.22 + p.y * 27.311 + p.z* 131.44)));\n}\n\tvec2 vUv = ( fragCoord.xy / iResolution.xy );\nfloat nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvec2 rot2d( vec2 p, float a ) {\n\tvec2 sc = vec2(sin(a),cos(a));\n\treturn vec2( dot( p, vec2(sc.y, -sc.x) ), dot( p, sc.xy ) );\n}\nvec4 circularBlur(){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= 0.1 *iTime;\n\n\tfloat maxofs = 12.0 * (0.5+0.5*sin( iTime ));\n\tconst int NUM_SAMPLES = 16;\n\tconst int NUM_SAMPLES2 = NUM_SAMPLES/2;\n\tconst float NUM_SAMPLES_F = float(NUM_SAMPLES);\n\tconst float anglestep = 30.28 / NUM_SAMPLES_F;\n\tconst float MIPBIAS = -8.0; //note: make sure we always pick mip0\n\n\t//note: rand\n\tfloat rnd = nrand( 0.01*fragCoord.xy );//+ fract(iTime) );\n\t\n\t//note: ordered dither\n\t//float rnd = texture( iChannel1, fragCoord.xy / 8.0 ).r;\n\n\t//note: create halfcircle of offsets\n\tvec2 ofs[NUM_SAMPLES];\n\t{\n\t\tfloat angle = 3.1416*rnd;\n\t\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\t{\n\t\t\tofs[i] = rot2d( vec2(maxofs,0.0), angle ) / iResolution.xy;\n\t\t\tangle += anglestep;\n\t\t}\n\t}\n\t\n\tvec4 sum = vec4(0.0);\n\t//note: sample positive half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += texture( iChannel0, vec2(uv.x, uv.y)+ofs[i], MIPBIAS );\n\n\t//note: sample negative half-circle\n\tfor( int i=0;i<NUM_SAMPLES2;++i )\n\t\tsum += texture(iChannel0, vec2(uv.x, uv.y)-ofs[i], MIPBIAS );\n\t\n\treturn vec4((sum.rgb / NUM_SAMPLES_F),texture( iChannel1, vUv ));\n}\n\nfloat dst(vec3 r) {\n\t//return max(abs(r.x), abs(r.y));\n\treturn length(r);\n}\n\n\nvec3 getPoint(float n) {\n    vec4 texture1 = texture(iChannel1, vUv, -0.8);\n\tvec2 p = ( fragCoord.xy / iResolution.xy );\n\t\n    float theta = (3.14149) /sin(4.0);\n\t#define time time + atan(p.x, p.y)*2.0\n    \n\tmat2 m = mat2(sin(theta), sin(theta)/ iTime, sin(theta)/ iTime, tan(theta));\n\t \n    p = p * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tp = m * p;\n\t\n    vec2 f = fract(p * 5.0);\n\tf = 2.0 * f - 1.0;\n\t\n\tfloat df = distance(f, vec2(0.0, 0.0));\n\tdf = 3.0*df*df - 2.0*df*df*df;\n\t\n    //df /= texture1.r;\n    float dp = max(1.5 - distance(p, vec2(0.0, 0.0)), 0.0);\n\t\n    dp = 3.0*dp*dp - 2.0*dp*df*df;\n\t\n    float from = 0.3 + sin(dp * PI * 0.5 + iTime * 0.5) * 0.75;\n\tfloat to = from + 0.05;\n    \n    vec3 d = texture(iChannel0,uv+iTime*0.05).xyz;\n     float t = iTime * 0.1;\n     vec2 center = iResolution.xy / 2.0;\n   \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n       \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n       \n     p += vec2(d.x + texture1.x,d.x * texture1.x) * dp * sin(t *  3.5 + n * LAG_A);\n     p += vec2(d.y + texture1.y,d.y * texture1.y) * dp * sin(t *  4.5 + n * LAG_B);\n     p += vec2(d.z + texture1.z,d.z * texture1.z) * 50.0 * sin(t *  4.0 + n * LAG_C);\n    \n    \n     p += vec2(100.0, 0.0) * sin(t *  2.5 + n * LAG_A)\n          - vec2(110.0, 100.0) * sin(t * -1.5 + n * LAG_B)\n          + vec2(150.0, 100.0) * cos(t * 0.05 + n * LAG_C)\n          - vec2(150.0, 0.0) * sin(t * 0.15 + n);\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n        p += vec2(100.0, 0.0) * sin(t *  2.5 + n * LAG_A)\n          + vec2(110.0, 100.0) * sin(t * -1.5 + n * LAG_B)\n          + vec2(150.0, 100.0) * cos(t * 0.05 + n * LAG_C)\n          + vec2(150.0, 0.0) * sin(t * 0.15 + n);\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n\n     p += vec2(150.0, 0.0) * sin(t * 0.15 + n);\n   \t\n   \n  \n     return vec3(center + p.xy,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     vec2 position = fragCoord.xy;\n    \t\n     float b = 0.3;\n    \n     for (float i = 0.0; i < POINTS; i += 0.8) {\n          vec3 p = getPoint(i);\n          float d = 1.0 - clamp(distance(p.xy, position) / RADIUS, 0.0, 0.5);\n          b -= pow(d, SMOOTHNESS);\n     }\n    \n     vec3 c = 0.9 - b+(\n            (sin(b * 0.0) - 0.25) * vec3(0.3, 0.1, 1.0)\n         \n          + clamp(1.0 - b, 1.0, 1.0) * (cos(b * 10.0) + 1.25) \n     );\n    \n\n     fragColor = vec4(c * BRIGHTNESS, 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tjGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tS3DD", "name": "Particle Experiment 3.1", "author": "aiekick", "description": "Particle Experiment 3.1", "tags": ["particleexperiment31"], "likes": 16, "viewed": 1744, "date": "1428954793", "time_retrieved": "2024-06-20T18:19:40.413603", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+5.;\n        \n    // vars\n    float z = 2.5;\n    \n    const int n = 200; // particle count\n    \n    vec3 startColor = normalize(vec3(1.,0.,0.));\n    vec3 endColor = normalize(vec3(0.2,0.2,.8));\n    \n    float startRadius = 0.3;\n    float endRadius = 0.8;\n    \n    float power = 0.6;\n    float duration = 8.;\n    \n    vec2 \n        s = iResolution.xy,\n\t\tv = z*(2.*fragCoord.xy-s)/s.y;\n    \n    // Mouse axis y => zoom\n    if(iMouse.z>0.) v *= iMouse.y/s.y * 20.;\n    \n    // Mouse axis x => duration\n    if(iMouse.z>0.) duration = iMouse.x/s.x * 10.;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 pm = v.yx*2.8;\n    \n    float dMax = duration;\n    \n    float mb = 0.;\n    float mbRadius = 0.;\n    float sum = 0.;\n    for(int i=0;i<n;i++)\n    {\n        float d = fract(t*power+48934.4238*sin(float(i)*692.7398))*duration;\n    \tfloat a = 6.28*float(i)/float(n);\n         \n        float x = d*cos(a);\n        float y = d*sin(a);\n        \n        float distRatio = d/dMax;\n        \n        mbRadius = mix(startRadius, endRadius, distRatio); \n        \n        v = mod(v,pm) - 0.5*pm;\n        \n        vec2 p = v - vec2(x,y);\n    \t\n        p = mod(p,pm) - 0.5*pm;\n        \n        mb = mbRadius/dot(p,p);\n    \t\n        sum += mb;\n        \n        col = mix(col, mix(startColor, endColor, distRatio), mb/sum);\n    }\n    \n    sum /= float(n);\n    \n    col = normalize(col) * sum;\n    \n    sum = clamp(sum, 0., .4);\n    \n    vec3 tex = vec3(1.);\n     \n    col *= smoothstep(tex, vec3(0.), vec3(sum));\n        \n\tfragColor.rgb = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tS3zy", "name": "Testing kuranes's normal deriv.", "author": "luutifa", "description": "Code from https://www.shadertoy.com/view/4lS3RG, just added a test light.", "tags": ["lighting", "normal"], "likes": 4, "viewed": 194, "date": "1429809599", "time_retrieved": "2024-06-20T18:19:40.413603", "image_code": "\nconst float heightScale = 0.0125;\nconst vec4 rgb2lum = vec4(0.2126, 0.7152, 0.0722, 0.0);\n\nfloat sampleHeight(in vec2 coord)\n{\n    \n    return heightScale * \n        dot(texture(iChannel0, coord), rgb2lum);\n} \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n \n    float dHdU;\n    float dHdV;\n    \n    float h0 = sampleHeight(uv);\n    \n    float split = uv.x - iMouse.x/iResolution.x;\n    if (split > 0.0)   {\n      \n       dHdU = -dFdx(h0) / dFdx(uv.x);\n       dHdV = -dFdy(h0) / dFdy(uv.y);\n        \n    }\n    else{\n    \tvec2 du = vec2(1.0 / 1024.0, 0.0);\n    \tvec2 dv = vec2(0.0, 1.0 / 1024.0);\n    \tfloat hpx = sampleHeight(uv + du);\n    \tfloat hmx = sampleHeight(uv - du);\n    \tfloat hpy = sampleHeight(uv + dv);\n    \tfloat hmy = sampleHeight(uv - dv);\n    \n        dHdU = (hmx - hpx) / (2.0 * du.x);\n        dHdV = (hmy - hpy) / (2.0 * dv.y);\n    }\n    vec3 normal = normalize(vec3(dHdU, dHdV, 1.0));\n   \tvec3 light = vec3(sin(iTime)*3.0, 0.0, -1.0);\n    \n    float l = 1.0/length(vec3((uv-vec2(0.5)), 0.0) - light) * max(dot(normalize(vec3((uv-vec2(0.5)), 0.0)-light), normal), 0.0);\n    fragColor = vec4(vec3(l), 1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tSGWD", "name": "Bouncing sun metaballs", "author": "frankier", "description": ":)", "tags": ["2d", "sun", "metaballs", "sky"], "likes": 4, "viewed": 196, "date": "1428917200", "time_retrieved": "2024-06-20T18:19:40.413603", "image_code": "#define THRESH 0.001\n#define LBLUE vec3(128.0 / 255.0, 188.0 / 255.0, 248.0 / 255.0)\n#define DBLUE vec3(4.0 / 255.0, 52.0 / 255.0, 196.0 / 255.0)\n#define CLOUD vec3(251.0 / 255.0, 251.0 / 255.0, 253.0 / 255.0)\n\nfloat metaball(in vec2 location, in vec2 fragCoord) {\n    return 1.0 / (\n        pow(location.x - fragCoord.x, 2.0) +\n        pow(location.y - fragCoord.y, 2.0));\n}\n\nfloat tri(in float x) {\n    return abs(fract(x) * 2.0 - 1.0);\n}\n\nvec2 ballPos(in float time) {\n    return vec2(\n        tri(time * 0.12) * iResolution.x,\n        abs(sin(time * 2.5)) * iResolution.y * 0.9);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos1, pos2, pos3, pos4, pos5;\n    pos1 = ballPos(iTime);\n    pos2 = ballPos(iTime + 8.0);\n    pos3 = ballPos(iTime * 0.9 + 13.5);\n    pos4 = ballPos(iTime * 1.04 + 2.5);\n    pos5 = ballPos(iTime * 0.97 + 8.5);\n    float sum = metaball(pos1, fragCoord) +\n                metaball(pos2, fragCoord) +\n                metaball(pos3, fragCoord) + \n                metaball(pos4, fragCoord) +\n                metaball(pos5, fragCoord);\n    vec3 skyCol = mix(LBLUE, DBLUE, fragCoord.y / iResolution.y);\n\tfragColor = vec4(mix(skyCol, vec3(0.0, 0.0, 0.0), THRESH - sum / THRESH), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4tSGWR", "name": "bobbing grass", "author": "public_int_i", "description": "waving grass, work in progress\n\nmy goal is to make the grass model better and to fix the lighting artifacts", "tags": ["grass", "bobbing"], "likes": 2, "viewed": 246, "date": "1428108336", "time_retrieved": "2024-06-20T18:19:40.413603", "image_code": "\n#define epil .01\n\nconst vec3 ne = vec3(.04,0,0);\n\nvec3 lightDir = normalize(vec3(2.,20.,4.));\n\n\nconst vec2 repSize = vec2(1.,1.);\nconst vec2 repSize2 = vec2(.5,.5);\nfloat one_grass(in vec3 rp) {\n    vec3 dp = vec3( mod(rp.xz,repSize)-repSize2,\n                   rp.y).xzy;\n\n    dp.x += pow(cos(rp.y),6.)*cos(iTime+floor(rp.x)+floor(rp.z));\n    \n    dp.y += 1.;\n    dp.y *= .1;\n    \n    return (length(dp)-.02);\n}\nfloat grass(in vec3 rp) {\n\treturn min(one_grass(rp),min(one_grass(rp+vec3(0.75,0.,0.75)),min(one_grass(rp+vec3(0.75,0.,0.5)),min(one_grass(rp+vec3(0.75,0.,0.25)),min(one_grass(rp+vec3(0.75,0.,0)),min(one_grass(rp+vec3(0.5,0.,0.75)),min(one_grass(rp+vec3(0.5,0.,0.5)),min(one_grass(rp+vec3(0.5,0.,0.25)),min(one_grass(rp+vec3(0.5,0.,0)),min(one_grass(rp+vec3(0.25,0.,0.75)),min(one_grass(rp+vec3(0.25,0.,0.5)),min(one_grass(rp+vec3(0.25,0.,0.25)),min(one_grass(rp+vec3(0.25,0.,0)),min(one_grass(rp+vec3(0,0.,0.75)),min(one_grass(rp+vec3(0,0.,0.5)),min(one_grass(rp+vec3(0,0.,0.25)),one_grass(rp+vec3(0,0.,0))))))))))))))))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n\tvec3 rp = vec3(0,0,0);\n    vec3 rd = vec3(0,0,1);\n    rd = normalize(cross(rd,vec3(0,1,0))*uv.x+vec3(rd.x,rd.y+uv.y,rd.z));\n    \n    float d,len = 0.;\n    for (int i = 0; i < 90; i++) {\n        d = min(grass(rp),rp.y+1.);\n        if (d < epil) {\n            break;\n        }\n        \n        rp += rd*d;\n    \tlen += d;\n    }\n    \n    if (len < 50.) {\n        if (grass(rp) < epil) {\n            \n            vec3 norm = normalize(vec3(grass(rp+ne)-grass(rp-ne),\n                                  grass(rp+ne.yxz)-grass(rp-ne.yxz),\n                                  grass(rp+ne.zyx)-grass(rp-ne.zyx)));\n            \n            vec3 c = vec3(.2,.8,.4);\n            c = c*.2 + c*max(0.,dot(lightDir,norm));\n            \n            fragColor = vec4(c,1);\n            \n        } else {\n        \n        \tif (rp.y+1. < epil) {\n                \n                vec3 c = texture(iChannel0,rp.xz).xyz;\n                c = c;\n                \n        \t\tfragColor = vec4(c,1);\n            } else {\n                fragColor = vec4(1);\n            }\n            \n        }\n    } else {\n        fragColor = vec4(1);\n    }\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll23DD", "name": "Blinking Colors", "author": "reuben364", "description": "blinking colors", "tags": ["colors", "blinking"], "likes": 0, "viewed": 161, "date": "1429271982", "time_retrieved": "2024-06-20T18:19:40.510542", "image_code": "#define time (iTime*1000.)\n#define resolution (iResolution.xy)\n\n#define PI 3.1415\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat offset = length(fragCoord/resolution-.5)*(1.5+sin(time/3000.));\n\tfragColor = (1.-offset)*vec4(.5*(1.+sin(time/500.)),.5*(1.+sin(time/500.+PI/3.)),.5*(1.+sin(time/500.+2.*PI/3.)),0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll23DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll23WR", "name": "Troubled sky", "author": "andregc", "description": "Experiment with 2d sky ", "tags": ["2dnoise", "sky", "lightning"], "likes": 11, "viewed": 399, "date": "1428264761", "time_retrieved": "2024-06-20T18:19:40.510542", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat ltTime = 0.;\nfloat fbm(vec2 n, vec2 center) {\n    vec2 dist = n - center;\n    float r = length(dist);\n    n *= 1.4;\n\n\tfloat total = 0.0, amplitude = 1.0;\n    float intencity = (2. - r) * noise(vec2(r*1. + iTime*0.8,n.x));\n    intencity = intencity * exp(-(ltTime-0.5)*(ltTime-0.5)*20.)*2.;//*noise(vec2(2.*iTime));\n    if (intencity < 0.) {\n        intencity = 0.;\n    }\n    \n\tfor (int i = 0; i <4; i++) {\n\t\t//total += noise(n + vec2(0., (amplitude)*iTime*0.8)) * amplitude;\n        float v = noise(n ) * amplitude;\n        v *= (1. + intencity * float(3-i)*1.);\n        total += v;\n        \n        \n        \n\t\tn += n;\n        //n.y += (amplitude)*iTime*0.8;\n        n.y += iTime*float(i+1)*0.2;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5, 0.);\n\n    \n    \n    vec3 r=vec3(uv.x, uv.y, 1);\n    r *= 2./ uv.y;\n    //r.xz = uv;\n    \n    float fog = exp(-(r.z-3.)*0.2);\n    if (fog > 1.) {\n        fog = 1.;\n    }\n    vec4 fogColor = vec4(0.5, 0.8, 1.0, 1.);\n    \n    vec2 per = vec2(0.1, 0.12121);\n    vec2 rnd = per*iTime;\n    vec2 s1 = fract(rnd)/per;\n    vec2 s2 = (1.-fract(rnd))/per;\n    rnd = floor(rnd);\n    \n    float t1 = min(s1.x, s1.y);\n    float t2 = min(s2.x, s2.y);\n    ltTime = t1/(t1+t2);\n   \n    \n\n    float c = fbm(r.xz, vec2(rand(rnd), 3.+rand(rnd*1.21)*5.))/2.;\n    vec4 res = mix(vec4(0.8,0.8,1,0), vec4(0,0,1,0), c);\n  \n\n     res = mix(c*vec4(0.8,0.8,1,0), fogColor*0.3, 1.-fog)*0.8;\n    \n    \n\tfragColor = vec4(res);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll23WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ll2GWm", "name": "Red Spiral", "author": "Normangorman", "description": "It's a red spiral.", "tags": ["spiral"], "likes": 3, "viewed": 96, "date": "1429792608", "time_retrieved": "2024-06-20T18:19:40.510542", "image_code": "#define PI 3.141592653\n#define E 2.71828\n\n// Returns 1 for a point on the spiral, 0 for not, [0,1] for on the edge for antialiasing.\nfloat inSpiral(vec2 p) {\n    // Using formula r = a*theta + b\n    \n    float r = length(p);\n    float a = 0.1;\n    float b = sin(iTime) * 1.5;\n    float theta = (r-b)/a;\n    \n    vec2 s = vec2(r * cos(theta), r * sin(theta));\n    float d = length(p - s);\n    \n    return 1.0 - smoothstep(0.0, 1.0, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 spiralColor = vec3(1.0, 0.0, 0.0); // red\n    vec3 bgColor = vec3(45.0/255.0, 187.0/255.0, 40.0/255.0); // black\n    \n    vec3 ret = bgColor;\n    /*\n    float spiral = inSpiral(uv);\n    if (length(spiral) > 0.01) {    \n    \tret = spiralColor * inSpiral(uv);\n    }\n    else {\n        ret = bgColor;\n    }\n\t*/\n    \n    ret = mix(bgColor, spiralColor, inSpiral(uv));\n    \n    fragColor = vec4(ret, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llB3DW", "name": "Mod Pseudo 3D", "author": "Slyth", "description": "Testing pseudo 3D with mod", "tags": ["3d", "mod"], "likes": 1, "viewed": 181, "date": "1429204896", "time_retrieved": "2024-06-20T18:19:40.674204", "image_code": "const float fovVal = 0.4; // not really fov, but meh\nconst float doRadical = 1.0; // 0.0 to disable, 1.0 for regular, 100.0 for acid trip\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.y = uv.y * 2.0 - 1.0 + cos(iTime * 1.5) * 0.5; // y rot\n    uv.x = uv.x * 2.0 - 1.0 + sin(iTime * 1.5) * 0.5; // x rot\n    \n    float xMod = doRadical != 0.0 ? 1.0 / (uv.x * fovVal) * doRadical : uv.x * fovVal;\n        \n    float a = mod(xMod, abs(uv.y)); // main func w/ radical\n    \n    a *= doRadical != 0.0 ? 1.0 + smoothstep(0.0, 0.5, uv.x) - smoothstep(0.0, 0.5 + (1.0 - fovVal), uv.x + 0.5 + (1.0 - fovVal)) : 1.0; // fog X\n    \n    a *= 1.0 + smoothstep(0.0, 0.5, uv.y) - smoothstep(0.0, 0.5 + (1.0 - fovVal), uv.y + 0.5 + (1.0 - fovVal)); // fog Y    \n    \n    vec3 color = vec3(cos(iTime * 2.0), sin(iTime * 0.5), 0.5); // diffuse\n    \n\tfragColor = vec4(color * vec3(a, a, a), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llB3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llB3W1", "name": "Fractal Audio 01", "author": "relampago2048", "description": "This shader is a render of the Julia Set, generated by audio input from microphone.", "tags": ["fractal", "mandelbrot", "input", "microphone"], "likes": 82, "viewed": 12323, "date": "1428522186", "time_retrieved": "2024-06-20T18:19:40.680242", "image_code": "const int iters = 150;\n\nint fractal(vec2 p, vec2 point) {\n\tvec2 so = (-1.0 + 2.0 * point) * 0.4;\n\tvec2 seed = vec2(0.098386255 + so.x, 0.6387662 + so.y);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\n\t\tif (length(p) > 2.0) {\n\t\t\treturn i;\n\t\t}\n\t\tvec2 r = p;\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\n\t}\n\t\n\treturn 0;\t\n}\n\nvec3 color(int i) {\n\tfloat f = float(i)/float(iters) * 2.0;\n\tf=f*f*2.;\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\n}\n\n\nfloat sampleMusicA() {\n\treturn 0.5 * (\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n    \n    vec2 position = 3. * (-0.5 + fragCoord.xy / iResolution.xy );\n\tposition.x *= iResolution.x/iResolution.y;\n    \n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);    \n    vec2 pos2 = 2. * (-0.5 + iFC.xy / iResolution.xy);\n    pos2.x*=iResolution.x/iResolution.y;\n    \n    vec4 t3 = texture(iChannel0, vec2(length(position)/2.0,0.1) );\n    float pulse = 0.5+sampleMusicA()*1.8;\n\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime/3.+0.5)/2.0,pulse*.9)));\n    \n    vec3 fract4 = color(fractal(position/1.6,vec2(0.6+cos(iTime/2.+0.5)/2.0,pulse*.8)));\n\n    vec3 c = color(fractal(position,vec2(0.5+sin(iTime/3.)/2.0,pulse)));\n    \n    t3=abs(vec4(0.5,0.1,0.5,1.)-t3)*2.;\n    \n    vec4 fract01 =  vec4( c , 1.0 );\n    vec4 salida;\n    salida = fract01 / t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.3);\n\tfragColor = salida;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llB3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llBGRG", "name": "The Black Shuriken", "author": "GreenSpiny", "description": "Project for Game Architecture, Spring 2015.", "tags": ["2d", "3d", "raymarching", "shuriken"], "likes": 2, "viewed": 112, "date": "1429831911", "time_retrieved": "2024-06-20T18:19:42.419788", "image_code": "// Constants\nconst float PI = 3.1415;\nconst float spinSpeed = 2.5;\nconst float gSpeed = -5.0;\n\n// 2D Background : Movement constants\nconst float bHeight = .45;\nconst float bHeight2 = .48;\nconst float bSpeed = 5.0;\n\n// Spinning shuriken : Blade position\nvec3 bladePos (vec3 anchor, float offset) {\n    return vec3(\n        anchor.x + sin(offset-(PI/12.0)+iTime*spinSpeed),\n        anchor.y + cos(offset-(PI/12.0)+iTime*spinSpeed),\n        0.0);\n}\n\n// Spinning shuriken : Blade angle\nvec3 bladeRot (float offset) {\n    return vec3(0.0,0.0,PI+offset-(PI/6.0)+iTime*spinSpeed);\n}\n\n// ------------------------------------------------------------------- o\n\n// Distance function for a sphere --- o\nfloat sphere (vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\n// Distance function for a box --- o\nfloat box (vec3 pos, vec3 bounds) {\n \tvec3 d = abs(pos) - bounds;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));   \n}\n\n// Distance function for a triangular prism --- o\nfloat triPrism (vec3 pos, vec2 h) {\n    vec3 q = abs(pos);\n    return max(q.z-h.y,max(q.x*0.866025+pos.y*0.5,-pos.y)-h.x*0.5);\n}\n\n// Distance function for a cone --- o\nfloat cone (vec3 p, vec3 c) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Distance functions for a cylinder --- o\nfloat cylinder (vec3 pos, vec2 h) {\n  vec2 d = abs(vec2(length(pos.xz),pos.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance function for an infinite y-axis plane -- o\nfloat plane (vec3 pos) {\n\treturn pos.y;   \n}\n\n// Union - combines two distance functions --- o\nvec2 opUnion (vec2 a, vec2 b) {\n    if (a.x < b.x) {return a;}\n    else           {return b;}\n}\n\n// Subtract - combines two distance functions --- o\nvec2 opSubtract (vec2 a, vec2 b) {\n    if (-a.x > b.x) {return vec2(-a.x,a.y);}\n    else            {return b;}\n}\n\n// Intersect - combines two distance functions --- o\nvec2 opIntersect (vec2 a, vec2 b) {\n    if (a.x > b.x) {return a;}\n    else           {return b;}\n}\n\n// Repeat - uses modulo to repeat distances --- o\nvec3 opRepeat (vec3 pos, vec3 c) {\n    return mod(pos,c)-0.5*c;\n}\n\n// Rotate - rotates a primitive --- o\nvec3 opRotate (vec3 pos, vec3 rot) {\n \tvec3 temp = pos;\n    // x\n    vec3 m1 = vec3(1.0,0.0,0.0);\n    vec3 m2 = vec3(0.0,cos(rot.x),-sin(rot.x));\n    vec3 m3 = vec3(0.0,sin(rot.x),cos(rot.x));\n    temp *= mat3(m1,m2,m3);\n    \n    // y\n    m1 = vec3(cos(rot.y),0.0,sin(rot.y));\n    m2 = vec3(0.0,1.0,0.0);\n    m3 = vec3(-sin(rot.y),0.0,cos(rot.y));\n    temp *= mat3(m1,m2,m3);\n    \n    // z\n    m1 = vec3(cos(rot.z),-sin(rot.z),0.0);\n    m2 = vec3(sin(rot.z),cos(rot.z),0.0);\n    m3 = vec3(0.0,0.0,1.0);\n    return temp * mat3(m1,m2,m3);\n}\n\n// ------------------------------------------------------------------- o\n\n// 2D background effect function\nvec3 effect (vec2 pos) {\n\t\n    vec3 color = vec3(.8*(1.0-pos.y),0.25,0.55) - (1.0-pos.y);\n    float rad = .1 * (2.0-pos.x) + .07;\n    \n    if (pos.y > bHeight2) {\n        \n        // Scrolling clouds 1\n        if ((distance(vec2(mod(pos.x-iTime/bSpeed*2.0,.3),pos.y), vec2(0.0,bHeight) ) < rad\n        ||  distance(vec2(mod(-pos.x+iTime/bSpeed*2.0,.3),pos.y), vec2(0.0,bHeight) ) < rad)){\n            color = vec3(.9,.8,.95)*pos.y*1.5; \n        }\n\n        // Scrolling clouds 2\n        else if ((distance(vec2(mod(pos.x-iTime/bSpeed*3.0,.6),pos.y), vec2(0.0,bHeight) ) < rad*2.0\n        ||  distance(vec2(mod(-pos.x+iTime/bSpeed*3.0,.6),pos.y), vec2(0.0,bHeight) ) < rad*2.0)){\n            color = vec3(0.7,0.3,0.5)*pos.y*1.5;\n        }\n    }\n    return color;\n}\n\n\n// Function to convert rgb color to hex\nfloat hex (vec3 rgb) {\n\treturn rgb.r + rgb.g * 256.0 + rgb.b * 256.0 * 256.0;\n}\n\n\n// Function to convert hex color to rgb\nvec3 rgb (float hex) {\n\tvec3 color;\n    color.b = floor(hex / 256.0 / 256.0);\n    color.g = floor((hex - color.b * 256.0 * 256.0) / 256.0);\n    color.r = floor(hex - color.b * 256.0 * 256.0 - color.g * 256.0);\n    return color / 256.0;\n}\n\n\n// Function to create a camera matrix --- o\nmat3 setCamera (vec3 pos, vec3 target, float rot) {\n\tvec3 cw = normalize(target-pos);\n\tvec3 cp = vec3(sin(rot), cos(rot),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n// Function in which all the objects in the scene are placed and measured --- o\nvec2 scene (vec3 cameraPos) {\n    \n    // Final result\n    vec2 result = vec2(99999.0,hex(vec3(0,0,0)));\n    \n    // Shuriken ~ ~ ~ ~ ~\n    vec3 shurikenPos = vec3(0.0,1.5 + sin(iTime*2.0)/5.0,0.0);\n    float sColor = hex(vec3(150,120,150));\n    float eyeColor = hex(vec3(20,0,20));\n    const float w = 0.15;\n    \n    vec2 shuriken = opUnion(\n        vec2(cone(opRotate(cameraPos-shurikenPos+vec3(0,0,w),vec3(PI/2.0,0,0)),vec3(.1,.83,w)),sColor),\n        vec2(cone(opRotate(cameraPos-shurikenPos+vec3(0,0,-w),vec3(PI/2.0,0,PI)),vec3(.1,.83,w)),sColor)\n        );\n    \n    shuriken = opSubtract(vec2(sphere(cameraPos-shurikenPos, 0.28), sColor), shuriken);\n    \n    for (float i=0.0; i<2.0*PI; i+=2.0*PI/8.0){\n    shuriken = opSubtract(\n    \tvec2(triPrism(opRotate(cameraPos-bladePos(shurikenPos,i),bladeRot(i)),vec2(0.6,0.5)), sColor),\n    \tshuriken);\n    }\n    \n    float eyeRadius = .17 + cos(iTime*2.0)*0.005;\n    shuriken = opUnion(shuriken,\n    \tvec2(cylinder(opRotate(cameraPos-shurikenPos,vec3(PI/2.0,0,0)), vec2(eyeRadius,0.1)), sColor));\n    \n    result = opUnion(result, shuriken);\n    \n    // Trees ~ ~ ~ ~ ~\n    vec3 treePos = vec3(1.0 + iTime*gSpeed,0.0,1.0);\n    vec3 treeRep = vec3(5.0,2.0,5.0);\n    float tColor = hex(vec3(80,40,40));\n    vec2 tree = vec2(cylinder(opRepeat(cameraPos-treePos,treeRep),vec2(0.3,10.0)),tColor);\n    \n    result = opUnion(result,tree);\n    \n    // Flower petals ~ ~ ~ ~ ~\n    float pColor = hex(vec3(255,150,200));\n    vec3 petalPos = vec3(4.0+iTime*0.3, 0.0-iTime*1.0+sin(iTime)*0.4, 0.0-iTime*1.5);\n    vec3 petalRot = vec3(iTime*5.0,iTime*4.0,0.0);\n    vec3 petalRep = vec3(5.0,1.0,1.0);\n    vec2 petal = vec2(box(opRotate(opRepeat(cameraPos-petalPos,petalRep),petalRot),vec3(.005,.02,.07)),pColor);\n    \n    result = opUnion(result,petal);\n    \n    // Road ~ ~ ~ ~ ~\n    float rColor = hex(vec3(70,50,30));\n    vec3 roadPos = vec3(cameraPos.x,0,0);\n    vec2 road = vec2(box(cameraPos-roadPos,vec3(.1,.01,.5)),rColor);\n    \n    result = opUnion(result,road);\n    \n    // Ground plane ~ ~ ~ ~ ~\n   \tfloat gColor = hex(vec3(20,50,20));\n    \n   \tresult = opUnion(result, vec2(plane(cameraPos - vec3(0,0,0)), gColor));\n    \n   \treturn result;\n}\n\n\n// Function to cast and march a ray though worldspace --- o\nvec2 raycast (vec3 cameraPos, vec3 rayDir) {\n    \n    float tmin = 0.5;\t\t// Near clipping distance\n    float tmax = 20.0;\t\t// Far clipping distance\n    float precis = .002;\t// Threshold for detecting a raycast hit\n    \n    float t = tmin;\t\t\t// Start the ray distance at the minimum threshold\n    float m = -1.0;\t\t\t// Color. Assume no hit detected (color is -1.0)\n        \n    // March the ray forward 50 times. This uses distance-aided raymarching (variable step).\n    for (int i=0; i<50; i++) {\n        \n        vec2 result = scene(cameraPos + (rayDir * t));\t// Cast the ray into the scene of objects\n        if( result.x<precis || t>tmax ) break;\t\t\t// Check if the ray hit an object\n        t += result.x;\t\t\t\t\t\t\t\t\t// RESULT: The distance traveled\n\t    m = result.y;\t\t\t\t\t\t\t\t\t// RESULT: The color of the object\n    }\n\n    if (t>tmax) {m = -1.0;}\t\t// Double check if the clipping threshold has been passed\n    return vec2(t,m);\t\t\t// Return the resulting distance and base color\n}\n\n\n// Function to calculate a normal\nvec3 calcNormal (vec3 pos) {\n    vec3 epsilon = vec3 (0.001,0,0);\n\tvec3 normal = vec3(\n\t    scene(pos+epsilon.xyy).x - scene(pos-epsilon.xyy).x,\n\t    scene(pos+epsilon.yxy).x - scene(pos-epsilon.yxy).x,\n\t    scene(pos+epsilon.yyx).x - scene(pos-epsilon.yyx).x );\n\treturn normalize(normal);\n}\n\n\n// Function to calculate a shadow\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat result = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene(ro + rd*t).x;\n        result = min(result, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp(result, 0.0, 1.0);\n}\n\n\n// Function to determine an output color via raycasting --- o\nvec3 render (vec3 cameraPos, vec3 rayDir, vec2 oldUV) {\n    \n    // Default to the background color\n    vec3 bgColor = vec3(0.4,0.25,0.55);\n    vec3 color = bgColor;\n    \n    // Cast the ray, and use the result to determine pixel color\n    vec2 result = raycast(cameraPos, rayDir);\n    float rayDist = result.x;\n    float baseColor = result.y;\n    \n    // If the color found is not -1.0, an object has been hit.\n    if (baseColor > -0.5 ) {\n   \t   color = rgb(baseColor);\n    }\n    else {\n    \treturn effect(oldUV); \t   \n    }\n    \n    // Calculate lighting #1: lighting vectors\n    vec3 position = cameraPos + (rayDir * rayDist);\t// Position of the surface in world space\n    vec3 normal = calcNormal(position); \t\t\t// Direction of the surface normal\n    vec3 rayReflect = reflect(rayDir,normal);\t\t// Direction of the reflected ray\n    vec3 lightDir = normalize(vec3(-2.0,2.0,-1.0));\t// Direction of the light source\n    \n    // Calculate lighting #2: components of illumination\n    float diffuse = clamp(dot(normal,lightDir),0.0,1.0);\n    diffuse *= shadow(position,normal,.5,.55);\n    float specular = pow(clamp(dot(rayReflect,lightDir),0.0,1.0),50.0);\n    \n    // Calculate lighting #3: sum the components of illumination\n    vec3 multiplier = vec3(0.0);\n    multiplier += 0.5*diffuse*vec3(1.0,1.0,1.0);\n    multiplier += 1.0*specular*bgColor*diffuse;\n    \n    // Return the final color\n    color *= multiplier;\n    return vec3(clamp(color,0.0,1.0));\n}\n\n// ------------------------------------------------------------------- o\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Get the position of the current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// The pixel position in screen space (0 to 1)\n    vec2 pixel = -1.0 + (2.0 * uv);\t\t\t\t// The pixel position in screen space (-1 to 1)\n\tpixel.x *= iResolution.x/iResolution.y;\t\t// The pixel position adjusted for aspect ratio\n    \n    // Create a camera\n    vec3 cameraPos = vec3(3.5,2.0,-3.0);\t// The position of the camera\n    vec3 cameraTarget = vec3(0,1.5,0);\t\t// The point at which the camera looks\n    float cameraRot = 0.0;\t\t\t\t\t// The rotation of the camera lens\n    float FOV = 2.5;\t\t\t\t\t\t// The field of view multiplier\n    \n    // Create a camera matrix in world space\n    mat3 camera = setCamera(cameraPos,cameraTarget,cameraRot);\n    \n    // Get the direction of the ray from the current pixel\n    vec3 rayDir = camera * normalize(vec3(pixel.xy,FOV));\n    \n    // Cast the ray and return a color based on the result (render)\n    vec2 extra = vec2(uv.x*iResolution.x/iResolution.y,uv.y);\n    vec3 color = render(cameraPos,rayDir,extra);\n    \n    // Set the color of the pixel on screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llBGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llBGW1", "name": "First ray-marching fun", "author": "archee", "description": "I never made any demo scene release, that uses ray-marching. (preferred immediate ray casting)\nLet's make up the fun that I had missed out.", "tags": ["raymarching"], "likes": 20, "viewed": 1537, "date": "1428514740", "time_retrieved": "2024-06-20T18:19:42.425999", "image_code": "//#define AUTOCAM\n\nvec3 campos;\nvec3 dir;\nfloat time;\n\n// rotate camera\n#define pee (acos(0.0)*2.0)\n\nfloat anglex,angley; // camera\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex);\n\t\n\tt = v.x * cos(angley) - v.z*sin(angley);\n\tv.z = v.z*cos(angley) + v.x*sin(angley);\n\tv.x = t;\n\treturn v;\n}\n\n\nvec3 pos;\nfloat mat;\n\nfloat blob()\n{\n    vec3 p = pos;\n    float f=0.0;\n    f += 1.0/dot(p,p);\n    p -= vec3(2.0+sin(time)*2.0,0.0,0.0);\n    f += 1.0/dot(p,p);\n    p = pos;\n    p -= vec3(2.0,2.0+cos(time*1.2)*2.0,0.0);\n    f += 1.0/dot(p,p);\n    return sqrt(1.0/f)-1.0;\n}\n\nfloat maxfade(float a,float b)\n{\n    return max( (a+b)*0.5, max(a,b-0.2));\n}\n\nfloat asteroid()\n{\n    vec3 p = pos;\n    float d=0.0;\n    \n    float rad = 1.0;\n    \n    p = rotatex(p,time);\n    \n    rad += clamp(sin(p.x*8.0)*2.0,-1.0,1.0)*0.05;\n    rad += clamp(sin(p.y*8.0)*2.0,-1.0,1.0)*0.05;\n    rad += clamp(sin(p.z*8.0)*2.0,-1.0,1.0)*0.05;\n    d = (length(p)-rad)*0.5;\n    \n    \n    return d;\n}\n\n\nfloat cube()\n{\n    float d;\n    vec3 p = rotatex(pos,time); // cube\n    vec3 p2 = p;\n//    p=  (fract(p/8.0+0.5)-0.5)*8.0;\n//    p.y = pos.y;\n    p = abs(p);\n    p = max(p-vec3(1.0),vec3(0.0));\n    d =  length(p)-0.2;\n    d = maxfade( d,   0.8+sin(time*3.0)*0.0-length(p2.xy) );\n    d = max( d,   0.7-length(p2.xz) );\n    d = max( d,   0.7-length(p2.yz) );\n    return d;\n}\n\nfloat toroid()\n{\n    float d=0.0;\n    vec3 p = pos;\n//    p=  (fract(p/8.0+0.5)-0.5)*8.0;\n    \n    vec2 tp;\n    tp = vec2(p.y/2.0,(dot(p.xz,p.xz))-1.0);\n//    return (length(tp)-0.4)/1.0;\n    d += 1.0/(length(tp));\n    \n    \n    p.x += sin(time)*2.0+1.0;\n    p.y += cos(time*1.2)*1.0+0.5;\n    tp = vec2(p.z,length(p.xy)-1.0);\n    d += 1.0/(length(tp));\n    return (1.0/d-0.3)*0.5;\n}\n\nfloat dist2(float scene)\n{\n    scene = mod(scene,4.0);\n    if (scene==0.0) return cube();\n    if (scene==1.0) return toroid();\n    if (scene==2.0) return asteroid();\n//    if (scene==3.0) \n        return blob();\n}\n\nfloat dist()\n{\n/*    float d = mix(asteroid(),cube(),sin(time)*0.5+0.5);\n//    d = cube();\n    d = toroid();*/\n    \n    float tscene = (time/8.0);\n    float iscene = floor(tscene);\n    float d = mix( dist2(iscene), dist2(iscene+1.0), max(fract(tscene)*3.0-2.0,0.0));\n    \n    d = min(d,pos.y+3.0);\n    return d;\n}\n\n\nfloat dist2(vec3 p)\n{\n    pos = p;\n    return dist();\n}\n\nvec3 calcnormal(vec3 pos)\n{\n    float dd = 0.001;\n    float mv = dist2(pos);\n    return normalize(vec3( dist2(pos+vec3(dd,0.0,0.0))-mv, dist2(pos+vec3(0.0,dd,0.0))-mv, dist2(pos+vec3(0.0,0.0,dd))-mv));\n}\n\nvec3  trace_normal()\n{\n    float st = 0.5;\n    pos = campos;\n    mat = 0.0;\n    \n    float lastst=0.0;\n    for(int p=0;p<250;p++)\n    {\n    \tst = dist();\n        if (st<0.002) \n        {\n            return calcnormal(pos);\n        }\n        if (length(pos)>20.0) return vec3(0.0);\n    \tpos += dir*st;\n        lastst = st;\n    }\n    return vec3(0.0);\n}\n\nfloat trace_shadow()\n{\n    float lastst=0.0;\n    float st = 0.02;\n    pos += dir*st;\n    float travel = st/99.0;\n    float shadow = 1.0;\n    for(int p=0;p<250;p++)\n    {\n    \tst = dist();\n        shadow = min(shadow,st/travel*90.0);\n        if (st<0.002) \n        {\n            return 0.0;\n        }\n        if (length(pos)>20.0) return shadow;\n    \tpos += dir*st;\n        travel += st;\n        lastst = st;\n    }\n    return shadow;\n    \n}\n\nvec3 sundir = normalize(vec3(0.7,1.0,0.2));\n\nvec3 backGround(vec3 dir)\n{\n    return mix(vec3(0.3,0.2,0.1),vec3(0.6,0.8,1.0)*0.5,clamp(dir.y*10.0,0.0,1.0));\n}\n\nvec3 trace()\n{\n    vec3 norm = trace_normal();\n    vec3 ambientLight = vec3(0.6,0.8,1.0);\n    vec3 sunLight = vec3(1.0,0.8,0.6);\n\n    if (length(norm)==0.0)\n    {\n        return backGround(dir);\n    }\n    \n    vec3 refdir = reflect(dir,norm);\n    float f = 1.0-max(-dot(dir,norm),0.0);\n    float fresnel = 0.1+0.9*f*f*f*f*f;\n    \n    float spec = pow(max(dot(sundir,refdir),0.0),8.0)*4.0;\n    \n    dir = sundir;\n\tfloat shadow = trace_shadow();                    \n    \n   \n    \n    return (mix(ambientLight * (norm.y*0.5+0.5) + shadow*(sunLight*max(dot(norm,dir),0.0)),backGround(refdir)+shadow * vec3(spec),fresnel  ))*0.7;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set camera\n    if (iMouse.x!=0.0)\n    {\n    anglex = ( iMouse.y/iResolution.y*-0.6+0.3)*pee*1.2; // mouse cam\n    angley = -iMouse.x/iResolution.x*pee*2.0;\n    }\n    else\n    {\n    anglex = sin(iTime*0.3)*-0.6+0.6;\n    angley = pee + sin(iTime*0.2);\n    }\n\n    \n    time = iTime+2.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tcampos = vec3(0,0,0);\n\tdir = vec3(uv*2.0-1.0,1);\n\tdir.y *= 9.0/16.0; // wide screen\n\t\n\tdir = normalize(rotcam(dir));\n\tcampos -= rotcam(vec3(0,0,4.0 + 0.0*exp(iTime*-0.8))); // back up from subject\n    \n \n    fragColor = vec4(trace(),0.0);\n    \n    \n//    fragColor = vec4(dot(pos-campos,dir)*vec3(0.1,0.01,0.001),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llBGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llj3DR", "name": "hypersphere", "author": "vahokif", "description": "Lots of spheres with some cool patterns that appear when they all line up.", "tags": ["raymarching"], "likes": 8, "viewed": 201, "date": "1428287108", "time_retrieved": "2024-06-20T18:19:42.425999", "image_code": "// by vahokif\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 FOG_COLOR = vec3(54.0 / 255.0, 159.0 / 255.0, 245.0 / 255.0);\n\nbool map(vec3 pos) {\t\n    vec2 pos2 = pos.xy;\n\t\n\t//pos2.x += pos.z * 20.0;\n\tfloat twist = pos.z * tan(iTime * 0.2) * 0.01 + iTime * 0.05;\n\tfloat s = sin(twist);\n\tfloat c = cos(twist);\n\t\n\tpos2 = vec2(c * pos2.x + s * pos2.y, c * pos2.y - s * pos2.x);\n\t\n\treturn length(fract(pos2 * 2.0) - 0.5) < 0.17;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 position = fragCoord.xy / iResolution.xy - 0.5;\n\tposition.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 rayDir = normalize(vec3(position.xy, 4.0));\n\n\tbool isHit = false;\n\tvec3 hit;\n\tvec3 ray = vec3(0.0);\n\tfor (int i = 0; i < 64; i++) {\n\t  ray += rayDir * 2.0;\n\t  if (map(ray)) {\n\t\t  isHit = true;\n\t\t  hit = ray;\n\t\t  break;\n\t  }\n\t}\n\n\tvec3 color;\n\tif (isHit) {\t\t\n\t\tcolor = FOG_COLOR * hit.z / 128.0;\n\t} else {\n\t\tcolor = FOG_COLOR;\n\t}\n\tfragColor = vec4(color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llj3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llj3Dw", "name": "4-Rook Anti Aliasing", "author": "demofox", "description": "Anti Aliasing on left, no antialiasing on right.", "tags": ["antialiasing", "nrook"], "likes": 7, "viewed": 1925, "date": "1429798611", "time_retrieved": "2024-06-20T18:19:43.104725", "image_code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n\n4-Rook anti aliasing works by using 4 samples per pixel in the following configuration:\n\n\n  +-----------+\n  |  |  |A |  |\n  |--|--|--|--|\n  |D |  |  |  |\n  |--|--|--|--|\n  |  |  |  |B |\n  |--|--|--|--|\n  |  |C |  |  |\n  +-----------+\n\n\nA,B,C,D have a weight of 0.25.\n\nThis makes for AA that is not quite as blurry looking as quincunx, but unlike\nquincunx you can't share samples between pixels.  This is straight up 4x SSAA!\n\nMore info here:\nhttp://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n*/\n\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n// camera wander: sin(time) controls magnitude, time controls angle\nfloat cameraAngle = iTime * 0.32;\nfloat cameraMag = sin(iTime*0.89) * 0.25 +1.0;\n\nvec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n// aspect ratio correction\nvec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\nfloat g_arcorrection = resolution.x / resolution.y;\n\n// image zoom, defined by time\nfloat g_scale = (sin(iTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w/2.0)&&(abs(pos.y-(_y)) < _h/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    // thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    // textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture(iChannel3, pos).xyz);\n    \n    // spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iTime, vec3(0.0, 0.0, 1.0));\n    \n    // concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    // untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    // grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord)\n{\n    vec2 ret = ((coord / resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t   \n    vec3 pixelColor;\n    \n    // draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    // right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy));\n\t}\n\t// left side = AA\n\telse\n    {\n        const float S = 1.0/8.0;\n        const float L  = 3.0/8.0;\n        pixelColor  = GetPixelColor(PixelToWorld(fragCoord.xy + vec2( S, -L ))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( L , S))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-S, -L ))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-L ,-S))) / 4.0;\n\t}\t\t\n\t\n    // write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llj3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llj3W1", "name": "Revision 2015 Livecoding Finals", "author": "mu6k", "description": "Written under 25 minutes at Revision 2015 live-coding finals. I tried to adapt it by making as less modifications as possible. Put some music into iChannel0.", "tags": ["3d", "raymarching", "livecoding"], "likes": 11, "viewed": 1351, "date": "1428741177", "time_retrieved": "2024-06-20T18:19:43.729142", "image_code": "//original at: ftp://ftp.scene.org/pub/parties/2015/revision15/shadershowdown/03-musk.glsl\n\n#define v2Resolution iResolution.xy\n#define texFFTSmoothed iChannel0\n#define texFFT iChannel0\n#define texNoise iChannel1\n#define fGlobalTime iTime\n#define out_color fragColor\n\n#define time fGlobalTime\n#define bt texture(texFFTSmoothed, vec2(.01,.0)).x*.2\n\nvec3 arep(vec3 p, float r)\n{\n  float a= atan(p.y,p.x);\n  float l = length(p.xy);\n  a = mod(a+r*.5,r)-r*.5;\n  p.xy = vec2(cos(a),sin(a))*l;\n  return p;\n}\n\nfloat b2(vec3 p, vec3 b)\n{\n  \n  return length(max(abs(p)-b,.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = arep(p,.5*355.0/113.0);\n  p = arep(p,.25*355.0/113.0);\n  return min(max(max(p.x-1.0,\n  max(p.x-1.0+p.z*.3,\n  max(p.x-1.3+p.z*.5,\n  max(p.x-1.6-p.z*.3,p.x-2.5-p.z*.8)))),-2.5-p.z),length(max(abs(p)-vec3(.1,0.1,.1),.0)));\n}\n\nfloat df(vec3 p)\n{\n  \n  //return length(p)-1.0;\n  return min(box(p, vec3(.5,.5,.5)),p.y+8.0+texture(texNoise,(p.zx+vec2(time*64.0,.0))*.0004).x*2.0\n+texture(texNoise,(p.zx+vec2(time*64.0,.0))*.0004).x*64.0*bt);\n}\n\nvec3 nf(vec3 p)\n{\n  vec2 e = vec2(.0,.1);\n  float c= df(p);\n  return normalize(vec3(c+df(p+e.yxx),c+df(p+e.xyx),c+df(p+e.xxy)));\n}\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  float a=time*.7, cs=cos(a), ss=sin(a);\n  mat3 r0 = mat3(cs,ss,0,-ss,cs,0,0,0,1);\n\n  a=sin(time*.6), cs=cos(a), ss=sin(a);\n  mat3 r1 = mat3(cs,0,ss,0,1,0,-ss,0,cs);\n\n  a=time*.4, cs=cos(a), ss=sin(a);\n  mat3 r2 = mat3(1,0,0,0,cs,ss,0,-ss,cs);\n\n\n  vec3 p = vec3(.0,.0,-8.0);\n  vec3 dir = normalize(vec3(uv.xy,-length(uv.xy)+0.5));\n\n  p*=r0*r1*r2;\n  dir*=r0*r1*r2;\n\n  float tt =.0;\n\n  for (int i=0; i<150; i++)\n  {\n    float dt = df(p);\n  tt += dt;\n    p += dir*dt*.5;\n    \n  }\n \n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1.0 / length(uv) * .2;\n  float d = m.y;\n\n  float f = texture( texFFTSmoothed, vec2(d,.0) ).r * 100.0;\n  m.x += sin( fGlobalTime ) * 0.1;\n  m.y += fGlobalTime * 0.25;\n\n  vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n  t = clamp( t, 0.0, 1.0 );\n  vec4 c0 = (f + t)*bt*4.0;;\n\n  vec3 col = c0.xyz;\n  \n  vec3 l = normalize(vec3(1,2,3));\n\n  if (df(p)<.1)\n  {\n    col = nf(p)*.5+.5;\n    col = vec3(dot(nf(p),l)*.5+.5);\n  col*=.9;\n  }\n\n  if(p.y<-2.1)\n  {\n    col*=vec3(.2,.5,.2);\n  }\n  else if (p.z>.75) col*=vec3(.9,.2,.2);\n\n  col = col +  vec3(.2,.4,.6)*tt*.003;\n\n  col += length(col);\n  col -=.4;\n  out_color = vec4(col,1.0)*(bt+.2)*2.0;\n\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llj3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llj3Ww", "name": "Grate", "author": "Bravendary", "description": "A scrolling grate, kinda sucks in full screen unfortunately. ", "tags": ["2d"], "likes": 2, "viewed": 144, "date": "1429813861", "time_retrieved": "2024-06-20T18:19:44.026026", "image_code": " float lerp(float t, float a, float b){\n      return (1.0 - t) * a + t * b;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n\tfloat xSize = 30.0 ;\n    float ySize = 25.0;\n    float maxSize = 10.;\n    float reduction = 8.;\n    \n    vec2 gridSize = vec2(mod(iResolution.x, xSize), mod(iResolution.y, ySize)) ;\n    \n    vec2 pos = vec2(mod(fragCoord.x  + iTime * 30., xSize), mod(fragCoord.y, xSize));\n    \n    \n   \n    float distx = distance(pos.x, gridSize.x);\n    float disty = distance(pos.y, gridSize.y);\n\n    float progress= x/iResolution.x;\n    \n    float col;\n    if( progress < 0.5){\n        col = lerp(max(clamp(((0.45 - progress)/1.)/(distx/xSize), 0.0, .7), clamp(disty/ySize, 0.0, 1.0)), 0.0, 0.8); \n    } else {\n        col = lerp(max(clamp((distx/xSize)- (1.1 - progress * 1.25), 0.0, .8), clamp(disty/ySize, 0.0, 1.0)), 0.0, 0.8); \n\n\n    }\n\tfloat distFromCenter = abs(x - (iResolution.x/2.))/(iResolution.x/2.);\n    \n    \n    \n    if(distx <= maxSize -(reduction * distFromCenter)){\n    \tcol = lerp(1.0- (iResolution.x - fragCoord.x)/iResolution.x, 0.25, 1.0);\n    }\n    \n    //Intensity increases from left to right\n    float colorAdjustment = lerp(progress, -0.2, .3 + (.1 * (sin(iTime) * 0.2)));\n    //The effect of the adjustment can be scaled per channel\n    float r = 1.0;\n    float g = .7;\n    float b = .4;\n\tfragColor = vec4(col + colorAdjustment * r,col + colorAdjustment * g,col + colorAdjustment * b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llj3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lljGzy", "name": "ngTile1", "author": "netgrind", "description": "checker", "tags": ["reactive", "blackandwhite", "audio", "checker", "tile", "microphone", "mic", "ska"], "likes": 5, "viewed": 558, "date": "1430128661", "time_retrieved": "2024-06-20T18:19:44.026026", "image_code": "float mic(float x, float y){\n return texture(iChannel0, vec2(abs(mod(x+1., 2.)-.1),y)).r;   \n}\n\nfloat com(vec2 uv, float i){\n    float d = length(uv)*.1;\n    \n    //uv*= mat2(d,sin(i+d),sin(-i+d),d);\n    //uv*= mat2(0,sin(i+d),sin(-i+d),0);\n    //uv*= mat2(1,sin(i+d),sin(-i+d),1);\n    //uv*= mat2(sin(i-d),0,0,sin(i-d));\n    //uv*= mat2(tan(d+1.5),sin(i),cos(i),tan(d+1.5));\n    //uv*= mat2(cos(i),sin(d),cos(d),sin(i));\n    //uv*= mat2(cos(i),d,d,sin(i));\n    //uv*= mat2(sin(i+d),cos(i+sin(i+d)),sin(i+cos(i-d)),cos(d));\n    uv*= mat2(d+mic(d, .3),cos(i+sin(i+d)),sin(i+cos(i-d)),d);\n    \n    float v =  floor(mod(uv.y,2.0));\n    return floor(mod(uv.x+v,2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime*.333;\n    \n    fragCoord.xy -= iResolution.xy*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    uv*=.4+mic(.1,.3)*0.1;\n    float o = sin(i)+1.;\n    float f = com(uv*20.,i);\n    f = max(f,com(uv*(20.+o),i)*.6);\n    f = max(f,com(uv*(20.+o*2.),i)*.3);\n    \n\tfragColor = vec4(f,f,f,1.0); \n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lljGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llS3RK", "name": "Worley Noise Waters", "author": "Kyle273", "description": "A simple Worley noise shader. Full tutorial at ibreakdownshaders.blogspot.com. Original shader from  http://glslsandbox.com/e#23237.0", "tags": ["2d", "noise", "worley", "noob"], "likes": 88, "viewed": 9237, "date": "1430268245", "time_retrieved": "2024-06-20T18:19:44.026026", "image_code": "//Calculate the squared length of a vector\nfloat length2(vec2 p){\n    return dot(p,p);\n}\n\n//Generate some noise to scatter points.\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n}\n\nfloat worley(vec2 p) {\n    //Set our distance to infinity\n\tfloat d = 1e30;\n    //For the 9 surrounding grid points\n\tfor (int xo = -1; xo <= 1; ++xo) {\n\t\tfor (int yo = -1; yo <= 1; ++yo) {\n            //Floor our vec2 and add an offset to create our point\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n            //Calculate the minimum distance for this grid point\n            //Mix in the noise value too!\n\t\t\td = min(d, length2(p - tp - noise(tp)));\n\t\t}\n\t}\n\treturn 3.0*exp(-4.0*abs(2.5*d - 1.0));\n}\n\nfloat fworley(vec2 p) {\n    //Stack noise layers \n\treturn sqrt(sqrt(sqrt(\n\t\tworley(p*5.0 + 0.05*iTime) *\n\t\tsqrt(worley(p * 50.0 + 0.12 + -0.1*iTime)) *\n\t\tsqrt(sqrt(worley(p * -10.0 + 0.03*iTime))))));\n}\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Calculate an intensity\n    float t = fworley(uv * iResolution.xy / 1500.0);\n    //Add some gradient\n    t*=exp(-length2(abs(0.7*uv - 1.0)));\t\n    //Make it blue!\n    fragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, 0.5-t)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llS3RK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llS3W1", "name": "polkaDot", "author": "DimitryK", "description": "Take on a polka dot shader with a smoothstep antialiasing and some coloring based on quadrants", "tags": ["2d", "polkadot"], "likes": 1, "viewed": 265, "date": "1428520610", "time_retrieved": "2024-06-20T18:19:44.026026", "image_code": "const float nr = 6.0;\nconst vec2 mid = vec2(0.5);\nconst float radius = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.y *= iResolution.y/iResolution.x;\n    \n    // we shift by 0.5 to fill the corners\n    vec2 uv_offset = (uv) * nr;\n    \n    vec2 local = vec2( fract(uv_offset.x), fract(uv_offset.y) );\n    \n    vec3 col = vec3(1.0);\n    float quadrantX = floor(abs(uv_offset.x));\n    float quadrantY = floor(abs(uv_offset.y));\n    col.x = cos(quadrantX*5.0) + sin(iTime);\n    col.y = sin(quadrantY*2.0) + cos(iTime);\n    //col.z = sin(col.x) + cos(col.y);\n    \n    vec2 distFM = local - mid;\n    \n    float dist = length(distFM);\n    \n    float circ = smoothstep(0.0, 0.02, radius-dist);\n    col *= circ;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llS3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "llSGRR", "name": "Minimal Bezier vector digits", "author": "klk", "description": "Minimalistic vector font. I planned to do all the letters, but shader limitations did not permit. Or I did not do my best.", "tags": ["bezier", "font", "digit"], "likes": 13, "viewed": 1220, "date": "1428187115", "time_retrieved": "2024-06-20T18:19:44.032086", "image_code": "#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\n//precision lowp float;\n\nfloat Draw(float2 p0, float2 p1, float2 uv)\n{\n    float2 dp=normalize(p1-p0);\n    float2 dpp=float2(dp.y, -dp.x);\n    float l=abs(dot(dpp,uv-p0));\n    if((dot(dp,uv-p0)<0.0))\n        l=length(uv-p0);\n    if((dot(-dp,uv-p1)<0.0))\n        l=length(uv-p1);\n    return l;\n}\n\nfloat l=1.0;\nfloat line;\nfloat2 CP0;\nfloat2 CP;\nfloat2 uv;\nfloat size;\n\nfloat2 Pp0=float2(-0.5,-0.25);\nfloat2 Ppx=float2(0.01,0);\nfloat2 Ppy=float2(0,0.01);\n\nfloat2 TS(float2 p)\n{\n    return Pp0+Ppx*p.x+Ppy*p.y;\n}\n    \nvoid BeginShape()\n{\n    l=1.0;\n}\n\nvoid MoveTo(float2 p)\n{\n    p=TS(p);\n    CP0=CP=p;\n}\n\nvoid LineTo(float2 p)\n{\n    p=TS(p);\n    l=min(l,Draw(CP,p,uv));\n    CP=p;\n}\n\nvoid RLineTo(float2 p)\n{\n    p=CP+TS(p)-Pp0;\n    l=min(l,Draw(CP,p,uv));\n    CP=p;\n}\n\nvoid LineToNoTS(float2 p)\n{\n    l=min(l,Draw(CP,p,uv));\n    CP=p;\n}\n/*\nvoid Bez2To(float2 p1, float2 p2)\n{\n    p1=TS(p1);\n    p2=TS(p2);\n    const int NS=3;\n    float t=1.0/float(NS);\n    float2 p0=CP;\n\tfor(int i=1;i<=NS;i++)\n    {\n        LineToNoTS(p0*(1.0-t)*(1.0-t)+2.0*p1*t*(1.0-t)+p2*t*t);\n        t+=1.0/float(NS);\n    }\n}\n*/\nvoid Bez3To(float2 p1, float2 p2, float2 p3)\n{\n    p1=TS(p1);\n    p2=TS(p2);\n    p3=TS(p3);\n    const int NS=8;\n    float t=1.0/float(NS);\n    float2 p0=CP;\n\tfloat2 d1=(p1-p0)*3.0;\n\tfloat2 d2=(p1-p2)*3.0;\n\tfor(int i=0;i<100;i+=1)\n    {\n\t\tLineToNoTS((((d2-p0+p3)*t-d1-d2)*t+d1)*t+p0);\n        t+=1.0/float(NS);\n        if(t>1.0)\n            break;\n    }\n}\n\n\nvoid CloseShape()\n{\n    if(length(CP-CP0)>0.0)\n    \tLineTo(CP0);\n}\n\nvoid FinishShape()\n{\n    float l0=sqrt(l*l*size*size)*0.25;\n    line=clamp(1.0-l0,0.0,1.0);\n}\n\nvoid Digit(float d);\n\nvoid Print(float v)\n{\n    if(v<0.0)\n    {\n    \tDigit(11.5);\n\t    Pp0+=Ppx*2.3;\n        v=-v;\n    }\n    Digit((fract(v/10.0)*10.0));\n    Pp0+=Ppx*2.3;\n    Digit(10.5);\n    float d=1.0;\n    for(int i=0;i<10;i+=1)\n    {\n        Pp0+=Ppx*2.3;\n\t    Digit((fract(v*d)*10.0));\n    \td*=10.0;\n        if(d>100.0)\n            break;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    size=min(iResolution.x, iResolution.y);\n    float2 mp=iMouse.xy/iResolution.xy-0.5;\n    mp.x=mp.x*iResolution.x/iResolution.y;\n\n    Ppx.x=0.06;\n    Ppy.y=0.09;\n    Ppy.x=0.01;\n    \n    float t=iTime*0.25;\n\tuv = fragCoord.xy/iResolution.xy-0.5;\n    uv.x=uv.x*iResolution.x/iResolution.y;\n    \n    BeginShape();\n    if(iMouse.xy==float2(0.0))\n        Print(fract(t*0.01)*10.0-5.0);\n    else\n        Print(mp.x);\n    FinishShape();\n\n    float3 col2=float3(0);\n\n    fragColor=float4(0.9,0.8,0.6,1.0);\n   \tfragColor.rgb=mix(fragColor.rgb,col2,line);\n}\n\nvoid glyph_0();\nvoid glyph_1();\nvoid glyph_2();\nvoid glyph_3();\nvoid glyph_4();\nvoid glyph_5();\nvoid glyph_6();\nvoid glyph_7();\nvoid glyph_8();\nvoid glyph_9();\nvoid glyph_Dot();\nvoid glyph_Minus();\n\nvoid Digit(float d)\n{\n    /* */if(d< 1.0)glyph_0();\n    else if(d< 2.0)glyph_1();\n    else if(d< 3.0)glyph_2();\n    else if(d< 4.0)glyph_3();\n    else if(d< 5.0)glyph_4();\n    else if(d< 6.0)glyph_5();\n    else if(d< 7.0)glyph_6();\n    else if(d< 8.0)glyph_7();\n    else if(d< 9.0)glyph_8();\n    else if(d<10.0)glyph_9();\n    else if(d<11.0)glyph_Dot();\n    else if(d<12.0)glyph_Minus();\n}\n\nfloat2 x=float2(1.0,0.0);\nfloat2 y=float2(0.0,1.0);\n\nvoid glyph_0()\n{\n  MoveTo(x);\n  Bez3To(-0.2*x,2.0*y-x*0.2,float2(1.0,2.0));\n  Bez3To(2.0*y+x*2.2,2.2*x,x);\n  MoveTo(x*0.85+y*0.7);\n  LineTo(x*1.15+y*1.3);\n}\nvoid glyph_1()\n{\n  MoveTo(0.5*x+1.7*y);\n  LineTo(x+2.0*y);\n  LineTo(x);\n  MoveTo(0.5*x);\n  LineTo(1.5*x);\n}\nvoid glyph_2()\n{\n  MoveTo(1.8*x+y*0.2);\n  LineTo(1.8*x);\n  LineTo(0.2*x);    \n  Bez3To(float2(0.9,0.625),x*1.8+y*1.1,x*1.8+y*1.5);\n  Bez3To(x*1.8+y*2.2,x*0.2+y*2.2,x*0.2+y*1.5);\n}\nvoid glyph_3()\n{\n  MoveTo(x*0.2+y*1.7);\n  Bez3To(x*0.4+y*2.15,x*1.7+y*2.15,x*1.7+y*1.55);\n  Bez3To(x*1.7+y*1.3,x*1.4+y*1.1,x*0.8+y*1.1);\n  Bez3To(x*1.4+y*1.1,x*1.8+y*0.9,x*1.8+y*0.55);\n  Bez3To(x*1.8-y*0.2,x*0.4-y*0.2,x*0.2+y*0.3);\n}\nvoid glyph_4()\n{\n  MoveTo(0.1*x+0.6*y);    \n  LineTo(x*1.6+2.0*y);\n  RLineTo(-y*2.0);\n  RLineTo(-0.3*x);\n  RLineTo(0.6*x);\n  MoveTo(0.1*x+0.6*y);    \n  RLineTo(1.8*x);\n}\nvoid glyph_5()\n{\n  MoveTo(x*0.2+y*1.1);\n  Bez3To(x*0.7+y*1.5,x*1.8+y*1.4,x*1.8+y*0.65);\n  Bez3To(x*1.8-y*0.2,x*0.4-y*0.2,x*0.1+y*0.3);\n  MoveTo(x*0.2+y*1.1);\n  RLineTo(y*0.9);\n  RLineTo(x*1.5);\n}\nvoid glyph_6()\n{\n  MoveTo(x*0.2+y*0.6);\n  Bez3To(x*0.2-0.2*y,1.8*x-y*0.2,float2(1.8,0.6));\n  Bez3To(1.8*x+y*1.4,x*0.2+1.4*y,x*0.2+y*0.6);\n  Bez3To(x*0.0+1.6*y,0.7*x+y*2.3,float2(1.6,1.9));\n}\nvoid glyph_7()\n{\n  MoveTo(x*0.1+y*1.8);\n  RLineTo(y*0.2);\n  RLineTo(x*1.8);\n  Bez3To(x+y*1.3,x+y*0.5,x);\n}\nvoid glyph_8()\n{\n  MoveTo(x+y*1.1);\n  Bez3To(y*1.1-x*0.2,-x*0.2-y*0.05,x-y*0.05);\n  Bez3To(2.2*x-y*0.05,y*1.1+2.2*x,x+y*1.1);\n  Bez3To(y*1.1,y*2.05,x+y*2.05);\n  Bez3To(y*2.05+2.0*x,2.0*x+y*1.1,x+y*1.1);\n}\nvoid glyph_9()\n{\n  MoveTo(float2(1.8,1.4));\n  Bez3To(1.8*x+y*0.6,x*0.2+0.6*y,x*0.2+y*1.4);\n  Bez3To(x*0.2+2.2*y,1.8*x+y*2.2,float2(1.8,1.4));\n  Bez3To(float2(1.9,0.0),float2(1.0,-0.2),float2(0.4,0.2));\n}\nvoid glyph_Dot()\n{\n  MoveTo(x);\n  Bez3To(x*1.2,x*1.2+y*0.2,x+y*0.2);\n  Bez3To(x*0.8+y*0.2,x*0.8,x);\n}\nvoid glyph_Minus()\n{\n  MoveTo(x*0.5+y);\n  RLineTo(x);\n}\n\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llSGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt2GDh", "name": "Fast coding at Revision 2k15", "author": "XT95", "description": "My first entry at Shadershowdown competition, Revision 2015.\nI really enjoyed this compo, I will participate next year for sure ! But i will learn english before.. ;)\nThank you to organizers and all participants!", "tags": ["distancefield", "revision", "fastcoding", "shadershowdown"], "likes": 12, "viewed": 1399, "date": "1428677707", "time_retrieved": "2024-06-20T18:19:44.032086", "image_code": "float rubban( vec3 p)\n{\n  return length( p.xy+vec2(cos(p.z),sin(p.z)) ) - .1;\n}\n\nfloat rubban1( vec3 p)\n{\n  return length( p.xy+vec2(cos(p.z+2.),sin(p.z+2.)) ) - .1;\n}\n\nfloat rubban2( vec3 p)\n{\n  return length( p.xy+vec2(cos(p.z+4.),sin(p.z+4.)) ) - .1;\n}\n\nfloat map( in vec3 p)\n{\n  float d = p.y+1.;\n  d = min(d, -p.y+2.);\n  d = min(d, cos(p.x)+cos(p.y)+cos(p.z)+cos(p.y*20.)*texture(iChannel0,vec2(0.05,0.)).r*.1);\n  p.x += 3.;\n  p.x = mod(p.x, 6.)-3.;\n  d = min(d, rubban(p));\n  d = min(d, rubban1(p));\n  d = min(d, rubban2(p));\n  d = max(d, p.z-iTime*3.-6.);\n  return d;\n}\n\nvec2 rotate( vec2 v, float a)\n{\n  return vec2( v.y*cos(a) - v.x*sin(a), v.x*cos(a) + v.y*sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec2 uv2 = uv;\n  uv.x += texture(iChannel0, vec2(uv.y*.5+.5,0.)).r*.05;\n  vec3 col = vec3(0.);\n\n  vec3 org = vec3(cos(iTime*10.)*texture(iChannel0,vec2(0.1,0.)).r*.2, cos(iTime*20.)*texture(iChannel0,vec2(0.1,0.)).r*.2,iTime*3.);\n  vec3 dir = normalize(vec3(uv, 1.-length(uv)*1.));\n  dir.xy = rotate(dir.xy, iTime*.25);\n  dir.xz = rotate(dir.xz, iTime*.1);\n  vec4 p =vec4(org,0.);\n\n  for(int i=0; i<128; i++)\n  {\n    float d = map(p.xyz);\n    p += vec4( dir*d, 1./64.);\n    if(d<0.01)\n      break;\n  }\n\n  col += vec3(.1,.1,1.0)*p.w *p.w;\n\n  p.x += 3.;\n  p.x = mod(p.x, 6.)-3.;\n  float coef = 0.;\n  for(float i=0.; i<.02; i+=1./100.)\n  {\n    coef += texture( iChannel0, vec2(i,0.0)).r;\n  }\n  col += vec3(1.,.3,.0) / (.1 + pow( rubban(p.xyz), 2.) ) * coef*.01;\n\n  coef = 0.;\n  for(float i=.1; i<.25; i+=1./100.)\n  {\n    coef += texture( iChannel0, vec2(i,0.)).r;\n  }\n  col += vec3(.1,1.,.1) / (.1 + pow( rubban1(p.xyz), 2.) ) * coef*.01;\n\n  coef = 0.;\n  for(float i=.25; i<.5; i+=1./100.)\n  {\n    coef += texture( iChannel0, vec2(i,0.)).r;\n  }\n  col += vec3(.5,.1,1.) / (.1 + pow( rubban2(p.xyz), 2.) ) * coef*.01;\n  \n  col *= vec3(3.);\n\n  col = pow(col, vec3(1.2));\n  //col += texture(texFFT, length(uv)).rgb*100;\n  //col = mix( col.rgb, col.bgr, texture(iChannel0, vec2(uv.y*.5+.5,0.)).r*1.);\n  \n  col *= exp(-length(p.xyz-org)*.25);\n\n  uv = uv2;\n  uv.y -= texture(iChannel0, vec2(0.05,0.)).r*.2;\n  uv += vec2(.6,.25);\n  if( uv.x < .2 && uv.x > -.2 && uv.y < -abs(uv.x) && uv.y > -.2 && !( uv.x < .1 && uv.x > -.1 && uv.y+.2 > abs(uv.x) && uv.y < -.1 ))\n    col = vec3(1.,.8,.2);\n\n\n  fragColor = vec4(col,1.);\n}\n", "image_inputs": [{"id": "Xdl3zn", "previewfilepath": "https://soundcloud.com/suol/fritz-kalkbrenner-kings-in-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/suol/fritz-kalkbrenner-kings-in-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt2GDW", "name": "Birdie sins", "author": "such", "description": "Birdie sins marching", "tags": ["raymarching"], "likes": 1, "viewed": 126, "date": "1429199223", "time_retrieved": "2024-06-20T18:19:45.886818", "image_code": "/////////\n// Choose your sin\n\n//#define SIN_WRATH\n//#define SIN_GLUTTONY\n//#define SIN_SLOTH\n#define SIN_LUST\n//#define SIN_ENVY\n//#define SIN_GREED\n//#define SIN_PRIDE\n\n\n\n\n/////////\n// CODE\n\nconst float bend_back = 1.;\nuniform float height;\n\n// as allways, higher is better\n#define RM_MAX_ITER 15\n\n\n#define POSITIONSTR p+=vec3(1.0,.5,.0);\n\n// define one of these\n#define FUNKY_BACKGROUND\n\n// this is cool with FUNKY_BACKGROUND\n//#define ONLY_BEAK\n\n// woho!\n//#define DANCE_GROOVE\n//#define DANCE_FUNK\n\n//#define EAT_MUSHROOMS\n\n//#define UNDERCOVER\n\n//#define BANDANA\n\n//#define BACKGROUNDTEXTURE\n\n                \nfloat DISTANCE = 2.;\nfloat funkyness = 1e9;\n\n#ifdef SIN_SLOTH\nfloat closed_left_eye = 0.65;\nfloat closed_right_eye = 0.65;\n#else\nfloat closed_left_eye = 0.75;\nfloat closed_right_eye = 0.8;\n#endif\n\nconst float eps = 0.01;\n\nvec3 roty(vec3 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec3(v.z*sa + v.x*ca, v.y, v.z*ca - v.x*sa);\n}\n\n// raymarching CSG: min = union, max = intersection\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p,n)-d;\n}\n\nvec3 bendBody(vec3 p)\n{\n    // offset position to compute distance from to give the effect of the object moving\n    float bending = bend_back*0.025;\n    //float bending = 0.015*sin(4.*iTime);\n    p.z = p.z - p.y*p.y*bending;\n    #ifdef EAT_MUSHROOMS\n    p.x = p.x - sin(p.y);\n    #endif\n    #ifdef DANCE_GROOVE\n    float o = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    #ifdef DANCE_FUNK\n    float o2 = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o2;\n    p.y -= abs(o2);\n    #endif\n    #ifdef SIN_PRIDE\n    float iy = clamp(p.y,0.,1.);\n    p.x /= 1.+clamp(iy,0.,1.);\n    p.z /= 1.+clamp(iy,0.,1.);\n    #endif\n    #ifdef SIN_GREED\n    p = roty(p,1.32*iTime+sin(iTime)*3.112*p.y);\n    #endif\n    #ifdef SIN_WRATH\n    p.y += 0.1-0.3*abs(sin(10.*iTime));\n    #endif\n    #ifdef SIN_LUST\n    float iy = clamp(p.y,0.,1.);\n    p.x += (iy-iy*iy*iy*iy*0.6)*0.1*abs(sin(9.*iTime));\n    p.z += (iy-iy*iy*iy*iy*0.6)*0.1*abs(sin(9.*iTime));\n    #endif\n    #ifdef SIN_ENVY\n    p = roty(p,0.7*sin(iTime*3.112)*p.y*p.y*p.y*p.y);\n    #endif\n    #ifdef SIN_GLUTTONY\n    float iy = clamp(1.-p.y,0.,1.);\n    p.x *= 1.-(iy-iy*iy*iy*iy)*0.43*(2.+0.2*sin(3.123*iTime));\n    p.z *= 1.-(iy-iy*iy*iy*iy)*0.43*(2.+0.2*sin(3.123*iTime));\n    #endif\n    #ifdef SIN_SLOTH\n    float iy = clamp(p.y,0.,1.);\n    float o = iy*iy*bending*2.*sin(4.*iTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    return p;\n}\n\nfloat birdieBody(in vec3 p)\n{\n    // Model the body as a cylinder with varying radius\n    float y = clamp(p.y,0.,1.);\n\n    float r;\n\tfloat neck = 0.48;\n    if (y<neck)\n    \tr = mix(1.4,0.15,y/neck);\n    else\n    {\n        float t = 1. - (y-neck)/(1.-neck);\n        r = -.85*t*t*t*t + 1.;\n        r *= sin(acos(1.-t));\n    }\n    \n    float body = length(p.xz) - r*0.1;\n    return max(max(p.y-1.,-p.y),body);\n}\n\nfloat birdieBeak1(in vec3 p)\n{\n    float d_back = p.z - (-0.02);\n    float d_bottom = -(p.y - 0.57);\n    float d_left = sphere(p,vec3(-.15, 0.6, 0.02),.2);\n    float d_right = sphere(p,vec3(.15, 0.6, 0.02),.2);\n    \n    return max(max(d_left,d_right),max(d_bottom,d_back));\n}\n\nfloat birdieBeak2(in vec3 p,float openjaw)\n{\n    float d_back = p.z - (-0.02);\n    float d_top = plane(p, vec3(0.,1.,-.6-.3*openjaw), 0.6+.03*openjaw);\n    float d_left = sphere(p,vec3(-.115, 0.65, 0.06),.2);\n    float d_right = sphere(p,vec3(.115, 0.65, 0.06),.2);\n    \n    return max(max(d_left,d_right),max(d_top,d_back));\n}\n\nfloat birdieBeak(in vec3 p)\n{\n    float beak1 = birdieBeak1(p);\n    #ifdef SIN_LUST\n    float beak2 = birdieBeak2(p, -2.+pow(sin(iTime),31.));\n    #else\n    float beak2 = birdieBeak2(p, pow(sin(iTime),31.));\n    #endif\n    return min(beak1,beak2);\n}\n\nfloat birdieEyePupil(in vec3 p)\n{\n    float angley = sin(iTime);\n    float anglex = cos(iTime);\n    anglex = clamp(anglex,-.1,.3);\n    angley = clamp(angley,-.4,.4);\n    \n    anglex *= 0.1;\n    #ifdef SIN_SLOTH\n    angley *= 0.1;\n    #endif\n    #ifdef SIN_GLUTTONY\n    angley *= 0.25;\n    #endif\n    #ifdef SIN_PRIDE\n    anglex *= 10.;\n    #endif\n    #ifdef SIN_GREED\n    anglex *= 10.;\n    #endif\n\n\tanglex = 0.04*sin(anglex);\n    vec3 off1 = vec3( 0.04, 0.717+anglex, -0.048);\n    vec3 off2 = vec3( -0.04, 0.717+anglex, -0.048);\n\n    float ca = cos(angley);\n    float sa = sin(angley);\n    \n    off1 = vec3(off1.z*sa + off1.x*ca, off1.y, off1.z*ca - off1.x*sa);\n    off2 = vec3(off2.z*sa + off2.x*ca, off2.y, off2.z*ca - off2.x*sa);\n    \n    return min(length(p-off1),length(p-off2)) - .025; // distance to sphere\n}\n\nfloat birdieEyeWhite(float body,in vec3 p)\n{\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.69);\n    float d_top = plane(p,vec3(0.,1.,0.),0.9);\n    float d_sphere = min(sphere(p,vec3(0.1,0.75,-0.1),.1),\n                         sphere(p,vec3(-0.1,0.75,-0.1),.1));\n    return max(max(body,d_sphere),max(d_top,d_bottom));\n}\n\nfloat birdieBandana(float body,in vec3 p)\n{\n#ifdef BANDANA\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.85);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#else\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.92);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#endif\n#ifdef UNDERCOVER\n    return body;\n#else\n    return max(body,max(d_top,d_bottom));\n#endif\n}\n\nfloat birdieEyeLid(in vec3 p)\n{\n    float c = pow(sin(.82873*iTime),391.);\n    #ifdef SIN_LUST\n    float closed_left = closed_left_eye-(closed_left_eye-0.7)*c;\n    float closed_right = closed_right_eye-(closed_right_eye-0.7)*c;\n    #else\n    float closed_left = closed_left_eye+(0.9-closed_left_eye)*c;\n    float closed_right = closed_right_eye+(0.9-closed_right_eye)*c;\n    #endif\n    p.y = (p.y-0.75)*0.5 + 0.75;\n    float d_bottom = plane(p,vec3(-.8*(1.-closed_left),-1.,0.),-0.9 + 0.21*closed_left);\n    float d_sphere1 = sphere(p,vec3(-0.1,0.75,-0.1),.1);\n    float d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid1 = max(max(d_sphere1,d_sphere2),d_bottom);\n\n    d_bottom = plane(p,vec3(0.8*(1.-closed_right),-1.,0.),-0.9 + 0.21*closed_right);\n    d_sphere1 = sphere(p,vec3(0.1,0.75,-0.1),.1);\n    d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid2 = max(max(d_sphere1,d_sphere2),d_bottom);\n    return min(lid1,lid2);\n}\n\nvec4 birdie(in vec3 p)\n{\n\tPOSITIONSTR\n    p = bendBody(p);\n    float body = birdieBody(p);\n    float beak = birdieBeak(p);\n    float eyepupil = max(body,birdieEyePupil(p));\n    float eyewhite = birdieEyeWhite(body,p);\n    float eyelid = birdieEyeLid(p);\n    float ninjabandana = birdieBandana(body,p);\n    \n    #ifdef ONLY_BEAK\n    body += 10.;\n    eyepupil += 10.;\n    eyewhite += 10.;\n    eyelid += 10.;\n    #endif\n\n    float m = min(min(min(body,beak),min(eyepupil,eyewhite)),eyelid);\n    vec4 r;\n    if (m==beak) return vec4(0.8, 0.4, 0.2, m);\n    if (m==eyepupil) return vec4(0.0, 0.0, 0.0, m);\n    #ifdef SIN_GREED\n    if (m==ninjabandana) return vec4(1, 1, 0.0, m);\n    #endif\n    #ifdef SIN_PRIDE\n    if (m==ninjabandana) return vec4(0.34, 0.10, 0.55, m);\n    #endif\n    #ifdef SIN_WRATH\n    if (m==ninjabandana) return vec4(1.0, 0.0, 0., m);\n    #endif\n    #ifdef SIN_LUST\n    if (m==ninjabandana) return vec4(0.2, 0.4, 0.6, m);\n    #endif\n    #ifdef SIN_ENVY\n    if (m==ninjabandana) return vec4(0.0, 1.0, 0., m);\n    #endif\n    #ifdef SIN_GLUTTONY\n    if (m==ninjabandana) return vec4(0.6071, .3929, 0., m);\n    #endif\n    #ifdef SIN_SLOTH\n    if (m==ninjabandana) return vec4(0.05, 0.1, 0.4, m);\n    #endif\n    if (m==ninjabandana) return vec4(0.2795, 0.3489, .3716, m);\n    //if (m==ninjabandana) return vec4(0.1, 0.2, 0.3, m);\n    if (m==eyewhite) return vec4(1.0, 1.0, 1.0, m);\n    #ifdef SIN_WRATH\n    if (m==eyelid) return vec4(0.8, 0.5, 0.5, m);\n    #endif\n    if (m==eyelid) return vec4(0.6, 0.6, 0.6, m);\n    #ifdef SIN_WRATH\n    return vec4(1.0, 0.6, 0.6, m); // m==body\n    #endif\n    #ifdef SIN_ENVY\n    return vec4(0.6, 0.9, 0.6, m); // m==body\n    #endif\n    return vec4(0.8, 0.8, 0.8, m); // m==body\n}\n\nvec4 scene(in vec3 p)\n{\n    return birdie(p);\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz).w - scene(p - ep.xyz).w;\n    normal.y = scene(p + ep.yxz).w - scene(p - ep.yxz).w;\n    normal.z = scene(p + ep.yzx).w - scene(p - ep.yzx).w;\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    //float a = 3.14+1.4*iTime;\n    float a = 3.14+sin(.1*iTime);\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n\n    a = 0.1*sin(.1*iTime);\n    //a = 3.14+.4*iTime;\n    ca = cos(a);\n    sa = sin(a);\n\trayStart = vec3(rayStart.x, rayStart.z*sa + rayStart.y*ca, rayStart.z*ca - rayStart.y*sa);\n    rayDir = vec3(rayDir.x, rayDir.z*sa + rayDir.y*ca, rayDir.z*ca - rayDir.y*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    vec4 currentColor;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        currentColor = scene(p);\n\t\tt += currentColor.w;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    //vec3 normal = vec3(0,0,1);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    //            finalColor = normal;\n    //            finalColor = vec3(1,0,1) *\n    //                dot(vec3(1.,sin(iTime ),cos(iTime )),normal);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n    \n    if (currentColor.w>funkyness)\n    {\n        currentColor = vec4(0.,0.,0.,currentColor.w);\n    }\n\n    //float specular = 0.;\n    float ambient = 0.2;\n    finalColor = currentColor.xyz *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-1000.*currentColor.w) + length(finalColor)));\n\n    #ifdef BACKGROUNDTEXTURE\n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n    #endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lt2GWw", "name": "from 2D to 3D", "author": "Lio", "description": "The idea of this shader https://www.shadertoy.com/view/ls2SDd\nExperiments ...\nComment to see the 2D pattern - #define pattern3D", "tags": ["2d", "3d", "fractal"], "likes": 38, "viewed": 1556, "date": "1429626541", "time_retrieved": "2024-06-20T18:19:45.886818", "image_code": "const int MAX_RAY_STEPS = 64;\n#define time  iTime\n//Comment to see the 2D pattern\n#define pattern3D\n#define var1\n#ifdef var1\n\tfloat scale = 0.3;\n\tfloat size  = 0.45;\n\tfloat intens = 1.5;\n#else\n\tfloat scale = 0.55;\n\tfloat size  = 0.43;\n\tfloat intens = 1.21;\n#endif\n//-----------------------------\nvec3 rotationCoord(vec3 n, in float t)\n{\n   vec3 result;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n  result = n * rotate;\n  return result;\n}\n//----------------------------------------------------\nfloat pattern(in vec3 p) \n{\n   float v = 0.;\n   p *= scale;\n   for (int i = 0; i < 10; ++i) \n         p = abs(p) / dot(p, p) - vec3(size);\n   v = dot(p, p) * intens;\n   return v;\n\n}\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n  float maxDist = 30.;\n  float d = 0.1;  \n\n  for(int i=0; i<MAX_RAY_STEPS; ++i)\n  {\n    if (abs(d) <0.0001 || t > maxDist) \n         break;\n    t += d;\n    posOnRay += rayDir * 1.0/ (d + 0.35);\n    d = pattern(posOnRay);;     \n  }\n\n   return d;\n}\n\n//------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n    vec3 p= vec3(pos, 1. );\n    #ifdef var1\n    \tp *= scale;\n    #endif\n\n    vec3 col = vec3(0);  \n    float t = 0.;  \n  #ifdef pattern3D\n  {  \n    vec3 camP =  vec3(0., 0., -1.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(camDir * 2. + pos.x * u + pos.y * v);  \n\n    vec4 color    = vec4(1.0);\n    vec3 posOnRay = vec3(80., 0., 0.);\n  //--------------------------- \n   posOnRay = rotationCoord(posOnRay,time / 2.0);\n   rayDir = rotationCoord(rayDir,time / 2.0 + 3.14 / 2.0);\n   t = render(posOnRay, rayDir);\n  } \n  #else\n    t = pattern(p) ;\n #endif  \n    col = vec3(0.5 * t * t * t, 0.6 * t * t, 0.7 * t); \n    col = min(col, 1.0) - 0.28 * (log(col + 1.));\n    fragColor = vec4(sqrt(col.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltB3Dw", "name": "Psychofract", "author": "curena", "description": "animated fractal tree", "tags": ["fractal", "animated", "tree"], "likes": 32, "viewed": 4146, "date": "1429440249", "time_retrieved": "2024-06-20T18:19:45.899622", "image_code": "// \"Psychofract\" by Carlos Urea - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nmat3 tran1, \n     tran2 ; //transform matrix for each branch\n\nconst float pi = 3.1415926535 ;\n\nconst float rsy = 0.30 ; // length of each tree root trunk in NDC\n\n// -----------------------------------------------------------------------------\n\nmat3 RotateMat( float rads )\n{\n   float c = cos(rads),\n         s = sin( rads ) ;\n   \n   return mat3(  c,  s, 0.0,\n                -s,   c, 0.0,\n               0.0, 0.0, 1.0  );\n}\n// -----------------------------------------------------------------------------\n\nmat3 TranslateMat( vec2 d )\n{\n   return mat3(  1.0, 0.0, 0.0,\n                 0.0, 1.0, 0.0,\n                 d.x, d.y, 1.0 );\n}\n// -----------------------------------------------------------------------------\n\nmat3 ScaleMat( vec2 s )\n{\n   return mat3( s.x, 0.0, 0.0,\n                0.0, s.y, 0.0,\n                0.0, 0.0, 1.0 );\n}\n// -----------------------------------------------------------------------------\n\nmat3 ChangeFrameToMat( vec2 org, float angg, float scale )\n{\n   float angr = (angg*pi)/180.0 ;\n   return\n        ScaleMat( vec2( 1.0/scale, 1.0/scale ) )\n      * RotateMat( -angr )\n      * TranslateMat( -org ) ;\n}\n// -----------------------------------------------------------------------------\n\nfloat RectangleDistSq( vec3 p )\n{ \n   if ( 0.0 <= p.y && p.y <= rsy )\n       return p.x * p.x;\n    \n   if (p.y > rsy)\n       return p.x*p.x + (p.y-rsy)*(p.y-rsy) ;\n    \n   return p.x*p.x + p.y*p.y ;\n}\n// -----------------------------------------------------------------------------\n\nfloat BlendDistSq( float d1, float d2, float d3 )\n{\n   float dmin = min( d1, min(d2,d3)) ;\n      \n   return 0.5*dmin ; \n}\n// -----------------------------------------------------------------------------\n\nvec4 ColorF( float distSq, float angDeg )\n{\n   float b = min(1.0, 0.1/(sqrt(distSq)+0.1)),\n         v = 0.5*(1.0+cos( 200.0*angDeg/360.0 + b*15.0*pi ));\n     \n   return vec4( b*b*b,b*b,0.0,distSq) ; // returns squared distance in alpha component\n}\n// -----------------------------------------------------------------------------\n\nfloat Trunk4DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ); \n    \n   return d1 ;   \n}\n\n// -----------------------------------------------------------------------------\n\nfloat Trunk3DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ),\n         d2 = Trunk4DistSq( tran1*p ),\n         d3 = Trunk4DistSq( tran2*p );\n      \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n// -----------------------------------------------------------------------------\n\nfloat Trunk2DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ), \n         d2 = Trunk3DistSq( tran1*p ),\n         d3 = Trunk3DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n// -----------------------------------------------------------------------------\n\nfloat Trunk1DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ) ,\n         d2 = Trunk2DistSq( tran1*p ),\n         d3 = Trunk2DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n// -----------------------------------------------------------------------------\n\nfloat Trunk0DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ) ,\n         d2 = Trunk1DistSq( tran1*p ),\n         d3 = Trunk1DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n// -----------------------------------------------------------------------------\n// compute the color and distance to tree, for a point in NDC coords\n\nvec4 ComputeColorNDC( vec3 p, float angDeg )\n{   \n   vec2 org = vec2(0.5,0.5) ;\n   vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n   float dmin ;\n    \n   for( int i = 0 ; i < 4 ; i++ )\n   {\n      mat3 m = ChangeFrameToMat( org, angDeg + float(i)*90.0, 0.7 ); \n   \t  vec3 p_transf = m*p ;\n      float dminc = Trunk0DistSq( p_transf ) ;\n            \n      if ( i == 0 )\n         dmin = dminc ;\n      else if ( dminc < dmin )\n         dmin = dminc ;\n   }  \n   return ColorF( dmin, angDeg ); // returns squared dist in alpha component\n}\n// -----------------------------------------------------------------------------\n\nvec3 ComputeNormal( vec3 p, float dd, float ang, vec4 c00 )\n{\n   vec4   //c00  = ComputeColorNDC( p, ang )  ,\n         c10  = ComputeColorNDC( p + vec3(dd,0.0,0.0), ang )  ,\n         c01  = ComputeColorNDC( p + vec3(0.0,dd,0.0) , ang ) ;\n   float h00  = sqrt(c00.a),\n         h10  = sqrt(c10.a),\n         h01  = sqrt(c01.a);\n   vec3  tanx = vec3( dd, 0.0, h10-h00 ),\n         tany = vec3( 0.0, dd, h01-h00 );\n   vec3  n    = normalize( cross( tanx,tany ) );\n       \n   if ( n.z < 0.0 ) n *= -1.0 ; \n   return n ;\n}\n\n// -----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   const float width = 0.1 ;\n\n   \n   vec2  res  = iResolution.xy ;\n   float mind = min(res.x,res.y);\n   vec2  pos  = fragCoord.xy ;\n   float x0   = (res.x - mind)/2.0 ,\n         y0   = (res.y - mind)/2.0 ,\n         px   = pos.x - x0 ,\n         py   = pos.y - y0 ;\n      \n  \n   // compute 'tran1' and 'tran2':\n    \n   vec2  org1      = vec2( 0.0, rsy ) ;\n   float ang1_deg  = +20.0 + 30.00*cos( 2.0*pi*iTime/4.05 ),\n         scale1    = +0.85 +  0.40*cos( 2.0*pi*iTime/2.10 )  ;\n\n   vec2  org2      = vec2( 0.0, rsy ) ;\n   float ang2_deg  = -30.0 + 40.00*sin( 2.0*pi*iTime/2.52 ),\n         scale2    = +0.75 +  0.32*sin( 2.0*pi*iTime/4.10 )  ;\n   \n   tran1 = ChangeFrameToMat( org1, ang1_deg, scale1 ) ;\n   tran2 = ChangeFrameToMat( org2, ang2_deg, scale2 ) ; \n   \n   // compute pixel color (pixCol)\n    \n   float mainAng = 360.0*iTime/15.0 ,    // main angle, proportional to time\n         dd      = 1.0/float(mind) ;           // pixel width or height in ndc\n   vec3  pixCen  = vec3( px*dd, py*dd, 1.0 ) ; // pixel center\n   vec4  pixCol  = ComputeColorNDC( pixCen, mainAng ), \n         resCol  ;\n   \n   // compute output color as a function 'use_normal'\n   \n    const bool use_gradient = true ;\n    \n   if ( use_gradient )\n   {\n      vec3 nor     = ComputeNormal( pixCen, dd, mainAng, pixCol );\n      vec4 gradCol = vec4( max(nor.x,0.0), max(nor.y,0.0), max(nor.z,0.0), 1.0 ) ;\n       \n      resCol = 0.8*pixCol+ 0.2*gradCol ;\n   }\n   else\n      resCol = pixCol ;\n      \n       \n   fragColor = vec4( resCol.rgb, 1.0 ) ;\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltB3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltBGWz", "name": "my zone plate", "author": "ap", "description": "Just a zoneplate. Started at 433 characters until GregRostami's first comment.", "tags": ["zoneplate"], "likes": 4, "viewed": 1214, "date": "1428018988", "time_retrieved": "2024-06-20T18:19:45.899622", "image_code": "void mainImage(out vec4 o, vec2 i)\n{\n  float f=length(i)/iResolution.y;\n  o=vec4((1.+cos(1e3*mix(1.,sin(iTime),.3)*f*f))/2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltBGzG", "name": "Windows 8 style loader", "author": "BeRo", "description": "The Windows 8 style loader from the fr-078: Sweet night dreams 64k", "tags": ["windows", "loader", "fr078"], "likes": 16, "viewed": 1424, "date": "1429855916", "time_retrieved": "2024-06-20T18:19:45.901616", "image_code": "const float PI = 3.14159265359;\nfloat interpolateLinear(float a, float b, float t){\n  return mix(a, b, clamp(t, 0.0, 1.0));\n}\nfloat interpolateEaseOut(float a, float b, float t){\n  return mix(a, b, clamp(sin(clamp(t, 0.0, 1.0) * (PI * 0.5)), 0.0, 1.0));\n}\nfloat interpolateEaseInOut(float a, float b, float t){\n  return mix(a, b, clamp((cos((clamp(t, 0.0, 1.0) * PI) + PI) + 1.0) * 0.5, 0.0, 1.0));\n}\nvec2 rotate(vec2 v, float a){\n\treturn vec2((v.x*cos(a))-(v.y*sin(a)), (v.x*sin(a))+(v.y*cos(a)));\n}\nfloat t2;\nfloat line(vec2 p1, vec2 p2, vec2 p, float t){\n\tvec2 a = p - p1, b = p2 - p1;\n\ta = rotate(a, -atan(b.y, b.x));\n\treturn pow(clamp(t / ((a.x < 0.0) ? length(a) : ((a.x < length(b)) ? abs(a.y) : length(p - p2))), 0.0, 1.0), t2);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec4 c = vec4(vec3(0.0), 1.0);\n  vec2 p = (((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0) * vec2(1., iResolution.y / iResolution.x);\n\tvec2 cp = (p + vec2(0.0, 0.3275)) * 32.0;  \n  float t = mod(iTime, 5.5);\n  vec4 ec0 = vec4(43.0 / 255.0, 128.0 / 255.0, 255.0 / 255.0, 1.0);\n  vec4 ec1 = vec4(1.0);\n  vec2 pp = p - vec2(0.0, 0.125);\n  {\n    vec2 cp = (pp * 4.0) + vec2(0., 0.0);\n    cp.y *= 1.65;\n    cp.x += 0.005;\n    cp.y -= 0.3875;\n    float d = dot(cp, normalize(vec2(-0.5, -0.5))) + 0.5;\n    d = min(d, dot(cp, normalize(vec2(0.5, -0.5))) + 0.5);\n    d = min(d, dot(cp, normalize(vec2(0.5, 0.0))) + 0.5);\n    d = min(d, dot(cp, normalize(vec2(-0.5, 0.0))) + 0.5);\n    cp.y += 0.5;\n    d = min(d, dot(cp, normalize(vec2(0.5, 0.5))) + 0.5);\n    d = min(d, dot(cp, normalize(vec2(-0.5, 0.5))) + 0.5);\n\t\tc = ec0 * clamp(d * 64.0, 0.0, 1.0); \n  }\n  {\n    vec2 cp = (pp * 1.5) + vec2(0.43, -0.29);\n    vec2 ip = vec2(0.5, -0.5) / vec2(80.0, 80.0);\n    float envelope1 = clamp(texture(iChannel0, vec2(0., 0.25)).x, 0.0, 1.0);\n    float g = interpolateEaseInOut(0.002, 0.005, envelope1);\n    t2 = interpolateEaseInOut(4.0, 1.25, envelope1);  \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 69.) * ip, vec2(72., 67.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(72., 67.) * ip, vec2(72., 64.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(72., 64.) * ip, vec2(69., 62.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 62.) * ip, vec2(66., 64.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(66., 64.) * ip, vec2(66., 67.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(66., 67.) * ip, vec2(69., 69.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 62.) * ip, vec2(69., 59.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 59.) * ip, vec2(73., 57.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(73., 57.) * ip, vec2(60., 48.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(60., 48.) * ip, vec2(63., 45.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(63., 45.) * ip, vec2(78., 54.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(78., 54.) * ip, vec2(83., 51.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(83., 51.) * ip, vec2(69., 43.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 43.) * ip, vec2(73., 40.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(73., 40.) * ip, vec2(84., 47.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(84., 47.) * ip, vec2(84., 41.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(84., 41.) * ip, vec2(78., 37.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(78., 37.) * ip, vec2(84., 33.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(84., 33.) * ip, vec2(84., 37.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(69., 59.) * ip, vec2(52., 50.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(52., 50.) * ip, vec2(49., 52.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(82., 51.) * ip, vec2(86., 52.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(86., 52.) * ip, vec2(89., 50.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(89., 50.) * ip, vec2(90., 50.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(90., 50.) * ip, vec2(92., 52.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(92., 52.) * ip, vec2(92., 56.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(92., 56.) * ip, vec2(90., 58.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(90., 58.) * ip, vec2(89., 58.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(89., 58.) * ip, vec2(86., 56.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(86., 56.) * ip, vec2(86., 52.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(96., 57.) * ip, vec2(96., 26.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(96., 26.) * ip, vec2(68.5, 10.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(68.5, 10.) * ip, vec2(41., 26.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(41., 26.) * ip, vec2(41., 57.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(41., 57.) * ip, vec2(68.5, 73.) * ip, cp, g), 0.0, 1.0)); \n\t\tc = mix(c, ec1, clamp(line(vec2(68.5, 73.) * ip, vec2(96.0, 57.0) * ip, cp, g), 0.0, 1.0)); \n  }\n  for(int i = 0; i < 5; i++){\n\t  float ct = max(0.0, t - (float(i) * 0.24));\n\t  float cca = interpolateEaseInOut(225.0, 345.0, ct / 0.385);\n\t  cca = interpolateLinear(cca, 455.0, (ct - 0.385) / 1.265);\n\t  cca = interpolateEaseOut(cca, 690.0, (ct - 1.65) / 1.495);\n\t  cca = interpolateLinear(cca, 815.0, (ct - 2.149) / 1.705);\n\t  cca = (interpolateEaseOut(cca, 945.0, (ct - 3.85) / 0.275) * (PI / 180.0)) - (PI * 0.25);\n   \tc = mix(c, vec4(1.0), clamp(pow(1.0 - smoothstep(0., 1., length((vec2(sin(cca), cos(cca)) * 1.0) - cp) * 3.0), 8.0) * 2.0, 0.0, 1.0) * \n\t\t                      interpolateEaseOut(interpolateEaseOut(0.0, 1.0, (ct - 0.0) / 0.055), 0.0, (ct - 4.125) / 0.055));\n\t} \n    fragColor=c;\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltBGzK", "name": "2D Distance Field Visualization", "author": "chronos", "description": "A simple 2D distance field visualization to experiment with signed distance functions.\nMouse down to specify eye-position, drag to specify ray direction.", "tags": ["2d", "distancefield", "visualization", "spheretracing"], "likes": 46, "viewed": 2539, "date": "1430349348", "time_retrieved": "2024-06-20T18:19:46.383729", "image_code": "float signedDistanceHorizontal( in vec2 position ) { return position.y; }\nfloat signedDistanceVertical  ( in vec2 position ) { return position.x; }\n\nfloat signedDistanceSphere(in vec2 position, float radius ) { return length(position)-radius; }\nfloat signedDistanceBox(in vec2 p, in vec2 b) { return length(max((abs(p)-b),0.0)); }\n\nfloat unionOperation(in float d1, in float d2 ) { return min(d1,d2); }\n\nfloat scene(in vec2 position ) {\n    float sphere_radius = 0.25;\n\n    vec2 sphere_position = vec2(1.0, sin(iTime)) / 4.0;\n    sphere_position = position - sphere_position;\n\n    vec2 box_position = vec2(0.0, 0.5);\n    vec2 box_size     = vec2(pow(sin(iTime), 2.0), 0.25);\n    \n    // Compute distance functions\n    float plane_distance = signedDistanceVertical(position - vec2(sin(iTime/2.0)-0.75,0.0));\n    float sphere_distance = signedDistanceSphere(sphere_position, sphere_radius );\n\tfloat box_distance = signedDistanceBox(position - box_position, box_size);\n    \n    // Compose distance functions\n    float result = unionOperation(plane_distance, sphere_distance);\n    result = unionOperation(box_distance, result);\n    return result;\n}\n\n// Draws contour lines (level set, isolines)  in gray and zero set in blue.\nvec3 isolines(in vec3 position, float offset) {\n    float l = mod(offset * 08.0, 1.0);\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 border_color = vec3(0.0, 0.0, 1.);\n    float bands = clamp(-100.0 * l * (l - 0.2), 0.0, 1.0);\n    color *= bands;\n    color = mix(color * 0.05, border_color, 1.0-smoothstep(0.00, 0.015, abs(offset)));\n    return color;\n}\n\n// lifted from https://www.shadertoy.com/view/Mss3zH\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n    if(dot(a-b,a-b) == 0.0) return 1.0;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m  = abs(iMouse) / iResolution.xyxy;\n    vec2 c = 2.0 * uv - 1.0;\n    m = 2.0 * m - 1.0;\n    \n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    m.xz *= aspect_ratio; \n    \n    float distance = scene(c);\n    \n    vec3 color = isolines(vec3(c, 0.0), distance);\n    \n    // Mouse input:\n    vec2 mouse_down = m.zw;\n    vec2 mouse_drag = m.xy;\n    vec2 eye = normalize(mouse_drag-mouse_down);\n    vec2 p = mouse_down;\n    \n    for(int i = 0; i < 10; i++) {\n        float sample_distance = scene(p);\n    \tif(sample_distance < 0.01) break;\n    \tfloat cm = 8.0*(length(c - p) - sample_distance); // abs(sample_distance)\n        float circle = smoothstep(0.01, 0.05, cm) * smoothstep(0.01, 0.05, 0.1-cm);\n        color = mix(vec3(0.2, 1.0, 0.2), color, 1.0-circle);\n        p = p + eye * sample_distance;\n    }\n\n    if(any(notEqual(mouse_down, mouse_drag))) {\n    \tfloat d = distanceToSegment(mouse_down, p, c);\n    \tcolor = mix(vec3(1.0, 1.0, 0.0), color, smoothstep(0.005, 0.01, d));\n   \t}\n    color = mix(vec3(0.0, 1.0, 1.0), color, smoothstep(0.03, 0.04, length(c - mouse_down)));\n    color = mix(vec3(1.0, 1.0, 1.0), color, smoothstep(0.03, 0.04, length(c - mouse_drag)));\n\n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltBGzV", "name": "Loading Screen Test", "author": "anastadunbar", "description": "Trying to make a loading screen. This is pretty easy, I use clamp too much.", "tags": ["noob", "loading"], "likes": 9, "viewed": 237, "date": "1430343325", "time_retrieved": "2024-06-20T18:19:46.614135", "image_code": "//EDITED 2015-07-05 10:50\n//EDITED 2015-05-01 22:12\n//anastadunbar's (Original)\n\n#define PI 3.1415926535897932384\n#define SIZE 0.08\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec2 uva = ((uv-0.5)/vec2(1.,iResolution.x/iResolution.y)+0.5);\n    float a = clamp(1.-(pow(clamp(mod((atan((uva.x)-0.5,(uva.y)-0.5)-(time*2.6))/(PI*2.),1.), 0., 1.),3.)),0.,1.);\n    float b1 = 1.-clamp((length(vec2(uva.x,uva.y)-0.5)-(SIZE))*260.0, 0., 1.);\n    float b2 = 1.-clamp((length(vec2(uva.x,uva.y)-0.5)-(SIZE-0.03))*260.0, 0., 1.);\n    float b12 = clamp(b1-b2, 0., 1.);\n    float finish = clamp(b12-a, 0., 1.);\n\tfragColor = vec4(vec3(finish),1.0);\n}\n\n/*\n//m1el's (Much better version)\n#define TAU 6.2831853071795864769\n#define ROUT 0.15\n#define RIN  0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    float scale = 1.0/min(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) * scale;\n    float a = mod((atan(uv.x, uv.y) - time * 2.6) / TAU, 1.0);\n    float l = length(uv);\n    float circle = 1.0 - smoothstep(0., scale, max(l - ROUT, RIN - l));\n    fragColor = vec4(circle * a);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltBGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltfGDs", "name": "Fancy ties", "author": "nimitz", "description": "Sorry about the flares, JJ made me do it.\nI feel it's missing sound now.. ", "tags": ["procedural", "3d", "raymarching", "folding", "flares"], "likes": 86, "viewed": 10722, "date": "1428455531", "time_retrieved": "2024-06-20T18:19:48.796206", "image_code": "// Fancy ties by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltfGDs\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSomewhat complex modelling in a fully procedural shader that runs decently fast.\n\tI kinda cheated on the wings, the real ones are less hexagonal than this.\n\tNot doing proper occlusion checking for the lens flares to keep it fast.\n*/\n\n#define ITR 100\n#define FAR 155.\n#define time iTime\n\nconst float fov = 1.5;\n\n//Global material id (keeps code cleaner)\nfloat matid = 0.;\n\n//--------------------Utility, Domain folding and Primitives---------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 nmzHash22(vec2 q)\n{\n    uvec2 p = uvec2(ivec2(q));\n    p = p*uvec2(3266489917U, 668265263U) + p.yx;\n    p = p*(p.yx^(p >> 15U));\n    return vec2(p^(p >> 16U))*(1.0/vec2(0xffffffffU));\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\n\n//2dFoldings, inspired by Gaz/Knighty  see: https://www.shadertoy.com/view/4tX3DS\nvec2 foldHex(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.5, 0.8657);\n    const vec2 pl2 = vec2(-0.8657, 0.5);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    return p;\n}\n\nvec2 foldOct(in vec2 p)\n{\n    p.xy = abs(p.xy);\n    const vec2 pl1 = vec2(-0.7071, 0.7071);\n    const vec2 pl2 = vec2(-0.9237, 0.3827);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    \n    return p;\n}\n\nfloat sbox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t ){\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n//using floor() in a SDF causes degeneracy.\nfloat smoothfloor(in float x, in float k)\n{\n    float xk = x+k*0.5;\n    return floor(xk-1.) + smoothstep(0.,k,fract(xk));\n}\n\nfloat hexprism(vec3 p, vec2 h){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.y*0.866025+q.x*0.5),q.x)-h.x);\n}\n\n//------------------------------------------------------------------------\n\nvec3 position(in vec3 p)\n{\n    float dst =7.;\n    float id = floor(p.z/dst*.1);\n    p.xy += sin(id*10.+time);\n    p.z += sin(id*10.+time*0.9)*.5;\n    p = rotz(p,sin(time*0.5)*0.5+id*0.1);\n    p.z = (abs(p.z)-dst)*sign(p.z);\n    return p;\n}\n\nfloat map(vec3 p)\n{\n    matid= 0.;\n\tvec3 bp =p; //keep original coords around\n   \n    float mn = length(bp)-.7; //main ball\n    \n    //Cockpit\n    p.z -=0.8;\n    vec3 q = p;\n    q.xy *= mat2(0.9239, 0.3827, -0.3827, 0.9239); //pi/8\n    q.xy = foldOct(q.xy);\n    p.z += length(p.xy)*.46;\n    p.xy = foldOct(p.xy);\n    float g = sbox(p-vec3(0.32,0.2,0.),vec3(.3,0.3,0.04)); //Cockpit Spokes\n   \tfloat mg = min(mn,g);\n    if (mn < -g)matid = 2.;\n    mn = max(mn,-g);\n    float g2 = sbox(q,vec3(.45,0.15,.17)); //Cockpit center\n    if (mn < -g2)matid = 2.;\n    mn = max(mn,-g2);\n    mn = min(mn,torus(bp.yzx+vec3(0,-.545,0),vec2(0.4,0.035))); //Cockpit lip\n    mn = max(mn,-torus(bp+vec3(0,-.585,0),vec2(0.41,0.03))); //Hatch\n    \n    //Engine (Polar coords)\n    mn = max(mn,-(bp.z+0.6));\n    vec3 pl = bp.xzy;\n    pl = vec3(length(pl.xz)-0.33, pl.y, atan(pl.z,pl.x));\n    pl.y += .55;\n    mn =  min(mn,sbox(pl, vec3(.29+bp.z*0.35,.25,4.)));\n    pl.z = fract(pl.z*1.7)-0.5;\n    mn = min(mn, sbox(pl + vec3(0.03,0.09,0.), vec3(0.05, .1, .2)));\n    \n    p = bp;\n    p.x = abs(p.x)-1.1; //Main symmetry\n    \n    mn = min(mn, cyl(p.xzy-vec3(-0.87,.43,-0.48),vec2(.038,0.1))); //Gunports\n    \n    const float wd = 0.61; //Main width\n    const float wg = 1.25; //Wign size\n    \n    mn = min(mn, cyl(p.yxz,vec2(0.22+smoothfloor((abs(p.x+0.12)-0.15)*4.,0.1)*0.04,0.6))); //Main structure\n    vec3 pp = p;\n    pp.y *= 0.95;\n    vec3 r = p;\n    p.y *= 0.65;\n    p.z= abs(p.z);\n    p.z -= 0.16;\n    q = p;\n    r.y = abs(r.y)-.5;\n    mn = min(mn, sbox(r-vec3(-.3,-0.37,0.),vec3(0.35,.12-smoothfloor(r.x*2.-.4,0.1)*0.1*(-r.x*1.7),0.015-r.x*0.15))); //Side Structure\n    mn = min(mn, sbox(r-vec3(-.0,-0.5,0.),vec3(0.6, .038, 0.18+r.x*.5))); //Side Structure\n    p.zy = foldHex(p.zy)-0.5;\n    pp.zy = foldHex(pp.zy)-0.5;\n    mn = min(mn, sbox(p-vec3(wd,wg,0),vec3(0.05,.01,.6))); //wing Outer edge\n    q.yz = foldHex(q.yz)-0.5;\n    \n    \n    mn = min(mn, sbox(q-vec3(wd,-0.495-abs(q.x-wd)*.07,0.),vec3(0.16-q.z*0.07,.015-q.z*0.005,wg+.27))); //wing spokes\n    mn = min(mn, sbox(q-vec3(wd,-0.5,0.),vec3(0.12-q.z*0.05,.04,wg+.26))); //Spoke supports\n    \n    mn = min(mn, sbox(pp-vec3(wd,-0.35,0.),vec3(0.12,.35,.5))); //Wing centers\n    mn = min(mn, sbox(pp-vec3(wd,-0.35,0.),vec3(0.15+tri(pp.y*pp.z*30.*tri(pp.y*2.5))*0.06,.25,.485))); //Wing centers\n    \n    float wgn = sbox(p-vec3(wd,0,0),vec3(0.04,wg,1.));//Actual wings (different material)\n    if (mn > wgn)matid = 1.;\n    mn = min(mn, wgn);\n    \n    //Engine port\n    float ep = hexprism(bp+vec3(0,0,0.6),vec2(.15,0.02));\n    if (mn > ep)matid = 2.;\n    mn = min(mn, ep);\n\n    \n    return mn;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n        float res = map(position(ro+rd*d))*0.93;\n        h = res;\n    }\n\treturn d;\n}\n\n//greeble-ish texture\nfloat tex(in vec3 q)\n{\n    q.zy = foldOct(q.zy);\n    vec2 p = q.zx;\n    float id = floor(p.x)+100.*floor(p.y);\n    float rz= 1.0;\n    for(int i = 0;i<3;i++)\n    {\n        vec2 h = (nmzHash22(floor(p))-0.5)*.95;\n        vec2 q = fract(p)-0.5;\n        q += h;\n        float d = max(abs(q.x),abs(q.y))+0.1;\n        p += 0.5;\n        rz += min(rz,smoothstep(0.5,.55,d))*1.;\n        p*=1.4;\n    }\n    rz /= 7.;\n    return rz;\n}\n\nvec3 wingtex(in vec2 p, in float ds, in float ind)\n{\n    p.y *= 0.65;\n    p.x = abs(p.x)-0.14;\n    p = foldHex(p);\n    \n    //Fighting aliasing with distance and incidence.\n    float rz = smoothstep(0.07,.0,tri(p.x*7.5))*15.*(ind)/(ds*ds);\n    return vec3(1,.9,.8)*rz*0.7;\n}\n\nfloat mapHD(in vec3 p)\n{\n    float d= map(p);\n    d += tex(p*3.+vec3(4.,0.,0.))*0.03/(length(p)*.3+.9);\n    return d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.008;\n\treturn normalize(e.yxx*mapHD(p + e.yxx) + e.xxy*mapHD(p + e.xxy) + \n\t\t\t\t\t e.xyx*mapHD(p + e.xyx) + e.yyy*mapHD(p + e.yyy) );   \n}\n\n//form iq\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.13*float(i)/3.;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1. - 3.5*occ, 0.0, 1.0 );    \n}\n\n//smooth and cheap 3d starfield\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    //Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = nmzHash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*1.5;\n}\n\nvec3 flare(in vec2 p, in vec2 pos, in vec3 lcol, in float sz)\n{\n\tvec2 q = p-pos;\n    q *= sz;\n\tfloat a = atan(q.x,q.y);\n    float r = length(q);\n    \n    float rz= 0.;\n    rz += .07/(length((q)*vec2(7.,200.))); //horiz streaks\n    rz += 0.3*(pow(abs(fract(a*.97+.52)-0.5),3.)*(sin(a*30.)*0.15+0.85)*exp2((-r*5.))); //Spokes\n\t\n    vec3 col = vec3(rz)*lcol;   \n    col += exp2((1.-length(q))*50.-50.)*lcol*vec3(3.);\n    col += exp2((1.-length(q))*20.-20.)*lcol*vec3(1,0.95,0.8)*0.5;    \n    return clamp(col,0.,1.);\n}\n\n\n//A weird looking small moon\nfloat slength(in vec2 p){ return max(abs(p.x), abs(p.y)); }\nfloat moontex(in vec3 p)\n{\n    float r = length(p);\n    vec3 q = vec3(r, acos(p.y/r), atan(p.z,p.x));\n    q *= 6.5;\n    vec3 bq = q;\n    q.y = q.y*0.44-0.42;\n    vec2 id = floor(q.zy);\n    vec2 s = fract(q.zy)-0.5;\n    \n    float rz = 1.;\n    float z = 0.25;\n    for(int i=0;i<=3;i++)\n    {\n        vec2 rn = nmzHash22(id+vec2(i)+0.0019)*.6 + 0.4;\n        s -= abs(s)-rn*0.45;\n        rz -= smoothstep(0.5,0.45-float(i)*0.1,slength(s*rn*1.3))*z;\n        q *= 3.5;\n        z *= .85;\n        id = floor(q.zy);\n    \ts = fract(q.zy)-0.5;\n    }\n    \n    rz -= smoothstep(0.035,.03,abs(bq.y-10.15))*.3; //main trench\n    return rz;\n}\n\nfloat sphr(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h < 0.) return -1.;\n\telse return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo*=4.;\n\tmo.x += time*0.17+0.1;\n\n    vec3 ro = vec3(0.,0.,17.);\n    vec3 rd = normalize(vec3(vec2(-p.x,p.y),-fov));\n    float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n    mat3 inv_cam = mat3(0);\n    \n    if (cms < 0.5)\n    {\n        mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n        inv_cam = rot_y(-mo.x)*rot_x(mo.y); \n        ro *= cam;rd *= cam;\n    }\n    else\n    {\n        float frct = fract(time*0.15915);\n        float frct2 = fract(time*0.15915+0.50001);\n        float cms = 1.-step(sin((time+0.0001)*0.5),0.);\n        ro = vec3(-15.,1.-(step(frct2,0.5))*frct2*40.,140.-frct*280.);\n        vec3 ta = vec3(0);\n        vec3 fwd = normalize(ta - ro);\n        vec3 rgt = normalize(cross(vec3(0., 1., 0.), fwd ));\n        vec3 up = normalize(cross(fwd, rgt));\n        mat3 cam = mat3(rgt,up,-fwd);\n        rd = normalize(vec3(vec2(p.x,p.y),-fov))*cam;\n        inv_cam = transpose(cam);\n    }\n    \n\tfloat rz = march(ro,rd);\n\t\n    vec3 lgt = normalize( vec3(.2, 0.35, 0.7) );\n    vec3 col = vec3(0.0);\n    float sdt = max(dot(rd,lgt),0.); \n    \n    vec3 lcol = vec3(1,.85,0.73);\n    col += stars(rd);\n    \n    vec3 fp = (-lgt*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov, lcol,1.)*fp.z*1.1,0.,1.);\n    \n    //Another nearby star\n    vec3 lcol2 = vec3(0.25,.38,1);\n    vec3 lgt2 = normalize(vec3(-0.2,-.1,-0.8));\n    fp = (-lgt2*inv_cam);\n    col += clamp(flare(p,-fp.xy/fp.z*fov, lcol2,2.)*fp.z*1.1,0.,1.);\n    \n    //A \"moon\"\n    vec4 sph = vec4(2000,500,-700,1000);\n    float mn = sphr(ro,rd,sph);\n    \n    if (mn > 0.)\n    {\n        vec3 pos = ro+rd*mn;\n        vec3 nor = normalize(pos-sph.xyz);\n        vec3 dif = clamp(dot( nor, lgt ), 0., 1.)*0.985*lcol;\n        vec3 bac = clamp( dot( nor, lgt2), 0.0, 1.0 )*lcol2;\n        col = moontex((pos-sph.xyz))*vec3(0.52,0.54,0.7)*0.3;\n        col *= dif + bac*0.01 + 0.005;\n    }\n    \n    \n    if ( rz < FAR )\n    {\n        float mat = matid;\n        vec3 pos = ro+rz*rd;\n        pos = position(pos);\n        vec3 nor= normal(pos);\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lgt2), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),7.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 3.0 );\n        vec3 brdf = vec3(0.);\n        brdf += bac*mix(lcol2,vec3(1),0.5)*0.06;\n        brdf += 1.5*dif*lcol;\n        col = vec3(0.54,0.56,0.65)*1.1;\n        col *= col;\n        if (mat == 1.) \n        {\n            brdf *= 0.0;\n            spe *= 0.05;\n            fre *= 0.05;\n            brdf += wingtex(pos.zy,rz, max(dot(-rd,nor),0.)*0.5+0.5)*0.6;\n        }\n        else if (mat == 2.)\n        {\n            col = vec3(0);\n            spe *= 0.1;\n        }\n        \n        col = col*brdf + spe*.23 +.03*fre;\n        col *= getAO(pos,nor);\n    }\n    \n    col = clamp(col, 0.,1.);\n    col = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltj3W1", "name": "Revision 2015 Livecoding Round 1", "author": "mu6k", "description": "Written under 25 minutes at Revision 2015 live-coding qualifier round. I tried to adapt it by making as less modifications as possible. Put some music into iChannel0 and remove the comments from the first define.", "tags": ["3d", "raymarching", "livecoding"], "likes": 10, "viewed": 1394, "date": "1428740067", "time_retrieved": "2024-06-20T18:19:48.796206", "image_code": "//#define LIGHT_REACT_TO_MUSIC\n\n#define time iTime\n#define v2Resolution iResolution.xy\n#define texFFTSmoothed iChannel0\n#define texFFT iChannel0\n#define fGlobalTime iTime\n#define out_color fragColor\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\n\n\nfloat df ( vec3 p)\n{\n  p+=0.5;\n  float a=time*.3,cs=cos(a),ss=sin(a);\n  mat3 r = mat3(cs,0,ss,0,1,0,-ss,0,cs);\n\na=time*.4,cs=cos(a),ss=sin(a);\n  mat3 r2 = mat3(cs,ss,0, -ss,cs,0 ,0,0,1);\n\n\n  float e = .5;\n  p = abs(p*r*r2)-.5-sin(time)*.005;;\n  p = abs(p*r*r2)-.25-sin(time)*.005;\n  p = abs(p*r*r2)-.125-sin(time)*.005;\n  p = abs(p*r*r2)-.06125-sin(time)*.005;\n  p = abs(p*r*r2)-.0025-sin(time)*.005;\n  p = abs(p*r*r2)-.00025-sin(time)*.005;\n  return mix(length(p)-.02,max(p.x,max(p.y,p.z))-.02, sin(time)*.5+.5 );\n}\n\nvec3 nf (vec3 p)\n{\n  vec2 e = vec2(.0,.001);\n  float c = df(p);\n  return normalize(\n vec3(df(p+e.yxx), df(p+e.xyx), df(p+e.xxy))\n );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1.0 / length(uv) * .2;\n  float d = m.y;\n\n  float a=time*.2,cs=cos(a),ss=sin(a);\n  mat3 r = mat3(cs,0,ss,0,1,0,-ss,0,cs);\n\n  a=time*.37,cs=cos(a),ss=sin(a);\n  mat3 r2 = mat3(cs,ss,0, -ss,cs,0 ,0,0,1);\n\n  float zoom = sin(time*2.1)*.3+.5;\n  float distr = texture(texFFTSmoothed, vec2(pow(uv.y-.5,2.0))*44.0*(sin(time)*.5+.5,.0)).x;\n\n  vec3 p = vec3(.0,.0,-4.0+sin(time*.8)*0.5);\n  vec3 dir = normalize(vec3(uv*zoom,distr+1.0-length(uv)));\n\n  p*=r*r2;\n  dir*=r*r2;\n\n  for (int i=0; i<40; i++)\n  {\n    float d = df(p);\n    p += d*dir;\n    \n   }\n  \n  vec3 l = normalize(vec3(.1,.2,.3));\n\n  vec3 c = nf(p)/(1.0+df(p));\n  c=vec3(.5+df(p-l*.01)*.5+df(p-l)*.5+df(p-l*2.0)*.25);\n  c*= dot(nf(p),-l)*.5+.8;\n  float f = texture( texFFT, vec2(d,.0) ).r * 100.0;\n  \n    #ifdef LIGHT_REACT_TO_MUSIC\n  float beat = texture(texFFTSmoothed,vec2(.1,.0)).x*1.4;\n\t#else\n  float beat = .7;\n    #endif\n    \n    \n  c = min(vec3(1.0),c);\n\n  c-=texture(texFFTSmoothed,vec2(pow(uv.y*.5,2.0)*2.0-1.0,.0)).xxx*uv.x*2.0;\n\n  m.x += sin( fGlobalTime ) * 0.1;\n  m.y += fGlobalTime * 0.25;\n\n  c -= length(uv);\n  c += mix(vec3(.1,.4,.9), vec3(.9,.7,.2), (uv.y+.5));\n  //c -= .1;\n  vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n  t = clamp( t, 0.0, 1.0 );\n  out_color = vec4(c,1.0)*beat + t*.05;;\n}\n\n\n", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltj3Wh", "name": "Fractal Experiment 8 bis", "author": "aiekick", "description": "Fractal Experiment 8", "tags": ["fractal", "experiment", "8"], "likes": 3, "viewed": 374, "date": "1428656483", "time_retrieved": "2024-06-20T18:19:48.802150", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Iterations 150\n\n// https://www.shadertoy.com/view/XdsXWN\nvec2 dMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n\tc.x = l;\n\tc.y += r;\n\treturn c;\n}\n\n\n\nfloat getJulia(vec2 coord, int iter, float time, float seuilInf, float seuilSup)\n{ \n    vec2 uvt = coord;\n    float lX = -0.78;//-0.74;\n    float lY = time*0.115;//0.11\n    float julia = 0., x = 0., y = 0., j=0.;\n\tfor(int i=0; i<Iterations; i++) \n    {\n        if ( i == iter ) break;\n        x = (uvt.x * uvt.x - uvt.y * uvt.y) + lX;\n        y = (uvt.y * uvt.x + uvt.x * uvt.y) + lY;\n        uvt.x = x;\n        uvt.y = y;\n       \tj = mix(julia, length(uvt)/dot(x,y), 1.);\n        if ( j >= seuilInf && j <= seuilSup ) julia = j;\n    }\n    return julia;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // vars / time\n    float speed = 0.5;\n    float t0 = iTime*speed;\n    float t1 = sin(t0);\n    float t2 = 0.5*t1+0.5;\n    float t3 = 0.5*sin(iTime*0.1)+0.5;\n    float zoom = iTime*pow(2., iTime);\n    \n    // uv\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;uv.x*=ratio;uv/=zoom;\n    vec2 mo = iMouse.xy / iResolution.xy*2.-1.;mo.x*=ratio;mo/=zoom;\n\n    // map\n    vec2 uvt = uv;\n    \n    // julia\n    float ratioIter = 1.;\n    float ratioTime = t1;\n    if ( iMouse.z > 0. ) \n    {\n        ratioIter = iMouse.y/iResolution.y;\n        ratioTime = iMouse.x/iResolution.x*2.-1.;\n    }\n    \n    int nIter = int(floor(float(Iterations)*ratioIter));\n    float julia = getJulia(uvt+vec2(0.3,0.1), nIter, 1., 0.2, 8.5); // default => 0.2 / 6.5\n    \n    // color\n    float d0 = julia;\n    float d = smoothstep(d0-45.,d0+4.,1.);\n    float r = mix(1./d, d, 1.);\n    float g = mix(1./d, d, 3.);\n    float b = mix(1./d, d, 5.);\n    vec3 c = vec3(r,g,b);\n    \n    fragColor.rgb = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltjGDW", "name": "Colibri", "author": "koiava", "description": "Colibri renderer title design", "tags": ["text", "font", "colibri"], "likes": 10, "viewed": 547, "date": "1429197287", "time_retrieved": "2024-06-20T18:19:49.632521", "image_code": "//https://www.facebook.com/pages/Colibri/211589399026983\n//Colibri renderer title design\n//Designer: Nick Monaselidze\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n#define SPP 8\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define HALF_PI \t\t\t1.5707963\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.00001 \n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n\n    \nfloat textWidth = 25.0;\nfloat textHeight = 6.0;\n\nstruct Disk {\n    vec2 position_;\n    float radius_innder_;\n    float radius_outter_;\n    float angle_begin_;\n    float angle_end_;\n};\n    \nstruct Box {\n    vec2 position_;\n    vec2 dimensions_;\t//positive\n};\n\nbool pointInBox( vec2 p, Box box ) {\n    if( IN_RANGE( p.x, box.position_.x, box.position_.x + box.dimensions_.x ) &&\n      \tIN_RANGE( p.y, box.position_.y, box.position_.y + box.dimensions_.y ) )\n        return true;\n    \n    return false;\n}\n\nbool pointInDisk( vec2 p, Disk disk ) {\n    Box bbox = Box(disk.position_ - vec2(disk.radius_outter_)*1.01, vec2(disk.radius_outter_)*2.01 );\n    \n    //primitive level culling\n    if( !pointInBox( p, bbox ) )\n        return false;\n    \n    vec2 v = p - disk.position_;\n    \n    float rho_2 = dot(v,v);\n    float r1_2 = disk.radius_innder_*disk.radius_innder_;\n    float r2_2 = disk.radius_outter_*disk.radius_outter_;\n    \n    if( !IN_RANGE( rho_2, r1_2, r2_2 ) )\n        return false;\n    \n\tfloat theta = atan( v.y, v.x );\n    theta += PI;\n    \n    if( !IN_RANGE( theta, disk.angle_begin_, disk.angle_end_ ) )\n        return false;\n    \n    return true;\n}\n\nvec3 draw( vec2 uv ) {\n    vec3 fontColor = vec3( 1.0 );\n    vec3 bgColor = vec3( 0.0 );\n    \n    //Object level culling\n    Box bbox = Box( vec2(0.0), vec2(textWidth,textHeight) );\n    if( !pointInBox( uv, bbox ) )\n        return bgColor;\n    \n    //C\n    if( pointInDisk( uv, Disk( vec2( 3.0, 3.0 ), 2.0, 3.0, PI + HALF_PI, TWO_PI ) ) ||\n       \tpointInDisk( uv, Disk( vec2( 3.0, 3.0 ), 2.0, 3.0, 0.0, HALF_PI ) ) \t\t||\n       \tpointInDisk( uv, Disk( vec2( 5.0, 6.0 ), 0.0, 1.0, HALF_PI, PI ) ) \t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 4.0, 0.0 ), 0.0, 1.0, PI, PI+HALF_PI ) ) \t\t||\n      \tpointInBox( uv, Box( vec2( 3.0, 5.0 ), vec2( 2.0, 1.0 ) ) ) \t\t\t\t||\n      \tpointInBox( uv, Box( vec2( 3.0, 0.0 ), vec2( 1.0, 1.0 ) ) ) )\n        return fontColor;\n    \n    //o\n    if( pointInDisk( uv, Disk( vec2( 7.0, 2.0 ), 1.0, 2.0, 0.0, TWO_PI ) ) )\n        return fontColor;\n    \n    //l\n    if( pointInBox( uv, Box( vec2( 10.0, 0.0 ), vec2( 1.0, 5.0 ) ) ) \t\t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 10.0, 5.0 ), 0.0, 1.0, PI, PI+HALF_PI ) ) )\n        return fontColor;\n    \n    //i\n    if( pointInBox( uv, Box( vec2( 12.0, 0.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 12.0, 3.0 ), 0.0, 1.0, PI, PI+HALF_PI ) ) \t\t||\n      \tpointInDisk( uv, Disk( vec2( 13.0, 6.0 ), 0.0, 1.0, 0.0, HALF_PI ) ))\n        return fontColor;\n    \n    //b\n    if( pointInBox( uv, Box( vec2( 14.0, 2.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 14.0, 5.0 ), 0.0, 1.0, PI, PI+HALF_PI ) ) \t\t||\n       \tpointInDisk( uv, Disk( vec2( 16.0, 2.0 ), 1.0, 2.0, 0.0, TWO_PI ) ) )\n        return fontColor;\n    \n    //r\n    if( pointInBox( uv, Box( vec2( 19.0, 0.0 ), vec2( 1.0, 2.0 ) ) ) \t\t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 21.0, 2.0 ), 1.0, 2.0, PI+HALF_PI, TWO_PI ) ) \t||\n       \tpointInDisk( uv, Disk( vec2( 21.0, 4.0 ), 0.0, 1.0, HALF_PI, PI ) ) )\n        return fontColor;\n    \n    //i\n    if( pointInBox( uv, Box( vec2( 23.0, 0.0 ), vec2( 1.0, 3.0 ) ) ) \t\t\t\t||\n       \tpointInDisk( uv, Disk( vec2( 23.0, 3.0 ), 0.0, 1.0, PI, PI+HALF_PI ) ) \t\t||\n      \tpointInDisk( uv, Disk( vec2( 24.0, 6.0 ), 0.0, 1.0, 0.0, HALF_PI ) ))\n        return fontColor;\n\n    return bgColor;\n}\n\n//from iq\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 rgb = vec3( 0.0 );\n    \n    vec2 center = vec2( iResolution.xy )*0.5;\n    vec2 textPos = vec2(textWidth,textHeight)*0.5;\n    \n    float frameTime = 0.04;\n    float t1 = iTime;\n    float t2 = iTime + frameTime;\n    \n    //Stratified sampling for better Anti-Aliasing and Motion Blur\n    float subPixelSize = 1.0/float(SPP);\n    for( int y=0; y<SPP; y++ ) {\n        for( int x=0; x<SPP; x++ ) {\n            vec2 subPixelCoord = fragCoord + (vec2(x,y) + vec2(rnd(),rnd()))*subPixelSize;\n            \n            float Xi = rnd();\n            float t = Xi*t1 + (1.0-Xi)*t2;\n            float textScale = 8.0 + impulse( 8.0, mod(t,1.5) )*4.0;\n            rgb += draw( (1.0/textScale)*(subPixelCoord - (center - textPos*textScale)) );\n        }\n    }\n    rgb *= 1.0/float(SPP*SPP);\n    \n\tfragColor = vec4( rgb, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltjGzG", "name": "echo_partition", "author": "echophon", "description": "Exploring @paniq partition noise (http://glslsandbox.com/e#4841.11)", "tags": ["noise"], "likes": 2, "viewed": 115, "date": "1430093728", "time_retrieved": "2024-06-20T18:19:49.632521", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 hash(vec2 v) {\n    vec2 n;\n    n.x=fract(fract(v.y-v.x*831.0518)*(v.y+v.x)*3156.7821);\n    n.y=fract(fract(v.x+v.y*804.3048)*(v.x-v.y)*5349.2627);\n    return n;\n}\n\n\n//via http://glslsandbox.com/e#4841.11\nfloat partition_noise(vec2 p) {\n    float time = iTime; \n\tvec2 id;\n\tfloat a, b;\n\t\n\tid = floor(floor(p)-.5);\n\tp *= floor(hash(id) * 1.)+.5;\n\n\tid = floor(p);\n\tp.yx *= floor(hash(id) * 3.)-2.*mix(sin(time*.013), sin(time*0.004), 1.0);\n\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\tp -= id;\n\n    vec2 u = abs(p - .5) * 2.;\n\t\n\t//return max(u.x, u.y);\n\t//return min(u.x, u.y);\n    \n\treturn mix(u.x, u.y, 0.0);\n    //return mix(u.x, u.y, step(sin(time),u.y) );\n\t//return step(u.x, u.y);\n\t//return clamp(0.0, u.x, u.y);\n\t//return smoothstep(u.x, u.y, sin(time*4.)*1.75 );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime; \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tuv *= 12.;\n\tuv += iMouse.xy * 1.;\n\tuv += time*0.5;\n\n\tfragColor = vec4(partition_noise(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltS3Dh", "name": "Stairs", "author": "dila", "description": "Coloured light projection test.", "tags": ["light", "window", "stairs", "project"], "likes": 28, "viewed": 950, "date": "1429979343", "time_retrieved": "2024-06-20T18:19:49.632521", "image_code": "#define DUST_SAMPLES 0\n#define WND_DIST 2.0\n#define WND_WIDTH 3.5\n#define WND_HEIGHT 3.0\n#define WND_FREQ 8.0\n\nconst float pi = 3.14159265359;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat infBox( vec3 p, float b )\n{\n  \treturn max(abs(p.x)-b,0.0);\n    //p.y -= p.z * 0.5;\n    //return length(max(abs(p.xy)-vec2(b,10.0),0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 post(vec3 pos, float t)\n{\n    //pos.x += sin(t*0.25) * 2.0;\n    return pos;\n}\n\nvec3 glass(vec3 pos, vec3 size)\n{\n    //return vec3(1.0, 1.0, 0.0);\n\tvec2 uv = pos.zy / size.zy;\n    uv.x *= WND_WIDTH / WND_HEIGHT;\n    \n    vec2 auv = abs(uv);\n    \n    if (auv.x > 1.0 || auv.y > 1.0) {\n        //return vec3(1.0, 1.0, 0.5);\n    }\n    \n    vec2 bv = fract(uv*5.0) * 2.0 - 1.0;\n    vec2 fl = floor(uv*5.0);\n    \n    float lt = -0.8;\n    if (bv.x<lt || bv.y<lt) {\n    \treturn vec3(0.0);\n    }\n    \n    vec3 col = vec3(cos(fl.x)*cos(fl.y),\n                    sin(fl.x)*cos(fl.y),\n                    sin(fl.y));\n    \n    col = col * 0.25 + 0.75;\n    \n\treturn col;\n}\n\nvec3 glassrep(vec3 pos)\n{\n    float wdist = 4.5;\n    float sp = WND_FREQ;\n    vec3 wps = pos;\n    wps.y -= floor(wps.z/sp) * sp * 0.5;\n    wps.z = fract(wps.z/sp)*sp;\n    float wndx = abs(wps.x);\n    vec3 wnd = vec3(wdist-wndx, wps.y-5.0, wps.z-4.0);\n    return glass(wnd+vec3(0.0,WND_DIST,0.0), vec3(2.0,WND_HEIGHT,WND_WIDTH));\n}\n\nvec2 staircase(vec3 pos)\n{\n    vec3 spos = pos;\n    vec3 lpos = vec3(spos.x,pos.y,spos.z);\n    float d = 1000.0;\n    for (int i = -1; i <= 1; ++i) {\n        float repz = fract(-lpos.z) * 0.5 - 0.5 + float(i);\n        float stepinc = floor(lpos.z);\n        vec3 crep = vec3(lpos.x, (lpos.y*2.0-stepinc-float(i)), repz);\n        float k = udBox(crep, vec3(6.0, 2.0, 1.0)*0.5);\n        d = min(d, k);\n    }\n    return vec2(d,1.0);\n}\n\nbool alpha;\n\nvec2 walls(vec3 pos)\n{\n    float wdist = 4.5;\n    vec3 axp = vec3(wdist-abs(pos.x), pos.y, pos.z);\n    float pl = infBox(axp, 1.0);\n    \n    float d = 1000.0;\n    for (int i = -1; i <= 1; ++i) {\n        float sp = WND_FREQ;\n        vec3 wps = pos;\n        wps.y -= floor(wps.z/sp) * sp * 0.5;\n        wps.z = fract(wps.z/sp)*sp;\n        wps.z += float(i) * sp;\n        float wndx = wps.x;//abs(wps.x);\n        vec3 wnd = vec3(wdist-wndx, wps.y-5.0, wps.z-4.0);\n        float wp = sdBox(wnd+vec3(0.0,WND_DIST,0.0), vec3(2.0,WND_HEIGHT,WND_WIDTH));\n        d = min(d, wp);\n    }\n    float fd = max(pl, -d);\n    return vec2(fd, 2.0);\n}\n\nvec2 skybox(vec3 pos)\n{\n\tfloat ps = abs(pos.y) - 20.0 - pos.z * 0.5;\n    return vec2(-ps, 0.0);\n}\n\nvec2 pane(vec3 pos)\n{\n    if (!alpha) {\n        float gl = 4.5 - abs(pos.x);\n        return vec2(gl, 3.0);\n    }\n    return vec2(1000.0, 3.0);\n}\n\nfloat material(vec3 pos)\n{\n\tvec2 sa = staircase(pos);\n    vec2 wp = walls(pos);\n    if (wp.x < sa.x) {\n    \tsa = wp;\n    }\n    wp = pane(pos);\n    if (wp.x < sa.x)\n    {\n        sa = wp;\n    }\n\treturn sa.y;\n}\n\nfloat map(vec3 pos)\n{\n\tvec2 sa = staircase(pos);\n    vec2 wp = walls(pos);\n\tvec2 pn = pane(pos);\n\treturn min(min(sa.x,wp.x),pn.x);\n}\n\nvec3 surfaceNormal(vec3 pos)\n{\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 pos = o + r * t;\n        float d = map(post(pos,t));\n        if (abs(d)<0.0001) {\n            break;\n        }\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 lightpos(vec3 world)\n{\n    //vec3 lps = vec3(10.0,0.0,0.0) * zrot(iTime);\n    vec3 lps = vec3(10.0,4.0,-2.5);\n    return lps;\n}\n\nvec3 light(vec3 world, vec3 wsn)\n{\n    vec3 col = vec3(0.0);\n    float lm = 1.0;\n    vec3 lps = lightpos(world);\n    vec3 lp = world + lps;\n    vec3 ublv = world - lp;\n    vec3 lv = ublv + wsn * 0.01;\n    float ld = length(lv);\n    lv /= ld;\n    float lt = trace(lp, lv);\n    if (lt >= ld) {\n\t\tvec3 plane = vec3(1.0, 0.0, 0.0);\n        vec3 porg = vec3(3.5, 0.0, 0.0);\n        vec3 del = porg - world;\n        float x = dot(del, plane) / dot(normalize(ublv), plane);\n\t\tvec3 proj = world + lv * x;\n        col = glassrep(proj);\n    }\n    return col;\n}\n\nvec2 projtex(vec3 p, vec3 sn)\n{\n    vec3 asn = abs(sn);\n    float msn = max(asn.x, max(asn.y, asn.z));\n    if (asn.x == msn) {\n        return vec2(p.y, p.z);\n    } else if (asn.y == msn) {\n        return vec2(p.x, p.z);\n    } else {\n        return vec2(p.x, p.y);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ns = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*0.33)) * 0.95;\n    \n    //r *= xrot(-pi*0.2);\n    //r *= yrot(iTime*0.25);\n    r *= yrot(-pi*0.3);\n    \n    float gt = iTime * 1.0;\n    \n    vec3 o = vec3(0.0,1.0,2.0) * gt;\n    \n    float eve = abs(sin(gt*10.0))*0.25;\n    o += vec3(0.0, 4.0, 0.0);\n    \n    alpha = false;\n    float t = trace(o, r);\n    \n    vec3 world = o + r * t;\n    vec3 wsn = surfaceNormal(post(world,t));\n    float tp = max(dot(wsn,-r), 0.0);\n    \n    float fd = map(post(world,t));\n    float fog = 1.0 / (1.0 + t * t * 0.01 + fd * 100.0);\n    \n    vec2 tuv = projtex(world, wsn) * 0.2;\n    vec3 texf = texture(iChannel1, tuv).xyz;\n    vec3 diff = texf * 0.5;\n    \n    if (material(world) == 3.0) {\n\t\tdiff = glassrep(world) * 0.25;\n        //vec3 ref = reflect(wsn, -r);\n        //vec3 rtex = texture(iChannel1, ref).xyz;\n        //diff = mix(diff, rtex, 1.0-tp);\n    }\n    \n    alpha = true;\n    \n\tvec3 lm = light(world, wsn);\n    \n    const int ni = DUST_SAMPLES;\n    vec3 vol = vec3(0.0);\n    for (int i = 0; i < ni; ++i) {\n        vec3 rll = r * zrot(float(i)/float(ni)*pi*2.0);\n        float xtex = atan(rll.z,rll.x);\n        vec2 ltf = vec2(xtex,rll.y) * 1.0;\n        float bs = texture(iChannel0, ltf).x;\n        bs = min(pow(bs,2.0),1.0);\n        float td = bs * min(t,20.0);\n        float tds = 1.0 / (1.0 + td * 0.01);\n        vec3 p = o + r * td;\n        vec3 vl = light(p,vec3(0.0));\n        vol += vl / float(ni) * tds;\n    }\n    \n    float skyp = 1.0 / (1.0 + t * t * 1.0);\n    \n    vec3 lpos = lightpos(world);\n    vec3 ldel = normalize(lpos - world);\n    float ldn = abs(dot(ldel,-wsn));\n    vec3 refv = reflect(ldel, wsn);\n    float spd = max(dot(refv, -r), 0.0);\n    \n    //diff += vec3(1.0) * pow(spd,4.0);\n    \n    vec3 fogc = vec3(255.0, 255.0, 255.0) / 255.0;\n    \n    //diff *= 0.25;\n    \n    vec3 fc = diff * fog;//mix(fogc, diff, fog);\n    \n    vec3 lit = lm * fog + vol;// * (1.0 + t * 0.05);\n    \n    fc += lit;\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltSGRG", "name": "Experiment#DF2", "author": "tomkh", "description": "New version: [url=https://shadertoy.com/view/llSGRy]llSGRy[/url]  and [url=https://shadertoy.com/view/Xt23zG]Xt23zG[/url].\nInspired by \"The evolution of motion\" (by x1Tr1m), NVScene15 seminar (by Cupe) and pouet discussion.", "tags": ["3d", "raymarching", "distancefields"], "likes": 12, "viewed": 529, "date": "1429816435", "time_retrieved": "2024-06-20T18:19:50.542148", "image_code": "// Just for my own educational purposes...\n// tomkh@2015\n\n#define SCENE 0\n// 0 = centered bboxes\n// 1 = centered decorated bboxes\n// 2 = non-centered bboxes\n\nconst int ray_steps = 80;\nconst float dist_max = 10.0;\nconst float fog_start = 8.0;\nconst float fog_density = 0.15;\nconst float cam_dist = 10.0;\n\n// Tile space:\nconst float tile_d = 2.0;\nconst float tile_ood = 1.0/tile_d;\n\n// +-----+-----+\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// +-----+-----+\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A, B, C and D are our tiles (aka cells).\n// We have to assume max/min height for tiles outside A,B,C,D.\n// We call \"frame\", a bounding area for everything outside A,B,C,D (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles (A,B,C,D) (TODO: use distance-dependent rough estimation ala Cupe)\n//   and bound it additionally to distance to frame.\n// Note:\n//   Actually you would need this \"frame\" only in extreme cases\n//   (i.e. variations in height, some tiles almost empty),\n//   but I've added it here anyway just for correctness,\n//   as this is a framework that I plan to reuse in other experiments.\n\nfloat dist2frame(vec3 p, float box_y)\n{\n    vec3 dp = vec3(\n        tile_d-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d-abs(p.z));\n    return length(vec2(min(dp.x,dp.z),dp.y));\n}\n\nfloat dist2box(vec3 p, float box_x, float box_y, float box_z, float box_r)\n{\n    // Distance to rounded box:\n    vec3 dp = vec3(\n        max(0.0,abs(p.x)-box_x),\n        max(0.0,abs(p.y)-box_y),\n        max(0.0,abs(p.z)-box_z));\n    return length(dp) - box_r;\n}\n\nfloat evaluate_tile(vec3 p, vec3 p_id, float dx, float dy)\n{\n    p_id.xz += vec2(dx,dy);\n    p.xz -= vec2(dx-.5,dy-.5)*tile_d;\n    float anim = iTime*.25;\n#if SCENE == 2\n    float p1 = 0.1 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*.9;\n    float id = p_id.x + p_id.z;\n    vec3 p2 = p + vec3(cos(id*3.0+anim*1.11),0,sin(id*3.0+anim*1.11))*.5;\n    float dist = dist2box(p2, .25, p1, .25, 0.025);\n#else\n    float p1 = 0.2 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*.8;\n    float p2 = 0.2 + abs(cos(p_id.x+anim*.5)*cos(p_id.z+anim*.66))*.7;\n    float dist = dist2box(p, p2, p1, p2, 0.025);\n    #if SCENE == 1\n        dist = min(dist, dist2box(p, p2+.1, p1-.1, .1, 0.025));\n        dist = min(dist, dist2box(p, .1, p1-.1, p2+.1, 0.025));\n    #endif\n#endif\n    return dist;\n}\n\nfloat get_distance(vec3 p)\n{\n    vec3 p_id = vec3(\n        floor(p.x*tile_ood),\n        0,\n        floor(p.z*tile_ood));\n    \n    p = vec3(\n        (fract(p.x*tile_ood)-.5)*tile_d,\n        p.y, //(fract(p.y*tile_ood)-.5)*tile_d,\n        (fract(p.z*tile_ood)-.5)*tile_d);\n    \n    float dist = dist2frame(p, 1.0);\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 1.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 1.0));\n\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    const float eps = 1e-3;\n    const vec3 x_eps = vec3(eps,0,0);\n    const vec3 y_eps = vec3(0,eps,0);\n    const vec3 z_eps = vec3(0,0,eps);\n    return normalize(vec3(\n        get_distance(p + x_eps) - get_distance(p - x_eps),\n        get_distance(p + y_eps) - get_distance(p - y_eps),\n        get_distance(p + z_eps) - get_distance(p - z_eps) ));\n}\n\nvec3 trace(vec3 p_start, vec3 n)\n{\n    float ray_len;\n    float dist;\n    const float dist_eps = .001;\n    vec3 p = p_start;\n    for(int k=0; k<ray_steps; ++k) {\n    \tdist = get_distance(p);\n        if (dist < dist_eps || dist > dist_max) break;\n        p += dist*n;\n        ray_len += dist;\n    }\n    \n    //vec3 light_dir = normalize(vec3(.1,1.0,-.3));\n    float light_ang = iMouse.x/iResolution.x*3.0;\n    vec3 light_dir = normalize(vec3(cos(light_ang),2.0,-sin(light_ang)));\n    vec3 normal = get_normal(p);\n    float shade = 0.0;\n    if (dist < dist_eps) {\n        //shade = (1.0 - dist/dist_eps)*dot(normal, light_dir);\n        shade = dot(normal, light_dir);\n        shade = max(0.0, shade);\n    }\n    \n    vec3 base_color = vec3(1.0,1.0,1.0);\n    vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),shade)*base_color;\n    \n    // Test ray with cut_plane:\n    float cut_plane = (iMouse.y / iResolution.y - 0.1) * 4.0;\n    if (p_start.y > cut_plane) {\n    \tfloat d = (p_start.y - cut_plane) / -n.y;\n        if (d < ray_len) {\n            vec3 hit = p_start + n*d;\n            float iso = fract(get_distance(hit)*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            color = mix(color,dist_color,.5);\n            ray_len = d;\n        }\n    }\n    \n    vec3 fog_color = vec3(.8,.8,.8);\n    float fog = 1.0-1.0/exp(max(0.0,ray_len-fog_start)*fog_density);\n    color = mix(color,fog_color,fog);\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = -0.2; //iMouse.x / iResolution.x * 2.0 - 1.0; \n    a += cos(anim)*.05;\n    float co = cos(a);\n    float si = sin(a);\n    vec3 p1 = vec3(-cam_dist*si, 0, -cam_dist*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //a = iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2 - 2.0;\n    a = -.4;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = vec4(trace(p2, n3), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltSGRV", "name": "Exovoid Logo", "author": "roberto", "description": "I'm a newbie in the shaders world, this is my first one.\nSimple test using my company logo ;) ", "tags": ["procedural", "raymarching", "noise", "distancefield", "perlin"], "likes": 1, "viewed": 134, "date": "1430316894", "time_retrieved": "2024-06-20T18:19:51.650829", "image_code": "//------------------------------------------------------------------------------------------\n//Exovoid logo fragment shader using raymarching, by Roberto Marra @shagan\n//Lighting from IQ\n//Thanks to Inigo Quilez for all explanations and articles. \n\n\n\n\nfloat perlin(vec3 p) {\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z);\n}\n\n\nvec2 merge(vec2 d1,vec2 d2) {\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat merge_substract( float d1, float d2) {\n    return max(-d2,d1);\n}\n\nfloat subPlane(vec3 p,float time) {    \n   vec3 noise=perlin(vec3(p.x,p.y,p.z))+vec3(sin(time)+cos(time));\n   return p.y-clamp(noise.z,-0.1,0.25);\n}\n\nfloat subSphere(vec3 p,float rad) {\n    return length(p)-rad;\n}\n\nfloat subBox(vec3 p,vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\n\nvec2 map( in vec3 pos ) {\n\tfloat time = iTime*2.0;\n    vec2 res = vec2(subPlane(pos,time), 1.0 );\n\n    float depth=0.2;\n\n    res = merge(res,\n        vec2(\n            subBox(pos,vec3(2.8,2,depth)),2\n            )\n          );\n\n\n    res = merge(res,\n        vec2(\n            subBox(pos-vec3(0,1,0),vec3(0.8,0.8,depth)),3\n            )\n          );\n\n    res = merge(res, vec2(\n         merge_substract(\n         subBox(pos-vec3(0,1,0),vec3(0.2,1,depth)),\n         subBox(pos-vec3(0,1,0),vec3(0.5,0.5,depth))\n         ),2\n         ));\n\n    res = merge(res,vec2(subBox(pos-vec3(0,1,0),vec3(0.5,0.5,depth)),2));\n\n    res = merge(res, vec2(subBox(pos-vec3(-1,1,0),vec3(0.2,0.2,depth)),3.0));\n    res = merge(res, vec2(subBox(pos-vec3(1,1,0),vec3(0.2,0.2,depth)),3.0));\n    res = merge(res, vec2(subBox(pos-vec3(1.7,abs(sin(time)+cos(time))*0.75,-1.),vec3(0.2,0.2,0.2)),5.0));\n\n    return res;\n}\n\nvec2 castRay( in vec3 rayOrigin, in vec3 rayDirection ) {\n    float tmin = 0.1;       //travel min\n    float tmax = 20.0;      //travel max\n\tfloat precis = 0.0002;  //precision\n    float step = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ ) {\n\t    vec2 res = map(rayOrigin+rayDirection*step);\n\n        if( res.x<precis || step>tmax ) break;  //check limit\n\n        step += res.x;\n\t    m = res.y;\n    }\n\n    if( step>tmax ) m=-1.0;\n    return vec2( step, m );\n}\n\n\n//---- Lighting from Inigo Quilez  ---------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 calcLight(in vec3 col, in vec3 pos, in vec3 rd) {\n         vec3 nor = calcNormal( pos );\n         vec3 ref = reflect( rd, nor ); //calculate the reflection direction for an incident vector\n         float occ = calcAO( pos, nor );\n \t\t vec3  lig = normalize( vec3(0,2,-2.));\n \t\t float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n         float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n         float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n         float dom = smoothstep( -0.1, 0.1, ref.y );\n         float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n \t\t float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n         dif *= softshadow( pos, lig, 0.5, 2.5 );\n         dom *= softshadow( pos, ref, 0.5, 2.5 );\n\n \t\t vec3 brdf = vec3(0);\n         brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n \t\t brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n         brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n         brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n         brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n         brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n \t\t brdf += 0.02;\n \t\t col = col*brdf;\n         return col;\n}\n//------------------------------------------------------------------------------------------\n\n\n\nvec3 render( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0.8, 0.9, 1.0);\n\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>0.) {\n        vec3 pos = ro + t*rd;\n\n        // material\n        if(m==3.0) {\n            col= vec3(0);\n        }else if(m==5.0){\n            col= vec3(0,0.68,0.92);\n        }else{\n            col= vec3(1);\n        }\n\n        if( m<1.5){\n            float f = mod( floor(2.0*pos.x)+floor(2.0*pos.z) , 2.0);\n            vec3 cc = vec3(clamp(0.5*f,0.3,1.0));\n            cc =  vec3(cc.x*0.5,cc.y*0.7,cc.z*0.9);\n            col = clamp(cc,0.,1.);\n        }\n\n        col = calcLight(col,pos,rd);\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) ); \n}\n\n\nmat3 getRotMatrix(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   \tfloat g_aspectRatio = iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    float focalLength = 1.5;\n\n    vec3 camPos\t\t= vec3(0, 1, -5);\t\t\t\t\t\t// The eye position in the world\n    vec3 camUp\t\t= normalize(vec3(0.0, 1.0, 0.0));\t\t// The upward-vector of the image plane\n    vec3 camRight\t= normalize(vec3(1.0, 0.0, 0.0));\t\t// The right-vector of the image plane\n    vec3 camForward\t= cross(camRight, camUp);\t    \t\t// The forward-vector of the image plane\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 uv = -1.0+2.0*q;\n\n    vec3 ang = vec3(0.0,0,sin(iTime * 0.5));\n    if(iMouse.z > 1.0) ang = vec3(0.0,-1.0*iMouse.y*0.001,iMouse.x*0.01);\n    mat3 rot = getRotMatrix(ang);\n\n\tvec3 ro = camPos;\n\tvec3 rd = normalize((camForward * focalLength) + (camRight * uv.x * g_aspectRatio) + (camUp * uv.y));\n\n    ro *= rot;\n    rd *= rot;\n\n    vec3 col = render( ro, rd );\n    \n    \n    fragColor=vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltSGWm", "name": "php screensaver", "author": "FMS_Cat", "description": "I have never wrote php\n\nReferences :\nhttps://www.shadertoy.com/view/lts3Df\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf", "tags": ["2d"], "likes": 5, "viewed": 230, "date": "1430216868", "time_retrieved": "2024-06-20T18:19:52.056913", "image_code": "#define t iTime*100.\n#define r iResolution.xy\n#define c fragCoord\n#define V vec2(0.,1.)\n#define cl(i) clamp(i,0.,1.)\n\n// https://www.shadertoy.com/view/lts3Df\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b ) { return a + ( b - a ) * cl( -dot( a, b - a ) / dot( b - a, b - a ) ); }\n\nvec2 getDistanceVector( vec2 b0, vec2 b1, vec2 b2 )\n{\n\t\n    float a = det( b0, b2 );\n    float b=2.0 * det( b1, b0 );\n    float d=2.0 * det( b2, b1 );\n    \n    if( abs( 2.0*a + b + d ) < 100.0 ) { return closestPointInSegment( b0, b2 ); }\n\t\n    float f = b*d - a*a;\n    \n    vec2 d21 = b2 - b1;\n    vec2 d10 = b1 - b0;\n    vec2 d20 = b2 - b0;\n    \n    vec2 gf = 2.0 * ( b * d21 + d * d10 + a * d20 );\n    gf = vec2( gf.y, -gf.x );\n    vec2 pp = -f * gf / dot( gf, gf );\n    vec2 d0p = b0 - pp;\n    float ap = det( d0p, d20 );\n    float bp = 2.0 * det( d10, d0p );\n    \n    float tt = cl( ( ap + bp ) / ( 2.0 * a + b + d ) );\n    return mix( mix( b0, b1, tt ), mix( b1, b2, tt ), tt );\n\n}\n\nfloat approxDistance( vec2 p, vec2 b0, vec2 b1 ) { return length( closestPointInSegment( b0-p, b1-p ) ); }\nfloat approxDistance( vec2 p, vec2 b0, vec2 b1, vec2 b2 ) { return length( getDistanceVector( b0-p, b1-p, b2-p ) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = V.xxx;\n    float size = r.x * 0.15;\n    vec2 center = vec2(\n        size + abs( mod( t, ( r.x - size*2.0 ) * 2.0 ) - ( r.x - size*2.0 ) ),\n        size + abs( mod( t*2.0, ( r.y * 2.0 - size * 2.0 ) * 2.0 ) - ( r.y * 2.0 - size * 2.0 ) )\n    );\n    float seed = ( floor( t / ( r.x - size * 2.0 ) ) + floor( t * 2.0 / ( r.y * 2.0 - size * 2.0 ) ) ) * 4.66;\n    \n    vec3 baseCol = vec3( sin( seed ) * 0.5 + 0.5, sin( seed + 2.0 ) * 0.5 + 0.5, sin( seed + 4.0 ) * 0.5 + 0.5 );\n    \n    col = cl( size - length( c * vec2( 1.0, 2.0 ) - center ) ) * baseCol;\n    \n    float dist = 1E4;\n    \n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( -0.55, -0.25 )*size, vec2( -0.45, 0.2 )*size ) );\n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( -0.45, 0.2 )*size, vec2( -0.15, 0.22 )*size, vec2( -0.2, 0.05 )*size ) );\n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( -0.5, -0.1 )*size, vec2( -0.25, -0.15 )*size, vec2( -0.2, 0.05 )*size ) );\n    \n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( -0.1, -0.1 )*size, vec2( 0.0, 0.35 )*size ) );\n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( 0.0, 0.2 )*size, vec2( 0.25, 0.25 )*size, vec2( 0.13, -0.1 )*size ) );\n    \n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( 0.25, -0.25 )*size, vec2( 0.35, 0.20 )*size ) );\n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( 0.35, 0.2 )*size, vec2( 0.65, 0.22 )*size, vec2( 0.6, 0.05 )*size ) );\n    dist = min( dist, approxDistance( c - center * vec2( 1.0, 0.5 ), vec2( 0.3, -0.1 )*size, vec2( 0.55, -0.15 )*size, vec2( 0.6, 0.05 )*size ) );\n    \n    col = vec3( cl( col + cl( 7.0 - dist ) ) );\n    col = vec3( cl( col - cl( 5.0 - dist ) ) );\n    \n    fragColor = vec4( col, 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlXDj", "name": "redpulse", "author": "dirkadirkadan", "description": "fun", "tags": ["heartbeat", "functionplot"], "likes": 3, "viewed": 222, "date": "1430098242", "time_retrieved": "2024-06-20T18:19:52.056913", "image_code": "void mainImage( out vec4 o, in vec2 I )\n{\n    I = 2.*I.xy / iResolution.xy-1.;\n    float w1 = .4*sin(4.*I.x);\n    float w2=.4*cos(13.*I.x);\n    float w3=.4*sin(4.*I.x*I.x*3.);\n\n    float y = w1+w2+w3-.105;\n    \n    float x = mod(iTime,2.)-1.;\n    \n    float r=.2;\n    \n    float f = 1.-22.*abs(y-I.y);\n    float rf = 1.-10.*length(I-vec2(x,y))-r;\n    \n    vec3 col = vec3(f);\n    col.r += rf;\n    o = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlXDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml23DD", "name": "Mandlebro", "author": "reuben364", "description": "Mandlebrot shader", "tags": ["mandlebrot"], "likes": 0, "viewed": 158, "date": "1429272375", "time_retrieved": "2024-06-20T18:19:52.323656", "image_code": "#define ITER 50\n#define PI 3.1415\n\n#define time (iTime*1000.)\n#define resolution (iResolution.xy)\n\n\nfloat mandlebrot(vec2 pos) {\n    vec2 z = vec2(0);\n    for(int i=1; i<ITER; i++) {\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + pos;\n        if(length(z) > 2.) {\n            return float(i);\n        }\n    }\n    return float(ITER);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = fragCoord / resolution;\n    pos -= .5;\n    pos *= 2.;\n    float rev = time/2000.;\n    float posiOsc = .5*(1.-cos(PI*fract(rev)));\n    float posiOsc2 = .5*(1.-cos(PI*rev));\n    float thres = float(ITER)*posiOsc;\n    float mandy = mandlebrot(pos);\n    float mandyWrap = 1./max(1., thres-mandy);\n    float mandyActual = float(ITER)-mandy < .1 ? 1. : 0.;\n    vec4 col1 = vec4(1,0,0,1);\n    vec4 col2 = vec4(1,1,0,1);\n    vec4 actualColor = mix(col2, col1, posiOsc2);\n    vec4 backgroundColor = mod(rev, 2.) < 1. ? col2 : col1;\n    vec4 wrapColor = mod(rev, 2.) < 1. ? col1 : col2;\n    fragColor = mix(mix(backgroundColor, wrapColor, mandyWrap), actualColor, mandyActual);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml23Ww", "name": "clothoid S", "author": "joeedh", "description": "fresnel root finder thingy", "tags": ["clothoids"], "likes": 2, "viewed": 152, "date": "1429650000", "time_retrieved": "2024-06-20T18:19:52.323656", "image_code": "#define STEPS 14\n\nvec2 f(float s1) {\n    float s = 0.0, ds = s1/float(STEPS);\n    float ds2=ds*ds, ds3=ds2*ds;\n    vec2 ret = vec2(0, 0);\n    float t = fract(iTime), t2;\n    t = abs(t-0.5)*0.2+0.75;\n    t2 = t*2.0;\n    \n    for (int i=0; i<STEPS; i++) {\n        float th = s*s*t, sinth=sin(th), costh = cos(th);\n        float th2=th*th;\n        \n        //4rd-order taylor approximation\n        \n        ret[0] += sinth + costh*s*t*ds + \n             0.1666666*(t2*(costh - 2.0*sinth*th))*ds2 -\n             0.0416666*4.0*(2.0*costh*th + 3.0*sinth)*s*t*t*ds3;\n        ret[1] += costh - sinth*s*t*ds -\n            2.0*t*(0.1666666)*(2.0*costh*th + sinth)*ds2 - \n            0.0416666*4.0*(3.0*costh-2.0*sinth*th)*s*t*t*ds3;\n        s += ds;\n    }\n    \n    return ret*ds;\n}\n/* reduce script, see http://reduce-algebra.sourceforge.net/\n\noperator isin, icos;\n\nforall s let df(isin(s), s) = sin(s**2);\nforall s let df(icos(s), s) = cos(s**2);\n\ndf((isin(s)-x)**2 + (icos(s)-y)**2, s);\ndf(sqrt((isin(s)-x)**2 + (icos(s)-y)**2), s);\n\n*/\n#define DF 0.05\n\nvec2 rot2d(vec2 v, float a) {\n    return vec2(\n      v[1]*sin(a) + v[0]*cos(a),\n      -v[0]*sin(a) + v[1]*cos(a)\n    );\n}\n\nfloat sample1(vec2 uv) {\n\tfloat size = max(iResolution.x, iResolution.y);\n    float x=0.0, y=0.0;\n    \n    float s = 0.4, d=0.0, g=0.0, div=0.0, d2;\n    vec2 r, r2;\n    float t = sin(iTime*6.0)*0.5 + 0.5;\n    \n    t = t*0.5 + 0.5;\n    t *= 1.0;\n    for (int i=0; i<50; i++) {\n        r = f(s);\n        d = length(r - uv);\n        \n        g = cos(s*s)*r[1] - cos(s*s)*uv[1] + r[0]*sin(s*s) - sin(s*s)*uv[0];\n        div = sqrt(r[1]*r[1] - 2.0*r[1]*uv[1] + r[0]*r[0] - 2.0*r[0]*uv[0] \n                         + uv[0]*uv[0] + uv[1]*uv[1]);\n        g = g / div;\n        //r2 = f(s+DF);\n        \n        //d2 = length(r2-uv);\n        //g = (d2-d)/DF;\n        \n        float fac = 1.0;//abs(3.0 - s)/6.0 + 0.5;\n        s += -d*(g)*0.5*fac;\n        //s = min(max(s, 0.0), 3.0);\n    }    \n    \n    d = 1.0-d;\n    float th = 0.8+(1.0-abs(s)*0.5)*0.05;\n    d = smoothstep(th, th+0.18, d);\n\treturn d;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / size;\n    float x=0.0, y=0.0;\n    \n    uv[0] -= 0.5;\n    uv[1] -= 0.3;\n    uv *= 5.0;\n    uv[1] *= 1.4;\n    \n    float s1 = sin(iTime*10.0+(uv[0]*uv[1])*5.0);\n    uv[0] += s1*0.015;\n    uv[1] += s1*0.015;\n    \n    uv = rot2d(uv, 0.6);\n    float d = sample1(uv);\n    //vec2 uv2 = vec2(-uv[0], uv[1])*1.5;\n    //float d2 = sample(uv2);\n    \n    //d = max(d, d2);\n\tfragColor = vec4(d, d, d, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml23zy", "name": "Buildings 2D", "author": "lamogui", "description": "Shader created for my attempt of LD32: noisecontroller (http://ludumdare.com/compo/ludum-dare-32/?action=preview&uid=48226). I just replaced the noise_lvl variable with a bass_lvl variable.", "tags": ["procedural", "2d", "sound", "reactive", "buildings", "bass", "noisecontroller"], "likes": 6, "viewed": 1521, "date": "1430150295", "time_retrieved": "2024-06-20T18:19:52.323656", "image_code": "\nfloat bass_lvl=0.;\n\nfloat bass()\n{\n    float b=.0; \n    for (int i=0; i < 7; i++)\n    {\n       \tvec2 coord=vec2(float(i)/iChannelResolution[0].x,.0);\n        b=max(b,texture(iChannel0,coord).x);\n    }\n    return pow(b*0.85,3.);\n}\n\n//Probably made by iq\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n  float n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\n\nvec4 sky(vec2 uv)\n{\n    return vec4(0.0,0.0,0.5*(1.0-uv.y),1.);\n}\n\nbool onRect(vec2 p, vec2 center, vec2 size) {\n  return !(p.x > center.x + size.x*0.5 ||\n             p.x < center.x - size.x*0.5 ||\n             p.y > center.y + size.y*0.5 ||\n             p.y < center.y - size.y*0.5 );\n\n}\nconst float immeubles=18.0;\nconst float immeuble_largeur=1.0/(immeubles-6.0);\nconst float window_width=immeuble_largeur/3.0;\nconst float window_height=immeuble_largeur/1.5;\nvec4 getImmeubleColor(vec2 uv, float height)\n{\n    if (cos(6.28*uv.x/window_width) > 0.0 && uv.y > 0.09 &&\n        sin(6.28*uv.y/window_height) > 0.0 && abs(uv.y + window_height*0.5) < height*0.5)  {\n        //On window\n        float random=hash(floor(uv/window_height)*height);\n        if ( random > 0.9-min(bass_lvl,0.65))\n          return vec4(1.0,1.0,0.0,1.);\n        else if ( random > 0.25)\n          return 0.33*sky(uv);\n        else \n          return vec4(0.0,0.0,0.0,1.);\n    }\n    return vec4(0.0,0.0,0.0,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bass_lvl=bass();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color=sky(uv);\n    //uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y -=0.1;\n    //uv = normalize(vec3(uv,1.-length(uv))).xy;\n\n    float posx=-iTime*0.1;\n    if (uv.y < 0.0) {\n      color=vec4(0.15,0.15,0.15,0.15);\n\n    }\n    else {\n       for (float i=0.0; i < immeubles; i++) {\n            float position_x=(i-3.0)*immeuble_largeur+mod(posx,immeuble_largeur);//-1.;\n            vec2 center=vec2(position_x,0.0);\n            vec2 size=vec2(immeuble_largeur,0.7*hash(i-floor(posx/immeuble_largeur))+0.3);\n\n            if (onRect(uv, center, size)) {\n                color=getImmeubleColor(uv-center,size.y);\n                break;\n            }\n        }\n    }\n\n   float a=1.;\n   if (uv.y < 0.) a=0.;\n   int cas=int(mod(gl_FragCoord.x,3.0));\n    if (cas==0) color = color*0.5 + color*vec4(0.5,0.0,0.0,1.);\n    else if (cas==1) color = color*0.5 + color*vec4(0.0,0.5,0.0,1.);\n    else color = color*0.5 + color*vec4(0.0,0.0,0.5,1.);\n    \n\tfragColor = color;\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ml2GWD", "name": "Flarin'", "author": "bbcollinsworth", "description": "Stylized light flare based on Blobs.", "tags": ["pulse", "blobs", "light", "stars", "sinewaves"], "likes": 13, "viewed": 297, "date": "1429219140", "time_retrieved": "2024-06-20T18:19:52.717766", "image_code": "// playing with pulsar effect - based on Blobs by @paulofalcao\n\nfloat time=iTime;\n\nfloat makePoint(float x,float y,float sparkDur,float fy,float sparkDist,float xShakeWidth,float t,float offset){\n   float xx=x;//=x+sin(t*sparkDur*3.0)*xShakeWidth;\n    //float xx=x+sin(t*fx)*sx;\n    //changed below from fy/sy -- this just creates different x/y orbit bases\n   float yy=y;//+cos(t*sparkDur)*0.4;//*sparkDist;\n    //float yy=y+cos(t*fx)*sx;\n    float overTime = 1.0/(sqrt(xx*xx+yy*yy));//+abs(cos(t*sparkDur*0.5)*0.5)));\n   //return 1.0/(sqrt(xx*xx+yy*yy));//+abs(cos(t*fx)));//+offset\n    \n    //multiplying by the sin makes light fade in then out on upward cos swing\n    return overTime;//*sin(t*sparkDur);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   vec2 p=(fragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);\n\n   p=p*2.0;\n   \n   float x=p.x;\n   float y=p.y;\n    \n    //vec2 boom = vec2(rand,rand);\n\n   float a=\n       makePoint(x,y,3.0,2.9,0.8,0.15,time,0.1);\n   a=a+makePoint(x,y,1.9,2.0,0.8,0.2,time,0.4);\n   a=a+makePoint(x,y,0.8,0.7,0.4,0.17,time,0.7);\n   a=a+makePoint(x,y,2.3,0.1,0.6,0.3,time,2.5);\n   a=a+makePoint(x,y,0.8,1.7,0.5,0.24,time,1.6);\n   a=a+makePoint(x,y,0.3,1.0,0.4,0.33,time,0.8);\n   a=a+makePoint(x,y,1.4,1.7,0.4,0.08,time,1.3);\n   a=a+makePoint(x,y,1.3,2.1,0.6,0.14,time,2.3);\n   a=a+makePoint(x,y,1.8,1.7,0.5,0.14,time,2.8);   \n   \n   /*float b=\n       makePoint(x,y,1.2,1.9,0.8,0.3,time,0.6);\n   b=b+makePoint(x,y,0.7,2.7,0.4,0.4,time);\n   b=b+makePoint(x,y,1.4,0.6,0.4,0.5,time);\n   b=b+makePoint(x,y,2.6,0.4,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.4,0.5,0.4,time);\n   b=b+makePoint(x,y,0.7,1.7,0.4,0.4,time);\n   b=b+makePoint(x,y,0.8,0.5,0.4,0.5,time);\n   b=b+makePoint(x,y,1.4,0.9,0.6,0.3,time);\n   b=b+makePoint(x,y,0.7,1.3,0.5,0.4,time);*/\n\n   /*float c=\n       makePoint(x,y,3.7,0.3,0.8,0.3,time,0.8);\n   c=c+makePoint(x,y,1.9,1.3,0.4,0.4,time);\n   c=c+makePoint(x,y,0.8,0.9,0.4,0.5,time);\n   c=c+makePoint(x,y,1.2,1.7,0.6,0.3,time);\n   c=c+makePoint(x,y,0.3,0.6,0.5,0.4,time);\n   c=c+makePoint(x,y,0.3,0.3,0.4,0.4,time);\n   c=c+makePoint(x,y,1.4,0.8,0.4,0.5,time);\n   c=c+makePoint(x,y,0.2,0.6,0.6,0.3,time);\n   c=c+makePoint(x,y,1.3,0.5,0.5,0.4,time);*/\n   \n   \n   vec3 d=vec3(a,a-y/2.*32.0,a-y/2.*50.0)/16.0*abs(sin(iTime)*2.);\n   // vec3 d=vec3(a,b,c)/32.0;\n   \n   fragColor = vec4(d.x,d.y,d.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2GWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlB3Ry", "name": "Skircle Mountains 2", "author": "BntChvn", "description": "Squircle based mountains, with a telepheric, with the Sun and the Moon (some snow too)\nUpdate: added sheep, return for the telepheric :)\nUpdate: added minimal depth fog, stars.", "tags": ["2d", "squircle"], "likes": 7, "viewed": 698, "date": "1429981975", "time_retrieved": "2024-06-20T18:19:52.717766", "image_code": "//\n// #TeamSquircle\n//\n#define PI\t\t\t\t3.1415926535\n#define EPS\t\t\t\t0.005\n#define MNTPOWER        0.9\n#define STARPOWER       0.6\n#define NB_MNT          6\n#define NB_CABIN        7\n#define NB_SHEEP        6\n\nstruct mountain {\n    vec3 base; \n    float sharpness; \n    float highness;\n};\n\nstruct sheep {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat TIME ()\n{\n    return sin(iTime)/3.0;\n}\n\nfloat CTIME ()\n{\n    return cos(iTime)/3.0;\n}\n    \n///////////////////////////////////////////////////////////////\n// Squircle Tools\n///////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////\n// classical squircle\n///////////////////////////////////////////////////////////////\nbool Squircle(in vec2 center, in float radius, in vec2 pos, in float ratio)\n{\n    float dist =  pow(abs(center.x-pos.x)*ratio, 4.0)\n                + pow(abs(center.y-pos.y), 4.0);\n\n    return( dist < pow(radius, 4.0));\n}\n\nbool Star(in vec2 center, in float radius, in vec2 pos, in float ratio)\n{\n    float dist =  pow(abs(center.x-pos.x)*ratio, STARPOWER)\n                + pow(abs(center.y-pos.y), STARPOWER);\n\n    return( dist < pow(radius, STARPOWER));\n}\n\n///////////////////////////////////////////////////////////////\n// mountain squircle\n///////////////////////////////////////////////////////////////\nbool Mountain(\n    in mountain mnt,\n    in vec2 pos, \n    inout vec3 color,\n\tinout float depth)\n{\n    // there is no mountain underground\n    if(pos.y > mnt.base.y)\n    {\n        float dist =  pow(abs(mnt.base.x-pos.x*mnt.sharpness),MNTPOWER)\n            \t\t+ pow(abs(mnt.base.y-pos.y),MNTPOWER);\n\n        if( dist < pow(mnt.highness,MNTPOWER))\n        {\n            color = vec3(0.47,0.46,0.42);\n            color*= abs(dist);\n            depth = mnt.base.z + 0.3*dist*mnt.highness;\n            \n            // compute snow\n            if(   pos.y > 0.32/mnt.sharpness*mnt.highness/1.7 \n               && pos.y > mnt.base.y + 0.8*(mnt.base.y + mnt.highness))\n            {\n                color = vec3(0.96,\n                             0.96 + 0.05*TIME(),\n                             0.96 + 0.051*TIME());\n                \n                depth = 0.1;\n            }\n            \n            return true;\n        }\n    }\n\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n// transform fragCoord => uv\n///////////////////////////////////////////////////////////////\nvec2 toUV(in vec2 pos)\n{\n    vec2 q = pos.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    return uv;\n}\n\n///////////////////////////////////////////////////////////////\n// transform uv => fragCoord\n///////////////////////////////////////////////////////////////\nvec2 toCoord(in vec2 pos)\n{\n    pos.x *= iResolution.y/iResolution.x;\n    return (pos.xy + 1.0)*iResolution.xy/2.0;\n}\n\n\n///////////////////////////////////////////////////////////////\n// determine the pos from x on line AB\n///////////////////////////////////////////////////////////////    \nvec2 getPosInLine(in vec2 a, in vec2 b, in float x)\n{\n    float m = (b.y-a.y)/(b.x-a.x);\n    float p = a.y - m*a.x;\n    \n    return vec2(x, m*x+p);\n}\n\n///////////////////////////////////////////////////////////////\n// determine is the pos is on line AB\n///////////////////////////////////////////////////////////////    \nbool Line(in vec2 a, in vec2 b, in vec2 pos)\n{\n    float m = (b.y-a.y)/(b.x-a.x);\n    float p = a.y - m*a.x;\n    \n    if( abs(pos.y-(m*pos.x + p)) < EPS)\n    {\n        return true;\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n// determine is the pos is in segment [AB]\n///////////////////////////////////////////////////////////////\nbool Segment(in vec2 a, in vec2 b, in vec2 pos)\n{\n    if( Line(a, b, pos))\n    {\n        if(   ((a.x < b.x) && (a.x < pos.x) && (pos.x < b.x))\n           || ((a.x > b.x) && (a.x > pos.x) && (pos.x > b.x)))\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawCabin (in vec2 center, in vec2 pos, inout vec3 color)\n{\n    if(Squircle(center, 0.05, pos, 1.0))\n    {\n        color = vec3(1.0, 0.0, 0.0);\n        \n        \n        if(Squircle ( vec2(center.x - 0.025, center.y + 0.020), 0.019, pos, 1.0))\n        {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n        \n        if(Squircle ( vec2(center.x + 0.025, center.y + 0.020), 0.019, pos, 1.0))\n        {\n            color = vec3(0.0, 0.0, 0.0);\n        }\n    }\n}\n\nvoid drawCabinLine(in vec2 start, in vec2 end, in vec2 pos, inout vec3 color)\n{\n    if(Segment(start, end, pos))\n    {\n        color = vec3(0.0, .0, .0);\n    }\n\n    for(int i=0; i< NB_CABIN; i++)\n    {\n        float running = 0.0;\n        float dist = 1.87/float(NB_CABIN);\n        if(TIME () > 0.0)\n        {\n            running = 10.0*TIME()*dist;\n        }\n\n        float x = start.x + 0.14 + running\n            + 0.04*TIME() // oscillation\n            + dist*float(i);\n\n        if(x >= end.x)\n        {\n            x -= (end.x-start.x);\n        }\n        \n        if(x <= start.x)\n        {\n            x -= end.x-abs(start.x - end.x);\n        }\n        \n        vec2 cabin = getPosInLine(start, end, x); // step on the wire\n\n        cabin.y += -0.07;\n        drawCabin(cabin, pos, color);\n    }\n}\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nbool isTelepherique (in vec2 pos, inout vec3 color)\n{\n    // draw up cabin\n    vec2 start = vec2(0.17, 0.03);\n    vec2 end   = vec2(2.0, 0.7 );\n\tdrawCabinLine(start, end, pos, color);\n\n    return false;\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawSun (in vec2 pos, inout vec3 color)\n{\n    vec2 sun= vec2(-2.0, 0.5);\n\n    sun.x = cos(iTime);\n    sun.y = TIME()*2.3;\n\n    float dist =  pow(abs(sun.x-pos.x),4.0)\n        \t\t+ pow(abs(sun.y-pos.y),4.0);\n\n    if( dist < pow(0.13, 4.0))\n    {\n        color = vec3(1.0,1.0, 0.0);\n        color/= abs(dist);\n    }\n\n    if(dist < pow(0.13, 4.0) + 0.0015)\n    {\n        color = 0.5*color + 0.5*vec3(1.0, 0.7, 0.0);\n    }\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawMoon (in vec2 pos, inout vec3 color)\n{\n    vec2 moon= vec2(-2.0, 0.5);\n\n    moon.x = -cos(iTime);\n    moon.y = -TIME()*2.0;\n\n    if(Squircle (moon, 0.10, pos, 1.0))\n    {\n        color = vec3(0.7);\n\n        if(Squircle(vec2(moon.x - 0.04, moon.y + 0.040), 0.040, pos, 1.0))\n        {\n            color = vec3(0.8);\n        }\n\n        if(Squircle(vec2(moon.x + 0.035, moon.y + 0.010), 0.022, pos, 1.0))\n        {\n            color = vec3(0.85);\n        }\n\n        if(Squircle(vec2(moon.x, moon.y - 0.041), 0.038, pos, 1.0))\n        {\n            color = vec3(0.85);\n        }\n    }\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid drawSheep(in sheep s, in float radius, in vec2 pos, inout vec3 color)\n{\n    float dir = -1.0;\n    float d = 0.0;\n    \n    \n    if(TIME()>0.0) {\n        s.pos.x += 1.5*TIME()*(s.dir.x - s.pos.x);\n        s.pos.y += TIME()*(s.dir.y - s.pos.y);\n    }\n    \n    if(cos(iTime)*(s.pos.x-s.dir.x) <= 0.){dir=1.0;}\n    \n    if(TIME()<0.0) { d = -radius;}\n    \n    \n    // draw the body\n    if(Squircle(vec2(s.pos.x, s.pos.y+d), radius, pos, 1.0))\n    {\n        color = vec3(0.5);\n    }\n    \n    // draw the head\n    s.pos.x += radius*1.7*dir;\n    if(Squircle(vec2(s.pos.x, s.pos.y+d), radius*0.7, pos, 1.0)){ color = vec3(0.55);}\n    \n    // draw the legs\n    if(TIME()>0.0)\n    {\n        s.pos.x -= radius*2.2*dir;\n        s.pos.y -= radius*1.4;\n        if(Squircle(s.pos.xy, radius*0.5, pos, 1.0)){ color = vec3(0.4);}\n\n        s.pos.x += (radius + radius*0.1)*dir;\n        if(Squircle(s.pos.xy, radius*0.5, pos, 1.0)){ color = vec3(0.4);}\n    }\n}\n\nvoid DrawCloud(in vec2 pos, inout vec3 color)\n{ \n    for(float i=0.; i<8.0; i+=1.0)\n    {\n        vec2 center = vec2(.5,.5);\n        center.x = 1.7-2.*TIME() - cos(i)*0.12;\n        center.y = 1.7*TIME() + sin(i)*0.07;\n        \n        if(Squircle(center, 0.0988, pos, 1.0))\n        {\n            if( CTIME() > 0.)\n            {\n            \tcolor = (1.0-CTIME())*color \n                \t   + CTIME()*vec3(0.8,0.8,0.8);\n            }\n            \n        }\n    }  \n\n}\n\n///////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 FOG = vec3(0.7,0.7,0.7);\n    float depth=0.3;\n        \n    // mountains added from left to right\n    // row from close to far\n    mountain mountains[NB_MNT];\n    \n    mountains[1] = mountain(vec3(-1.5,-0.5, .1), 2.4, 1.4);\n    mountains[4] = mountain(vec3(-1.5,-0.5, .4), 1.0, 1.2);\n    mountains[5] = mountain(vec3(-0.4,-0.5, .6), 1.0, 1.0);\n    mountains[0] = mountain(vec3(0.2, -0.5, .8), 1.8, 1.0);\n    mountains[3] = mountain(vec3(1.38,-0.5, .4), 1.5, 0.7);\n    mountains[2] = mountain(vec3(2.1, -0.5, .3),  1.0, 1.4);\n\n    // sheep arre added from left to right\n    sheep bunchOfSheep [NB_SHEEP];\n    \n    bunchOfSheep[0] = sheep(vec3(-1.3, -0.55, 0.01),vec3(-0.8, -0.65, 0.5));\n    bunchOfSheep[1] = sheep(vec3(-1.4, -0.6, 0.01), vec3(-1.9, -0.8, 0.5));\n    bunchOfSheep[2] = sheep(vec3(-1.5, -0.67, 0.01), vec3(-2.0, -0.8, 0.5));\n    bunchOfSheep[3] = sheep(vec3(-1.45, -0.59, 0.01), vec3(-0.7, -0.8, 0.5));\n    bunchOfSheep[4] = sheep(vec3(-2.0, -0.85, 0.01),vec3(-1.1, -0.8, 0.5));\n    bunchOfSheep[5] = sheep(vec3(-1.7, -0.57, 0.01), vec3(-1.0, -0.8, 0.5));\n    \n    // get the frag uv\n\tvec2 pos = toUV(fragCoord.xy);\n    vec3 color = vec3(1.0);\n    \n    // draw the sky\n    color *= vec3(0.3, 0.34, 0.55);\n    color *= (1.0-sin(pos.y))*3.0;\n    color *= 0.25 + TIME();\n    \n    // draw the stars\n    if(TIME()<0.0)\n    {\n        for(float i=-5.; i<5.; i+=1.)\n        for(float j=0.; j<20.; j+=1.)\n        {\n            float X = i*0.3 + cos(i*j);\n            float Y = sin(i*j);\n            if(abs(i-j)<4.)\n            {\n                X += 0.02*TIME() - 0.002*tan(i);\n                Y += 0.01*TIME() - 0.002*tan(j);\n            }\n            \n            if(Star(vec2(X, Y), 0.02, pos, 1.0))\n            {\n                color = vec3(1.0);\n            }\n        }\n    }\n    else\n    {\n        DrawCloud(pos, color);\n    }\n    // draw the moon/sun\n    drawSun(pos, color);\n \tdrawMoon(pos, color);   \n    \n    // draw the mountains\n    for(int i=0; i< NB_MNT; i++)\n    {\n\t\tMountain(mountains[i], pos, color, depth);\n    }\n    \n    // draw the telepherique\n    isTelepherique (pos, color);\n        \n    // add some grass\n    if(pos.y<=-0.5)\n    {\n        color = vec3(0.25, 0.7, 0.3);\n        color.r += cos(pos.y)/2.0;\n        \n        // add depth\n        depth = 0.5+pos.y;\n    }\n    \n    // draw the sheep\n    for(int a=0; a<5; a++)\n    for(int i=0; i<NB_SHEEP; i++)\n    {\n        sheep s = bunchOfSheep[i];\n        s.pos.x += float(a); \n\n        drawSheep(s, 0.05, pos, color);\n    }\n    \n    // simple linear depth fog\n    vec3 foggycolor = (1.0-depth)*color + depth*FOG;\n    \n    fragColor = vec4(foggycolor,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlB3zK", "name": "002 Dynamic Ebbinghaus Illusion", "author": "nmarsden", "description": "Press the 'space bar' to break the illusion\n\nMore info about the illusion is at http://illusionoftheyear.com/2014/the-dynamic-ebbinghaus/\n", "tags": ["2d", "illusion"], "likes": 3, "viewed": 128, "date": "1430310934", "time_retrieved": "2024-06-20T18:19:52.723738", "image_code": "const float PI = 3.141592;\nconst float PI2 = 2.0 * PI;\n\nconst float MIDDLE_CIRCLE_RADIUS = 0.08;\n\nconst vec2 MIDDLE_CIRCLE_START_POS = vec2(-MIDDLE_CIRCLE_RADIUS*6.0, MIDDLE_CIRCLE_RADIUS*6.0);\n\nconst vec2 MIDDLE_CIRCLE_END_POS = vec2(MIDDLE_CIRCLE_START_POS.x + (MIDDLE_CIRCLE_RADIUS*12.0), MIDDLE_CIRCLE_START_POS.y - (MIDDLE_CIRCLE_RADIUS*12.0));\n\nconst float OUTER_CIRCLE_RADIUS_MIN = 0.5 * MIDDLE_CIRCLE_RADIUS;\nconst float OUTER_CIRCLE_RADIUS_MAX = 2.0 * MIDDLE_CIRCLE_RADIUS;\nconst float MARKER_RADIUS = 0.005;\n\nconst vec3 BACKGROUND_COLOUR = vec3(1.0, 1.0, 1.0);\nconst vec3 CIRCLE_COLOUR     = vec3(0.1, 0.1, 0.1);\nconst vec3 MARKER_COLOUR     = vec3(1.0, 1.0, 0.0);\nconst vec3 LINE_COLOUR       = vec3(0.8, 0.8, 1.0);\n\nbool keyToggle( int ascii ) \n{\n\treturn (texture(iChannel0, vec2((0.5 + float(ascii)) / 256.0, 0.75)).x > 0.0);\n}\n\nfloat draw_circle( vec2 uv, vec2 center, float radius ) \n{\n    vec2 p1 = uv - center;\n    \n    return step(sqrt(dot(p1, p1)), radius);\n}\n\nfloat draw_horizontal_line( vec2 uv, vec2 start_point, vec2 end_point, float line_width )\n{\n    if (uv.x < min(start_point.x, end_point.x) || uv.x > max(start_point.x, end_point.x)) {\n        return 0.0;\n    }\n    if (uv.y >= (start_point.y - line_width*0.5) && uv.y <= (start_point.y + line_width*0.5)) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (uv * 2.0) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n\n    float anim = 0.5 * sin(t) + 0.5;\n        \n    vec2 offset = mix(MIDDLE_CIRCLE_START_POS, MIDDLE_CIRCLE_END_POS, anim);\n    \n    float outer_circle_radius = mix(OUTER_CIRCLE_RADIUS_MIN, OUTER_CIRCLE_RADIUS_MAX, anim);\n\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    \n    vec3 c = black;\n\n    // check keyboard\n    bool showLines = keyToggle(32); // space bar\n\n    // draw middle circle\n    c +=  mix(CIRCLE_COLOUR * draw_circle(p, offset, MIDDLE_CIRCLE_RADIUS), black, ceil(c));\n    \n    // draw outer circles\n    for (float a = 0.0; a<=PI2; a += PI2/6.0) \n    {\n        vec2 center = vec2(cos(a), sin(a));\n        center *= (MIDDLE_CIRCLE_RADIUS + (outer_circle_radius * 2.0));\n        center += offset;\n\n        // draw marker\n        if (a < PI && a > PI/2.0) {\n\t\t    c +=  mix(MARKER_COLOUR * draw_circle(p, center, MARKER_RADIUS), black, ceil(c));\n        }\n    \t// draw outer circle\n\t    c +=  mix(CIRCLE_COLOUR * draw_circle(p, center, outer_circle_radius), black, ceil(c));\n    }\n\n    if (showLines) \n    {\n    \t// draw lines to break the illusion\n        float x1 = MIDDLE_CIRCLE_START_POS.x;\n        float x2 = MIDDLE_CIRCLE_END_POS.x;\n        for (float y=MIDDLE_CIRCLE_END_POS.y; y <= MIDDLE_CIRCLE_START_POS.y; y += MIDDLE_CIRCLE_RADIUS*4.0) \n        {\n            c += mix(LINE_COLOUR * draw_circle(p, vec2(x1, y), MIDDLE_CIRCLE_RADIUS), black, ceil(c));\n            c += mix(LINE_COLOUR * draw_horizontal_line(p, vec2(x1, y), vec2(x2, y), MIDDLE_CIRCLE_RADIUS*2.0), black, ceil(c));\n            c += mix(LINE_COLOUR * draw_circle(p, vec2(x2, y), MIDDLE_CIRCLE_RADIUS), black, ceil(c));\n        }\n    }\n    \n    c = mix(BACKGROUND_COLOUR, c, ceil(c));\n    \n    c = mix(c, vec3(dot(c,vec3(.33))),.5);\n    \n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlBGDm", "name": "manhattan voronoi public_int_i", "author": "public_int_i", "description": "manhattan voronoise", "tags": ["voronoi", "manhattan"], "likes": 2, "viewed": 154, "date": "1429496632", "time_retrieved": "2024-06-20T18:19:52.723738", "image_code": "\nvec2 pfromi(in float i) {\n   return vec2( mod(i,6.)+sin(i+iTime)*1. , i/6.+cos(i+iTime)*.1 )*.3; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n\tint sm = 1;\n    float ld = 999999.,db;\n    vec2 p;\n    for (int i = 1; i < 22; i++) {\n        p = pfromi(float(i));\n        db = abs(p.x-uv.x)+abs(p.y-uv.y);\n        if (db < .01) {\n            fragColor = vec4(0.);\n            return;\n        }\n        if (db < ld) {\n            sm = i;\n            ld = db;\n        }\n    }\n    \n    \n    if (abs(uv.x+.2-mod(iTime*.1,1.4))-.2 < 0.) {\n        fragColor = vec4(ld*1.);\n    } else {\n    \tfragColor = texture(iChannel0,vec2(float(sm)*.02));\n    }\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlBGWz", "name": "Birdie bird", "author": "such", "description": "The geometry is built with ray marching constructive solid geometry. The background is a result from taking the end result from ray marching regardless whether it hit something or not with distances estimated in different transformations for each compone.", "tags": ["raymarchingcsg"], "likes": 0, "viewed": 1186, "date": "1428020316", "time_retrieved": "2024-06-20T18:19:54.123768", "image_code": "const float closed_left_eye = 0.75;\nconst float closed_right_eye = 0.8;\nconst float bend_back = 1.;\n\n// as allways, higher is better\n#define RM_MAX_ITER 15\n#define DISTANCE 2.\n\n// define one of these\n//#define CLEAN // at least 10 iterations\n//#define EVIL_BIRD_IN_THE_DARK // at least 16 iterations\n#define FUNKY_BACKGROUND\n\n// this is cool with FUNKY_BACKGROUND\n//#define ONLY_BEAK\n\n// woho!\n//#define DANCE_GROOVE\n//#define DANCE_FUNK\n\n//#define EAT_MUSHROOMS\n\n//#define UNDERCOVER\n\n//#define BANDANA\n\n//#define BACKGROUNDTEXTURE\n\nconst float eps = 0.01;\n\n// raymarching CSG: min = union, max = intersection\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p,n)-d;\n}\n\nvec3 bendBody(vec3 p)\n{\n    // offset position to compute distance from to give the effect of the object moving\n    float bending = bend_back*0.025;\n    //float bending = 0.015*sin(4.*iTime);\n    p.z = p.z - p.y*p.y*bending;\n    #ifdef EAT_MUSHROOMS\n    p.x = p.x - sin(p.y);\n    #endif\n    #ifdef DANCE_GROOVE\n    float o = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    #ifdef DANCE_FUNK\n    float o2 = p.y*p.y*bending*2.*sin(4.*iTime);\n    p.x += o2;\n    p.y -= abs(o2);\n    #endif\n    return p;\n}\n\nfloat birdieBody(in vec3 p)\n{\n    // Model the body as a cylinder with varying radius\n    float y = clamp(p.y,0.,1.);\n\n    float r;\n\tfloat neck = 0.48;\n    if (y<neck)\n    \tr = mix(1.4,0.15,y/neck);\n    else\n    {\n        float t = 1. - (y-neck)/(1.-neck);\n        r = -.85*t*t*t*t + 1.;\n        r *= sin(acos(1.-t));\n    }\n    \n    float body = length(p.xz) - r*0.1;\n    return max(max(p.y-1.,-p.y),body);\n}\n\nfloat birdieBeak1(in vec3 p)\n{\n    float d_back = p.z - (-0.02);\n    float d_bottom = -(p.y - 0.57);\n    float d_left = sphere(p,vec3(-.15, 0.6, 0.02),.2);\n    float d_right = sphere(p,vec3(.15, 0.6, 0.02),.2);\n    \n    return max(max(d_left,d_right),max(d_bottom,d_back));\n}\n\nfloat birdieBeak2(in vec3 p,float openjaw)\n{\n    float d_back = p.z - (-0.02);\n    float d_top = plane(p, vec3(0.,1.,-.6-.3*openjaw), 0.6+.03*openjaw);\n    float d_left = sphere(p,vec3(-.115, 0.65, 0.06),.2);\n    float d_right = sphere(p,vec3(.115, 0.65, 0.06),.2);\n    \n    return max(max(d_left,d_right),max(d_top,d_back));\n}\n\nfloat birdieBeak(in vec3 p)\n{\n    float beak1 = birdieBeak1(p);\n    float beak2 = birdieBeak2(p, pow(sin(iTime),31.));\n    \n    return min(beak1,beak2);\n}\n\nfloat birdieEyePupil(in vec3 p, float angley, float anglex)\n{\n    anglex = clamp(anglex,-.1,.3);\n    angley = clamp(angley,-.4,.4);\n    \n\tanglex = 0.04*sin(anglex);\n    vec3 off1 = vec3( 0.04, 0.717+anglex, -0.048);\n    vec3 off2 = vec3( -0.04, 0.717+anglex, -0.048);\n\n    float ca = cos(angley);\n    float sa = sin(angley);\n    \n    off1 = vec3(off1.z*sa + off1.x*ca, off1.y, off1.z*ca - off1.x*sa);\n    off2 = vec3(off2.z*sa + off2.x*ca, off2.y, off2.z*ca - off2.x*sa);\n    \n    return min(length(p-off1),length(p-off2)) - .025; // distance to sphere\n}\n\nfloat birdieEyeWhite(float body,in vec3 p)\n{\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.69);\n    float d_top = plane(p,vec3(0.,1.,0.),0.9);\n    float d_sphere = min(sphere(p,vec3(0.1,0.75,-0.1),.1),\n                         sphere(p,vec3(-0.1,0.75,-0.1),.1));\n    return max(max(body,d_sphere),max(d_top,d_bottom));\n}\n\nfloat birdieBandana(float body,in vec3 p)\n{\n#ifdef BANDANA\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.85);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#else\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.92);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#endif\n#ifdef UNDERCOVER\n    return body;\n#else\n    return max(body,max(d_top,d_bottom));\n#endif\n}\n\nfloat birdieEyeLid(in vec3 p, float closed_left, float closed_right)\n{\n    p.y = (p.y-0.75)*0.5 + 0.75;\n    float d_bottom = plane(p,vec3(-.8*(1.-closed_left),-1.,0.),-0.9 + 0.21*closed_left);\n    float d_sphere1 = sphere(p,vec3(-0.1,0.75,-0.1),.1);\n    float d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid1 = max(max(d_sphere1,d_sphere2),d_bottom);\n\n    d_bottom = plane(p,vec3(0.8*(1.-closed_right),-1.,0.),-0.9 + 0.21*closed_right);\n    d_sphere1 = sphere(p,vec3(0.1,0.75,-0.1),.1);\n    d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid2 = max(max(d_sphere1,d_sphere2),d_bottom);\n    return min(lid1,lid2);\n}\n\nvec4 birdie(in vec3 p)\n{\n    p.y += 0.5;\n    p = bendBody(p);\n    float body = birdieBody(p);\n    float beak = birdieBeak(p);\n    float eyepupil = max(body,birdieEyePupil(p,sin(iTime),cos(iTime)));\n    float eyewhite = birdieEyeWhite(body,p);\n    float eyelid = birdieEyeLid(p,closed_left_eye+0.05*pow(sin(.22873*iTime),391.), closed_right_eye+0.05*pow(sin(.22873*iTime),391.));\n    float ninjabandana = birdieBandana(body,p);\n    \n    #ifdef ONLY_BEAK\n    body += 10.;\n    eyepupil += 10.;\n    eyewhite += 10.;\n    eyelid += 10.;\n    #endif\n\n    float m = min(min(min(body,beak),min(eyepupil,eyewhite)),eyelid);\n    vec4 r;\n    if (m==beak) return vec4(0.8, 0.4, 0.2, m);\n    if (m==eyepupil) return vec4(0.0, 0.0, 0.0, m);\n    if (m==ninjabandana) return vec4(0.1, 0.2, 0.3, m);\n    if (m==eyewhite) return vec4(1.0, 1.0, 1.0, m);\n    if (m==eyelid) return vec4(0.6, 0.6, 0.6, m);\n    return vec4(0.8, 0.8, 0.8, m); // m==body\n}\n\nvec4 scene(in vec3 p)\n{\n    return birdie(p);\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz).w - scene(p - ep.xyz).w;\n    normal.y = scene(p + ep.yxz).w - scene(p - ep.yxz).w;\n    normal.z = scene(p + ep.yzx).w - scene(p - ep.yzx).w;\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    //float a = 3.14+1.4*iTime;\n    float a = 3.14+sin(.1*iTime);\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n\n    a = 0.1*sin(.1*iTime);\n    //a = 3.14+.4*iTime;\n    ca = cos(a);\n    sa = sin(a);\n\trayStart = vec3(rayStart.x, rayStart.z*sa + rayStart.y*ca, rayStart.z*ca - rayStart.y*sa);\n    rayDir = vec3(rayDir.x, rayDir.z*sa + rayDir.y*ca, rayDir.z*ca - rayDir.y*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    vec4 currentColor;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        currentColor = scene(p);\n\t\tt += currentColor.w;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    //vec3 normal = vec3(0,0,1);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    //            finalColor = normal;\n    //            finalColor = vec3(1,0,1) *\n    //                dot(vec3(1.,sin(iTime ),cos(iTime )),normal);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n    \n    #ifdef CLEAN\n    //if (currentColor.w>100.)\n    if (currentColor.w>eps)\n    {\n        currentColor = vec4(0.,0.,0.,0.);\n    }\n    #endif\n    \n    #ifdef EVIL_BIRD_IN_THE_DARK\n    if (currentColor.w>0.)\n    {\n        currentColor = vec4(0.,0.,0.,0.);\n    }\n    #endif\n\n\n    //float specular = 0.;\n    float ambient = 0.2;\n    finalColor = currentColor.xyz *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-currentColor.w) + length(finalColor)));\n\n    #ifdef BACKGROUNDTEXTURE\n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n    #endif\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlS3Dh", "name": "It's ... something", "author": "caiwan", "description": "Made with copying around the whole shadertoy. It may be useful for a displacement map in a raymarched scene.\nBased on https://www.shadertoy.com/view/Xsl3zN", "tags": ["lsd"], "likes": 15, "viewed": 748, "date": "1428504590", "time_retrieved": "2024-06-20T18:19:54.408637", "image_code": "#define PI 3.14159265359\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** PERLIN ZAJ ***\n/// 2D random\nvec2 random2(vec2 c) { float j = 4906.0*sin(dot(c,vec2(169.7, 5.8))); vec2 r; r.x = fract(512.0*j); j *= .125; r.y = fract(512.0*j);return r-0.5;}\n\n/// 1D random / hash\nfloat hash(float f){ return fract(56546.235423 * sin(f*235345.345345));}\n\nconst float F2 =  0.3660254;\nconst float G2 = -0.2113249;\n\n/// simplex 2D zaj; perlin zaj egy frekvenciajahoz tartozo ertekek\nfloat simplex2d(vec2 p){vec2 s = floor(p + (p.x+p.y)*F2),x = p - s - (s.x+s.y)*G2; float e = step(0.0, x.x-x.y); vec2 i1 = vec2(e, 1.0-e),  x1 = x - i1 - G2, x2 = x - 1.0 - 2.0*G2; vec3 w, d; w.x = dot(x, x); w.y = dot(x1, x1); w.z = dot(x2, x2); w = max(0.5 - w, 0.0); d.x = dot(random2(s + 0.0), x); d.y = dot(random2(s +  i1), x1); d.z = dot(random2(s + 1.0), x2); w *= w; w *= w; d *= w; return dot(d, vec3(70.0));}\n\nfloat fbm(vec2 n){\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\ttotal += simplex2d(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n       \n    float t = iTime*.2; // let globally control the time\n\tfloat q = fbm(uv+t * 0.1);\n    vec2 r = vec2(fbm(uv + q+ t * 0.7 - uv.x - uv.y), fbm(uv + q -t * 0.4));\n\t\n    fragColor.rg = .5+r;\n    fragColor.b = 0.;\n    fragColor.a = 1.;\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mt2GWW", "name": "Test one - water", "author": "vlekos", "description": "Testing wave effects", "tags": ["2d"], "likes": 6, "viewed": 337, "date": "1429174975", "time_retrieved": "2024-06-20T18:19:54.911851", "image_code": "#define PI 3.14159265\n\nvec3 drop(in vec3 uvc, in int index, in float time, in float radMax, in float scale)\n{\n    float duration = 2.5;\n    time += duration * float(index);\n    float round = floor(time / duration);\n    \n    float hitX = (sin(round * 10.0) * 0.4);\n    float hitY = (cos(round * 10.0) * 0.2);\n    \n    float waveCount = 6.0;\n    float width = 0.05 * waveCount;\n    \n    float rad = (mod(time, duration)) * radMax;\n    float dx = uvc.x - hitX;\n    float dy = uvc.y - hitY;\n    \n    float dist = sqrt(dx * dx + dy * dy);\n    \n    if (dist >= rad - width && dist <= rad) \n    {\n    \tfloat a = sin((dist - (rad - width)) / width * PI * 2.0 * waveCount);\n        float b = a * width / 50.0 * pow(1.0 + radMax - rad, 8.0) * pow(scale - 0.1, 20.0);\n        float angle = atan(dy, dx);\n        \n        float s = 1.0 + b + b * sin(angle * 10.0) * 0.25;\n        uvc.x = hitX + s * (uvc.x - hitX);\n        uvc.y = hitY + s * (uvc.y - hitY);\n       \tif (b > 0.0) \n        {\n       \t\tuvc.z += b * 0.5 * dy / dist;\n        }\n    }\n    \n    return uvc;\n}\n\nvec4 multiplyLuminosity( in vec4 color, in float multiplier )\n{\n    float y = 0.2126 * color.x + 0.7152 * color.y + 0.0722 * color.b;\n    float u = -0.09991 * color.x - 0.33609 * color.y + 0.436 * color.b;\n    float v = 0.615 * color.x - 0.55861 * color.y - 0.05639 * color.b;\n\n    y *= multiplier;\n\n    color.x = y + 1.28033 * v; \n    color.y = y - 0.21482 * u - 0.39059 * v;\n    color.z = y + 2.12789 * u;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.0;\n    float scale = (1.125 - (iMouse.x / iResolution.x) * 0.125);\n    \n\tfloat amplitude = (0.005 + 0.00125 * (sin(time / 2.0))) * 0.05 * 2.0 * pow(scale - 0.05, 20.0);\n    vec2 resolution = vec2(max(iResolution.x, iResolution.y), max(iResolution.x, iResolution.y));\n\n    vec3 uvc = vec3(fragCoord.x / resolution.x, fragCoord.y / resolution.y, 0.0);\n\t\n    uvc.x -= 0.5;\n    uvc.y -= 0.3;\n    \n    uvc.x *= scale;\n    uvc.y *= scale;\n    \n    if (scale > 1.01)\n    {\n        float dx = sin(time * 5.0 + (uvc.y + uvc.x) * 30.0) * amplitude;\n        float dy = sin(time * 5.0 + (uvc.x) * 60.0) * amplitude + sin(time * 2.0) * 0.005 * pow(scale - 0.08, 20.0);\n\n        uvc.x += dx;\n        uvc.y += dy;\n\n        for (int i = 0; i < 13; i++)\n        {\n           uvc = drop(uvc, i, time + 0.2 * float(i), 0.3 + sin(float(i)) * 0.05, scale);\n        }\n    }\n\n    uvc.x = 0.5 + (uvc.x);\n    uvc.y = 0.3 + (uvc.y);\n    \n    vec4 color = texture(iChannel0, uvc.xy);\n\n    if (scale <= 1.01)\n    {\n        color.x = pow(color.x, pow(1.05, 8.0));\n        color.y = pow(color.y, pow(1.05, 8.0));\n        color.z = pow(color.z, pow(1.05, 8.0));\n    }    \n    else \n    {\n        color = multiplyLuminosity(color, scale * scale + 0.1);\n    }\n    \n    fragColor = multiplyLuminosity(color, 1.0 + uvc.z) + vec4(uvc.z, uvc.z, uvc.z, 0.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2GWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtB3RG", "name": "FlipTri AntiAliasing", "author": "demofox", "description": "Anti Aliasing on left, no antialiasing on right.", "tags": ["antialiasing", "flipquad"], "likes": 6, "viewed": 1652, "date": "1429846790", "time_retrieved": "2024-06-20T18:19:55.651229", "image_code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n\nFliptri anti aliasing works by using 3 samples per pixel in the following configuration (which shows 4 pixels):\n\n        B           B\n  +-----*-----+-----*-----+\n  |           |           |\n  |           |           |\n  |           |           |\n C*           |           *C\n  |           |           |\n  |           |           |\n  |           |A          |\n  +-----------*-----------+\n  |           |           |\n  |           |           |\n  |           |           |\n C*           |           *C\n  |           |           |\n  |           |           |\n  |           |           |\n  +-----*-----+-----*-----+\n        B           B\n\nA has a weight of 0.2, B,C have a weight of 0.4 each.\n\nA is shared by 4 pixels, B and C are shared by 2 pixels each.\n\nThis makes it so that you can render 1.25 samples per pixel, but get 3x SSAA.\n\nIn shadertoy you can't render to texture (yet), so i actually do all 3 samples, but\nthis has the same visual result as if the samples were actually shared.\n\nMore info here: http://blog.demofox.org/2015/04/23/flipquad-fliptri-antialiasing/\n\n*/\n\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w/2.0)&&(abs(pos.y-(_y)) < _h/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    // thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    // textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture(iChannel3, pos).xyz);\n    \n    // spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iTime, vec3(0.0, 0.0, 1.0));\n    \n    // concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    // untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    // grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord, in vec2 resolution, in float g_arcorrection, in float g_scale, in vec2 cameraOffset)\n{\n    vec2 ret = ((coord / resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t       \n    // camera wander: sin(time) controls magnitude, time controls angle\n    float cameraAngle = iTime * 0.32;\n    float cameraMag = sin(iTime*0.89) * 0.25 +1.0;\n\n    vec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n    // aspect ratio correction\n    vec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\n    float g_arcorrection = resolution.x / resolution.y;\n\n    // image zoom, defined by time\n    float g_scale = (sin(iTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;    \n    \n\tvec3 pixelColor;\n    \n    // draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    // right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy, resolution, g_arcorrection, g_scale, cameraOffset));\n\t}\n\t// left side = AA\n\telse\n    {\n        bool xOdd = (floor(mod(fragCoord.x,2.0)) == 1.0);\n        bool yOdd = (floor(mod(fragCoord.y,2.0)) == 1.0);\n               \n        vec2 a = vec2(xOdd ? -0.5 : 0.5, yOdd ? -0.5  : 0.5 );\n        vec2 b = vec2(0.0, yOdd ? 0.5 : -0.5);\n        vec2 c = vec2(xOdd ? 0.5 : -0.5, 0.0 );\n        \n        pixelColor  = GetPixelColor(PixelToWorld(fragCoord.xy + a, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.2;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + b, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.4;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + c, resolution, g_arcorrection, g_scale, cameraOffset)) * 0.4;\n\t}\t\t\n\n    // write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtB3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtB3WW", "name": "filtered flickering", "author": "hornet", "description": "Quick mockup of filtered flickering instead of picking a random value per frame.\nYou could offset the values and interpolate between them instead, which is how you end up with value-noise. This is an example of pure bruteforce box-filtering.", "tags": ["flicker"], "likes": 10, "viewed": 1505, "date": "1429002992", "time_retrieved": "2024-06-20T18:19:55.651229", "image_code": "float sat( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\nfloat mytrunc( float x, float l )\n{\n\treturn floor(x * l) / l;\n}\nfloat remap( float a, float b, float v ) {\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n\n// ====\n\nfloat hash11( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n// ====\n\nconst float FLICKER_RATE = 13.0;\nconst float FLICKER_PHASE = 13.583;\n\nfloat flicker0( float t )\n{\n    float ft0 = mytrunc( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    //note: single sample\n    return hash11( ft0 );\n}\n\nfloat flicker1( float t )\n{\n    float ft0 = mytrunc( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    const int NUM_SAMPLES = 8;\n    const float RCP_NUM_SAMPLES_F = 1.0 / float(NUM_SAMPLES);\n    const float diff_t = 1.0/60.0; //note: delta-time at 60Hz\n    const float FILTERWIDTH = 4.0 * diff_t;\n\n    //note: box-filter => linear interpolations\n    float stepsiz = FILTERWIDTH * RCP_NUM_SAMPLES_F;\n    float sum = 0.0;\n    float st = t - 0.25*FILTERWIDTH; //TODO: rnd offset...\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        float ft = mytrunc( st + FLICKER_PHASE, FLICKER_RATE );\n        sum += hash11( ft );\n\n        //sum += fract( ft );\n        \n        st += stepsiz;\n    }\n    \n    return sum * RCP_NUM_SAMPLES_F;\n}\n\n// ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = vec2( fract( 2.0 * uv.x ), 2.0 * uv.y );\n    \n    vec2 ctr = vec2(0.5,-0.25);\n\n    \n    int idx = int( floor(2.0*uv.x) );\n    \n    float dist = 1.0 - length( (ctr -  p + vec2(0.0, 1.5) ) * aspect  );\n\n    float circle = remap( 0.6125, 0.625, dist );\n    circle = smoothstep( 0.0, 1.0, circle );\n\n    float its = 0.0;\n    if ( idx == 0 )\n    \tits = flicker0( iTime );\n    else if ( idx == 1 )\n    \tits = flicker1( iTime );\n\n    its *= circle;\n\n    const float ysiz = 0.25;\n\t//note: current is left\n    if ( uv.y < ysiz )\n    {\n        //note: quantize to 60Hz\n        const float hztime_s = 2.0;\n        p.x = iTime - fract(2.0*uv.x) * hztime_s;\n        p.y = uv.y / (ysiz*0.9);\n        \n        float t = mytrunc( p.x, 60.0 * hztime_s );\n        float v = 0.0;\n\n        if ( uv.x < 1.0/2.0 )\n        {\n            v = flicker0( t );\n        }\n        else /*if ( uv.x < 2.0/3.0 )*/\n        {\n            v = flicker1( t );\n        }\n\n        its = step( p.y, v );\n        \n        if ( abs(fract(uv.x*2.0) - 0.49) > 0.5 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    if ( abs( uv.y - ysiz ) < 1.0 / iResolution.y )\n    {\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n\tfragColor = vec4( vec3(its), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtB3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtBGDW", "name": "Illustrated Equations ", "author": "sben", "description": "My contribution shows stuff about curves and iterative functions . After some explorations into the fractal world , I offers two drawing formulas with peculiar shapes. Enjoy!", "tags": ["procedural", "2d", "fractal", "trigonometric", "curve", "complex", "iterative", "equation", "popcorn"], "likes": 67, "viewed": 2581, "date": "1429739184", "time_retrieved": "2024-06-20T18:19:56.481525", "image_code": "// Created by sofiane benchaa - sben/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define FIELD 20.0\n#define ITERATION 12\n#define CHANNEL bvec3(true,true,true)\n#define PI4 0.7853981633974483\n#define TONE vec3(0.299,0.587,0.114)\n\n//triangle\nvec2 triangleEQ( vec3 p, float t )\n{\n\tvec2 h = vec2(0.0);\n\tvec3 q = abs(p);\n\tvec2 fx = vec2(1.0);\n\tfx.x = max(q.x*PI4+p.y*0.5,-p.y);\n\treturn fx;\n}\n//regular trifolium\nvec2 bretzTrifolEQ(vec3 p,float t){\t\n\tvec2 fx = vec2(0.008);\n\tfloat x2 = p.x*p.x;\n\tfloat y2 = p.y*p.y;\n\tfx.x = (x2+y2)*(x2+y2)-p.x*(x2-3.0*y2);\n\tfx.x *= fx.x;\n\tfx.x += p.z*p.z;\n\tfx.x /=\tfx.y;\n\treturn fx;\n}\n//quad torus\nvec2 quadTorusEQ(vec3 p,float t){\n\tvec2 fx = vec2(2.0);\n\tfloat x2 = p.x*p.x;\n\tfloat y2 = p.y*p.y;\n\tfx.x = x2*pow(1.0-x2,2.0)*pow(4.0-x2,3.0)-20.0*y2;\n\tfx.x *= fx.x;\n\tfx.x += 80.0*(p.z*p.z);\n\tfx.x /=  fx.y;\n\treturn fx;\n}\n//lemniscat Bernoulli\nvec2 bretzBernEQ(vec3 p,float t){\n\tvec2 fx = vec2(0.01);\n\tfloat x2 = p.x*p.x;\n\tfloat y2 = p.y*p.y;\n\tfx.x = ((x2+y2)*(x2+y2)-x2+y2);\n\tfx.x *= fx.x;\n\tfx.x /= fx.y;\n\treturn fx;\n}\n//just a line\nvec2 lineEQ(vec3 p,float t){\n\tvec2 fx = vec2(0.01);\n\tfloat r = 1.0;\n\tvec3 offset=vec3(0.0);\n\tp+=offset;\n\tfloat cx = clamp(p.x,-r,r);\n\tfx.x = p.y;\n\tfx.x *= fx.x;\n\tfx.x /= min(fx.y,abs(abs(cx)-r));\n\t\n\treturn fx;\n}\n//iterative equation\n\n//mandelbrot\nvec2 complexEQ(vec3 c,float t){\n\tvec4 z = vec4(c,0.0);\n\tvec3 zi = vec3(0.0);\n\tfor(int i=0; i<ITERATION; ++i){\n\t\tzi.x = (z.x*z.x-z.y*z.y);\n\t\tzi.y = (z.x*z.y+z.x*z.y);\n\t\tzi.xyz += c;\n\t\tif(dot(z.xy,z.xy)>4.0)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx;\n}\n\n//\nvec2 wolfFaceEQ(vec3 p,float t){\n\tvec2 fx = p.xy;\n\tp=(abs(p*2.0));\n\tconst float j=float(ITERATION);\n\tvec2 ab = vec2(2.0-p.x);\n\tfor(float i=0.0; i<j; i++){\n\t\tab+=(p.xy)-cos(length(p));\n\t\tp.y+=sin(ab.x-p.z)*0.5;\n\t\tp.x+=sin(ab.y)*0.5;\n\t\tp-=(p.x+p.y);\n\t\tp+=(fx.y+cos(fx.x));\n\t\tab += vec2(p.y);\n\t}\n\tp/=FIELD;\n\tfx.x=(p.x+p.x+p.y);\n\treturn fx;\n}\n\nvec2 dogFaceEQ(vec3 p,float t){\n\tvec2 fx = p.xy;\n\tp=(abs(p*2.0));\n\tconst float j=float(ITERATION);\n\tvec2 ab = vec2(2.0-p.x);\n\tfor(float i=0.0; i<j; i++){\t\t\n\t\tab+=p.xy+cos(length(p));\n\t\tp.y+=sin(ab.x-p.z)*0.5;\n\t\tp.x+=sin(ab.y)*0.5;\n\t\tp-=(p.x+p.y);\n\t\tp-=((fx.y)-cos(fx.x));\n\t}\n\tp/=FIELD;\n\tfx.x=(p.x+p.x+p.y);\n\treturn fx;\n}\n\nvec2 pieuvreEQ(vec3 p,float t){\n\tvec2 fx = p.xy;\n\tfx.x = (fx.y+length(p*fx.x)-cos(t+fx.y));\n\tfx.x = (fx.y+length(p*fx.x)-cos(t+fx.y));\n\tfx.x = (fx.y+length(p*fx.x)-cos(t+fx.y));\n\tfx.x*=fx.x*0.1;\n\treturn fx;\n}\n\n\n////////////////////////////////////////////////////////\nvec3 computeColor(vec2 fx){\n\tvec3 color = vec3(vec3(CHANNEL)*TONE);\n\tcolor -= (fx.x);\n\tcolor.b += color.g*1.5;\n\treturn clamp(color,(0.0),(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time = iTime;\n\tfloat ratio = iResolution.y/iResolution.x;\n\tfragCoord.y *= ratio;\n\tvec2 position = ( fragCoord.xy / iResolution.xy )-vec2(0.5,0.5*ratio);\n\tvec3 p = position.xyx*FIELD;\n\tp.z = 2.0*FIELD*0.5;\n\tvec3 color = computeColor(wolfFaceEQ(p+vec3(5.0,0.0,0.0),time));\n    \n\tcolor += computeColor(complexEQ(p+vec3(-5.0,-4.0,0.0),time));\n    \n\tcolor += computeColor(triangleEQ(p+vec3(-5.0,-1.0,0.0),time));\n\tp.z = 0.0;\n    \n\tcolor += computeColor(dogFaceEQ(p*2.0+vec3(0.0,0.0,0.0),time));\n    \n\tcolor += computeColor(quadTorusEQ(p+vec3(-5.0,1.0,0.0),time));\n    \n\tcolor += computeColor(bretzTrifolEQ(p+vec3(-6.0,3.0,0.0),time));\n\tcolor += computeColor(bretzBernEQ(p+vec3(-4.0,3.0,0.0),time));\n\t//color += computeColor(lineEQ(p+vec3(-5.0,4.5,0.0),time));\n\tcolor += computeColor(pieuvreEQ(p*2.5+vec3(-5.0,8.0,0.0),time));\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtBGW1", "name": "Shadow Hall", "author": "purton", "description": "Testing shadows with raymarching.", "tags": ["3d", "raymarching", "shadows", "ao"], "likes": 4, "viewed": 155, "date": "1428603281", "time_retrieved": "2024-06-20T18:19:56.481525", "image_code": "float map(in vec3 pos)\n{\n    float negCircle = length(pos) - 1.37;\n    float cube = length(max(abs(pos) - 0.95, 0.0)) - 0.05;\n    float shape = max(-negCircle, cube);\n    \n    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0;\n    \n    vec2 repeatPos = mod(pos.xz, 2.5) - 0.5 * 2.5;\n    float pillars = length(max(abs(repeatPos) - 0.075, 0.0)) - 0.025;\n    \n    return min(min(shape, ground), pillars);\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd, in float mint, in float maxt)\n{\n    float t = mint;\n    \n    for(int i = 0; i < 96; i++)\n    {\n        vec3 p = ro + rd*t;\n        float dist = map(p);\n        \n        if (dist <= 0.0 || t > maxt)\n            break;\n        \n        t += max(dist, 0.0001);\n    }\n    \n    return ro + rd*min(t, maxt);\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.02;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos);\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(p.x, p.y, 0.75));\n    \n    vec3 hitp = castRay(ro, rd, 1.5, 32.0);\n    vec3 normal = getNormal(hitp);\n    \n    vec3 lightPos = vec3(cos(iTime * 0.1) * 3.0, 0.0, sin(iTime * 0.4) * 3.0);\n    vec3 lightDir = normalize(lightPos - hitp);\n    vec3 lightHit = castRay(hitp, lightDir, 0.01, distance(hitp, lightPos));\n\t\n    float ao = getAO(hitp, normal);\n    float ndist = distance(ro, hitp) / 32.0;\n    float shadow = pow(distance(hitp, lightHit) / distance(hitp, lightPos), 64.0);\n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float attenuation = 1.0 / pow(distance(hitp, lightPos), 2.0);\n    float specular = pow(clamp(dot(normalize(lightDir - rd), normal), 0.0, 1.0), 64.0);\n    \n    vec4 diffuseColor = vec4(1.0) * diffuse * attenuation;\n    vec4 specularColor = vec4(1.0) * specular * diffuse * attenuation;\n    vec4 fogColor = vec4(0.5, 0.5, 0.0, 1.0) * pow(ndist, 3.0) +\n        \t\t\tvec4(1.0, 0.0, 0.0, 1.0) * pow(ndist, 2.0);\n    \n    fragColor = sqrt((diffuseColor + specularColor) * min(ao, shadow) + fogColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtBGWh", "name": "Flake Sea", "author": "aiekick", "description": "Flake Sea", "tags": ["sea", "flake"], "likes": 10, "viewed": 1233, "date": "1428702702", "time_retrieved": "2024-06-20T18:19:57.487707", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    \n#define displaceOffset 0.085\n\nconst int REFLEXIONS_STEP = 2;\n\n#define m2pi 6.2831\nvec3 effect(vec2 uv) \n{\n    vec2 v = uv;\n    \n   \tvec2 c0 = vec2(30.,20.);\n    vec2 c1 = vec2(10.,40.);\n    \n    vec2 n=floor(v);\n    vec2 f=fract(v);\n    \n    vec3 col;col.x=10.;\n    \n    for( float j=-1.; j<=1.; j+=1. )\n    {\n        for( float i=-1.; i<=1.; i+=1. )\n        {\n            vec2 g = vec2( i, j);\n            \n            vec2 ng = n+g;\n            float ng0 = dot(ng,c0);\n            float ng1 = dot(ng,c1);\n            vec2 ng01 = vec2(ng0,ng1);\n            vec2 hash = fract(cos(ng01)*iTime*0.2);\n            \n            vec2 o=sin(m2pi*hash)*.5+.5;\n            \n            vec2 r=g+o-f;\n            \n            float d=dot(r,r);\n            \n            if( d < col.x ) \n                col = vec3(d,r);\n        }\n    }\n     \n    return col.xzz;\n}\n\nvec4 displacement(vec3 p)\n{\n    vec2 uv = vec2(atan(p.x,p.z),acos(p.y));\n    \n    vec3 col = effect(p.xz); // p.xz\n    \n    float dist = dot(col, vec3(displaceOffset));\n    \n    dist = clamp(dist, 0., 1.);\n    \n    return vec4(dist,col*1.5);\n}\n\nvec4 map(vec3 p)\n{\n   \tfloat scale = 3.;\n    float dist = 0.;\n    \n    float x = 10.;\n    float z = 10.;\n    \n    vec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x) * scale;\n    \n    return vec4(p.y+y, disp.yzw);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\tvec2 e = vec2( 0.02,0.);\n\tvec3 nor = vec3(\n\t    map(p+e.xyy).x - map(p-e.xyy).x,\n\t    map(p+e.yxy).x - map(p-e.yxy).x,\n\t    map(p+e.yyx).x - map(p-e.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 envMap(vec3 ray)\n{\n    vec2 uv = ray.xz*100./ray.y;\n    float t = iTime;\n    float c0 = texture( iChannel0, 0.00015*uv +0.1+ 0.0043*t ).x;\n    float c1 = 0.35*texture( iChannel0, 0.00015*2.0*uv + 0.0043*.5*t ).x;\n    return vec3(c0,c1,0.);\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 0.; // elevation\n    float cam_d = 8.; // distance to origin axis\n        \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 40.; // ray marching distance max\n    float refl_i = 0.6; // reflexion intensity\n    float refr_a = 0.5; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n     \n    /////////////////////////////////////////////////////////\n    //if ( iMouse.z>0.) cam_e = iMouse.x/iResolution.x * 10.; // mouse x axis \n    //if ( iMouse.z>0.) cam_d = iMouse.y/iResolution.y * 50.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy -res)/res.y;\n        \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = 0.;\n    vec3 p = ro+rd*d;\n    float s = prec;\n    \n    vec3 ray, cubeRay;\n    \n    for(int k=0;k<REFLEXIONS_STEP;k++)\n    {\n        for(int i=0;i<20;i++)\n        {      \n            if (s<prec||s>maxd) break;\n            s = map(p).x;\n            d += s;\n            p = ro+rd*d;   \n        }\n\n        if (d<maxd)\n        {\n            vec3 n = calcNormal(p);\n\n            float ratio = float(k)/float(REFLEXIONS_STEP);\n            \n            b=li;\n\n            ray = reflect(rd, n);\n            cubeRay = envMap(ray) * refl_i;\n\n            ray = refract(rd, n, refr_a);\n            cubeRay += envMap(ray) * refr_i;\n\n            // lighting        \n            vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n            float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n            float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n            float dom = smoothstep( -0.1, 0.1, cubeRay.y );\n            float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n            float spe = pow(clamp( dot( cubeRay, lig ), 0.0, 1.0 ),16.0);\n\n            vec3 brdf = vec3(0.0);\n            brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n            brdf += 1.20*spe*vec3(1.00,0.90,0.60);\n            brdf += 0.30*amb*vec3(0.50,0.70,1.00);\n            brdf += 0.40*dom*vec3(0.50,0.70,1.00);\n            brdf += 0.30*bac*vec3(0.25,0.25,0.25);\n            brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n            \n            col=(k==0?map(p).yzw:mix(col,cubeRay+pow(b,25.),0.8*ratio));  \n\n            col *= brdf;\n            \n            ro = p;\n            rd = ray;\n            s = prec;\n        }\n        else if (k == 0)\n        {\n            col = envMap(rd);\n        }\n    }\n\tfragColor.rgb = col;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mtj3W1", "name": "Revision 2015 Livecoding Round 2", "author": "mu6k", "description": "Written under 25 minutes at Revision 2015 live-coding semifinals. I tried to adapt it by making as less modifications as possible. Put some music into iChannel0.", "tags": ["3d", "raymarching", "livecoding"], "likes": 8, "viewed": 1321, "date": "1428740660", "time_retrieved": "2024-06-20T18:19:58.160609", "image_code": "//original at: ftp://ftp.scene.org/pub/parties/2015/revision15/shadershowdown/02a-musk.glsl\n//#define LIGHT_REACT_TO_MUSIC\n\n#define v2Resolution iResolution.xy\n#define texFFTSmoothed iChannel0\n#define texFFT iChannel0\n#define fGlobalTime iTime\n#define out_color fragColor\n\n#define bt (texture(texFFTSmoothed, vec2(.01,.0)).x*1.0)\n\n#define time fGlobalTime\n\n//layout(location = 0) out vec4 out_color; // out_color must be written in order to see anything\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,.0))-r;\n}\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nfloat dft(vec3 p)\n{\n  \n  float a=time,cs=cos(a),ss=sin(a);\n  mat3 r0 = mat3(cs,ss,0,-ss,cs,0,0,0,1);\n\n\n  a=time,cs=cos(a),ss=sin(a);\n  mat3 r1 = mat3(cs,0,ss,0,1,0,-ss,0,cs);\n\n  p*=r0*r1;\n\n  p*=(1.0+bt*.1);\n  vec3 q = p;\n  p.x = abs(p.x)-.6;\n  p.x = abs(p.x)-.6;\n  //return rbox(q,vec3(.5),.1);\n  return min(rbox(p,vec3(.5),.1),rbox(q+vec3(0,1.2,0),vec3(.5),.1));\n  return length(p)-1.0-bt*.1;\n}\n\nvec3 nft(vec3 p)\n{\n  vec2 e = vec2(.0,.001);\n  float d= dft(p);\n  return normalize(vec3(d+dft(p+e.yxx), d+dft(p+e.xyx), d+dft(p+e.xxy)));\n}\n\nfloat dfb(vec3 p)\n{\n  float d =1000.0;\n  p.x+=time*16.0;\n  p = mod(p+8.0,vec3(16.0))-8.0;\n  d = min(d, -(length(p)-9.1));\n \n  p = mod(p+4.0,vec3(8.0))-4.0;\n  d = max(d,\n -(length(p)-5.1)+sin(time)*.1);\n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1.0 / length(uv) * .2;\n  float d = m.y;\n\n  float a=time*.6,cs=cos(a),ss=sin(a);\n  mat3 r0 = mat3(cs,ss,0,-ss,cs,0,0,0,1);\n\n\n  a=time*.4,cs=cos(a),ss=sin(a);\n  mat3 r1 = mat3(cs,0,ss,0,1,0,-ss,0,cs);\n\n\n  vec3 p = vec3(.0,.0,-8.0);\n  vec3 dir = normalize(vec3(uv,1.0));\n\n  p*=r0*r1;\n  dir*=r0*r1;\n  float i=0.0;\n\n  float td = 0.0;\n\n  for (int i=0; i<50; i++)\n  {\n    float d = min(dft(p),dfb(p));\n    td +=d;\n    p+=dir*d; \n  }\n\n  vec3 l = normalize(vec3(1,2,3));\n  vec3 col = (vec3(dft(p+l*.1)*2.5+.5));\n\n  if (dft(p)>dfb(p)){\n    col = vec3(i*.04)*.0;\n    col = (vec3(dfb(p+l*.1)*2.5+.5));\n    col *=4.0;\n    col *= mix(vec3(.3,.4,.9),vec3(.2,.4,.7), (uv.x-.5)*.5);\n  }\n  else\n  {\n    col*=vec3(9.0,3.0,1.0);\n    //col *= bt*vec3(.5,4.0,.5);\n  }\n  \n  col /= td;\n\n  col += length(col)*.5;\n  col -= length(uv)*.5;\n\n  float f = texture( texFFTSmoothed, vec2((uv.x-.5)*.5,.0) ).r * 5.0;\n  m.x += sin( fGlobalTime ) * 0.1;\n  m.y += fGlobalTime * 0.25;\n\n  vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n  t = clamp( t, 0.0, 1.0 );\n\n  \n  out_color = vec4(col,1.0)+f*.1;\n}\n", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtj3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtjGDm", "name": "Squircle_bc_2", "author": "BntChvn", "description": "My second Squircle Shader - 4 squircles on a parabole, chasing each other in a colorful run.", "tags": ["squircle"], "likes": 2, "viewed": 138, "date": "1429722337", "time_retrieved": "2024-06-20T18:19:58.166673", "image_code": "#define PI\t\t\t\t3.1415926535\n#define EPS\t\t\t\t0.005\n#define SQUIRCLES       4\n\n// Math tools\nfloat parabole( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\n// Squircle tools\nbool isSquircle(vec2 center, float r, vec2 uv, inout vec3 outColor)\n{\n    bool yes = false;\n    float ratio = iResolution.x/iResolution.y;\n    float power = 4.0;\n    \n    float A = (uv.x - center.x)*ratio;\n    float B = (uv.y - center.y);\n    \n    \n    if(pow(r, 4.0)*ratio > (pow(A, power)+pow(B, 4.0)))\n    {\n        yes = true;\n        outColor = vec3(sin(center.y), \n                            cos(center.x), \n                            tan(center.x));\n    }\n    \n    return yes;\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // inital color\n    vec3 color = vec3(0.5, 0.5, 0.5);\n    \n\tfloat k = 7.0;\n    float test = parabole(uv.x, k);\n    \n    // draw parabole\n    if( abs(uv.y-test)<EPS)\n    {\n        color = vec3(0.);\n    }\n    \n    // draw squircle (s)\n    for (int i=0; i<SQUIRCLES; i++)\n    {\n        vec2 center;\n        center.x = (sin(iTime + 0.25 * float(i))+PI/2.0)/PI ;\n        center.y = parabole(center.x, k);\n\n        float r = 0.05;\n        if(isSquircle(center, r, uv, color))\n        {\n            color.x += 0.2*float(i);\n            color.y += -0.2*float(i);\n            color.z += 0.2*float(i);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtjGWm", "name": "post: brightness functions", "author": "hornet", "description": "Test of various functions for increasing brightness.\nLeft-to-right: softmin, third degree polynomial, exponential.", "tags": ["post", "color", "brightness"], "likes": 7, "viewed": 420, "date": "1429699334", "time_retrieved": "2024-06-20T18:19:59.269617", "image_code": "vec3 hash32n(vec2 n)\n{\n    return fract( sin(dot(n.xy, vec2(12.9898, 78.233)))* vec3(43758.5453, 28001.8384, 50849.4141 ) );\n}\n\nvec3 remap( float a, float b, vec3 v ) {\n    //return (v-a) / (b-a);\n\treturn clamp( (v-vec3(a)) / vec3(b-a), 0.0, 1.0 );\n}\n\n/*\nvec3 gamma_pow( vec3 x, float n )\n{\n    return x; //pow( x, vec3(n) );\n    //return pow( x, vec3(1.0 - 0.65 * n) );\n    \n    //http://www.fmwconcepts.com/imagemagick/kneemap/index.php\n    //return x / (-2.0*n*(x-1.0)+1.0);\n\n}\n*/\n\nvec3 gamma_deg2( vec3 x, float n )\n{\n    //n = 1.0;\n    float x0 = 0.5 - 0.125*n;\n    float y0 = 0.5 + 0.125*n;\n\n    float b = (y0 - x0*x0) / (x0-x0*x0);\n\tfloat a = 1.0 - b;\n\n    return clamp( a*x*x + b*x, 0.0, 1.0 );    \n}\n\nvec3 gamma_deg3( vec3 x, float n )\n{\n    //n = 1.0;\n    float x0 = 0.5 - 0.125*n;\n    float y0 = 0.5 + 0.125*n;\n    \n    float x02 = x0*x0;\n    float x03 = x02*x0;\n    \n    float c = 1.0 + 0.75 * n; //note: slope at 0,0\n    //float c = 1.0;\n    float b = (y0 - x03 + c*x03 - c*x0) / (x02 - x03);\n\tfloat a = 1.0 - b - c;\n\n    vec3 x2 = x*x;\n    vec3 x3 = x2*x;\n    \n    return clamp( a*x3 + b*x2 + c*x, 0.0, 1.0 );\n}\n\nvec3 gamma_deg3_grad( vec3 x, float n )\n{\n\t//n = 1.0;\n\n\tfloat g0 = 1.0+2.2*pow(n, 2.0);\n    float g1 = 1.0-pow(n,0.5);\n    \n    float c = g0;\n    float b = 3.0 - 2.0*g0 - g1;\n\tfloat a = 1.0 - b - c;\n\t\n    vec3 ret = clamp( a*x*x*x + b*x*x + c*x, 0.0, 1.0 );\n    \n    //foot\n    //float p0 = 10.0;\n    //float p1 = 1.0 + 0.25 * n;\n    //ret *= 1.0 - exp(-p0 * pow( x, vec3(p1) ) );\n    \n    return ret;\n}\n\nvec3 gamma_cutoff( vec3 x, float n )\n{\n    return remap( 0.0, 1.0-n, x );\n}\n\nvec3 gamma_exp( vec3 x, float n )\n{\n    //n = 1.0;\n    float c1 = 1.75;\n    float c2 = 2.0; //s-curve, [1.0;2.0]\n    float c3 = 2.0; //TODO: calc so 1 maps to 1\n    vec3 fe = 1.0 - exp( -c1 * pow( abs(c3*x), vec3(c2) ) );\n\t\n    return clamp( mix( x, fe, n ), 0.0, 1.0 );\n}\n\n\nvec3 remap_noclamp( float a, float b, vec3 v ) {\n\treturn (v-vec3(a,a,a)) / (b-a);\n}\n\n//note: smooth minium, soft-min, https://www.shadertoy.com/view/ltf3W2\nfloat SAbs(float x, float k)\n{\n    return sqrt(x * x + k);\n}\n\nfloat SRamp1(float x, float k)\n{\n    return 0.5 * (x - SAbs(x, k));\n}\n\nfloat SMin1(float a, float b, float k)\n{\n    return a + SRamp1(b - a, k);\n}\n\n//note: smax = -smin(-a, -b, k )\nvec3 SMin1(vec3 a, vec3 b, float k)\n{\n    return vec3( SMin1( a.r, b.r, k ),\n\t\t\t     SMin1( a.g, b.g, k ),\n\t\t\t     SMin1( a.b, b.b, k ) );\n}\n\n\nvec3 gamma_softmin( vec3 x, float t )\n{\n    //note: black-cutoff, white-cutoff, power, soft-clipping\n    vec4 parms = mix( vec4( 0.0, 1.0, 0.0, 0.0 ),\n                      vec4( 0.0, 0.25, 0.25, 1.0 ), t );\n    float blacklift = mix( 0.0, 0.05, t );\n        \n\tx = max( x, parms.xxx ); //note: clamp below min\n\tx = remap_noclamp( parms.x, parms.y, x );\n\n\tfloat pexp = 1.0 / (1.0 - 0.5*parms.z); //TODO: input pexp\n\tx = pow( x, vec3(pexp, pexp, pexp) );\n\n\tx = x * (1.0-blacklift) + blacklift;\n\n\tfloat pmin = 0.2 * parms.w;\n\tx = SMin1( x, vec3(1.0, 1.0, 1.0), pmin ); //upper\n\n\treturn x;\n}\n\n\n\nvec3 gamma( vec3 x, float t, int idx )\n{\n    if ( idx == 0 )\n        return gamma_softmin( x, t ); //return gamma_pow( x, t ); //return gamma_cutoff( vec3(x), t ).x;\n    else if ( idx == 1 )\n        return gamma_deg3_grad(x,t); // return gamma_deg2(vec3(x),t).x;\n    else\n        return gamma_exp(x, t );\n}\n\nfloat f( float x, float t, int idx )\n{\n\treturn gamma( vec3(x), t, idx ).x;\n}\n\nfloat calcCurve( vec2 uv, float t, int idx )\n{\n    float threshold = 17.0 / iResolution.y;\n    float x = uv.x;\n    float fx = f( x, t, idx );\n    float dist = abs( uv.y - fx );\n    return max( 0.0, 10.0*( threshold - dist ) );\n}\n\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(1.0/2.2) );\n}\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(2.2) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0-uv.y;\n    \n    //vec3 col = texture( iChannel0, uv).rgb;\n    vec3 col = texture( iChannel0, uv + vec2( 0.05 * iTime, 0.0 ), -10.0 ).rgb;\n    col = srgb2lin( col );\n    //col *= 0.25;\n\n    float t = 0.5 + 0.5 * sin( iTime );\n    //t = 1.0;\n    \n    if ( iMouse.z > 0.5 )\n        t = iMouse.x / iResolution.x;\n\n    if ( uv.y > 0.9 )\n    {\n    \tcol = srgb2lin( vec3( fract( uv.x * 3.0 ) ) );\n    }\n\n    if ( uv.x < 1.0/3.0 )\n        col = gamma(col, t, 0 );\n    else if ( uv.x < 2.0/3.0 )\n\t\tcol = gamma(col, t, 1 );\n    else\n        col = gamma(col, t, 2 );\n\n    \n    if ( uv.y < 0.9 && uv.y > 0.8 )\n    {\n        vec2 guv;\n        guv.x = fract( 3.0 * uv.x );\n        guv.y = 1.0-(uv.y-0.81) / 0.09;\n\n        vec3 curvecol;\n        if ( uv.x < 1.0/3.0 )\n\t\t\tcurvecol = vec3( calcCurve( guv, t, 0 ) );\n        else if ( uv.x < 2.0/3.0 )\n            curvecol = vec3( calcCurve( guv, t, 1 ) );\n        else\n            curvecol = vec3( calcCurve( guv, t, 2 ) );\n            \n        col = mix( vec3(0.1, 0.1, 0.1), vec3(1,1,1), curvecol );\n    }\n\n    \n    vec4 outcol = vec4( lin2srgb(col), 1.0 );\n    vec3 rnd = hash32n( uv + fract(iTime) ) + hash32n( uv + 0.1337 + fract(iTime) ) - 0.5;\n    outcol.rgb += rnd / 255.0;\n    \n\tfragColor = outcol;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtjGWR", "name": "flame2D", "author": "Eddh", "description": "A flame in 2D created with some noise function.", "tags": ["2d", "coherentnoise"], "likes": 1, "viewed": 272, "date": "1428247804", "time_retrieved": "2024-06-20T18:19:59.275476", "image_code": "// This code is a mess. Please ignore\n\n\n// noise function from iq\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(vec2 p, int octaves, float gain, float lacunarity){\n\tfloat val = noise(p+vec2(0.0, -10.0*iTime));\n\tfloat current;\n\tfloat f = lacunarity;\n\tfor(int i=0 ; i<5 ; i++){\n\t\tfloat b = 1.0;\n\t\tcurrent =  noise((p+vec2(0.0, -13.0*iTime*b))*f)*gain;\n\t\tval += current;\n\t\t\n\t\tf*= lacunarity;\n\t}\n\t\t\t//val*=val;\n\treturn val;\n}\n\nvec4 getPoint(float x, float y){\n\tvec2 center = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n\tfloat nX = x;\n\tfloat nY = y;\n\tfloat trueDistFromCenter = length(vec2(nX-center.x, nY-center.y))*0.2;\n\tfloat distFromCenter = length(vec2( (nX-center.x)/(nY-center.y),\n\t\t\t\t\t\t\t\t\t\t(nY-center.y)*0.5));\n\t//float val = fbm(vec2(x*100, y*100 - 30*inTime*(1-trueDistFromCenter*trueDistFromCenter)), 5, 0.6, 1.83);\n\tfloat val = fbm(vec2(x*iResolution.x*0.3, 5.0*iResolution.y*y*(trueDistFromCenter*trueDistFromCenter) ), 5, 0.8, 1.83);\n\tval = 0.1/(distFromCenter*distFromCenter*10.0) + 1.0*val/(distFromCenter*distFromCenter*150.0) -0.1;\n\tval = abs(val);\n\tif( nY-center.y < 0.0){\n\t\tval = 0.0;\n\t}\n\tfloat red = 3.0*val*val+ val+0.3;\n\tfloat green = val*val+val+0.2;\n\tfloat blue =val*val +0.2;\n\tif(val < 0.3){\n\t\tfloat val2 = 0.2 - distFromCenter*0.7 + val*0.5;\n\t\tred = val2;\n\t\tgreen = val2;\n\t\tblue = val2;\n\t}\n\treturn vec4(red, green, blue, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 p1 = getPoint(gl_FragCoord.x/iResolution.x, gl_FragCoord.y/iResolution.y + 0.5/iResolution.y);\n\tvec4 p2 = getPoint(gl_FragCoord.x/iResolution.x - 0.3/iResolution.x, gl_FragCoord.y/iResolution.y - 0.3/iResolution.y);\n\tvec4 p3 = getPoint(gl_FragCoord.x/iResolution.x + 0.3/iResolution.x, gl_FragCoord.y/iResolution.y - 0.3/iResolution.y);\n\tvec4 i1 = mix(p2, p3, 0.5);\n\tvec4 i2 = mix(i1, p1, 0.5);\n\ti1 = mix(i1, i2, 0.5);\n\t\n\t\n\tfragColor = i1;\n\t//outColor = vec4(val, 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtjGWz", "name": "spheres with oscillating spec", "author": "ballzac", "description": "No idea how much of what I've done here is how it would 'normally' be done.\n\nEach sphere is just drawn on top of the previously drawn sphere. I will need to work out how to do occlusion properly to be able to, say, get two spheres to orbit each other.", "tags": ["sphere", "specular", "diffuse"], "likes": 0, "viewed": 150, "date": "1428296403", "time_retrieved": "2024-06-20T18:19:59.275720", "image_code": "#define PI 3.14159264359\n\n\nfloat mag ( vec3 v )\n{\n return  sqrt(dot(v,v));   \n}\n\nvec3 sphere( vec3 c, float r, vec3 obs, vec3 Lpos, vec2 uv, vec3 diffuse_col,vec3 spec_col,vec3 I )\n{\n    \n    if((uv.x-c.x)*(uv.x-c.x)+(uv.y-c.y)*(uv.y-c.y) < r*r) {\n             \n            vec3 s = vec3(uv,c.z-sqrt(r*r-(uv.x-c.x)*(uv.x-c.x)-(uv.y-c.y)*(uv.y-c.y)));//surface point\n            float test = dot(s-obs,s-c);\n            float t1 = acos(dot(obs-s,s-c)/(mag(s-obs)*mag(s-c)));\n            float t2 = acos(dot(Lpos-s,s-c)/(mag(Lpos-s)*mag(s-c))); \n\n            vec2 diffspec = vec2(0.,0.);\n\n            {\n             diffspec.x += abs(t1-t2)/(PI);//diffuse\n             diffspec.y += diffspec.x*diffspec.x*diffspec.x*diffspec.x*1.;//specular\n                diffspec/=2.;\n\n            }\n\n            vec3 colour = diffuse_col*diffspec.x+spec_col*diffspec.y;\n            return abs(colour);\n    }else{\n        return I;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = (fragCoord.xy / iResolution.x - vec2(0.5,0.5))*2.0;\n    \n    \n    \n    vec3 obs = vec3(uv.x,uv.y,2.);\n    vec3 Lpos = vec3(5.,1.,-10.);//light position\n    vec3 Lcol = vec3(1.*sin(time)*sin(time),1.*sin(time*1.235)*sin(time*1.235),1.*sin(time*5.));\n    \n    vec3 c;\n    float r;\n    vec3 I =vec3(0.,0.,0.);\n    \n    r = 0.4*sin(time*0.25)*sin(time*0.25)+0.1;\n    c = vec3(-0.5+0.5*cos(time/4.2)*cos(time/4.2),-0.3*sin(time*1.2),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(0.,1.,1.),Lcol, I ) ;\n    \n    r = 0.2*sin(time/4.)*sin(time/4.)+0.02;\n    c = vec3(0.5*sin(time*0.47),-0.5*cos(time*1.2),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,1.),Lcol, I ) ;\n    \n    r = 0.05*sin(time)*sin(time)+0.05;\n    c = vec3(0.6+0.1*cos(time/2.),-0.5+1.*sin(time/1.3),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,0.),Lcol, I ) ;\n    \n    r = 0.06*cos(time*0.9)*cos(time*0.9)+0.045;\n    c = vec3(-1.1+1.2*mod(time,4.)/2.,-0.7,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n    r = 0.06*cos(time*0.9)*cos(time*0.9)+0.045;\n    c = vec3(-1.1+1.2*mod(time,4.)/2.,0.,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n    r = 0.3*sin(time*0.3)*sin(time*0.3)+0.1;\n    c = vec3(-0.6+0.6*cos(time/3.)*cos(time/3.),-0.3,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(0.,1.,0.),Lcol, I ) ;\n    \n    r = 0.01*sin(time)*sin(time)+0.01;\n    c = vec3(0.6+0.2*cos(time/1.1),0.5+1.*sin(time/1.7),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,0.),Lcol, I ) ;\n    \n    r = 0.02*sin(time*0.8)*sin(time*0.8)+0.02;\n    c = vec3(0.2+0.1*cos(time/1.4),0.3+0.9*sin(time/1.3),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,0.),Lcol, I ) ;\n    \n    r = 0.04*cos(time*0.8)*cos(time*0.8)+0.03;\n    c = vec3(0.2+0.1*sin(time/1.4),0.3+0.9*cos(time/1.3),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(0.3,0.4,0.7),Lcol, I ) ;\n    \n    r = 0.04*cos(time*0.8)*cos(time*0.8)+0.03;\n    c = vec3(-1.1+1.2*mod(time,2.),-0.5,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n    \n    \n    \n    \n    r = 0.3*sin(time*0.15)*sin(time*0.15)+0.15;\n    c = vec3(-0.4+0.6*cos(time/4.1)*cos(time/4.1),-0.25*sin(time*1.1),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.2,1.),Lcol, I ) ;\n    \n    r = 0.22*sin(time/3.1)*sin(time/3.1)+0.022;\n    c = vec3(0.4*sin(time*0.44),-0.3*cos(time*1.1),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,1.),Lcol, I ) ;\n    \n    r = 0.05*sin(time)*sin(time)+0.05;\n    c = vec3(0.3+0.2*cos(time/1.05),-0.35+1.6*sin(time/1.1),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,0.),Lcol, I ) ;\n    \n    r = 0.06*cos(time*0.9)*cos(time*0.9)+0.045;\n    c = vec3(1.1-1.2*mod(time,4.)/2.,-0.9 ,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n    r = 0.06*cos(time*0.9)*cos(time*0.9)+0.045;\n    c = vec3(1.1-1.2*mod(time,4.)/2.,-0.1,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n    r = 0.35*sin(time*0.34)*sin(time*0.34)+0.1;\n    c = vec3(-0.7+0.5*cos(time/3.2)*cos(time/3.2),-0.2,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(0.,1.,0.),Lcol, I ) ;\n    \n    r = 0.1*sin(time)*sin(time)+0.005;\n    c = vec3(0.4+0.3*cos(time/0.85),0.2+1.25*sin(time/1.2),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,0.),Lcol, I ) ;\n    \n    r = 0.02*sin(time*0.97)*sin(time*0.97)+0.02;\n    c = vec3(0.3+0.15*cos(time/1.278),0.257+0.98*sin(time/1.1258),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,0.,0.),Lcol, I ) ;\n    \n    r = 0.03*cos(time*0.2)*cos(time*0.2)+0.04;\n    c = vec3(0.1+0.1*sin(time/1.4),-0.1*cos(time/1.3),-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(0.3,0.4,0.7),Lcol, I ) ;\n    \n    r = 0.04*cos(time*0.8)*cos(time*0.8)+0.03;\n    c = vec3(1.1-1.2*mod(time,2.),-0.8,-r*10.);\n    I=  sphere( c, r, obs, Lpos, uv, vec3(1.,1.,1.),Lcol, I ) ;\n    \n\tfragColor = vec4(I,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtjGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtS3RG", "name": "some warped blob like pattern", "author": "public_int_i", "description": "some blob like pattern", "tags": ["2d", "blob", "pattern", "warped"], "likes": 1, "viewed": 117, "date": "1429839940", "time_retrieved": "2024-06-20T18:19:59.275720", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy - vec2(.5);\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= 8.+cos(iTime)*8.;\n    \n    float sy = sin(uv.y);\n    float cx = cos(uv.x);\n    uv.x += sy/cx;\n    uv.y += cx/sy;\n    \n    float len = length(mod(uv,1.)-vec2(.5));\n    if (len < 1.) {\n        fragColor = vec4(len);\n    } else {\n        fragColor = vec4(0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtS3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtSGRV", "name": "Hypnotizr", "author": "bzgeb", "description": "Bvvvvvvvvvvvvvvvvvvvvvvvvvvvv", "tags": ["2d"], "likes": 0, "viewed": 107, "date": "1430320248", "time_retrieved": "2024-06-20T18:19:59.493975", "image_code": "//Experiment by @bzgeb\n//Based on previous shader: Overly satisfying by nimitz (twitter: @stormoid)\n\n#define time iTime*2.6\n#define pi 3.14159265\n\n#define NUM 20.\n\nfloat aspect = iResolution.x/iResolution.y;\nfloat w = 50./sqrt(iResolution.x*aspect+iResolution.y);\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy*2.-1.;\n\tp.x *= aspect;\n    p*= 1.05;\n    vec2 bp = p;\n    \n    p *= mm2(time*.25);\n    \n    float lp = length(p);\n    float id = floor(lp*NUM+.5)/NUM;\n    \n    p *= mm2(id*11.);\n    \n    p.y = abs(p.y); \n    \n    //polar coords\n    vec2 plr = vec2(lp, atan(p.y, p.x));\n\tfragColor = vec4(plr, 0.0 ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl23Dz", "name": "The Tender Cut [TV]", "author": "jimmikaelkael", "description": "This shader is based on a screenshot of the video game \"The Tender Cut\" with the permission of the authors.\nYou can toggle colors using 'C' key, sit down and watch TV using 'W' key.\nMore infos on the game: http://thetendercut.info/", "tags": ["tv", "chair", "cut", "room", "tender", "television"], "likes": 18, "viewed": 524, "date": "1428248180", "time_retrieved": "2024-06-20T18:19:59.523199", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ID_NONE         -1.0\n#define ID_FLOOR         0.01\n#define ID_CEILING       0.02\n#define ID_WALL_BACK     0.03\n#define ID_WALL_FRONT    0.04\n#define ID_WALL_LEFT     0.05\n#define ID_WALL_RIGHT    0.06\n#define ID_BASEBOARD_XY  0.07\n#define ID_BASEBOARD_YZ  0.08\n#define ID_CARPET        0.09\n#define ID_CARPET_B      0.10\n#define ID_TV_0          0.11  // tv wood body\n#define ID_TV_1          0.12  // tv wood borders\n#define ID_TV_2          0.13  // tv hp\n#define ID_TV_3          0.14  // tv tube\n#define ID_TV_4          0.15  // tv screen\n#define ID_TV_5          0.16  // tv btn\n#define ID_TV_6          0.17  // tv pot black\n#define ID_TV_7          0.18  // tv pot white\n#define ID_CHAIR_0       0.19  // chair wood\n#define ID_CHAIR_1       0.20  // chair seat\n\n#define KEY_C            67\n#define KEY_W            87\n\nfloat noise3d(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel1, (uv + 0.5) / 256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fBm3d(in vec3 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise3d(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, float r)\n{\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdSphere(in vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdCappedCylinder(in vec3 p, in vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 rotateY(in vec3 p, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(in vec3 p, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n/*\nvec2 mapChair(in vec3 p)\n{\n    float d1 = sdBox(p + vec3(3.0, -2.0, 4.5), vec3(1.8, 3.1, 0.5));\n    float d2 = max(-d1, sdBox(p + vec3(3.0, -2.5, 4.5), vec3(2.1, 2.9, 0.2)));\n    float d3 = sdBox(p + vec3(3.0, -2.0, 8.5), vec3(1.8, 3.1, 0.5));\n    float d4 = max(-d3, sdBox(p + vec3(3.0, -2.5, 8.5), vec3(2.1, 2.9, 0.2)));\n    float d5 = sdBox(p + vec3(1.05, -2.0, 6.5), vec3(0.5, 4.3, 1.8));\n    float d6 = max(-d5, sdBox(p + vec3(1.05, -2.5, 6.5), vec3(0.2, 4.1, 2.2)));\n    vec3 size = vec3(2.0, 0.075, 0.075);\n    float d7 = sdBox(p + vec3(3.0, -4.35, 4.5), size);\n    float d8 = sdBox(p + vec3(3.0, -4.35, 8.5), size);\n    float d9 = sdBox(p + vec3(1.05, -4.35, 6.5), vec3(0.075, 0.075, 2.0));\n    float d10 = sdBox(p + vec3(1.05, -5.35, 6.5), vec3(0.075, 0.075, 2.0));\n    size = vec3(0.075, 1.0, 0.075);\n    d1 = sdBox(p + vec3(2.35, -4.25, 4.5), size);\n    d3 = sdBox(p + vec3(3.65, -4.25, 4.5), size);\n    d5 = sdBox(p + vec3(2.35, -4.25, 8.5), size);\n    float d11 = sdBox(p + vec3(3.65, -4.25, 8.5), size);\n    size = vec3(0.075, 1.75, 0.075);\n    float d12 = sdBox(p + vec3(1.05, -4.75, 5.85), size);\n    float d13 = sdBox(p + vec3(1.05, -4.75, 7.25), size);\n    vec2 res = vec2(ID_CHAIR_0, min(d13, min(d12, min(d11, min(d5, min(d3, min(d1, min(d10, min(d9, min(d8, min(d7, min(d6, min(d4, min(d2, sdBox(p + vec3(3.0, -3.25, 6.5), vec3(2.1, 0.2, 2.2))))))))))))))));\n    vec2 obj = vec2(ID_CHAIR_1, udRoundBox(p + vec3(3.05, -3.26, 6.5), vec3(1.8, 0.2, 1.8), 0.025));\n    if (obj.y < res.y) res = obj;\n    return res;\n}\n*/\nvec2 map(in vec3 p)\n{\n    // hit object ID is stored in res.x, distance to object is in res.y\n\n    float rot90 = 6.2831 / 4.0;\n\n    // walls mapping\n    vec2 res = vec2(ID_FLOOR, sdBox(p + vec3(0.0, 1.0, 0.0), vec3(15.0, 1.0, 17.0)));\n    //vec2 obj = vec2(ID_CEILING, sdBox(p + vec3(0.0, -17.0, 0.0), vec3(15.0, 0.0, 17.0)));\n    //if (obj.y < res.y) res = obj;\n    //obj = vec2(ID_WALL_BACK, sdBox(p + vec3(-10.5, 0.0, 0.0), vec3(0.5, 17.0, 17.0)));\n    //if (obj.y < res.y) res = obj;\n    vec2 obj = vec2(ID_WALL_FRONT, sdBox(p + vec3(15.0, 0.0, 0.0), vec3(0.0, 17.0, 17.0)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_WALL_LEFT, sdBox(p + vec3(0.0, 0.0, 15.0), vec3(15.0, 17.0, 0.0)));\n    if (obj.y < res.y) res = obj;\n    //obj = vec2(ID_WALL_RIGHT, sdBox(p + vec3(0.0, 0.0, -17.0), vec3(15.0, 17.0, 0.0)));\n    //if (obj.y < res.y) res = obj;\n\n    // baseboards mapping\n    vec3 size = vec3(17.0, 0.65, 0.065);\n    obj = vec2(ID_BASEBOARD_YZ, sdBox(p + vec3(0.0, 0.0, 15.0), size));\n    if (obj.y < res.y) res = obj;\n    //obj = vec2(ID_BASEBOARD_YZ, sdBox(p + vec3(0.0, 0.0, -17.0), size));\n    //if (obj.y < res.y) res = obj;\n    obj = vec2(ID_BASEBOARD_XY, sdBox(rotateY(p + vec3(15.0, 0.0, 0.0), rot90), size));\n    if (obj.y < res.y) res = obj;\n    //obj = vec2(ID_BASEBOARD_XY, sdBox(rotateY(p + vec3(-10.0, 0.0, 0.0), rot90), size));\n    //if (obj.y < res.y) res = obj;\n\n    // carpet mapping\n    if (res.x == ID_FLOOR) {\n        obj = vec2(ID_CARPET_B, udRoundBox(rotateY(p + vec3(2.0, 0.0, -2.0), -2.0), vec3(8.0, 0.05, 7.0), 0.15));\n        if (obj.y < res.y) res = obj;\n        obj = vec2(ID_CARPET, sdBox(rotateY(p + vec3(2.0 - 0.075, 0.0, -2.0 + 0.025), -2.0), vec3(7.925, 0.25, 6.925)));\n        if (obj.y < res.y) res = obj;\n    }\n\n    // tv mapping\n    vec3 sizeTV = vec3(3.0, 9.0, 3.0);\n    float d1 = sdBox(p + vec3(15.0, 0.0, 6.0), vec3(7.0, 13.0, 2.5));\n    float d2 = udRoundBox(p + vec3(15.0, 0.0, 6.0), vec3(5.0, 1.2, 1.5), 0.5);\n    float d3 = udRoundBox(p + vec3(12.0, -3.5, 6.0), vec3(1.0, 0.5, 1.5), 0.5);\n    size = vec3(4.0, 1.0, 0.08);\n    float d4 = sdBox(p + vec3(15.0, -3.5, 6.0), size);\n    float d5 = sdBox(p + vec3(15.0, -3.5, 5.6), size);\n    float d6 = sdBox(p + vec3(15.0, -3.5, 6.4), size);\n    float d7 = udRoundBox(p + vec3(12.0, -7.25, 6.0), vec3(1.0, 0.61, 1.2), 1.0);\n    obj = vec2(ID_TV_0, max(-d7, min(d6, min(d5, min(d4, max(-d3, max(-d2, max(d1, udRoundBox(p + vec3(15.0, 0.0, 6.0), sizeTV, 1.0)))))))));\n    if (obj.y < res.y) res = obj;\n    d1 = sdBox(p + vec3(15.18, 0.25, 3.5), vec3(7.0, 13.0, 0.2));\n    size = vec3(0.1, 1.0, 1.0);\n    d2 = sdBox(p + vec3(12.8, -3.5, 4.0), size);\n    d3 = sdBox(p + vec3(13.2, -3.5, 4.0), size);\n    d4 = max(-d3, max(-d2, max(d1, udRoundBox(p + vec3(15.18, 0.25, 3.5), sizeTV, 1.0))));\n    d5 = sdBox(p + vec3(15.18, 0.25, 8.5), vec3(7.0, 13.0, 0.2));\n    //d6 = sdBox(p + vec3(12.8, -3.5, 8.0), size);\n    //d7 = sdBox(p + vec3(13.2, -3.5, 8.0), size);\n    //obj = vec2(ID_TV_1, min(d4, max(-d7, max(-d6, max(d5, udRoundBox(p + vec3(15.18, 0.25, 8.5), sizeTV, 1.0))))));\n    obj = vec2(ID_TV_1, min(d4, max(d5, udRoundBox(p + vec3(15.18, 0.25, 8.5), sizeTV, 1.0))));\n    if (obj.y < res.y) res = obj;\n    d1 = sdBox(p + vec3(8.25, -3.5, 6.0), sizeTV);\n    obj = vec2(ID_TV_2, max(-d1, udRoundBox(p + vec3(12.0, -3.5, 6.0), vec3(1.0, 0.5, 1.5), 0.5)));\n    if (obj.y < res.y) res = obj;\n    d1 = sdBox(p + vec3(7.85, -7.25, 6.0), sizeTV);\n    d2 = udRoundBox(p + vec3(12.0, -7.25, 6.0), vec3(1.0, 0.6, 1.175), 1.0);\n    obj = vec2(ID_TV_3, max(-d2, max(-d1, udRoundBox(p + vec3(12.0, -7.25, 6.0), vec3(1.0, 0.7, 1.25), 1.0))));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_TV_4, udRoundBox(p + vec3(12.75, -7.25, 6.0), vec3(1.0, 1.05, 1.75), 0.5));\n    if (obj.y < res.y) res = obj;\n    d1 = sdCappedCylinder(rotateZ(p + vec3(11.25, -5.0, 6.25), rot90), vec2(0.12, 0.425));\n    obj = vec2(ID_TV_5, min(d1, sdCappedCylinder(rotateZ(p + vec3(11.25, -5.0, 5.75), rot90), vec2(0.12, 0.325))));\n    if (obj.y < res.y) res = obj;\n    vec2 sizePot = vec2(0.3, 0.4);\n    d1 = sdCappedCylinder(rotateZ(p + vec3(11.25, -5.0, 4.0), rot90), sizePot);\n    d2 = sdCappedCylinder(rotateZ(p + vec3(11.25, -5.0, 8.0), rot90), sizePot);\n    d3 = sdBox(p + vec3(10.425, -5.0, 4.0), vec3(0.25));\n    d4 = sdSphere(p + vec3(10.84, -5.0, 8.0), 0.25);\n    d5 = sdBox(p + vec3(10.425, -5.0, 8.0), vec3(0.25));  \n    d6 = sdCappedCylinder(rotateZ(p + vec3(10.675, -5.0, 4.0), rot90), vec2(0.175, 0.01));\n    d7 = sdCappedCylinder(rotateZ(p + vec3(10.675, -5.0, 8.0), rot90), vec2(0.175, 0.01));\n    float rot = 6.2831 / 3.428;\n    float d8 = sdBox(rotateZ(p + vec3(10.8, -5.2, 4.0), rot), vec3(0.08, 0.1, 0.04));\n    float d9 = sdBox(rotateZ(p + vec3(10.8, -5.2, 8.0), rot), vec3(0.08, 0.1, 0.04));\n    obj = vec2(ID_TV_6, min(d9, min(d8, min(d7, min(d6, max(-d5, min(d4, max(-d3, min(d2, min(d1, sdSphere(p + vec3(10.84, -5.0, 4.0), 0.25)))))))))));\n    if (obj.y < res.y) res = obj;\n    sizePot = vec2(0.29, 0.01);\n    d1 = sdCappedCylinder(rotateZ(p + vec3(10.84, -5.0, 4.0), rot90), sizePot);\n    d2 = sdCappedCylinder(rotateZ(p + vec3(10.675, -5.0, 4.0), rot90), vec2(0.2, 0.01));\n    d3 = sdCappedCylinder(rotateZ(p + vec3(10.675, -5.0, 8.0), rot90), vec2(0.2, 0.01));\n    obj = vec2(ID_TV_7, min(d3, min(d2, min(d1, sdCappedCylinder(rotateZ(p + vec3(10.84, -5.0, 8.0), rot90), sizePot)))));\n    if (obj.y < res.y) res = obj;\n\n    // chair mapping\n    d1 = sdBox(p + vec3(3.0, -2.0, 4.5), vec3(1.8, 3.1, 0.5));\n    d2 = max(-d1, sdBox(p + vec3(3.0, -2.5, 4.5), vec3(2.1, 2.9, 0.2)));\n    d3 = sdBox(p + vec3(3.0, -2.0, 8.5), vec3(1.8, 3.1, 0.5));\n    d4 = max(-d3, sdBox(p + vec3(3.0, -2.5, 8.5), vec3(2.1, 2.9, 0.2)));\n    d5 = sdBox(p + vec3(1.05, -2.0, 6.5), vec3(0.5, 4.3, 1.8));\n    d6 = max(-d5, sdBox(p + vec3(1.05, -2.5, 6.5), vec3(0.2, 4.1, 2.2)));\n    size = vec3(2.0, 0.075, 0.075);\n    d7 = sdBox(p + vec3(3.0, -4.35, 4.5), size);\n    d8 = sdBox(p + vec3(3.0, -4.35, 8.5), size);\n    d9 = sdBox(p + vec3(1.05, -4.35, 6.5), vec3(0.075, 0.075, 2.0));\n    float d10 = sdBox(p + vec3(1.05, -5.35, 6.5), vec3(0.075, 0.075, 2.0));\n    size = vec3(0.075, 1.0, 0.075);\n    d1 = sdBox(p + vec3(2.35, -4.25, 4.5), size);\n    d3 = sdBox(p + vec3(3.65, -4.25, 4.5), size);\n    d5 = sdBox(p + vec3(2.35, -4.25, 8.5), size);\n    float d11 = sdBox(p + vec3(3.65, -4.25, 8.5), size);\n    size = vec3(0.075, 1.75, 0.075);\n    float d12 = sdBox(p + vec3(1.05, -4.75, 5.85), size);\n    //float d13 = sdBox(p + vec3(1.05, -4.75, 7.25), size);\n    //obj = vec2(ID_CHAIR_0, min(d13, min(d12, min(d11, min(d5, min(d3, min(d1, min(d10, min(d9, min(d8, min(d7, min(d6, min(d4, min(d2, sdBox(p + vec3(3.0, -3.25, 6.5), vec3(2.1, 0.2, 2.2))))))))))))))));\n    obj = vec2(ID_CHAIR_0, min(d9, min(d8, min(d7, min(d6, min(d4, min(d2, sdBox(p + vec3(3.0, -3.25, 6.5), vec3(2.1, 0.2, 2.2)))))))));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(ID_CHAIR_0, min(d12, min(d11, min(d5, min(d3, min(d1, min(d10, sdBox(p + vec3(1.05, -4.75, 7.25), size))))))));\n    if (obj.y < res.y) res = obj;   \n    obj = vec2(ID_CHAIR_1, udRoundBox(p + vec3(3.05, -3.26, 6.5), vec3(1.8, 0.2, 1.8), 0.025));\n    if (obj.y < res.y) res = obj;\n    //obj = mapChair(p);\n    //if (obj.y * 0.95 < res.y) res = obj;\n\n    // floor bumps\n    if (res.x == ID_FLOOR)\n    {\n        if (p.x < 9.85 && p.x > -14.85 && p.z < 16.85 && p.z > -14.85)\n            res.y += 0.1 * texture(iChannel0, 0.1875 * p.xz).x;\n    }\n\n    return res;\n}\n\nvec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    vec3 res = vec3(ID_NONE);\n    float t = tmin;\n    for (int i = 0; i < 90; i++)\n    {\n        vec3 p = ro + rd * t;\n        res = vec3(map(p), t);\n        float d = res.y;\n        if (d < (0.0001 * t) || t > tmax)\n            break;\n        t += 0.75 * d;\n    }\n    return res.xz;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    vec2 eps = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + eps.xyy).y - map(p - eps.xyy).y,\n                          map(p + eps.yxy).y - map(p - eps.yxy).y,\n                          map(p + eps.yyx).y - map(p - eps.yyx).y));\n}\n\nvec3 getBump(in vec3 p, float e) {\n    vec2 eps = vec2(e, 0.0);\n    return normalize(vec3(fBm3d(p + eps.xyy) - fBm3d(p - eps.xyy),\n                          fBm3d(p + eps.yxy) - fBm3d(p - eps.yxy),\n                          fBm3d(p + eps.yyx) - fBm3d(p - eps.yyx)));\n}\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin)\n{\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++)\n    {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = map(p).y;\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.15 * ao;\n}\n\nbool toggleKey(int key)\n{\n\treturn texture(iChannel3, vec2((float(key) + 0.5) / 256.0, 0.75)).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(4.0, 6.25, -6.0);\n    if (!toggleKey(KEY_W)) {\n        eye = vec3(0.0 + sin(iTime * 0.25) * 0.5, 8.0, 1.0 + cos(iTime * 0.05) * 0.5);\n    }\n    //vec2 rot = 6.2831 * (vec2(-0.625, 0.035) + vec2(1.0, 0.15) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    vec2 rot = 6.2831 * vec2(0.125, 0.035);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 7.0, 0.0);\n    if (toggleKey(KEY_W)) {\n        ta = vec3(-1.0, 7.35, -6.0);\n    }\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    float l = 2.5;\n    if (!toggleKey(KEY_W)) {\n        l = 2.0 + sin(iTime * 0.1) * 0.35;\n    }\n    \n    vec3 rd = cam * normalize(vec3(p.xy, l));\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 0.5;\n    float tmax = 25.0;\n    vec2 obj = raymarchScene(ro, rd, tmin, tmax);\n    float id = obj.x;\n    if (id > ID_NONE)\n    {\n        float t = obj.y;\n        vec3 pos = ro + rd * t;\n        vec3 nor = getNormal(pos);\n\n        if (id == ID_FLOOR)\n        {\n            float n = 0.025 * fBm3d(1.5 * pos);\n            col = vec3(0.3, 0.25, 0.2) - n;\n            col = mix(col, texture(iChannel0, 0.1875 * pos.xz).xyz, 0.15);\n            col += 0.1 * mod(floor(0.5 * pos.z + n * 0.5), 2.0) * vec3(0.075);\n            col = mix(col - 0.035, col, smoothstep(0.025, 0.035, mod(pos.z + n, 2.0)));           \n        }\n        /*else if (id == ID_CEILING)\n        {\n            float n = 0.015 * fBm3d(1.5 * pos);\n            col = vec3(0.5, 0.45, 0.35) + 0.04 - n;\n        }*/\n        else if (/*id == ID_WALL_BACK ||*/ id == ID_WALL_FRONT)\n        {\n            float n = 0.015 * fBm3d(1.5 * pos);\n            col = vec3(0.5, 0.45, 0.35) + n;\n            float s = smoothstep(1.0, 0.0, pos.y - 14.0);\n            col = mix(col + 0.01, mix(col, texture(iChannel0, 0.125 * pos.xz).xyz, 0.05), s);\n            col = mix(col, mix(col - 0.035, col, smoothstep(0.025, 0.06, mod(1.8 * pos.z + n * 2.0, 2.0))), s);\n            if (pos.y > 13.5 && pos.y < 14.5)\n            {\n                col = vec3(0.5, 0.45, 0.35) - 0.04 + n;\n            }\n        }\n        else if (id == ID_WALL_LEFT /*|| id == ID_WALL_RIGHT*/)\n        {\n            float n = 0.015 * fBm3d(1.5 * pos);\n            col = vec3(0.5, 0.45, 0.35) + n;\n            float s = smoothstep(1.0, 0.0, pos.y - 14.0);\n            col = mix(col + 0.01, mix(col, texture(iChannel0, 0.125 * pos.xz).xyz, 0.05), s);\n            col = mix(col, mix(col - 0.035, col, smoothstep(0.025, 0.06, mod(1.8 * pos.x + n * 2.0, 2.0))), s);\n            if (pos.y > 13.5 && pos.y < 14.5)\n            {\n                col = vec3(0.5, 0.45, 0.35) - 0.04 + n;\n            }          \n        }\n        else if (id == ID_BASEBOARD_XY)\n        {\n            float n = 0.075 * fBm3d(1.5 * pos);\n            col = mix(vec3(0.4, 0.35, 0.3), texture(iChannel0, (0.5 * pos.xy) + n).xyz, 0.4);\n        }\n        else if (id == ID_BASEBOARD_YZ)\n        {\n            float n = 0.075 * fBm3d(1.5 * pos);\n            col = mix(vec3(0.4, 0.35, 0.3), texture(iChannel0, (0.5 * pos.zy) + n).xyz, 0.4);\n        }\n        else if (id == ID_CARPET_B)\n        {\n            col = vec3(0.45, 0.4, 0.35);\n            col = mix(col, texture(iChannel0, 0.125 * pos.xz).xyz, 0.2);\n        }        \n        else if (id == ID_CARPET)\n        {\n            float n = 0.5 * fBm3d(0.25 * pos);\n            col = vec3(0.45, 0.4, 0.35) - n * 0.15;\n            nor = normalize(nor - 0.5 * getBump(256.0 * pos, 0.1));\n            col -= 0.05 * mod(floor(0.25 * (-pos.x + pos.z) + n), 2.0);           \n        }\n        else if (id == ID_TV_0)\n        {\n            float n = 0.075 * fBm3d(1.5 * pos);\n            col = vec3(0.2, 0.16, 0.1) - n;\n            col = mix(col, texture(iChannel0, (0.1875 * pos.yz)).xyz, 0.25);\n        }\n        else if (id == ID_TV_1)\n        {\n            float n = 0.075 * fBm3d(1.5 * pos);\n            col = vec3(0.2, 0.16, 0.1) - n;\n            col = mix(col, texture(iChannel0, (0.1875 * pos.yx)).xyz, 0.25);\n        }\n        else if (id == ID_TV_2)\n        {\n            col = vec3(0.0);\n            col = mix(col, 0.25 * texture(iChannel1, pos.yz).xyz, 0.8);\n            col = mix(vec3(0.2), col, smoothstep(0.0, 0.15, mod(8.0 * (pos.z + 0.25), 2.0)));\n        }\n        else if (id == ID_TV_3 || id == ID_TV_5 || id == ID_TV_7)\n        {\n            col = vec3(0.5, 0.4, 0.3);\n        }\n        else if (id == ID_TV_4)\n        {\n            col = texture(iChannel2, vec2(0.22, 0.3) * (pos.zy + vec2(8.25, -5.6))).xyz;\n            col = pow(clamp(col, 0.0, 1.0), vec3(1.8));\n        }\n        else if (id == ID_TV_6)\n        {\n            col = vec3(0.1);\n        }\n        else if (id == ID_CHAIR_0)\n        {\n            float n = 0.05 * fBm3d(1.5 * pos);\n            col = vec3(0.2, 0.16, 0.1) - n;\n            col = mix(col, texture(iChannel0, (0.1875 * pos.yx) + n).xyz, 0.25);\n        }\n        else if (id == ID_CHAIR_1)\n        {\n            float n = 0.15 * fBm3d(1.5 * pos);\n            col = vec3(0.6, 0.5, 0.4) + n;\n            col -= 0.25 * mod(floor(4.0 * (pos.x + pos.z)), 2.0);\n            nor = normalize(nor - 0.05 * getBump(256.0 * pos, 0.1));\n        }\n\n        float occ = clamp(raymarchAO(pos, nor, tmin), 0.0, 1.0);\n        col *= occ;\n\n        // tv light\n        vec3 lightPos = vec3(-17.0, 7.25, -6.0);\n        vec3 lDir = normalize(lightPos - pos);\n        float lDist = length(lightPos - pos);\n        float tvLight = 0.0 + max(0.0, dot(nor, lDir));\n        vec3 lightColor = 1.25 * vec3(0.15, 0.2, 0.25);\n        vec3 speColor = vec3(0.0);\n        \n        if (id != ID_TV_0 && id != ID_TV_1 && id != ID_TV_2 && id != ID_TV_3\n         && id != ID_TV_5 && id != ID_TV_6 && id != ID_TV_7\n         && id != ID_CHAIR_0 && id != ID_CHAIR_1)\n        {       \n            tvLight = smoothstep(0.0, 3.0, pos.x + 11.0);\n        }\n        if ((iChannelTime[2] > 28.25 && iChannelTime[2] < 29.5) ||\n            (iChannelTime[2] > 17.0 && iChannelTime[2] < 17.1) ||\n            (iChannelTime[2] >= 0.0 && iChannelTime[2] < 0.1))\n            tvLight *= 0.5;\n\n        if (id == ID_CHAIR_0 || id == ID_CHAIR_1)\n        {\n            tvLight *= 6.0;\n        }\n        else if (id == ID_TV_3 || id == ID_TV_5 || id == ID_TV_6 || id == ID_TV_7)\n        {\n            vec3 h = normalize(-rd + lDir);\n            float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 16.0);\n            speColor = vec3(4.0 * spe * tvLight);\n        }\n\n        lightColor += tvLight * vec3(0.5) * (10.0 / lDist);\n\n        if (id != ID_TV_4)\n            col *= lightColor + speColor;\n\n        if (!toggleKey(KEY_C)) {\n            col = vec3(dot(col, vec3(0.2126, 0.7152, 0.0722)));\n        }\n        \n    }\n\n    // vignetting\n    vec2 q = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    col *= 1.0 - 0.5 * pow(length(q * q * q), 2.0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl23Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl23zm", "name": "AO Morph", "author": "purton", "description": "Testing distance functions with simple ambient occlusion.", "tags": ["3d", "raymarching", "distance", "occlusion", "ambient", "functions"], "likes": 3, "viewed": 279, "date": "1427919180", "time_retrieved": "2024-06-20T18:19:59.524580", "image_code": "#define MAXT 10.0\n\nfloat map(in vec3 pos)\n{\n    float circle = length(pos) - 2.0 + cos((pos.x + pos.y) * 15.0) * 0.05;\n    float negCircle = length(pos) - 1.4;\n    float cube = length(max(abs(pos) - 1.0, 0.0)) - 0.05;\n    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0 + cos(pos.x * 20.0) * 0.05;\n    float ceiling = dot(pos, vec3(0.0, -1.0, 0.0)) + 3.0 + 1.0 + cos(pos.z * 20.0) * 0.05;\n    \n    float shape = mix(circle, cube, 0.5 + 0.5 * cos(iTime));\n    shape = max(-negCircle, shape);\n    return min(shape, min(ground, ceiling));\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n    vec3 p = vec3(0.0);\n    float t = 0.0;\n    \n    for(int i = 0; i < 64; i++)\n    {\n        p = ro + rd*t;\n        float dist = map(p);\n        \n        if (dist < 0.0 || t > MAXT)\n            break;\n        \n        t += max(dist * 0.8, 0.001);\n    }\n    \n    return p;\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.1;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos);\n    return clamp(sdist / dist, 0.5, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(p.x, p.y, 0.5));\n    \n    vec3 hitp = castRay(ro, rd);\n    vec3 normal = getNormal(hitp);\n    float ao = getAO(hitp, normal);\n    float ndist = distance(ro, hitp) / MAXT;\n    \n    fragColor = vec4(1.0) * ao - ndist;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl23zm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl2GDm", "name": "Squircles go to the disco!", "author": "gouky", "description": "Not the cleanest code ever... ** Not for epileptic! **\n\n#TeamSquircle \n", "tags": ["lighting", "disco", "squircle"], "likes": 16, "viewed": 1397, "date": "1429613478", "time_retrieved": "2024-06-20T18:20:00.833328", "image_code": "//\n// #TeamSquircle\n//\n#define PI\t\t\t\t3.1415926535\n#define STEP_COUNT\t\t16\n#define EPS\t\t\t\t0.01\n\n#define ROTATE_LIGHT\t\t\t1\n#define DANCING_SQUIRCLES\t\t1\n\n// Smoke noise based on https://www.shadertoy.com/view/Mlj3W1\n#define ENABLE_SMOKE\t1\t// Change me!Change me!Change me!Change me!\n\nstruct\tSquircle\n{\n    vec3\tcolor;\n    float\td;\n    vec2\tuv;\n};\n\n#define SMOKE_MAX_STEPS  8\n#define SMOKE_MIN_STEP  0.010\n    \n// noise from iq's hell shader\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\n///////////////////////////////\nfloat NoiseSample(vec3 orp)\n{\n    float t = iTime * 0.01;\n    float m = 0.0;\n    \n    vec3 uv = orp + vec3(t, 0.0, 0.0);\n    float n = noise(uv * 10.0) - 0.5;\n\n    uv = orp + vec3(t * 0.2, 0.0, 0.0);\n    n += noise(uv * 22.50) * 0.5;\n\n    uv = orp + vec3(t * 1.0, 0.0, 0.0);\n    n += noise(uv * 52.50) * 0.5;\n\n    uv = orp + vec3(t * 1.8, 0.0, 0.0);\n    n += noise(uv * 152.50) * 0.25;\n\n    return n;\n}\n\nfloat Smoke(in vec3 ro, in vec3 rd)\n{\n    vec3 rp = ro;\n    float smoke = 0.0;\n    \n    for (int i = 0; i < SMOKE_MAX_STEPS; ++i)\n    {\n        rp += rd * max(SMOKE_MIN_STEP, 0.0);\n        float h = NoiseSample(vec3(rp.xy, float(i)*1.5));\n        \n        smoke += abs(h);\n    }\n    \n    smoke /= float(SMOKE_MAX_STEPS+1);\n    \n    return smoke;\n}\n\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nSquircle\tcheck(Squircle x, Squircle y)\n{\n    if(x.d <= y.d)\n        return x;\n    \n    return y;\n    //return x.d <= y.d ? x : y;\n}\n\nSquircle f(vec2 p, vec2 centre, float mult, float radius, float bias, float fft)\n{\n    Squircle ret;\n    \n    ret.color = vec3(1.0, 0.0, 1.0);\n    \n    float cosTheta = cos(iTime);\n    float sinTheta = sin(iTime);\n    \n    vec2 ab = p-centre;\n    \n    vec2 rotatedPos = vec2(ab.x * cosTheta - ab.y * sinTheta, ab.x * sinTheta + ab.y * cosTheta);\n    ab = rotatedPos;\n    \n#if DANCING_SQUIRCLES == 0\n    float power = 0.5 + 2.0*(1.0+sin(iTime+bias));\n#else\n    float power = 0.5 + 0.90*(sin((fft * (30.0+bias))+2.0)*0.5+0.5);\n#endif\n    \n    float dist = pow(abs(ab.x),power) + pow(abs(ab.y),power);\n   \n    ret.d = dist < pow(radius,power) ? EPS : 1.0;\n    ret.uv = vec2(\n            (abs(ab.x+radius) / radius*0.5),\n            (abs(ab.y+radius) / radius*0.5));\n   \t    \n    return ret;\n}\n\nSquircle SampleScene(in vec2 uv, in float fft)\n{\n    Squircle r;\n    \n    r.d = 100.0;\n    \n    vec2 pos;\n    \n    pos.x = cos(iTime)*0.5;\n    pos.y = sin(iTime)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 0.0, fft));\n\n    pos.x = cos(iTime+PI/2.0)*0.5;\n    pos.y = sin(iTime+PI/2.0)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 0.5, fft));\n   \n    pos.x = cos(iTime+PI)*0.5;\n    pos.y = sin(iTime+PI)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 1.0, fft));\n      \n    pos.x = cos(iTime-PI/2.0)*0.5;\n    pos.y = sin(iTime-PI/2.0)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 1.5, fft));\n   \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tvec3 color = vec3(0.0);\n    vec2 pos = vec2(0.0,0.0);\n    \n    float cosTheta = cos(iTime);\n    float sinTheta = sin(iTime);\n           \n\tfloat smoke = 1.0;\n\n#if ENABLE_SMOKE == 1\n    smoke = Smoke(vec3(0.0, 0.0, -1.1), vec3(uv, 1.0)) * 1.5;\n#endif\n    \n    //\t\n    float freqs = 0.0;\n\n    float weights[5];\n    weights[0] = 0.4;\n    weights[1] = 0.1;\n    weights[2] = 0.2;\n    weights[3] = 0.2;\n    weights[4] = 0.2;\n\n    //\tdirty approx.\n    freqs += texture( iChannel0, vec2( 0.01, 0.25 ) ).x * weights[0];\t\t// 0.01\n    freqs += texture( iChannel0, vec2( 0.25, 0.25 ) ).x * weights[1];\t\t// 0.07\n    freqs += texture( iChannel0, vec2( 0.50, 0.25 ) ).x * weights[2];\t\t// 0.15\n    freqs += texture( iChannel0, vec2( 0.75, 0.25 ) ).x * weights[3];\t\t// 0.30\n    freqs += texture( iChannel0, vec2( 0.99, 0.25 ) ).x * weights[4];\t\t// 0.30\n\n    float fft = freqs;///5.0;\n    fft += 0.5;\n\n    //\tScene\n    Squircle scene = SampleScene(uv, fft);    \n    \n    //\tlights\n    {\n        vec4 lightColor[5];\n    \tvec2 lightPos[5];\n        \n        lightPos[0] \t= vec2(0.0, 0.0);\n        lightPos[1] \t= vec2(1.0, 0.0);\n        lightPos[2] \t= vec2(-1.0, 0.0);\n        lightPos[3] \t= vec2(0.0, 1.0);\n        lightPos[4] \t= vec2(0.0,-1.0);\n        lightColor[0] \t= vec4(1.0, 0.2, 0.4, 0.1); \t//\t2.0\n        lightColor[1] \t= vec4(1.0, 1.0, 0.5, 0.5);\t\t//\t0.0\n        lightColor[2] \t= vec4(0.2, 1.0, 1.0, 0.5);\t\t//\t0.5\n        lightColor[3] \t= vec4(1.0, 0.2, 1.0, 1.2);\t\t//\t1.5\n        lightColor[4] \t= vec4(0.2, 1.0, 0.2, 1.2);\t\t//\t1.0\n\n#if ROTATE_LIGHT == 1        \n        lightPos[1].y = cos(iTime);\n        lightPos[1].x = sin(iTime);\n        lightPos[2].y = -cos(iTime);\n        lightPos[2].x = -sin(iTime);\n\t\tlightPos[3].y = -cos(PI*0.5+iTime);\n        lightPos[3].x = -sin(PI*0.5+iTime);\n\t\tlightPos[4].y = cos(PI*0.5+iTime);\n        lightPos[4].x = sin(PI*0.5+iTime);        \n#endif\n        \n        color = vec3(0.0);\n        for(int i = 0; i < 5; ++i)\n        {\n            vec2 rayOrigin = vec2(uv);\n            vec2 ray = lightPos[i] - rayOrigin;\n            float rayLength = length(ray);\n            vec2 rayDir = ray / rayLength;\n\n            float raySteps = rayLength / float(STEP_COUNT);\n\n            float acc = 0.0;\n            float t = 0.0;\n            float offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iTime);\n\n            for(int stepIndex = 0; stepIndex < STEP_COUNT; stepIndex++)\n            {\n                vec2 P = rayOrigin + rayDir * (t + offset * 0.1);\n                float d = SampleScene(P, fft).d;\n\n                if(d <= EPS) \n                {\n                    acc += 1.0;\n                }\n\n                t += raySteps;\n            }\n\n            acc = acc/float(STEP_COUNT);\n            acc = clamp(1.0-acc, 0.0, 1.0);\n\n#if ENABLE_SMOKE == 1\n            smoke = scene.d <= EPS ? 1.0 : smoke * acc;\n#endif            \n            \n            const float maxAtten = 0.22;\t\t//0.2\n            \n            float attenDist = max(clamp(maxAtten*(sin((fft * 20.0)+lightColor[i].w)*0.5+0.5), 0.0, maxAtten), 0.01);\n            attenDist = i == 0 ? max(attenDist, 0.1) : attenDist;\n            float atten = (rayLength/attenDist);\n            \n            acc = acc / atten;\n\n            color += vec3(acc) * lightColor[i].xyz * smoke;// * color;\n        }\n    }\n    \n    // Squircles are the best!   \n    if(scene.d <= EPS)\n    {\n        vec2 squircleUv = scene.uv * 2.0 - 1.0;\n        float gradient = (1.0 - length(squircleUv) * 0.5);\n       \n        vec3 basecolor = mix(vec3(1.0, 0.2, 0.4), vec3(1.0, 1.0, 0.0), cos(iTime));\n        basecolor = color;//vec3(1.0);\n        color = vec3(gradient) * basecolor * 2.0;\n    }\n    \n    fragColor = vec4(color,1.0); \n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl2GDW", "name": "Mirror Box", "author": "purton", "description": "Testing reflections with raymarching.", "tags": ["3d", "raymarching", "shadows", "reflections", "ao"], "likes": 31, "viewed": 1716, "date": "1429723998", "time_retrieved": "2024-06-20T18:20:00.833328", "image_code": "#define REFLECTION_COUNT 4\n\nfloat map(in vec3 pos)\n{\n    float negCircle = length(pos) - 1.37;\n    float cube = length(max(abs(pos) - 0.95, 0.0)) - 0.05;\n    float shape = mix(max(-negCircle, cube), cube, 0.5 + sin(iTime * 0.4) * 0.5);;\n    \n    float roof = dot(pos, vec3(0.0, -1.0, 0.0)) + 2.0 + sin(pos.x * 35.0) * 0.005;\n    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0;\n    float backWall = dot(pos, vec3(0.1, 0.0, -1.0)) + 6.5;\n    float frontWall = dot(pos, vec3(0.1, 0.0, 1.0)) + 6.5;\n    \n    vec3 repeatPos = mod(pos + vec3(0.0, -0.05, 0.0), 2.0) - 0.5 * 2.0;\n    float pillars = length(max(abs(repeatPos) - 0.15, 0.0)) - 0.05;\n    pillars = max(-(dot(pos, vec3(0.0, -1.0, 0.0)) + 0.5), pillars);\n    \n    return min(min(min(min(min(shape, roof), ground), backWall), frontWall), pillars);\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd, in float mint, in float maxt)\n{\n    float t = mint;\n    \n    for (int i = 0; i < 96; i++)\n    {\n        vec3 p = ro + rd*t;\n        float dist = map(p);\n        \n        if (dist <= 0.0 || t > maxt)\n            break;\n        \n        t += max(dist, 0.0001);\n    }\n    \n    return ro + rd*min(t, maxt);\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 normal = vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx));\n    return normalize(normal);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.02;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos);\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec4 shade(in vec3 hitp, in vec3 normal, in vec3 rd, in vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - hitp);\n    vec3 lightHit = castRay(hitp, lightDir, 0.01, distance(hitp, lightPos));\n    \n    float ao = getAO(hitp, normal);\n    float shadow = pow(distance(hitp, lightHit) / distance(hitp, lightPos), 64.0);\n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float attenuation = 1.0 / pow(distance(hitp, lightPos), 2.0);\n    float specular = pow(clamp(dot(normalize(lightDir - rd), normal), 0.0, 1.0), 64.0);\n    \n    vec4 diffuseColor = vec4(1.0) * diffuse * attenuation;\n    vec4 specularColor = vec4(1.0) * specular * diffuse * attenuation;\n    \n    return (diffuseColor + specularColor) * min(ao, shadow);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0.1 * cos(iTime * 0.4), 0.05 * sin(iTime * 0.25), -3.0);\n    vec3 rd = normalize(vec3(p.x, p.y, 0.75));\n    vec3 lightPos = vec3(cos(iTime * 0.1) * 3.0, 0.0, sin(iTime * 0.4) * 3.0);\n    \n    vec3 hitp = castRay(ro, rd, 1.0, 32.0);\n    vec3 normal = getNormal(hitp);\n    \n    vec4 color = vec4(0.0);\n    float refMult = 1.0;\n    color += shade(hitp, normal, rd, lightPos);\n    \n    for (int i = 0; i < REFLECTION_COUNT; i++)\n    {\n        refMult *= 0.75;\n        vec3 refDir = reflect(rd, normal);\n        vec3 refHitp = castRay(hitp, refDir, 0.01, 32.0);\n        vec3 refNormal = getNormal(refHitp);\n        color += shade(refHitp, refNormal, refDir, lightPos) * refMult;\n        \n        rd = refDir;\n        hitp = refHitp;\n        normal = refNormal;\n    }\n    \n    fragColor = sqrt(color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl2GWw", "name": "_rayMarcher_cr_DE", "author": "foad1989", "description": "rm_cr_DE", "tags": ["rmcrde"], "likes": 0, "viewed": 93, "date": "1429533160", "time_retrieved": "2024-06-20T18:20:01.948795", "image_code": "#define degToRad(x) x * pi * inv_180\n#define prec 0.0001\n#define epsilon vec3(0.0, prec, 0.0)\n// #define CRUDE\nconst float pi = 3.14159265359;\nconst float inv_pi = 0.31830988618;\nconst float inv_180 = 0.00555555555;\nconst int sierp_iters = 10;\n\nfloat sierp_DE(in vec3 p)\n{\n    vec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = sierp_iters;\n    float alpha = 0.5 * iTime;\n    //float alpha = 0.25 * pi;\n\tfloat dist, d;\n    \n    for(int i = 0; i < sierp_iters; i++)\n    {\n        c = a1; dist = length(p-a1);\n\t    d = length(p-a2); if (d < dist) { c = a2; dist=d; }\n\t\td = length(p-a3); if (d < dist) { c = a3; dist=d; }\n\t\td = length(p-a4); if (d < dist) { c = a4; dist=d; }\n        p = p - c;\n        //p.x = p.x * cos(alpha) - p.y * sin(alpha);\n        //p.y = p.y * cos(alpha) + p.x * sin(alpha);\n        p = 2.0*p-c;        \n\t}\n\treturn length(p) * pow(2.0, float(-n));\n}\nfloat sierp_fold_DE(vec3 z)\n{\n    float r;\n    for(int i = 0; i < sierp_iters; i++) {\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*2.0 - 1.;\n    }\n    return (length(z)) * pow(2.0, float(-sierp_iters));\n}\n/*float menger_DE(inv vec3 p)\n{\n    \n}*/\n\nfloat unsigned_box_DE(in vec3 p)\n{\n    vec3 abc = vec3(1.0, 1.0, 1.0);\n\treturn length(max(abs(p) - abc, 0.0));\n}\n\nfloat signed_box_DE(in vec3 p)\n{\n    vec3 abc = vec3(1.0, 1.0, 1.0);\n    vec3 d = p - abc;\n    return min(max(max(d.x, d.y), d.z), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere_DE(in vec3 p) \n{\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    float r = 0.2 + 0.25 * (sin(5.0 * iTime) + 1.0);\n    //float r = 1.0;\n    return length(p - pos) - r;\n}\n\nfloat instance_DE(vec3 p)\n{\n    p.xz = mod(p.xz, 2.0) - vec2(1.0);\n  \treturn sphere_DE(p);\n    //return sierp_DE(p);\n}\n\n\nfloat DE_selector(in vec3 p) \n{\n   \t//return sphere_DE(p);\n    //return box_DE(p);\n    //return sierp_DE(p);\n    return instance_DE(p);\n    //return sierp_fold_DE(p);\n}\n\nvec3 grad_at_p(in vec3 p) {\n    // when calculating de partials we don't devide by 'espsilon' since we \n    // normalize the gradient vector and therefore it has no effect >>> vec3(1/h * (dx, dy, dz)) == vec3(dx, dy, dz)\n\tfloat dx = DE_selector(p + epsilon.yxx) - DE_selector(p - epsilon.yxx);\n    float dy = DE_selector(p + epsilon.xyx) - DE_selector(p - epsilon.xyx);\n    float dz = DE_selector(p + epsilon.xxy) - DE_selector(p - epsilon.xxy);\n    return normalize(vec3(dx, dy, dz));\n}\n\nconst float THRESHOLD = 0.001;\nconst float max_dist = 50.0;\nconst int max_iters = 256;\nvec3 rm(in vec3 ro, in vec3 rd, out bool hit)\n{\n    vec3 p;\n    float distGone = 0.0;\n    for(int i = 0; i < max_iters; i++)\n    {\n        p = ro + rd * distGone;\n        float dist = DE_selector(p);\n        if(abs(dist) <= THRESHOLD || distGone > max_dist)\n            break;\n        distGone += dist;\n    }\n    if(distGone < max_dist) {\n        hit = true;\n        return p;\n    } else {\n        hit = false;\n    \treturn vec3(0.0);\n    }\n}\n\nvec3 rm_crude(in vec3 ro, in vec3 rd, out bool hit) \n{\n    vec3 p;\n\tfloat stepSize = 0.001;\n    float distGone = 0.0;\n    for(int i = 0; i < max_iters; i++)\n    {\n       \tp = ro + rd * distGone;\n        float dist = DE_selector(p);\n        if(dist <= 0.0) {\n         \thit = true;\n            return p;\n        }\n       \tdistGone += stepSize;\n    }\n    hit = false;\n    return vec3(0.0);\n}\n\nfloat kd = 0.5;\nfloat ka = 0.3;\nfloat ks = 1.5;\nvec3 cd = vec3(0.3, 0.1, 0.4);\nvec3 ambient_brdf_rho = ka * cd;\nvec3 diffuse_brdf_f = kd * cd * pi;\nvec3 glossy_brdf_f = ks * cd;\nfloat phong_exp = 100.0;\nvec3 ambient_light_L = vec3(0.1, 1.2, 0.2);\nvec3 directional_light_dir = vec3(0.5773, 0.5773, 0.5773);\nvec3 directional_light_L = vec3(1.5, 1.5, .0);\nvec3 matte(vec3 p, vec3 n) {\n\tvec3 L = ambient_brdf_rho * ambient_light_L;\n    // TODO: for loop many light\n    float ndotwi = dot(n, -directional_light_dir);\n    if(ndotwi > 0.0)\n    {  \n        L += diffuse_brdf_f * directional_light_L * ndotwi;\n    }\n    return L;\n}\n\nvec3 phong(vec3 p, vec3 n, vec3 ro) {\n\tvec3 L = ambient_brdf_rho * ambient_light_L;\n    // TODO: for loop many light\n    vec3 wi = -directional_light_dir;\n    vec3 wo = -ro;\n    float ndotwi = dot(n, wi);\n    if(ndotwi > 0.0)\n    {\n        vec3 r = -wi + 2.0 * n * dot(n, wi);\n        glossy_brdf_f *= pow(max(0.0, dot(r, wo)), phong_exp);\n        L += (diffuse_brdf_f + glossy_brdf_f) * directional_light_L * ndotwi;\n    }\n    return L;\n}\n\nvec3 compute_color(in vec3 ro, in vec3 rd) \n{\n    bool hit = false;\n    vec3 hitPt;\n#ifdef CRUDE\n    hitPt = rm_crude(ro, rd, hit);\n#else\n    hitPt = rm(ro, rd, hit);\n#endif\n    // return hit ? grad_at_p(hitPt) : vec3(0.0);\n    // return hit ? vec3(1.0) : vec3(0.0);\n    // return hit ? matte(hitPt, grad_at_p(hitPt)) : vec3(0.0);\n    return hit ? phong(hitPt, grad_at_p(hitPt), rd) : vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // complete camera system(ortho and pers)\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    // vec3 lookat = vec3(0.0, 0.0, 4.0);\n    // vec3 eye = vec3(0.0, 5.0, 3.0);\n    float roll = degToRad(-20. * iTime);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    // GLSL stores in column major\n    mat2 rot = mat2(cos(roll), sin(roll), -sin(roll), cos(roll));\n    up = vec3(rot * up.xy, 0.0);\n    vec3 eye = vec3(2.0 * cos(iTime), 0.0, 2.0 * sin(iTime));\n    // vec3 eye = vec3(0.0, 2.0, 10.0 * iTime);\n    // vec3 eye = vec3(2.0, 0.0, 2.0);\n    vec3 w = normalize(eye - lookat);\n    vec3 u = normalize(cross(up, w));\n \tvec3 v = normalize(cross(w, u));\n    vec2 scale = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 onpln = (uv - vec2(0.5, 0.5)) * scale;\n    // pixel size\n    float psize = 1.0;\n    // distance from view plane\n    float camDistPln = 1.0; \n    vec3 p_ortho = vec3(onpln * psize, camDistPln);\n    vec3 rd_ortho = -w;\n    vec3 rd_pers = normalize(-camDistPln * w + psize * onpln.x * u + psize * onpln.y * v);\n    vec3 color = compute_color(eye, rd_pers);\n    //vec3 color = compute_color(p_ortho, rd_ortho);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlB3Dw", "name": "Squircle 3D", "author": "dys129", "description": "Take it to another dimension squircle in 3D - because we can! Credits go to all shadertoy community!", "tags": ["squircle"], "likes": 2, "viewed": 1157, "date": "1429289576", "time_retrieved": "2024-06-20T18:20:01.948795", "image_code": "//\n// #TeamSquircle\n//\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\n\nvec3 rotateX(vec3 v, float a)\n{\n    return vec3(v.x ,\n                v.y * cos(a) + v.z * sin(a),\n                -v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotateY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a),\n                v.y,\n                -v.x * sin(a) + v.z * cos(a));\n}\n\nvec3 rotateZ(vec3 v, float a)\n{\n \treturn vec3(v.x * cos(a) + v.y * sin(a),\n                v.x * -sin(a) + v.y * cos(a),\n                v.z);\n}\n\nfloat plane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(vec3 ro, float r)\n{\n return length(ro) - r;   \n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\n\nbool IntersectBox(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, out float t0, out float t1)\n{\n    vec3 invR = 1.0 / rd;\n    vec3 tbot = invR * (bmin-ro);\n    vec3 ttop = invR * (bmax-ro);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    return t0 <= t1;\n}\n\nfloat sphercile(vec3 ro, float r, float power)\n{\n\treturn pow( abs(ro.x), power) + pow( abs(ro.y), power) + pow( abs(ro.z), power) - r;\n}\n\nfloat selipse(vec3 ro, float e, float n)\n{\n \tfloat r = 2.0 / e;\n    float t = 2.0 / n;\n    \n    float inside =  pow(pow(abs(ro.x), r) + pow(abs(ro.y), r), t/r) + pow(abs(ro.z),t);\n    return inside - 1.0;\n}\n\nvec3 selipse_nrm(vec3 ro, float e, float n)\n{\n    float r = 2.0 / e;\n    float t = 2.0 / n;\n    \n    float xr = pow(abs(ro.x), r);\n    float yr = pow(abs(ro.y), r);\n    float zt = pow(abs(ro.z), t);\n \treturn vec3(t*xr * pow((xr + yr), t/r-1.0)/ro.x,\n                t*yr * pow((xr + yr), t/r-1.0)/ro.y,\n                t*zt/abs(ro.z));\n}\n\nvec4 map( vec3 p )\n{\n\n    vec3 cc = vec3(2.3);\n\tvec3 q = mod(p, cc) - 0.5 * cc;\n    p = q;\n    float d = box(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n \tfloat s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\n\nvec3 fog_clr = vec3(0.3,0.1,0.2);\nvec3 applyFog(vec3 clr, vec3 rd)\n{\n    \n    float fog = 1.0 - exp(-length(rd) * 0.05);\n    clr.rgb = mix(clr.rgb, fog_clr, fog);\n    return clr;\n}\n\nvec2 scene(vec3 ro)\n{\n\n    float time = iTime;\n    float tt = 1.0 + abs(sin(time * 1.5))*3.0;\n \tvec3 ppp = ro + vec3(0,-1,0);\n    ppp = rotateY(ppp, iTime * 2.0);\n    vec2 sp0 = vec2(sphercile(ppp, 1.0, 1.0), 0.0);\n    vec2 pl0 = vec2(plane(ro), 1.0);\n    vec2 sa0 = vec2(selipse(ppp, 2.0, 2.0), 0.0);\n    float rad = 3.5;\n    vec3 ccc = vec3(0.0, 0.0, 2.0*rad + 0.5);\n    vec3 qqq = mod(ro - vec3(0.0,0.0,rad), ccc) - 0.5 * ccc;\n    float sph = sphere(qqq, rad);\n    float cb = map(ro).x;\n    float r = max(cb, -sph);\n    return vec2(r, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat shadow( vec3 ro, vec3 rd)\n{\n\tfloat t = 0.02;\n    float res = 1.0;\n    for(int i=0;i<16;i++)\n    {\n    \tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001) break;    \n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat freqs[4];\n\nvec3 lighting(vec3 pos, vec3 rd, vec3 nrm, float mid)\n{\n    vec3 lpos = vec3(0.6, 0.7, 0.80);\n    vec3  lig = normalize( lpos );\n    float ndl = clamp( dot( nrm, lig ), 0.0, 1.0 );\n\t\n\tfloat bac = clamp( dot( nrm, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n    \n    \n    vec3 clr = vec3(0.0);\n    clr += ndl*vec3(0.70,0.12,0.30);\n    clr += bac*vec3(0.40,0.18,0.20);\n    clr += 0.5 * clamp( dot(nrm,normalize(-pos)), 0.0, 1.0) * vec3(0.3,0.4,0.3);\n    float off = texture( iChannel1, vec2( atan(pos.z, pos.x) * 0.15 * 0.5 + 0.5, 0.25 ) ).x * 1.0 - 0.5;\n    float ns = noise(pos.xz + iTime * 1.2);\n    float p0 = clamp(1.0 - abs(pos.y*20.0 + /*mod(iTime * 50.0, 150.0) - 75.0*/ + ns * 35.0 + (freqs[3] + freqs[2] * 40.0)), 0.0,1.0);\n    float p1 = clamp(1.0 - abs(pos.y*20.0 + /*mod(iTime * 50.0, 150.0) - 75.0*/ + off * 55.0), 0.0,1.0);\n    float bit1 = mix(0.4, 5.0, clamp( (freqs[0] - 0.95) * 20.0, 0.0, 1.0));\n    float bit2 = freqs[3] + freqs[2];//mix(0.2, 10.0, clamp( (freqs[2] - 0.5) * 1.0 / 0.5, 0.0, 1.0));\n   // clr.rgb += vec3(p0) * 2.0 * mix(vec3(0.6,0.6,0.2), vec3(0.6,0.2,0.9), bit1);\n    clr.rgb += vec3(p1) * 2.0 * mix(vec3(1.0,0.0,0.0), vec3(0.2, 0.9,0.1), bit2 );\n    clr.rgb *= calcAO(pos + 0.01 * nrm, nrm);\n    return clr;\n}\n\n#define NUM_STEPS 64\n\nvec4 rayMarchSpheroid(vec3 ro, vec3 rd, out float tk)\n{\n   float t0, t1;\n\tbool box_hit = IntersectBox(ro, rd, vec3(-1,-1,-1), vec3(1,1,1), t0, t1); \n    \n    if(!box_hit)\n        return vec4(0.0);\n    \n    \n\tfloat E = sin(iTime * 0.8) * 1.5 + 1.6;\n    float N = 1.6 + sin(iTime * 0.7) * 1.5;\n    float t = t0;\n    vec4 clr = vec4(0.0);\n    float dt = (t1 - t0) / float(NUM_STEPS);\n    \n    for(int i =0; i<NUM_STEPS; i++)\n    {\n        float hit = selipse(ro+t*rd, E, N);\n        float eps = 0.001;\n        \n        if(hit < eps)\n        {\n            float resT = t - 0.5 * dt;\n        \tvec3 pos = ro + resT*rd;        \t\n            vec3 nrm = normalize(selipse_nrm(pos, E, N));\n            vec3 rfl = reflect( rd, nrm );\n            vec3  lig = normalize( vec3(0.6, 0.7, 0.5) );\n            \n            vec3 ppp = pos;\n            clr.rgb = vec3(0.0);\n            float rt = 1.0;\n            vec3 rfl_clr = vec3(0.0);\n            for(int j = 0; j < 10; j++)\n            {\n                \n            \tvec2 rhit = scene(pos + rt * rfl); \n                if(rhit.x < 0.001)\n                {\n                 vec3 rpos = pos + rt * rfl;\n                 vec3 rnrm = calcNormal(rpos);   \n                 rfl_clr = lighting(rpos, rfl, rnrm, 0.0);   \n                   break;\n                }\n                \n                rt += max(rhit.x, 0.001);\n            }\n            clr.rgb += rfl_clr * 0.6;\n            clr.rgb += max(dot(lig, nrm), 0.0) * vec3(0.4,0.5,0.6)* 0.3;\n            clr.rgb = applyFog(clr.rgb, t*rd);\n            clr.w = 1.0;\n            break;\n        }                \n        t += dt;\n    }\n    tk = t;\n    return clr;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.50, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.80, 0.25 ) ).x;\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\n    \n    float k = 3.0;\n \tvec3 ro = vec3(sin(iTime * 0.4) * 4.3, 0.1 + 0.0 * sin(iTime*0.4), cos(iTime * 0.4) * 3.1);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    float t = 0.0;\n    vec4 clr = vec4(0.0, 0.0, 0.0, 1.0);\n    clr.rgb = fog_clr;\n    for(int i =0; i<64; i++)\n    {\n        vec2 hit = scene(ro+t*rd);\n        float eps = 0.001;\n        float dt = 0.01;\n        if(hit.x < eps)\n        {\n        \tvec3 pos = ro + t*rd;\n        \tvec3 nrm = calcNormal( pos );\n        \tvec3 rfl = reflect( rd, nrm );\n            clr.rgb = lighting(pos, rd, nrm, 0.0); \n            \n            clr.rgb = applyFog(clr.rgb, t*rd);\n    \n            break;\n        }\n        \n        t += max(hit.x, 0.001);\n    }\n    float kt = 1000.0;\n    vec4 sph = rayMarchSpheroid(ro, rd, kt);\n    clr.rgb = mix(clr.rgb, sph.rgb, sph.a * float(k < t));\n\n\tfragColor = clr;\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3Dw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlB3RV", "name": "Funky Spiral", "author": "anastadunbar", "description": "Another spiral I've been working on GLSL sandbox.", "tags": ["spiral", "rainbow"], "likes": 3, "viewed": 292, "date": "1430234298", "time_retrieved": "2024-06-20T18:20:01.948795", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat pi = 3.141592653589;\n\tfloat time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 gradient = vec4(uv.x,(sin((time/2.)+uv.y)/2.)+0.5,(sin(time)/2.)+0.5,1.0);\n\tvec2 middle = ((fragCoord.xy)/(iResolution.xy)-0.5);\n\tfloat a1 = length(uv - vec2(0.5) );\n\tfloat b1 = (atan(middle.x,middle.y)+3.1415925)/6.2831;\n\tfloat c1 = sin(((a1+(b1/3.18))*40.0)+(time*3.0))*10.;\n\tfloat c2 = sin(((a1+(b1/3.18))*40.0)+(time*4.0))*10.;\n\tfloat c3 = sin(((a1+(b1/3.18))*40.0)+(time*5.0))*10.;\n\tfloat d1 = sin(c1*0.2);\n\tfloat d2 = sin(c2*0.25);\n\tfloat d3 = sin(c3*0.2);\n\tvec3 sickspiral = vec3(d1,d2,d3);\n\tfloat uvxs = (uv.x*5.)+time+d1;\n\tvec3 rainbow = vec3(sin(uvxs),sin(uvxs+(pi/2.)),sin(uvxs+pi));\n\tfragColor = vec4(ceil(rainbow/0.2)*0.2, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlB3Wz", "name": "Rainbow soft brush draw ", "author": "klk", "description": "Draw something with rainbow-like color gradient.", "tags": ["rainbow", "soft", "paintbrush"], "likes": 12, "viewed": 2013, "date": "1427935835", "time_retrieved": "2024-06-20T18:20:01.948795", "image_code": "float PI=3.14159265359;\n\nvec3 h2rgb(float h)\n{\n    return clamp(2.0-abs(mod(h*3.0+vec3(0.0,0.0,2.0),3.0)-vec3(2.0,1.0,2.0))*2.0,0.0,1.0);\n}\n\nfloat dp(float i)\n{ \n    i=floor(i);\n    return i*2.0-floor(i/2.0)-floor(i/3.0)*4.0;\n}\n\nfloat dith(vec2 xy)\n{\n    float x=floor(xy.x);\n    float y=floor(xy.y);\n    float v=0.0;\n    float sz=16.0;\n    float mul=1.0;\n    for(int i=0;i<5;i++)\n    {\n    \t\tv+=dp(\n                mod(mod(x/sz,2.0)+2.0*mod(y/sz,2.0),4.0)\n            )*mul;\n        sz/=2.0;\n        mul*=4.0;\n    }\n\treturn float(v)/float(mul-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=iTime;\n    if(t<0.5)\n    {\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    float v=dith(fragCoord.xy);\n    if(abs(fract(t/2.0)*256.0-v*256.0)<4.0)    \n    {\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    v=dith(vec2(fragCoord.x+fragCoord.y*3.0,fragCoord.y-fragCoord.x*3.0)/length(vec2(1,3)));\n    \n    if(length(fragCoord.xy-iMouse.xy)>45.0-v*45.0)\n        discard;\n\tfragColor = vec4(h2rgb(fract(t/5.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlBGDW", "name": "Raymarch Tutorial2", "author": "Daedelus", "description": "Loads of comments in simple framework to explain raymarching to some friends..", "tags": ["raymarchsimpletutorial"], "likes": 33, "viewed": 1445, "date": "1428861950", "time_retrieved": "2024-06-20T18:20:03.100476", "image_code": "/*\na shader executes per pixel\nso every thing you see here is he function for every pixel\n\nraymarching is in principe a function that finds the closest point to any surface in the world\nthen we move our point by that distance and use the same function,\nthe function will probably be closer to an object in the world every time\nand after about 40 to 200 iterations you'll either have found an object or\nmissed them all into infinity\n\nraymarching is not raytracing, a raytracer intersects the world in 1 function\nwhen marching the 'scene' function only computes the distance to the current ray 'position'\nit does not know which direction we are moving, the main loop moves the ray instead\n\nthis is much cheaper because intersection maths are not hardware supported in a GPU\n*/\n\n// these constants are used throughout the shader, \n// they can be altered to avoid glitches or optimize the framerate,\n// their meaning can best be seen in context below\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 40.0\n#define NUMBER_OF_MARCH_STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\nvec2 scene(vec3 position)\n{\n    /*\n\tThis function generates a distance to the given position\n\tThe distance is the closest point in the world to that position\n\t*/\n    // to move the sphere one unit forward, we must subtract that translation from the world position\n    vec3 translate = vec3(0.0, -0.5, 1.0);\n    float distance = sdSphere(position - translate, 0.5);\n\tfloat materialID = 1.0;\n    \n    translate = vec3(0.0, 0.5, 1.0);\n    // A power of raymarching is tiling, we can modify the position in any way we want\n    // leaving the shape as is, creating various results\n    // So let's tile in X with a sine wave offset in Y!\n    vec3 sphere_pos = position - translate;\n    // Because our sphere starts at 0 just tiling it would cut it in half, with\n    // the other half on the other side of the tile. SO instead we offset it by 0.5\n    // then tile it so it stays in tact and then do -0.5 to restore the original position.\n    // When tiling by any tile size, offset your position by half the tile size like this!\n    sphere_pos.x = fract(sphere_pos.x + 0.5) - 0.5; // fract() is mod(v, 1.0) or in mathemathical terms x % 1.0\n    sphere_pos.z = fmod(sphere_pos.z + 1.0, 2.0) - 1.0; // example without fract\n    // now let's animate the height!\n    sphere_pos.y += sin(position.x + iTime) * 0.35; //add time to animate, multiply by samll number to reduce amplitude\n    sphere_pos.y += cos(position.z + iTime);\n    float distance2 = sdSphere(sphere_pos, 0.25);\n\tfloat materialID2 = 2.0; // the second sphere should have another colour\n    \n    // to combine two objects we use the minimum distance\n    if(distance2 < distance)\n    {\n\t\tdistance = distance2;\n        materialID = materialID2;\n    }\n    \n    // we return a vec2 packing the distance and material of the closes object together\n    return vec2(distance, materialID);\n}\n\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    /*\n\tThis function iteratively analyses the scene to approximate the closest ray-hit\n\t*/\n    // We track how far we have moved so we can reconstruct the end-point later\n    float total_distance = NEAR_CLIPPING_PLANE;\n    vec2 result;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        result = scene(position + direction * total_distance);\n        // If our ray is very close to a surface we assume we hit it\n        // and return it's material\n        if(result.x < EPSILON)\n        \tbreak;\n        \n        // Accumulate distance traveled\n        // The result.x contains closest distance to the world\n        // so we can be sure that if we move it that far we will not accidentally\n        // end up inside an object. Due to imprecision we do increase the distance\n        // by slightly less... it avoids normal errors especially.\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity\n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    // By default we return no material and the furthest possible distance\n    // We only reach this point if we didn't get close to a surface during the loop above\n    return vec2(total_distance, result.y);\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Given the pixel X, Y coordinate and the resolution we can get 0-1 UV space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Our rays should shoot left and right, so we move the 0-1 space and make it -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Last we deal with an aspect ratio in the window, to make sure our results are square\n    // we must correct the X coordinate by the stretching of the resolution\n    uv.x *= iResolution.x / iResolution.y;\n    // Now to conver the UV to a ray we need a camera origin, like 0,0,0; and a direction\n    // We can use the -1 to 1 UVs as ray X and Y, then we make sure the direction is length 1.0\n    // by adding a Z component. Code blow is just an example:\n    //float sqr_length = dot(uv, uv);\n    //vec3 direction = vec3(uv, sqrt(1.0 - sqr_length));\n    \n    // a shorter and easier way is to create a vec3 and normalise it, \n    // we can manually change the Z component to change the final FOV; \n    // smaller Z is bigger FOV\n    vec3 direction = normalize(vec3(uv, 2.5));\n    // if you rotate the direction with a rotatin matrix you can turn the camera too!\n    \n    vec3 camera_origin = vec3(0.0, 0.0, -2.5); // you can move the camera here\n    \n    vec2 result = raymarch(camera_origin, direction); // this raymarches the scene\n    \n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = 1.0 - result.x / FAR_CLIPPING_PLANE;\n    \n    // now let's pick a color\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.25, 0.1);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.7, 0.7, 0.7);\n    }\n    \n    // We can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result.x;\n    \n    // The normals can be retrieved in a fast way\n    // by taking samples close to the end-result sample\n    // their resulting distances to the world are used to see how the surface curves in 3D\n    // This math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    // Lambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    // Wrap the lighting around\n    // https://developer.valvesoftware.com/wiki/Half_Lambert\n    diffuse = diffuse * 0.5 + 0.5;\n    // For real diffuse, use this instead (to avoid negative light)\n    //diffuse = max(0.0, diffuse);\n    \n    // Combine ambient light and diffuse lit directional light\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}\n\n/*\nNow that was pretty complex.\nI have omitted transparency and volumetric objects\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlBGWw", "name": "Voronoi Beat", "author": "reuben364", "description": "More voronoi", "tags": ["voronoi"], "likes": 0, "viewed": 116, "date": "1429273035", "time_retrieved": "2024-06-20T18:20:03.403235", "image_code": "#define time (iTime*1000.)\n#define resolution (iResolution.xy)\n\nvec2 random(vec2 x)\n{\n\treturn fract(sin(vec2(dot(x,vec2(127.1,311.7)),dot(x,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvec2 randomCircle(vec2 x, float t) {\n    vec2 randCenter =  random(x+random(vec2(0)));\n    vec2 randRadii = min(randCenter, 1.-randCenter)*random(x+random(vec2(1)));\n    float randSpeed = 2.*length(random(x+random(vec2(2))))-1.;\n    t *= randSpeed;\n    return randCenter+randRadii*vec2(cos(t),sin(t));\n}\n\nvec2 gridClosest(vec2 pos, vec2 prev) {\n    vec2 center = floor(pos);\n    vec2 closest = vec2(2.);\n    for(int i=-1; i<=1; i++)\n        for(int j=-1; j<=1; j++){\n            vec2 point = center+vec2(i,j);\n            point += randomCircle(point, time/1000.);\n            if(prev==vec2(0) || point != prev && length(pos-prev) <= length(pos-point))\n                if(length(pos-point) <= length(pos-closest)) {\n                    closest = point;\n                }\n        }\n    return closest;\n}\n\nfloat voronoi(vec2 pos, vec2 first, vec2 second) {\n   \treturn abs(dot(normalize(first-second),pos-0.5*(first+second)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord/resolution;\n    float sTime = time/10000.;\n    pos-=10.+mix(random(vec2(3)),random(vec2(5)), clamp((sTime-2.)/10.,0.,1.))*sTime ;\n    pos*=5.;\n    vec2 first = gridClosest(pos, vec2(0));\n    vec2 second = gridClosest(pos, first);\n    float vor = voronoi(pos, first, second);\n    float clampDist = abs(min(length(pos-first),1.));\n    vec4 center = .2/clampDist*vec4(1,1,0,1);\n    float borderPulse = 1.-abs(.5-clamp(5.*(fract(sTime)-.8),0.,1.));\n    vec4 border = max(0., 1.-vor)*mix(vec4(1,0,1,1),vec4(1,0,0,1),borderPulse);\n    fragColor = mix(center, border, .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xlj3Ww", "name": "heyx3 Cloud Raymarcher", "author": "heyx3", "description": "Playing around with the idea of raymarching through transparent materials with variable density. Still a WIP.", "tags": ["3d", "raymarching", "clouds"], "likes": 2, "viewed": 179, "date": "1429561357", "time_retrieved": "2024-06-20T18:20:03.403235", "image_code": "//Z axis is height.\n\n\n#define N_ITERATIONS 50\n#define FOG_COLOR vec3(0.8, 0.75, 0.7)\n#define SUN_COLOR vec3(0.9, 0.9, 0.0)\n#define LIGHT_DIR normalize(vec3(1.0, -1.0, -0.4))\n\n\nvec3 getVoroniCenter(vec3 minGridCorner)\n{\n    return mix(minGridCorner, minGridCorner + 1.0,\n               texture(iChannel0, minGridCorner.xy * 454.232 + minGridCorner.z * 35.151).xyz);\n}\nfloat getDensityLayer(vec3 pos)\n{\n    const float gridSize = 0.8;\n    vec3 gridPos = pos / gridSize;\n    \n    vec3 minGridCorner = floor(gridPos);\n    \n    float minDist = 999999.0;\n    for (int x = 0; x < 3; ++x)\n    {\n        for (int y = 0; y < 3; ++y)\n        {\n            for (int z = 0; z < 3; ++z)\n            {\n                vec3 voroniPos = gridSize *\n                    \t\t\t getVoroniCenter(minGridCorner +\n                                                 vec3(float(x - 1), float(y - 1), float(z - 1)));\n                minDist = min(minDist, distance(pos, voroniPos));\n            }\n        }\n\t}\n    \n    const float maxDist = 3.3;\n    float density = clamp(minDist / maxDist, 0.1, 1.0);\n    \n    density *= 1.0 - step(mix(2.5, 4.5,\n                              pow(texture(iChannel0, pos.xy * 0.005 - (pos.z * 0.009 * -fract(iTime * 0.1))).r, 0.3)),\n                          pos.z);\n \n    return density;\n}\nfloat getDensity(vec3 pos)\n{\n    return getDensityLayer(pos * vec3(0.5, 0.5, 1.0));\n}\nvec3 getNormal(vec3 pos)\n{\n    const vec2 epsilon = vec2(0.0, 0.01);\n    \n    float myDensity = getDensity(pos);\n    return normalize(vec3(getDensity(pos + epsilon.yxx) -\n                              getDensity(pos - epsilon.yxx),\n                     \t  getDensity(pos + epsilon.xyx) -\n                              getDensity(pos - epsilon.xyx),\n                     \t  getDensity(pos + epsilon.xxy) -\n                              getDensity(pos - epsilon.xxy)));\n}\n\nfloat colorSurface(vec3 pos, float tLerp)\n{\n    return 1.0;\n    \n    \n    //Calculate lighting.\n    const float ambient = 0.1,\n                diffuse = 1.0 - ambient;\n    float dotted = max(0.0, dot(-LIGHT_DIR, getNormal(pos)));\n    float brightness = ambient + (diffuse * dotted);\n        \n    return brightness;\n}\n\nvec3 colorSky(vec3 dir)\n{\n    float heightLerp = (0.5 + (0.5 * dot(dir, vec3(0.0, 0.0, 1.0)))),\n          sunLerp = pow(0.5 + (0.5 * dot(dir, -LIGHT_DIR)), 64.0);\n    return mix(mix(vec3(0.2), FOG_COLOR, heightLerp),\n               SUN_COLOR,\n               sunLerp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Cam data.\n    const float turnSpeed = 0.01;\n    float moveAmount = (iMouse.y * 0.1) + (iTime * 1.3);\n    vec3 pos = vec3(vec2(moveAmount), 4.8);\n    vec3 forward = normalize(vec3(sin(iMouse.x * turnSpeed), cos(iMouse.x * turnSpeed), -0.5)),\n         up = vec3(0.0, 0.0, 1.0),\n         side = cross(forward, up);\n    \n    //Ray data.\n    vec2 uv = fragCoord / iResolution.xy,\n         screenXY = -1.0 + (2.0 * uv);\n    vec3 start = pos + forward +\n        \t\t (up * screenXY.y) +\n        \t\t (side * screenXY.x * iResolution.x / iResolution.y);\n    vec3 dir = normalize(start - pos);\n    vec3 end = start + dir;\n    \n    //March the ray. Accumlate color as the ray passes through the clouds.\n    float t = 0.0,\n          tIncrement = 0.01;\n    const float tIncrementIncrement = 0.002;\n    fragColor = vec4(colorSky(dir), 1.0);\n    for (int i = 0; i < N_ITERATIONS; ++i)\n    {\n        vec3 rayPos = mix(start, end, t);\n        \n        float density = getDensity(rayPos);\n        fragColor = mix(fragColor,\n                        vec4(1.0),//vec4(colorSurface(rayPos, t)),\n                        pow(density, 2.0));\n        \n        \n        t += tIncrement;\n        tIncrement += tIncrementIncrement;\n    }\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XljGDz", "name": "Protophore", "author": "otaviogood", "description": "I put together this fractal and then watched some tutorials on how to light sports cars for photography. I think the key is to get the giant softbox up top with just the right fade at the edges. I also ray march 1 reflection.", "tags": ["reflection", "raymarch", "lighting"], "likes": 204, "viewed": 11190, "date": "1428379120", "time_retrieved": "2024-06-20T18:20:05.354995", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*/\n\n// Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n// Animation splits the sphere in different directions\n// This ended up running a significantly slower fps and not looking very different. :(\n//#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t// gamma correct\n    return tex;\n}*/\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    // fade bottom to top so it looks like the softbox is casting light on a floor\n    // and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    // overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    // fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    // purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001/(1.0 - abs(rayDir.x)));\n    // yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = texture(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = texture(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t// fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        // rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);\n#endif\n        // main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        // subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        // calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        // subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        // make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t// 1/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        // subtract sphere from fins so they don't intersect the inner spheres.\n        // also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        // smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t// recurse\n        // do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25/blender);\n#endif\n        // Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        // Scale things for the next iteration / recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    // Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 / outness, cut);\n    return distMat;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------------- Animate ------------------------------------\n    localTime = iTime*0.5;\n    // This is a wave function like a triangle wave, but with flat tops and bottoms.\n    // period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    // lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    //globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    // intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        // ray marching time\n        for (int i = 0; i < 290; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            //if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    // --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\t//if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        // Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t// don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);// vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        //texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);// sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        //if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        // reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;// * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n    //finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    // vignette?\n    //finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    //finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XljGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XljGWR", "name": "One more glass", "author": "andregc", "description": "This shader calculates a full set of reflection and refraction rays recursively. Use mouse to look around. Comment or set OBJECT_MAP_FUNCTION to see other objects", "tags": ["raymarching", "reflection", "refraction", "glass"], "likes": 18, "viewed": 812, "date": "1428102442", "time_retrieved": "2024-06-20T18:20:07.294675", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Distance function, camera setup and base for raymarching from iq's // https://www.shadertoy.com/view/Xds3zN\n\n//comment it or set to map1..map4 to see other objects (it is a bit slower when uncommented)\n#define OBJECT_MAP_FUNCTION map1\n\n\n#define RECURSION\n#define RAY_COUNT 15 //valid if RECURSION IS OFF: total number of rays (refl+reft) = 2^n-1, where n number of contact surfaces\n#define calcRecursion rec4 //valid if RECURSION IS ON: use n rays levels: total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 3.\n#define ID_FLOOR 1.\n#define ID_GLASS_WALL 2.\n#define ETA 0.75\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 1.\n#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n#define SURFACE_COLOR vec3(0.8,1.,0.8)*1.6\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.+0.6*noise(p.xz*30. + p.yy*23.));\n\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n    \n    \n//-------------------------------------------------------------------------------\n//  https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 d = abs(p) - b;\n   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n   return (length(p)-r);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return abs(length(max(abs(p)-b,0.0))-r);\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opS(  vec3 d1, vec3 d2 )\n{\n    return -d1.x>d2.x ? d2: d1;\n}\n\n//-------------------------------------------------------------------------------\n\nvec3 map3(in vec3 pos) {\n    \n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res.x =abs(res.x);\n    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n\treturn res;\n}\n\nvec3 map4(in vec3 pos) {\n    \n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n\treturn res;\n}\n\nvec3 map2(in vec3 pos) {\n   vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.4,0), vec2(0.8,0.5))), ID_GLASS_WALL, ETA);\n    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n \treturn res;\n}\n\n\nvec3 map1(in vec3 pos) {\n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 plane = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\n    vec3 res = plane;\n#ifdef OBJECT_MAP_FUNCTION    \n\tres =opU(res, OBJECT_MAP_FUNCTION(pos));    \n#else\n    float t = mod(iTime*0.1, 4.);\n    if (t < 1.) {\n    \tres = opU(res, map1(pos));\n    } else if (t<2.) {\n       \tres = opU(res, map2(pos));\n    } else if (t<3.) {\n        res = opU(res, map3(pos));\n    } else if (t<4.) {\n        res = opU(res, map4(pos));\n    }\n#endif\n    return res;\n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n\n}\n\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.000;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<200; i++ )\n    {\n\t     res = map(p+rd*t);\n      \n\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n    \n    p+=rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\n//-------------------------------------------------------------------------------\n\n\nvec3 getColor(in Ray ray, vec3 pos) {\n    vec3 col = vec3(0);\n    if (ray.cp.mat == ID_FLOOR) {\n        const float m = 3.;\n        vec2 p = fract(vec2(-pos.x+0.5,pos.z+0.5)/m)*m;\n        col = texture(iChannel0, p.xy).xyz;\n    } else {\n        col = ray.col * SURFACE_COLOR;\n    }\n\n \treturn col;\n\n}    \n\n//-------------------------------------------------------------------------------\n\n\n#ifdef RECURSION\n\nvec3 getRayColor(Ray ray) {\n\n    vec3 p =  ray.cp.p;\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray,p);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n    vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);\n}\n    \n// set of \"recursion\" functions\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    rec2(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec3(r1);\n    ray.col += getRayColor(r1);\n    rec3(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec4(r1);\n    ray.col += getRayColor(r1);\n    rec4(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec5(r1);\n    ray.col += getRayColor(r1);\n    rec5(r2);\n    ray.col += getRayColor(r2);\n}\n\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col += getRayColor(ray);\n\treturn ray.col;\n    \n}\n\n#else\n//-------------------------------------------------------------------------------\n\n// shorter but a bit slower \n    \nRay rays[RAY_COUNT];\nvec3 castRay(vec3 p, vec3 rd) {\n   \n   \n    CP cp = findIntersection(p, rd);\n   \n    rays[0] = Ray( rd, cp, vec3(0), 1., ETA);\n\n    for(int i = 0; i < RAY_COUNT/2; ++i) {\n        Ray ray = rays[i];\n        \n\t\tvec3 p = ray.cp.p;\n       \t float cs = dot(ray.cp.normal, ray.rd);\n        float fresnel = 1.0-abs(cs);\n        //float fresnel =mix(0.2, 1., pow(1.-abs(cs),2.));\n         vec3 normal = sign(cs)*ray.cp.normal;\n    \tvec3 refr = refract(ray.rd, -normal, ray.eta);\n        vec3 refl = reflect(ray.rd, ray.cp.normal);\n        vec3 z = normal*DIST_EPSILON*2.;\n        p += z;\n        rays[i*2+1] = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);\n        p -= 2.*z;\n        rays[i*2 + 2] = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);\n    }\n    \n    for(int i = RAY_COUNT-1; i>=0;--i) {\n        Ray ray = rays[i];\n        vec3 p =  ray.cp.p;\n\t\tvec3 atColor;\n        float  d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n        vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n        vec3 col = getColor(ray, p);\n        float q = exp(-d*ray.cp.dist);\n        col = col*q+matColor*(1.-q);\n        rays[(i-1)/2].col += col*ray.share;\n\n    }\n   \n\treturn rays[0].col;\n}\n\n#endif\n\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (mo.x==mo.y && mo.x==0.) {\n        mo = vec2(0.42,0.4);\n    }\n\n    mo.y+=0.02;\n\tmo.y *=1.57;\n    float time =iTime*0.1;;\n\tmo.x*=10.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(time + mo.x)*X, Y, X*sin(time + mo.x) )*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta,0. );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XljGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XljGWW", "name": "Deformation of a circle", "author": "frankier", "description": "Not very interesting", "tags": ["2dcircle"], "likes": 0, "viewed": 101, "date": "1429100994", "time_retrieved": "2024-06-20T18:20:07.294675", "image_code": "#define PI 3.14159265359\n\nfloat dist(vec2 vec) {\n    return sqrt(pow(vec.x, 2.0) + pow(vec.y, 2.0));\n}\n\n// https://en.wikipedia.org/wiki/Circular_segment\n\nfloat deformedRadius(float natRadius, float theta) {\n    return sqrt(natRadius * natRadius / (1.0 - 1.0/(2.0*PI)*(theta - sin(theta))));\n}\n\nfloat deformedDistance(float natRadius, float theta) {\n    return natRadius * (1.0 - cos(theta / 2.0));\n}\n\nfloat tri(in float x) {\n    return abs(fract(x) * 2.0 - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    // uv.x -0.8..0.8 uv.y -0.5..+0.5\n    float t = tri(iTime * 0.2);\n    // t 0..1\n    float natRadius = 0.2;\n    float theta = 2.0*atan(t*4.0);\n    //vec2 center = vec2(deformedDistance(natRadius, theta), 0.0);\n    float radius = deformedRadius(natRadius, theta);\n    vec2 center = vec2(deformedDistance(natRadius, theta), 0.0);\n    bool isCircle = dist(uv - center) < radius && uv.x < natRadius;\n\tfragColor = isCircle ?\n        vec4(1.0,1.0,1.0,1.0) :\n    \tvec4(0.0,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XljGWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlS3Dm", "name": "ColorfulCubes", "author": "0x17de", "description": "cubes are rotating around the center and themselfes, some background animations and scanlines", "tags": ["grid", "scanlines", "colorful", "cubes", "rotating"], "likes": 8, "viewed": 1462, "date": "1429355417", "time_retrieved": "2024-06-20T18:20:07.294675", "image_code": "vec3 circ(float aspect, vec2 uv, float size, vec3 color, float angle) {\n    float powF = 10.0;\n    vec2 xy;\n    xy[0] = uv[0] - 0.5;\n    xy[1] = uv[1] - 0.5;\n    xy[1] /= aspect;\n    xy[0] -= 0.1*sin(angle);\n    xy[1] += 0.1*cos(angle);\n    xy *= 20.0 * size;\n    \n    float pow1 = pow(abs(xy[0] * sin(angle) + xy[1] * cos(angle)),powF);\n    float pow2 = pow(abs(xy[1] * sin(angle) - xy[0] * cos(angle)),powF);\n    \n    float outColor = 1.0-clamp(\n        pow1+pow2\n        , 0.0, 1.0);\n    \n    return color * outColor;\n}\n\nvec3 bg(float aspect, vec2 uv, float size, float angle) {\n    float powF = -10.0;\n    vec2 xy;\n    xy[0] = uv[0] - 0.5;\n    xy[1] = uv[1] - 0.5;\n    xy[1] /= aspect;\n    xy[0] -= 0.5*sin(angle);\n    xy[1] += 0.5*cos(angle);\n    xy *= 20.0 * size;\n    \n    \n    float pow1 = pow(abs(xy[0] * sin(angle) + xy[1] * cos(angle)),powF);\n    float pow2 = pow(abs(xy[1] * sin(angle) - xy[0] * cos(angle)),powF);\n\n    float outColor = clamp(\n        pow1+pow2\n        , 0.0, 1.0);\n\n    return vec3(outColor);\n}\n\nvec3 scanline(vec2 uv, float angle, vec3 color, float size, float strength) {\n    uv[1] -= 0.5 + 0.5 * cos(mod(angle,3.14*2.0) / 2.0);\n    uv[1] *= 1000.0 * size;\n    float col = pow(uv[1],-1.0);\n   \tfloat damp = clamp(pow(abs(uv[0]), 10.0)+pow(abs(1.0-uv[0]), 10.0), 0.0, 1.0);\n\tcol-= damp * 0.2;\n    col = clamp(col, 0.0, strength);\n    return color * col;\n}\n\nfloat vignetting(vec2 uv, float aspect) {\n    float powF = 3.5;\n    \n    vec2 xy;\n    xy[0] = uv[0] - 0.5;\n    xy[1]/= aspect;\n    xy[1] = uv[1] - 0.5;\n\txy *= 1.8;\n\n    xy[0] = pow(abs(xy[0]), powF)-0.1;\n    xy[1] = pow(abs(xy[1]), powF)-0.1;\n\n    return clamp(1.0-(xy[0] + xy[1]), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float bgFactor = sin(uv[0]) * cos(uv[1]);\n    vec3 backgroundColor = vec3(0.3, 1.0, 1.0) * bgFactor;\n    \n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 purple = vec3(0.5, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    vec3 topColor = (\n        circ(aspect, uv, 1.0, red, iTime + 3.14) +\n        circ(aspect, uv, 2.0, green, iTime - 1.56) +\n        circ(aspect, uv, 3.0, blue, iTime) +\n        circ(aspect, uv, 4.0, yellow, iTime + 1.56)\n    );\n    float colorFactor = ceil(dot(topColor, topColor));\n    vec3 outColor = backgroundColor * (1.0-colorFactor) + topColor * colorFactor;\n\n    float slowTime = iTime/3.0;\n    outColor /= 1.0-bg(aspect, uv, 1.0, slowTime + 3.14);\n    outColor /= 1.0-bg(aspect, uv, 2.0, slowTime - 1.56);\n    outColor /= 1.0-bg(aspect, uv, 3.0, slowTime);\n    outColor /= 1.0-bg(aspect, uv, 4.0, slowTime + 1.56);\n    \n    outColor += scanline(uv, iTime, green, 1.0, 0.3);\n    outColor += scanline(uv, iTime-0.1, purple, 0.2, 0.2);\n    outColor += scanline(uv, iTime*0.7+1.3, green, 1.0, 0.1);\n    outColor += scanline(uv, iTime*0.7+1.3, purple, 0.2, 0.08);\n    \n    outColor = clamp(outColor, 0.0, 1.0);\n    \n    outColor *= vec3(vignetting(uv, aspect));\n\n    fragColor = vec4(outColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlS3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlS3Ww", "name": "Fading shapes", "author": "pixelzealot", "description": "Squircles are fun.", "tags": ["2d", "fade", "candy"], "likes": 9, "viewed": 292, "date": "1429277228", "time_retrieved": "2024-06-20T18:20:07.294675", "image_code": "float f(vec2 p, vec2 centre, float mult)\n{\n    float radius = 0.09;\n    \n    float power = 0.5 + 3.5 * mult;\n    power = clamp(power, 0.0, 4.0);\n    vec3 a = vec3(p, radius);\n    vec3 b = vec3(centre, 0.0);\n    return dot(pow(abs(a-b), vec3(power)), vec3(1.0, 1.0, -1.0));\n}\n\nvec2 grad(in vec2 x, in vec2 centre, in float mult)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy, centre, mult) - f(x-h.xy, centre, mult),\n                 f(x+h.yx, centre, mult) - f(x-h.yx, centre, mult) ) / (2.0*h.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv = -1.0+2.0*uv;\n\tuv.x *= iResolution.x/iResolution.y;    \n\n    const float gridSize = 5.0;\n   \n    vec2 grid = vec2(gridSize);\n    vec2 coord = floor(uv * grid) / grid;\n    \n    vec2 c = vec2(1.0/gridSize);\n    vec2 p = mod(uv, c) - c*0.5;\n    \n    vec2 centre = vec2(0,0);\n    \n    float t = sin(abs(coord.x * coord.y) + iTime*2.0) * 0.5 + 0.5;\n    t *= t;\n    \n    float v = f(p, centre, t);\n    vec2  g = grad(p, centre, t);\n    float de = v / length(g);\n    \n    vec2 mixVal = coord;\n    mixVal*= mixVal;\n    vec3 sCol = vec3(0.2 + mixVal * 0.8, 0.0) + vec3(0,0,1) * (1.0 - dot(abs(coord), vec2(1.0)));\n    \n    float edge = 5.0 / iResolution.x;\n    float border = smoothstep(0.0, edge * 2.0, abs(de));\n    sCol *= border;\n\n    vec3 col = vec3(0.3);\n    col = mix( col, sCol, 1.0-smoothstep(0.0, edge, de));\n    \n    fragColor = vec4(col,  1.0); \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlS3Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlSGWR", "name": "Torus Knot", "author": "vgs", "description": "A trefoil knot as a (p, q) torus knot. Click to rotate.", "tags": ["3d", "torus", "knot", "trefoil"], "likes": 30, "viewed": 2026, "date": "1427921255", "time_retrieved": "2024-06-20T18:20:07.294675", "image_code": "// Created by Vinicius Graciano Santos - vgs/2015\n\n#define STEPS 64\n#define EPS 0.01\n#define FAR 21.0\n#define TAU 6.28318530718\n\nfloat knot(vec3 p, float k) {\n    float r = length(p.xy);\n    float oa, a = atan(p.y, p.x); oa = k*a;\n    a = mod(a, 0.001*TAU) - 0.001*TAU/2.0;\n    p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n    p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n    p.x = abs(p.x) - 1.35; \n    return length(p) - 1.0;\n}\n\nfloat map(vec3 p) {\n   \tfloat t = mod(iTime+8.0, 12.0);\n    float k = step(5.0, t)*smoothstep(5.0, 6.0, t)*step(t, 11.0);\n    k += step(11.0, t)*(1.0-smoothstep(11.0, 12.0, t));;\n    \n    return knot(p, mix(1.5, 3.5, k));\n}\n\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\nvec3 bgColor(vec3 rd) {\n    vec3 bl = vec3(22., 122., 198.)/255.;\n    return bl*(1.0+2.0*rd.y)/3.0+.35;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + t*rd;\n    for (int i = 0; i < 3; ++i)\n    \tp = p + rd*(map(p) - 4.0*t/iResolution.x);\n    \n    vec3 n = normalize(grad(p));\n    return bgColor(reflect(rd, n))*(0.2+0.8*pow(1.0-dot(-rd, n), 0.5));\n}\n\nmat3 lookAt(vec3 p) {\n    vec3 z = normalize(p);\n    vec3 x = normalize(cross(vec3(0., 1., 0.), z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float ms = -1.0+2.0*iMouse.y/iResolution.y;\n    \n    vec3 ro = vec3(5.0*cos(iTime), iMouse.z > 0.0 ? 10.0*ms : 0.0, 10.0);\n    vec3 rd = normalize(lookAt(ro)*vec3(uv, -1.0));\n    \n    float d, t = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (d < EPS) break;\n        t += 0.85*d;\n    }\n    vec3 col = d < EPS ? shade(ro, rd, t) : bgColor(rd);\n    \n    vec2 vig = fragCoord.xy/iResolution.xy;\n    col *= 0.5+0.7*pow(vig.x*(1.0-vig.x)*vig.y*(1.0-vig.y), 0.15);\n    col = smoothstep(0.0, 0.8, col);\n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlSGWw", "name": "Ring Thing", "author": "reuben364", "description": "Ring Thing", "tags": ["ring", "thing"], "likes": 0, "viewed": 86, "date": "1429272564", "time_retrieved": "2024-06-20T18:20:07.409708", "image_code": "#define time (iTime*1000.)\n#define resolution (iResolution.xy)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = time/1000.;\n\tvec2 uv = fragCoord / resolution;\n    uv *= 1.+sin(t);\n    vec2 whatEvah = cos(uv);\n    vec4 col1 = mix(vec4(1,0,1,1), vec4(1,0,0,1), abs(.5-fract(t)));\n    uv -= .4-vec2(.1*sin(t),-.4*abs(.5-fract(t*2.)));\n    col1 = mix(.25*(1.+sin(length(uv*40.)+t))*vec4(0,0,1,1), col1, .7);\n\tfragColor = col1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlSGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt23Dz", "name": "20150405_sakura revisited", "author": "FMS_Cat", "description": "repetition rulez", "tags": ["3d", "raymarching"], "likes": 56, "viewed": 2686, "date": "1428244960", "time_retrieved": "2024-06-20T18:20:07.409708", "image_code": "#define PI 3.1415926\n#define V vec2(0.,1.)\n\n#define t iTime\n#define r iResolution.xy\n#define c fragCoord\n#define cl(i) clamp(i,0.,1.)\n\n#define MAT_NULL -1.\n#define MAT_ANTHER 0.\n#define MAT_FILAMENT 1.\n#define MAT_PISTIL 2.\n#define MAT_PETAL 3.\n#define MAT_CALYX 4.\n#define MAT_TREE 5.\n\nfloat hash(vec2 _v)\n{\n    return fract(sin(dot(_v,vec2(89.44,19.36)))*22189.22);\n}\n\nfloat iHash(vec2 _v,vec2 _r)\n{\n    float h00 = hash(vec2(floor(_v*_r+V.xx)/_r));\n    float h10 = hash(vec2(floor(_v*_r+V.yx)/_r));\n    float h01 = hash(vec2(floor(_v*_r+V.xy)/_r));\n    float h11 = hash(vec2(floor(_v*_r+V.yy)/_r));\n    vec2 ip = vec2(smoothstep(V.xx,V.yy,mod(_v*_r,1.)));\n    return (h00*(1.-ip.x)+h10*ip.x)*(1.-ip.y)+(h01*(1.-ip.x)+h11*ip.x)*ip.y;\n}\n\nfloat noise(vec2 _v)\n{\n    float sum = 0.;\n    for(int i=1; i<9; i++)\n    {\n        sum += iHash(_v+vec2(i),vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n    }\n    return sum;\n}\n\nmat2 rotate( float _th )\n{\n    return mat2( cos(_th), -sin(_th), sin(_th), cos(_th) );\n}\n\nfloat pole( vec3 _p, float _r, float _l )\n{\n    vec2 d = abs( vec2( length( _p.xz ), _p.y ) ) - vec2( _r, _l );\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nfloat pole( vec3 _p, float _r )\n{\n    return length( _p.xz ) - _r;\n}\n\nfloat smin( float _a, float _b, float _k )\n{\n    float h = cl( 0.5+0.5*( _b-_a )/_k );\n    return mix( _b, _a, h ) - _k*h*( 1.-h );\n}\n\nvec2 stamen( vec3 _p )\n{\n    vec2 dist = vec2( 1E2 );\n    vec2 distC = dist;\n    float phase = floor( atan( _p.z, _p.x )/PI/2.*13.-1. );\n    vec3 offset = vec3( .04, -.0, .04 ) * ( 1. + sin( t )*.1 );\n    offset.xz *= .6 + hash( vec2( phase*1.9873, 821.122 ) )*.6;\n    vec3 p = _p - V.xyx*.01;\n    p.xz = rotate( floor( phase )*PI*2./13. ) * p.xz;\n    vec3 pa = p + ( sin(p.x*200.)*sin(p.y*200.)*sin(p.z*200.) ) * .003 - offset - V.xyx*.1;\n    distC = vec2( length( pa ) - .005, MAT_ANTHER );\n    if( distC.x < dist.x ){ dist = distC; }\n    pa = p + vec3( sin(p.y*20.), 0., cos(p.y*20.) )*.003 - offset * ( .5+.5*sin( p.y/.1*PI/2. ) );\n    distC = vec2( pole( pa-V.xyx*.025,  sin( pa.y/.1*PI )*.001, .075 ), MAT_FILAMENT );\n    if( distC.x < dist.x ){ dist = distC; }\n    return dist;\n}\n\nvec2 pistil( vec3 _p )\n{\n    vec3 p = _p;\n    float pistil = pole( p - V.xyx*.01 + vec3( cos(p.y*50.), 0., sin(p.y*50.) )*.001, .004, .06 );\n    pistil = smin( pistil, length( vec2( length( p.xz )-.007, p.y-.07 ) )-.001, .01 );\n    return vec2( pistil, MAT_PISTIL );\n}\n\nvec2 petals( vec3 _p )\n{\n    float dist = 1E2;\n    vec3 p = _p;\n    p.y -= pow( length( p.xz ), .5)*.2-.055;\n    p.xz = rotate( floor( atan( p.z, p.x )/PI/2.*5.-2. )*PI*2./5. ) * p.xz;\n    p.xy = rotate( -.3 + sin( t )*.1 ) * p.xy;\n    p.x += .14;\n    p.x *= ( 1. - pow( abs( sin( atan( p.z, p.x ) ) ), .1 )*.3 )*1.4;\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = min( dist, pole( p, .1, .001 ) );\n    return vec2( dist, MAT_PETAL + cl( length( _p.xz ) ) );\n}\n\nvec2 calyx( vec3 _p )\n{\n    float dist = 1E2;\n    \n    vec3 p = _p;\n    p.y -= pow( length( p.xz ), .2)*.2-.13;\n    p.xz = rotate( floor( atan( p.z, p.x )/PI/2.*5.-2. )*PI*2./5. ) * p.xz;\n    p.xy = rotate( -.3 ) * p.xy;\n\n    vec3 ptemp = p;\n    p.x += .04;\n    p.x *= max( pow( abs( sin( atan( p.z, p.x ) ) ), .1 ), .6 );\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = smin( dist, pole( p, .03, .001 ), .02 );\n\n    p = ptemp + V.xyx*.15;\n    p.x -= .02;\n    p.x *= max( pow( abs( sin( atan( p.z, p.x ) ) ), .1 ), .6 );\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = smin( dist, pole( p, .01, .001 ), .02 );\n    \n    dist = smin( dist, pole( _p + vec3( cos(_p.y*20.), 0., sin(_p.y*20.) )*.004 + V.xyx*.15, .01, .09 ), .02 );\n    \n    return vec2( dist, MAT_CALYX + cl( -_p.y-.05 ) );\n}\n\nvec2 blossom( vec3 _p, float _h )\n{\n    vec2 dist = vec2( 1E2 );\n    if( length( _p ) < .28 )\n    {\n        dist = stamen( _p );\n        vec2 distC = pistil( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n        distC = petals( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n        distC = calyx( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n    }\n    else\n    {\n        dist = vec2( length( _p )-.27, MAT_NULL );\n    }\n\treturn dist;\n}\n\nvec2 branch( vec3 _p )\n{\n    vec2 dist = vec2( 1E2 );\n    vec3 p = _p;\n    p.xy = rotate( -1. )*p.xy;\n    vec3 pt = p + sin( p.x*10. )*sin( p.y*10. )*sin( p.z*10. ) * .03;\n    dist = vec2( pole( pt, .1 ), MAT_TREE );\n    p.zx = rotate( floor( p.y*2.+.5 )*.7 - .5 )*p.zx;\n    float th = atan( p.z, p.x );\n    if( th < 0. ){ p.zx = rotate( PI )*p.zx; }\n    p.yz = rotate( PI/2. )*p.yz;\n    p.y -= .3;\n    p.z = mod( p.z+.25, .5 )-.25;\n    vec2 distC = blossom( p, 12.4 );\n    if( distC.x < dist.x ){ dist = distC; }\n    return dist;\n}\n\nvec2 scene( vec3 _p )\n{\n    vec2 dist = branch( _p );\n    return dist;\n}\n\nvec3 sceneNormal( vec3 _p )\n{\n    vec2 d = V*1E-4;\n    return normalize( vec3(\n        scene( _p + d.yxx ).x - scene( _p - d.yxx ).x,\n        scene( _p + d.xyx ).x - scene( _p - d.xyx ).x,\n        scene( _p + d.xxy ).x - scene( _p - d.xxy ).x\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (c*2.-r)/r.x;\n    \n    vec3 camPos = vec3( .8, 0., 1. );\n    vec3 camTar = vec3( sin(t*.72), sin(t*.83), sin(t*.37) )*.01 - vec3( sin( t*.21 )*.2, -.2, .0 );\n    vec3 camDir = normalize( camTar - camPos );\n    vec3 camAir = V.xyx;\n    vec3 camSid = normalize( cross( camDir, camAir ) );\n    vec3 camTop = normalize( cross( camSid, camDir ) );\n    \n    vec3 rayDir = normalize( camSid * p.x + camTop * p.y + camDir );\n    vec3 rayPos = camPos;\n    float rayLen = 0.;\n    vec2 dist = V.xx;\n    for( int i=0; i<64; i++ )\n    {\n        dist = scene( rayPos )*vec2( .6, 1. );\n        rayLen += dist.x;\n        rayPos = camPos + rayDir * rayLen;\n        if( dist.x < 2E-3 || 1E2 < rayLen ){ break; }\n    }\n    \n    vec3 col = V.xxx;\n    if( dist.x < 4E-3 )\n    { \n        vec3 ligPos = vec3( 0., 1., 11. );\n        vec3 nor = normalize( sceneNormal( rayPos ) );\n        float dif = cl( dot( normalize( rayPos-ligPos ), -nor ) )*.3;\n        float amb = .7;\n        float speDot = cl( dot( normalize( normalize( rayPos-ligPos ) + normalize( rayPos-camPos ) ), -nor ) );\n        float spe = cl( pow( speDot, 10. ) )*.1;\n        vec3 matCol = V.xxx;\n        if( floor( dist.y ) == MAT_NULL ){ amb = 1.; matCol = vec3( 1. ); }\n        else if( floor( dist.y ) == MAT_ANTHER ){ matCol = vec3( .9, .9, .5 ); }\n        else if( floor( dist.y ) == MAT_FILAMENT ){ matCol = vec3( .9, .9, .8 ); }\n        else if( floor( dist.y ) == MAT_PISTIL ){ matCol = vec3( .8, .9, .6 ); }\n        else if( floor( dist.y ) == MAT_PETAL ){ matCol = vec3( .9, .4, .8 ) + vec3( .1, .6, .2 ) * ( 1.-exp( -fract( dist.y )*16. ) ); }\n        else if( floor( dist.y ) == MAT_CALYX ){ matCol = vec3( .7, .1, .3 ) + vec3( -.4, .4, -.4 ) * cl( fract( dist.y )*8. ); }\n        else if( floor( dist.y ) == MAT_TREE ){\n            nor += vec3(\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+27.1982))-.5,\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+28.1982))-.5,\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+29.1982))-.5\n            )*2.;\n            nor = normalize( nor );\n            dif = cl( dot( normalize( rayPos-ligPos ), -nor ) )*.6;\n            float speDot = cl( dot( normalize( normalize( rayPos-ligPos ) + normalize( rayPos-camPos ) ), -nor ) );\n            float spe = cl( pow( speDot, 10. ) )*.1;\n            matCol = vec3( .4, .3, .1 );\n        }\n       \tcol = ( dif + amb ) * matCol + spe;\n    }\n    else\n    {\n        col = vec3( .5, .7, .9 );\n        for( float i=12.; i<39.; i+=1. )\n        {\n            vec2 pos = ( vec2( hash(vec2(i,198.33)), hash(vec2(i,298.33)) ) - .5 )*r/r.x*2.;\n            pos += vec2( sin( t*.2*hash(vec2(i,19.233)) ), sin( t*.2*hash(vec2(i,29.233)) ) )*.01;\n            col += cl( 12.-length(p-pos)*50. ) * vec3( 1., .7, .9 )*.02;\n        }\n    }\n    \n    col -= length( p )*.4;\n    \n    fragColor = vec4( col, 1. );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt23WR", "name": "Water Shafts", "author": "chees502", "description": "Stylized Water lightshafts", "tags": ["2dwater"], "likes": 14, "viewed": 643, "date": "1428102588", "time_retrieved": "2024-06-20T18:20:07.409708", "image_code": "vec2 uv;\nfloat GodRay(float scale,float threshold,float speed,float angle){\n\tfloat value = pow(sin((uv.x+uv.y*angle+iTime*speed)*scale),6.0);\n    value+=float(threshold<value);\n    //return float(threshold<(sin((uv.x+uv.y*angle+iTime*speed)*scale)));\n    \n    return clamp(value,0.0,1.0); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n    float light = GodRay(22.0,0.5,-0.003,0.2)*\t0.3;\n    light+=GodRay(47.0,\t0.99,\t0.02,\t0.2)*\t0.1;\n    light+=GodRay(25.0,0.9,\t\t-0.01,\t0.2)*\t0.2;\n    light+=GodRay(52.0,\t0.4,\t0.0001,\t0.2)*\t0.1;\n    light+=GodRay(49.0,\t0.4,\t0.0003,\t0.2)*\t0.1;\n    light+=GodRay(57.0,\t0.4,\t-0.0001,0.2)*\t0.1;\n    light+=GodRay(200.0,0.8,\t-0.0001,0.2)*\t0.05;\n    light-=pow((1.0-uv.y)*0.7,0.8);\n    light=max(light,0.0);\n    vec3 LightColor = vec3(1.0,0.95,0.85);\n    vec3 WaterTop = vec3(0.15,0.6,0.7);\n    vec3 WaterBot = vec3(0.08,0.12,0.3);\n    vec3 WaterColor = WaterBot+uv.y*(WaterTop-WaterBot);\n    vec3 Color = WaterColor+light*(LightColor-WaterColor);\n\tfragColor = vec4(Color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt23zG", "name": "Experiment#DF4", "author": "tomkh", "description": "Repetition with overlap benchmark.\nTry changing SCENE and OVERLAP_SCENE, DEBUG_MODE.\nLighting is not perfect, I know. Prev.attempts: [url=https://www.shadertoy.com/view/ltSGRG]ltSGRG[/url] and [url=https://www.shadertoy.com/view/llSGRy]llSGRy[/url]. ", "tags": ["3d", "raymarching", "distancefields", "benchmark"], "likes": 12, "viewed": 1113, "date": "1429971567", "time_retrieved": "2024-06-20T18:20:09.052425", "image_code": "// Just for my own educational purposes...\n// Extended from my previous attempt: llSGRy\n// tomkh@2015\n\n#define SCENE 2\n//   0 = centered bboxes\n//   1 = centered decorated bboxes\n//   2 = non-centered bboxes\n//   3 = non-centered decorated\n\n#define OVERLAP_SCENE 2\n//   0 = coins\n//   1 = pipes\n//   2 = tori\n//   To show nothing just comment out OVERLAP.\n\n// Enable to test overlap (must be less than 0.5):\n#define OVERLAP 0.1\n\n// Enable to debug distance field:\n#define DEBUG_MODE 1\n//   0 = no debug\n//   1 = show DF plane\n//   2 = show all DF slices\n\n// Enable experimental AO (I still need to work on it):\n//#define TEST_AO\n\n#define VIEW_DIST 1\n//   0 = short distance\n//   1 = middle\n//   2 = far\n\n#if VIEW_DIST == 0\n\tconst int ray_steps = 160;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 20.0;\n\tconst float cam_tilt = -.2;\n#elif VIEW_DIST == 1\n\tconst int ray_steps = 80;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 30.0;\n\tconst float cam_tilt = -.4;\n#else\n\tconst int ray_steps = 80;\n\tconst float dist_max = 200.0;\n\tconst float fog_start = 100.0;\n\tconst float fog_density = 0.02;\n\tconst float cam_dist = 80.0;\n\tconst float cam_tilt = -.4;\n#endif\nconst float floor_plane = -5.0;\n\n// Tile space:\nconst float tile_d = 2.0;\nconst float tile_ood = 1.0/tile_d;\n\nmat3 tori_rot[2];\n\n// P-----+-----Q\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// R-----+-----S\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A,B,C,D are our tile centers.\n// We have to assume max/min height.\n// We call \"frame\", a bounding area of everything outside PQRS (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles: A,B,C,D\n//   (possibly with early-out optimization with rough distance estimation)\n//   and we bound it additionally to distance to PQRS frame.\n\nfloat dist2frame(vec3 p, float box_y)\n{\n#ifdef OVERLAP\n    vec3 dp = vec3(\n        tile_d*(1.0-OVERLAP)-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d*(1.0-OVERLAP)-abs(p.z));\n#else\n    vec3 dp = vec3(\n        tile_d-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d-abs(p.z));\n#endif\n    return length(vec2(min(dp.x,dp.z),dp.y));\n}\n\nfloat dist2box(vec3 p, float box_x, float box_y, float box_z, float box_r)\n{\n    // Distance to rounded box:\n    vec3 dp = vec3(\n        max(0.0,abs(p.x)-box_x),\n        max(0.0,abs(p.y)-box_y),\n        max(0.0,abs(p.z)-box_z));\n    return length(dp) - box_r;\n}\n\nfloat dist2pipe(vec3 p, float r, float h, float cap)\n{\n    float dxz = length(p.xz) - r;\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat dist2cyl(vec3 p, float r, float h, float cap)\n{\n    float dxz = max(0.0, length(p.xz) - r);\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat evaluate_tile(vec3 p, vec3 p_id, float dx, float dy)\n{\n    p_id.xz += vec2(dx,dy);\n    p.xz -= vec2(dx-.5,dy-.5)*tile_d;\n    float anim = iTime*.25;\n    float p1, dist;\n    p1 = sin(p_id.x+anim)*sin(p_id.z+anim*.33);\n#ifdef OVERLAP\n    float r = tile_d*(.5 + OVERLAP);\n    #if OVERLAP_SCENE == 0\n    \tdist = dist2cyl(vec3(p.x,p.y-p1*.25,p.z),r-.25,.0,.25);\n    #elif OVERLAP_SCENE == 1\n    \tdist = dist2pipe(vec3(p.x,p.y-p1*2.0,p.z),r-.25,1.75,.25);\n    #else\n    \tmat3 rot = (mod(p_id.x*.17 + p_id.z*.71,2.0)<1.0) ? tori_rot[0] : tori_rot[1];\n        dist = dist2pipe(vec3(p.x,p.y-p1*3.0,p.z)*rot,r-.25,.0,.25);\n    #endif\n#else\n    dist = 1e32;\n#endif\n#if SCENE >= 2\n    p1 = 4.0 - abs(p1)*3.9;\n    float id = p_id.x + p_id.z;\n    vec3 p2 = p + vec3(cos(id*3.0+anim*1.11),0,sin(id*3.0+anim*1.11))*.5;\n    dist = min(dist, dist2box(p2, .25, p1, .25, 0.025));\n    #if SCENE == 3\n    \t//if (dist > .3) return dist - .1; // simple early-out optimziation\n    \tdist = min(dist, dist2box(p2 - vec3(0,p1*.333,0), .25, .0, .25, .1));\n        dist = min(dist, dist2box(p2 - vec3(0,p1*.666,0), .25, .0, .25, .1));\n    #endif\n#else\n    p1 = 4.0 - abs(p1)*3.8;\n    float p2 = 0.2 + abs(cos(p_id.x+anim*.5)*cos(p_id.z+anim*.66))*.7;\n    dist = min(dist, dist2box(p, p2, p1, p2, 0.025));\n    #if SCENE == 1\n        //if (dist > .2) return dist - .1; // simple early-out optimziation\n        dist = min(dist, dist2box(p, p2+.1, p1-.1, .1, 0.025));\n        dist = min(dist, dist2box(p, .1, p1-.1, p2+.1, 0.025));\n    #endif\n#endif\n    return dist;\n}\n\nfloat get_distance(vec3 p)\n{\n    vec3 p_id = vec3(\n        floor(p.x*tile_ood),\n        0,\n        floor(p.z*tile_ood));\n    \n    p = vec3(\n        (fract(p.x*tile_ood)-.5)*tile_d,\n        p.y, //(fract(p.y*tile_ood)-.5)*tile_d,\n        (fract(p.z*tile_ood)-.5)*tile_d);\n    \n    float dist = dist2frame(p, 4.25);\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 1.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 1.0));\n\n    dist = min(dist, abs(p.y - floor_plane));\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    const float eps = 1e-3;\n    const vec3 x_eps = vec3(eps,0,0);\n    const vec3 y_eps = vec3(0,eps,0);\n    const vec3 z_eps = vec3(0,0,eps);\n    return normalize(vec3(\n        get_distance(p + x_eps) - get_distance(p - x_eps),\n        get_distance(p + y_eps) - get_distance(p - y_eps),\n        get_distance(p + z_eps) - get_distance(p - z_eps) ));\n}\n\nfloat get_ao(vec3 hit, vec3 n)\n{\n#ifdef TEST_AO\n    // TODO: this AO sux, so would be nice to implement better approximation ;)\n    const float ao_step = .1;\n    float ao_dist, ao_len, d;\n    hit += n*ao_step;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len = d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    return clamp(0.0,1.0,ao_len*1.5);\n#else\n    return 1.0; // no AO for now looks better :(\n#endif\n}\n\nvec3 trace(vec3 p_start, vec3 n)\n{\n#if DEBUG_MODE != 2\n    float ray_len;\n    float dist;\n    const float dist_eps = .001;\n    vec3 p = p_start;\n    for(int k=0; k<ray_steps; ++k) {\n    \tdist = get_distance(p);\n        if (dist < dist_eps || dist > dist_max) break;\n        p += dist*n;\n        ray_len += dist;\n    }\n    \n    //vec3 light_dir = normalize(vec3(.1,1.0,-.3));\n    float light_ang = (iMouse.x/iResolution.x-.5) + 1.0;\n    vec3 light_dir = normalize(vec3(cos(light_ang),2.0,-sin(light_ang)));\n    vec3 normal = get_normal(p);\n    float shade = 0.0;\n    float specular = 0.0;\n    vec3 base_color = vec3(1.0,1.0,1.0);\n    if (dist < dist_eps) {\n        if (p.y < floor_plane + dist_eps*2.0) {\n            float d = (p_start.y - floor_plane) / -n.y;\n        \tvec3 hit = p_start + n*d;\n            float pattern = mod(floor(hit.x/tile_d)+floor(hit.z/tile_d),2.0);\n            base_color = mix(vec3(.2,.4,.6),vec3(.4,.6,.8),pattern);\n        }\n        //shade = (1.0 - dist/dist_eps)*dot(normal, light_dir);\n        shade = dot(normal, light_dir);\n        shade = max(0.0, shade);\n        shade *= get_ao(p,normal);\n        specular = max(0.0,dot(n, light_dir - normal*dot(normal,light_dir)*2.0));\n        specular = pow(specular,32.0)*.25;\n    }\n        \n    vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),shade)*base_color;\n    color += vec3(1.,1.,1.)*specular;\n\n    // Test ray with cut_plane:\n#if DEBUG_MODE == 1\n    float cut_plane = (iMouse.y / iResolution.y - 0.1) * 8.0;\n    cut_plane = max(0.0, cut_plane);\n    if (n.y*sign(p_start.y-cut_plane) < 0.0) {\n        float d = (p_start.y - cut_plane) / -n.y;\n        if (d < ray_len) {\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n            //dist_color = min(vec3(1.0,1.0,1.0),dist_color);\n            color = mix(color,dist_color,.25);\n            ray_len = d;\n        }\n    }\n#endif\n    vec3 fog_color = vec3(.8,.8,.8);\n    float fog = 1.0-1.0/exp(max(0.0,ray_len-fog_start)*fog_density);\n    color = mix(color,fog_color,fog);\n#else\n    vec3 color = vec3(0.,.1,.3);\n   \n    for(float cut_plane = 4.0; cut_plane >= 0.0; cut_plane -= 0.1) {\n        // Test ray with cut_plane:\n        if (n.y*sign(p_start.y-cut_plane) < 0.0) {\n            float d = (p_start.y - cut_plane) / -n.y;\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.05);\n            color += dist_color*.02*cut_plane*.25;\n        }\n    }\n#endif\n\n\treturn color;\n}\n\nmat3 from_axis_angle(float angle, vec3 axis) {\n  \tfloat si, co, ti, tx, ty, tz, sx, sy, sz;\n\n    si = sin(angle);\n    co = cos(angle);\n    ti = 1.0 - co;\n\n    tx = ti * axis.x; ty = ti * axis.y; tz = ti * axis.z;\n    sx = si * axis.x; sy = si * axis.y; sz = si * axis.z;\n\n    return mat3(\n        tx * axis.x + co, tx * axis.y + sz, tx * axis.z - sy,\n        tx * axis.y - sz, ty * axis.y + co, ty * axis.z + sx,\n        tx * axis.z + sy, ty * axis.z - sx, tz * axis.z + co\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = -0.2; //iMouse.x / iResolution.x * 2.0 - 1.0; \n    a += cos(anim)*.05;\n    float co = cos(a);\n    float si = sin(a);\n    vec3 p1 = vec3(-cam_dist*si, 0, -cam_dist*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //a = iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2 - 2.0;\n    a = cam_tilt;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n#if defined(OVERLAP) && OVERLAP_SCENE == 2\n    tori_rot[0] = from_axis_angle(anim, normalize(vec3(.5,.2,.3)));\n\ttori_rot[1] = from_axis_angle(anim+2.0, normalize(vec3(.3,.7,-.2)));\n#endif\n    \n    fragColor = vec4(trace(p2, n3), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt23zy", "name": "Two floating cubes", "author": "luutifa", "description": "The only thing I dislike here are the speculars on the floor plane, but I have yet no idea how to handle different materials and textures and mapping for different objects.", "tags": ["raymarching", "lighting", "reflections"], "likes": 11, "viewed": 484, "date": "1430056585", "time_retrieved": "2024-06-20T18:20:09.828093", "image_code": "#ifdef GL_ES\n    precision highp float;\n#endif\n\n#define ITR 40\n#define EPSILON 0.001\n#define PI 3.14159265\n#define NUM_LIGHTS 4\n#define MAX_MARCH_LENGTH 30.0\n\n#define TRY_DRAW_LIGHTSOURCES //comment to hide light sources\n\n//-----------------------------------------------------------------------------\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 getXRotMat(float a) {\n    return mat3(\n         1.0,  0.0,     0.0,\n         0.0,  cos(a), -sin(a),\n         0.0,  sin(a),  cos(a)\n    );\n}\n\nmat3 getYRotMat(float a) {\n    return mat3(\n         cos(a),  0.0,  sin(a),\n         0.0,     1.0,  0.0,\n        -sin(a),  0.0,  cos(a)\n    );\n}\n\nmat3 getZRotMat(float a) {\n    return mat3(\n         cos(a), -sin(a),  0.0,\n         sin(a),  cos(a),  0.0,\n         0.0,     0.0,     1.0\n    );\n}\n//-----------------------------------------------------------------------------\n\nfloat plane(vec3 p) {\n    return p.y;\n}\n\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos) -r;\n}\n\nfloat tunnel(vec3 pos, float r) {\n    return -(length(vec3(pos.xy,0.0))-r);\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 cam = vec3(0.0, 3.0, 0.0);\nvec3 lights[NUM_LIGHTS*2];\nvec3 normal;\n\nfloat scene(vec3 pos) {\n    return min(\n        plane(pos),\n        min(\n            box(getYRotMat(iTime*0.33)*getXRotMat(iTime)*(pos-vec3(1.4, 1.3+sin(iTime)*0.5, 5.0-sin(iTime*0.2)*0.2)), vec3(0.4, 0.4, 0.4)),\n            box(getYRotMat(iTime*0.6)*getXRotMat(iTime*0.4)*(pos-vec3(-1.4, 1.0+cos(iTime)*0.3, 5.0)), vec3(0.4, 0.4, 0.4))\n        )\n    );\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p+e.xyy), scene(p+e.yxy), scene(p+e.yyx)) - scene(p)) / e.x;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    float h;\n    for(int i=0;i<ITR;i++)\n    {\n        h = scene(ro + rd*t);\n        if(h<EPSILON)\n            return 0.0;\n        t += h;\n        res = min(res, k*h/t);\n        if(t > maxt)\n            break;\n    }\n    return res;\n}\n\nvec3 light(vec3 pos, vec3 light, vec3 color) {\n    float nmLight = max(dot(normalize(pos-light), -normal), 0.0);\n    return (1.0/length(pos-light)) * nmLight * softShadow(pos, normalize(light-pos), 0.1, length(light-pos), 18.0) * color * texture(iChannel0, pos.xz*0.2).rgb + pow(nmLight, 200.0)*color;\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 spos) {\n    vec3 l=vec3(0.0);\n    for (int i=0; i<NUM_LIGHTS; i++) {\n        l += light(pos, lights[i*2], lights[i*2+1]);\n        \n        #ifdef TRY_DRAW_LIGHTSOURCES\n            if (length(pos-spos) > length(lights[i*2]-spos))\n                l += pow(max(dot(normalize(spos-lights[i*2]), -dir), 0.0), 2000.0)*lights[i*2+1];\n        #endif\n    }\n    return l;\n}\n\nvec3 march(vec3 origin, vec3 direction) {\n    float t;\n    float dist;\n    for (int i=0; i<ITR; i++) {\n        dist = scene(origin+direction*t);\n        t += dist;\n        if (t > MAX_MARCH_LENGTH)\n            break;\n    }\n    return origin + direction*t;\n}\n\nvec3 getImage(vec2 screenPos) {\n    vec3 screenDir = getXRotMat(-0.5)*normalize(vec3(screenPos*0.5, 1.0));\n    vec3 pos = march(cam, screenDir);\n    normal = normalize(grad(pos)); //Global normal, declared after distfield tools\n    vec3 reflectDir = normalize(reflect(screenDir, normal));\n    return lighting(pos, screenDir, cam)*0.7 + lighting(march(pos+reflectDir*EPSILON, reflectDir), reflectDir, pos)*0.3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lights[0] = vec3(sin(iTime*0.3+(PI/3.0))*3.0, 2.0, 6.0);\n    lights[1] = vec3(1.0, 1.0, 0.6)*3.0;\n    \n    lights[2] = vec3(sin(iTime*0.5)*4.0, 2.5+cos(iTime*0.2)*0.4, 3.5+cos(iTime*0.5)*6.0);\n    lights[3] = vec3(1.0, 0.5, 0.0)*4.0;\n    \n    lights[4] = vec3(sin(iTime*0.3+(PI/3.0))*1.0, 3.0, 4.5);\n    lights[5] = vec3(1.0, 1.0, 0.8)*0.6;\n    \n    lights[6] = vec3(sin(iTime*0.5)*1.0, 5.5+cos(iTime*0.2)*1.4, cos(iTime*0.6));\n    lights[7] = vec3(1.0, 0.7, 0.6)*4.0;\n    \n    //lights[4] = vec3(0.0, 5.0+sin(iTime*0.2)*2.0, 2.0);\n    //lights[5] = vec3(0.6, 0.6, 0.8);\n    \n    vec2 pos = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    fragColor = vec4(vec3(getImage(pos)), 1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xt2GRG", "name": "Parking Garage", "author": "Hamneggs", "description": "An empty parking garage, with some architectural mishaps explaining why. I had a whole lot of fun with the camera on this one.", "tags": ["procedural", "raymarching", "distance", "reflections", "night", "lights", "texturing", "fields", "parking", "garage"], "likes": 45, "viewed": 1348, "date": "1430119074", "time_retrieved": "2024-06-20T18:20:14.761756", "image_code": "/**\n * Written by Gerard Geer.\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * \n * Version 1.0\n * Version 1.1 \tOptomized/cleaned up a bit, and did some more documentin'.\n * Version 1.2 \tGave pipes a clear protective coating. (I made them shiny.) \n * \t\t\t\tI also changed some colors.\n * Version 1.3\tFunctioned out determining reflectivity and deflection. This allowed me\n * \t\t\t\tto add some variation in the reflections in the form of puddles\n * \t\t\t\tand a less roof-icured ceiling.\n * Version 1.4\tImplemented mainVR.\n * Version 1.41 Unimplemented mainVR. Sorry guys...\n * Version 1.42 Optimized a small bit, and also added angle dependence for the reflections.\n *\t\t\t\t(Took out one case in the texturing if statements, and remove the branching\n *\t\t\t\tin u().)\n */\n\n// Main marching steps.\n#define V_STEPS 80\n// Shadow marching steps.\n#define R_STEPS 80\n// Maximum successful marching distance.\n#define EPSILON .0005\n// Max possible depth, from corner to corner.\n#define MAX_DEPTH 175.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0); // An up vector.\n\n// Scene object dimensions, modulus repetitions and offsets.\nconst vec3 GARAGE_DIM = vec3(90.,8.,150.);\n#define GARAGE_OFF 4.\t\t/* Along the Y axis. */\n\nconst vec2 PILLAR_DIM = vec2(1.5);\n#define PILLAR_OFF 26.66 \t/* Along the X axis. */\nconst vec2 PILLAR_REP = vec2(26.66,10.);\n\nconst vec3 RAFTER_DIM = vec3(3.,.75,3.);\nconst vec3 RAFTER_OFF = vec3(26.66,7.625,0.);\nconst vec2 RAFTER_REP = vec2(26.66,10.);\n\nconst vec2 BOLLARD_DIM = vec2(.25,2.);\nconst vec2 BOLLARD_OFF = vec2(.05,5.);\n\nconst vec2 PIPES_OFF  = vec2(1.,7.);\n#define PIPES_REP 26.66\t\t/* Along the X axis. */\n#define PIPES_R \t.2\n\nconst vec3 LIGHTS_A   = vec3(-2.,7.825,0.);\nconst vec3 LIGHTS_B   = vec3( 2.,7.825,0.);\n#define LIGHTS_R    .125\nconst vec2 LIGHTS_REP = vec2(13.,10.);\n\n#define PUDDLESCALE .005\n\n// Object IDs. (For texturing and whatnot).\n#define ID_GARAGE \t1.0\n#define ID_PILLAR \t2.0\n#define ID_BOLLARDS 4.0\n#define ID_RAFTER \t8.0\n#define ID_PIPES  \t16.0\n#define ID_LIGHTS \t32.0\n#define ID_WIRES\t64.0\n\n// Texture definition.\n#define NOISE_S iChannel0\n\n// Lighting color.\nconst vec3 LCOLOR = vec3(1.,.95,.95);\t// Light color.\nconst vec3 ACOLOR = vec3(.01, .017, .02);\t// Ambient light color.\n\n// Object base colors.\nconst vec3 PIPECOLOR = vec3(.4,.07,.06);\t// Color of the pipe.\nconst vec3 CLAMPCOLOR = vec3(.7,.675,.6); \t// Color of the pipe brackets.\nconst vec3 PILLARCOLOR = vec3(1.0, 1.0, .1);// Color of pillar paint.\nconst vec3 WALLCOLOR = vec3(.05,.1,.8);\t\t// Wall base paint.\nconst vec3 BOLLARDCOLOR = vec3(1.,1.,0.); \t// Bollard color.\nconst vec3 WIRECOLOR = vec3(.01);\t\t\t// Ceiling wire color.\nconst vec3 LIGHTCOLOR = vec3(1.0);\t\t\t// Lights are always white petty much.\nconst vec3 CAGECOLOR = vec3(.08, .02, .01); // Light caging color.\nconst vec3 PUDDLECOLOR = vec3(.07,.08,.0); // The color of the grit in the puddles.\n\n// Occlusion samples.\n#define OCC_SAMPLES 3.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.\n// Light and reflection penumbra factors.\n#define LPFACTOR 30.0\n#define RPFACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 3.0\n\n/*\n\tA linear Bezier function. I'm going to use the built in mix here\n\tjust in case the vendor interpolation is faster than implementing\n\tit myself.\n*/\nvec3 lb(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n/*\n\tThe first derivative of a linear Bezier function. Ain't a\n\tbuilt in for this. It's also normalized since it's exclusively\n\tused to specify camera direction.\n*/\nvec3 dlb(vec3 a, vec3 b, float t)\n{\n    return normalize( b - a );\n}\n\n/*\n\tA quadratic Bezier function. A more certain benefit of using mix()\n\tis that the recursive nature of a Bezier curve becomes immediately\n\tapparent, and makes the whole concept far easier to understand.\n*/\nvec3 qb(vec3 a, vec3 b, vec3 c, float t)\n{\n\treturn mix( mix(a,b,t), mix(b,c,t), t);\n}\n\n/*\n\tThe first derivative of a quadratic Bezier function.\n*/\nvec3 dqb(vec3 a, vec3 b, vec3 c, float t)\n{\n    return normalize( (2.0-2.0*t)*(b-a) + 2.0*t*(c-b) );\n}\n\n/*\n\tA cubic Bezier function. Mixing in some more mixin mix()s.\n*/\nvec3 cb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn mix(mix(mix(a,b,t), mix(b,c,t),t),mix(mix(b,c,t), mix(c,d,t),t), t);\n}\n\n/*\n\tAgain, a derivative. This time of cubic Bezier function.\n*/\nvec3 dcb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn normalize( 3.0*pow(1.0-t, 2.0)*(b-a) + 6.0*(1.0-t)*t*(c-b)+3.0*pow(t, 2.0)*(d-c) );\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade(in float s, in float e, in float t, in float duration)\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n\n/*\n\tA static camera path for the artsy shots. This one requires an input camera\n\tdirection.\n*/\nvoid s_cam_path(in float s, in float e, in float f,\n                in vec3 a, float t,\n                out vec3 cp, inout vec3 cd, out float shutter)\n{\n    cp = a;\n  \tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a linear Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid l_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = lb(a, b, smoothstep(s, e, t));\n\tcd = dlb(a, b, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a quadratic Bezier curve, based\n\ton start and end times, and start and end positions.\n*/\nvoid q_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = qb(a, b, c, smoothstep(s, e, t));\n\tcd = -cross(dqb(a, b, c, smoothstep(s, e, t)), UP);\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a cubic Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid c_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in vec3 d, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = cb(a, b, c, d, smoothstep(s, e, t));\n\tcd = dcb(a, b, c, d, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tAnimates the camera, choosing a path based on the current time. Also\n\tperforms camera shuttering.\n*/\nvoid animate_cam(in vec2 uv, in float t, out vec3 ro, out vec3 rd, out float shutter)\n{\n\t// \"Yeah I'm not gonna const-out all of those positions.\"\n    vec3 cp, cd;   // Vectors into which we store the camera position/direction.\n\tt = mod(t, 60.); // Restart the camera animation every 60 seconds.\n     //t = 7.3;\n    // Each clause here is a different scene, determined by the current time\n    // into the animation. They are ordered longest-duration-first so the\n\t// conditionals of the most likely clauses are evaluated first, cutting\n\t// down on false comparisons.\n    if(t >= 22.0 && t < 32.0)\t// 10 seconds.\n    {\n        l_cam_path(\t20.0, 32.0, .5, \n\t\t\t\t\tvec3(40., 2., -68.0), vec3(-38., 3., 75.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 46.0 && t < 54.0)\t// 8 seconds.\n    {\n        l_cam_path(\t46.0, 54.0, .5, \n\t\t\t\t\tvec3(17., 5.0, 15.0), vec3(17., 5.0, 45.0), t,\n\t\t\t\t\tcp, cd, shutter);\n        cd = vec3(-0.57735, 0.57735, 0.57735);\n    }\n\telse if(t >= 8.0 && t < 15.0)\t\t// 7 seconds.\n\t{\n\t\tl_cam_path(\t8.0, 15.0, .5, \n\t\t\t\t\tvec3(16., 2., -25.0), vec3(16., 3., 25.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t\tcd = vec3(-0.707107, 0, 0.707107);\n\t}\n   \telse if(t >= 0.0 && t < 5.0)\t// 5 seconds.\n\t{\n\t\tl_cam_path(\t0.0, 5.0, .5, \n\t\t\t\t\tvec3(0.0, 4., -5.0), vec3(0.0, 4., 5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t >= 15.0 && t < 20.0)\t// 5 seconds.\n\t{\n\t\tc_cam_path(\t15.0, 20.0, .5,\n\t\t\t\t\tvec3(5.0, 3., 5.0), vec3(-1.0, 3., 5.0), vec3(1.0, 3., -5.0), vec3(-10.0, 3., -5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n    else if(t >= 32.0 && t < 37.0)\t// 5 seconds.\n    {\n        q_cam_path(\t32.0, 37.0, .5, \n\t\t\t\t\tvec3(-38.0, 1.5, -.075), vec3(-38.1, 1.5, .0), vec3(-38., 1.5, .075), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 42.0 && t < 46.0)\t// 4 seconds.\n    {\n        c_cam_path(\t42.0, 46.0, .5,\n\t\t\t\t\tvec3(10.0, 2., 0.0), vec3(10.0, 2., 10.0), vec3(18.0, 2., 10.0), vec3(18.0, 2., 20.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n\telse if(t >= 5.0 && t < 8.0)\t// 3 seconds.\n\t{\n\t\tq_cam_path(\t5.0, 8.0, .5, \n\t\t\t\t\tvec3(-16.0, 3., -1.1), vec3(-13, 3., 4.0), vec3(-6., 3., -1.1), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n    else if(t >= 39.0 && t < 42.0)\t// 3 seconds.\n    {\n        l_cam_path(\t39.0, 42.0, .5, \n\t\t\t\t\tvec3(22., 1., 22.0), vec3(26., 3.5, 26.0), t,\n\t\t\t\t\tcp, cd, shutter);\n    }\n    else if(t >= 20.0 && t < 22.0)\t// 2 seconds.\n    {\n        cd = vec3(0.995037, -0.0995037, 0.);\n        s_cam_path( 20.0, 22.0, .5,\n                    vec3(-38., 3., 78.0), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 37.0 && t < 39.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.0618984, -0.123797, 0.990375);\n        s_cam_path( 37.0, 39.0, .5,\n                    vec3(14.5, .75, 6.), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 54.0 && t < 56.0)\t// 2 seconds.\n    {\n        cd = vec3(1.,0.,0.);\n        s_cam_path( 54.0, 56.0, .5,\n                    vec3(-24., .5, 6.75), t,\n                    cp, cd, shutter);\n    }\n    else if(t >= 56.0 && t < 58.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.912871, 0.365148, 0.182574);\n        s_cam_path( 56.0, 58.0, .5,\n                    vec3(-3.5, 7.0, 4.), t,\n                    cp, cd, shutter);\n    }\n    else if(t > 58.0 && t < 60.0)\t// 2 seconds.\n    {\n        cd = vec3(-0.408248, -0.408248, 0.816497);\n        s_cam_path( 58.0, 60.0, .5,\n                    vec3(11.5, 7.85, -20.), t,\n                    cp, cd, shutter);\n    }\n\tcamera(uv, cp, cd, 1.0, ro, rd);\n}\n\n/*\n\tUnions two distance functions together, returning\n\tthe ID of and the distance to the nearest.\n*/\nvec2 u(in vec2 a, in vec2 b)\n{\n    // No more branching here!\n    return mix(a,b,step(b.s,a.s));\n}\n\n/*\n\tA non-euclidean length function\n*/\nfloat length8(in vec2 a)\n{\n    return pow(pow(a.x,8.)+pow(a.y,8.), .125);\n}\n\n/*\n\tIQ's signed box distance function. I've edited it\n\tso the box dimensions passed in are manifested\n\tas the complete size of the box, not the distance\n\teach side is from the box's center.\n*/\nfloat box(in vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b*.5;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.));\n}\n\n/*\n\t2D columns for the pillars.\n*/\nfloat box2D(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b*.5;\n    return min(max(d.x, d.y), 0.)+\n        length(max(d,0.));\n}\n\n/*\n\tIQ's signed capsule function.\n*/\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n/*\n\tCylinder distance function. (Also from IQ's \n\tprimitives example, but explicitly horizontal.)\n*/\nfloat cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n\n/*\n\tThe outer box of the garage.\n*/\nfloat garage(in vec3 p)\n{\n\treturn -box(p-GARAGE_OFF, GARAGE_DIM);\n}\n\n/*\n\tThe pillars of the garage.\n*/\nfloat pillars(in vec3 p)\n{\n    // Translate...\n\tp.x -= PILLAR_OFF;\n    // Repeat...\n\tp.xz = mod(p.xz, PILLAR_REP)-.5*PILLAR_REP;\n    // Evaluate.\n\treturn box2D(p.xz, PILLAR_DIM);\n}\n\n/*\n\tThe parking bollards.\n*/\nfloat bollards(in vec3 p)\n{\n    p.yz -= BOLLARD_OFF;\n    p.xz = mod(p.xz, PILLAR_REP)-.5*PILLAR_REP;\n    return cylinder(p, BOLLARD_DIM);\n}\n\n/*\n\tThe rafters of the garage.\n*/\nfloat rafters(in vec3 p)\n{\n\tp -= RAFTER_OFF;\n\tp.xz = mod(p.xz, RAFTER_REP)-.5*RAFTER_REP;\n\treturn box(p, RAFTER_DIM);\n}\n\n/*\n\tA couple pipes that run the length of the garage.\n*/\nfloat pipes(in vec3 p)\n{\n    p.xy -= PIPES_OFF;\n    p.x = mod(p.x, PILLAR_REP.x)-PILLAR_REP.x*.5;\n\treturn length(p.xy)-PIPES_R;\n}\n\n/*\n\tCeiling wires, because all garages have ceiling wires.\n*/\nfloat wires(in vec3 p)\n{\n    p.y -= 7.925;\n    p.xz = mod(p.xz, 1.3)-.65;\n    return min(length(p.xy)-.025, length(p.yz)-.025);\n}\n\n/*\n\tThe lights in the garage.\n*/\nfloat lights(in vec3 p)\n{\n\tp.xz = mod(p.xz, LIGHTS_REP)-.5*LIGHTS_REP;\n    // Fatten up those capsules.\n    p.z *= .25;\n\treturn capsule(p, LIGHTS_A, LIGHTS_B, LIGHTS_R);\n}\n\n/*\n\tA simple distance function.\n*/\nfloat dist(vec3 p)\n{\n    // Oh yeah that nesting right there I'm the king of tiny wings collectables.\n\treturn min(min(min(min(min(pillars(p),wires(p)),bollards(p)),pipes(p)),rafters(p)), garage(p));\n}\n\n/*\n\tA distance function that also returns object ID.\n*/\nvec2 distID(vec3 p)\n{\n\tvec2 r = u( vec2(pillars(p), ID_PILLAR), vec2(rafters(p), ID_RAFTER) );\n\tr = u( r, vec2(garage(p), ID_GARAGE) );\n    r = u( r, vec2(bollards(p), ID_BOLLARDS) );\n    r = u( r, vec2(lights(p), ID_LIGHTS) );\n    r = u( r, vec2(pipes(p), ID_PIPES) );\n    r = u( r, vec2(wires(p), ID_WIRES));\n\treturn r;\n}\n\n/*\n\tA function that uses the tri-planar texturing method\n\tto return a value from a noise texture in 3D space.\n*/\nfloat n3D(in vec3 p, in vec3 n)\n{\n    n = abs(n);\n    return \ttexture(NOISE_S, p.xy).r*n.z +\n        \ttexture(NOISE_S, p.zy).r*n.x +\n        \ttexture(NOISE_S, p.xz).r*n.y;\n}\n\n/*\n\tUses that noise function to generate an FBM.\n*/\nfloat fbm(in vec3 p, in vec3 n)\n{\n\t// I distributed the finishing divide.\n    return  0.57190716*n3D(p*1.1,n)+\n\t\t\t0.28515355*n3D(p*1.9,n)+\n    \t\t0.14297679*n3D(p*4.0,n);\n}\n\n/*\n\tReturns a trial-by-error procedural cement texture.\n\tIt's even that fancy cement with the speckles in it.\n*/\nvec3 cement_tex(in vec3 p, in vec3 n)\n{\n    // Do some scaling...\n    p*=.5;\n    // Make a noise value that has vaguely cement like features, and\n    // cale the brightness so that it looks a bit more like cement.\n    return vec3( .6-pow( fbm( p+fbm(p, n),n ), 3.0 ) );\n}\n\n/*\n\tTakes a pre-existing cement value, and modifies it\n\tto fit the texturing needs of the pillars.\n*/\nvec3 tex_pillars(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    \n    p.xz += p.zx; // So faces in front of each other aren't identical.\n    \n    // Only paint the pillars below y=3.\n    if(p.y < 3.)\n    {\n        // Get a noise value to determine whether or not the given\n        // point on a pillar has paint or is in a flake.\n        //\n        // This decreases the edge contrast of the paint flakes\n        // as distance increases, so you don't have flikery gray\n        // dots on far away pillars.\n        float f  = smoothstep(.7-.15*d, .7+.15*d, fbm(p*.1, n));\n        // Smoothstep will return whether or not the noise value\n        // was greater than the threshold. Here we use that result\n        // to mix between having cement with or without paint.\n        return mix(PILLARCOLOR*cement, cement, f);\n    }\n    else return cement;\n}\n\n/*\n\tReturns a texel of the simple texture for the pipes on the pillars.\n*/\nvec3 tex_pipe(in vec3 p, in float d, in vec3 n)\n{\n    // Do some scaling to align the brackets with the pillars.\n    p.z += 5.5;\n    p.z *= .1;\n    \n    // If the fractional part of the distance along the pipe/z-axis\n    // is below a threshold, return 0, otherwise return 1.\n    float f = step(.1, p.z-floor(p.z));\n    \n    // Create the red foam color for the pipe.\n    vec3 base = PIPECOLOR;\n   \tbase.gb *= fbm(p*5., n);\n    \n    // Mix between bracket or foam.\n    return mix(CLAMPCOLOR,base, f);\n}\n\n/*\n\tReturns a procedural texture for the bollards.\n*/\nvec3 tex_bollards(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    // Simply use the same paint-flaking effect as on the walls and\n    // pillars, but with a different threshold for variety.\n    float f  = smoothstep(.8-.15*d, .8+.15*d, fbm(p*.1, n));\n    return mix(mix(BOLLARDCOLOR,cement,.275), cement, f);\n}\n\n/*\n\tDraws a cage on the lights.\n*/\nvec3 tex_lights(in vec3 p, in float d, in vec3 n)\n{\n    // Do some scaling.\n    p *= 4.;\n    // We do the same thing as with the pipes here. If the\n    // fractional part of the position is less than a threshold,\n    // we return one value, and a different one otherwise,\n    // except we use smoothstep so we can filter based on distance.\n    float f = smoothstep(.1-.5*d, .1+.5*d, p.x-floor(p.x)) \n            * smoothstep(.1-.5*d, .1+.5*d, p.z-floor(p.z));\n    // Mix between the cage and light color.\n    return mix(CAGECOLOR, LIGHTCOLOR, f);\n    if(p.x-floor(p.x)<.2 || p.z-floor(p.z)<.2) return vec3(.1, .025, .01);\n    return vec3(1.);\n}\n\n/*\n\tGenerates the oil stains on the ground. People need to\n\tkeep their cars tuned up. Keep an eye on those gaskets\n\tand bolt torque specifications.\n*/\nfloat tex_stains(in vec3 p, in vec3 n)\n{\n    // Do some janky translation and scaling.\n    p = vec3(p.xz+vec2(11.0, 1.0), p.z);\n    p.xy *= vec2(.125, .4);\n    \n    // Set up repetition.\n\tp.xy = mod(p.xy, vec2(1.75, 2.0))-.5;\n    \n    // The oil spots are just a clamped circle gradient\n    // times a noise value.\n    float spill = clamp(length(p.xy), 0.,1.);\n\treturn clamp(spill+fbm(p*.25, n)*1.35, 0.,1.);\n}\n\n/*\n\tReturns a puddle dirt coefficient. This is keyed with the puddle reflectivity\n\tregions. \n*/\nfloat tex_puddles(in vec3 p, in vec3 n)\n{\n    return mix(1.,.15, smoothstep(.5,.8, fbm(PUDDLESCALE*p, n)));\n}\n\n/*\n\tAh yes, what every parking place needs: lines.\n*/\nfloat tex_lines(in vec3 p, in vec3 n)\n{\n    // Do some translation, scaling and repetition,\n    // and the same \"if we're here, return this, otherwise\n    // send back the other\" jive.\n    p.xz *= vec2(.035, .2);\n    p.xz -= vec2(.17, .5);\n    if(mod(p.x,1.) < .65 && mod(p.z,1.) < .05) return 1.;\n    return 0.;\n}\n\n/*\n\tTextures the walls, floor and ceiling of the garage.\n*/\nvec3 tex_garage(in vec3 p, in float d, in vec3 n, in vec3 cement)\n{\n    // Texture the walls.\n    if(length(n.xz) > .1 && p.y < 2.5)\n    {\n        // That same ol' filtering technique.\n        float f  = smoothstep(.7-.15*d, .7+.15*d, fbm(p*.125, n));\n        return mix(WALLCOLOR*cement, cement, f);\n    }\n    // Put some stains and lines on the floor.\n    if(n.y > .8)\n    {\n        float stains = tex_stains(p, n), \n\t\t\t  lines = tex_lines(p, n), \n\t\t\t  puddles = tex_puddles(p, n);\n        return mix(PUDDLECOLOR, (cement + lines)*stains, puddles);\n    }\n    // Make the ceiling dark like in absolutely all underground garages.\n    if(n.y < -.8)\n    {\n        return cement *.025;\n    }\n    // Oherwise just return the original cement color.\n    else return cement;\n}\n\n/*\n\tReturns a generated texture element given a point in space,\n\tand that point's object ID.\n*/\nvec3 tex(in vec3 p, in vec3 e, in vec3 n, in float id)\n{\n    vec3 cement = cement_tex(p, n);\n    float d = length(p-e)/MAX_DEPTH;\n\tif(id == ID_GARAGE) return tex_garage(p, d, n, cement);\n\telse if(id == ID_PILLAR) return tex_pillars(p, d, n, cement);\n\telse if(id == ID_RAFTER) return cement;  \n\telse if(id == ID_PIPES)  return tex_pipe(p, d, n);\n\telse if(id == ID_LIGHTS) return tex_lights(p, d, n);\n    else if(id == ID_BOLLARDS) return tex_bollards(p, d, n, cement);\n    else return WIRECOLOR;\n\treturn vec3(1.,0.,0.);\n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm(vec3 p)\n{\n    // The math behind this is cool beans.\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction dir\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n\tReturns the object ID of the found object.\n*/\nfloat march(inout vec3 p, vec3 dir)\n{\n\tvec2 r = distID(p+dir*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r.s < EPSILON)\n\t\t\treturn r.t;\n\t\tp += dir*r.s;\n        r = distID(p);\n\t}\n\treturn r.t;\n}\n\n/*\n\tSimple marched reflection that returns the position and object ID of\n\tthe imaged surface.\n*/\nfloat reflection( inout vec3 start, in vec3 ldir, out vec3 finish)\n{    \n\tfloat t = EPSILON;\n\tvec2 iter, res = vec2(1.0);\n    for ( int i = 0; i < R_STEPS; ++i )\n    {\n        finish = start + ldir*t;\n        iter = distID( finish );\n        if ( iter.s < EPSILON*.1 )\n            return iter.t;\n        t += iter.s;\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res.t;\n}\n\n/*\n\tGenerates a reflection deflection map, because no surface in a parking\n\tgarage is perfectly flat.\n*/\nvec2 bumpmap(in vec3 p, in vec3 n, in float id)\n{\n    // The garage floor and ceiling have their own reflectivities.\n    if(id == ID_GARAGE)\n    {\n        // The floor is bumpy, with some smoother spots where puddles are.\n        if(n.y > 0.8)\n        {\n            vec2 bumpy = .5*vec2(fbm(p, n),fbm(-p, n)) - .25;\n\t\t\tvec2 smth = vec2(0.);\n        \treturn mix(bumpy,smth,step(.6, fbm(.005*p, n)));\n        }\n        // The ceiling is bumpy everywhere, but not shiny everywhere, as\n        // handled in the reflectivity function.\n        else if(n.y < -.8)\n            return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;\n        else return vec2(0.);\n    }\n    // The pipes are smoothish.\n    else if(id == ID_PIPES)\n    {\n\t\tp *= .1;\n        return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;\n    }\n    else return vec2(0.);\n}\n\n/*\n\tReturns how reflective a position is.\n*/\nfloat reflectivity(in vec3 p, in vec3 n, in vec3 d, in float id, in float rid)\n{\n    float r = 0.;\n    // The garage floor and ceiling have their own reflectivities.\n    if(id == ID_GARAGE)\n    {\n        // The floor is shinier where puddles are.\n        if(n.y > 0.8)\n        {   \n            // This is keyed with the puddle texture.\n            r = mix(.1,.2, step(.6, fbm(PUDDLESCALE*p, n)));\n        }\n        // The ceiling isn't shiny everywhere.\n        else if(n.y < -.8)\n            r = mix(.0, .075, smoothstep(.3,.7, fbm(.005*p, n)));\n        else r = 0.0;\n    }\n    // The pipes are quite shiny.\n    else if(id == ID_PIPES)\n    {\n        r = .333;\n    }\n    // If we are reflecting the lights, bump up how reflected they are to\n    // mimick the reflection of a light source being brighter than the\n    // rest of the reflected image.\n    if(rid == ID_LIGHTS) r *= 2.0;\n    return r*=pow(length(cross(n,d)),2.0);\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(in vec3 p, in vec3 n)\n{\n\tfloat r = .0;\n    float s = -OCC_SAMPLES;\n    const float u = 1.0/OCC_SAMPLES;\n\tfor(float i = u; i < 1.0; i+=u)\n\t{\n\t\tr += pow(2.0,i*s)*(i-dist(p+i*n));\n\t}\n\treturn clamp(0.,1.,1.0-r*OCC_FACTOR);\n}\n\n/*\n\tSome super fake global illumination.\n*/\nvec3 gi(in vec3 p, in vec3 n, in float id)\n{\n\tvec3 r = vec3(0.);\n\tif(id != ID_PIPES)\n\t{\n\t\tr += PIPECOLOR * pow(max(0., 1.0-pipes(p)),2.0)*.3;\n\t}\n\treturn r;\n}\n\n/*\n\tTakes in a surface and eye position, and calculates an ambient and diffuse\n\tlighting term.\n*/\nvoid light(in vec3 p, in vec3 d, in vec3 e, in vec3 n, in float id,\n\t\t   out float amb, out float dif)\n{\n\tif(id == ID_LIGHTS) amb = 1.0;\n\telse amb = occlusion(p, n);\n   \n\t// Yep! The diffuse term is just the distance to the light.\n    dif = clamp(1.0- pow( lights(p)*.1, 1.5 ), 0., 1.);\n}\n\n/*\n\tShades a point, giving it lighting, reflection and texture.\n*/\nvec3 shade(in vec3 p, in vec3 d, in vec3 e, in float id)\n{\n\tfloat amb, dif;\t // The ambient and diffuse lighting terms.\n    vec3 n,\t\t\t // The surface normal at the first bounce.\n         primary;\t // The primary and secondary colors.\n    \n    n = norm(p);\t// Get the surface normal at the first bounce.\n\tlight(p, d, e, n, id, amb, dif);\t// Light the first bounce.\n    primary = tex(p, e, n, id)*amb*dif*LCOLOR;\t// Texture the first bounce.\n\tprimary += gi(p, n, id);\n\t\n    if((id == ID_GARAGE && abs(n.y) > .8) || id == ID_PIPES)\n    {\n\t\t// The ID of the object in the reflection image.\n\t\tfloat rID;\n\t\t// The reflection's position, normal, direction and color.\n\t\tvec3 rp, rn, rd, secondary;\n\t\t\n\t\t// Create surface features so the reflections aren't pristine.\n        n.xz += bumpmap(p, n, id);\n\t\tn = normalize(n);\n\t\t\n\t\t// Reflect the ray direction through the first surface normal.\n\t\trd = reflect(d, n);\n\t\t// Get that reflection.\n\t\trID = reflection(p, rd, rp);\n\t\t\n\t\t// Get the surface normal at the imaged position.\n\t\trn = norm(rp);\n\t\t// Get the lighting at that point, using the new normal.\n\t\tlight(rp, rd, p, rn, rID, amb, dif);\n\t\t// Get the texture in the reflection.\n\t\tsecondary = tex(rp, p, rn, rID)*amb*dif*LCOLOR;\n        \n        return mix( primary, secondary, reflectivity(p, n, d, id, rID));\n    }\n\t\n\t// Since we weren't on a reflective material we just return the\n\t// first color.\n    else return primary;\n}\n\n/*\n\tFinalizes each pixel, performing tone-mapping and other post-processing \n\teffects.\n*/\nvec3 post(vec2 uv, vec3 c)\n{\n\treturn pow(c, vec3(.4545));\n}\n\n/*\n\tShadertoy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat id, shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n\teye = vec3(pos);\n    \n\tid = march(pos, dir);\n\tcolor = vec4(post(uv,shade(pos, dir, eye, id)), 1.0)*shutter;\n}\n\n/*\n\tThe Shadertoy VR entrypoint.\n*/\n/*\nvoid mainV( out vec4 fragColor, in vec2 fragCoord, \n            in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat id, shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n    // I think this will work.\n    pos += fragRayOri;\n    dir = normalize(dir+fragRayDir);\n    \n\teye = vec3(pos);\n    \n\tid = march(pos, dir);\n\tfragColor = vec4(post(uv,shade(pos, dir, eye, id)), 1.0)*shutter;\n}*/", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2GRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtBGDR", "name": "A Simple Bezier Camera", "author": "Hamneggs", "description": "Gosh darn it I should have learned this way long ago.", "tags": ["bezier", "camera", "curves", "animation"], "likes": 16, "viewed": 289, "date": "1428227956", "time_retrieved": "2024-06-20T18:20:16.883274", "image_code": "/**\n * A simple bezier camera system.\n * Author: Gerard Geer\n * License Creative Commons CC0 1.0 Universal (CC-0)\n */\n// The plane height.\n#define PHEIGHT -.9\n// Radius of the sphere.\n#define SRAD .33\n\nconst vec3 SPOS = vec3(1.1, -.6, -0.2); \t// Sphere position.\nconst vec3 OBSIZE = vec3(.6125, 1, .2);\t\t// Outside door box size.\nconst vec3 IBSIZE = vec3(.5250, .95, .73);\t// Inner door box size.\nconst vec3 IBOFFSET = vec3(.0, -.1, .0);\t// The offset of the inner door box.\n\n// Main marching steps.\n#define V_STEPS 100\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .00025\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t// An Up vector.\nconst vec3 LDIR = vec3(0.408248, 0.816497, -0.408248); // Light direction.\nconst vec3 LCOLOR = vec3(1.0, .875, 0.5);\t// Light color.\nconst vec3 ACOLOR = vec3(.02, .006, .017);\t// Ambient light color.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t// ... and the second as well.\nconst vec3 OTHER = vec3(.33); \t\t\t\t// The other object color.\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define LPFACTOR 30.0\n#define RPFACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 3.0\n\n/*\n\tA linear Bezier function.\n*/\nvec3 lb(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n/*\n\tThe first derivative of a linear Bezier function.\n*/\nvec3 dlb(vec3 a, vec3 b, float t)\n{\n    return normalize( b - a );\n}\n\n/*\n\tA quadratic Bezier function.\n*/\nvec3 qb(vec3 a, vec3 b, vec3 c, float t)\n{\n\treturn mix( mix(a,b,t), mix(b,c,t), t);\n}\n\n/*\n\tThe first derivative of a quadratic Bezier function.\n*/\nvec3 dqb(vec3 a, vec3 b, vec3 c, float t)\n{\n    return normalize( (2.0-2.0*t)*(b-a) + 2.0*t*(c-b) );\n}\n\n/*\n\tA cubic Bezier function.\n*/\nvec3 cb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn mix(mix(mix(a,b,t), mix(b,c,t),t),mix(mix(b,c,t), mix(c,d,t),t), t);\n}\n\n/*\n\tAgain, a derivative. This time of cubic Bezier function.\n*/\nvec3 dcb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn normalize( 3.0*pow(1.0-t, 2.0)*(b-a) + 6.0*(1.0-t)*t*(c-b)+3.0*pow(t, 2.0)*(d-c) );\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade(in float s, in float e, in float t, in float duration)\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n/*\n\tSets up camera direction and position along a linear Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid l_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = lb(a, b, smoothstep(s, e, t));\n\tcd = dlb(a, b, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a quadratic Bezier curve, based\n\ton start and end times, and start and end positions.\n*/\nvoid q_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = qb(a, b, c, smoothstep(s, e, t));\n\tcd = -cross(dqb(a, b, c, smoothstep(s, e, t)), UP);\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a cubic Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid c_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in vec3 d, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = cb(a, b, c, d, smoothstep(s, e, t));\n\tcd = dcb(a, b, c, d, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tAnimates the camera, choosing a path based on the current time. Also\n\tperforms camera shuttering.\n*/\nvoid animate_cam(in vec2 uv, in float t, out vec3 ro, out vec3 rd, out float shutter)\n{\n\t// \"Yeah I'm not gonna const-out all of those positions.\"\n\tvec3 cp, cd;\n\tt = mod(t, 15.0);\n\tif(t > 1.0 && t < 5.0)\n\t{\n\t\tl_cam_path(\t1.0, 5.0, .5, \n\t\t\t\t\tvec3(0.0, .33, -5.0), vec3(0.0, .33, 2.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t > 5.0 && t < 8.0)\n\t{\n\t\tq_cam_path(\t5.0, 8.0, .5, \n\t\t\t\t\tvec3(-7.0, .125, 0.1), vec3(0.0, 0.175, 7.0), vec3(7.0, 0.125, 0.1), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t > 8.0 && t < 15.0)\n\t{\n\t\tc_cam_path(\t8.0, 15.0, .5, \n\t\t\t\t\tvec3(5.0, .33, 5.0), vec3(-1.0, .33, 5.0), vec3(1.0, .33, -5.0), vec3(-5.0, .33, -5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\t\n\tcamera(uv, cp, cd, 1.0, ro, rd);\n}\n\n/*\n\tIQ's signed box distance function.\n*/\nfloat box(in vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0));\n}\n \n/*\n\tA subtraction of two boxes to make a door frame.\n*/   \nfloat door(vec3 p)\n{\n\treturn max(-box(p, IBSIZE), box(p+IBOFFSET, OBSIZE));\n}\n\n/*\n\tIQ's plane distance function.\n*/\nfloat plane(vec3 p)\n{\n\treturn p.y-PHEIGHT;\n}\n\n/*\n\tIQ's sphere distance function.\n*/\nfloat sphere(vec3 p)\n{\n    return length((p-SPOS))-SRAD;\n}\n\n/*\n\tReturns a \"texel\" in a tile texture, whose contrast is reduced by distance.\n*/\nvec3 tile_tex(vec3 p, vec3 e)\n{\n    p *= 2.0;\n    \n    // The tile is absolute value of the difference in the modulo of the x and z terms of the position.\n    float tile = abs(floor(mod(p.x, 2.0)) - floor(mod(p.z, 2.0)));\n    // We add a term to soften the edge with distance for psuedo anisotropic filtering.\n    tile += (length(p-e)/MAX_DEPTH);\n    \n    // Finally we return the mix of the two tile colors, based on the tile difference.\n    return mix( TILEA, TILEB, smoothstep(0.0, 1.0, tile));\n}\n\n/*\n\tA pretty simple distance function combining my door, a plane, and\n\ta sphere.\n*/\nfloat dist(vec3 p)\n{\n\treturn min(min(door(p), plane(p)), sphere(p));\n}\n\n/*\n\tReturns a texture color given a point in space (and an eye coordinate\n\tfor filtering).\n*/\nvec3 tex(vec3 p, vec3 e)\n{\n\t// Only texture the plane.\n    if(plane(p) == dist(p))\n    \treturn tile_tex(p, e);\n\t// If it's not the plane return the other object color.\n    else return OTHER;\n        \n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm(vec3 p)\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction dir\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march(inout vec3 p, vec3 dir)\n{\n\tfloat r = dist(p+dir*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || r > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += dir*r;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in vec3 n, in float p)\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tOren-Nayar reflectance modeling, since I may no longer use Phong after\n\tthe incident with the Mummy's Tiara.\n*/\nfloat orenNayar(in vec3 n, in vec3 v, in vec3 ldir)\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tTakes in a surface and eye position, and calculates an ambient and diffuse\n\tlighting term.\n*/\nvoid light(in vec3 p, in vec3 d, in vec3 e, in vec3 n, out float amb, out float dif)\n{\n\tamb = occlusion(p, n);\n    float prim = shadow(p, LDIR, n, LPFACTOR);\n    float refl = shadow(p, reflect(d, n), n, RPFACTOR);\n    \n    // Go ahead and lambert it up if we're working with the plane.\n    if(dist(p) == plane(p))  dif = clamp(0.0, 1.0, dot(n, LDIR))*mix(prim, refl, .175);\n    // Otherwise stick with O.N.\n    else dif = orenNayar(n, d, normalize(LDIR))*mix(prim, refl, .1);\n}\n\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade(vec3 p, vec3 d, vec3 e)\n{\n    float l = length(p-e);\n    vec3 n = norm(p);\n\tif(l >= MAX_DEPTH) return vec3(0.0);\n\telse\n\t{\n\t\tfloat amb, dif;\n\t\tlight(p, d, e, n, amb, dif);\n\t\treturn tex(p, e)*(LCOLOR*dif + ACOLOR*amb) *(1.0- pow(l/MAX_DEPTH, 2.0));\n\t}\n}\n\n/*\n\tFinalizes each pixel, performing tonemapping and other post-processing \n\teffects.\n*/\nvec3 render(vec2 uv, vec3 c)\n{\n\tc = pow(clamp(c, 0., 1.), vec3(.4545));\n    return c;\n}\n\n/*\n\tShaderToy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n\teye = vec3(pos);\n    \n\tmarch(pos, dir);\n   \tvec3 c = shade(pos, dir, eye);\n\tcolor = vec4(render(uv, c)*shutter, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtBGW1", "name": "Plain metaballs", "author": "such", "description": "https://en.wikipedia.org/wiki/Metaballs", "tags": ["raymarching"], "likes": 0, "viewed": 140, "date": "1428395549", "time_retrieved": "2024-06-20T18:20:16.889378", "image_code": "#define RM_MAX_ITER 40\n#define DISTANCE 4\n#define NBLOBf 3.\n\nconst float eps = 0.01;\n\nvec3 rand3(float co){\n    return fract(sin(co*vec3(12.9898,78.233,43.2311)) * 43758.5453);\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat multisphere(in vec3 p)\n{\n    float x = cos(iTime);\n    \n    const float N = 2.;\n    float l = 0.;\n    float r = 0.3;\n    float r2 = 0.6 + 0.5*sin(1.12*iTime);\n    vec3 f = rand3(1.);\n    for (float i=1.; i<=NBLOBf; ++i)\n    {\n        vec3 q = sin(f*i*iTime);\n        q = (q - 0.5)*1.75;\n        l += 1./(sphere(p-q,r) + r2);\n        //l += 1./distance(p,q);\n    }\n    return 1./l - r2;\n    //return 1./l;\n}\n\nfloat scene(in vec3 p)\n{\n//    float s1 = sphere(p,0.3);\n//    float s2 = sphere(p+vec3(sin(iTime)*1.0,0.,0.),0.5);\n    // return sqrt(s1*s1 + s2*s2);\n//    return min(s1,s2);\n    //return (s1+s2)*0.5;\n    float s3 = multisphere(p);\n//    return min(s1,s3);\n    return s3;\n}\n\n// gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz) - scene(p - ep.xyz);\n    normal.y = scene(p + ep.yxz) - scene(p - ep.yxz);\n    normal.z = scene(p + ep.yzx) - scene(p - ep.yzx);\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    float a = 0.4*iTime;\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    float dist;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        dist = scene(p);\n\t\tt += dist;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    vec3 light1 = vec3(sin(iTime),cos(iTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n\n    float ambient = 0.5;\n    finalColor = vec3(1,0,1) *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n\n    if (dist>eps)\n\t{\n    \tfinalColor = vec3(0,0,0);\n\t}\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-dist) + length(finalColor)));\n    \n    fragColor = mix(vec4(pow(texture (iChannel0,fragCoord/iResolution.xy).r,21.)), fragColor, fragColor.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtBGWh", "name": "Waving Flag With SDF Text", "author": "joeedh", "description": "signed distance field text", "tags": ["text", "signeddistancefield"], "likes": 1, "viewed": 232, "date": "1428351886", "time_retrieved": "2024-06-20T18:20:17.665107", "image_code": "#define TVAL 0.075\n\nfloat vbar(vec2 uv, vec2 p, vec2 s) {\n   float ux = (uv[0]-p[0])/s[0];\n  \n   ux = (1.0 - 2.0*abs(ux-0.5)) * float(uv[0] >= p[0] && uv[0] <= p[0]+s[0] && uv[1] >= p[1] && uv[1] <= p[1]+s[1]);\n    \n   return ux;\n}\n\nfloat vbar_cap(vec2 uv, vec2 p, vec2 s) {\n   float ux = (uv[0]-p[0])/s[0];\n   float uy = (uv[1]-p[1])/s[1];\n   float vis =  float(ux >= 0.0 && ux <= 1.0 && uy >= 0.0 && uy <= 1.0);\n      \n   float l = (1.0 - 2.0*abs(ux-0.5));\n   \n   float t = TVAL/s[1];\n    \n   l = uy > 1.0-t ? 1.0 - 2.0*length(vec2((uy-(1.0-t))*(0.5/t), abs(ux-0.5))) : l;\n   l = uy < t ? 1.0 - 2.0*length(vec2((t-uy)*(0.5/t), abs(ux-0.5))) : l;\n\n   return l*vis;\n}\n\nfloat hbar(vec2 uv, vec2 p, vec2 s) {\n   float ux = (uv[1]-p[1])/s[1];\n  \n   ux = (1.0 - 2.0*abs(ux-0.5)) * float(uv[0] >= p[0] && uv[0] <= p[0]+s[0] && uv[1] >= p[1] && uv[1] <= p[1]+s[1]);\n   \n   return ux;\n}\n\nfloat hbar_cap(vec2 uv, vec2 p, vec2 s) {\n   float ux = (uv[0]-p[0])/s[0];\n   float uy = (uv[1]-p[1])/s[1];\n    \n   float l;\n   float vis = float(uv[0] >= p[0] && uv[0] <= p[0]+s[0] && uv[1] >= p[1] && uv[1] <= p[1]+s[1]);\n    \n   l = (1.0 - 2.0*abs(uy-0.5));\n    \n   float t = TVAL/s[0];\n    \n   l = ux > 1.0-t ? 1.0 - 2.0*length(vec2((ux-(1.0-t))*(0.5/t), abs(uy-0.5))) : l;\n   l = ux < t ? 1.0 - 2.0*length(vec2((t-ux)*(0.5/t), abs(uy-0.5))) : l;\n   \n   return l*vis;\n}\n\nfloat hbar_cap1(vec2 uv, vec2 p, vec2 s) {\n   float ux = (uv[0]-p[0])/s[0];\n   float uy = (uv[1]-p[1])/s[1];\n    \n   float l;\n   float vis = float(uv[0] >= p[0] && uv[0] <= p[0]+s[0] && uv[1] >= p[1] && uv[1] <= p[1]+s[1]);\n    \n   l = (1.0 - 2.0*abs(uy-0.5));\n    \n   float t = TVAL/s[0];\n    \n   l = ux > 1.0-t ? 1.0 - 2.0*length(vec2((ux-(1.0-t))*(0.5/t), abs(uy-0.5))) : l;\n   \n   return l*vis;\n}\n\nfloat arc(vec2 uv, vec2 p, vec2 s, vec2 c, vec2 arc, float rad) {\n   float ux = (uv[0]-p[0])/s[0] -c[0];\n   float uy = (uv[1]-p[1])/s[1] -c[1];\n\n   float vis = float(uv[0] >= p[0] && uv[0] <= p[0]+s[0] && uv[1] >= p[1] && uv[1] <= p[1]+s[1]);\n   float angle = atan(ux, uy);\n   float r = sqrt(ux*ux + uy*uy);\n   float v2 = vis;\n   vis *= max(1.0-abs(r-rad)*9.0, 0.0);\n   vis *= float(angle >= arc[0] && angle <= arc[1]);\n    \n   return vis;\n}\n\nfloat text(vec2 uv) {\n\tfloat l = vbar_cap(uv, vec2(0.025, -0.15), vec2(0.15, 0.85));\n    float l2 = hbar_cap1(uv, vec2(0.12, 0.5), vec2(0.5, 0.15));\n    float l3 = arc(uv, vec2(0.1, 0.1), vec2(0.5, 0.5), vec2(0.3, 0.7), vec2(-3.141, 5.141), 0.5);\n    \n    float ret = l+l2 - l*l2*1.43;\n    ret = ret+l3 - ret*l3*1.3;\n    \n    //ret = l3;\n    //ret = smoothstep(0.7, 0.65, ret);\n    float sfac = -length(uv-vec2(100, 100))*20.0 + iTime*10.0;\n    \n    float dt = (sin(sfac)*0.5+0.5)*0.4 + 0.3;\n    float dt2 = (sin(sfac)*0.5+0.5)*0.4 + 0.1;\n    \n    dt = 0.7;\n    dt2 = 0.1;\n    float r1 = smoothstep(dt2, dt2-0.05, ret);\n    ret = r1 + (1.0 - smoothstep(dt, dt-0.03, ret));\n    \n    /*\n    float sin2 = (sin(sfac)*0.5+0.5)*0.4+0.3;\n    float scale = 0.0675;\n    \n    if (uv[0] > 0.6+sin2*scale)\n    \treturn 0.0;\n    if (uv[0] < -0.07+sin2*scale)\n    \treturn 0.0;\n    if (uv[1] < -0.1+sin2*scale)\n    \treturn 0.0;\n    if (uv[1] > 0.65+sin2*scale)\n    \treturn 0.0;\n    return ret*0.3 + ret*sin2;\n    */\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv[1] *= 0.6;\n    uv[1] -= 0.1;\n    uv[0] -= 0.1;\n    uv *= 1.5;\n\n    float t = iTime/10.0;\n    vec2 scent = 10.0 + vec2(sin(t) - cos(t), sin(t)+cos(t))*100.0;\n    float phasefac = cos(iTime*0.00105);\n    phasefac = phasefac*0.5+0.5;\n    phasefac *= 1.0;\n    \n    float sfac = -length(uv-scent)*20.0;\n    sfac += iTime*10.0*phasefac;\n    \n    float sin2 = (sin(sfac)*0.5+0.5)*0.4+0.3;\n    float scale = 0.0375;\n    \n    float tfac = uv[1];\n    \n    scale *= 1.0-tfac; //length(vec2(uv[0], 1.0-uv[1]));\n    \n    uv[0] += sin2*scale;\n    uv[1] += sin2*scale;\n    \n    //uv[0] -= uv[1]*0.05;\n    float l = text(uv);\n    float vis = float(uv[0] >= -0.05 && uv[0] <= 0.65 && uv[1] >= -0.1 && uv[1] <= 0.7);\n    \n    sin2 = sin2*1.5 - 0.2;\n    if (sin2 > 1.0) sin2 = 1.0;\n    \n    sin2 = sin2 + (1.0 - sin2)*tfac;\n    sin2 *= vis;\n   \t\n    \n\tfragColor = vec4(l*sin2, l*sin2*0.5 + 0.5*sin2, l*sin2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtBGzV", "name": "jump scare", "author": "binnie", "description": "forked from https://www.shadertoy.com/view/MtjGDm", "tags": ["noob", "squircle"], "likes": 1, "viewed": 1441, "date": "1430244789", "time_retrieved": "2024-06-20T18:20:17.665107", "image_code": "#define PI\t\t\t\t3.1415926535\n#define EPS\t\t\t\t0.005\n#define SQUIRCLES       10\n\n// Math tools\nfloat parabole( float x, float k )\n{\n    return pow( 3.8*x*(1.005-x), k );\n}\n\n// Squircle tools\nbool isSquircle(vec2 center, float r, vec2 uv, inout vec3 outColor)\n{\n    bool yes = false;\n    float ratio = iResolution.x/iResolution.y;\n    float power = 4.0;\n    \n    float A = (uv.x - center.x)*ratio;\n    float B = (uv.y - center.y);\n    \n    \n    if(pow(r, 4.0)*ratio > (pow(A, power)+pow(B, 4.0)))\n    {\n        yes = true;\n        outColor = vec3(tan(center.y), \n                        tan(center.x), \n                        tan(center.x));\n    }\n    \n    return yes;\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // inital color\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n\tfloat k = 7.0;\n    float test = parabole(uv.x, k);\n    \n    // draw parabole\n    //if( abs(uv.y-test)<EPS)\n    //{\n    //    color = vec3(0.);\n    //}\n    \n    // draw squircle (s)\n    for (int i=0; i<SQUIRCLES; i++)\n    {\n        vec2 center;\n        center.x = (tan(iTime + 1.0 * float(i+1))+PI/2.0)/PI ;\n        center.y = parabole(center.x, k);\n\n        float r = 0.05;\n\n        if(isSquircle(center, r, uv, color))\n        {\n            color.x += 0.025*float(i);\n            color.y += 0.05*float(i);\n            color.z += 0.1*float(i);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xtj3Dm", "name": "Artistic shading", "author": "nimitz", "description": "Wipe left/right for Standard PBR vs Artistic shading, wipe up/down for ripeness.", "tags": ["3d", "raymarched", "shading", "bumpmapping", "aa", "pbr", "tasty", "artistic", "tomato"], "likes": 74, "viewed": 5749, "date": "1429879632", "time_retrieved": "2024-06-20T18:20:19.331942", "image_code": "// Artistic shading by nimitz (twitter: @stomroid)\n// https://www.shadertoy.com/view/Xtj3Dm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tIdea from \"Kawacy\" (@kawanocy) http://kawacy.deviantart.com/art/Normal-vs-my-shading-526828438\n\t\n\tUsing n.l to change the Hue, Saturation and value of the material color/properties of the scenes\n\tthis is not physically correct, but produces some interesting coloring.\n\n\tAlso using a few other tricks to make the render nicer, AA form eiffie, shadows and AO inspired\n\tby iq, PBR math from epic games, hemispherical lights for bounce light apprixomation, bump mapping, \n\tdomain folding, and sRGB gamma.\n*/\n\n#define ITR 120\n#define FAR 30.\n#define time iTime\n\nconst float fov = 1.5;\n\nfloat dfog = 0.;\nfloat matid = 0.;\nvec2 mous = vec2(0.);\nfloat pxx =0.;\n\n//----------------------------Utility----------------------------\n\n//iq's ubiquitous 3d noise\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat sbox(in vec3 p, in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 foldPent(in vec2 p)\n{\n    p.x = abs(p.x);\n    const vec2 pl1 = vec2(0.809, 0.5878);\n    const vec2 pl2 = vec2(-0.309, 0.951);\n   \tconst vec2 pl3 = vec2(-0.809, 0.5878);\n    p -= pl1*2.*min(0., dot(p, pl1));\n    p -= pl2*2.*min(0., dot(p, pl2));\n    p -= pl3*2.*min(0., dot(p, pl3));\n    return p;\n}\n\nfloat cyl(in vec3 p, in vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin(in float a, in float b)\n{\n    float k = .15;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------------------------\n\nfloat map(in vec3 p)\n{\n    float r =length(p);\n    vec2 sph = vec2(acos(p.y/r), atan(p.x, p.z));\n    \n    matid = 1.;\n    float d = r-1.; \n    d += sin(sph.y*7.)*0.02;\n    d += sin(sph.y*20.)*0.002;\n    float gbh = sin((sph.x+sph.y)*7.+0.5)*0.5+0.5;\n    d += sin(sph.y*40.)*0.001*gbh;\n    d += sin(sph.x*1.85+2.7)*0.3;\n    \n    //Leaves\n    vec3 p2 = p;\n    float rxz2 = dot(p.xz,p.xz);\n    float rxz = sqrt(rxz2);\n    rxz = exp2(rxz*6.-5.);\n    p2.xz = foldPent(p2.xz);\n    p2.y -= sqrt(rxz)*0.17 + sin(rxz*2.+p.z*p.x*10.)*0.05;\n    float leaves = sbox(p2+vec3(0,-.92-smoothstep(-0.01,.05,rxz2)*0.05,0),vec3(.07- rxz*0.1,0.002+p2.x*0.15,0.8));\n    leaves = smin(leaves, cyl(p+vec3(sin(p.y*3.5 + 0.8)*0.3 + 0.3,-1.1,0),vec2(.05,.25))); //Tail\n    if (leaves < d)matid = 2.;\n    d = min(d, leaves);\n    \n    float flor = p.y+.65;\n    if (flor < d)matid = 0.;\n    d = min(d, flor);\n    return d;\n}\n\nvec3 normal(in vec3 p, in vec3 rd)\n{\n    vec2 e = vec2(-1., 1.)*2e-5;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy));   \n}\n\nfloat getAO(in vec3 pos, in vec3 nor)\n{\n\tfloat rz = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i);\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos);\n        rz += -(dd-hr)*sca;\n        sca *= 0.8;\n    }\n    return clamp(rz*-3.+1., 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax, in float sft)\n{\n\tfloat rz = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        rz = min(rz, sft*h/t);\n        t += clamp(h, 0.01, .1);\n        if(h<0.0001 || t>tmax) break;\n    }\n    return clamp(rz, 0.0, 1.0);\n}\n\nfloat bnoise(in vec3 p)\n{\n    p*= 2.5;\n    float n = noise(p*10.)*0.8;\n    n += noise(p*25.)*0.5;\n    n += noise(p*45.)*0.25;\n    return (n*n)*0.004;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.007,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n    \nvec3 lgt = normalize( vec3(-.05, .19, -0.11) );\nvec3 lcol = vec3(1.,1.,1.);\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//PBR math from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd, in float dst)\n{\n    vec3 nor = normal(pos,rd);\n  \tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n    float ripe = smoothstep(0.2,2.2,(mous.y + noise(pos*1.5)))*0.22;\n    vec3 albhsv = vec3(0.003+ripe, .99-ripe*0.5,.5);\n    float nz = (noise(pos*150.)-0.5)*0.035; //Skin imperfections\n    albhsv.z += nz;\n    albhsv.y -= nz;\n    vec3 f0hsv = vec3(0.01,.5,.15);\n    float soft = 2.;\n    float rough = 0.5;\n\tfloat mtid = matid;\n    if (matid == 0.) //floor/walls\n    {\n        albhsv = vec3(1.,.0,1.);\n        soft = 8.;\n    } \n    else if (matid == 2.) //Leaves/Tail\n    {\n        float nz2 = noise(pos*17.)*0.8;\n        nz2 += noise(pos*70.)*0.8;\n        \n        nor = bump(pos,nor,dst);\n        nl = clamp(dot(nor,lgt), 0., 1.);\n        albhsv = vec3(.25 + nz2*0.07 - (1.-mous.y)*0.05, .9,.35- nz2*0.15 - (1.-mous.y)*0.08);\n        rough = 0.7;\n    }\n    \n    //Artistic shading\n    float stp = step(mous.x,pxx);\n    albhsv.x += ((nl-.7)*0.08)* stp; //Hue variation\n    float vari = sin(nl*6.28*0.5-1.5708);\n    albhsv.y += vari*0.1*stp; //Saturation variation\n    albhsv.z += vari*0.12*stp; //Value variation\n    //albhsv.z += sin(nl*6.28*1.+3.14159)*0.13*stp; //Can be higher freqency\n    \n    vec3 alb = hsv2rgb(albhsv);\n    vec3 f0 = hsv2rgb(f0hsv);\n    \n\tvec4 col = vec4(0.);\n    \n    if (nl > 0.)\n    {\n        nl *= shadow(pos, lgt, 0.01,2.5, soft)*0.9+0.1;\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = rough*rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2/(3.14159*dnm*dnm);\n        float k = pow(rough + 1., 2.)/8.; //hotness reducing\n\t\tfloat G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));\n        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh); //exp2 \"optimization\"\n        vec3 spec = nl*D*F*G;\n        col.rgb = lcol*nl*(spec + alb*(1. - f0));\n        col.a = nl;\n    }\n    \n    float h = clamp(pos.y*2.+.85,0.01,1.);\n    \n    //Hemispherical bounce lights (GI fakery)\n    float bnc = clamp(dot(nor, normalize(vec3(lgt.x,0.0,lgt.z)))*.5+0.28,0. , 1.);\n    col.rgb += lcol*alb*bnc*0.25 *h* (1.-col.a);\n    float bnc2 = clamp(dot(nor, vec3(-lgt.x,lgt.y,-lgt.z))*.5+0.28,0. , 1.);\n    col.rgb += lcol*alb*bnc2*0.1 *h* (1.-col.a);\n    \n    col.rgb += 0.02*alb;\n   \tcol *= getAO(pos,nor);\n    return col.rgb;\n}\n\n//From eiffie: https://www.shadertoy.com/view/XsSXDt\nvec3 marchAA(in vec3 ro, in vec3 rd, in vec3 bgc, in float px)\n{\n    float precis = px*.01;\n    float prb = precis;\n    float t=map(ro);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0,d=0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n\t\td=map(ro+rd*t);\n\t\tif(df==100.0)\n        {\n\t\t\tif(d>od)\n            {\n\t\t\t\tif(od<px*(t-od))\n                {\n\t\t\t\t\tdf=od; tf=t-od;\n                    t += .05;\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tt+=d;\n\t\tif(t>FAR || d<precis)break;\n\t}\n\tvec3 col=bgc;\n    \n\tif(dm<px*tm)\n        col=mix(shade((ro+rd*tm) - rd*(px*(tm-dm)) ,rd, tm),col,clamp(dm/(px*tm),0.0,1.0));\n\t\n    float qq=0.0;\n    if((df==100.0 || tm==tf) && t < FAR)\n    {\n        ro+=vec3(0.5,0.5,0.)*px*tm*1.;\n        tf=tm;\n        df=dm;\n        qq=.01;\n\t}\n    dfog = tm;\n    return mix(shade((ro+rd*tf) - rd*(px*tf-df),rd, tf),col,clamp(qq+df/(px*tf),0.0,1.0));\n    \n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float px= 1.5/(iResolution.y*fov);\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    pxx = q.x;\n    vec2 p = q - 0.5;\n\tfloat asp =iResolution.x/iResolution.y;\n    p.x *= asp;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.5,0.1):mo;\n    mous = mo;\n\t\n    vec3 ro = vec3(0., 0., 4.5+sin(time*0.2)*0.5);\n    vec3 rd = normalize(vec3(p,-fov));\n    \n    mat3 cam = rot_x(0.4+sin(time*0.7)*.1)*rot_y(sin(time*0.35)*1.3+4.);\n    ro *= cam;rd *= cam;\n    \n    vec3 bg = vec3(1.);\n    vec3 col = vec3(0);\n    \n    col = marchAA(ro, rd, bg, px);\n    \n    col = clamp(col, 0.,1.);\n    \n    col = mix(col, bg, smoothstep(FAR-20.,FAR, dfog)); //Distance fog\n    col *= smoothstep(0.,.005,abs(mous.x-pxx));//Separator\n\tcol = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //sRGB\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.85+0.15; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtj3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xtj3DW", "name": "Twisted Rings", "author": "poljere", "description": "Lots of rings reacting and dancing with the music. If you do not have a mic you can select any sound in the iChannel0 and it will also react to it  *** Chrome/Firefox only. Sorry Safari and IE ***", "tags": ["2d", "sound", "music", "mic"], "likes": 42, "viewed": 6377, "date": "1429548830", "time_retrieved": "2024-06-20T18:20:19.337986", "image_code": "// Created by Pol Jeremias - pol/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SOUND_MULTIPLIER 2.0\n\nfloat drawCircle(float r, float polarRadius, float thickness)\n{\n\treturn \tsmoothstep(r, r + thickness, polarRadius) - \n        \tsmoothstep(r + thickness, r + 2.0 * thickness, polarRadius);\n}\n\nfloat sin01(float v)\n{\n\treturn 0.5 + 0.5 * sin(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float rstandard = SOUND_MULTIPLIER * texture( iChannel0, vec2(0.1, 0.0) ).x;\n    \n    // Center the coordinates and apply the aspect ratio\n    vec2 p = uv - vec2(0.5) + vec2(0.05, 0.05) * rstandard;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Calculate polar coordinates\n    float pr = length(p);\n    float pa = atan(p.y, p.x); // * 3.0 / 3.14;\n    \n    // Retrieve the information from the texture\n    float idx = (pa/3.1415 + 1.0) / 2.0;   // 0 to 1\n    float idx2 = idx * 3.1415;             // 0 to PI\n    \n    // Get the data from the microphone\n    vec2 react = sin(idx2) * SOUND_MULTIPLIER * texture( iChannel0, vec2(idx, 0.0) ).xy;    \n    \n    // Draw the circles\n    float o = 0.0;\n    float inc = 0.0;\n    \n    for( float i = 1.0 ; i < 8.0 ; i += 1.0 )\n    {\n        float baseradius = 0.3 * ( 0.3 + sin01(rstandard + iTime * 0.2) ); \n        float radius = baseradius + inc;\n\n        radius += 0.01 * ( sin01(pa * i + iTime * (i - 1.0) ) );\n        \n    \to += drawCircle(radius, pr, 0.008 * (1.0 + react.x * (i - 1.0)));\n        \n        inc += 0.005;\n    }\n    \n    // Calculate the background color    \n    vec3 bcol = vec3(1.0, 0.22, 0.5 - 0.4*p.y) * (1.0 - 0.6 * pr * react.x);\n    vec3 col = mix(bcol, vec3(1.0,1.0,0.7), o);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtj3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtS3zG", "name": "Test-shader", "author": "FlorianDuf", "description": "Created as part of my course-work.", "tags": ["procedural", "lave"], "likes": 0, "viewed": 105, "date": "1429785425", "time_retrieved": "2024-06-20T18:20:21.404773", "image_code": "// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n\n// Noise ------------------------------------------------------------\n\n\n// hash simple avec un seed = 43758.5453123\n// n : le float a hasher\n// return un nombre hash\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// hash simple\n// n : le float a hasher\n// seed : la graine d'alatoire\n// return un nombre hash\nfloat hash( float n, float seed ) { return fract(sin(n)*seed); }\n\n// gnration d'un bruit (point par point)\n// x est la position du point sur le bruit\n// return : la valeur du piont dans le bruit\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// gnration d'un bruit (point par point)\n// x est la position du point sur le bruit\n// seed : la graine d'alatoire\n// return : la valeur du piont dans le bruit\nfloat noise(in vec3 x, in float seed) {\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0, seed), hash(n+  1.0, seed),f.x),\n                   mix( hash(n+157.0, seed), hash(n+158.0, seed),f.x),f.y),\n               mix(mix( hash(n+113.0, seed), hash(n+114.0, seed),f.x),\n                   mix( hash(n+270.0, seed), hash(n+271.0, seed),f.x),f.y),f.z);\n}\n\n\n// Noise adoucit ------------------------------------------------------------\n\n\n// matrice : filtre pour le flou\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// gnration d'un bruit doux\n// p est la position du point sur le bruit\n// return : la valeur du point dans le bruit adoucit\nfloat smooth_noise(vec3 p) {\n\n    float v;\n    vec3 q = 8.0*p;\n    v  = 0.5000*noise( q ); q = m*q*2.01;\n    v += 0.2500*noise( q ); q = m*q*2.02;\n    v += 0.1250*noise( q ); q = m*q*2.03;\n    v += 0.0625*noise( q ); q = m*q*2.01;\n\n    return v;\n}\n\n// gnration d'un bruit doux\n// p est la position du point sur le bruit\n// seed : la graine d'alatoire\n// return : la valeur du piont dans le bruit adoucit\nfloat smooth_noise(vec3 p, in float seed) {\n\n    float v;\n    vec3 q = 8.0*p;\n    v  = 0.5000*noise( q , seed); q = m*q*2.01;\n    v += 0.2500*noise( q , seed); q = m*q*2.02;\n    v += 0.1250*noise( q , seed); q = m*q*2.03;\n    v += 0.0625*noise( q , seed); q = m*q*2.01;\n\n    return v;\n}\n\n\n\n\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 noire=vec3(0.0,0.0,0.0);\nconst vec3 blanc=vec3(1.0,1.0,1.0);\nconst vec3 dgris=vec3(0.1,0.1,0.1);\nconst vec3 gris=vec3(0.3,0.3,0.3);\nconst vec3 lgris=vec3(0.7,0.7,0.7);\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 orange=vec3(1.0,0.4,0.0);\nconst vec3 yellow=vec3(1.0,1.0,0.0);\nconst vec3 bleu=vec3(0.5,0.5,1.0);\nconst vec3 cyan=vec3(0.5,0.8,1.0);\nconst vec3 violet=vec3(0.5,0.0,1.0);\n\nfloat M_PI = 3.141592;\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(red,yellow,v);\n}\n\n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(14.0*sqrt(dot(pa,pa))));\n    return mix(red,yellow,v);\n}\n\n// lave\nvec3 lava(in vec3 p, in  vec3 n)\n{\n    float temperature = 1.; // plus temperature est faible la lave est \"solide\"\n    \n    float v = smooth_noise(p);\n\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    v=0.5*(1.0+cos(v*8.0*sqrt(dot(pa,pa))));\n    \n    if(v != 0.) // on vite la division pas 0\n    \tv = abs(temperature/v);\n    else\n        v = 1.;\n    \n    return mix(noire,orange,v);\n}\n\n// rouille \nvec3 rouille(in vec3 p, in  vec3 n)\n{\n\n    float noise  = smooth_noise(1.5*p);\n    float v = max(exp(abs(sin(noise*5.0)*cos(noise*5.0))) - 0.90, 0.4*noise);\n    \n    if(v <  0.5*noise)\n        return mix(1.2*orange, noire, noise);\n    return 0.8*cyan* v;\n\n}\n\n// fumee = le noise adoucit\nvec3 fumee(in vec3 p, in  vec3 n)\n{\n\n    float v = smooth_noise(p);\n    return mix(noire,blanc,v);\n\n}\n\n// mars\nvec3 mars(in vec3 p, in  vec3 n)\n{\n\n    float v = smooth_noise(p);\n    v =abs(sin(p.x+v*5.0)*cos(p.y+v*5.0));\n\n    if(v < 0.5)\n        v*= 0.5;\n\n    return mix(mix(dgris,noire,sqrt(v)), orange,1.2*smooth_noise(p));\n\n}\n\n// marbre\nvec3 marbre(in vec3 p, in  vec3 n) {\n    \n    float param = 0.4; // augmente ou diminue le nombre de rainure\n\t\n    float noise  = smooth_noise(param*p);\n    \n    float v = 0.5 - sqrt(abs(sin(2. * 3.141592 * noise)));\n    return mix(blanc, lgris, v);\n}\n\n// nuage\nvec3 nuage(in vec3 p, in  vec3 n) {\n    \n    float taille_nuage = 0.4; // plus le nombre est grand, plus les nuages sont petits\n\n    float noise  = smooth_noise(taille_nuage*p);\n\n    float v = 0.5 - abs(fract(noise + 0.2 * noise));\n\n   \treturn mix(cyan*1.5,blanc*2., 2.0*v);\n\n\n}\n\n// metal bross\nvec3 metalbrosse(in vec3 p, in vec3 n) {\n    \n    float facteur_l = 3.5; // modifie l'espace entre les \"lignes\"\n    float frequence = 0.5;\n    float noise1 = smooth_noise(frequence*p + p.y * facteur_l);\n    float noise2  = smooth_noise(frequence*p+p.y* facteur_l, 656565656.56565);\n    float noise3  = smooth_noise(frequence*p+p.y* facteur_l,13756359.7428651);\n\n    noise1 = 1.0-sqrt(noise1);\n    noise2 = 1.-sqrt(noise2);\n    noise3 = 1.-sqrt(noise3);\n    \n    return mix(gris, mix(blanc, mix(gris, lgris, noise1), noise2), noise3);\n\n}\n\n// foudre\nvec3 foudre(in vec3 p, in  vec3 n) {\n    \n    \n    float frequence = 0.2;\n    float noise  = smooth_noise(frequence*p);\n\n    float v = 0.5 - sqrt(abs(sin(2. * 3.141592 * noise)));\n\n   \treturn mix(mix(noire*2.,cyan*2., 2.0*v),2.0*violet, v);\n}\n\n// bois\nvec3 bois(in vec3 p,in vec3 n)\n{\n    \n    float distortion = 2.; // plus c'est grand plus la perturbation aura d'impact\n    \n    float phi = asin(p.z);\n    float teta = atan(p.y,p.x) + M_PI;\n    \n    float phi2 = 0.; // modifier phi2 et teta2 permet de modifier la position du centre de l'ecorse\n    float teta2 = 0.;//255;165;79\n    \n    vec3 brown = vec3(255./255.,165./255.,79./255.), dark = vec3(139./255.,90./255.,43./255.);\n    \n    float dist = acos(cos(phi)*cos(phi2)*cos(teta-teta2)+sin(phi)*sin(phi2))*10.;\n    float noises = smooth_noise(p)*distortion;\n\treturn mix(brown,dark,sin(5.*(dist+noises)));\n}\n\n// terre\nvec3 earth(in vec3 p, in vec3 n){\n    \n    float frequence = 0.5; // modifie la taille des \"terres\"\n    \n    float noises = smooth_noise(p*frequence);\n    vec3 grass = vec3(0.,1.,0.);\n    vec3 couleur;\n    vec3 ocean = vec3(0.,0.,1.);\n    vec3 mountain = vec3(1.,0.,0.);\n    vec3 deep = vec3(0.,0.,0.);\n    vec3 snow = vec3(1.,1.,1.);\n    \n    float phi = asin(p.z);\n    float teta = atan(p.y,p.x) + M_PI;\n\n    \n    if(p.y > (1.4 * smooth_noise(p/4.))) {\n     \t  return snow;\n    }\n    \n    else if(p.y < -(1.4 * smooth_noise(p/4.))) {\n     \t   return  snow;\n    }\n    else if (noises<0.45){\n        return mix(mountain,grass,pow(noises/0.45,2.));\n    }\n    else\n        return mix(ocean,deep,pow((noises-0.45)/0.55,2.));\n    \n    \n}\n\n// terre avec nuages et la nuit\nvec3 nuage_earth(in vec3 p, in  vec3 n) {\n    \n    vec3 dark = vec3(0.,0.,0.);\n    \n    float frequence = 1.5; // ou taille des nuages\n\n    float noise  = smooth_noise(frequence*p);\n\n    float v = 0.5 - abs(fract(noise + 0.2 * noise));\n\n   \tvec3 jour =  mix(earth(p,n),vec3(1.,1.,1.), 4.0*v);\n\n    float nuit = 0.;\n    \n   \tif(p.x > 0.)\n    \tnuit = 0.75;\n    \n\treturn mix(jour,dark,nuit);\n}\n\n// granit\nvec3 granit(in vec3 p, in vec3 n){\n    \n    float frequence = 6.; // modifier la frequence permet de rendre les dtails petits ou grand\n    float seuil_noir=0.3; // change l'aspect du granite (le niveau de noir change)\n    \n    float noi = smooth_noise(frequence*p);\n    if (noi>seuil_noir){\n        float noi2 = 1.5*smooth_noise(frequence*p);\n        return vec3(noi2);\n    }\n    else\n\t\treturn vec3(0.,0.,0.);\n}\n\n//balle de tennis\nvec3 tennis(in vec3 p, in vec3 n){\n   \tif(abs(p.x*p.x-p.y*p.y - 2.* 0.1 * p.z) < 0.1)\n    \treturn vec3(1.,1.,1.);\n    return vec3(1.,1.,0.);\n}\n\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n    vec3 oc = o-c;\n\n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n\n    if (t<=0.0) return false;\n\n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n\n    // Normal\n    n=(o+t*d-c)/r;\n\n    return true;\n}\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n\n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)*dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*lava(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n    return c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n\n    // Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    vec3 d = normalize(vec3(uv, 1.0));\n\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n\n    vec3 n;\n    float t;\n\n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtSGDz", "name": "colour blobs with glitch", "author": "ballzac", "description": "Just learning at the moment. Put together this abstract pattern mostly using sinusoidal functions, with a glitch pattern added using square waves that invert the colours.", "tags": ["2d", "abstract", "glitch"], "likes": 1, "viewed": 152, "date": "1427961077", "time_retrieved": "2024-06-20T18:20:21.707945", "image_code": "\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool glitch = true;//enables 'glitch' effect\n    float time = iTime;\n    \n    /*Move and scale coordinate system*/\n    vec2 offset = vec2(0.5*(sin(time/1.)+1.),0.5*(sin(time/3.)+1.));\n    float scale = 100.*cos(time/25.)*cos(time/25.)+100.;\n    float scale2 = 50.*cos(time/21.)*cos(time/21.)+2.;\n\tvec2 uv_temp = (fragCoord.xy / (iResolution.xy)-offset)*sin(time/scale)*scale2;\n    vec2 uv = vec2( uv_temp.y*sin(time/(scale*2.)),-uv_temp.x*cos(time/(scale*2.)));\n    \n    /*create 'phase-like' colour distributions*/\n    float phib = (sin(time)*uv.y-cos(time)*uv.x)/(uv.x*uv.x+uv.y*uv.y)/2.0+0.5;\n    float phir = (-sin(time)*uv.y-cos(time)*uv.x)/(uv.x*uv.x+uv.y*uv.y)/2.0+0.5;\n    float phig = sin(time)*sin(time)*(sin(uv.x)/uv.x)*(sin(uv.x)/uv.x);\n\t\n    /*modulate using sinusoidal functions*/\n    vec4 result = 5.0*(vec4(phir,phig,phib,1)*sin(uv.x+time)+vec4(phir,phig,phib,1)*sin(uv.y-time))\n        +sin(uv.x-3.0*time)*cos(uv.y+3.0*time)/2.0+0.5;\n    \n    /*add glitch effect*/\n    float blend = sin(time/12.0)*sin(time/10.0*cos(time/3.0))*(1.0-(sin(uv.x-0.5)/(uv.x-0.5))*(sin(uv.x-0.5)/(uv.x-0.5)))*2.0;\n    if( glitch && mod(uv.x+sin(time/10.0)*time/1000.0,sin(time)*sin(time)*0.05) < 0.01 && mod(uv.y+time/10.0,0.05+cos(time/2.0)/(time/2.0)) < 0.01 ) \n        result = vec4(1.0,1.0,1.0,1.0)*blend+result*(1.0-blend);\n    \n    \n    result*=(result.x-(result.y+result.z))*(result.x-(result.y+result.z));\n    \n    /*insert bands into black and white regions*/\n    if( result.x >1. && result.y >1. && result.z > 1. )\n        result = vec4(1.,1.,1.,1)*(sin(uv.x));\n    else if( result.x <0. && result.y <0. && result.z <0. )\n    \tresult = sin(uv.y)*vec4(1.,1.,0.,1.)+cos(uv.y)*vec4(0.,0.,1.,0.);\n    \n    /*soften origin*/    \n    result *= sqrt(uv.x*uv.x+uv.y*uv.y);\n    \n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtSGRV", "name": "Prism Break", "author": "Virgill", "description": "Effects from \"Prism Break\" 4k intro by Virgill / Alcatraz              \nFull Intro here:\nwww.pouet.net/prod.php?which=65359\nwww.youtube.com/watch?v=8UYrJoCsYEY", "tags": ["3d", "raymarching", "demoscene", "glass"], "likes": 69, "viewed": 4226, "date": "1430212092", "time_retrieved": "2024-06-20T18:20:23.362300", "image_code": "// Prism Break\n// an Alcatraz 4K intro \n\n// www.pouet.net/prod.php?which=65359\n// www.youtube.com/watch?v=8UYrJoCsYEY\n\n\n// Jochen \"Virgill\" Feldkoetter\n\n//*****************************************************\n\n// change effect number:\n\t\t\t\t\t\nint ef = 1;\t\t// Effekt\n\n// ef=0 : boxes\n// ef=1 : menger sponge\n// ef=2 : singlebox\n// ef=4 : menger sponge + box\n\n//***************************************************************************************************\n\n\nfloat kl = 0.0;\t\t\t// from 4Klang\nvec4 ot;\t\n\n\n//***************************************************************************************************\n// function rotate\n//***************************************************************************************************\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2;\n\tp.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2;\n\tp.z = z2;\n\treturn p;\n}\n\n//***************************************************************************************************\n// function rand1\n//***************************************************************************************************\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\n//***************************************************************************************************\n// function sdBox\n//***************************************************************************************************\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.));\n\n}\n\n//***************************************************************************************************\n// sdf boxes\n//***************************************************************************************************\nfloat Boxes(vec3 pos) \n{\nvec3 rok = vec3(0.35);\nfloat m;\nm = length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,0.0),iTime*0.3 ),iTime*0.15))-rok,0.0))-0.03; // Cube\nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3, 1.2),iTime*0.21),iTime*0.24))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,-1.2),iTime*0.2 ),iTime*0.3 ))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(1.2,-0.3, 0.0),iTime*0.17),iTime*0.26))-rok,0.0))-0.03); \nm = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(-1.2,-0.3,0.0),iTime*0.32),iTime*0.2 ))-rok,0.0))-0.03); \nreturn m;\n}\n\n//***************************************************************************************************\n// sdf singlebox\n//***************************************************************************************************\nfloat Singlebox(vec3 pos) \n{\nreturn length(max(abs(rotXaxis(pos+vec3(0.0,-0.5,0.0),iTime*0.47))-vec3(0.55-0.025*(kl+0.4)*sin(pos.z*pos.x*pos.y*35.)),0.0))-0.025; // Cube\n}\n\n//***************************************************************************************************\n// sdf plane\n//***************************************************************************************************\nfloat sdPlane(vec3 p) \n{\nreturn p.y+(0.005*sin(p.x*10.))+(0.005*sin(p.z*12.))+0.4;\n}\n\n//***************************************************************************************************\n// sdf menger by IQ\n//***************************************************************************************************\nfloat menger(vec3 pos )\n{\n\tfloat d = sdBox(pos,vec3(1.));\n\tfloat s = 1.63+0.07*sin(0.53*iTime)-0.3*pos.y;\n\tfor( int m=0; m<2; m++ )\n\t{\n      vec3 a = mod( pos*s, 2.0 )-1.0;\n      s *= 3.0;\n\t  vec3 r = abs(1.0 - 3.0*abs(a))-0.025;\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n      d = max(d,c);\n   }\n    return d;\n}\n\n//***************************************************************************************************\n// map\n//***************************************************************************************************\nfloat map(vec3 p)\n{\nfloat d,m;\not = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*0.8;\nd = sdPlane(p);\n\nif (ef==0)\t\t   m = Boxes(p); \nif (ef==1||ef==3)  m = menger(rotYaxis(p,0.12*iTime));\nif (ef==2)\t\t   m = Singlebox(p+0.1*kl*rand1(gl_FragCoord.xy+iTime));\nif (ef==4)\t\t   m = min(menger(rotYaxis(p,0.1*iTime)),sdBox(rotYaxis(rotXaxis(p+vec3(0.,0.2,0.),iTime),0.2*iTime),vec3(0.1,0.1,0.04)-0.002*sin(p.x*p.y*440.+iTime))-0.01);\nreturn min (m, d); \n}\n\n//***************************************************************************************************\n// softshadow by IQ\n//***************************************************************************************************\nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh = 1.0;\n    float t = 0.02;\n    float h = 0.0;\n    for(int i = 0; i < 23; i++)  \n\t{\n        if(t > 20.) continue;\n        h = map(ro + rd * t)+0.003*rand1(gl_FragCoord.xy+iTime);\n        sh = min(sh, 4.0 * h / t);\n        t += h;\n    }\n    return sh;\n}\n\n//***************************************************************************************************\n// normal calculation\n//***************************************************************************************************\nvec3 calcNormal(vec3 p) \n{\n    vec3 e = vec3(0.0001,0.,0.);\n\tif (ef==1) e = vec3(0.01,0.,0.);\n\treturn normalize (vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx)));\n}\n\n//***************************************************************************************************\n// orbit color\n//***************************************************************************************************\nvec3 cycle(vec3 c, float s) \n{\n\tfloat Cycles = 10.;\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\n}\n\nvec3 getColor(int o)\n{\n\tvec4 Z = vec4(0.3, 0.5, 0.6, 0.2);\n\tvec4 Y = vec4(0.1, 0.5, 1.0, -0.5);\n\tvec4 X = vec4(0.7, 0.8, 1.0, 0.3);\n\tvec3 orbitColor = cycle(X.xyz,ot.x)*X.w*ot.x + cycle(Y.xyz,ot.y)*Y.w*ot.y + cycle(Z.xyz,ot.z)*Z.w*ot.z;\n\tif (orbitColor.x >= 4.) orbitColor.x =0.;\n\tif (orbitColor.y >= 4.) orbitColor.y =0.;\n\tif (orbitColor.z >= 4.) orbitColor.z =0.;\n\treturn clamp(3.0*orbitColor,0.0,4.0);\n}\n\n//***************************************************************************************************\n// cast ray\n//***************************************************************************************************\nfloat castRay(vec3 ro,vec3 rd,float maxt) \n{\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\n\tfor(int i = 0; i < 130; i++) \n\t{\n        if(abs(h) < precis || t > maxt) break;\n\t\th = map(ro + rd * t);\n        t += h;\n\t}\n    return t;\n}\n\n//***************************************************************************************************\n// cast ray2 inside\n//***************************************************************************************************\nfloat castRay2(vec3 ro,vec3 rd) \n{\n    float precis = 0.2;\n    float h = 0.;\n    float t = 0.01;\n\n    for(int i = 0; i < 90; i++) \n\t{\n\t\tif(abs(h) > precis ) break;\n\t\th = map(ro + rd * t);\n\t\tt-=h;\n\t}\n\treturn t;\n}\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    // time control (only in shadertoy)\n\n    if (iTime>32.) ef=0;\n\n//  blend    \n\tfloat blend=min(2.*abs(sin((0.1*iTime)*3.1415/3.2)),1.0); // Blende\n\tvec2 uv,p;\n\n//\tzoom XY\t\n    if (ef==1||ef==3){\n\tuv.x = 1.0+(mod(gl_FragCoord.x-   sin(iTime)*gl_FragCoord.y   -(iResolution.x/2.),    ((iResolution.x/4.)* (-1.5*blend+0.501) +(iResolution.x/4.)))-(1.*gl_FragCoord.x)  ) / iResolution.x;\n\tuv.y = 1.0+(mod(gl_FragCoord.y+   sin(iTime)*gl_FragCoord.x   -(iResolution.y/2.),    ((iResolution.y/4.)* (-1.5*blend+0.501) +(iResolution.y/4.)))-(1.*gl_FragCoord.y)  ) / iResolution.y;\n\t}\n\n// \tzoom Y\n\tif (ef==0||ef==2)\n    {\n\tuv.x = 1.0+ (mod(gl_FragCoord.x   -(iResolution.x/2.),    ((iResolution.x/4.)  * (-1.5*blend+0.501)  +(iResolution.x/4.)))-1.*gl_FragCoord.x) / iResolution.x;\n\tuv.y=  1.0-(gl_FragCoord.y /iResolution.y);\n\t}\n\tp = (1.-uv) * 2.0 - 1.0;\n\n// \twithout effect\n\tif (ef==4){ uv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;}\n   \n    \n\tp.x *= iResolution.x /iResolution.y;\n\tfloat theta = sin(iTime*0.1) * 6.28;\n    float x = 3.0 * cos(theta); \n    float z = 3.0 * sin(theta);\n\n//  camera\n\tvec3 ro; \n\tif (ef==0||ef==2) ro = vec3(x*2.0, 2.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t//camera Cubes\n\tif (ef==1)\t\t\t\t ro = vec3(x*0.2+1.0, 4.0, 0.6*z-3.);\t\t\t\t\t    //camera Menger\n\tif (ef==4)\t\t\t\t ro = vec3(0.0, 0.3+0.10*iTime, 0.001);\t\t\t    //camera Tunnel\n\tif (ef==3)\t\t\t\t ro = vec3(0.0, 36.-0.24*iTime, 0.001);\t\t\t    //camera Tunnel\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n\n\n\n// \trender:\n    vec3 col= vec3(0.);\n\tfloat t = castRay(ro,rd,12.);\n\tif (t >= 12.) t=12.;\n\tvec3 pos = ro + rd *t;\n\tvec3 nor = calcNormal(pos);\n\n// \tlightning:\n\tvec3 ligvec = vec3(-0.5,.2,.5);\n\tif (ef==4||ef==2||ef==1) ligvec = vec3(0.5*sin(iTime*0.2), 0.2, -0.5*cos(iTime*0.3));\n\tvec3 lig = normalize(ligvec);\t\n\tfloat dif = clamp(dot(lig, nor),0.,1.);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig),0.,1.),16.);\n\tvec3 color = (3.5-0.35*t)*getColor(1);\n\tcol = 0.3*dif+0.5*color+spec;\n  \tfloat sh = softshadow(pos, lig);\n  \tcol *= clamp(sh, 0.0, 1.0);\n\n\n// \treflection\n\tvec3 ro2r = pos-rd/t;\n\tvec3 rd2r = reflect(rd,nor);\n    float t2r = castRay(ro2r, rd2r, 7.0);\n\tvec3 pos2r = vec3(0.0);\n\tpos2r = ro2r + rd2r* t2r;\n    vec3 nor2r = calcNormal(pos2r);\n\tfloat dif2r = clamp(dot(lig, nor2r), 0.0, 1.0);\n\tfloat spec2r = pow(clamp(dot(reflect(rd2r, nor2r), lig), 0.0, 1.0), 16.0);\n\tcol+= 0.1*(dif2r*color+spec2r);\n\n  \n//  refraction\n\tvec3 rd2 = refract(rd,nor,0.78);  \n    float t2 = castRay2(pos, rd2);\n\tvec3 pos2 = pos + rd2* t2;\n    vec3 nor2 = calcNormal(pos2);\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n\tcol.r+= 0.3*dif2;\n\n\trd2 = refract(rd,nor,0.82);  \n    t2 = castRay2(pos, rd2);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.,1.);\n\tcol.b+= 0.3*dif2;\n\n\trd2 = refract(rd,nor,0.8);  \n    t2 = castRay2(pos, rd2);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.,1.);\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig),0.,1.),16.);\n\tcol.g+=.3*dif2;\n\tcol +=.6*spec2;\n  \n// \trefraction 2\n\tvec3 ro3 = pos2+rd; \n\tvec3 rd3 = rd2+0.002*rand1(gl_FragCoord.xy); \n    float t3 = castRay(ro3, rd3, 10.);\n\tif (t3>=10.)t3=10.;\n\tvec3 pos3 = ro3 + rd3* t3;\n    vec3 nor3 = calcNormal(pos3);\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\n\tcolor = clamp(1.+(1.-0.2*t3)*getColor(1),0.,8.);\n\tcol+= 0.1*dif3*color;\n\tcol+= 0.04*(1.-dif3)*color;\n\n\tcol = mix(col, vec3(.4,.5,.6), exp(-(2.-(0.18*t)) ) );\n\n// \tpostprocessing\n\tvec2 uv2= gl_FragCoord.xy/iResolution.xy;\n\tcol-=0.04*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\t\t\n\tcol*=.9+.1*sin(2.*uv2.y*iResolution.y);\t\n    col-=1.-dot(uv,1.-uv)*2.4;\n    fragColor = vec4(col*blend, 1.0);\n\n\n}\n\n", "image_inputs": [{"id": "4dfGW2", "previewfilepath": "https://soundcloud.com/virgill/prism-break", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/prism-break", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XtSGzy", "name": "TestShaderDraz", "author": "Drazatlam", "description": "Test", "tags": ["test"], "likes": 1, "viewed": 108, "date": "1429802249", "time_retrieved": "2024-06-20T18:20:24.999166", "image_code": "// Rotation ------------------------------------------------------------\n \n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n \n// Textures ------------------------------------------------------------\n \nconst vec3 red=vec3(0.4,0.137,0.047);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n \nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n \nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n \n\nfloat PerlinNoise3DABS(vec3 p,float alpha,float beta)\n{\n   float val,sum = 0.0;\n   float scale = 1.0;\n    \n   for (int i=0;i<5;i++) {\n      val = noise(p);\n            val = abs(val);\n      sum += val / scale;\n      scale *= alpha;\n      p *= beta;\n   }\n   return(sum);\n}\n\n\n\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    //float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    float f;\n     vec3 q = 8.0*p;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return mix(red,yellow,f);\n    //return vec3(f,f,f);\n}\n\nvec3 rouille(in vec3 p,in vec3 n)\n    \n{\n    float f;\n    vec3 q = 8.0*p;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    float seuil=0.5;\n\tif(f > seuil)\n    {\n        return mix(red,yellow,(f-seuil)/(1.0-seuil));//checker(p+2,n+2);\n    }\n    else\n    {\n        return mix(grey2,grey,f/seuil);\n    }   \n}\n\nvec3 bois(in vec3 p,in vec3 n){\n    \n    float f;\n    vec3 q =1.2*m* p;\n    f  = 0.7*noise( q ); q = m*q*2.01;\n    f += 0.300*noise( q ); q = m*q*2.02;\n    //f += 0.100*noise( q ); q = m*q*2.02;\n    f/=(0.7+0.3);\n   // f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.1250*noise( q ); q = m*q*2.01;\n    float m =mod(10.0*(p.x+f*0.2),1.0);\n    //float m=(1.0+sin(30.0*(0.7*p.x+0.3*f)))/2.0;\n    return mix(clair,fonce,pow(m,1.5));\n}\n\nvec3 marbre(in vec3 p,in vec3 n){\n    float i=p.x,j=p.y;\n    float PN1;\n   \n   \tPN1=(1.0+cos(i*70.0+PerlinNoise3DABS(p,5.0,5.0)*200.0))/2.0;\n    return mix(blanc,noir,pow(PN1,3.0));\n        \n}\n\nvec3 trait(in vec3 p,in vec3 n){\n   \t\n float c= floor((1.0 + cos(p.x*5.0))/2.0*15.0);// floor(p.x*100.0);// - floor(1.0+p.y*12.0);\n float cy=(1.0 + sin(p.y*50.0))/2.0*15.0;\n float cz=0.0;\n     //floor(p.z*5.0);\n \n    if(mod(c+cy+cz,3.0)<1.0){\n     \treturn blanc;   \n    }\n    \n    if(mod(c+cy+cz,3.0)<2.0){\n     \treturn grey;   \n    }\n    \n    if(mod(c+cy+cz,3.0)<3.0){\n     \treturn noir;   \n    }\n return mix(grey,grey2,(c+cy+cz)/20.0);\n \n}\n\nvec3 lave(in vec3 p, in vec3 n, in float temperature) {\n\t\n    float seuil = temperature-0.8;\n    if(seuil == 0.0) {\n    \tseuil = 0.00001;   \n    }\n    float c;\n    vec3 q = p*10.0;\n    c = 0.7*noise(q);\n    c += 0.3*noise(2.0*q);\n    \n    if(c < seuil) {\n    \treturn mix(jaune*temperature, orange*temperature, pow(c/seuil,4.0));\n    }\n    else {\n    \treturn mix(orangeFonce, tenebres, (c-seuil)/(1.0-seuil));\n    }\n}\n\nvec3 granit(in vec3 p,in vec3 n){\n    \n     float f,g,h;\n     vec3 q = 100.0*p;\n    f  = 0.8*noise( q );\n    f  += 0.25*noise( 2.0*q );\n    f  += 0.125*noise( 4.0*q );\n    f/=(0.8+0.25+0.125);\n    q = m*q;\n     g  = 0.8*noise( q );\n    g  += 0.25*noise( 2.0*q );\n    g  += 0.125*noise( 4.0*q );\n    g/=(0.8+0.25+0.125);\n    q=m*q;\n     h  = 0.8*noise( q );\n    h  += 0.25*noise( 2.0*q );\n    h  += 0.125*noise( 4.0*q );\n    h/=(0.8+0.25+0.125);\n    //f += 0.2500*noise( q ); q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.1250*noise( q ); q = m*q*2.01;\n    \n    if(f>0.6){\n        return noir;\n    }\n    else{\n        if(g>0.6){\n       \t\t return grey;\n   \t\t}\n        else{\n        \tif(h>0.6){\n       \t\t return blanc;\n   \t\t}\n        else{\n        \treturn pink;\n        }\n        }\n        //return blanc;\n    }\n}\n \n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(14.0*sqrt(dot(pa,pa))));\n    \n    \n        return mix(red,yellow,v);\n}\n\nbool inTruc(in vec3 p,in vec3 c, in float r){\n    \n    float dist = distance(p,c);\n    float f;\n    vec3 q = 0.5*p;\n    f  = 0.8*noise( q );\n    f  += 0.4*noise( 4.0*q );\n    f  += 0.2*noise( 8.0*q );\n    f  += 0.1*noise( 16.0*q );\n    f/=(0.8+0.4+0.2+0.1);\n    f  = f/dist/dist/dist/dist/dist/dist/dist/dist;\n    \n    return f>0.8;\n}\n \n// Objects --------------------------------------------------------------\n \n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n    vec3 oc = o-c;\n   \n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n    float e = 0.001;\n    for(float i=0.0;i<10000.0;++i){\n        vec3 p =o+(e*i)*d;\n        if(inTruc(p,c,r)){\n            t=e*i;\n            return true;\n        }\n    }\n      \n    /*if (t<=0.0) return false;\n   \n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n   \n    // Normal\n    n=(o+t*d-c)/r;*/\n \n   return false;\n}\n \n// Lighting -------------------------------------------------------------\n \n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\nvec3 planet(in vec3 p){\n    float h =0.9;\n    if(distance(p,vec3(0.0,0.0,0.0))<h)\n        return vec3(0.0, 0.0, 1.0);\n    \n    else \n   \t\treturn mix(vec3(0.0, 1.0, 0.0),vec3(1.0, 0.0, 0.0),distance(p,vec3(0.0,0.0,0.0))-h);\n    \n}\n \n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n \n    vec3 l = normalize(lightPos - p);\n \n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)*dot(n, l));\n \n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = planet(p)*diff*lightColor;//1.0*marbre(p,n)*\n \n    return c;\n}\n \n// Vignetting    \n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n                return c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n\n// Main -----------------------------------------------------------------\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n   \n                // Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n                vec3 d = normalize(vec3(uv, 1.0));\n               \n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n   \n                vec3 n;\n    float t;\n   \n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {         \n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
