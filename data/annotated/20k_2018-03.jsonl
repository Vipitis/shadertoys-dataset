{"id": "4d3cDX", "name": "I am playing", "author": "gasgiant", "description": "Some cosine madness", "tags": ["acid"], "likes": 5, "viewed": 139, "published": "Public", "date": "1520335520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 texColor = texture(iChannel0,uv);\n    float r = 0.5 + 0.5*cos(iTime + texColor.r*10.0);\n    float g = 0.5 + 0.5*cos(iTime + texColor.g*10.0);\n    float b = 0.5 + 0.5*cos(iTime + texColor.b*10.0);\n    fragColor = vec4(r,g,b,1);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3cDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340]]}
{"id": "4d3cWj", "name": "n-poly circles", "author": "Stoteles_Harry", "description": "Inspired by Chris M. Thomasson what is infinity on sci.math", "tags": ["math"], "likes": 1, "viewed": 143, "published": "Public", "date": "1520137290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float V;\nfloat pi=radians(180.);\nfloat sqrt2=sqrt(2.);\n\nvec4 splat(vec2 D) {\n    D /= V/180. ;            // splats radius\n    return exp(-.5*dot(D,D) ) * vec4(1,.7,.4,0)*2.; // colored Gaussian\n}\n\nvoid mainImage( out vec4 Out, vec2 In )\n{   \n    float t=iTime+1.;\n    vec2 R = iResolution.xy; vec2 P;\n    V=max(R.x,R.y)/sqrt2;\n \n    float M=floor(t);\n    float K=t-M;\n    for (float j=0.; j<14.; j++) {\n        float F=2.*pi/(M+j);\n        float U=V-(j-K)*V/14.;\n        for (float i=0.; i<M+j; i++) {\n            P.x=R.x/2.+cos(F*i)*U;\n            P.y=R.y/2.+sin(F*i)*U;\n            Out += splat(In-P);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3cWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 76, 76, 196], [198, 198, 239, 239, 622]]}
{"id": "4d3yDl", "name": "Ð¡hamomile", "author": "Pr0fed", "description": "Functions further understanding", "tags": ["functions"], "likes": 4, "viewed": 104, "published": "Public", "date": "1520496057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA = vec3(0.349,0.241,0.812);\nvec3 colorB = vec3(1.000,0.233,0.224);\nvec3 colorC = vec3(1.000,0.033,0.024);\nvec3 colorD = vec3(1.000,0.978,0.913);\nvec3 colorE = vec3(0.123,0.078,0.323);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    float r = length(st) * 2.0;\n    float a = atan(st.y , st.x);\n\n    float f = abs(cos(a * 9.5)) * abs(0.4 + 0.05 * sin(iTime)) + .3;\n\n    vec3 color = mix(vec3( smoothstep(f + 0.22,f,  r) ), \n                vec3( smoothstep(f + 0.52,1.0 -f,  r)) * colorB,\n        \t\tcolorA);\n    \n    color *=  smoothstep(0.0, 0.15, length(st)) + colorC;\n    color *= 1.76 * smoothstep(0., 0.1, length(st)) + colorD;\n    color *= smoothstep(0.55, 0.0, length(st)) + colorE;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3yDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 253, 303, 867]]}
{"id": "4d3yWB", "name": "Self-Playing Pong", "author": "Kosro", "description": "I will soon limit the ball's position, so it doesn't clip through the frame border. Feel free to make it shorter!", "tags": ["2d", "game", "pong"], "likes": 2, "viewed": 721, "published": "Public API", "date": "1519940955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OFFSET 1.3541\n#define RADIUS 0.05\n#define SIZE vec2(0.02,0.3)\n#define TIME_SCALE 0.5\n\n#define NORM vec2(iResolution.x/iResolution.y,1.0)\n\nfloat frac(float c) {\n\treturn c - floor(c);\n}\n\nfloat lerp(float a, float b, float t) {\n\treturn a + (b-a) * t;\n}\n\nfloat pingpong(float t) {\n\treturn abs(frac(t)-0.5)*2.0;\n}\n\nvec2 ball(float t) {\n    return vec2(pingpong(t),pingpong(t*OFFSET));\n}\n\nfloat getPos(float t) {\n    return clamp(lerp(ball(ceil(t)).y,ball(ceil(t+1.0)).y,frac(t)),SIZE.y*0.5,1.0-SIZE.y*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfloat t = iTime*TIME_SCALE;\n\n \tfloat a;\n\n\ta += step(length((uv-ball(t))*NORM),RADIUS);\n    \n    a += step(uv.x,SIZE.x) * step(abs(uv.y-getPos(t+0.5)),SIZE.y*0.5);\n    \n    a += step(1.0-SIZE.x,uv.x) * step(abs(uv.y-getPos(t-1.0)),SIZE.y*0.5);\n\n\tfragColor = vec4(vec3(a), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3yWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 167, 167, 191], [193, 193, 232, 232, 257], [259, 259, 284, 284, 316], [318, 318, 338, 338, 389], [391, 391, 414, 414, 511], [513, 513, 570, 570, 893]]}
{"id": "4dccWj", "name": "Oldschool Plasma Effect", "author": "iq", "description": "The oldschool Plasma effect of the early 90s", "tags": ["2d", "oldschool", "plasma"], "likes": 15, "viewed": 928, "published": "Public API", "date": "1520138734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = 6.0*fragCoord/iResolution.xy;\n\t\n    // pattern\n    float f = sin(p.x + sin(2.0*p.y + iTime)) +\n              sin(length(p)+iTime) +\n              0.5*sin(p.x*2.5+iTime);\n    \n    // color\n    vec3 col = 0.7 + 0.3*cos(f+vec3(0,2.1,4.2));\n\n    // putput to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dccWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 93, 401]]}
{"id": "4dcyWB", "name": "modulo", "author": "jmaire", "description": "rayures et rotation", "tags": ["rotationmodulomouseclick"], "likes": 0, "viewed": 73, "published": "Public", "date": "1519939763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modulo le 01/03/2018\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 crds =(2.0* fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 mous=vec3((2.0* iMouse.xy-iResolution.xy)/iResolution.y,1.0);\n\tvec3 coords=vec3(crds,1.0);\n\tfloat co=cos(iTime);\n\tfloat si=sin(iTime);\n    coords = vec3(co*coords.x-si*coords.y,si*coords.x+co*coords.y,1.0);\n    coords=mod(mous*mous,coords*coords);\n    fragColor = vec4(6.0*coords+3.0*coords*coords,1.0);\n}\n\n\n\n\n\n   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 84, 84, 461]]}
{"id": "4ddcWl", "name": "Lava Tubes", "author": "Shane", "description": "Smoothly combining a couple of gyroid objects with a perturbed cylinder to create a cheap lava-tube network. Low budget volumetric noise was added to create a little atmosphere.", "tags": ["raymarching", "tunnel", "volumetric", "translucency", "gyroid", "bumpmap"], "likes": 32, "viewed": 1248, "published": "Public API", "date": "1520685919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Lava Tubes\n    ----------\n\n\tI put this together for fun, as a means to take a break from other things I'm trying \n\tto code at the moment. It's nothing exciting, just a glorified bump mapped tunnel.\t\n\n\tThe example was aimed toward the 800 by 450 window and built to accommodate mid-range \n\tsystems. I also procedurally textured the scene to keep Dr2 happy. :)\n\t\n\tI started with a perturbed cylindrical tunnel, combined it with a couple of gyroids, \n\tthen bump mapped a cellular surface onto it. It wasn't my intention to go for the \n\tlow-budget 80s sci-fi -- or late 90s demoscene -- look, but that's how it turned out. :) \n\tI'll put together a more sophisticated version at some point.\t\n    \n    Creating volumetric dust, vapor, etc, is simple enough in theory -- just accumulate\n    multiple layers of dust-like noise, then layer it onto to the scene in some way. In \n\tpractice, however, you're trying to do the best you can with just a few iteratios of \n\tcheap FBM noise -- usually consisting of just two value noise octaves. In this case, \n\tI've used 16 iterations of two-octave value-noise FBM, which means there are 32 3D\n\tvalue-noise calls at most. It's not ideal, but I think it gets the job done\n\twell enough.\n\n\n    Related examples: \n\n\t// A much simpler example, but the one I vaguely had in mind when coding this.\n\tNautilus - Weyland\n\thttps://www.shadertoy.com/view/MdXGz4\n\n\t// Better usage of the cellular algorithm and XT95's translucency formula.\n    3D Cellular Tiling - Shane\n    https://www.shadertoy.com/view/ld3Szs\n\n\t// One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https://www.shadertoy.com/view/XtfSWX\n    Based on one of my all time favorites:\n\tThis was one of the first volumetric dust examples I saw on Shadertoy.\n    Xyptonjtroz - Nimitz\n\thttps://www.shadertoy.com/view/4ts3z2\n\n\n*/\n\n// A more subtle, slightly less heated, scene.\n//#define COOLER\n\n#define FAR 50.\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n*/\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n// The cellular tile routine. Draw a few objects (four spheres, in this case) using a minumum\n// blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the \n// objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as three spheres. If you sum the total \n// instruction count here, you'll see that it's way, way lower than 2nd order 3D Voronoi.\n// Not requiring a hash function provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost.\n//\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n  \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular tube - Doesn't wrap, but it's here for completeness.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p.yzx);\n    //return max(max(p.x, p.y), p.z);    \n    \n    // Cubic.\n    //p = abs(fract(p) - .5); \n    //return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    p = abs(fract(p) - .5); \n    p = max(p*.866025 + p.yzx*.5, p.yzx);\n    return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n\n// Second order cellular tiled routine - I've explained how it works in detail in other examples.\nfloat cellTile(in vec3 p){\n    \n     \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    const float scale = 2.;\n    return min(d.x*2.*scale, 1.); // Normalize.\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0); // Straight line.\n    \n    // Curved path.\n    float a = sin(z * 0.11/1.5);\n    float b = cos(z * 0.14/1.5);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5)*1.5; \n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n// Based on the triangle function that Shadertoy user Nimitz has used in various triangle noise \n// demonstrations. See Xyptonjtroz - Very cool.\n// https://www.shadertoy.com/view/4ts3z2\n// Anyway, these have been modified slightly to emulate the sin and cos waves.\nvec3 triS(in vec3 x){ return 1. - abs(fract(x + .25) - .5)*4.; } // Triangle function.\nvec3 triC(in vec3 x){ return 1. - abs(fract(x + .5) - .5)*4.; } // Triangle function.\n\n\n// Tube functions - for the tunnel.\nfloat dist2D(in vec2 p){\n\n    // Other tube shapes to try.\n    /*\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.\n    return max(p.x, p.y); // Square.\n    return (p.x + p.y)*.7071; // Diamond.\n    return max(p.x*.8660254 + p.y*.5, p.y); // Hexagon.\n    */\n    \n    return length(p); // Round cylinder.\n    \n}\n\n// Perturbed gyroid tunnel function: In essence, it's a couple of smoothly\n// combined gyroid functions, with a cylindrical hole (wrapped around the\n// camera path) smoothly carved out from them.\n//\nfloat map(vec3 p){\n    \n   \n    //float sf = cellTile(p*.25); // Cellular layer.\n    //sf = smoothstep(-.1, .5, sf);\n    \n\n    // Trancendental gyroid functions and a function to perturb\n    // the tunnel. For comparisson, I included a rough triangle\n    // function equivalent option.\n    #if 1\n    vec3 q = p*3.1415926;\n    float cav = dot(cos(q/2.), sin(q.yzx/2.5)); // Gyroid one.\n    float cav2 = dot(cos(q/6.5), sin(q.yzx/4.5)); // Gyroid two.\n    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.\n    \n    // Transendental function to perturb the walls.\n    float n = dot(sin(q/3. + cos(q.yzx/6.)), vec3(.166));\n    //float n = (-cellTile(p*.125) + .5)*.5;\n    #else\n    vec3 q = p/2.;\n    float cav = dot(triC(q/2.), triS(q.yzx/2.5)); // Triangular gyroid one.\n\tfloat cav2 = dot(triC(q/6.5), -triS(q.yzx/4.5)); // Triangular gyroid two.\n    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.\n    \n    // Triangular function to perturb the walls.\n    float n = dot(triS(q/3. + triC(q.yzx/6.)), vec3(.166));\n    //float n = (-cellTile(p*.125) + .5)*.5;\n\t#endif\n\n    // Wrap the tunnel around the camera path.\n    p.xy -= path(p.z);\n    \n\n    // Smoothly combining the wrapped cylinder with the gyroids, then \n    // adding a bit of perturbation on the walls.\n    n = smax((2.25 - dist2D(p.xy)), (-cav - .75), 1.) +  n;// - sf*.375;\n    \n    // Return the distance value for the scene. Sinusoids aren't that great\n    // to hone in on, so some ray shortening is a necessary evil.\n    return n*.75;\n \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    // Cellular tiling.\n    float sf = cellTile(p*.5);\n    float sf2 = cellTile(p*1.5);\n    float n = sf*.66 + sf2*.34; // FBM.\n    \n    // Noise.\n    float ns = noise3D(p*40.);\n    \n    // Combining the above. Trial and error to achieve a slightly\n    // cracked looking surface crust... or something. :)\n    return n*.45 + smoothstep(-.1, .6, sf*.75 + sf2*.25)*.5 + ns*.05;\n    \n    // Another variation that enhances the cracks.\n    //return smoothstep(-.1, .5, sf)*.8 + n*.2; \n\n}\n\n// Standard function-based bump mapping function. Six taps is usually better, but I'm trying\n// trying to save some cycles.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n// Standard raymarching function.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i<80; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calcAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 3.;\n\tconst float nbIte = 5.;\n\t//const float falloff = .9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + .0)*.5/nbIte*maxDist;        \n        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    //ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<16; i++){\n        \n        // If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (ro + rd*t0)*3.;\n        float c = noise3D(ro2)*.66 + noise3D(ro2*3.)*.34; //cellTile\n        float n = (c - .25);\n        mist += n*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += max(c*.5, .05);\n        \n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/32., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n\n}\n\n//////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0., 0.0, iTime*4. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .25, 5); // Placed in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n    \n    // A bit of lens mutation to increase the scene peripheral, if that's your thing.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2(path(lookAt.z).x/16.)*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        vec3 oSn = sn; // A copy of the unperturbed (unbumped) normal.        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // For aesthetic reasons, sometimes you might not want the reflected vector to be\n        // perturbed too much by the bumped surface. The following tone it down a little. \n        //oSn = mix(oSn, sn, .75);\n\t    \n\t    // Ambient occlusion and shadows.\n        float ao = calcAO(sp, sn);\n        float sh = softShadow(sp + sn*.002, lightPos, 4., t); // Set to \"1.,\" if you can do without them.\n        sh = min(sh + ao*.3, 1.);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + distlpsp*0.25); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = ao*.5;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        //diff *= diff;\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd), 0.), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Refected vector at the surface hit point. \n        vec3 ref = reflect(rd, oSn);\n\n        // Object texturing and coloring: I made this up as I went along. It's just a combination \n        // of value noise and cellular noise. Sometimes, I like to darken crevices, etc, a little \n        // more by applying combinations that match those in the distance field calculations, or \n        // bump map calculations.\n        vec3 texCol = mix(vec3(.5, .4, .3), vec3(0, .1, .2), (noise3D(sp*32.)*.66 + noise3D(sp*64.)*.34));\n        texCol *= mix(vec3(0, .1, .2).zyx, vec3(1, .9, .8), (1. - cellTile(sp*4.5)*.75));\n \n        // Extra shading in the cracked crevices for a slightly more cartoonish look.\n        texCol *= mix(vec3(.9, .95, 1), vec3(.1, 0, 0), .75 - smoothstep(-.1, .5, cellTile(sp*.5))*.75);\n        \n        \n        // Last minute decision to give the rocky surface a blueish charcoal tinge. Still not sure about it. :)\n        texCol *= vec3(.8, 1, 1.2); \n        \n        \n    \t/////////   \n        // Translucency, courtesy of XT95. See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        float th = thickness( sp, sn, 1., 1.);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = (tdiff + .0)*th;  \n        trans = pow(trans, 4.);        \n    \t//////// \n    \t\n    \t\n    \t// Combining the above terms to produce the final color. It's based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 3.)*3.;\n        sceneCol += texCol*vec3(1, .1, .05)*trans*12.;\n        \n        // Fake reflection. Other that using the refected vector, there's very little science \n        // involved, but since the effect is subtle, you can get away with it.\n        vec3 refCol = vec3(1, .05, .075)*smoothstep(.25, 1., noise3D(ref*2.)*.66 + noise3D(ref*4.)*.34 );\n        sceneCol += texCol*refCol*2.;\n\n\t    // Shading.\n        sceneCol *= atten*ao*sh;\n\t   \n\t\n\t}\n    \n   \n       \n    // Blend the scene and the background with some very basic, 16-layered smokey haze.\n    float mist = getMist(camPos, rd, lightPos, t);\n    vec3 sky = vec3(2, 1, .5);\n    sky = mix(sky, sky.xzy, .25 - rd.y*.25);\n    sceneCol = mix(sky, sceneCol, 1./(t*t/FAR/FAR*12. + 1.));\n    \n\n    // Brown mist was too brown, and blue mist was too blue, so I combined the two... Not a lot of thought\n    // went into it. :)\n    //vec3 mistCol = vec3(1.2, 1, .8); // Probably, more realistic, but less interesting.\n    vec3 mistCol = mix(vec3(1.4, 1, .85), vec3(1.4, 1, .85).zyx, dot(sin(rd*9. + cos(rd.yzx*5.)), vec3(.166)) + .5);\n    // Applying the mist to the scene. This particular compositing formula was based on how I wanted\n    // the mist to look when blended in with the background... More Star Trek science. :D\n    sceneCol += (mix(sceneCol, mistCol, .66)*.66 + sceneCol*mistCol*1.5)*mist;\n    \n    #ifdef COOLER\n    // Cooler, more subtle version.\n    sceneCol *= vec3(.85, .95, 1.25);\n    #endif\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(sceneCol, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25))*.5);\n\n\n    // Clamp and present the pixel to the screen.\n\tfragColor = vec4(sqrt(max(sceneCol, 0.)), 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1927, 1999, 2021, 2021, 2056], [2058, 2102, 2122, 2122, 2231], [2233, 2385, 2406, 2406, 2472], [3196, 3272, 3297, 3390, 4342], [4344, 5016, 5044, 6326, 6445], [6449, 6547, 6573, 6687, 7391], [7393, 7493, 7515, 7586, 7704], [7707, 7930, 7968, 7968, 8049], [8052, 8275, 8313, 8313, 8390], [8393, 8658, 8679, 8679, 8722], [8723, 8745, 8766, 8766, 8808], [8833, 8869, 8893, 9154, 9207], [9209, 9408, 9426, 9693, 10939], [10942, 11006, 11035, 11064, 11524], [11526, 11650, 11707, 11707, 12086], [12088, 12122, 12158, 12158, 12583], [12585, 12685, 12712, 12712, 12870], [12874, 13111, 13182, 13182, 13469], [13472, 13773, 13826, 13904, 15201], [15930, 16082, 16118, 16118, 16426], [16725, 16776, 16797, 16797, 16863], [16865, 17153, 17215, 17215, 18312], [18314, 18322, 18378, 18404, 25189]]}
{"id": "4ddyD2", "name": "Apollonianscopic KIFS Remix", "author": "Loadus", "description": "Slight remix of the Apollonianscopic KIFS by gPlatl. ", "tags": ["ifs", "kaleidoscope"], "likes": 7, "viewed": 168, "published": "Public", "date": "1520264908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Apollonianscopic kifs remix\n\n// original creator wyatt, https://www.shadertoy.com/view/Xdcyzl\n// Apollonianscopic version gPlatl https://www.shadertoy.com/view/4scyRs\n\n// Tags: apollonian, kifs, fractal, fractal, inversion, koleidoscope\n\nmat3 m;\nfloat k;\nmat3 rot (vec3 s) {\n\tfloat \tsa = sin(s.x),\tca = cos(s.x),\n\t\t\tsb = sin(s.y),\tcb = cos(s.y),\n\t\t\tsc = sin(s.z),\tcc = cos(s.z);\n\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb));\n}\nvec3 app (vec3 v) {\n\tfor (int i = 0; i < 70; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\nvec3 ap (vec3 v) {\n\tfor (int i = 0; i < 15; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\nvec3 norm (vec3 p) {\n\t\tvec2 e = vec2 (.05,0.);\n    \tvec3 g = ap(p);\n\t\treturn normalize(vec3(\n\t\t\t\tap(p+e.xyy).x - g.x,\n\t\t\t\tap(p+e.yxy).y - g.y,\n\t\t\t\tap(p+e.yyx).z - g.z));\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\nconst float PI = 3.14159265359;\n\n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 mp = iMouse.xy / iResolution.xy;\n    uv *= 0.2 + 10. * mp.x;\n    float sideCount = 1.0 + round(mp.y * 11.0);\n    smallKoleidoscope (uv, PI / sideCount);\n    \n    float t = 0.015*iTime;\n    m = rot(t+vec3(2,3,5));\n    k = 1.3+0.1*sin(0.08*iTime);\n    vec3 v = (.5+0.25*sin(0.03*iTime))*m*vec3(2.*uv,0);\n    vec3 col = sin(app(v))*0.5+0.5;\n    col = col*0.8+0.2*(sin(norm(v))*0.5+0.5);\n    \n    \tfloat gm = 1.0/2.22;\n    \tcol = vec3(pow(col.r, gm), pow(col.g, gm), pow(col.b, gm));\n    \tcol.r = SCurve(col.g * 0.3 + col.r * 0.7, 4.0, 2.0);\n    \tcol.g = SCurve(col.g * 0.7 + col.b * 0.3, 2.0, 2.0);\n    \tcol.b = col.g * 0.3 + col.b * 0.7;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 259, 278, 278, 527], [528, 528, 547, 547, 641], [642, 642, 660, 660, 754], [755, 755, 775, 775, 926], [928, 928, 988, 988, 1248], [1283, 1350, 1399, 1399, 1526], [1527, 1594, 1651, 1651, 2426]]}
{"id": "4dGcDh", "name": "Asteroid Field", "author": "dr2", "description": "Use the mouse; switch forward/backward views when mouse in lower-right view", "tags": ["space", "flight", "asteroid"], "likes": 5, "viewed": 667, "published": "Public API", "date": "1521709610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Asteroid Field\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nmat3 flMat, flyerMat;\nvec4 ast;\nvec3 flPos, flyerPos, qHit, ltDir, cId, hsh;\nfloat tCur, dstFar, spd, szFacFl;\nint idObj;\nconst vec3 bGrid = vec3 (1.);\nconst float pi = 3.14159;\n\nvec3 trkAx = vec3 (0.7, 0.8, 1.2), trkAy = vec3 (1., 1.1, 0.9),\n   trkFx = vec3 (0.43, 0.33, 0.23), trkFy = vec3 (0.41, 0.31, 0.12);\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nvoid AstState ()\n{\n  float s, r, a;\n  hsh = Hashv3v3 (cId);\n  s = fract (64. * length (hsh));\n  s *= s;\n  r = 0.5 * bGrid.x * (0.8 + 0.2 * hsh.x * (1. - s) * abs (sin (3. * pi * hsh.y * (1. - s))));\n  a = hsh.z * tCur + hsh.x;\n  ast = vec4 ((r - 1.1 * (0.15 - 0.07 * s)) * vec3 (cos (a), sin (a), 0.), 0.15 - 0.07 * s);\n}\n\nfloat AstDf (vec3 p)\n{\n  vec2 s;\n  s = abs (cId.xy - floor (TrackPath (bGrid.z * cId.z).xy / bGrid.xy));\n  return (hsh.x > 0.7 && max (s.x, s.y) > 0.) ?\n     length (p - bGrid * (cId + 0.5) - ast.xyz) - ast.w : dstFar;\n}\n\nvec3 AstCell (vec3 p)\n{\n  cId.xy = floor (p.xy / bGrid.xy);\n  p.z += 0.1 * spd * tCur * Hashfv2 (cId.xy) * step (10., length (cId.xy));\n  cId.z = floor (p.z / bGrid.z);\n  return p;\n}\n\nfloat AstRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + rd * dHit;\n    p = AstCell (p);\n    if (length (cId - cIdP) > 0.) {\n      AstState ();\n      cIdP = cId;\n    }\n    d = AstDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 AstNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  p = AstCell (p);\n  AstState ();\n  v = vec4 (AstDf (p + e.xxx), AstDf (p + e.xyy), AstDf (p + e.yxy), AstDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FlyerEngDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p = flyerMat * (p - flyerPos);\n  p = p / szFacFl;\n  q = p - vec3 (0., 0.3, -0.6);\n  q.xz = abs (q.xz) - vec2 (1.6, 1.3);\n  q.xy = Rot2D (q.xy, -32. * tCur);\n  d = max (PrCylDf (q, 0.4, 0.4), 0.05 - min (abs (q.x), abs (q.y)));\n  return szFacFl * d;\n}\n\nfloat FlyerEngRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = FlyerEngDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, h;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos);\n  p = p / szFacFl;\n  q = p;\n  h = 0.5 - 0.05 * (q.z + 0.3) * (q.z + 0.3);\n  q.y -= h;\n  d = PrRoundBoxDf (q, vec3 (0.9 - 0.06 * (q.z + 0.5) * (q.z + 0.5), h, 2.7), 0.15);\n  q = p + vec3 (0., -0.3, 0.6);\n  qq = q;  qq.xz = abs (qq.xz) - vec2 (1.6, 1.3);\n  d = min (min (min (d, PrCylAnDf (qq, 0.44, 0.04 - 0.03 * (qq.z / 0.48) * (qq.z / 0.48), 0.48)),\n     PrCylDf (qq, 0.15 - 0.12 * (qq.z / 0.45) * (qq.z / 0.45), 0.45)),\n     PrRoundBoxDf (qq, vec3 (0.4, 0.01, 0.1), 0.01));\n  q = p;  q.y -= 0.3;\n  qq = q;  qq.z = abs (qq.z + 0.6) - 1.3;\n  d = SmoothMin (d, PrRoundBoxDf (qq, vec3 (1.15, 0.03 - 0.05 * abs (qq.z), 0.3), 0.01), 0.05);\n  DMINQ (1);\n  q = p;  q.yz -= vec2 (0.52, 0.5);\n  d = PrCapsDf (q, 0.6, 1.);\n  DMINQ (2);\n  return 0.7 * szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (FlyerDf (p + e.xxx), FlyerDf (p + e.xyy), FlyerDf (p + e.yxy), FlyerDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col;\n  float ax;\n  col = vec4 (0.9, 0.9, 0.95, 0.3);\n  ax = abs (qHit.x);\n  if (idObj == 1) {\n    if (qHit.z > 2. && length (vec2 (ax - 0.15, qHit.y + 0.3)) < 0.08) {\n      if (length (vec2 (ax - 0.15, qHit.y + 0.3)) < 0.06) col = vec4 (1., 1., 0.8, -2.);\n      else col = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (qHit.z < -2. && length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.1) {\n      if (length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.08) col = vec4 (1., 0., 0., -2.);\n      else col = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && length (vec2 (ax - 1.6, qHit.y)) < 0.2) {\n      col = vec4 (1., 0., 0., 0.3);\n    } else if (ax < 0.02 || qHit.z < -2.8 && mod (8. * qHit.x + 0.1, 1.) < 0.2 ||\n       qHit.z > 2.8 && mod (12. * qHit.y + 0.1, 1.) < 0.2 ||\n       abs (qHit.z + 1.3) < 0.9 && ax < 0.8 && mod (6. * qHit.x + 0.1, 1.) < 0.15 ||\n       abs (qHit.z + 0.7) < 0.5 && abs (qHit.y - 0.2) < 0.3 && mod (12. * qHit.y + 0.1, 1.) < 0.15) {\n      col = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && ax > 1.12) {\n      col = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (length (vec2 (abs (qHit.z + 0.6) - 1.3, ax - 1.6)) < 0.1 && abs (qHit.y) > 0.44) {\n       col = mix (0.8 * col, vec4 (0., 1., 0., -2.), step (0.5, mod (0.5 * tCur, 1.)));\n    }\n  } else if (idObj == 2) {\n    if (min (ax, abs (qHit.z - 1.)) > 0.03) col = vec4 (0.1, 0.1, 0.2, -1.);\n  }\n  return col;\n}\n\nvec3 HvnCol (vec3 rd)\n{\n  vec3 col;\n  float b;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  col = 0.3 * mix (vec3 (0.8, 0.8, 0.7), vec3 (0.6, 0.6, 0.5), 0.5 * (1. - rd.y)) *\n     (0.4 + 0.15 * (rd.y + 1.) * (rd.y + 1.));\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  rd = floor (2000. * rd);\n  rd = 0.00015 * rd + 0.1 * Noisefv3 (0.0005 * rd.yzx);\n  for (int j = 0; j < 19; j ++) rd = abs (rd) / dot (rd, rd) - 0.9;\n  col += 0.3 * vec3 (1., 1., 0.9) * min (1., 0.5e-3 * pow (min (6., length (rd)), 5.));\n  return col;\n}\n\nvec3 AstCol (vec3 ro, vec3 rd, float dstAst)\n{\n  vec3 vn, p, col;\n  ro += dstAst * rd;\n  vn = AstNf (ro);\n  p = ro;\n  p = AstCell (p);\n  AstState ();\n  p -= ast.xyz + bGrid * (cId + 0.5) + 0.3 * (hsh - 0.5);\n  vn = VaryNf (32. * (0.5 + 0.5 * hsh.x) * p, vn, 10. * (0.5 + 0.5 * hsh.y));\n  col = HsvToRgb (vec3 (0.13 + 0.03 * hsh.x, 0.3 + 0.3 * hsh.y,\n     min (0.5 + 0.2 * hsh.z + 0.5 * Fbm3 (32. * p), 1.)));\n  col = col * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n     0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return mix (col, HvnCol (rd), smoothstep (0.5, 1., min (dstAst / dstFar, 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstAst, dstFlyer, dstEng, refFac;\n  dstEng = FlyerEngRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (dstFlyer < dstEng) dstEng = dstFar;\n  dstAst = AstRay (ro, rd);\n  if (dstFlyer < min (dstAst, dstFar)) {\n    ro += rd * dstFlyer;\n    vn = FlyerNf (ro);\n    col4 = FlyerCol ();\n    col = col4.rgb;\n    refFac = 0.;\n    if (col4.a >= 0.) {\n      col = col * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.)) +\n         col4.a *  pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      refFac = 0.5;\n    } else if (col4.a == -1.) refFac = 0.9;\n    if (refFac > 0.) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstAst = AstRay (ro, rd);\n      col = mix (col, AstCol (ro, rd, dstAst), refFac);\n    }\n  } else col = AstCol (ro, rd, dstAst);\n  if (dstEng < min (dstAst, dstFar)) col = mix (col, vec3 (1., 0.5, 0.1), 0.7);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = - asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = clamp (rl - 3. * TrackAcc (s).x, -0.4 * pi, 0.4 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, ori, ca, sa;\n  vec2 canvas, uv, mMid, ut, mSize;\n  float el, az, asp, vuDir;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (1. / mSize.y, 1. / mSize.y - 1.) * mSize * vec2 (1. - 1./6., -1.);\n  ut = abs (uv - mMid) - mSize;\n  vuDir = 1.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuDir = -1.;\n  }\n  szFacFl = 0.005;\n  spd = 1.5;\n  tCur = mod (tCur, 10800.) + 30.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x < 0.5 - 1./6. || mPtr.y > -0.5 + 1./6.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.6 * pi * mPtr.y;\n    } else vuDir *= -1.;\n  }\n  ori = vec3 (el, az, 0.02 * pi * (Fbm1 (tCur) - 0.5));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  FlyerPM (spd * tCur + ((vuDir > 0.) ? 0.5 + 0.45 * sin (0.2 * tCur) :\n     - (0.25 + 0.2 * sin (0.2 * tCur))), 0.03 * pi * (Fbm1 (1.3 * tCur) - 0.5), 0.);\n  flyerPos = flPos;\n  flyerMat = flMat;\n  FlyerPM (spd * tCur, 0., vuDir);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.7));\n  rd = rd * flMat;\n  rd = vuMat * rd;\n  ltDir = normalize (vec3 (1., 1., ((vuDir >= 0.) ? -1. : 1.)));\n  ltDir.xy = Rot2D (ltDir.xy, -0.07 * pi * tCur);\n  dstFar = 40.;\n  col = ShowScene (ro, rd);\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0.1, 0.1, 0.8);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGcDh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 967, 993, 993, 1074], [1076, 1076, 1101, 1101, 1208], [1210, 1210, 1235, 1235, 1358], [1360, 1360, 1378, 1378, 1681], [1683, 1683, 1705, 1705, 1903], [1905, 1905, 1928, 1928, 2087], [2089, 2089, 2122, 2122, 2688], [2690, 2690, 2711, 2711, 2945], [2947, 2947, 2974, 2974, 3248], [3250, 3250, 3288, 3288, 3469], [3471, 3471, 3495, 3495, 4349], [4351, 4351, 4386, 4386, 4565], [4567, 4567, 4590, 4590, 4798], [4800, 4800, 4818, 4818, 6288], [6290, 6290, 6313, 6313, 6845], [6847, 6847, 6893, 6893, 7461], [7463, 7463, 7498, 7498, 8451], [8453, 8453, 8497, 8497, 9019], [9021, 9021, 9074, 9074, 10800], [10802, 10802, 10848, 10848, 10895], [10897, 10897, 10939, 10939, 10990], [10992, 10992, 11045, 11045, 11106], [11108, 11108, 11151, 11151, 11224], [11226, 11226, 11271, 11271, 11374], [11376, 11376, 11433, 11433, 11516], [11518, 11518, 11540, 11540, 11578], [11580, 11580, 11610, 11610, 11668], [11670, 11670, 11694, 11694, 11830], [11864, 11864, 11888, 11888, 11948], [11950, 11950, 11974, 11974, 12027], [12029, 12029, 12053, 12053, 12183], [12185, 12185, 12209, 12209, 12402], [12404, 12404, 12428, 12428, 12648], [12650, 12650, 12675, 12675, 12821], [12823, 12823, 12848, 12848, 13034], [13036, 13036, 13061, 13061, 13286], [13288, 13288, 13310, 13310, 13464], [13466, 13466, 13487, 13487, 13642], [13644, 13644, 13673, 13673, 13885], [13887, 13887, 13926, 13926, 14106]]}
{"id": "4dGcDW", "name": "Polygon Infinity", "author": "smiarx", "description": "Yet another album cover inspired shader. This time King Gizzard's Nonagon Infinity. Ref http://nonagoninfinity.com/", "tags": ["geometry", "polygon", "cover"], "likes": 6, "viewed": 163, "published": "Public", "date": "1521944035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.9\n#define COLOR vec4(0.45, 0.1, 0.1, 1.) \n\nconst float twopi = 6.283185307179586;\n\n// utility functions\nfloat rand(in float x)\n{\n    return fract(sin(x)*398442.32);\n}\n\nfloat noise(in float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    //f = f*f*(3. - 2.*f);\n    return mix(rand(i), rand(i+1.), f);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)*2. - 1.); \n}\n\nmat2 rotmat(in float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\n// evil goat mask\n// thanks to FabriceNeyret2\n// https://www.shadertoy.com/view/lsGyWW\n#define S(v,e) smoothstep(3./iResolution.y,0.,abs(v)-(e))\nfloat goatmask( in vec2 uv )\n{\n    uv.y += 0.06;\n    uv = 1.8*uv; \n    float x = abs(uv.x), y=uv.y,z = abs(y-.2)+.05;;\n    return clamp(\n        1.\n         - S(y-x+cos(6.*x)/6.,.72*exp(-3.*x)-.02*x)\n         - S(x*x/6.+z*z*4.,.1)\n         //- S(x*x+y*y/3.,.1);   // try also without this one\n        , 0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float val = 0.;\n    \n    // space transformation\n    uv.x += (2. * rand(uv.y+iTime*3.32) - 1.) * (4./iResolution.x);\n    vec2 uvOrig = uv;\n    uv *= rotmat(iTime * 0.3);\n     \n    // number of vertex\n    int N = 7 + 2*int((tri(iTime*0.3)) * 5.99);\n    int segpervert = N/2;\n    \n    //linewith\n    float linewidth = mix(0.005, 0.025, noise(iTime*15.));\n    \n    //rotation matrix\n    float theta = twopi / float(N);\n    mat2 rot = rotmat(theta);\n\n    float theta2 = theta * .5;\n    mat2 rot2 = rotmat(theta2);\n    \n    \n    // precompute length of segments\n    float seglength[10];\n    for(int i=0; i<segpervert; i++)\n        seglength[i] = 2.* sin(theta2 * float((i+1))) * RADIUS;\n    \n    // Polygon plotting\n    for(int i=0; i<N; i++){\n        \n        // transform space to plot lines at a given vertex\n        vec2 vertuv = uv;\n        vertuv.y -= RADIUS;\n        \n        vertuv *= rot2;\n        for(int j=0; j < segpervert; j++){ \n            \n            // distance function of horizontal line\n        \tfloat y = abs(vertuv.y);\n            // only plot corresponding segment length\n            y += smoothstep(0., -0.1, vertuv.x) + smoothstep(0., 0.1, vertuv.x-seglength[j]);\n        \t\n            // horizontal line and rotate\n       \t\tval += 1.-smoothstep(0.,linewidth,y);\n            vertuv *= rot2;\n        } \n        uv *= rot;  \n    }\n    \n    //val = clamp(val, 0., 1.);\n\n    // Output to screen\n    fragColor = COLOR*val*(1. + 2.7*(1.-goatmask(uvOrig)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGcDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 121, 145, 145, 183], [185, 185, 210, 210, 327], [329, 329, 352, 352, 389], [391, 391, 420, 420, 504], [506, 651, 681, 681, 963], [966, 966, 1023, 1074, 2615]]}
{"id": "4dGczw", "name": "Iced Cake", "author": "dr2", "description": "Delicious taste not included (mouseable)", "tags": ["raymarch", "chocolate", "cake"], "likes": 9, "viewed": 481, "published": "Public API", "date": "1521363315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Iced Cake\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit;\nfloat dstFar, tCur, cakRd, cakHt, cakSlc;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, qs, qr;\n  vec2 cs, cs2;\n  float dMin, d, r, dw1, dw2, db, c;\n  dMin = dstFar;\n  c = cos (pi / (2. * cakSlc));\n  cs = vec2 (cos (pi / cakSlc), sin (pi / cakSlc));\n  cs2 = vec2 (cos (2. * pi / cakSlc), sin (2. * pi / cakSlc));\n  dw1 = SmoothBump (0.15, 0.6, 0.1, mod (0.1 * tCur, 1.));\n  dw2 = SmoothBump (0.4, 0.85, 0.1, mod (0.1 * tCur, 1.));\n  r = length (p.xz);\n  qs = p;\n  qs.xz = Rot2D (qs.xz, 2. * pi * (floor (cakSlc * ((r > 0.) ? atan (qs.z, - qs.x) / (2. * pi) :\n     0.) + 0.5) / cakSlc));\n  qr = p;\n  qr.xz = Rot2Cs (qr.xz, cs);\n  qr.xz = Rot2D (qr.xz, 2. * pi * (floor (cakSlc * ((r > 0.) ? atan (qr.z, - qr.x) / (2. * pi) :\n     0.) + 0.5) / cakSlc));\n  for (int k = 0; k < 3; k ++) {\n    q = qs;\n    qq = p;\n    if (k == 0) {\n      qq.xz = Rot2D (qq.xz, pi / cakSlc);\n      db = - dot (vec2 (abs (qq.z), qq.x), cs2);\n    } else {\n      qq = p;\n      if (k == 1) {\n        db = max ((dw1 * cs.y - abs (qr.z)) * c, dot (vec2 (abs (qq.z), dw1 + qq.x), cs));\n        q.x += dw1;\n      } else {\n        qq.xz = Rot2D (qq.xz, 2. * pi / cakSlc);\n        db = max ((dw2 * cs.y - abs (qr.z)) * c, dot (vec2 (abs (qq.z), dw2 + qq.x), cs));\n        q.x += dw2;\n      }\n    }\n    d = PrCylDf (q.xzy, cakRd, cakHt);\n    d = SmoothMin (d, length (vec2 (abs (abs (length (q.xz) - 0.47 * cakRd) - 0.33 * cakRd) -\n       0.2 * cakRd + 0.05, q.y - cakHt)) - 0.05, 0.03);\n    d = SmoothMin (d, PrTorusDf ((q + vec3 (0.8 * cakRd, - cakHt, 0.)).xzy, 0.05, 0.15 * cakRd), 0.03);\n    d = SmoothMin (d, PrTorusDf (vec3 (q.xz, abs (q.y) - 0.33 * cakHt), 0.05 * (1. +\n       0.5 * SmoothBump (-0.1, 0.1, 0.02, q.z / cakRd)), cakRd), 0.03);\n    d = max (d, db);\n    DMINQ (1);\n    q.y -= cakHt;\n    d = max (PrSphDf (q, 0.1), db);\n    DMINQ (2);\n    q.x -= -0.8 * cakRd;\n    d = max (PrSphDf (q, 0.1), db);\n    DMINQ (3);\n  }\n  q = p;\n  q.y -= - cakHt - 0.051;\n  d = PrCylDf (q.xzy, cakRd + 1.1, 0.05);\n  DMINQ (4);\n  return dMin;\n}\n     \nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn;\n  vec2 s;\n  float dstObj, spec, r, a, t, dfSum, spSum, at;\n  bool isRefl;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = 7. * vec3 (0., 1., 1.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. -0.1 * pi * tCur);\n  }\n  ltPos[3] = 7. * vec3 (1., 1., 0.);\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  cakRd = 2.;\n  cakHt = 0.5;\n  cakSlc = 13.;\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  if (dstObj < dstFar && idObj == 4) {\n    if (length (qHit.xz) < 3.05) {\n      isRefl = true;\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vn = VaryNf (32. * qHit, vn, 0.5);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      r = length (qHit.xz);\n      if (abs (qHit.y) < cakHt - 0.05 && r < cakRd - 0.1) {\n        t = 3. * qHit.y / (2. * cakHt) + 0.1 * sin (4. * pi * r);\n        col = mix (((floor (t + 0.5) == 0.) ? vec3 (0.6, 0.3, 0.1) : vec3 (0.9, 0.7, 0.1)),\n           vec3 (0.6, 0., 0.), SmoothBump (-0.05, 0.05, 0.01, mod (t, 1.) - 0.5)) *\n           (1. - 0.1 * Noisefv2 (64. * vec2 (r, qHit.y)));\n        spec = 0.05;\n        vn = VaryNf (64. * vec3 (r, qHit.yz), vn, 1.);\n      } else {\n        a = (r > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) : 0.;\n        s = vec2 (8. * abs (r - 0.5 * cakRd + 0.05), mod (4. * cakSlc * a, 1.) - 0.5);\n        t = length (s);\n        col = vec3 (0.4, 0.2, 0.);\n        if (qHit.y > cakHt - 0.001 && t < 0.48) {\n          col = mix (vec3 (0.3, 0.1, 0.), col, smoothstep (0.2, 0.25, t));\n          vn.xz = 0.2 * normalize (s) * SmoothBump (0.25, 0.43, 0.05, t);\n          vn.y = sqrt (1. - dot (vn.xz, vn.xz));\n        }\n        col = mix (col, vec3 (0.9, 0.7, 0.5), smoothstep (0.005, 0.015, qHit.y - cakHt));\n        spec = 0.2;\n        if (abs (qHit.y) < cakHt && abs (r - cakRd) < 0.005)\n           vn.xz = Rot2D (vn.xz, -0.2 * sin (pi * (mod (16. * cakSlc * a, 1.) - 0.5)));\n      }\n    } else if (idObj == 2) {\n      col = mix (vec3 (0.9, 0.3, 0.2), vec3 (0.3, 0.9, 0.2), step (length (qHit), 0.07));\n      spec = 0.1;\n    } else if (idObj == 3) {\n      col = vec3 (0.9, 0.9, 0.95);\n      spec = 0.4;\n    } else if (idObj == 4) {\n      col = vec3 (0.9, 0.9, 0.7);\n      spec = 0.2;\n    }\n    dfSum = 0.;\n    spSum = 0.;\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.5, 0.6, dot (normalize (ltPos[k] - ro), ltDir));\n      dfSum += at * max (dot (vn, ltDir), 0.);\n      spSum += at * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n    col = col * (0.1 + 0.35 * dfSum);\n    if (! isRefl) col += 0.6 * spec * spSum;\n    if (isRefl) col = mix (col, vec3 (0.8), 0.05);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = (15./26.) * pi;\n  el = -0.18 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.12 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 7. - 2. * abs (el); //0.8 * lookU.z;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGczw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 628, 650, 650, 2583], [2590, 2590, 2623, 2623, 2800], [2802, 2802, 2823, 2823, 3023], [3025, 3025, 3060, 3060, 5960], [5962, 5962, 6018, 6018, 6904], [6906, 6906, 6939, 6939, 6966], [6968, 6968, 7010, 7010, 7061], [7063, 7063, 7109, 7109, 7166], [7168, 7168, 7213, 7213, 7316], [7318, 7318, 7375, 7375, 7458], [7460, 7460, 7490, 7490, 7548], [7550, 7550, 7581, 7581, 7645], [7679, 7679, 7703, 7703, 7833], [7835, 7835, 7860, 7860, 8046], [8048, 8048, 8077, 8077, 8289], [8291, 8291, 8330, 8330, 8510]]}
{"id": "4dGyzR", "name": "SPACEJUNK", "author": "greendestruction", "description": "Some kind of rusted tunnel", "tags": ["raymarch"], "likes": 7, "viewed": 632, "published": "Public API", "date": "1520718635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* greetings to shadertoy friends everywhere! */\n/* no textures were harmed in the making of this shader */\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat map(vec3 p) {\n\tvec3 q = abs(p);\n    float c = 0.9;\n    float d = max(q.x, max(q.y, q.z)) - 1.0;\n    d = max(d, c - max(q.y, q.z));\n    d = max(d, c - max(q.x, q.z));\n    d = max(d, c - max(q.x, q.y));\n    return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 fc = vec3(0.0);\n    float m = 1.0;\n    \n    for (int n = 0; n < 5; ++n) {\n        vec3 po = vec3(0.0, 0.0, iTime * 0.5);\n        vec3 pr = normalize(vec3(uv, 1.0));\n        \n        pr.xz *= rot(sin(iTime * 0.25) * 0.25);\n\n        float td = 0.75 + float(n);\n        \n        float pt = 0.0;\n        for (int i = 0; i < 16; ++i) {\n            vec3 mp = po + pr * pt;\n            pt += td - length(mp.xy);\n        }\n\n        vec3 pw = po + pr * pt;\n        \n        pw.xy /= td;\n\n        float tc = 5.0;\n        \n        pw.xy *= rot(iTime * 0.125 * (mod(floor(pw.z / tc) + float(n), 2.0) * 2.0 - 1.0));\n        \n        pw.z = (fract(pw.z / tc) - 0.5) * tc;\n\n        vec3 st = vec3(atan(pw.y, pw.x) / 3.141592, length(pw), 1.0);\n\n        st.x = abs(st.x) - 0.5;\n        st.y -= 0.5;\n\n        st.xy *= 1.0 + float(n) * 0.125;\n\n        for (int i = 0; i < 8; ++i) {\n            st.xy = abs(st.xy) - 0.5;\n            st.xy *= rot(3.141592 * 0.25);\n            st *= 1.1;\n        }\n\n        st.xy /= st.z;\n\n        vec3 r = normalize(vec3(st.xy, 1.0));\n        vec3 o = vec3(0.0, 0.0, -4.0 - float(n));\n        \n        float t = trace(o, r);\n        vec3 w = o + r * t;\n        float fd = map(w);\n\n        float f = 1.0 / (1.0 + pt * pt * 0.1 + fd * 100.0);\n        \n        float tb = 1.0 / (1.0 + t * t * 0.1);\n        vec3 tex = mix(vec3(1.0, 0.25, 0.25), vec3(0.5, 1.0, 0.5), tb);\n        fc += tex * f * m;\n        m *= max(sign(fd - 0.1), 0.0);\n    }\n\n    fragColor = vec4(fc, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 128, 128, 180], [182, 182, 201, 201, 404], [406, 406, 435, 435, 540], [542, 542, 599, 599, 2214]]}
{"id": "4dGyzz", "name": "Rift 2004", "author": "Pr0fed", "description": "My first raymarched terrain. Heavily based on Shane's \n\"Dry Rocky Gorge\" https://www.shadertoy.com/view/lslfRN and IQs articles.\n\nLol, looks like from 2004. I guess it need some anti aliasing, motion blur and godrays :) WIP", "tags": ["raymarching"], "likes": 7, "viewed": 296, "published": "Public", "date": "1520756145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------\n//\n// Most of this shader is based on Shane's \"Dry Rocky Gorge\".\n// https://www.shadertoy.com/view/lslfRN\n//\n// First of all i'd like to say, that of course this is just \n// learning, so a lot of code is taken as it is and tweaked.\n// I was trying to understand the concept behind raymarching,\n// the fBm and noise derivateves as the part of a terrain \n// raymarching.\n//\n// First i've done it using Unity (HLSL) and then switched \n// back here for feedback and future contributions.\n// If anyone interested here how the first version looked:\n// https://pr0fed.itch.io/raymarched-terrain-learning\n// (May not work on MacOS, GLES was not included also).\n//\n// Hopefully my commentaries would help someone to understand \n// terrain raymarching better. At least that worked for me :)\n//\n// Some of the commentaries are left from Shane's code because\n// there was nothing else to say or i don't understand it yet.\n//\n// * Upd 11.03 - Added ground level fog from IQs article. \n//   http://www.iquilezles.org/www/articles/fog/fog.htm\n//\n// * Upd 12.03 - Tweaked sun distance formula. Raised sun height.\n//\t removed shades brightening, decreased min. diffuse value. \n//\t (Actually in tunnels diffuse is obviously wrong, should be darker\n//\t  there).\n//\n// * Upd 14.03 Renamed to Rift 2004 as mentioned in comments :)\n//\n//-----------------------------------------------------------------\n\n\n//-----------------------------------------------------------------\n//      IMPORTANT CONSTANTS\n//-----------------------------------------------------------------\n\nconst float drawdist = 60.;\nconst int maxstep = 160;\nconst vec3 SkyColor = vec3(0., 0.54, 0.81);\nconst vec3 FogColor = vec3(0.266, 0.396, 0.27);\n//const vec3 FogColor = vec3(0.45);\nconst vec3 SpecColor = vec3(0.837, 0.309, 0.254);\nconst vec3 SunColor = vec3(0.769, 0.637, 0.501);\nconst vec3 LightPos = vec3(-33., 75., 142.);\n\n// Seems to be seed Shane used here and there, so i moved it up.\nconst vec3 seed = vec3(7, 157, 113);\n\n//-----------------------------------------------------------------\n//\t\tHELPER FUNCTIONS\n//-----------------------------------------------------------------\n\n// Rotation matrix used in camera rotation.\nmat2 r2(in float a)\n{\n    float c = cos(a), s = sin(a); return mat2(c, s, -s, c);\n}\n\n// vec3 to float hash.\nfloat hash31( vec3 p )\n{ \n    return fract(sin(dot(p, seed))*45758.5453); \n}\n\n// Non-standard vec3-to-vec3 hash function. (From Shane's code).\nvec3 hash33(vec3 p)\n{\n    float n = sin(dot(p, seed));\n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\n\n\n// Shane modification of IQs 3D Value noise.\nfloat n3D(vec3 p)\n{\n    vec3 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., seed.yz, seed.y + seed.z) + dot(ip, seed);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + seed.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Shane modification of IQs 2D noise.\nfloat n2D(vec2 p)\n{\n    vec2 i = floor(p); p -= i; p *= p*(3. - p*2.);\n    return dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n}\n\n// Tri-Planar blending function. Didn't work with them at all,\n// so can't say much.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n)\n{\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1., 1., 1.));\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Some kind of sRGB - linear space conversion.\n    return (tx * tx * n.x + ty * ty * n.y + tz * tz * n.z);\n}\n\n// Just an epsilon for normals.\nconst vec2 e = vec2(0.002, 0);\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf) \n{\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n\n    // Converting to greyscale.\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(tex3D(tx, p, n), vec3(0.299, 0.587, 0.114))) / e.x; g -= n*dot(n, g);\n\n    // Bumped normal. \"bf\" - bump factor.\n    return normalize(n + g * bf); \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z) \n{\n    return vec2(sin(z * .092) * 8., cos(z * .5) * .15); \n}\n\n// Shanes smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s) \n{\n    float h = clamp(.5 + .5*(a - b) / s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Distance function.\nfloat fmap(vec3 p) \n{\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1) / 400.;\n\n    return n3D(p)*0.57 + n3D(p*4.)*0.28 + n3D(p*8.)*0.15;\n}\n\n\n//-----------------------------------------------------------------\n//\t\tMAIN FUNCTIONS\n//-----------------------------------------------------------------\n\n// Main terrain function.\nfloat terrain(vec2 p) \n{\n    // Choosing a suitable starting frequency.\n    p /= 9.; \n\n    // Amplitude, amplitude total, and result variables.\n    float a = 1., sum = 0., res = 0.;\n\n    // Number of noise layers we run to generate the terrain.\n    for (int i = 0; i < 3; i++) \n    {\n        // Adding the noise value for this layer - multiplied by the amplitude.\n        res += n2D(p) * abs(a) * .78; \n\n        p *= 4.2; \n\n        sum += a;\n\n        // Tempering the amplitude. Note the negative sign - a less common variation - which\n        // was thrown in just to mix things up.\n        a *= -.5 / 1.315;\n    }\n\n    // Return the noisy terrain value.\n    return res / sum;\n}\n\nfloat map(vec3 p) \n{\n    // The noise layers.\n    float trSf = terrain(p.xz);\n\n    // Wrap the gorge around the path.\n    p.xy -= path(p.z); \n\n    \n    vec2 ca = abs(p.xy * vec2(0.75, .7) + vec2(0.73, 1.55));\n\n    // Some magic here. To understand it, one should start with a straight plane and\n    // try adding some noise and everything else, looking how it changes the terrain.\n    // Smoothly carve out the gorge from the plane, then add the noise to the result.\n    float n = smax(4. - mix(length(ca), max(ca.x, ca.y), .18), p.y - 0.825, 2.) + (.5 - trSf) * 4.;\n\n    // Return the minimum hit point.\n    return n * .7;\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n\n    for (int i = 0; i < maxstep; i++)\n    {\n        \n        d = map(ro + rd * t);\n        if (abs(d) < .001 * (t * .125 + 1.) || t > drawdist) break;\n\n        t += d;\n    }\n\t\n    // We either hit something, or exceeded the drawdist.\n    return min(t, drawdist);\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal(in vec3 p) \n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.02, -0.02);\n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n\n//-----------------------------------------------------------------\n//\t\tCOLORING\n//-----------------------------------------------------------------\n\n\n// Shadow iteration count.\nconst int maxIterationsShad = 48;\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t) \n{\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025 * (t * .125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i < maxIterationsShad; i++) \n    {\n        float h = map(ro + rd * dist);\n        \n        \n        shade = min(shade, smoothstep(0.0, 1.0, k*h / dist)); \n        \n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .2);\n\n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break;\n    }\n\n    return min(max(shade, 0.), 1.);\n}\n\n// Ambient occlusion by Shane. He said he collects AO routines :)\n// Anyway a bit of magic for me.\nfloat calcAO(in vec3 p, in vec3 nor)\n{\n    float sca = 1.5, occ = 0.;\n\n    for (float i = 0.; i < 5.; i++) \n    {\n        float hr = .01 + i*.5 / 4.;\n        float dd = map(nor*hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n\n    return clamp(1. - occ, 0., 1.);\n}\n\n// Coloring\\texturing the scene objects.\nvec3 getObjectColor(vec3 p, vec3 n) \n{\n    p.xy -= path(p.z);\n\n    // Texture value.\n    vec3 tx = tex3D(iChannel0, p / 8., n); \n\n    // Shane:\n    // Hinting that there's some dry vegetation below. The flatter the surface (based on n.y), the greater \n    // the chance that something's growing on it. Physical trees would be much nicer, and I'm working on that,\n    // but for now, cheap trickery will have to suffice. :) By the way, take a look at IQ's \"Rainforest\"\n    // example for an amazing looking compromise.\n    vec3 gr = mix(vec3(1, 1, 1), vec3(.8, 1.3, .2), smoothstep(.5, 1., n.y));\n    return mix(tx, tx * gr, smoothstep(0.0, 1.11, (n.y)));\n}\n\n// 4 layers clouds routine by Shane (taken as it is):\nvec4 cloudLayers(vec3 ro, vec3 rd, vec3 lp, float far)\n{\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.004 - 0.002));\n\n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(seed, rd.zyx))*43758.5453)*0.04 - 0.02);\n\n    // Local density, total density, and weighting factor.\n    float ld = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .4;\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0., 0., 0.), sp;\n    vec4 d4 = vec4(1, 0, 0, 0);\n\n    // Particle surface normal.\n    //\n    // Shanes hacky reasoning: \"I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\"\n    vec3 sn = normalize(hash33(rd.yxz)*.03 - rd);\n\n    // Raymarching loop.\n    for (int i = 0; i < 4; i++) {\n\n        // Loop break conditions.\n        if (td > 1. || t > far)break;\n\n        // Current ray position.\n        sp = ro + rd*t;\n        d = fmap(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        ld = (h - d) * step(d, h);\n        w = (1. - td) * ld;\n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n\t\t// Looks cleaner, but a little washed out.\n        td += w*.5 + 1. / 65.; \n\n        // Point light calculations.\n        vec3 ld = lp - sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld /= lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 100. / (1. + lDist * 0.005 + lDist * lDist * 0.00005);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot(sn, ld), 0.);\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 4.);\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        //col += w*(1. + diff*.5 + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        col += w*(diff + vec3(1, .75, .5)*spec + .5)*atten;//*1.25;\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        t += max(d4.x*.5, 0.25)*100.;\n    }\n\n    return vec4(col, t);\n}\n\n// So basically we add a sky color, a sun, based on LightPos and then add clouds.\nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp, float t)\n{\n    float sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n    \n    // If i'd have a horizon, i'd blend the sun color near norizon. But i don't.\n    //float horiz = pow(1.0 - max(rd.y, 0.0), 3.) * .25; // Horizon strength.\n\t//col = mix(col, vec3(1, .5, .25), horiz);\n    \n    // Setting the sky color.\t\n    vec3 col = mix(SkyColor, vec3(.9, .45, .45), sun * .5);\n\n    // Sun. Producing the sun with three layers, \n    // rather than just the one. Much better.\n    col += 0.25 * SunColor * pow(sun, 5.0);\n    col += 0.25 * SunColor * pow(sun, 64.0);\n    col += 0.15 * SunColor * max(pow(sun, 512.0), .35);\n\n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    //col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n\n    // Clear sky day. Just a blue sky color and a sun. No clouds. Cheap :)\n    //return col; \n\n    \n    // Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n\n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n\n    // If we haven't hit anything and are above the horizon point (there for completeness), render the sky.\n\n    // Raytrace to a plane at 2km. (assuming 1 unit is a meter).\n    float tt = (2000. - ro.y) / (rd.y + .2);\n\n    if (t >= drawdist && tt > 0.)\n    {\n        // Trace out a very small number of layers. In fact, there are so few layer that the following\n        // is almost pointless, but I've left it in.\n        vec4 cl = cloudLayers(ro + rd*tt, rd, lp, drawdist * 3.);\n        vec3 clouds = cl.xyz;\n\n        // Mix in the clouds.\n        col = mix(col, vec3(1., 1., 1.), clouds); // *clamp(rd.y*4. + .0, 0., 1.)\n    }\n\n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, shadows etc.\n// Personally i'm not yet very familiar with all the lighting techniques, so making the basics only.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t)\n{\n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0., 0., 0.);\n\n    if (t < drawdist)\n    { \n        // If we've hit a scene object, light it up.\n\n        // Advancing the ray origin, \"ro,\" to the new hit point.\n        vec3 sp = ro + rd * t;\n\n        // Retrieving the normal at the hit point.\n        vec3 sn = getNormal(sp);\n        \n        vec3 tx = sp;\n        sn = doBumpMap(iChannel0, tx / 3., sn, .025);\n        \n        // Looks to be a right way to do sun distance vec.\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        // Attenuating the light, based on distance.\n        float atten = 3./ (1. + lDist * 0.0005 + lDist * lDist * 0.000005);\n       \n        // Standard diffuse tweaked to have darker regions.\n        float diff = max(dot(sn, ld), -0.15);\n\n        // Standard specular term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 64.0);\n\n        // Ambient occlusion and shadows\n        float sh = softShadow(sp + sn, lp, 8., t);\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao * .25) * ao;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol * (diff + SpecColor * spec + ao *.5);\n\n        // Apply attenuation and shadows.\n        sceneCol *= atten * sh * SunColor;\n\n        // Simple fog addition. (Screen space)\n        //float fog = smoothstep(0.3, 0.95, t / drawdist);\n        //sceneCol = mix(sceneCol, FogColor, fog);\n    }\n\t\n    // If we didn't hit scene obj - we color the sky.\n    \n    // Not sure if it is cheaper to make it conditional here\n    // or to calc sky for whole picture. Any clues?\n    else \n    {\n        sceneCol = getSky(ro, rd, lp, t);\n    }\n\n    // Return the color. Done once for each pass.\n    return sceneCol;\n}\n\nvec3 applyFog(in vec3  rgb,      // original color of the pixel\n\t\t\t\tin float distance, // camera to point distance\n\t\t\t\tin vec3  rayOri,   // camera position\n\t\t\t\tin vec3  rayDir)  // camera to point vector\n{\n\tfloat fogAmount = 0.0025 * exp(-rayOri.y * 0.55) * (1.0 - exp(-distance * rayDir.y * 0.55)) / rayDir.y;\n\treturn mix(rgb, FogColor * SunColor, fogAmount);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(-.9, -2.25, iTime*2.5); // Camera position.\n\tvec3 lk = ro + vec3(0., -3.5, 20.315);  // \"Look At\" position.\n \n   \n    // Light position. I've chosen a place where we can see the sun while\n    // moveing through the path.\n    vec3 lp = ro + LightPos;\n    \n    \n    // As long as we use path function, we would be ok.\n    // Path function gurantees we are in the center of our rift.\n    // Of course having wrong noise values will lead us being inside a wall,\n    // (This sometimes happen in this shader, in small \"rock windows\" camera pass)\n    // but if the rift is wide enough - that shouldn't happen.\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159 / 3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/46.);\n\n    // Trace the scene.\n    float t = trace(ro, rd);\n\n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    sceneColor = applyFog(sceneColor, t - ro.y, ro, rd);\n\n    // Returns final color.\n    fragColor = vec4(sqrt(clamp(sceneColor,0. ,1.)), 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGyzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2203, 2247, 2268, 2268, 2330], [2332, 2355, 2379, 2379, 2431], [2433, 2498, 2519, 2519, 2604], [2608, 2653, 2672, 2672, 2958], [2960, 2999, 3018, 3018, 3220], [3222, 3307, 3354, 3354, 3640], [3706, 3788, 3851, 3957, 4296], [4298, 4398, 4422, 4422, 4481], [4483, 4539, 4579, 4579, 4671], [4673, 4695, 4716, 4767, 4859], [5018, 5044, 5068, 5115, 5723], [5725, 5725, 5745, 5770, 6350], [6352, 6385, 6416, 6416, 6703], [6705, 6777, 6805, 6920, 7067], [7283, 7584, 7639, 7639, 8564], [8566, 8665, 8703, 8703, 8944], [8946, 8987, 9025, 9025, 9643], [9645, 9699, 9755, 10117, 13594], [13596, 13678, 13733, 13733, 15603], [15605, 15807, 15866, 15917, 17950], [17952, 17952, 18158, 18158, 18315], [18318, 18318, 18374, 18401, 20160]]}
{"id": "4dKyRD", "name": "Varignon's Theorem, Projectively", "author": "mla", "description": "Projective version of Varignon's theorem: the red points form a quadrangle, intersect 4 sides with the green line and conjugate. Draw pairs of (red) lines through the conjugates - they intersect on the green line, concurrent with one of the diagonals.", "tags": ["projective", "varignon", "theorem"], "likes": 10, "viewed": 5121, "published": "Public API", "date": "1521233458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective version of Varignon's Theorem\n//\n// Copyright (c) Matthew Arcus, 2018\n// MIT License: https://opensource.org/licenses/MIT\n//\n// Varignon's Theorem, Projective Version\n//\n// Controls:\n// Use mouse to move line, which is reciprocal to the mouse position.\n// 'd': show dual configuration\n// '1' and '2': change initial configuration\n// 'f': change line & point drawing style\n// 'z': zoom in\n// 'v': put line at infinity\n//\n// Take a quadrangle ABCD and line L. Pick 2 non-opposite\n// sides, AB,BC, say, and their opposites, CD,DA: each\n// side intersects L & the point of intersection has a\n// harmonic conjugate on that side. Draw a line through the \n// conjugates on AB and BC and those on CD and DA, the two\n// lines, and a diagonal meet on L at a point.\n//\n// If L is the line at infinity, the conjugates are the\n// midpoints of the sides and we have the original\n// Euclidean theorem.\n//\n// https://plus.google.com/+johncbaez999/posts/hE2bhKZuBzc\n// https://en.wikipedia.org/wiki/Varignon%27s_theorem\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\nbool invert = false;\nbool drawdual = false;\n\nconst float lwidth = 0.03;\nconst float pwidth = 0.12;\nfloat ledge0 = 0.0, ledge1 = lwidth;\nfloat pedge0 = 0.5*(lwidth+pwidth), pedge1 = pwidth;\nconst float scale = 2.5;\nfloat zoom = 1.0;\n\nconst float PI =  3.141592654;\nfloat eps = 1e-4;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = pcolor2;\nvec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\n\nconst int CHAR_SPACE = 32;\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nbool keypress(int key);\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Distance from the conic\nfloat dist(vec3 p, mat3 m) {\n  return dot(p,m*p);\n}\n\n// The gradient uses the same matrix.\n// Don't homegenize the result!\nvec3 grad(vec3 p, mat3 m) {\n  return m*p*2.0;\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float d = dist(p,m);\n  vec3 dd = grad(p,m);\n  d = abs(d/(p.z*length(dd.xy))); // Normalize for Euclidean distance\n  return 1.0-smoothstep(ledge0,ledge1,d);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 solve(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  vec3 p4a = p*p4;\n  float a = p4a.x, b = p4a.y, c = p4a.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\nfloat point0(vec3 p, vec3 q) {\n  if (abs(p.z) < eps) return 0.0;\n  if (abs(q.z) < eps) return 0.0;\n  p /= p.z; q /= q.z; // Normalize\n  return 1.0-smoothstep(pedge0,pedge1,distance(p,q));\n}\n\nfloat line0(vec3 p, vec3 q) {\n  // Just treat as a degenerate conic. Note factor of 2.\n  // We could do this more efficiently of course.\n  return conic(p,mat3(0,  0,  q.x,\n                      0,  0,  q.y,\n                      q.x,q.y,2.0*q.z));\n}\n\nfloat point(vec3 p, vec3 q) {\n  if (drawdual) return line0(p,q);\n  else return point0(p,q);\n}\n\nfloat line(vec3 p, vec3 q) {\n  if (drawdual) return point0(p,q);\n  else return line0(p,q);\n}\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*zoom*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = iTime;\n  //if (keypress(CHAR_SPACE)) t = 0.0;\n  p.x -= sin(0.08*t);\n  p.xy = rotate(p.xy,0.2*t);\n  p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  if (invert) return mix(color0,1.0-color1,level);\n  else return mix(color0,color1,level);\n}\n\nvec3 mid(vec3 p, vec3 q) {\n  return p*q.z + q*p.z;\n}\n\nbool keypress(int code) {\n#if defined LOCAL || __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  drawdual = keypress(CHAR_D);\n  invert = keypress(CHAR_I);\n  if (invert) ccolor0 = vec3(0);\n  if (keypress(CHAR_Z)) zoom = 0.25;\n  if (keypress(CHAR_F)) {\n      float pixelwidth = 4.0*scale/iResolution.y;\n      pedge0 = pwidth-pixelwidth;\n      //pedge1 = pwidth+pixelwidth;\n      ledge0 = lwidth-pixelwidth;\n      //ledge1 = lwidth+pixelwidth;\n  }    \n  configuration = int(keypress(CHAR_0+1)) + 2*int(!keypress(CHAR_0+2));\n  vec3 p = map(fragCoord.xy);\n  vec3 p0,p1,p2,p3,p4; // p4 is the movable point\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0);\n    p2 = vec3(0,0,1); p3 = vec3(1,1,1);\n    p4 = vec3(0.5,-1,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1);\n    p2 = vec3(0,1,1); p3 = vec3(1,1,1);\n    p4 = vec3(0.5,-1,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,0,1);\n    p1 = vec3(0,1,1);\n    p2 = vec3(0.866,-0.5,1);\n    p3 = vec3(-0.866,-0.5,1);\n    p4 = vec3(0,0.618,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1);\n    p2 = vec3(-1,0,1); p3 = vec3(0,-1,1);\n    p4 = vec3(0.5,-1,1);\n  }\n  p0 = transform(p0); p1 = transform(p1);\n  p2 = transform(p2); p3 = transform(p3);\n  if (iMouse.x != 0.0) {\n    p4 = map(iMouse.xy);\n  }\n  if (keypress(CHAR_V)) {\n     p4 = vec3(0,0,1);\n  }\n  vec3 p01 = join(p0,p1);\n  vec3 p02 = join(p0,p2);\n  vec3 p03 = join(p0,p3);\n  vec3 p12 = join(p1,p2);\n  vec3 p13 = join(p1,p3);\n  vec3 p23 = join(p2,p3);\n\n  // The line through A,B intersects line L at\n  // (A.L)B - (B.L)A, whose conjugate is (A.L)B + (B.L)A\n  vec3 s01 = dot(p4,p0)*p1 + dot(p4,p1)*p0;\n  vec3 t01 = dot(p4,p0)*p1 - dot(p4,p1)*p0;\n  vec3 s12 = dot(p4,p1)*p2 + dot(p4,p2)*p1;\n  vec3 t12 = dot(p4,p1)*p2 - dot(p4,p2)*p1;\n  vec3 s23 = dot(p4,p2)*p3 + dot(p4,p3)*p2;\n  vec3 t23 = dot(p4,p2)*p3 - dot(p4,p3)*p2;\n  vec3 s03 = dot(p4,p3)*p0 + dot(p4,p0)*p3;\n  vec3 t03 = dot(p4,p3)*p0 - dot(p4,p0)*p3;\n\n  vec3 s02 = dot(p4,p0)*p2 + dot(p4,p2)*p0;\n  vec3 t02 = dot(p4,p0)*p2 - dot(p4,p2)*p0;\n  vec3 s13 = dot(p4,p1)*p3 + dot(p4,p3)*p1;\n  vec3 t13 = dot(p4,p1)*p3 - dot(p4,p3)*p1;\n  \n  vec3 color = vec3(0);\n\n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(p,p01));\n  color = cmix(color,lcolor2,line(p,p02));\n  color = cmix(color,lcolor2,line(p,p03));\n  color = cmix(color,lcolor2,line(p,p12));\n  color = cmix(color,lcolor2,line(p,p13));\n  color = cmix(color,lcolor2,line(p,p23));\n  \n  // The moving line\n  color = cmix(color,lcolor1,line(p,p4));\n\n  vec3 l0 = join(s01,s12);\n  vec3 l1 = join(s23,s03);\n  vec3 l2 = join(s12,s23);\n  vec3 l3 = join(s03,s01);\n  //vec3 l4 = join(s02,s23);\n  //vec3 l5 = join(s01,s13);\n  color = cmix(color,lcolor0,line(p,l0));\n  color = cmix(color,lcolor0,line(p,l1));\n  color = cmix(color,lcolor0,line(p,l2));\n  color = cmix(color,lcolor0,line(p,l3));\n  //color = cmix(color,lcolor0,line(p,l4));\n  //color = cmix(color,lcolor0,line(p,l5));\n\n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(p,p0));\n  color = cmix(color,pcolor0,point(p,p1));\n  color = cmix(color,pcolor0,point(p,p2));\n  color = cmix(color,pcolor0,point(p,p3));\n\n  color = cmix(color,pcolor2,point(p,s01));\n  color = cmix(color,pcolor2,point(p,t01));\n  color = cmix(color,pcolor2,point(p,s12));\n  color = cmix(color,pcolor2,point(p,t12));\n  color = cmix(color,pcolor2,point(p,s23));\n  color = cmix(color,pcolor2,point(p,t23));\n  color = cmix(color,pcolor2,point(p,s03));\n  color = cmix(color,pcolor2,point(p,t03));\n\n  color = cmix(color,pcolor1,point(p,join(l0,l1)));\n  color = cmix(color,pcolor1,point(p,join(l2,l3)));\n\n  //color = cmix(color,pcolor1,point(p,join(l4,l5)));\n  \n  if (invert) color = 1.0 - color;\n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKyRD.jpg", "access": "shaders20k", "license": "mit", "functions": [[2494, 2521, 2549, 2549, 2572], [2574, 2644, 2671, 2671, 2691], [2693, 2693, 2722, 2722, 2882], [2884, 3072, 3123, 3230, 3520], [3522, 3633, 3690, 3755, 4093], [4095, 4095, 4125, 4125, 4284], [4286, 4286, 4315, 4422, 4535], [4537, 4537, 4566, 4566, 4630], [4632, 4632, 4660, 4660, 4724], [4726, 4726, 4753, 4851, 4874], [4876, 4906, 4924, 4924, 4997], [4999, 5097, 5133, 5133, 5185], [5187, 5187, 5211, 5211, 5363], [5365, 5365, 5415, 5415, 5508], [5510, 5510, 5536, 5536, 5562], [5564, 5564, 5589, 5589, 5717], [5719, 5719, 5776, 5776, 9451]]}
{"id": "4dtcDj", "name": "minimalistic tardis", "author": "visy", "description": "minimalistic tardis", "tags": ["tardis", "minimalistic"], "likes": 1, "viewed": 91, "published": "Public", "date": "1520247743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float NEAR_CLIPPING_PLANE=.001;\nfloat FAR_CLIPPING_PLANE=100.;\nint NUMBER_OF_MARCH_STEPS=400;\nfloat EPSILON=.005;\nfloat DISTANCE_BIAS=.3;\nfloat t = 0.;\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - (s);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\n\nfloat cellTile(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*2.66; \n}\n\nfloat hex(vec2 p) {\n    p.x *= 0.57735*2.;\n\tp.y += mod(floor(p.x), 2.)*.5;\n\tp = abs((mod(p, 1.) - .5));\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\n}\n\nfloat cellTile2(in vec3 p){\n    vec4 d; \n    d.x = celli(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\n    d.y = celli(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\n    d.z = celli(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\n    d.w = celli(p - vec3(.2, .82, .64));\n    d.xy = min(d.xz, d.yw);\n    return min(d.x, d.y)*.5; \n}\nfloat bump(vec3 pos) {\n    float re = 0.;\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\n    return re;\n}\nvec3 hit;\n\n\nfloat scene(vec3 pos) {\n//\trota(pos);\n//    float of = .3*sin(pos.z*5.5);\n\n    pR(pos.xz,t);\n    float hull = sdRoundBox(pos, vec3(1.0,2.0,1.0), 0.01);\n    float hullCut;\n    \n    // on 4 sides\n    for (float a = 0.; a < 4.; a+=1.0) {\n        pR(pos.xz,a*3.1415/2.);\n\n        // recess\n        \n        float cut1 = sdRoundBox(pos+vec3(-0.45,0.20,1.45), vec3(0.4,1.7,0.5), 0.01);\n        float cut2 = sdRoundBox(pos+vec3(0.45,0.20,1.45), vec3(0.4,1.7,0.5), 0.01);\n\t    hullCut = opS(cut1,hull);\n        hullCut = opS(cut2,hullCut);\n\n        // panels\n        \n        for (float y = 1.45; y > -1.5; y-=0.83) {\n            cut1 = sdRoundBox(pos+vec3(-0.45,y,1.4), vec3(0.3,0.35,0.5), 0.01);\n            hullCut = opS(cut1,hullCut);\n            cut1 = sdRoundBox(pos+vec3(0.45,y,1.4), vec3(0.3,0.35,0.5), 0.01);\n            hullCut = opS(cut1,hullCut);\n        }\n        \n        hull = hullCut;\n\n    }\n\tfloat hullFinal = hullCut;    \n    \n    return hullFinal;\n}\n\nfloat sceneb(vec3 pos) {\n\treturn scene(pos);\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    float acc = 0.;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 pos = position + direction * total_distance;\n        float result = scene(pos);\n        acc+=cos(result*1.)*.05;\n\n        if(result < EPSILON)\n        {\n            return vec2(total_distance, acc);\n        }\n        \n        total_distance += result * DISTANCE_BIAS;\n        \n        \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    return vec2(FAR_CLIPPING_PLANE, acc);\n}\n\nvec3 nr(vec3 n) {\n\treturn normalize(n);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\n\tvec3 nor = vec3(\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\n\treturn nr(nor);\n}\n\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\n  float B = .45 * sigma2 / (sigma2 + .09);\n\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\n}\n\nfloat fader = 1.0;\nfloat fader2 = 1.0;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    // pixel coordinates\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\n    \n    vec3 direction = nr(vec3(uv, 0.));\n\n    t = iTime;\n    \n    float cz = -5.0;\n    \n\n    float FOV = 0.65;\n        \n\tvec3 camera_origin = vec3(0., -0., cz);\n\tvec3 lookAt = vec3(0.,-0.,cz+1.);\n    \n    vec3 forward = nr(lookAt-camera_origin);\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\n    vec3 up = nr(cross(forward,right));\n\n    \n    vec3 ro = camera_origin;\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    vec2 result = raymarch(ro, rd);\n            \n    float fog = 1.0;\n    \n\tvec3 materialColor = vec3(10./255.,23./255.,72./255.);\n\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\n    vec3 intersection = ro + rd*result.x;\n    \n    vec3 nrml = normal(intersection);\n    vec3 light_dir = nr(vec3(1.0,0.0,-1.0));\n    vec3 ref = reflect( rd, nrml );\n\t\n    float dom = smoothstep( -.1, 0.9, ref.y);\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1.0 ),32.);\n\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,1.3,.7);\n    \n    vec3 light_color = vec3(1.);\n    vec3 ambient_color = light_color;\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    vec3 outColor = diffuseLit*fog+dom*.3+spe*.6;\n    if (result.x < FAR_CLIPPING_PLANE) fragColor = vec4(outColor.rgb,1.0);\n    else fragColor=vec4(0.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 186, 186, 213], [215, 215, 260, 260, 300], [302, 302, 335, 335, 360], [362, 362, 395, 395, 421], [424, 424, 457, 457, 482], [485, 485, 517, 517, 559], [561, 561, 584, 584, 621], [623, 623, 649, 649, 1019], [1021, 1021, 1040, 1040, 1172], [1174, 1174, 1201, 1201, 1593], [1594, 1594, 1616, 1616, 1752], [1765, 1765, 1788, 1838, 2726], [2728, 2728, 2752, 2752, 2774], [2776, 2776, 2822, 2822, 3365], [3367, 3367, 3384, 3384, 3408], [3410, 3410, 3438, 3438, 3660], [3664, 3664, 3791, 3791, 4262], [4303, 4303, 4358, 4358, 5770]]}
{"id": "4dVcD1", "name": "Game HP UI", "author": "FishMan", "description": "a game HP (health point) ui effect", "tags": ["2d", "game", "wave", "bubble", "ui"], "likes": 36, "viewed": 672, "published": "Public", "date": "1521973327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a sunny day of sea - by JiepengTan - 2018\n// jiepengtan@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define  SIZE  0.5\n#define WATER_DEEP 0.6\n#define PI 3.1415927\n#define Deg2Radius PI/180.\n\nfloat Rand(float x)\n{\n    return fract(sin(x*866353.13)*613.73);\n}\n\nmat2 Rotate2D(float deg){\n    deg = deg * Deg2Radius;\n\treturn mat2(cos(deg),sin(deg),-sin(deg),cos(deg));\n}\nvec2 Within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\nfloat Remap(float a,float b,float c,float d,float val){\n\treturn (val-a)/(b-a) * (d-c) + c;\n}\n\nfloat Circle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\nfloat PureCircle(vec2 uv,vec2 center,float size,float blur,float powVal){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = 1.-length(uv);\n    float val = clamp(Remap(0.,blur,0.,1.,len),0.,1.);\n    return pow(val,powVal);//* pow(1.+len * 3.,0.1);\n}\nfloat Ellipse(vec2 uv,vec2 center,vec2 size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\n\nvec3 Draw3DFrame(vec2 uv){\n    //cameraPos  \n    vec3 camPos = vec3(0.,0.,-3);\n    //Torus \n\tvec3 frameCol = vec3(0.9,0.75,0.6);\n    float frameMask = Circle(uv,vec2(0.,0.),SIZE*1.1,0.01) - \n        Circle(uv,vec2(0.,0.),SIZE,0.01);\n    return vec3(0.);\n    \n}\nfloat Torus2D(vec2 uv,vec2 center,vec2 size,float blur){\n\tuv = uv - center;\n\tfloat len = length(uv);\n    if(len<size.y || len >size.x)\n        return 0.;\n    float radio = (len-size.y)/(size.x-size.y);\n    float val = 1.-abs((radio-0.5)*2.);\n\treturn pow(val,blur);\n}\n\nvec3 DrawFrame(vec2 uv){\n    vec3 frameCol = vec3(0.9,0.75,0.6);\n    float frameMask = Circle(uv,vec2(0.,0.),SIZE*1.1,0.01) - \n        Circle(uv,vec2(0.,0.),SIZE,0.01);\n    //return frameCol * frameMask;\n    return Torus2D(uv,vec2(0.,0.),vec2(SIZE * 1.1,SIZE),0.2) *frameCol;\n}\nvec3 DrawHightLight(vec2 uv){\n    //up\n    vec3 hlCol = vec3(0.95,0.95,0.95);\n    float upMask = Ellipse(uv,vec2(0.,0.8)*SIZE,vec2(0.9,0.7)*SIZE,0.6)*0.9;\n    upMask = upMask * Circle(uv,vec2(0.,0.)*SIZE,SIZE*0.95,0.02) ;\n    upMask = upMask * Circle(uv,vec2(0.,-0.9)*SIZE,SIZE*1.1,-0.8) ;\n    //bottom\n    uv *= Rotate2D(30.);\n    float btMask =1.;\n    btMask *=  Circle(uv,vec2(0.,0.)*SIZE,SIZE*0.95,0.02);\n    float scale = 0.9;\n    btMask *= 1.- Circle(uv,vec2(0.,-0.17+scale)*SIZE,SIZE*(1.+scale),0.2) ;\n    return  (upMask + btMask) * hlCol;\n    \n}\n\n\nfloat GetWaveHeight(vec2 uv){\n    uv = Rotate2D(-30.)*uv;\n\tfloat wave =  0.12*sin(-2.*uv.x+iTime*4.); \n\tuv = Rotate2D(-50.)*uv;\n\twave +=  0.05*sin(-2.*uv.x+iTime*4.); \n\treturn wave;\n}\n\nfloat RayMarchWater(vec3 camera, vec3 dir,float startT,float maxT){\n    vec3 pos = camera + dir * startT;\n    float t = startT;\n    for(int i=0;i<200;i++){\n        if(t > maxT){\n        \treturn -1.;\n        }\n        float h = GetWaveHeight(pos.xz) * WATER_DEEP;\n        if(h + 0.01 > pos.y ) {//+ 0.01 acc intersect speed\n            // get the intersect point\n            return t;\n        }\n        t += pos.y - h; \n        pos = camera + dir * t;\n    }\n    return -1.0;\n}\n\nvec4 SimpleWave3D(vec2 uv,vec3 col){\n\tvec3 camPos =vec3(0.23,0.115,-2.28);\n    vec3 targetPos = vec3(0.);\n    \n    vec3 f = normalize(targetPos-camPos);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 ray = normalize(uv.x*r+uv.y*u+1.0*f);\n    \n\tfloat startT = 0.1;\n    float maxT = 20.;\n\tfloat dist = RayMarchWater(camPos, ray,startT,maxT);\n    vec3 pos = camPos + ray * dist;\n\t//only need a small circle\n    float circleSize = 2.;\n    if(dist < 0.){\n    \treturn vec4(0.,0.,0.,0.);\n    }\n    vec2 offsetPos = pos.xz;\n    if(length(offsetPos)>circleSize){\n    \treturn vec4(0.,0.,0.,0.);\n    }\n    float colVal = 1.-((pos.z+0.)/circleSize +1.0) *.5;//0~1\n\treturn vec4(col*smoothstep(0.,1.4,colVal),1.);\n}\nfloat SmoothCircle(vec2 uv,vec2 offset,float size){\n    uv -= offset;\n    uv/=size;\n    float temp = clamp(1.-length(uv),0.,1.);\n    return smoothstep(0.,1.,temp);\n}\nfloat DrawBubble(vec2 uv,vec2 offset,float size){\n    uv = (uv - offset)/size;\n    float val = 0.;\n    val = length(uv);\n    val = smoothstep(0.5,2.,val)*step(val,1.);\n    \n    val +=SmoothCircle(uv,vec2(-0.2,0.3),0.6)*0.4;\n    val +=SmoothCircle(uv,vec2(0.4,-0.5),0.2)*0.2;\n\treturn val; \n}\nfloat DrawBubbles(vec2 uv){\n\tuv = Within(uv, vec4(-SIZE,-SIZE,SIZE,SIZE));\n    uv.x-=0.5;\n    float val = 0.;\n    const float count = 2.;// bubble num per second\n    const float maxVY = 0.1;\n    const float ay = -.3;\n    const  float ax = -.5;\n    const  float maxDeg = 80.;\n    const float loopT = maxVY/ay + (1.- 0.5*maxVY*maxVY/ay)/maxVY;\n    const  float num = loopT*count;\n    for(float i=1.;i<num;i++){\n    \tfloat size = 0.02*Rand(i*451.31)+0.02;\n        float t = mod(iTime + Rand(i)*loopT,loopT);\n        float deg = (Rand(i*1354.54)*maxDeg +(90.-maxDeg*0.5))*Deg2Radius;\n        vec2 vel = vec2(cos(deg),sin(deg));\n        float ty = max((vel.y*0.3 - maxVY),0.)/ay;\n        float yt = clamp(t,0.,ty);\n\t\tfloat y = max(0.,abs(vel.y)*yt + 0.5*ay*yt*yt) + max(0.,t-ty)*maxVY;\n        \n        float tx = abs(vel.x/ax);\n        t = min(tx,t);\n        float xOffset = abs(vel.x)*t+0.5*ax*t*t + sin(iTime*(0.5+Rand(i)*2.)+Rand(i)*2.*PI)*0.03;\n        float x = sign(vel.x)*xOffset;\n        vec2 offset = vec2(x,y);\n    \tval += DrawBubble(uv,offset,size*0.5);\n    }\n\treturn val;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float hpPer = sin(iTime*0.2)*0.2+0.5;\n    vec3 waterCol = vec3(0.5)+vec3(0.5)*cos(2.*PI*(vec3(1.)*iTime*0.1+vec3(0.,0.33,0.67)));\n    \n\tvec2 uv = (fragCoord/iResolution.xy - 0.5)*iResolution.xy/iResolution.y*2.;\n    vec3 col = vec3(0.,0.,0.);//final color \n\t//draw 3D frame\n    col += DrawFrame(uv);\n    \n    //draw base water\n    float hpPerMask = step(0.,(hpPer *2. -1.)*SIZE - uv.y);\n  \tfloat bgMask = 0.;\n    bgMask += PureCircle(uv,vec2(0.,0.),SIZE*1.1,.9,0.9);\n \tbgMask += Circle(uv,vec2(0.,0.),SIZE,.6)*0.2;\n    col += bgMask * waterCol *hpPerMask ;\n    \n    //draw wave\n    float waterMask = step(length(uv),SIZE);\n    float offset = hpPer -0.5+0.01;\n    float wavePicSize = 0.8*SIZE;\n    vec2 remapUV = Within(uv,vec4(0.,offset,wavePicSize,offset+wavePicSize-0.2));\n    vec4 wave = SimpleWave3D(remapUV,waterCol);\n    col = mix(col,wave.xyz*bgMask,wave.w*waterMask);\n\t\n    //draw bubbles\n    float bubbleMask = smoothstep(0.,0.1,(hpPer *2. -1.2)*SIZE - uv.y);\n    col+= DrawBubbles(uv)*vec3(1.)* bubbleMask*waterMask;\n    //draw hight light\n    col += DrawHightLight(uv*1.);\n    \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVcD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 249, 270, 270, 315], [317, 317, 342, 342, 424], [425, 425, 458, 458, 500], [501, 501, 556, 556, 593], [595, 595, 651, 651, 746], [748, 748, 821, 821, 991], [992, 992, 1048, 1048, 1143], [1146, 1146, 1172, 1190, 1406], [1407, 1407, 1463, 1463, 1673], [1675, 1675, 1699, 1699, 1952], [1953, 1953, 1982, 1991, 2507], [2510, 2510, 2539, 2539, 2693], [2695, 2695, 2762, 2762, 3170], [3172, 3172, 3208, 3208, 3907], [3908, 3908, 3959, 3959, 4073], [4074, 4074, 4123, 4123, 4364], [4365, 4365, 4392, 4392, 5446], [5449, 5449, 5506, 5506, 6637]]}
{"id": "4dVcDW", "name": "Sickbow's Polar Madness", "author": "sickbow", "description": "woooop", "tags": ["polar"], "likes": 1, "viewed": 82, "published": "Public", "date": "1522269248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1419526535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 qr;\n\n    \n    uv = uv*1.1;\n     \n    //domain restricted to -pi/2 < x < 3pi/2\n    qr = vec2(length(uv),pi/2.-atan(uv.x, uv.y));\n    \n    \n    fragColor =  vec4(0.);\n    \n    \n    \n    for (float i = -pi/2.; i<=2.*pi; i+=1./100.){\n    \t\n        if(qr.x > cos(iTime*i/1.) -.01 && qr.x < cos(iTime*i/1.) && qr.y > i -.09 && qr.y < i){\n            \n            fragColor = vec4(1.+uv.x,1.+uv.y,sin(iTime)/2.+.5,1);\n        }\n        \n    }\n    \n   \tif (qr.y > -pi/2. && qr.x > .5 -.1 && qr.x < 0.5)\n    {\n    \t//fragColor = vec4(0.5);\n    }\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVcDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 118, 749]]}
{"id": "4dVcR1", "name": "Ellipse / quartic", "author": "mattz", "description": "Visualizing the relationship between the ellipse distance problem and roots of a quartic. Drag the white point around to see how the roots behave, or click in bottom left to reset position.", "tags": ["distance", "quartic", "ellipse", "analytic", "exact"], "likes": 13, "viewed": 578, "published": "Public API", "date": "1521263121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \"Ellipse / quartic\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   Visualizing the relationship between the ellipse distance\n   problem and the resulting quartic.\n\n   Colored points on the ellipse are where the white dotted\n   lines are perpendicular to solid white tangents of ellipse.\n   Each colored point corresponds to a root of the quartic\n   (4th degree polynomial) function plotted below the ellipse.\n\n   Note that the shortest white dotted line (i.e. the one \n   corresponding to the exact ellipse distance to the white\n   point) is always perpendicular to the shaded isocontours\n   of the ellipse distance function at the white point.\n\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// closed-form solver from https://www.shadertoy.com/view/XdKyRR \n// but without special-case checks\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from angle around circle\n\nvec2 from_angle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from cosine of angle\n\nvec2 from_cos(float u) {\n    u = clamp(u, -1., 1.);\n    return vec2(u, sqrt(1. - u*u));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct 2D vector perpendicular to input \n\nvec2 perp(vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// return whichever vector has smaller x-coordinate\n\nvec2 smaller_x(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat ellipse_dist(in vec2 p, in vec2 ab, \n                   out vec4 coeffs,\n                   out vec4 roots,\n                   out bool is_circle) {\n    \n    // distance and sign\n    vec2 ds = vec2(1e5, -1);\n    \n    is_circle = abs((ab.x - ab.y) / ab.x) < 1e-2;\n    \n    // circles need special-case handling because the quartic\n    // degenerates into a quadratic.    \n    if (is_circle) {\n        \n        // a and b are pratically equal, so treat this as a circle\n        float dc = length(p) - ab.x;\n        \n        float u = normalize(p).x;\n        \n        \n        \n        roots = vec4(u, 0, 0, -u);\n        coeffs = vec4(0, 1, 0, -u*u);\n        \n        ds = vec2(abs(dc), dc);\n        \n    } else {\n        \n        // general ellipse case\n        \n        \n        // formulate the quartic polynomial that represents\n        // this ellipse. we are solving for the position \n        // u = cos(theta) along the ellipse such that the\n        // tangent at the point [a*u, b*sqrt(1-u^2)] is \n        // perpendicular to the displacement between p\n        // and the point itself.\n        //\n        // there may be multiple valid solutions for this \n        // polynomial -- for a full ellipse we could just \n        // grab the maximal root but we actually need\n        // to inspect each of them in the arc case.\n        \n        float l = ab.y*ab.y - ab.x*ab.x;\n\n        float ax = ab.x*p.x / l;\n        float by = ab.y*p.y / l;\n\n        float a2x2 = ax*ax;\n        float b2y2 = by*by;\n\n        // vector of polynomial coefficients\n        coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);\n\n        // solve for up to 4 roots \n        solve_quartic(coeffs, roots);\n\n        // for each root\n        for (int i=0; i<4; ++i) {\n            \n            // construct point on unit circle\n            vec2 uv = from_cos(roots[i]);\n            \n            // need to check this point both above and below x-axis\n            for (int j=0; j<2; ++j) {\n                \n                // get the absolute distance to the closest point on \n                // the ellipse, as well as its sign\n                vec2 pc = ab*uv;\n                ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));    \n                \n                // mirror the root point across the x-axis\n                uv.y *= -1.;\n                \n            }\n        }        \n        \n    }\n    \n    // combine the absolute distance with the sign of the \n    // distance, respecting original sign classification\n    // before root finding\n    return ds.x*sign(ds.y);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to (optionally dashed) line\n\nfloat dline(vec2 p, vec2 a, vec2 b, float dash) {\n    \n    p -= a;\n    b -= a;\n    \n    float l2 = dot(b,b);\n    float l = sqrt(l2);\n    \n    float u = clamp(dot(p, b) / l2, 0., 1.);\n    \n    float d = length(p - u*b);\n    \n    if (dash != 0.) {\n        float p = dash/6.28;\n        d = max(d, -sin(u*l/p)*p);\n    }\n    \n    return d;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n    return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\nfloat poly4(vec4 p, float x) {\n    return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n    vec2 p0 = vec2(p.x, fdf.x);\n    vec2 n = normalize(vec2(-fdf.y, 1));\n    return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    ////////////////////////////////////////////////////////////\n    // set up ellipse drawing\n    \n\tfloat e_px_per_unit = iResolution.y / 3.;\n    \n    vec2 pctr = iResolution.xy * vec2(0.5, 0.65);\n    \n    // frag coords relative to ellipse\n    vec2 p = (fragCoord.xy - pctr) / e_px_per_unit;\n    \n    // white dot\n    vec2 q = vec2(0.5, 0.2);\n    \n    if (max(iMouse.x, iMouse.y) > 20.) {\n        q = (iMouse.xy - pctr) / e_px_per_unit;\n    }\n    \n    // ellipse radii\n    float time = iTime * 0.25 + 4.4;\n    vec2 ab = vec2(cos(time + 1.2)*.6 + .8, sin(time*0.7 - 0.5)*.2 + .6);\n   \n    // get initial ellipse distance for shading background and drawing ellipse\n    vec4 coeffs, roots;\n    bool is_circle;\n    float d = ellipse_dist(p, ab, coeffs, roots, is_circle);\n    \n    ellipse_dist(q, ab, coeffs, roots, is_circle);\n    \n    ////////////////////////////////////////////////////////////\n    // set up graph \n    \n    float g_px_per_unit = iResolution.x / 2.75;\n    \n    // frag coords relative to graph\n    vec2 v = (fragCoord.xy - vec2(0.5, 0.2)*iResolution.xy)/g_px_per_unit;\n    \n    // get derivative polynomial\n    vec4 pder = vec4(4,3,2,1) * vec4(1, coeffs.xyz);\n\n    // evaluate quartic & derivative\n    vec2 fdf = vec2(poly4(coeffs, v.x), poly3(pder, v.x));\n    \n    if (is_circle) {\n        \n        // in circle case, quartic collapses down to a quadratic\n        pder[0] = 0.;\n        fdf = vec2(poly3(coeffs, v.x), poly3(pder, v.x));\n        \n    }\n    \n    ////////////////////////////////////////////////////////////\n\t// get distances for drawing\n\n    // dist to ellipse & markers\n    float dwhite = abs(d)*e_px_per_unit - .75;\n\n    // dist to draggable dot\n    float dq = length(p-q)*e_px_per_unit - 5.;\n\n    // distances to colored points on ellipse/x-axis\n    vec4 d_ellipse_root = vec4(1e5);\n    vec4 d_axis_root = vec4(1e5);\n    \n    // distance to gray graph line\n    float dplot = dist_to_plot(v, 20.*fdf)*g_px_per_unit;\n    \n    // distance to dark dot outlines by ellipse\n    float ddot = length(p-q)*e_px_per_unit-7.;\n\n    // for each potential root\n    for (int i=0; i<4; ++i) {\n        \n        // create point on unit circle\n        vec2 uv = from_cos(roots[i]);\n        \n        vec3 uvmin = vec3(1e5);\n        \n        // test against both pos & neg. y\n        for (int j=0; j<2; ++j) {\n            \n            // ellipse point\n            vec2 e = ab*uv;\n            \n            // tangent\n            vec2 t = 0.5*(ab*perp(uv));\n            \n            vec3 uvd = vec3(uv, abs(dot(t, q-e)));\n            if (uvd.z < uvmin.z) { uvmin = uvd; }\n            \n            // test other sign next\n            uv.y = -uv.y;\n            \n        }\n            \n        // if we found a good tangent point\n        if (uvmin.z < 1e-3) {\n            \n            // reconstruct unit circle point, ellipse point, tangent            \n            uv = uvmin.xy;\n            vec2 e = ab*uv;\n            vec2 t = 0.5*(ab*perp(uv));\n\n            // distance to point on ellipse\n            float edst = length(p-e)*e_px_per_unit - 5.;\n            d_ellipse_root[i] = min(d_ellipse_root[i], edst);\n                \n            // distance to root on x-axis\n            float pdst = length(v - vec2(roots[i], 0.))*g_px_per_unit - 5.;\n            d_axis_root[i] = min(d_axis_root[i], pdst);\n            dplot = min(dplot, pdst-2.);\n\n            ddot = min(ddot, edst-2.);\n            dwhite = min(dwhite, dline(p, q, e, 10./e_px_per_unit)*e_px_per_unit - .25);\n            dwhite = min(dwhite, dline(p, e-t, e+t, 0.)*e_px_per_unit - .25);\n            \n        }\n        \n    }\n   \n    ////////////////////////////////////////////////////////////\n\t// do actual drawing\n\n        \n    const vec3 axis_color = vec3(0.12, 0.15, 0.25);\n    \n    const vec3 root_colors[4] = vec3[4](\n        vec3(1, 0, 0),\n        vec3(1, 0.7, 0),\n        vec3(0, 0.7, 0),\n        vec3(0, 0, 1)\n    );\n\n    // bg color\n    vec3 col = vec3(0.45, 0.4, 0.48);\n    \t\n    // ellipse isolines\n    col *= 0.95 + 0.05*cos(60.*d);\n\n    // squares\n    vec2 g = abs(v - .25*floor(4.*v + 0.5));\n    col = mix(col, axis_color, 0.5*smoothstep(1., 0., min(g.x, g.y)*g_px_per_unit));\n\n    // x-axis \n    col = mix(col, axis_color, smoothstep(1., 0., abs(v.y)*g_px_per_unit-1.));\n    \n    // plot line\n    col = mix( col, vec3(0.025), smoothstep(1., 0., dplot-1.));\n    \n    // roots on x-axis\n    for (int i=0; i<4; ++i) {\n        col = mix(col, root_colors[i], smoothstep(1., 0., d_axis_root[i]));\n    }\n\n    // slight dark shadow/glow for ellipse figure\n    col = mix( col, vec3(0), 0.6*exp(-.5*dwhite) );\n    \n    // ellipse figure\n    col = mix( col, vec3(1), smoothstep(1., 0., dwhite) );\n\n    // dark dot outlines \n    col = mix( col, vec3(0.025), smoothstep(1., 0., ddot) );\n    \n    // roots on ellipse\n    for (int i=0; i<4; ++i) {\n        col = mix(col, root_colors[i], smoothstep(1., 0., d_ellipse_root[i]));\n    }\n    \n    // draggable dot\n    col = mix( col, vec3(0.025), smoothstep(1., 0., dq-2.) );\n    col = mix(col, vec3(1), smoothstep(1., 0., dq)); \n\n    // gamma correction\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVcR1.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[736, 909, 982, 982, 2761], [2763, 2885, 2911, 2911, 2946], [2948, 3066, 3090, 3090, 3155], [3157, 3276, 3295, 3295, 3325], [3327, 3451, 3483, 3483, 3515], [3517, 3589, 3743, 3773, 6161], [6163, 6275, 6324, 6324, 6616], [6618, 6745, 6775, 6775, 6825], [6827, 6962, 6992, 6992, 7048], [7050, 7253, 7291, 7291, 7408], [7410, 7503, 7560, 7660, 12713]]}
{"id": "4dVyW1", "name": "Strange Reflections", "author": "Klems", "description": "Trying to replicate the shimmer from annihilation.", "tags": ["procedural", "2d"], "likes": 15, "viewed": 723, "published": "Public API", "date": "1521851350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a+PI*vec4(0,1.5,0.5,0)))\n\n// dave hoskins hash function\nvec4 hash( in vec2 p ) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// value noise\nvec4 noise( in vec2 p ) {\n    p*=200.0;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// domain warped noise\nfloat liquid( in vec2 p ) {\n    p += noise(vec2(0, iTime*0.0005)-(p*=rot(0.1)*vec2(2.5, 0.5))).rg*0.01;\n    p += noise(vec2(0, iTime*0.0002)+(p*=rot(0.2)*2.5)).ba*0.01;\n    p += noise(p*=6.5).rg*0.005;\n    return noise(p*0.1).a;\n}\n\n// used for normal calculation\nfloat height( in vec3 p ) {\n    return p.z-liquid(p.xy)*0.001;\n}\n\n// normal from central differences\nvec3 normal( in vec2 uv ) {\n    const vec2 e = vec2(0.0, 0.0001);\n    vec3 p = vec3(uv, 0);\n    return normalize(vec3(height(p-e.yxx)-height(p+e.yxx),\n                          height(p-e.xyx)-height(p+e.xyx),\n                          height(p-e.xxy)-height(p+e.xxy)));\n}\n\n// custom cubemap\nvec3 cubemap( in vec3 dir ) {\n    vec3 color = cos(dir*vec3(1, 9, 2)+vec3(2, 3, 1))*0.5+0.5;\n    color = (color * vec3(0.8, 0.3, 0.7)) + vec3(0.2);\n    color *= dir.y*0.5+0.5;\n    color += exp(6.0*dir.y-2.0)*0.05;\n    color = pow(color, vec3(1.0/2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec3 dir = normalize(vec3(uv, 0.2));\n    \n    vec3 norm = normal(uv*0.02);\n    dir = reflect(dir, norm);\n    \n\tdir.xz *= rot(iTime*0.5);\n    dir.yz *= rot(sin(iTime*0.2)*0.3);\n    \n    fragColor.rgb = cubemap(dir);\n    \n    fragColor.rgb = clamp(fragColor.rgb, vec3(0), vec3(1));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), dot(uv, uv)*1.0);\n    \n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 105, 129, 129, 277], [279, 294, 319, 319, 624], [626, 649, 676, 676, 879], [881, 912, 939, 939, 976], [978, 1013, 1040, 1040, 1285], [1287, 1305, 1334, 1334, 1577], [1579, 1579, 1636, 1636, 2076]]}
{"id": "4dyyDh", "name": "Decor Wall Tiles", "author": "markusm", "description": "Creates a decorated stone tile pattern. The id can be used for bump height and unique color per tile.", "tags": ["wall", "tiles"], "likes": 4, "viewed": 305, "published": "Public", "date": "1521705950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- IQs Voronoi: https://www.shadertoy.com/view/MslGD8\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      \tvec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n// --- Returns the stone tile height and id at the given pos\n\nconst float tileHeight = 0.4;\n\nvec2 stone( vec2 uv )\n{\n    vec2 _uv = uv;\n    \n    uv.y = floor( uv.y * 10. * 1./tileHeight );\n    \n    vec2 c = voronoi( 5. * uv );\n    float height = c.y * 0.7;\n            \n    return vec2( height, c.y );\n}\n\n// --\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n\n    p.y += iTime * 0.2;\n    \n    vec2 res = stone( p );\n\n    vec3 col = vec3( res.y * vec3( 0.5 ) ); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 80, 80, 171], [173, 173, 200, 200, 572], [574, 667, 690, 690, 877], [879, 886, 943, 943, 1139]]}
{"id": "4dyyDW", "name": "rainbow noise", "author": "violetforest", "description": "rainbow hue noise", "tags": ["rainbow", "hue"], "likes": 4, "viewed": 407, "published": "Public", "date": "1521939738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 6\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm (in vec2 uv) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = 0.5 * .5 + cos(iTime + 6. * fbm(uv * atan(3.0))+ vec3(0,23,21));\n\t\n    col += fbm(uv * atan(3.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyyDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 153], [155, 155, 181, 181, 561], [564, 564, 588, 588, 813], [815, 815, 872, 872, 1111]]}
{"id": "4dyyR1", "name": "Elliptical arc distance", "author": "mattz", "description": "Like [url]https://www.shadertoy.com/view/4sS3zz[/url], but with arcs. Use mouse to play with parameters, or click in bottom left corner to reset.", "tags": ["distance", "quartic", "ellipse", "analytic", "exact"], "likes": 19, "viewed": 2063, "published": "Public API", "date": "1520971899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \"Elliptical arc distance\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   This is similar to iq's \"Ellipse - Distance shader\"\n   at https://www.shadertoy.com/view/4sS3zz, except that \n   it can also compute distances to elliptical arcs (i.e. \n   circular arcs with nonuniform scaling along the x- and\n   y- axes). \n\n   I'm borrowing iq's awesome color scheme for visualizing \n   signed distance fields -- it really makes things pop and \n   also makes it easy to see when the SDF is incorrect.\n\n   This shader uses the quartic solver demonstrated in \n   https://www.shadertoy.com/view/XdKyRR to find all candidate\n   closest points on the ellipse to a given point; they are\n   then filtered against the given angular extents.   \n\n   See also \"Bezier - Signed Distance\" by ajs15822 at \n   https://www.shadertoy.com/view/ltXSDB which works similarly,\n   for a quadratic Bezier curve segment.\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// closed-form solver from https://www.shadertoy.com/view/XdKyRR \n// but without special-case checks\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from angle around circle\n\nvec2 from_angle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct unit vector from cosine of angle\n\nvec2 from_cos(float u) {\n    u = clamp(u, -1., 1.);\n    return vec2(u, sqrt(1. - u*u));\n}\n\n//////////////////////////////////////////////////////////////////////\n// construct 2D vector perpendicular to input \n\nvec2 perp(vec2 v) {\n    return vec2(-v.y, v.x);\n}\n\n//////////////////////////////////////////////////////////////////////\n// return whichever vector has smaller x-coordinate\n\nvec2 smaller_x(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// return distance from point p to ellipse centered at origin\n// with radii given by ab and angular limits given by alim.\n//\n// alim.x = start angle\n// alim.y = angular delta (use 0 or >2*PI for full ellipse)\n\nfloat ellipse_arc_dist(vec2 p, vec2 ab, vec2 alim) {\n    \n\t// constants    \n    const float PI = 3.141592653589793;\n    \n    // distance and sign\n    vec2 ds = vec2(1e5, -1);\n    \n    // needed for deciding sign for distance later\n    float orig_sign = -1.;\n    \n    // are we going all the way around ellipse?\n    bool full_ellipse = (alim[1] == 0. || abs(alim[1]) >= 2.*PI);\n\n    // construct unit vectors corresp. to start and end angles\n    vec2 n0 = from_angle(alim.x);\n    vec2 n1 = from_angle(alim.x + alim.y);\n\n    // determine some tangent vectors along ellipse at \n    // endpoints\n    float delta_sign = sign(alim.y);\n    vec2 t0 = -perp(n0)*delta_sign;\n    vec2 t1 = perp(n1)*delta_sign;\n    \n    // angular extents bigger than 1/2 rotation are\n    // treated differently than those less \n    float wedge_sign = 1.;\n    \n    if (abs(alim[1]) > PI) {\n        t0 = -t0;\n        t1 = -t1;\n        wedge_sign = -1.;\n    }\n\n    // determine endpoints of ellipse \n    vec2 p0 = ab * n0;\n    vec2 p1 = ab * n1;\n\n    // determine whether we are inside the wedge\n    // formed by the normal vectors at the endpoints\n    if (!full_ellipse) {\n        orig_sign = sign(max(dot(p - p0, ab.yx*n0), dot(p - p1, ab.yx*n1)));\n        ds = vec2(min(length(p - p0), length(p - p1)), orig_sign);\n    }\n    \n    \n    // circles need special-case handling because the quartic\n    // degenerates into a quadratic.    \n    if (abs((ab.x - ab.y) / ab.x) < 1e-2) {\n        \n        // a and b are pratically equal, so treat this as a circle\n        \n        float dc = length(p) - ab.x;\n        \n        if (full_ellipse || max(dot(p, t0), dot(p, t1))*wedge_sign <= .0) {\n            ds = smaller_x(ds, vec2(abs(dc), dc));\n        }\n        \n    } else {\n        \n        // general ellipse case\n        \n        // the quartic is numerically ill-conditioned\n        // near the y-axis, so keep on the nicely behaved\n        // side of the diagonal\n        if (abs(p.x) < abs(p.y)) {\n            p.xy = p.yx;\n            ab.xy = ab.yx;\n            t0 = t0.yx;\n            t1 = t1.yx;\n        }\n        \n        // formulate the quartic polynomial that represents\n        // this ellipse. we are solving for the position \n        // u = cos(theta) along the ellipse such that the\n        // tangent at the point [a*u, b*sqrt(1-u^2)] is \n        // perpendicular to the displacement between p\n        // and the point itself.\n        //\n        // there may be multiple valid solutions for this \n        // polynomial -- for a full ellipse we could just \n        // grab the maximal root but we actually need\n        // to inspect each of them in the arc case.\n        \n        float l = ab.y*ab.y - ab.x*ab.x;\n\n        float ax = ab.x*p.x / l;\n        float by = ab.y*p.y / l;\n\n        float a2x2 = ax*ax;\n        float b2y2 = by*by;\n\n        // vector of polynomial coefficients\n        vec4 coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);\n\n        // solve for up to 4 roots \n        vec4 roots;\n        solve_quartic(coeffs, roots);\n\n        // for each root\n        for (int i=0; i<4; ++i) {\n            \n            // construct point on unit circle\n            vec2 uv = from_cos(roots[i]);\n            \n            // need to check this point both above and below x-axis\n            for (int j=0; j<2; ++j) {\n                \n                // if we are considering the entire ellipse or\n                // the given uv is inside the angle clip region,\n                if (full_ellipse ||\n                    max(dot(uv, t0), dot(uv, t1))*wedge_sign <= .0) {\n                    \n                    // get the absolute distance to the closest point on \n                    // the ellipse, as well as its sign\n                    vec2 pc = ab*uv;\n                    ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));\n                    \n                }\n                \n                // mirror the root point across the x-axis\n                uv.y *= -1.;\n                \n            }\n        }\n        \n    }\n    \n    // combine the absolute distance with the sign of the \n    // distance, respecting original sign classification\n    // before root finding\n    return ds.x*max(sign(ds.y), orig_sign);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tfloat scl = 2.0 / iResolution.y;\n    \n    vec2 p = (fragCoord.xy - 0.5*iResolution.xy) * scl;\n    \n    vec2 ab = vec2(cos(iTime + 1.2)*.6 + .8, sin(iTime*0.1 - 0.5)*.2 + .6);\n    vec2 alim = vec2(0.5*iTime, 7.*cos(0.3*iTime));\n    \n    if (max(iMouse.x, iMouse.y) > 20.) {\n        \n        ab = abs(iMouse.xy - 0.5*iResolution.xy) * scl;\n        ab = max(ab, vec2(.125));    \n        alim = 16. * iMouse.xy / iResolution.xy - 8.;\n\n    }\n    \n    float d = ellipse_arc_dist(p, ab, alim);\n    \n    // iq's lovely color scheme\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyyR1.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[978, 1151, 1224, 1224, 3003], [3005, 3127, 3153, 3153, 3188], [3190, 3308, 3332, 3332, 3397], [3399, 3518, 3537, 3537, 3567], [3569, 3693, 3725, 3725, 3757], [3759, 4040, 4092, 4115, 8264], [8266, 8359, 8416, 8416, 9165]]}
{"id": "4dyyWm", "name": "randomblob", "author": "laney", "description": "random blob thing", "tags": ["2d"], "likes": 3, "viewed": 98, "published": "Public", "date": "1522185328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdCircle(vec2 p, float r) {\n \treturn length(p) - r;\n}\n\nvec2 cMov(vec2 p, vec2 trans) {\n \treturn p - trans;   \n}\n\nfloat asFilled(float d) {\n    return (1.0 - smoothstep(0.,.01, d));\n}    \n\nfloat sMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\t\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    float objects = 300.;\n    \n    float ds = 1000.0;\n\n    for(float i=0.; i<objects; ++i) {\n        float r1 = rand(vec2(i));\n        float r2 = rand(vec2(i*objects));\n        vec2 loc = cMov(uv, vec2( cos(iTime*r1)*r1*1.5, cos(iTime*r2)*r2)*0.8);\n        float dc = sdCircle(loc,0.1);\n        ds = sMin(ds,dc,.19);\n     }\n     \n    float d = asFilled(ds) * 0.4;\n\n    fragColor = vec4(min(vec3(.0),vec3(.6,0.1,0.1) * 4.0 * ds) + vec3(0.9,0.1,0.1) * d, 1.0) ;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 59], [61, 61, 92, 92, 117], [119, 119, 144, 144, 188], [194, 194, 235, 235, 328], [331, 331, 351, 351, 423], [425, 425, 482, 482, 1006]]}
{"id": "4sccDX", "name": "Neon blue illusion", "author": "ga354", "description": "http://www.psy.ritsumei.ac.jp/~akitaoka/blueraydiscs.jpg", "tags": ["illusion", "perception"], "likes": 0, "viewed": 450, "published": "Public", "date": "1520339375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 0.1\n#define pi 3.1415\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3.0*(mod(fragCoord, iResolution.xy/2.) - .25*iResolution.xy)/iResolution.y;\n \tfloat dUV = 2.*length(vec2(dFdx(uv.x), dFdy(uv.y)));\n    vec2 polar = vec2(length(uv), atan(uv.x, uv.y));\n    float l = mod(polar.x, scale);\n    float ring = smoothstep(0.033,0.033 + dUV,l);\n    ring *= 1.-smoothstep(0.053, 0.053 + dUV, l);\n    ring = 1.-ring;\n    \n    float theta = polar.y+iTime;\n    float blue = smoothstep(pi/16.-0.01, pi/16.+ dUV, mod(theta, pi/4.));\n    blue *= 1.- smoothstep(3.*pi/16.-0.01, 3.*pi/16. + dUV, mod(theta, pi/4.));\n    \n    vec3 b = (1.-ring)*vec3(0.,0.,1.)*blue;\n    \n    fragColor = vec4(ring + b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sccDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 94, 94, 731]]}
{"id": "4sccWX", "name": "Pseudo-Helianthus", "author": "dr2", "description": "Metallic flower with spiral disk (mouseable)", "tags": ["spiral", "flower"], "likes": 2, "viewed": 434, "published": "Public API", "date": "1520325926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Pseudo-Helianthus\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, r, a, aa, s, ss, szFac;\n  dMin = dstFar;\n  szFac = 0.5;\n  dMin /= szFac;\n  q = p / szFac;\n  r = length (q.xz);\n  aa = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  a = aa;\n  d = dMin;\n  s = r - 0.7 * q.y + 0.6;\n  for (float c = 0.; c < 12.; c ++) d = min (d, abs (s - 0.3 * (a + c)) - 0.13);\n  d = SmoothMin (d, abs (s) - 0.13, 0.03);\n  d = max (d, abs (s - 1.5) - 1.5);\n  d = SmoothMin (d, abs (s - 3.) - 0.13, 0.03);\n  ss = 5. - length (q - vec3 (0., -3.2, 0.));\n  d = - SmoothMin (- d, ss, 0.05);\n  q.xz = Rot2D (q.xz, 0.03 * 2. * pi * r);\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (64. * ((r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5)) / 64.));\n  d = - SmoothMin (- d, 0.04  * r - abs (q.z), 0.05);\n  d = SmoothMin (d, - min (- s - 0.05, ss), 0.05);\n  d = max (d, 0.57 - q.y);\n  DMINQ (1);\n  d = length (q - vec3 (0., -3.2, 0.)) - 4.75;\n  d = max (d, 0.56 - q.y);\n  DMINQ (2);\n  dMin *= szFac;\n  szFac = 4.;\n  dMin /= szFac;\n  qq = p / szFac;\n  for (float k = 0.; k < 2.; k ++) {\n    q = qq;\n    if (k > 0.) q.xz = Rot2D (q.xz, pi / 6.);\n    a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a + 0.5) / 6.));\n    q.x += 0.2;\n    q.y -= 0.05 + 0.005 * (1. - 2. * k) + 0.4 * dot (q.xz, q.xz);\n    q.z *= 2.5;\n    d = 0.5 * max (max (length (q.xz + vec2 (0.4, 0.)) - 0.5,\n       abs (q.y) - 0.01 * (1.2 - 1.2 * length (q.xz))), 2.8 - length (r));\n    DMINQ (3);\n  }\n  dMin *= szFac;\n  q = p;\n  d = max (length (q - vec3 (0., 1., 0.)) - 1.7, q.y - 0.22);\n  q.y -= -2.;\n  d = SmoothMin (d, PrCylDf (q.xzy, 0.1, 2.), 0.1);\n  DMINQ (4);\n  q = p;\n  q.y -= 1.5;\n  a = aa;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (12. * a + 0.5) / 12.));\n  s = 0.5 * (q.y / 1.5 + 1.);\n  d = PrCylDf (vec3 (q.x + 0.12 + s * s, q.y, q.z).xzy, 0.03 * (1. - 0.7 * s), 1.5);\n  DMINQ (5);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0005, -0.0005);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BgVal (vec3 rd)\n{\n  return 0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, spec, sh, r;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    spec = 0.1;\n    if (idObj == 1) {\n      col = vec3 (0.1, 0.3, 0.9);\n      r = length (ro.xz);\n      if (r < 0.3) col *= 1. - 0.5 * smoothstep (0.15, 0.2, r) * step (0.007, qHit.z);\n      spec = 0.05;\n      vf = vec2 (128., 0.5);\n    } else if (idObj == 2) {\n      col = vec3 (0.1, 0.2, 0.5);\n    } else if (idObj == 3) {\n      r = length (qHit.xz + vec2 (0.4, 0.)) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.15,\n         mod (32. * atan (qHit.z, - qHit.x) / (2. * pi), 1.)));\n      col = mix (vec3 (1., 1., 0.2), vec3 (0.7, 0.7, 0.4), \n         SmoothBump (0.3, 0.7, 0.1, mod (8. * r + 0.5, 1.)));\n      spec = 0.3;\n      if (vn.y < 0.) col = mix (col, vec3 (Maxv3 (col)), 0.5);\n      vf = vec2 (128., 0.5);\n    } else if (idObj == 4) {\n      col = mix (vec3 (0.4, 0.2, 0.1), vec3 (0.2, 0.7, 0.2), smoothstep (-0.2, 0.2, qHit.y));\n      if (qHit.y > 1.3) col *= 1. - 0.3 * SmoothBump (0.45, 0.55, 0.02,\n         mod (24. * atan (ro.z, - ro.x) / (2. * pi), 1.));\n      vf = vec2 (64., 3. - 2. * smoothstep (-0.2, 0.2, qHit.y));\n    } else if (idObj == 5) {\n      col = mix (vec3 (0.5, 1., 0.5) * (0.5 + 0.5 * SmoothBump (0.2, 0.8, 0.05,\n         mod (16. * qHit.y, 1.))), vec3 (1., 0., 0.), step (1.4, qHit.y));\n      spec = 0.;\n    }\n    if (idObj == 1 || idObj == 3 && vn.y > 0.01) col *= BgVal (reflect (rd, vn));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n  } else {\n    col = vec3 (0.6, 0.6, 0.5) * BgVal (rd);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.02 * pi * tCur;\n    el -= 0.15 * pi * cos (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -20.);\n  ro.y += 0.5;\n  zmFac = 5.4 - 0.9 * abs (el);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 30.;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sccWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 509, 531, 531, 2413], [2415, 2415, 2448, 2448, 2625], [2627, 2627, 2648, 2648, 2848], [2850, 2850, 2887, 2887, 3127], [3129, 3129, 3152, 3152, 3205], [3207, 3207, 3242, 3242, 5070], [5072, 5072, 5128, 5128, 6130], [6132, 6132, 6174, 6174, 6225], [6227, 6227, 6272, 6272, 6375], [6377, 6377, 6434, 6434, 6517], [6519, 6519, 6541, 6541, 6579], [6581, 6581, 6611, 6611, 6669], [6703, 6703, 6727, 6727, 6857], [6859, 6859, 6884, 6884, 7070], [7072, 7072, 7101, 7101, 7313], [7315, 7315, 7354, 7354, 7534]]}
{"id": "4scyDX", "name": "Apollonianscopic KIFS Deep Remix", "author": "Loadus", "description": "Deeper remix of the Apollonianscopic KIFS by gPlatl. ", "tags": ["ifs", "kaleidoscope"], "likes": 7, "viewed": 281, "published": "Public", "date": "1520646284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Apollonianscopic kifs remix\n\n// original creator wyatt, https://www.shadertoy.com/view/Xdcyzl\n// Apollonianscopic version gPlatl https://www.shadertoy.com/view/4scyRs\n\n// Tags: apollonian, kifs, fractal, fractal, inversion, koleidoscope\n\nmat3 m;\nfloat k;\nmat3 rot (vec3 s) {\n\tfloat \tsa = sin(s.x),\tca = cos(s.x),\n\t\t\tsb = sin(s.y),\tcb = cos(s.y),\n\t\t\tsc = sin(s.z),\tcc = cos(s.z);\n\treturn mat3 (\n\t\t\tvec3(cb*cc, -cb*sc, sb),\n\t\t\tvec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n\t\t\tvec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb));\n}\n\nvec3 app (vec3 v) {\n\tfor (int i = 0; i < 10; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 ap (vec3 v) {\n\tfor (int i = 0; i < 10; i++)\n        v = abs(k*m*v/dot(v,v)*0.5-0.5)*2.-1.; \n    return v;\n}\n\nvec3 norm (vec3 p) {\n\t\tvec2 e = vec2 (.05,0.);\n    \tvec3 g = ap(p);\n\t\treturn normalize(vec3(\n\t\t\t\tap(p+e.xyy).x - g.x,\n\t\t\t\tap(p+e.yxy).y - g.y,\n\t\t\t\tap(p+e.yyx).z - g.z));\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\nconst float PI = 3.14159265359;\n\n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(-angle));\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 mp = vec2(0.1, 0.1); //iMouse.xy / iResolution.xy;\n    uv *= 0.2 + 10. * mp.x;\n    float sideCount = -7.0; //1.0 + round(mp.y * 11.0);\n    smallKoleidoscope (uv, PI / sideCount);\n    \n    float t = 0.015 * iTime;\n    m = rot(t + vec3(2, 3, 5));\n    k = 1.3 + 0.1 * sin(0.008 * iTime);\n    vec3 v = (0.5 + 0.25 * sin(0.003 * iTime)) * m * vec3(2.0 * uv, 0);\n    vec3 col = sin(app(v + iTime * 0.0001)) * 0.5 + 0.5;\n    \n    col = col * 0.8 + 0.2 * (sin(norm(v)) * 0.5 + 0.5);\n    col = col * 0.7 + 0.1;\n\n    \n    \tfloat gm = 1.0/2.2;\n    \tcol = vec3(pow(col.r, gm), pow(col.g, gm), pow(col.b, gm));\n    \tcol.r = SCurve(col.g * 0.3 + col.r * 0.7, 6.0, 2.2);\n    \tcol.g = SCurve(col.g * 0.5 + col.b * 0.5, 4.0, 2.2);\n    \tcol.b = SCurve(col.g * 0.3 + col.b * 0.7, 2.0, 2.2);\n    \n        col.g = col.g * 0.9 + 0.1;\n        col.b = col.b * 0.7 + 0.3;\n  \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 259, 278, 278, 527], [529, 529, 548, 548, 642], [644, 644, 662, 662, 756], [758, 758, 778, 778, 929], [931, 931, 991, 991, 1251], [1286, 1353, 1402, 1402, 1530], [1531, 1598, 1655, 1655, 2644]]}
{"id": "4sdcDl", "name": "Peeled Spheres", "author": "dr2", "description": "Cutting helical slices from concentric spheres (mouseable)", "tags": ["spiral", "sphere", "geometry", "helix"], "likes": 3, "viewed": 491, "published": "Public API", "date": "1520598635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Peeled Spheres\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HueToRgb (float c);\n\nfloat vRot[4], wSlc[3], dstFar, tCur, spRad, nSlc, nSeg;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dRot, az, r, s1, s2, c, dr;\n  dMin = dstFar;\n  dRot = 1.;\n  for (int k = 0; k < 3; k ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, - dRot * vRot[k]);\n    az = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    c = cos (asin (q.y / length (q)));\n    r = spRad - 0.2 * float (k);\n    s1 = 0.2 * c;\n    s2 = 0.25 / c;\n    dr = 0.03 * max (SmoothBump (0.5 - s2, 0.5 + s2, 0.5 * s2, mod (q.y * nSlc / r +\n       dRot * az, 1.)), SmoothBump (0.5 - s1, 0.5 + s1, 0.5 * s1, mod (nSeg * az, 1.)));\n    d = abs (length (q) - r - dr) - 0.03 - dr;\n    if (wSlc[k] > 0.) d = max (d, wSlc[k] - abs (2. * mod (nSlc * q.y / r + dRot * az +\n       0.5, 1.) - 1.) / nSlc);\n    DMIN (k + 1);\n    dRot *= -1.;\n  }\n  dMin *= 0.5;\n  d = length (q) - spRad + 0.6;\n  DMIN (4);\n  return dMin;  \n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir, ltPos[4], sCol[4];\n  float dstObj, dRot, aRot, r, az, el, s1, s2, c, dfSum, spSum, at;\n  sCol[0] = HueToRgb (0.4);\n  sCol[1] = HueToRgb (0.6);\n  sCol[2] = HueToRgb (0.2);\n  sCol[3] = HueToRgb (0.);\n  ltPos[0] = 5. * vec3 (1., 1., 1.);\n  ltPos[1] = 5. * vec3 (-1., 1., -1.);\n  ltPos[2] = 5. * vec3 (1., -1., -1.);\n  ltPos[3] = 5. * vec3 (-1., -1., 1.);\n  spRad = 2.;\n  nSlc = 8.;\n  wSlc[0] = 0.9 * (spRad / (2. * nSlc)) * SmoothBump (0.15, 0.85, 0.05, mod (0.05 * tCur, 1.));\n  wSlc[1] = 0.9 * ((spRad - 0.2) / (2. * nSlc)) * SmoothBump (0.27, 0.73, 0.05, mod (0.05 * tCur, 1.));\n  wSlc[2] = 0.9 * ((spRad - 0.4) / (2. * nSlc)) * SmoothBump (0.39, 0.61, 0.05, mod (0.05 * tCur, 1.));\n  vRot[0] = 0.2 * tCur;\n  vRot[1] = 0.3 * tCur;\n  vRot[2] = 0.4 * tCur;\n  vRot[3] = 0.5 * tCur;\n  nSeg = 32.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    r = spRad - 0.2 * float (idObj - 1);\n    dRot = (idObj == 1 || idObj == 3) ? 1. : -1.;\n    for (int k = 0; k < 4; k ++) {\n      if (k == idObj - 1) {\n        col = sCol[k];\n        aRot = vRot[k];\n        break;\n      }\n    }\n    if (idObj < 4 && length (ro) < r + 0.051) col *= 0.7;\n    else {\n      ro.xz = Rot2D (ro.xz, - dRot * aRot);\n      az = (length (ro.xz) > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.;\n      el = asin (ro.y / length (ro)) / (0.5 * pi);\n      c = cos (0.5 * pi * el);\n      s1 = 0.03 * c;\n      s2 = 0.02 / c;\n      col *= 1. - 0.2 * max (SmoothBump (0.5 - s1, 0.5 + s1, 0.5 * s1,\n         mod (ro.y * nSlc / r + dRot * az, 1.)), (1. - smoothstep (0.93, 0.98, abs (el))) *\n         SmoothBump (0.5 - s2, 0.5 + s2, 0.5 * s2, mod (nSeg * az, 1.)));\n    }\n    dfSum = 0.;\n    spSum = 0.;\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.3, 0.7, dot (normalize (ltPos[k] - ro), ltDir));\n      dfSum += at * max (dot (vn, ltDir), 0.);\n      spSum += at * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    }\n    col = col * (0.05 + 0.7 * dfSum) + 0.2 * spSum;\n  } else {\n    col = vec3 (1., 0.86, 0.8) * (0.2 + 0.1 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    el -= 0.2 * pi * sin (0.03 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -15.);\n  rd = vuMat * normalize (vec3 (uv, 6.5));\n  dstFar = 30.;\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HueToRgb (float c)\n{\n  return clamp (abs (fract (c + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdcDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 389, 411, 411, 1217], [1219, 1219, 1252, 1252, 1429], [1431, 1431, 1452, 1452, 1652], [1654, 1654, 1689, 1689, 3864], [3866, 3866, 3922, 3922, 4781], [4783, 4783, 4840, 4840, 4923], [4925, 4925, 4955, 4955, 5013], [5015, 5015, 5040, 5040, 5125]]}
{"id": "4sdyW2", "name": "Just another FBM", "author": "Pr0fed", "description": "Learning and playing with colors.\n2d Worley noise this time.\n\nBTW what is the difference between Worley and Voronoi if any? I've seen people naming it Voronoi mostly.", "tags": ["fbm"], "likes": 3, "viewed": 98, "published": "Public", "date": "1520255854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Worley noise.\nfloat r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return dis;\n}\n\n// Try setting to one :)\n#define NUM_OCTAVES 8\n\nfloat fbm ( in vec2 _st) \n{\n    float v = 0.075;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.25), sin(0.25),\n                    -sin(0.25), cos(0.25));\n    \n    // Stable upward shift.\n    vec2 shift = -vec2(-iTime, iTime);\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * worley2D(_st);\n        _st = rot * _st * 2.5 + shift;\n        a *= 0.4;\n    }\n    \n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Basic normalizarion.\n    vec2 st = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    \n    // Tiling.\n    st *= 15.;\n    \n    vec3 color = vec3(0.0);\n\n    float f = fbm(st + fbm(st + fbm(st - fbm(st))));\n\n    // Orange - darkOrange mix.\n    color = mix(vec3(1.291, 0.549, 0.000),\n                vec3(0.992, 0.636, 0.000),\n                clamp((f*f) * 2.3, 0.0, 1.0));\n\n   \t// Further addition of orange.\n    color = mix(color,\n                vec3(1.836, 0.554, 0.000),\n                clamp(length(f), 0.0, 0.1));\n\n    fragColor = vec4((f*f*f + .93*f*f + .4 * f) * color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 38, 38, 77], [79, 79, 95, 95, 172], [174, 174, 201, 201, 574], [576, 624, 651, 651, 1059], [1061, 1061, 1117, 1145, 1711]]}
{"id": "4sGcWR", "name": "å±é¨å¹³ç§»", "author": "q6823287", "description": "translate", "tags": ["translate"], "likes": 5, "viewed": 143, "published": "Public", "date": "1521542804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 warpPositionToUse(vec2 center, vec2 current, float r, float R, float ratio, vec2 t)\n{\n    vec2 currentToUse = vec2(current.x, current.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 centerToUse  = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 tToUse = vec2(t.x, t.y / ratio);\n    \n    vec2  p \t= current;\n    float L_c  \t= distance(currentToUse, centerToUse);\n    float L_e_c = distance(currentToUse - t, centerToUse);\n    \n    float x \t= currentToUse.x;\n    float y \t= currentToUse.y;\n    float tx \t= t.x;\n    float ty\t= t.y;\n    \n    float ax = x - R * tx / (R - r) - centerToUse.x;\n    float ay = y - R * ty / (R - r) - centerToUse.y;\n    \n    float bx = tx / (R - r);\n    float by = ty / (R - r);\n    \n    float A = bx * bx + by * by - 1.0;\n    float B = 2.0 * (ax * bx + ay * by);\n    float C = ax * ax + ay * ay;\n    float G = sqrt(B * B - 4.0 * A * C);\n    \n    float d = (-B + G) / (2.0 * A);\n    \n    if (d < r)\n    {\n        d = (-B - G) / (2.0 * A);\n    }\n        \n    \n    float delta = 1.0;\n    \n    if (L_e_c < r)\n    {\n        p = current - tToUse;\n    }\n    else if (L_c < R)\n    {\n        p = p - ((R - d) / (R - r)) * tToUse;  \n    }\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    //ratio = 1.0;\n    \n    float r \t= 0.10;\n    float R     = 0.25;\n    vec2 center = vec2(0.5);\n    vec2 t \t\t= vec2(0.1 * sin(iTime), 0.1 * sin(iTime));\n    \n    vec2 currentToUse = vec2(uv.x, uv.y * ratio + 0.5 - 0.5 * ratio);\n    vec2 centerToUse  = vec2(center.x, center.y * ratio + 0.5 - 0.5 * ratio);\n    \n    vec2 p = warpPositionToUse(center, uv, r, R, ratio, t);\n    \n    if (abs(distance(currentToUse, centerToUse) - R) <= 0.001 || abs(distance(currentToUse - t, centerToUse) - r) < 0.001)\n    {\n        // æ·»å è¾¹æ¡\n        fragColor = vec4(1.0);\n    }\n    else\n    {\n    \tfragColor = texture(iChannel0, p);\n    }\n    \n    //fragColor = texture(iChannel0, p);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 90, 90, 1187], [1189, 1189, 1246, 1296, 2062]]}
{"id": "4sGcWz", "name": "Tropical Fish", "author": "rigel", "description": "An abstract tropical fish made with a complex map. Whatever you do, don't STRESS HIM with your mouse. :)", "tags": ["2d", "voronoi", "domain", "complex", "coloring"], "likes": 37, "viewed": 6372, "published": "Public API", "date": "1521711398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tAuthor: Rigel rui@gil.com\n\tlicence: https://creativecommons.org/licenses/by/4.0/\n\tlink: https://www.shadertoy.com/view/4sGcWz\n\t------------------------------------------------------\n\n\tMy goal with this shader was to learn about the voronoi algorithm.\n\tThe algorithm in itself is pretty straighforward, but the distance\n\tto edges is a bit more tricky.\n\n\tSo I started with this reference article by IQ.\n\thttp://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n\tAnd then searching Shadertoy I stumbled on Shane quest for the perfect \n\tround borders voronoi and his interactions with FabriceNeyret2, DR2 and Tomkh.\n\tIt was quite fun to follow the breadcrumbs and I learned a lot :)\n\n\tShane - https://www.shadertoy.com/view/4dsfDl\n\tDR2 - https://www.shadertoy.com/view/Xsyczh\n\tFabriceNeyret2 - https://www.shadertoy.com/view/4dKSDV\n\tTomkh - https://www.shadertoy.com/view/llG3zy\n\t\n\tThe voronoi algorithm is constant time, because it's based on a grid.\n\tBut that makes the feature points evenly distributed, wich can be kind of\n\tlimitied from an artistic perspective...\n\tI wanted to have a variable point density, so I needed a way to distort the grid.\n\t\n\tLuckly complex functions have this tendency of distorting space around zeros\n\tand poles (infinity), so I decided to try that.\n\n\tThere is a way to visualize complex functions called Domain Coloring \n\thttps://en.wikipedia.org/wiki/Domain_coloring\n\n\tThis shader is nothing more than Domain Coloring taken literaly.\n\tI use the domain as a kind coloring book, and then apply the transform.\n\n\tThe complex function is the Lambert Series https://en.wikipedia.org/wiki/Lambert_series\n\tThat I used in my shader about Domain Coloring https://www.shadertoy.com/view/ltjczK\n\tI already thought at that time, that it looked like a fish, so I only needed to make it so. :)\n*/\n\n// uncomment if you want to see the domain without the transform\n//#define DOMAIN \n\n// uncomment to see the grid, and visualize the distortion\n//#define GRID\n\n\n// a few utility functions\n// smoothstep antialias with fwidth\nfloat ssaa(float v) { return smoothstep(-1.,1.,v/fwidth(v)); }\n// stroke an sdf 'd', with a width 'w', and a fill 'f' \nfloat stroke(float d, float w, bool f) {  return abs(ssaa(abs(d)-w*.5) - float(f)); }\n// fills an sdf 'd', and a fill 'f'. false for the fill means inverse \nfloat fill(float d, bool f) { return abs(ssaa(d) - float(f)); }\n// a signed distance function for a rectangle 's' is size\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// a signed distance function for a circle, 'r' is radius\nfloat sdfCircle(vec2 uv, float r) { return length(uv)-r; }\n// hash function for pseudorandom numbers\nvec2 hash2( vec2 p ) { return fract(sin(vec2(dot(p,vec2(1275.1,3131.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\n// a cosine palette with domain d between 0-1\nvec3 pal(float d) { return .5 * ( cos(d*6.283*vec3(2.,2.,1.) + vec3(.0,1.4,.4)) + 1. ); }\n// a simple square grid, you can control the scale and the width\nfloat grid(vec2 uv, float scale, float w) { vec2 guv = fract((uv*scale)-.5)-.5; return max(stroke(guv.x,w,true),stroke(guv.y,w,true)); }\n// conversion from cartesian to polar\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// conversion from polar to cartesian\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// complex division in polar form z = vec2(radius,angle)\nvec2 zdiv(vec2 z1, vec2 z2) { return vec2(z1.x/z2.x,z1.y-z2.y); }\n// complex pow in polar form z = vec2(radius,angle)\nvec2 zpow(vec2 z, float n) { return vec2(exp(log(z.x)*n),z.y*n); }\n// complex sub in polar form z = vec2(radius,angle)\nvec2 zsub(vec2 z1, vec2 z2) { return toPolar(toCarte(z1) - toCarte(z2)); }\n\n\n// This is the Lambert series transform\n// https://en.wikipedia.org/wiki/Lambert_series\nvec2 lambert(vec2 uv, float m) {\n    vec2 z = toPolar(uv);\n    vec2 sum = vec2(.0);\n    vec2 offset = vec2(1.+m * cos(iTime*3.),.2*cos(iTime*(2.+m*2.)));\n    for (float i=1.; i<7.; i++)\n        sum += toCarte(zdiv(zpow(z,i),zsub(offset,zpow(z,i))));\n   return sum;\n}\n\n// IQ's smooth minimum function.\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n\n// Classic voronoi algorithm taken from tomkh\n// https://www.shadertoy.com/view/llG3zy\nvec3 voronoi( in vec2 x, float m) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n            vec2 r = g + seed - f;\n            float d = dot(r,r);\n            if( d<md ) {\n                md = d;\n                mr = r;\n            }\n    }\n    //----------------------------------\n    // second pass: distance to borders,\n    //----------------------------------\n    md = 8.0;\n    for( float j=-1.; j<=1.; j++ )\n        for( float i=-1.; i<=1.; i++ ) {\n            vec2 g = vec2(i,j);\n\t    \tvec2 seed = hash2( n + g );\n            seed = .5 + .3 * cos(iTime*m * 6.283 * seed);\n\t\t    vec2 r = g + seed - f;\n\n            if( dot(mr-r,mr-r)>.0001 ) { // skip the same cell \n                // smooth minimum for rounded borders\n                // apparently I need the max(,.0) to filter out weird values\n                md = max(smin(md,dot( 0.5*(mr+r), normalize(r-mr) ),.25),.0);\n            }\n        }\n    \n\n    return vec3( mr, sqrt(md));\n}\n\n// The scene\nvec3 TropicalFish(vec2 uv) {\n\n    vec2 z = uv;\n    bool dom = false;\n\n    #ifdef DOMAIN\n        z = uv*15.-vec2(4.,.0); dom = true;\n    #else\n        // transform uv with the complex lambert series\n        z = lambert(uv*4., iMouse.z > 0. ? .4 : .0);\n    #endif\n\n    // the voronoi tesselation is \"pulled back\" by the complex map\n    // this means that we pick a color from the domain after the transform\n    vec3 vvz = voronoi(z, iMouse.w > 0. ? .7 : .2);\n\n    // a few helpers for the domain coloring\n    vec2 zv = floor(z + vvz.xy); // voronoi feature point center\n    float phase = atan(uv.y,uv.x); // phase in untransformed space to apply some masks\n\n    // the scales and back fin\n\tvec3 colorphase = pal(atan(z.y,z.x)/6.283);\n    vec3 c = mix(colorphase*.8,pal(.4+vvz.z*.7)*.7,smoothstep(0.,.2,vvz.z)); // mixin the fins with the ocean\n    c = mix(c,pal(vvz.z+.3)*.8*.5*(sin(vvz.z*6.283*8.)+1.), step(.2,vvz.z) ); // scales in the fin\n    // the center of the back fin\n    c = mix(c,colorphase*(sin(6.5*log(1.+length(zv+vec2(4.,.0)))))*.7,fill(sdfCircle(zv.xy+vec2(4.,.0),7.),false));\n\n    // scales mouth\n    vec3 mouth = mix(pal(.47+z.y*.05)*.8,pal(.5+vvz.z*.15)*.9, step(.4,vvz.z) )*smoothstep(18.,7.,length(z));\n    // kind of cheating here. It is not domain coloring, because the scales in the mouth are the same\n    // that the scales in in the back fin, so I apply the mask in the untransformed space to break the symmetry.\n    c = mix(c,mouth,smoothstep(radians(130.),radians(170.),abs(phase)) ); // phase mask\n    \n    // ocean mask\n    float ocmask = step(sdfRect(zv.xy+vec2(6.,.5),vec2(1.,1.)),.0);\n    c = mix(c,pal(.1+z.x*.05)*.6,ocmask); // ocean\n\n    // dorsal fins\n    vec3 dorsalFin = mix(pal(.47+z.y*.15),pal(.5+vvz.z*.5)*.4,.5*cos(z.y*6.283*4.));\n    float fpm = dom ? 1. : smoothstep(radians(30.),radians(17.),abs(abs(phase)-radians(100.))); // fin phase mask\n    c = mix(c,dorsalFin,fill(sdfRect(zv+vec2(4.5,.5),vec2(.5,.5)),true)*fpm);\n\n    // bubbles mask\n    float bubble = max(stroke(sdfCircle(vvz.xy,.05),.01,true),fill(sdfCircle(vvz.xy+vec2(.01),.02),true));\n    c = mix(c,pal(.8+vvz.z*.2),bubble*ocmask);  // bubles\n\n    // body\n    c = mix(c,pal(.47+z.y*.15),fill(sdfRect(zv.xy+vec2(.5,.5),vec2(.5,.5)),true)); \n    \n    // eye mask\n    float eye = max(fill(sdfCircle(z-vec2(-.33,-.14)+.05*vec2(cos(iTime),sin(iTime*2.)),.05),true),stroke(sdfCircle(z-vec2(-.33,-.14),.17),.03,true));\n    // if you remove this mask you will get a multieye monster ! :)\n    float epm = dom ? 1. : float(abs(phase-radians(150.)) < radians(30.)); // eye phase mask\n    c = mix(c,mix(pal(.8+z.x),vec3(.0),eye),fill(sdfCircle(z-vec2(-.33,-.14),.17),true)*epm); // eye\n\n\t// vignette\n\tc *= exp(-.5*dot(uv,uv));\n\n    #ifdef GRID\n        c = mix(c,vec3(1.),grid(z,1.,.05));\n    #endif\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n\tfragColor = vec4( TropicalFish(uv), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGcWz.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[1990, 2053, 2074, 2074, 2115], [2116, 2172, 2212, 2212, 2257], [2258, 2329, 2358, 2358, 2392], [2393, 2451, 2483, 2483, 2538], [2539, 2597, 2632, 2632, 2655], [2656, 2698, 2720, 2720, 2811], [2812, 2858, 2877, 2877, 2947], [2948, 3013, 3056, 3056, 3149], [3150, 3188, 3211, 3211, 3254], [3255, 3293, 3315, 3315, 3353], [3354, 3411, 3440, 3440, 3476], [3477, 3529, 3557, 3557, 3595], [3596, 3648, 3677, 3677, 3722], [3725, 3813, 3845, 3845, 4079], [4081, 4166, 4205, 4205, 4295], [4297, 4384, 4419, 4419, 5678], [5680, 5693, 5721, 5721, 8503], [8506, 8506, 8563, 8563, 8676]]}
{"id": "4sGyRK", "name": "Psyflower", "author": "NohatCoder", "description": "A first experiment with shaders.", "tags": ["2d", "colorful", "abstract", "symmetry"], "likes": 3, "viewed": 381, "published": "Public API", "date": "1522520295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rcol(float i){\n    return vec3(mod(cos(i*i*.631)*772.3,1.0),mod(cos(i*235.631)*472.0,1.0),mod(cos(i*i*.691+i*442.7)*775.2,1.0));\n}\n\nfloat rint(float i){\n    return floor(2.+mod(cos(.2047219*i*i+43.962*i+56.)*336.,6.));\n}\n\nfloat rval(float divides,float angle){\n    float nangle=abs(mod(angle,2.*3.14159/divides)-3.14159/divides)*divides/3.14159;\n    float ptime=iTime;\n    vec2 picka=.07*vec2(sin(ptime*.042+.9),cos(ptime*.03119));\n    vec2 pickb=.08*vec2(sin(ptime*.04962),cos(ptime*.02619));\n    \n    return texture(iChannel0,picka*nangle+pickb*(1.-nangle)).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.xx;\n    float angle = atan(uv.x,uv.y)+iTime*.03;\n    float vtime=iTime-length(uv+.07*vec2(sin(iTime*.3),cos(iTime*.3)))*29.;\n    float colortime=.5;\n    \n    float rtime=floor(vtime/colortime);\n    float ntime=rtime+1.;\n    float lapse=mod(vtime/colortime,1.0);\n    vec3 ncol=cos((rcol(ntime)*lapse+rcol(rtime)*(1.-lapse))*3.14159)*.5+.5;\n\n    float diva=rint(floor(iTime*.05));\n    float divb=rint(1.+floor(iTime*.05));\n    float divc=diva*divb;\n    float divd;\n    float divstep=mod(iTime*.05,1.);\n    if(divstep<.9){\n        divd=diva;\n    }\n    else{\n        divd=divb;\n    }\n    float cweight=clamp(1.-10.*abs(divstep-.9),0.,1.);\n    float rvalue=rval(divc,angle)*cweight+rval(divd,angle)*(1.-cweight);\n    \n    float ring=clamp((.08-abs(.1+rvalue*.3-length(uv)))*19.,.0,1.);\n    vec2 tile=floor(fragCoord*.01+0.01*vec2(1000.*sin(iTime*.5)+iTime*5.,1000.*cos(iTime*.5)));\n    vec3 rtile=rcol(tile.x+59.*tile.y);\n    vec3 tilecol=vec3(.1*sin(rtile.x*iTime));\n    fragColor = vec4(ncol*ring+tilecol*(1.-ring),1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 135], [137, 137, 157, 157, 225], [227, 227, 265, 265, 569], [571, 571, 628, 628, 1704]]}
{"id": "4sKyRD", "name": "Random Delaunay Triangulation", "author": "tomkh", "description": "Random Delaunay triangulation on a regular grid. My response to Shane's wishlist :)\nAlso check out [url=http://polycu.be/edit/?h=M963jR]PolyCu.be edition[/url] with panning/zooming.", "tags": ["procedural", "voronoi", "random", "distance", "delaunay"], "likes": 40, "viewed": 1553, "published": "Public API", "date": "1521233257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2018\n\n// Random Delaunay triangulation on regular grid.\n\n// +LMB to see distance to Voronoi edges\n\n// This is a response to Shane, who wrote:\n// \"I'm writing a wish list, an out-of-the-box way to cheaply produce\n//  a geometric Delaunay triangulation of random 2D points\"\n// in https://www.shadertoy.com/view/Xsyczh\n\n// I wouldn't describe my method \"out of the box\", as it is more or\n// less straigh-forward implementation for heavily restricted\n// point set on a regular grid.\n// Nevertheless, enjoy!\n\n// Also check out PolyCube's edition with panning/zooming:\n// http://polycu.be/edit/?h=M963jR\n\n#define FLIP_ANIMATION 1\n\n// Hash variation by Shane,\n// from https://www.shadertoy.com/view/4dSfzD\nvec2 hashPt(vec2 p, float timeOffset) {\n   float n = sin(dot(p, vec2(41, 289)));\n   // Animated.\n   p = fract(vec2(262144, 32768)*n);\n   return sin( p*6.2831853 + timeOffset )*.5 + .5;\n}\n\n// We generate point in the cell center\n// restricted in movement to box half the cell width/height,\n// so Delaunay triangles behaves regularly.\nvec2 cellPt(vec2 p) {\n    return p + .5 + (hashPt(p, iTime) - .5)*.5;\n}\n\n// Fast distance to edge-Voronoi.\n// Since seed positions are heavily restricted,\n// 3x3 check is enough to search for a closest point\n// as well as search for a pair of neighbours.\nvec2 edgeVoronoi(vec2 p) {\n   vec2 h, pH = floor(p);\n\n   vec2 mh = cellPt(pH) - p;\n   float md = 8.0;\n   for (int j=-1; j<=1; ++j )\n   for (int i=-1; i<=1; ++i ) {\n      h = cellPt(pH + vec2(i,j)) - p;\n      float d = dot(h, h);\n      if (d < md) {\n         md = d;\n         mh = h;\n      }\n   }\n\n   const float eps = .0001;\n   float ed = 8.0;\n\n   for (int j=-1; j<=1; ++j )\n   for (int i=-1; i<=1; ++i ) {\n      h = cellPt(pH + vec2(i,j)) - p;\n      if (dot(h-mh, h-mh) > eps)\n         ed = min( ed, dot( 0.5*(h+mh), normalize(h-mh) ) );\n   }\n   return vec2(sqrt(md),ed);\n}\n\n// Signed distance to a line crossing (p0, p1) segment.\nfloat distLine( vec2 p0, vec2 p1 ) {\n   vec2 e0 = p1 - p0;\n   return dot( p0, normalize(vec2(e0.y,-e0.x)) );\n}\n\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3)\n{\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1,h1));\n   vec3 g2 = vec3(h2, dot(h2,h2));\n   vec3 g3 = vec3(h3, dot(h3,h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   #if FLIP_ANIMATION\n     return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   #else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   #endif\n}\n\n// Find distance to closest Delaunay edge in (h0, h1, h2, h3) quad.\nfloat delaunayQuad(vec2 h0, vec2 h1, vec2 h2, vec2 h3) {\n   // Get distance to quad (note: in general it can be concave, but we don't care).\n   float md = min(\n      min(distLine(h0, h1), distLine(h1, h2)),\n      min(distLine(h2, h3), distLine(h3, h0)));\n   if (md < 0.0)\n      return 8.0; // outside of the quad\n\n   // Calculate flip distance relative to h2, but any other point would do.\n   float dc = flipDistance(h0 - h2, h1 - h2, h3 - h2);\n\n   #if FLIP_ANIMATION\n     float f = clamp(dc*6. + .5, 0., 1.);\n   #else\n     float f = float(dc > 0.0);\n   #endif\n   // Flipping rotates diagonal from (h0 h2) to (h3 h1).\n   // Calculate distance to diagonal (positive from both sides).\n   return min(md, abs(distLine(mix(h0, h3, f), mix(h2, h1, f))));\n}\n\n// Final function visits 4 quads around the center cell.\nfloat delaunayTriangulation(vec2 p) {\n   vec2 pH = floor(p);\n\n   vec2 o = cellPt(pH) - p;\n   // Go clock-wise around center cell.\n   vec2 h0 = cellPt(pH + vec2(-1, 0)) - p;\n   vec2 h1 = cellPt(pH + vec2(-1,-1)) - p;\n   vec2 h2 = cellPt(pH + vec2( 0,-1)) - p;\n   vec2 h3 = cellPt(pH + vec2( 1,-1)) - p;\n   vec2 h4 = cellPt(pH + vec2( 1, 0)) - p;\n   vec2 h5 = cellPt(pH + vec2( 1, 1)) - p;\n   vec2 h6 = cellPt(pH + vec2( 0, 1)) - p;\n   vec2 h7 = cellPt(pH + vec2(-1, 1)) - p;\n\n   float md =   delaunayQuad(h0,h1,h2,o);\n   md = min(md, delaunayQuad(o,h2,h3,h4));\n   md = min(md, delaunayQuad(h6,o,h4,h5));\n   md = min(md, delaunayQuad(h7,h0,o,h6));\n   return md;\n}\n\n// Do shading with pseudo-linear color space and fake anti-aliasing.\nvec3 lin(vec3 col) { return col*col; }\nvec3 gamma(vec3 col) { return sqrt(max(vec3(0),col-.03)); }\nvec3 shade(float tri, float dist, vec2 ev, float ss) {\n   ss *= .6;\n   return\n    mix(\n     mix(\n      mix(\n       mix(\n        mix(\n         lin(vec3(.7,.5,1.))*(dist*2.2 + .1),\n         lin(vec3(.7,.6,1.)),\n         smoothstep(.03+ss,.03-ss,ev.y)*.3\n        ),\n        vec3(0), // edge shadow\n        smoothstep(.05,.01+ss,tri)*.3\n       ),\n       lin(vec3(1.,.7,.3)),\n       max(\n        smoothstep(ss*2.,0.,abs(fract(dist*8.+.5)-.5)/8.)*.7*step(1./16.,dist),\n        smoothstep(.01+ss,.01-ss,tri))\n      ),\n      vec3(0), // seed point shadow\n      smoothstep(.08,min(.075,.05+ss),ev.x)*.7\n     ),\n     lin(vec3(1,.8,.5)),\n     smoothstep(.05+ss,.05-ss,ev.x)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ss = .01;\n    vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss;\n    vec2 ev = edgeVoronoi(p);\n    float tri = delaunayTriangulation(p);\n    float dist = (iMouse.z > 0.) ? ev.y : tri;\n    vec3 col = shade(tri, dist, ev, ss);\n    fragColor = vec4(gamma(col), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKyRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[738, 812, 851, 851, 998], [1000, 1145, 1166, 1166, 1216], [1218, 1400, 1426, 1426, 1974], [1976, 2032, 2068, 2068, 2142], [2144, 2599, 2646, 2685, 3103], [3105, 3173, 3229, 3313, 3923], [3925, 3982, 4019, 4019, 4643], [4645, 4714, 4734, 4734, 4752], [4753, 4753, 4775, 4775, 4812], [4813, 4813, 4867, 4867, 5484], [5486, 5486, 5543, 5543, 5814]]}
{"id": "4sKyRm", "name": "Cubic bezier maxnorm distance", "author": "NinjaKoala", "description": "Computes maxnorm distance to cubic bezier curve, and also norms whose 'circles' are regular polygons with more edges, just comment out first line. Mouse to show curve touching polygon, click lower left to let it disappear", "tags": ["bezier", "cubic", "maxnorm"], "likes": 8, "viewed": 597, "published": "Public API", "date": "1521479777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXNORM\n#define SHOW_POLYGON\n#define NUM_CORNERS int(mod(iTime,6.))*2+4\n\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size=.005;\nconst vec3 point_col=vec3(1,1,0);\nconst float pi = 3.1416;\nconst int max_corners=16;\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat max_norm(vec2 vector){\n\treturn max(abs(vector.x),abs(vector.y));\n}\n\nfloat hexagon_norm(vec2 vector){\n\treturn max(dot(abs(vector),vec2(0.866025403784439,.5)),abs(vector.y));\n}\n\nfloat octagon_norm(vec2 vector){\n\treturn max(dot(abs(vector),vec2(0.707106781186548)),max_norm(vector));\n}\n\nfloat decagon_norm(vec2 vector){\n\tvec2 dir1=vec2(0.587785252292473,0.809016994374947);\n\tvec2 dir2=vec2(0.951056516295154,0.309016994374947);\n\n\treturn max(max(abs(vector.y),dot(abs(vector),dir1)),dot(abs(vector),dir2));\n}\n\n//only even numbers >=4 allowed\nfloat regular_polygon_norm(vec2 vector, int n){\n\tfloat dir_step=(1.-2./float(n))*pi;\n\n\tfloat norm=0.;\n\n\tfor(int i=0;i<max_corners/2;i++){\n\t\tif(i<n/2){\n\t\t\tfloat cur_dir=float(i)*dir_step;\n\t\t\tvec2 dir=abs(vec2(sin(cur_dir),cos(cur_dir)));\n\n\t\t\tnorm=max(norm,dot(abs(vector),dir));\n\t\t}\n\t}\n\n\treturn norm;\n}\n\nfloat cubic_bezier_max_norm_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tvec2 b2 = 3.*a3;\n\tvec2 b1 = 2.*a2;\n\tvec2 b0 = a1;\n\n\tvec3 roots1 = vec3(1e38);\n\tvec3 roots2 = vec3(1e38);\n\n\tint num_roots1 = solve_cubic(vec3(a0.x+a0.y,a1.x+a1.y,a2.x+a2.y)/(a3.x+a3.y),roots1);\n\tint num_roots2 = solve_cubic(vec3(a0.x-a0.y,a1.x-a1.y,a2.x-a2.y)/(a3.x-a3.y),roots2);\n\n\tvec2 roots_drv_x = vec2(1e38);\n\tvec2 roots_drv_y = vec2(1e38);\n\n\tint num_roots_drv_x = solve_quadric(vec2(b0.x,b1.x)/b2.x, roots_drv_x);\n\tint num_roots_drv_y = solve_quadric(vec2(b0.y,b1.y)/b2.y, roots_drv_y);\n\n\tfloat d0 = 1e38;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i<num_roots1){\n\t\t\troots1[i]=clamp(roots1[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots1[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots2){\n\t\t\troots2[i]=clamp(roots2[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots2[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots_drv_x){\n\t\t\troots_drv_x[i]=clamp(roots_drv_x[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots_drv_x[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t\tif(i<num_roots_drv_y){\n\t\t\troots_drv_y[i]=clamp(roots_drv_y[i],0.,1.);\n\t\t\tvec2 point = parametric_cub_bezier(roots_drv_y[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,max_norm(point-uv));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_regular_polygon_norm_dis(vec2 uv, int n, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = -p0 + 3. * p1 - 3. * p2 + p3;\n\tvec2 a2 = 3. * p0 - 6. * p1 + 3. * p2;\n\tvec2 a1 = -3. * p0 + 3. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat dir_step=(1.-2./float(n))*pi;\n\n\tfor(int i=0;i<max_corners/2;i++){\n\t\tif(i<n/2){\n\t\t\tfloat cur_dir=dir_step*float(i);\n\t\t\tfloat next_dir=dir_step*float(i+1);\n\n\t\t\tvec2 dir=(vec2(sin(cur_dir),cos(cur_dir)));\n\t\t\tvec2 dir2=(vec2(sin(next_dir),cos(next_dir)));\n\n\t\t\tvec3 poly=vec3(dot(a0,dir+dir2),dot(a1,dir+dir2),dot(a2,dir+dir2))/dot(a3,dir+dir2);\n\t\t\tvec2 poly_drv=vec2(dot(a1,(dir)),2.*dot(a2,(dir)))/(3.*dot(a3,(dir)));\n\n\t\t\tvec3 roots=vec3(1e38);\n\t\t\tvec2 roots_drv=vec2(1e38);\n\n\t\t\tint num_roots = solve_cubic(poly,roots);\n\t\t\tint num_roots_drv = solve_quadric(poly_drv,roots_drv);\n\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(j<num_roots){\n\t\t\t\t\troots[j]=clamp(roots[j],0.,1.);\n\t\t\t\t\tvec2 point = parametric_cub_bezier(roots[j],p0,p1,p2,p3);\n\t\t\t\t\td0 = min(d0,regular_polygon_norm(point-uv,NUM_CORNERS));\n\t\t\t\t}\n\t\t\t\tif(j<num_roots_drv){\n\t\t\t\t\troots_drv[j]=clamp(roots_drv[j],0.,1.);\n\t\t\t\t\tvec2 point = parametric_cub_bezier(roots_drv[j],p0,p1,p2,p3);\n\t\t\t\t\td0 = min(d0,regular_polygon_norm(point-uv,NUM_CORNERS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.y *= iResolution.y / iResolution.x;\n\n\tborder*=zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat t0=mod(iTime*2.+1.5,24.*pi);\n\n\tvec2 p0 = vec2(-cos(t0 * 1./2.) * .2,sin(t0 * 1./3.) * .25);\n\tvec2 p1 = vec2(-cos(t0 * 2./3.) * .2,sin(t0 * 1./4.) * .1);\n\tvec2 p2 = vec2(cos(t0 * 1./4.) * .1,-sin(t0 * 2./3.) * .2);\n\tvec2 p3 = vec2(cos(t0 * 1./3.) * .25,-sin(t0 * 1./2.) * .1);\n\n\t//vec2 p0=vec2(-.3,-.1);\n\t//vec2 p1=vec2(-.5,.5);\n\t////vec2 p1=mouse;\n\t//vec2 p2=vec2(.1,-.2);\n\t//vec2 p3=vec2(.2,.15);\n    \n    float radius=1e38;\n    \n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        #ifdef SHOW_POLYGON\n        \n        #ifdef MAXNORM\n\t\tradius = cubic_bezier_max_norm_dis(mouse,p0,p1,p2,p3);\n    \t#else\n    \tradius = cubic_bezier_regular_polygon_norm_dis(mouse,NUM_CORNERS,p0,p1,p2,p3);\n    \t#endif\n        \n        #else\n        p0=vec2(-.3,-.1);\n        p1=mouse;\n        p2=vec2(.1,-.2);\n        p3=vec2(.2,.15);\n        #endif\n    }\n\n\tfloat d0 = 1e38;\n\n    #ifdef MAXNORM\n\td0 = min(d0,cubic_bezier_max_norm_dis(uv,p0,p1,p2,p3));\n    #else\n\td0 = min(d0,cubic_bezier_regular_polygon_norm_dis(uv,NUM_CORNERS,p0,p1,p2,p3));\n    #endif\n\n\tfloat sgn = cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 col = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-8.0 * d0);\n\tcol *= 0.8 + 0.2*cos(480.0*d0);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d0)));\n\n\td0 = 1e38;\n\n\td0 = min(d0,distance(p0,uv) - dot_size);\n\td0 = min(d0,distance(p1,uv) - dot_size);\n\td0 = min(d0,distance(p2,uv) - dot_size);\n\td0 = min(d0,distance(p3,uv) - dot_size);\n\n\tcol = mix(point_col,col,smoothstep(0.,border,d0));\n\n\td0 = 1e38;\n\n    #ifdef SHOW_POLYGON\n    #ifdef MAXNORM\n\td0 = min(d0,abs(max_norm(mouse-uv)-radius));\n    #else\n\td0 = min(d0,abs(regular_polygon_norm(mouse-uv,NUM_CORNERS)-radius));\n    #endif\n    #endif\n\n\tcol = mix(vec3(0),col,smoothstep(0.,border,d0));\n\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 316, 316, 497], [499, 499, 534, 534, 705], [707, 828, 877, 915, 1128], [1130, 1215, 1258, 1258, 2273], [2275, 2547, 2616, 2616, 3778], [3780, 3780, 3808, 3808, 3852], [3854, 3854, 3886, 3886, 3960], [3962, 3962, 3994, 3994, 4068], [4070, 4070, 4102, 4102, 4290], [4292, 4324, 4371, 4371, 4625], [4627, 4627, 4704, 4704, 6073], [6075, 6075, 6171, 6171, 7352], [7354, 7354, 7408, 7408, 9560]]}
{"id": "4sKyW1", "name": "Apollonian without shape anim", "author": "chrisjj", "description": "An adjustment of https://www.shadertoy.com/view/4ds3zn\n\nShape is no longer animated by time. It can be varied by mouse drag vertical.\n\nEDIT: Mouse drag horizontal sets fractal depth 2-8;", "tags": ["art"], "likes": 6, "viewed": 421, "published": "Public", "date": "1521841750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013 modified by chrisjj 2018-03-24 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<2+int(iMouse.x/iResolution.x*7.);i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 ;//+ 0.01*iMouse.x;\n    float anim = 1.+ iMouse.y/iResolution.y ; // was float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKyW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[287, 378, 408, 408, 702], [704, 704, 752, 752, 1005], [1007, 1007, 1063, 1063, 1314], [1316, 1316, 1370, 1384, 2369], [2371, 2371, 2428, 2428, 3483], [3485, 3485, 3579, 3579, 3806]]}
{"id": "4sKyz1", "name": "Strips", "author": "peko", "description": "Glitch effect", "tags": ["mirror", "strips"], "likes": 5, "viewed": 561, "published": "Public API", "date": "1521046017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nvec3 point(vec2 p) {\n\treturn length(p)<0.005 ? vec3(1.0) : vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // LINE ax+by+c = 0\n    // y = -(ax+c)/b\n    // through two points\n    // a = y2-y1 \n    // b = x1-x2\n    // c = x2y1-x1y2\n    \n    vec2 p1 = vec2(\n        0.5+sin(iTime*0.5)*0.3,\n        0.5+cos(iTime*0.5)*0.3);\n    vec2 p2 = vec2(\n        0.5+sin(iTime*0.2)*0.2,\n        0.5+cos(iTime*0.2)*0.2);\n    \n    float a = p2.y-p1.y;\n    float b = p1.x-p2.x;\n    float c = p2.x*p1.y-p1.x*p2.y;\n \n    float x = uv.x;\n    float y = -(a*x+c)/b;\n    \n    vec3 col;\n    if (uv.y > y) {\n    \tcol = texture(iChannel0, uv).rgb;\n    } else {\n        // closest point to line\n        // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n        float x0 = uv.x;\n        float y0 = uv.y;\n        vec2 uv2 = vec2(\n            b*( b*x0-a*y0) - a*c,\n            a*(-b*x0+a*y0) - b*c);\n        uv2 /= a*a+b*b;\n        col = texture(iChannel0, uv2 ).rgb;\n    }\n    col+= point(uv-p1)+point(uv-p2);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 95], [98, 98, 155, 205, 1175]]}
{"id": "4sKyzW", "name": "Cubic bezier - Signed Distance", "author": "NinjaKoala", "description": "Exact distance to cubic bezier curve. Use mouse to play with control point, click in bottom left corner to autoplay.", "tags": ["2d", "bezier", "beziercurve", "distance", "polynomial", "cubicbezier"], "likes": 29, "viewed": 2340, "published": "Public API", "date": "1521219666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\nInspired by https://www.shadertoy.com/view/4sXyDr and https://www.shadertoy.com/view/ldXXWH\nSee also my approximate version:\nhttps://www.shadertoy.com/view/lsByRG\n*/\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size=.005;\nconst vec3 point_col=vec3(1,1,0);\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.y *= iResolution.y / iResolution.x;\n\n\tborder*=zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat t0 = mod(iTime*2.+1.5,24.*3.1416);\n\n\tvec2 p0 = vec2(-cos(t0 * 1./2.) * .2,sin(t0 * 1./3.) * .25);\n\tvec2 p1 = vec2(-cos(t0 * 2./3.) * .2,sin(t0 * 1./4.) * .1);\n\tvec2 p2 = vec2(cos(t0 * 1./4.) * .1,-sin(t0 * 2./3.) * .2);\n\tvec2 p3 = vec2(cos(t0 * 1./3.) * .25,-sin(t0 * 1./2.) * .1);\n\n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        p0=vec2(-.3,-.1);\n        p1=mouse;\n        p2=vec2(.1,-.2);\n        p3=vec2(.2,.15);\n    }\n\n\tfloat d0 = 1e38;\n\n\td0 = min(d0,cubic_bezier_dis(uv,p0,p1,p2,p3));\n\n\tfloat sgn = cubic_bezier_sign(uv,p0,p1,p2,p3);\n\n\t//iq's sd color scheme\n\tvec3 col = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-8.0 * d0);\n\tcol *= 0.8 + 0.2*cos(480.0*d0);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d0)));\n\n\td0 = 1e38;\n\n\td0 = min(d0,distance(p0,uv) - dot_size);\n\td0 = min(d0,distance(p1,uv) - dot_size);\n\td0 = min(d0,distance(p2,uv) - dot_size);\n\td0 = min(d0,distance(p3,uv) - dot_size);\n\n\tcol = mix(point_col,col,smoothstep(0.,border,d0));\n\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[474, 577, 655, 655, 1248], [1250, 1309, 1387, 1387, 1983], [1985, 1985, 2057, 2057, 2238], [2240, 2240, 2275, 2275, 2446], [2448, 2448, 2483, 2483, 2800], [2802, 2802, 2878, 2878, 2956], [2958, 3184, 3267, 3267, 3524], [3526, 3526, 3572, 3572, 3848], [3850, 3971, 4020, 4058, 4271], [4273, 4358, 4401, 4401, 5416], [5418, 5539, 5584, 5584, 7570], [7572, 7844, 7913, 7913, 9075], [9077, 9077, 9145, 9265, 14042], [14044, 14044, 14098, 14098, 15454]]}
{"id": "4stcWX", "name": "Torus_Thingy_15", "author": "balkhan", "description": " ", "tags": ["raynarching"], "likes": 1, "viewed": 123, "published": "Public", "date": "1520395605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.1 // defining a high epsilon value let you blurr jittering stuff\n#define FAR\t\t\t410.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n#define FILLED\t\t0 // can be [0-2]\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 210.0);\n\n    pos.z += 100.5*sin(t*2.);\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col.xyz = vec3(.5,.6,.20)*(1.-inter.y/max(inter.x, .001)*.45);\n    c_out =  vec4(.75-.25/max(abs(-h*4.+1.25-.0625*col), .001),1.0);\n    c_out = c_out * c_out * c_out * (3.-2.*c_out);\n    c_out *= (1.5-length(uv)*1.);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    rotate(p.xz, 1.57-.125*iTime );\n    rotate(p.yz, 1.57-.5*iTime );\n    vec3 op = p;\n    var  = atan(op.x,op.y);\n    p.xy = modA(p.xy, 80.);\n    p.x -= 50.;\n    p.zy = modA(p.zy, 80.);\n    p.z -= 20.;\n    vec2 q = vec2( ( mylength(p.xy) )-1.,1.*p.z+10.*cos(iTime*-1.5*1.+.525*length(p.xy)) );\n    q.xy = abs(q.xy)-12.;\n    rotate(q, (var*.25+iTime*.5) );\n    q.xy = abs(q.xy)-12.;\n    #if FILLED >= 1\n    q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;\n    #if FILLED == 2\n    q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;q = abs(q)-.5;\n    #endif\n    #endif\n    ret_col = vec3(.20, .2, .0);\n    mind = mylength(q)-.5;\n    h -= vec3(.00751,.00851,.01)*vec3(1.)*1./max(1.+mind*mind, .001);\n    h += vec3(.05,.105,.205)*vec3(1.)*.25/max(5.10001+mind*mind, .001);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stcWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 680, 723, 723, 1200], [1202, 1273, 1306, 1306, 1437], [1439, 1462, 1483, 1483, 2452], [2454, 2454, 2486, 2486, 2897], [2899, 2913, 2937, 2937, 3034], [3036, 3036, 3076, 3076, 3151], [3153, 3153, 3181, 3181, 3289], [3291, 3291, 3313, 3313, 3519], [3521, 3521, 3571, 3571, 3834]]}
{"id": "4styzj", "name": "FlowingRiver", "author": "kuvkar", "description": "A dried out river bank with some evening scenery. Mouse to look around. Kind of continuation on my previous flow experiment https://www.shadertoy.com/view/4dtyWM", "tags": ["water", "grass", "flow", "river", "trees"], "likes": 32, "viewed": 2016, "published": "Public API", "date": "1520594105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nconst float waterY = .0;\n// light\nconst vec3 ld = normalize(vec3(0.0, 2.1, 14.0));\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat water(vec2 uv) {\n    uv += noise(uv * .8);        \n    vec2 wv = 1.0-abs(sin(uv));\n    return (wv.x + wv.y) * .5;\n}\nfloat getCurve(in vec3 rp)\n{\n    float x = sin(rp.z * .1) * 2.4 + sin(rp.z * .22) * 1.;\n    x -= sin(rp.z * .02 - .0) * 21.5;\n    return x;\n}\n\nfloat shoreLine(vec3 rp)\n{\n    return abs(getCurve(rp) + rp.x);\n}\n\n\nfloat river(vec2 uv)\n{\n    float s = 0.;\n    const float levels = 4.;\n    mat2 r;\n    r[0] = vec2(0.4, 0.4);\n    r[1] = vec2(-0.24, 0.27);\n    for (float i = 1.; i < (levels + 1.); i = i + 1.)\n    {\n        uv *= r;\n        s += water(uv * i * 2.);\n    }\n    s /= (levels + 1.);\n    return s;\n}\n\n\nfloat mapEdge(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float edgeL = -1.;\n    float difx = 1.-abs(rp.x);\n    return difx;\n}\n\nfloat mapBottom(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float bottom = -.6;\n    float ax = abs(rp.x);\n    bottom += smoothstep(1., 10., ax);\n    bottom += (0.5 + 0.5 * noise(rp.xz * .3)) * .5;\n    float hill = smoothstep(65., 80., ax);\n    bottom += hill * 15.;\n    bottom += hill * sin(rp.z * .1) * 2.;\n    bottom += hill * sin(rp.z * .15) * 1.;\n    return bottom; \n}\n\nfloat mapHeightHQ(in vec3 rp)\n{\n    float bottom = mapBottom(rp);\n    float limit = smoothstep(45., 80., abs(rp.x)) * 3.;\n    bottom -= (0.4 * smoothstep(0.2, 0.5, noise(rp.xz * .13))) * limit;\n    bottom += (0.3 * smoothstep(0.1, 0.5, noise(rp.xz * .33))) * limit;\n    return rp.y - bottom;\n}\n\nfloat mapHeightLQ(in vec3 rp)\n{\n    return rp.y - mapBottom(rp);\n}\n\n\nvec3 grad(in vec3 rp, float bump)\n{\n    float hc = mapHeightHQ(rp);\n    vec2 off = vec2(1.1, 0.0);\n    float hh = mapHeightHQ(rp + off.xyy);\n    float hv = mapHeightHQ(rp + off.yyx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\n\nvec3 seagrad(in vec2 uv, float bump, float t)\n{\n    uv *= 14.;\n    float hc = river(uv);\n    vec2 off = vec2(3./t, 0.0);\n    float hh = river(uv + off);\n    float hv = river(uv + off.yx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nvec3 texgrad(in sampler2D tex, in vec2 uv, float bump)\n{\n    float hc = dot(texture(tex, uv).rgb, vec3(.33));\n    vec2 off = vec2(0.002, 0.0);\n    float hh = dot(texture(tex, uv + off).rgb, vec3(.33));\n    float hv = dot(texture(tex, uv + off.yx).rgb, vec3(.33));\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nbool trace(inout vec3 rp, in vec3 rd)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec3 prevp = rp;\n    \n    // rough height map tracing\n    for (int i = 0; i < 350; ++i)\n    {\n        float dify = mapHeightLQ(rp);\n        if(dify < 0.)\n        {\n            hit = true;\n            break;\n        }\n        prevp = rp;\n        rp += rd * max(0.15, dify);\n        if(dot(ro - rp, ro - rp) > 150000.) break;\n    }\n\n    // detailed height map tracing\n    if(hit)\n    {\n        hit = false;\n        for (int i = 0; i < 25; ++i)\n        {\n            float dify = mapHeightHQ(rp);\n            if(dify < 0.)\n            {\n                hit = true;\n                break;\n            }\n            prevp = rp;\n            rp += rd * max(0.1, dify * (1.0 + log2(1.0 + length(ro - rp) * 1.5)));\n\t        if(dot(ro - rp, ro - rp) > 150000.) break;\n        }\n    }\n   \n    // binary search the surface\n    if(hit)\n    {\n        vec3 insidep = rp;\n        vec3 outsidep = prevp;\n        float cursor = 0.5;\n        \n        for (int i = 1; i < 20; ++i)\n        {\n        \trp = mix(outsidep, insidep, cursor);\n            float dist = mapHeightHQ(rp);\n            cursor += pow(0.5, float(i + 1)) * sign(dist);\n        }\n        \n    }\n    \n    return hit;\n    \n}\n \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\nvec4 colorSurface(in vec3 rp, in vec3 rd)\n{\n    vec4 color = vec4(0.);\n    \n    vec2 uv = rp.xz * .05;\n    color  = pow(texture(iChannel1, uv), vec4(2.2));\n    vec3 g = texgrad(iChannel1, uv, .2);\n    color.rgb *= 0.4 + 1.7 * max(0.0, dot(g, ld));\n    \n    float toEdge = smoothstep(-9., -2., mapEdge(rp * 1.1) + noise(rp.zx * 2.5));\n    color *= mix(1.0, toEdge, 0.7);\n    vec3 worldg = grad(rp, 1.2);\n    \n    float limit = smoothstep(25.0, 50.0, abs(mapEdge(rp)));\n    color += vec4(.01, .02, .0, 1.) * worldg.y * limit;\n    color += vec4(.01, .02, .0, 1.) * abs(worldg.x) * limit;\n    color.a = 1.;\n    return color;\n}\n\nvec2 flowGrad(in vec3 rp)\n{\n    vec3 off = vec3(.02, 0.0, 0.0);\n\t\n    float dc = mapEdge(rp);\n    float dh = mapEdge(rp + off);\n    float dv = mapEdge(rp + off.yyx);\n    \n    return -vec2(dh - dc, dv - dc);\n    \n}\n\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 2.0;\n    if(mixval > 1.0) mixval = 2.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .5, 1.0);\n    return mixval;\n}\n\nvec4 getTrees(in vec3 rd)\n{\n    float an = atan(rd.z, rd.x);\n    \n    vec4 trees = vec4(.0);\n    const float layers = 5.0;\n    float alpha = 0.0;\n    \n    for (float i = 1.; i <= layers; i = i + 1.0)\n    {\n        float offset = an * 2. + i * .5;\n        float colA =   texture(iChannel0, vec2(offset, offset)).r;\n        \n        float yp = (0.5 + 0.5 * sin(i + an * .5)) * .005;\n        yp += (0.5 + 0.5 * sin(i * 2. + an * 5.)) * .025;\n        yp -= .1 * cos(an * .1);\n        yp += rd.y;\n        \n        float layerH = max(0., .2- (i * .05));\n\t    colA *= smoothstep(layerH, layerH - .1, yp);\n        colA = smoothstep(.33, .37, colA);\n        float a = an * .05 + i * .01;\n        mat2 rm; rm[0] = vec2(cos(a), -sin(a)); rm[1] = vec2(sin(a), cos(a));\n        vec4 texCol = texture(iChannel2, (vec2(offset, yp * .4) * rm) * 4.) * colA;\n        texCol = smoothstep(-.6, 1.0, texCol);\n        texCol.rgb *= pow((1. / layers) * i, 1.0);\n        texCol.rgb *= vec3(0.25 , 0.3, 0.15) * .5;\n        \n        trees.rgb = texCol.rgb * colA + (1.0 - colA) * trees.rgb;\n        trees.a = clamp(trees.a + colA, 0.0, 1.0);\n    }\n    return trees;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(.5)) * vec2(1.0, iResolution.y / iResolution.x);\n    vec2 im = 1.5 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    \n    vec3 rp = vec3(-.0, 17.5, -10.);\n    if(iMouse.z < 0. || iMouse.xy == vec2(0.))\n    {\n        im.xy = vec2(.11, .551);\n        rp.z += sin(iTime * .2);\n        rp.y += sin(iTime * .5);\n        rp.x += cos(iTime * .5);\n    }\n    \n\t// camera    \n    vec3 rd = normalize(vec3(uv, .4));\n    vec3 _rp = rp;\n    rp = roty(im.x * 5.) * rp;\n    rp.y = (rotx(im.y * 1.5) * _rp).y;\n    \n    \n    vec3 ro = rp;\n    rd = lookat(rp, vec3(.0, 4.0, 5.0)) * rd;\n    \n    \n    \n    // ground \n    bool hit = trace(rp, rd);\n    _rp = rp;\n    \n    if(hit) \n    {\n        fragColor = colorSurface(rp, rd);\n    }\n    \n    // water\n    if(rp.y < waterY && mapEdge(rp) > -30.)\n    {\n        vec3 n = vec3(0.0, 1.0, 0.0);\n        float t = (waterY - dot(ro, n))/dot(n, rd);\n        if(t > 0.)\n        {\n            vec3 p = ro+rd*t;\n            \n            float T = 4.;\n            \n            // texture offsets for advection\n            float cycle = mod(iTime, T)/T;\n            float o1, o2 = 0.;\n            float mv = getMixValue(cycle, o1, o2);\n            float dist = smoothstep(6., 1., shoreLine(p));\n            \n            // flow vec \n            vec2 sideFlow = (flowGrad(p))  * 3.;\n            float h = mapHeightLQ(p);\n            \n            vec2 flowFwd = flowGrad(vec3(shoreLine(vec3(0.0, 0.0, rp.z)), 0., rp.z)).yx * 3.;\n            float mixval = dist;//smoothstep(-5., 0., dist);\n            vec2 flow = mix(sideFlow, flowFwd, mixval);\n            \n            // normal\n            float speed = 50.;\n            vec2 scale = vec2(.35, .4);\n            float bmp = 0.1;\n            vec3 g1 = seagrad(scale * p.xz + flow * o1 * speed, bmp, t);\n            vec3 g2 = seagrad(scale * p.xz + flow * o2 * speed, bmp, t);\n            \n            vec3 g3 = seagrad(scale * p.xz + vec2(.1, .2) + flow * o1 * speed * .4, bmp, t);\n            vec3 g4 = seagrad(scale * p.xz + vec2(.3, .2) + flow * o2 * speed * .4, bmp, t);\n            \n\t\t\tvec3 gm = mix(g2, g1, mv);\n            gm += mix(g4, g3, mv);\n            gm = normalize(gm);\n            \n            // diffuse\n            vec4 blue = vec4(0., 69., 129., 0.) / 255.;\n            float wd = dot(gm, ld);\n            wd = max(0.0, wd);\n            float wrp = 0.5;\n            wd = (wd+wrp)/(1.+wrp);\n            vec4 difcol = blue;\n            \n            // spec\n            vec3 H = normalize(-rd + ld);\n            float specd = dot(H, gm);\n            specd = max(0.0, specd);\n            float sd = pow(max(0.0, specd), 58.0) * 1.;\n            \n            // fres\n            float fres = 1.-max(0., dot(-rd,gm));\n            vec4 lightblue = vec4(151./255., 203./255., 220./255., 0.);\n            vec4 orange = vec4(.7, .3, 0.1, 0.0);\n            fres = pow(fres, 2.)* 1.;\n            \n            // combined\n            vec4 frescol = fres*orange;\n            vec4 surfcol = frescol * .4 + difcol * wd * 0.2;\n            \n            vec3 refr = normalize(refract(rd, gm, .7));\n            \n            bool hit = trace(p, refr);\n            vec4 bottomColor = colorSurface(p,refr);\n            float mx = 1.-smoothstep(-.1, 2., -refr.y);\n            fragColor = mix(bottomColor, surfcol, mx);\n            fragColor +=vec4(sd);\n            \n            float foam = smoothstep(0.1, -0.5, h + noise(rp.xz * .15) * .2);//smoothstep(0.5, -1.4, mixval);\n            fragColor += foam * texture(iChannel2, .5 * p.xz + sideFlow * o1 * speed).rrrr;\n            fragColor += foam * texture(iChannel2, .5 * p.xz + sideFlow * o2 * speed).rrrr;\n            \n            fragColor.a = 1.;\n        }\n    }\n    else if(hit)\n    {\n        // grass\n        float toEdge = smoothstep(10.0, 7.0, shoreLine(_rp) + noise(_rp.xz) * 1.5);\n        toEdge += smoothstep(17.0, 87.0, shoreLine(_rp));\n        float H = .1;\n        vec3 rstp = rd/-rd.y;\n        rp -= rstp * H;\n        float STP = .002;\n        \n        bool hitGrass =false;\n        float i = 0.;\n        for (i = 0.0; i < H; i = i + STP)\n        {\n            vec4 tcl = texture(iChannel3, rp.xz * .6);\n            float D = .4 - i;\n            D += toEdge;\n            D += abs(noise(rp.xz * .015)) * .5;\n            if(D < tcl.g)\n            {\n                \n                hitGrass = true;\n                break;\n            }\n            rp += rstp * STP;\n        }\n        \n        if(hitGrass)\n        {\n            vec4 grassLow = vec4(0.08, 0.05, 0.0, 1.0);\n            vec4 grassHi = vec4(0.1, 0.1, 0.0, 1.0);\n            float depth = clamp(pow(1.0 - (i/H), 4.), 0.0, 1.0);\n            vec4 grassCol= mix(grassLow, grassHi, depth);\n            grassCol += texture(iChannel1, rp.xz * .05)*.25 * mix(1.0, depth, .4);\n            grassCol *= texture(iChannel1, rp.xz * .01).g;\n            fragColor =  grassCol;\n        }\n        \n        fragColor.a = 1.;\n        \n        vec3 g = grad(_rp, 1.2);\n        float d = max(0.0, dot(g, normalize(vec3(0.0, 1.0, 1.0)))) * 2. ;\n        float wrap = .4;\n        d = (d + wrap)/(1.0 + wrap);\n        fragColor.rgb *= d;\n        \n    }\n\n    \n    vec3 skyLow = vec3(.6, 0.7, 0.8);\n    vec3 skyHi = vec3(.6, 0.3, 0.5);\n    vec3 skyRed = vec3(6., .3, 0.);\n    vec3 sky = mix(skyLow, skyHi, rd.y);\n    vec3 skyYellow = vec3(1.0, 1.0, .5);\n    \n    float a = sin((atan(rd.z, rd.x) + 3.14159265) * .5);\n    vec2 sun = vec2(a, rd.y * 1.5);\n\tsky = mix(skyRed, sky, smoothstep(0.0, 1.5, length(sun)));\n\tsky = mix(skyYellow, sky, smoothstep(0.0, .7, length(sun)));\n    \n    \n    if(length(_rp)>400.)fragColor=vec4(.0);\n    \n    fragColor.rgb *= .2 + .8 * smoothstep(-22.0, 0.0, _rp.x + sin(_rp.z * 0.5));\n    fragColor.rgb *= 1.0 + .7 * smoothstep(4.0, 50.0, _rp.x + sin(_rp.z * .2));\n    \n    fragColor = mix(getTrees(rd), fragColor, fragColor.a);\n    fragColor.rgb = mix(fragColor.rgb, sky, 1.-fragColor.a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4styzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [471, 530, 552, 552, 632], [634, 634, 660, 660, 961], [963, 963, 985, 985, 1084], [1085, 1085, 1113, 1113, 1226], [1228, 1228, 1254, 1254, 1293], [1296, 1296, 1318, 1318, 1590], [1593, 1593, 1620, 1620, 1719], [1721, 1721, 1750, 1750, 2093], [2095, 2095, 2126, 2126, 2388], [2390, 2390, 2421, 2421, 2456], [2459, 2459, 2494, 2494, 2783], [2786, 2786, 2833, 2833, 3115], [3117, 3117, 3173, 3173, 3522], [3524, 3524, 3563, 3563, 4783], [4786, 4786, 4819, 4819, 5019], [5021, 5021, 5064, 5064, 5643], [5645, 5645, 5672, 5672, 5858], [5860, 5860, 5934, 5972, 6202], [6204, 6204, 6231, 6231, 7345], [7347, 7347, 7404, 7404, 13425]]}
{"id": "4sVyWR", "name": "Unknown Pleasures", "author": "smiarx", "description": "Tribute to Joy Division", "tags": ["noise", "lines", "cover"], "likes": 33, "viewed": 543, "published": "Public", "date": "1521594240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\n#define LINEWIDTH 3.2\n#define H 35.\n\n#define WAVEHEIGHT 6.6\n#define WIDTH 0.6\n\nfloat random (in float x) {\n    return fract(sin(x)*\n        43758.5453123);\n}\n\n\nfloat noise (in float x) {\n    float i = floor(x);\n    float f = fract(x);\n\n    float a = random(i);\n    float b = random(i + 1.);\n\n    float u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u);\n}\n\n#define OCTAVES 3\nfloat fbm (in float x) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(x);\n        x *= 2.;\n        amplitude *= .7;\n    }\n    return value;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    st.y *= 45.;\n    \n    float linewidth = 45.*LINEWIDTH / iResolution.y;\n    \n    float val = 0.;\n    if(abs(st.x) < WIDTH){\n        float env = pow(cos(st.x/WIDTH*3.14159/2.),4.9);\n        float i = floor(st.y);\n        for (float n = max(-H,i-6.); n <= min(H, i); n++) {\n            float f = st.y - n;\n            float y = f - 0.5;\n            y -= WAVEHEIGHT \n                * pow(fbm(st.x*10.504 +n*432.1 + 0.5*iTime), 3.)\n                * env\n                + (fbm(st.x*25.+n*1292.21)-0.32)*2. * 0.15;\n            float grid = abs(y);\n                val += (1.-smoothstep(0., linewidth,grid));\n            \t//val = grid;\n            if(y < 0.)\n                break;\n        }\n    }\n\n        \n\n    \n\n    fragColor = vec4(val);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 110, 110, 161], [164, 164, 190, 190, 362], [382, 382, 406, 406, 633], [636, 636, 691, 691, 1504]]}
{"id": "4sVyz1", "name": "Counter Motion Illusion", "author": "ga354", "description": "The colour gradient makes image seem like it's moving one way, while the actual image is rotating the other way. Quite uncomfortable to look at :'(\nInspired by Akiyoshi Kitaoka", "tags": ["illusion", "perception"], "likes": 2, "viewed": 420, "published": "Public API", "date": "1521047042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415\n#define from vec3(253./255.,27./255.,32./255.)\n#define to vec3(198./255.,48./255.,249./255.)\n\nfloat gradient(float t){\n\treturn .5 + .5*sin(t);\n}\n\nfloat luminance(float t){\n\treturn-.1*cos(t);\n}\n\nvec3 colour(float t){\n    return from + gradient(t)*(to-from) + luminance(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3.0*(mod(fragCoord, iResolution.xy/2.) - .25*iResolution.xy)/iResolution.y;\n    vec2 polar = vec2(length(uv), atan(uv.x, uv.y));\n    fragColor.xyz = smoothstep(0.0, 0.1, polar.x)*colour(10.*polar.y + iTime/2. + 10.*polar.x );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 136, 136, 162], [164, 164, 189, 189, 210], [212, 212, 233, 233, 291], [293, 293, 350, 350, 592]]}
{"id": "4sycD1", "name": "Movement in Cellural", "author": "ircss", "description": "Practising from book of shaders by patriciogv\n", "tags": ["cellural"], "likes": 0, "viewed": 370, "published": "Public API", "date": "1522347408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Practice based on book of shaders\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid DrawCircle(inout vec3 lFragColor, in vec2 pos, in vec2 uv, in vec3 color){\n \t lFragColor=mix(color, lFragColor, smoothstep(0.1, 0.102, distance(pos, uv)));   \n}\nfloat randFloat( in float seed){\n \treturn fract(sin(seed)*50000.);   \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n    vec2 uv = st;\n\n    \n    st *= 8.;\n    \n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n\n    float time = iTime * 0.4;\n    float time_i = floor(time);\n    float time_f = fract(time);\n    \n    vec2 pos = vec2(randFloat(time_i)*iResolution.x/iResolution.y, randFloat(time_i+ 44.));\n    vec2 posNext = vec2(randFloat(time_i+1.)*iResolution.x/iResolution.y, randFloat(time_i+45.));\n    pos = mix(pos, posNext, time_f);\n    \n    //float distanceToMoving = distance(closestPoint/8., pos);\n    float distanceToMoving = distance(st/8., pos);\n    float m_dist = 1.0;  // minimun distance\n    \n    vec2 closestPoint = vec2(0.0,0.0);\n    vec3 closestPointFactor = vec3(0.);\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i + neighbor);\n\t\t\tvec2 randSeed=point;\n\t\t\t// Animate the point\n            //point = 0.5 + 0.5*sin(iTime*(0.4 +point.y *0.9) + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f;\n\t\t\tfloat factor = .38;\n            \n             // Distance to the point\n            float dist = length(diff);\n            for (int d= -1; d <= 1; d++) {\n        \t\tfor (int j= -1; j <= 1; j++) {\n            \tvec2 neighborSecondIteration = vec2(float(d),float(j));\n\t\t\t\t\n                vec2 seed = random2(i + neighbor);\n                \n            \tfloat weight = seed.x;\n                factor +=  dist *weight* float ((d==0)&&(j==0)) * (sin(iTime*4.1*(1.-seed.x )+seed.y*4.21321)*0.5+0.5 ) ;\n            \n        \t\t}\n    \t\t}\n\t\t\t\n            if(distanceToMoving*8.<2.){ \n                factor += (1.0-pow(smoothstep(0.,2.,distanceToMoving*8.), 2.))* 0.5;\n            }\n\t\t\t\n            // Keep the closer distance\n            if(dist*factor<= m_dist){\n                m_dist =dist *factor;\n                closestPoint = point + i + neighbor;\n                closestPointFactor.x =factor; \n                closestPointFactor.yz = randSeed.xy;\n            }\n            \n        }\n    }\n\n\t\n \n    m_dist = min(distanceToMoving*8.*0.5, m_dist);\n    // Draw the min distance (distance field)\n    color += 1.0 -m_dist;\n    \n    \n\n    color *= vec3(0.3,0.9,0.2);\n    color.g *= 1.0- m_dist;\n    color.g *= 1.0- m_dist;\n    color.b *=  pow(m_dist,-0.328);\n   \n    // Debug Circle\n    //DrawCircle(color,pos,uv,vec3(1.));\n\t//color = vec3(closestPointFactor.x);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sycD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 62, 62, 155], [157, 157, 236, 236, 322], [323, 323, 355, 355, 394], [398, 398, 455, 455, 3139]]}
{"id": "4sycRW", "name": "Solar Flare", "author": "Xor", "description": "I was playing around with my [url=https://www.shadertoy.com/view/4d2fzw]eclipse shader[/url] and came up with this. What do you think?", "tags": ["sun", "light", "space", "flare"], "likes": 10, "viewed": 1056, "published": "Public", "date": "1521322221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O,vec2 I)\n{\n    O = vec4(0);\n    //Centered coordinates.\n    vec2 P = (I-.5*iResolution.xy)*2.2/iResolution.y;\n    //Iterate for radius.\n    for(float i = 1.;i<1.7;i+=.01)\n    {\n        //Calculate twisting sphere rays.\n        vec3 R = vec3(P,sqrt(i-dot(P,P)));\n        R.xy *= mat2(cos(i*.1),sin(i*.1),sin(i*.1),-cos(i*.1));\n        //Add light rays.\n    \tO += .025*pow(texture(iChannel0,R.xy/sqrt(R.z)-.1*iTime),vec4(i*4.-3.));\n    }\n    //Create edge glow and attenuation in space.\n\tO *= vec4(.65,.4,.25,1)/(abs(dot(P,P)-1.)+.2),pow(1.-sqrt(max(1.-dot(P,P),0.)),2.);\n    //Calculate disk distance for solar flares.\n    float D = 1.5-length(P+P.y*.4+.1*cos(P.x*6.+.2*iTime));\n    \n    //Added center glow.\n    O += vec4(2,1,.5,0)*(exp(-dot(P,P)) +\n\t//Calculate the solar flares.\n    .1*smoothstep(.8,1.,cos(iTime/8.+P.x+P.y*.4))*(cos(P.y*8.+iTime)*.3+.7)*exp(cos(P.x+P.y*.4+iTime)\n    -10.*abs((cos(D*38.+P.x*17.+2.*iTime)*.1+.9)*D)));\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sycRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 964]]}
{"id": "4syyRy", "name": "Emissive plasma.", "author": "Pr0fed", "description": "More tweaking of  https://www.shadertoy.com/view/XdKyWm \nAny ideas on reducing the jitter and adding some kind of blur are aprecciated.\nI understand that it is probably because of noise , and might really be hard to clean somehow.", "tags": ["procedural", "noise", "fbm"], "likes": 2, "viewed": 138, "published": "Public", "date": "1522355746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Just another generative piece of 'art' (lol), for FBM and noise training purpose.\n\n\n// \"replace this by something better\" (IQ said).\n// and i'm really not yet sure what is 'better'.\n// Better means faster? Or better distribution? \nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    \n    // Earlier version, too noisy now. You have to lower\n    // values on 72 and 79 and 88 to get ~ initial result.\n    // It was not such big as if you uncomment this now, but\n    // really a lot more than smooth version. \n    \n    // So smoothstepping a noise is cool if you can improve \n    // a picture after it, without adding more. Nice!\n    \n    //return -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y)));\n    \n    // A bit smoother version, with less jitter.\n    return smoothstep(0.0, 1.15, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// Simple 2D gradient noise taken from you know where: https://www.shadertoy.com/view/XdXGW8\n// Thx IQ :)\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.20,  1.00, -1.00,  1.20 );\n\n// Four octave FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise2D( p ); p = p * 2. * m;\n    f += 0.2500 * noise2D( p ); p = p * 2. * m;\n    f += 0.1250 * noise2D( p ); p = p * 2. * m;\n    f += 0.0625 * noise2D( p );\n    return f;\n}\n\n// Six octave FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Waves motion.\n    float ql = length( q.y );\n    q += 0.05 * (0.5 + 0.5 * sin(iTime + ql * 1.05));\n\n    // First point.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second point.\n    vec2 n;\n    n = vec2(fbm6(q + fbm4( vec2(4.0 * o + vec2(2.)))));\n\n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 8.0 * n;\n    float f = 0.5 + 0.5 * fbm6( p );\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    // Really just a magic which i've seen in IQ's https://www.shadertoy.com/view/lsl3RH.\n    float g = 0.5 + 0.5 * sin(5.0 * p.x) * sin(5.0 * p.y);\n    f *= 1.0 - 0.55 * pow( g, 16.0 ) * f;\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix( vec3(0.78, 0.0, 0.56), vec3(0.0, 0.0, 0.11), f );\n    col = mix( col, vec3(0.2, 0.85, 0.85), dot(on.xy, on.zw));\n    col = mix( col, vec3(0.1, 0.79, 0.88), 1.2 * smoothstep(0.8, 1.6, abs(on.z) + abs(on.z)));\n    \n    return col * 6. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p*= 4.;\n\n    fragColor = vec4( GetColor( p ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syyRy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[174, 321, 344, 344, 1001], [1003, 1109, 1137, 1137, 1543], [1648, 1668, 1690, 1690, 1901], [1903, 1922, 1944, 1944, 2347], [2349, 2349, 2386, 2407, 3286], [3288, 3319, 3342, 3342, 3697], [3699, 3699, 3756, 3796, 3944]]}
{"id": "4syyWw", "name": "Sylvester's Fan", "author": "dr2", "description": "Sylvester's Lady's Fan - a mechanical angle trisector\nA digital simulation of an analog device for solving a mathematically hard(!) problem\n", "tags": ["mechanism", "trisect"], "likes": 10, "viewed": 520, "published": "Public API", "date": "1522143934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sylvester's Fan\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing (0/1 - off/on)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nbool isShad;\nconst float pi = 3.14159;\n\nfloat rad, len1, len2, ang1, ang2, angT, angS;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, cRot, wFac;\n  dMin = dstFar;\n  p.xz -= -2.;\n  cRot = 0.25 * pi - 1.5 * angT;\n  wFac = isShad ? 10. : 1.;\n  for (float n = 0.; n < 4.; n ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, n * angT + cRot);\n    q.y -= n * 2. * 0.02;\n    q.z -= 0.5 * rad + 0.5;\n    d = PrFlatCylDf (q.zxy, 0.5 * rad + 0.5, 0.2, 0.02);\n    DMINQ (1);\n    q.y = p.y - 0.1;\n    q.z -= 0.5 * rad - 0.5;\n    d = PrCapsDf (q.xzy, 0.05, 0.3);\n    DMINQ (4);\n  }\n  for (float n = 0.; n < 3.; n ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, n * angT + 2. * ang2 + cRot);\n    q.y -= 0.17 + 2. * n * 0.01;\n    q.z -= 0.5 * rad;\n    d = max (PrFlatCylDf (q.zxy, 0.5 * rad, 0.15, 0.01 * wFac),\n       0.03 - length (vec2 (q.x, q.z - 0.5 * rad)));\n    DMINQ (2);\n    q.y -= 0.03;\n    q.z -= 0.5 * rad;\n    d = max (PrCylDf (q.xzy, 0.05, 0.1), 0.03 - length (q.xz));\n    DMINQ (4);\n  }\n  for (float n = 0.; n < 4.; n ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, n * angT + cRot);\n    q.y -= 0.24 + n * 2. * 0.012;\n    q.z -= rad;\n    q.xz = Rot2D (q.xz, - angS);\n    q.z -= 0.5 * (len2 - len1);\n    d = max (PrFlatCylDf (q.zxy, 0.5 * (len1 + len2), 0.1, 0.005 * wFac),\n       0.03 - length (vec2 (q.x, abs (q.z) - 0.5 * (len1 + len2))));\n    DMINQ (3);\n  }\n  for (float n = 0.; n < 3.; n ++) {\n    q = p;\n    q.xz = Rot2D (q.xz, n * angT + 2. * ang2 + cRot);\n    q.y -= 0.252 + n * 2. * 0.012;\n    q.z -= rad;\n    q.xz = Rot2D (q.xz, angS);\n    q.z -= 0.5 * (len2 - len1);\n    d = max (max (PrFlatCylDf (q.zxy, 0.5 * (len1 + len2), 0.1, 0.005 * wFac),\n       0.05 - length (vec2 (q.x, q.z - 0.5 * (len1 - len2)))),\n       0.03 - length (vec2 (q.x, abs (q.z) - 0.5 * (len1 + len2))));\n    DMINQ (3);\n    q.z = abs (q.z) - 0.5 * (len1 + len2);\n    d = max (PrCylDf (q.xzy, 0.05, 0.05), 0.02 - length (q.xz));\n    DMINQ (4);\n  }\n  q = p;\n  d = PrCapsDf (q.xzy, 0.08, 0.3);\n  DMINQ (4);\n  q = p;\n  q.xz -= 2.5;\n  q.y -= -0.3;\n  d = PrBoxDf (q, vec3 (4., 0.03, 4.));\n  DMINQ (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.05, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Trig (float x, float a)\n{\n  return atan (sin (x) / ((rad / len2) + cos (x))) +\n     atan (sin (x) / ((rad / len1) - cos (x))) - 0.5 * a;\n}\n\nfloat SecSol (float a)\n{\n  float xk, xk1, xk2, fk, fk1, fk2;\n  bool isOk;\n  xk2 = 0.5 * a;\n  xk1 = xk2 + 0.05;\n  fk2 = Trig (xk2, a);\n  fk1 = Trig (xk1, a);\n  isOk = false;\n  for (int nIt = 0; nIt < 6; nIt ++) {\n    xk = xk1 - (xk1 - xk2) * fk1 / (fk1 - fk2);\n    fk = Trig (xk, a);\n    xk2 = xk1;\n    xk1 = xk;\n    fk2 = fk1;\n    fk1 = fk;\n    if (abs (xk1 - xk2) < 1e-5) {\n      isOk = true;\n      break;\n    }\n  }\n  return isOk ? xk : 0.5 * a;\n}\n\nvoid SetupMech ()\n{\n  vec2 ts;\n  float t, tp;\n  t = mod (0.1 * tCur, 2.);\n  if (t < 1.) {\n    tp = t + 0.1;\n    ts = vec2 (t, ((tp > 1.) ? t : tp));\n  } else {\n    tp = 2. - (t + 0.1);\n    t = 2. - t;\n    ts = vec2 (((tp < 0.) ? t : tp), t);\n  }\n  ts = 0.1 * floor (10. * ts);\n  angT = (pi/3.) * (0.18 + 0.44 * mix (ts.x, ts.y, smoothstep (0.3, 0.7,\n     (t - 0.1 * floor (10. * t)) / 0.1)));\n  rad = 4.;\n  len1 = 1.;\n  len2 = 2.;\n  angS = SecSol (angT);\n  ang1 = sin (angS) / ((rad / len2) + cos (angS));\n  ang2 = 0.5 * angT - ang1;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, spec, sh, r;\n  isShad = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == 1) {\n      col = mix (vec3 (0.6, 0.3, 0.1), vec3 (0.5, 0.2, 0.),\n         smoothstep (0.4, 0.6, Fbm2 (qHit.xz * vec2 (16., 4.))));\n    } else if (idObj == 2) {\n      col = vec3 (0.9, 0.8, 0.8);\n      if (vn.y > 0.5) {\n        col *= 1. - 0.1 * Noisefv2 (128. * qHit.xz);\n        spec = 0.3;\n      } else {\n        col *= 0.5;\n        spec = 0.;\n      }\n    } else if (idObj == 3) {\n      col = vec3 (1., 1., 0.);\n      if (vn.y > 0.5) {\n        col *= 1. - 0.1 * Noisefv2 (128. * qHit.xz);\n        spec = 0.3;\n      } else {\n        col *= 0.5;\n        spec = 0.;\n      }\n    } else if (idObj == 4) {\n      col = vec3 (0.6, 0.4, 0.1);\n    } else if (idObj == 5) {\n      col = vec3 (0.8, 0.85, 0.8);\n      qHit.xz += 2.5;\n      r = length (qHit.xz);\n      if (vn.y > 0.99 && r > 1.49) {\n        qHit.xz = Rot2D (qHit.xz, 2. * pi * (floor (72. *\n           atan (qHit.z, - qHit.x) / (2. * pi) + 0.5) / 72.));\n        col = mix (vec3 (0.5, 0.5, 1.), col, SmoothBump (0.03, 0.97, 0.01, mod (2. * r, 1.)) *\n           smoothstep (0.01, 0.02, (abs (qHit.z))));\n      }\n      spec = 0.;\n    }\n    isShad = true;\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n       spec * sh * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvd, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  SetupMech ();\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ltDir = vuMat * normalize (vec3 (1., 3., -1.));\n  dstFar = 40.;\n  ro = vuMat * vec3 (0., 0., -20.);\n#if ! AA\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  col = ShowScene (ro, rd);\n#else\n  col = vec3 (0.);\n  for (int iy = 0; iy <= 1; iy ++) {\n    for (int ix = 0; ix <= 1; ix ++) {\n      uvd = (0.5 / canvas.y) * (2. * vec2 (float (ix), float (iy)) - 1.);\n      rd = vuMat * normalize (vec3 (uv + uvd, 5.));\n      col += ShowScene (ro, rd);\n    }\n  }\n  col *= 0.25;\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syyWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 698, 720, 720, 2686], [2688, 2688, 2721, 2721, 2898], [2900, 2900, 2921, 2921, 3121], [3123, 3123, 3160, 3160, 3400], [3402, 3402, 3433, 3433, 3546], [3548, 3548, 3572, 3572, 3996], [3998, 3998, 4017, 4017, 4533], [4535, 4535, 4570, 4570, 6155], [6157, 6157, 6213, 6213, 7416], [7418, 7418, 7450, 7450, 7550], [7552, 7552, 7594, 7594, 7645], [7647, 7647, 7690, 7690, 7763], [7765, 7765, 7824, 7824, 7964], [7966, 7966, 8023, 8023, 8106], [8108, 8108, 8138, 8138, 8196], [8230, 8230, 8254, 8254, 8384], [8386, 8386, 8411, 8411, 8597], [8599, 8599, 8620, 8620, 8775]]}
{"id": "4syyzw", "name": "Interactive Collatz with good", "author": "rodolphito", "description": "Lots of credit to IQ for being really good. Hope I got all the math right!\n\nTry using the mouse! IQ's collatz: https://www.shadertoy.com/view/llcGDS", "tags": ["fractal", "domain", "hsv", "complex", "collatz"], "likes": 4, "viewed": 176, "published": "Public", "date": "1521357041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 pi = vec4(0,2,4,8)*atan(1.0);\n\nvec2 cdiv (vec2 a,vec2 b){return vec2(dot(a,b),a.y*b.x-a.x*b.y)/dot(b,b);}\nvec2 cmul (vec2 a,vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 cmulj(vec2 z){return vec2(-z.y,z.x);}\nvec2 cexp (vec2 z){return exp( z.x)*sin(z.y+pi.yx);}\nvec2 cexpj(vec2 z){return exp(-z.y)*sin(z.x+pi.yx);}\nvec2 cpow (float a,vec2 z){return pow(a, z.x)*sin(z.y+pi.yx);}\nvec2 cpowj(float a,vec2 z){return pow(a,-z.y)*sin(z.x+pi.yx);}\nvec2 csqr (vec2 z){return vec2(z.x*z.x-z.y*z.y,2.0*z.y*z.x);}\nvec2 cinv (vec2 z){return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cPow (vec2 z,float n){return pow(length(z),n)*sin(atan(z.y,z.x)*n+pi.yx);}\nvec2 cexpc(vec2 a, vec2 b)\n{\n    return cmul(cpow(dot(a,a),0.5*b),cexpj(atan(a.y,a.x)*b));\n    //(a+bi)^(c+di)=(aa+bb)^((c+id)/2)*e^(i(c+id)arg(a+ib))\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n\treturn c.z*mix(vec3(1.0),0.5+0.5*sin(c.x+pi.xzw/3.0),c.y);\n}\n\nvec3 getcol(float a)\n{\n\tvec3 c = sin(pi.w*vec3(a, a + 0.333, a + 0.666)) * 0.5 + 0.5;\n    c += 0.01;\n    return c * 0.05;\n}\n\nvec4 collatz(vec4 z, vec2 shift)\n{\n    vec2 k = cexpj(pi.z*z.xy);\n    vec2 zd = z.xy*1.25+vec2(0.5,0.0);\n    return vec4(\n          z.xy*1.75+vec2(0.5,0.0) - cmul(k,zd) + shift,\n         cmul(z.zw,vec2(1.75,0.0) - cmul(k,zd*pi.z-vec2(0.0,1.25)))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 7.0*(fragCoord-iResolution.xy*0.5)/iResolution.x;\n    vec4 z = vec4(p,1.0,0.0);\n    vec2 shift = 1.0 - 2.0 * iMouse.xy / iResolution.xy;\n    if (iMouse.xy == iMouse.zw) shift += sin(iTime + vec2(0.0,pi*0.5));\n    for (int i = 0; i < 18; i++)\n    {\n        z = collatz(z, shift);\n    }\n    float hue = atan(z.z,z.w);\n    float val = 1.0/(1.0+0.0000000000001*dot(z.xy,z.xy));\n    float sat = 1.0-1.0/(1.0+0.000000001*dot(z.zw,z.zw));\n\tfragColor = vec4(hsv2rgb(vec3(hue+iTime,sat,val)),1.0);\n    //fragColor = vec4(pow(getcol(hue),vec3(val)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 62, 62, 110], [111, 111, 137, 137, 183], [184, 184, 203, 203, 226], [227, 227, 246, 246, 279], [280, 280, 299, 299, 332], [333, 333, 360, 360, 395], [396, 396, 423, 423, 458], [459, 459, 478, 478, 520], [521, 521, 540, 540, 572], [573, 573, 600, 600, 652], [653, 653, 681, 681, 805], [807, 807, 832, 832, 894], [896, 896, 918, 918, 1019], [1021, 1021, 1055, 1055, 1275], [1277, 1277, 1334, 1334, 1894]]}
{"id": "ld3cDB", "name": "Recursive Primitives", "author": "felipunkerito", "description": "Menger", "tags": ["3d", "raymarching", "sdf", "menger", "sponge"], "likes": 1, "viewed": 463, "published": "Public API", "date": "1520012876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.0001\n#define FAR 1000.0\n#define STEPS 1028\n#define PI acos( -1.0 )\n#define TWOPI PI * 2.0\n\n// Some little hacks but basiclly based on http://iquilezles.org/www/articles/menger/menger.htm\n\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  float t = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n  float sph = length( p ) - 1.0;\n  p.y -= 0.8;\n  float tim = sin( ( iTime * 0.2 ) + sin( iTime * 0.2 ) * 0.5 );\n  float f = mix( t, sph, max( 0.2, min( 0.5, tim ) ) );\n  return f;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3((iTime * 0.2 ),1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,(iTime * 0.2 ),1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,(iTime * 0.2 )));\n  return min(da,min(db,dc));\n}\n\nvec3 map( in vec3 p )\n{\n   vec2 d = vec2( sdBox(p,vec3(1.0)), 0.0 );\n   vec2 pla = vec2( p.y + 1.0, 1.0 );\n\n   float s = 1.0;\n   for( int m=0; m<5; m++ )\n   {\n       vec3 a = mod( p*s, 2.0 ) - 1.0;\n       s *= 3.0;\n       \n       vec3 r = max( 1.0, sin( iTime ) ) - 3.0*abs(a);\n\n       vec2 c = vec2( sdCross(r)/s, 0.0 );\n       d = max( d, c );\n       \n   }\n    \n   if( d.x < pla.x ) pla = d;\n\n   return vec3( pla, 0.0 );\n}\n\n/*vec3 map( in vec3 p )\n{\n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n       }\n   }\n\n   return res;\n}*/\n\n\nvec3 grad( vec3 p )\n{\n\n    vec2 e = vec2( 0.0, EPS );\n    vec3 n = vec3( map( p + e.xyy ).x - map( p -  e.xyy ).x,\n                   map( p + e.yxy ).x - map( p -  e.yxy ).x,\n                   map( p + e.yyx ).x - map( p -  e.yyx ).x\n                 );\n    return n;\n\n        \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        if( h < EPS ) return 0.0;\n        res = min( res, 8.0 * h / t );\n        t += h;\n        \n        \n    }\n    \n    return res;\n\n}\n\n// https://www.shadertoy.com/view/4lSSRW\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.2;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        //dir = normalize(nor + dir);\n        dir *= sign(dot(dir,nor));\n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d*2.0);\n    }\n    return clamp( 4.0 - 2.5*ao, 0.0, 1.0 )*(0.5+0.5*nor.y);\n}\n\nvec3 shade( vec3 ro , vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = normalize( grad( p ) );\n    vec3 lig = normalize( vec3( 1.0, 4.0, 0.6 ) );\n    vec3 col;\n    vec3 ref = reflect( ro, n );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\n    float rim = pow( 1.0 + dot(n, rd), 2.0 );\n    float occ = calcOcc( p, n ); occ *= occ * occ;\n    \n    col += vec3( 1.0, 0.98, 0.8 ) * amb;\n    col += dif * vec3( 1.0, 0.98, 0.8 ) * sha;\n    col += 1.0 * spe;\n    col += 0.1 * rim;\n    col += 1.0 * occ;\n   \n    map( p ).y == 0.0 ? col *= mix( vec3( 0.0, 1.0, 0.0 ), vec3( 0.0, 0.0, 1.0 ), fbm( p + fbm( p + fbm ( p ) ) ) ) : vec3( 0.0 );\n    map( p ).y == 1.0 ? col *= vec3( 1.0 ) : vec3( 0.0 );\n    \n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = 2.5 * vec3( sin( sin( iTime * 0.2 ) ), 0.0, cos( iTime * 0.2 ) );\n    \n    if( mou.x == 0.0 ) ro = 2.5 * vec3( sin( sin( iTime * 0.2 ) ), 0.0, cos( iTime * 0.2 ) );\n    \n    if( mou.x != 0.0 ) ro = mou.y * vec3( sin( mou.x * TWOPI ), 0.0, cos( -mou.x * TWOPI ) );\n  \n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    //vec3 ro = vec3( 2.0, 0.0, 2.0 );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    \n    \n    float t = 0.0, d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    // Time varying pixel color\n    vec3 col = d < EPS ? shade( ro, rd, t ) : mix( vec3( 0.5 ), vec3( 0.0 ), uv.y  );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3cDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 203, 226, 226, 276], [278, 278, 304, 304, 920], [922, 922, 946, 946, 1179], [1182, 1182, 1213, 1213, 1483], [1485, 1485, 1513, 1513, 1712], [1714, 1714, 1737, 1737, 2138], [2140, 2653, 2674, 2674, 2934], [2936, 2936, 2981, 2981, 3230], [3232, 3274, 3317, 3317, 3682], [3684, 3684, 3726, 3726, 4551], [4553, 4553, 4610, 4660, 5726]]}
{"id": "ldccWj", "name": "Mobius Transformations", "author": "mla", "description": "Construct a MÃ¶bius transformation from a reflection and inversion. Shows construction and fixed points of transformation. The grid is the image of the square with -2 < x,y < 2.\n\nMouse changes transformation parameters, see code for key controls.", "tags": ["mobius", "transformation", "domaincoloring"], "likes": 24, "viewed": 3620, "published": "Public API", "date": "1520183089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018 by Matthew Arcus\n//\n// MÃ¶bius transformations\n//\n// Construct a MÃ¶bius transformation from reflection in a line and\n// inversion in a circle.\n//\n// Domain coloring from https://www.shadertoy.com/view/MtjBzV by phi16\n//\n// Controls:\n//\n// Mouse x: select circle centre on x-axis\n// Mouse y: select angle of inclination of the mirror line\n// c: show construction line, circle and fixed points\n// i: toggle inversion\n// m: toggle reflection in mirror line\n// r: toggle time rotation\n// a: toggle alternative coloring\n// b: map fixed points to 0 and infinity\n//\n// Algebraically, a MÃ¶bius transformation is of the form z -> (az+b)/(cz+d)\n// but can also be constructed more geometrically as the composition of a\n// number of spherical inversions, including inversion in a sphere of\n// \"infinite\" radius, ie. reflection in a straight line - this\n// definition also generalizes well to higher dimensions.\n//\n// Here we construct a MÃ¶bius transformation from a reflection in a line\n// through the origin, and an inversion in a unit circle with its\n// centre on the x-axis. This seems sufficient to construct any MÃ¶bius\n// transformation that does not fix the point at infinity, up to\n// scaling, translation and rotation of the final image.\n//\n// Every MÃ¶bius transformation has two, possibly coincident, fixed\n// points. We show them here - if the circle and mirror line \n// intersect, then the fixed points are their points of intersection\n// (or if line is tangent to the circle, the single point of\n// tangency). If they do not intersect, the fixed points are on the\n// line through the circle centre perpendicular to the mirror.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float scale = 2.2;\nconst float grid = 4.0;\nconst float clip = 2.0;\nconst float width0 = 0.02, width1 = 0.015;\n\nconst float PI\t= 3.14159265359;\nconst float TWOPI = 2.0*PI;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cconj(vec2 z) {\n  return vec2(z.x,-z.y);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cconj(w))/dot(w,w);\n}\n\n// Invert p in circle, centre c, radius squared r2.\nvec2 invert(vec2 p, vec2 c, float r2) {\n    p -= c;\n    p *= r2/dot(p,p);\n    p += c;\n    return p;\n}\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n    return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool showconstruction = !keypress(CHAR_C);\n    bool doinvert = !keypress(CHAR_I);\n    bool doreflect = !keypress(CHAR_M);\n    bool dorotate = !keypress(CHAR_R);\n    \n    vec2 z = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.0) {\n    \tmouse = (2.0*iMouse.xy-iResolution.xy) / iResolution.y;\n    } else {\n      mouse = vec2(cos(0.2*iTime),0.1*iTime);\n    }\n    z *= scale;\n    \n    vec2 z0 = z; // Remember untransformed point\n    \n    float r = 0.5*PI*mouse.y; // y-coord of mouse sets mirror angle\n    \n    vec2 c = vec2(scale*mouse.x,0); // x-coord of mouse sets circle centre\n    vec2 m = vec2(cos(r),sin(r));   // Normal to rotating line\n\n    // Compute the fixed points, this involves solving a\n    // quadratic, the fixed points are the (real or imaginary)\n    // solutions. For a parabolic transformation (circle and line\n    // are tangent), there is just one solution.\n      \n    // First, find the distance from the circle centre to the line\n    float s = dot(c,m);\n    // Now solve for circle centre 0, with mirror at x = -s\n    // Fixed point equation is z^2 - 2sz + 1 = 0\n    float d = s*s - 1.0;\n    float k = sqrt(abs(d));\n    vec2 w0,w1;\n    if (d >= 0.0) {\n      // Real solutions on y = 0\n      w0 = vec2(-s+k,0);\n      w1 = vec2(-s-k,0);\n    } else {\n      // Imaginary solutions on mirror line, x = -s\n      w0 = vec2(-s,k);\n      w1 = vec2(-s,-k);\n    }\n    // Move w0,w1 to correct frame of reference\n    w0 = rotate(w0,r)+c;\n    w1 = rotate(w1,r)+c;\n   \n    vec3 col;\n  \tif (doinvert) z = invert(z,c,1.0);\n    if (doreflect) z = reflect(z,m);\n\tif (keypress(CHAR_B)) z = cdiv(z-w0,z-w1);\n    if (!keypress(CHAR_A)) {\n        float t = 0.2*iTime;      // rotation, mainly for show\n    \tif (dorotate) z = rotate(z,t);\n    \t// Domain coloring is from https://www.shadertoy.com/view/MtjBzV\n    \tfloat arg = atan(z.y,z.x);\n    \tfloat len = length(z);\n    \tvec3 hue = cos(vec3(0,1,-1)*2.0/3.0*PI + arg) * 0.5 + 0.5;\n    \tfloat lum = 1.0;\n    \t// Only show grid for -2 <= x,y <= 2\n    \tif (abs(z.x) <= clip && abs(z.y) <= clip) {\n      \t\tlum *= pow(-cos(z.x * grid * TWOPI) * 0.5 + 0.502, 0.06);\n      \t\tlum *= pow(-cos(z.y * grid * TWOPI) * 0.5 + 0.502, 0.06);\n    \t}\n        col = lum*hue;\n    } else {\n\n        float t = 0.0;\n        if (dorotate) t = 8.0*iTime;\n    \tfloat arg = atan(z.y,z.x);\n\t    float len = length(z);\n    \tvec3 hue = cos(vec3(0,1,-1)*2.0/3.0*PI+arg+t/16.0) * 0.5 + 0.5;\n    \tfloat lum = 1.0;\n        float spiral = 10.0;\n#if 1\n    \tlum *= pow(-cos(spiral*(log(len) - arg)) * 0.5, 0.1);\n    \tlum *= pow(-cos(spiral*(log(len) + arg - 0.5*iTime)) * 0.5, 0.1);\n#else\n        // log here make coloring invert\n    \tlum *= pow(-cos(log(len)*16.0 + t) * 0.5 + 0.502, 0.06);\n    \tlum *= pow(-cos(arg*16.0 + t) * 0.5 + 0.502, 0.06);\n#endif\n        col = lum*hue;\n    }\n    if (showconstruction) {\n      // Now draw circle, mirror line and fixed points.\n      float t = abs(dot(z0,m));\n      t = min(t,abs(length(z0-c)-1.0));\n      t = min(t,max(abs(length(z0-w0)),width0)-width0);\n      t = min(t,max(abs(length(z0-w1)),width0)-width0);\n      // Uncomment next 2 lines to show images of 0 and 1.\n      //t = min(t,max(abs(length(z)),w0)-w0);\n      //t = min(t,max(abs(length(z-vec2(1,0))),w0)-w0);\n      float eps = width1; // 2.0*scale/iResolution.y;\n      col = mix(0.6+0.4*col,col, smoothstep(width1-eps,width1+eps,t));\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldccWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1996, 2026, 2026, 2078], [2080, 2080, 2107, 2107, 2157], [2159, 2159, 2179, 2179, 2206], [2208, 2208, 2235, 2235, 2273], [2275, 2327, 2366, 2366, 2428], [2430, 2430, 2455, 2455, 2568], [2709, 2709, 2766, 2766, 6211]]}
{"id": "ldcyDB", "name": "dunno02", "author": "Del", "description": "dunno", "tags": ["dunno"], "likes": 6, "viewed": 384, "published": "Public API", "date": "1520010312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// dunno02\n// Del 02/03/2018\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.x -= exp(0.5+(uv.y*1.5));\n    uv.y-=time*2./scale;\n    uv.x+=sin(uv.y+time*.95)*0.025;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head,float d)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    vec3 background2 = vec3(1.0-d*d,0.3,0.35);\n    float bub_brightness = 2.5+head+d;\n    vec3 scol = background2 * bub_brightness;\n    scol = mix(background2,scol,c);\n    return scol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/ iResolution.y;\n\n    float d = length(uv);\n    float head = 1.0-length(uv);\n    d+=(0.5+sin(iTime*2.0)*0.5)*0.25;\n    uv *= 0.25;\n    vec3 col = Bubbles(uv*(d+0.5), head,d);\n    fragColor =vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 62, 62, 428], [430, 430, 472, 472, 791], [793, 793, 850, 850, 1102]]}
{"id": "ldcyRs", "name": "fullOfScreenByCircle", "author": "theGarlic", "description": "use circle to full the screen", "tags": ["fullofscreen"], "likes": 0, "viewed": 53, "published": "Public", "date": "1520262975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time interval\n    float ti = 2.0;\n    \n    // Time normalize (from 0 to 1)\n    float t = fract(iTime/ti);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Circle radius max\n    float xMax = length(iResolution.xy) / iResolution.x;\n    float yMax = length(iResolution.xy) / iResolution.y;\n    \n    // Move to center\n    uv = uv - vec2(0.5, 0.5);\n    \n    // Scale uv\n    uv = uv / vec2(xMax, yMax);\n    \n    // Circle radius current\n    float r = clamp(t, 0.0, 1.0);\n    \n    // Color set\n    float d = length(uv);\n    vec3 col = vec3(1.0 * (r - d) / r, 0.2, .0) * 0.9;\n    if (d > r)\n        col = vec3(.0, .0, .0);\n    \n    // Output to screen\n    fragColor.rgb = col;\n    fragColor.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 78, 815]]}
{"id": "ldcyWj", "name": "Thing_7", "author": "balkhan", "description": "draft", "tags": ["draft"], "likes": 8, "viewed": 158, "published": "Public", "date": "1520394471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tret_col;\t// color far\nvec3\th;\t\t\t// accumulated color\nfloat\tscreen_dist;\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n//#define NO_SCREEN\n//#define OUTSIDE\n//#define SCANLINES\n#define PIXELS\n#define GLITCH\n\n// transition function\nfloat\ttrans(float start, float time, float speed)\n{\n\treturn 1. - clamp(exp(-time*speed+start*speed), .0, 1. );\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    #ifdef NO_SCREEN\n    screen_dist=2.;\n    #else\n    screen_dist = 1.+-2.*trans(.1, mod(iTime*.5, 12.), .51)+.0*.125*sin(iTime*2.)+ -55.*trans(10., mod(iTime*.5, 12.), .25);//(1. -clamp(exp(-iTime*.125+5.), .0, 1.) ) ;\n    #endif\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    else\n        ret_col = vec3(.0,.0,.0);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col.xyz = max(col.xyz, h);\n//    col = col - (col*col*col*(2.-3.*col)); // contrast\n\n    c_out =  vec4(col*1.,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    float displz = iTime*1.;\n    #ifdef OUTSIDE\n    p.y -= -5.25;\n    p.x -= -7.;\n    #endif\n    //p.xy += vec2(cos(iTime), sin(iTime) )*.25;\n    p.z -= displz;\n    vec3 op = p;\n    rotate(p.xy, .5*( sin(p.z*.125-iTime*.5)*3.06125+(p.z*.75)+iTime*.5) );\n    //p.xy += vec2(cos(iTime*.5), sin(iTime*.5) )*1.1005;\n    //p.xy += vec2(cos(p.z*.125)*2.3, sin(p.z*.125)*2.3);\n    vec3 pp = p;\n    pp = fract(pp)-.5;\n    \n    mind = min(mylength(pp.yz), min(mylength(pp.xy), mylength(pp.xz) ))-.051;\n    \n    mind = max(mind\n               ,\n               (mylength(p.xy)-1.570)\n              );\n    pp = p;\n    \n    mind = min(mind\n               ,\n               mylength(vec2(abs(pp.x)-.5, pp.y))-.051 // rails\n              );\n    float cadres = max(abs(abs(pp.x)-.2)-.2, max(abs(pp.y)-.2, abs(pp.z+-screen_dist+displz)-.01) );\n    vec2 texcd = 2.*vec2(abs(pp.x) , (pp.y)-.61 )*1.22;\n    if (cadres < E*1.)\n    {\n        vec3 texcol = texture(iChannel0, texcd).xyz;\n        float key;\n        \n        #ifdef GLITCH\n        // little glitch effect\n        vec2 texcdg = texcd;\n        vec2 texcdb = texcd;\n        texcdg.x += sin(floor(iTime*300.)/10.+floor(texcd.y*50.)*.1 )*.05*floor(sin( floor(texcdg.y*500.)+iTime*100. ) );\n        texcdb.x += sin(floor(iTime*300.)/10.+floor(texcd.y*50.)*.1 )*.05*floor(sin( floor(texcdb.y*500.)+iTime*100. +1.57) );\n        vec3 tcg = texture(iChannel0, texcdg).xyz;\n        vec3 tcb = texture(iChannel0, texcdb).xyz;\n        texcol = (1.*texcol+tcg+tcb)*.33333;\n        //texcol = vec3(texcol.x, tcg.y, tcb.z); // too ugly\n        // end glitch\n        #endif\n        // keying\n        key = ( (texcol.y) < length(texcol.xz) ) ? 1. : .0;\n        texcol *= key;\n        // end keying\n        \n        #ifdef SCANLINES\n        // scanlines;\n        texcol += .251*vec3(.1,.5,.1)*ceil(sin(texcd.y*150.)) * (1.-length(texcd.xy+vec2(-.3, .5) ));\n        // end scanlines\n        #endif\n        \n        #ifdef PIXELS\n        // pixels\n        texcol = texcol * abs(1.*cos(texcd.x*150.)*sin(texcd.y*150.) );\n        texcol += vec3(.25,.91,.1)*abs(.125-abs(.125*cos(texcd.x*150.)*sin(texcd.y*150.) ));\n        // end pixels\n        #endif\n    \th = (texcol*1.)*1./max(cadres*cadres , 1.);\n    }\n    mind = min(mind\n               ,\n               cadres\n              );\n    mind = min(mind\n               ,\n               mylength(vec2(mylength(vec2(abs(pp.x)-.182, abs(pp.y)-.02) )-.2, pp.z+-screen_dist+displz ))-.0251\n               );\n    mind = min(mind\n               ,\n               max(-(mylength(vec2(abs(pp.x)-.45,pp.y) )-.025), mylength(vec3(abs(pp.x)-.45,pp.y, pp.z+.75*.0-screen_dist+displz) )-.05)\n               );\n    h += vec3(.75, .45, .1)*1./max(mind*mind*30000.+10., 10.001);\n    \n    float ecrous = 1e5;\n    pp = p;\n    pp.x = abs(pp.x)-.5;\n    pp.z = mod(pp.z, .0625)-.0625*.5;\n    \n    ecrous = mylength(vec2(length(pp.xz)-.051, pp.y ))-.01251;\n\n    mind = min(mind\n               ,\n               ecrous\n               );\n    \n    float bgd = 1e5;\n    \n    bgd = length(p.xy)-3.1;\n    bgd = max(bgd, -(length(p.xy)-3.010) );\n    h += vec3(.2, .27, .74)*1./max(bgd*bgd*30000.+60., .001);\n    bgd = max(abs(bgd), .002);\n    \n    float mine = 1e5;\n    pp = op;\n    rotate(pp.xy, ( (p.z+.5)*-.030 ) +iTime*-.40);\n    op = pp;\n    pp = fract(pp-.5)-.5;\n    rotate(pp.yx, floor( (p.z+.5)*-20. )/20. +iTime*-1.0);\n    mine = mylength(pp.xyz*.15)-0.01468*3.5;\n    mine = max(mine, -(mylength(op.xy)-4.5) );\n    mine = max(mine, mylength(op.xy)-5.4999);\n    h += 1.*vec3(.1, .7, .10)*1./max(mine*mine*100000000.+250., .001);\n\n    mind = min(mind, mine);\n    mind = min(mind, bgd);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n            vec3 dirr;\n            dirr = dir;\n            rotate(dirr.xz, dist.y*.02510+iTime*.0+1.0*sin(iTime*1.)*.2528);\n            //rotate(dirr.zy, -dist.y*.0510+iTime*.0+1.0*sin(iTime*1.)*.125);\n\t    \tp = pos + dirr * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x), abs(p.y) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), max(abs(p.y), abs(p.z)));\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.-.25*abs(sin(iTime*1.125));\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcyWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[526, 549, 600, 600, 661], [663, 663, 706, 706, 1397], [1399, 1399, 1420, 1420, 5108], [5110, 5110, 5142, 5142, 5724], [5726, 5740, 5764, 5764, 5837], [5839, 5839, 5863, 5863, 5944], [5946, 5946, 5986, 5986, 6061], [6063, 6063, 6091, 6091, 6199], [6201, 6201, 6223, 6223, 6455]]}
{"id": "ldGcRm", "name": "rng colors saturated", "author": "lahwran", "description": "describe your shader", "tags": ["tags", "commaseparated"], "likes": 0, "viewed": 80, "published": "Public", "date": "1521438698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub0 = L + 16.0;\n    float sub1 = sub0 * sub0 * sub0 * .000000641;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  \n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3( \n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n    \n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 \n    );\n    return hsluv_toLinear(tuple) * m;\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n    \n    float div = 1./dot(tuple,vec3(1,15,3)); \n\n    return vec3(\n        1.,\n        (52. * (X*div) - 2.57179),\n        (117.* (Y*div) - 6.08816)\n    ) * L;\n}\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = length(tuple.yz);\n    float H = degrees(atan(V,U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\nvec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\nvec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\nvec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\nvec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\nvec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\nvec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\nvec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\nvec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\nvec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\nvec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\nvec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\nvec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\nvec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\nvec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\nvec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\nvec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\nvec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\nvec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\nvec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\nvec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\nvec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\nvec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\nvec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\nvec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\nvec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n\n\n\n\n\n\n\n\n\n// https://stackoverflow.com/a/37221804/1102705\nint cash(int x, int y, int seed){   \n    int h = seed + x*374761393 + y*668265263; //all constants are prime\n    h = (h^(h >> 13))*1274126177;\n    return h^(h >> 16);\n}\n/*vec4 cash4(int x, int y, int seed) { \n    int intensity = cash(x, y, seed);\n    float i1 = float(intensity&0xff);\n    float i2 = float(intensity>>8 & 0xff);\n    float i3 = float(intensity>>16 & 0xff);\n    float i4 = float(intensity>>24 & 0xff);\n    return vec4(i1,i2,i3,i4)/float(0xff);\n}*/\nvec2 cash2(int x, int y, int seed) {\n    \n    int intensity = cash(x, y, seed);\n    float i1 = float(intensity&0xffff);\n    float i2 = float(intensity>>16 & 0xffff);\n    return vec2(i1,i2)/float(0xffff);\n}\nvec4 cash4(int x, int y, int seed) {\n    vec2 xy = cash2(x, y, seed);\n    vec2 zw = cash2(x+30185, y-18513, seed*4815);\n    return vec4(xy,zw);\n}\nfloat smoothstp(float x) { \n  // Evaluate polynomial\n  return x * x * (3. - 2. * x);\n    //\n}\nvec4 mix_custom(vec4 edge0, vec4 edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nvec2 mix_custom(vec2 edge0, vec2 edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nfloat mix_custom(float edge0, float edge1, float x) {\n    return mix(edge0, edge1, smoothstp(x));\n}\nvec4 cash4(int x, int y, float seed) {\n    vec4 a = cash4(x, y, int(floor(seed)));\n    vec4 b = cash4(x, y, int(ceil(seed)));\n    vec4 res = mix(a, b, mix(fract(seed), smoothstp(fract(seed)), 0.5));\n\n    vec4 hsluv_a = rgbToHsluv(res);\n    vec4 hsluv_b = rgbToHsluv(res);\n    vec4 hsluv_res = rgbToHsluv(res);\n    hsluv_res.y = mix(hsluv_a.y, hsluv_b.y, fract(seed))/2.0 + 50.0;\n    hsluv_res.z = mix(hsluv_a.z, hsluv_b.z, fract(seed))/2.0 + 25.0;\n    return vec4(hsluv_toLinear(hsluvToRgb(hsluv_res).xyz), res.w);\n}\nvec4 cash4(float x, int y, float seed) {\n    vec4 a = cash4(int(floor(x)), y, seed);\n    vec4 b = cash4(int(ceil(x)), y, seed);\n    vec4 res = mix_custom(a, b, fract(x));\n    return res;\n}\nvec4 cash4(float x, float y, float seed) {\n    vec4 a = cash4(x, int(floor(y)), seed);\n    vec4 b = cash4(x, int(ceil(y)), seed);\n    vec4 res = mix_custom(a, b, fract(y));\n    return res;\n}\nvec2 cash2(float x, int y, int seed) {\n    vec2 a = cash2(int(floor(x)), y, seed);\n    vec2 b = cash2(int(ceil(x)), y, seed);\n    vec2 res = mix_custom(a, b, fract(x));\n    return res;\n}\nvec2 cash2(float x, float y, int seed) {\n    vec2 a = cash2(x, int(floor(y)), seed);\n    vec2 b = cash2(x, int(ceil(y)), seed);\n    vec2 res = mix_custom(a, b, fract(y));\n    return res;\n}\n\nvec2 cash2(float x, float y, float seed) {\n    vec2 a = cash2(x, y, int(floor(seed)));\n    vec2 b = cash2(x, y, int(ceil(seed)));\n    vec2 res = mix_custom(a, b, fract(seed));\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/600.0;\n    vec2 a = cash2(iTime/20.0, 34625, 75134) - 0.5;\n    vec4 rand = vec4(cash4(pos.x+iTime*(a.x*a.x*0.1), pos.y+iTime*(a.y*a.y*0.1), iTime));\n    vec4 rgb = vec4(hsluv_fromLinear(rand.xyz), rand.w);\n    fragColor = rgb;\n    \n    /*fragColor = toGamma(hsluvToRgb(rand.x * 360.0,\n                           100.0,\n                           50.0,\n                           1.0));//;\n*/}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 83, 83, 135], [137, 137, 191, 191, 241], [243, 243, 310, 310, 489], [491, 491, 530, 530, 1850], [1852, 1852, 1898, 1898, 3042], [3044, 3044, 3077, 3077, 3154], [3155, 3155, 3186, 3186, 3276], [3278, 3278, 3309, 3309, 3387], [3389, 3389, 3418, 3418, 3502], [3504, 3504, 3530, 3530, 3630], [3632, 3632, 3659, 3659, 3737], [3739, 3739, 3766, 3766, 4057], [4059, 4059, 4086, 4086, 4376], [4378, 4378, 4404, 4404, 4665], [4668, 4668, 4695, 4695, 4962], [4964, 4964, 4991, 4991, 5208], [5210, 5210, 5237, 5237, 5372], [5374, 5374, 5403, 5403, 5488], [5490, 5490, 5519, 5519, 5604], [5606, 5606, 5635, 5635, 5714], [5716, 5716, 5745, 5745, 5824], [5826, 5826, 5853, 5853, 5903], [5905, 5905, 5932, 5932, 5982], [5984, 5984, 6013, 6013, 6055], [6057, 6057, 6086, 6086, 6128], [6130, 6130, 6159, 6159, 6201], [6203, 6203, 6232, 6232, 6274], [6276, 6276, 6302, 6302, 6342], [6344, 6360, 6385, 6385, 6437], [6438, 6438, 6463, 6463, 6515], [6516, 6516, 6541, 6541, 6593], [6594, 6594, 6619, 6619, 6671], [6672, 6672, 6697, 6697, 6749], [6750, 6750, 6775, 6775, 6827], [6828, 6828, 6853, 6853, 6905], [6906, 6906, 6931, 6931, 6983], [6984, 6984, 7009, 7009, 7061], [7062, 7062, 7087, 7087, 7139], [7140, 7140, 7165, 7165, 7217], [7218, 7218, 7243, 7243, 7295], [7296, 7296, 7321, 7321, 7373], [7374, 7374, 7399, 7399, 7451], [7452, 7452, 7477, 7477, 7529], [7530, 7530, 7555, 7555, 7607], [7608, 7608, 7633, 7633, 7685], [7686, 7704, 7748, 7748, 7782], [7783, 7783, 7827, 7827, 7861], [7862, 7862, 7906, 7906, 7940], [7941, 7941, 7985, 7985, 8019], [8020, 8020, 8064, 8064, 8098], [8099, 8099, 8143, 8143, 8177], [8178, 8178, 8222, 8222, 8256], [8257, 8257, 8301, 8301, 8335], [8336, 8336, 8380, 8380, 8414], [8415, 8415, 8459, 8459, 8493], [8494, 8494, 8538, 8538, 8572], [8573, 8573, 8617, 8617, 8651], [8652, 8652, 8696, 8696, 8730], [8731, 8731, 8775, 8775, 8809], [8810, 8810, 8854, 8854, 8888], [8889, 8889, 8933, 8933, 8967], [8968, 8968, 9012, 9012, 9046], [9047, 9065, 9118, 9118, 9154], [9155, 9155, 9208, 9208, 9244], [9245, 9245, 9298, 9298, 9334], [9335, 9335, 9388, 9388, 9424], [9425, 9425, 9478, 9478, 9514], [9515, 9515, 9568, 9568, 9604], [9605, 9605, 9658, 9658, 9694], [9695, 9695, 9748, 9748, 9784], [9785, 9785, 9838, 9838, 9874], [9875, 9875, 9928, 9928, 9964], [9965, 9965, 10018, 10018, 10054], [10055, 10055, 10108, 10108, 10144], [10145, 10145, 10198, 10198, 10234], [10235, 10235, 10288, 10288, 10324], [10325, 10325, 10378, 10378, 10414], [10415, 10415, 10468, 10468, 10504], [10505, 10505, 10558, 10558, 10594], [10605, 10653, 10686, 10686, 10821], [10822, 11115, 11151, 11151, 11320], [11321, 11321, 11357, 11357, 11466], [11467, 11467, 11493, 11519, 11560], [11561, 11561, 11611, 11611, 11657], [11658, 11658, 11708, 11708, 11754], [11755, 11755, 11808, 11808, 11854], [11855, 11855, 11893, 11893, 12371], [12372, 12372, 12412, 12412, 12560], [12561, 12561, 12603, 12603, 12751], [12752, 12752, 12790, 12790, 12938], [12939, 12939, 12979, 12979, 13127], [13129, 13129, 13171, 13171, 13322], [13323, 13323, 13380, 13380, 13798]]}
{"id": "ldGyRw", "name": "Portfolio hero II", "author": "kow", "description": "Header animation for my personal site", "tags": ["kaleidoscope"], "likes": 0, "viewed": 74, "published": "Public", "date": "1521567540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------------------------------------------------------------------------\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(1.,5.)\n#define R_ vec2(2.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(A_,M_,p) + t(M_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n#define S1(p) t(C_,A_,p) + t(A_,J_,p) + t(J_,L_,p) + t(I_,H_,p) + t(H_,E_,p) + t(E_,F_,p) + t(O_,M_,p) + t(M_,P_,p) + t(P_,R_,p)\n#define S2(p) t(A_,C_,p) + t(D_,F_,p) + t(G_,H_,p) + t(H_,Q_,p) + t(Q_,P_,p) + t(J_,M_,p) \n#define S3(p) t(A_,C_,p) + t(D_,F_,p) + t(F_,I_,p) + t(I_,G_,p) + t(G_,P_,p) + t(P_,R_,p) + t(L_,K_,p) + t(K_,N_,p) + t(N_,O_,p)\n#define S4(p) t(A_,B_,p) + t(B_,K_,p) + t(K_,J_,p) + t(D_,G_,p) + t(M_,N_,p) + t(N_,Q_,p) + t(Q_,P_,p)\n#define UL(p) t(C_,A_,p) + t(A_,D_,p) + t(D_,F_,p) \n#define UM(p) t(A_,C_,p) + t(D_,F_,p)\n#define UR(p) t(A_,B_,p) + t(B_,E_,p) + t(E_,D_,p)\n\nvec2 caret_origin = vec2(3.0, .7);\nvec2 caret;\nfloat t_time = 0.; // Text drawing delay timer\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\nfloat when_lt(float x, float y) \n{\n\treturn max(sign(y - x), 0.0);\n}\n\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n    float condition = when_lt(count, t_time*15.0);\n\n\treturn textColor(grid(from), grid(to), p) * condition;\n}\n\n\n//-----------------------------------------------------------------------------------\nvec2 r(vec2 fragCoord)\n{\n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\n\n\n// UV warping \nvec2 kaleido(vec2 uv)\n{\n\tfloat th = atan(uv.y, uv.x);\n\tfloat r = pow(length(uv), .9);\n\tfloat f = 3.14159 / 3.5;\n\n\tth = abs(mod(th + f/4.0, f) - f/2.0) / (1.0 + r);\n\tfloat th2 = sin(th * 6.283 / f);\n\n    th += th2;\n    \n\treturn vec2(cos(th), sin(th)) * r * .1;\n}\n\n// for kaleidoscope\nvec2 transform(vec2 at)\n{\n\tvec2 v;\n\tfloat th = .02 * iTime;\n\tv.x = at.x * cos(th) - at.y * sin(th) - .2 * sin(th);\n\tv.y = at.x * sin(th) + at.y * cos(th) + .2 * cos(th);\n\treturn v;\n}\n\n// Lens distortion around edges\nvec2 lens_distortion( vec2 uv, float k, float kcube )\n{\n    vec2 t = uv;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t;\n    nUv.y = nUv.y;\n \n    return nUv;   \n}\n\nfloat getText( vec2 coord )\n{\n    float tex = .0;\n\n    if( iTime < 3. ) \n    {\n        t_time = iTime;\n        newline(); \n        tex += H(r(coord)); add(); \n        tex += I(r(coord)); space();\n        tex += T(r(coord)); add();\n        tex += H(r(coord)); add();\n        tex += E(r(coord)); add();\n        tex += R(r(coord)); add();\n        tex += E(r(coord)); add();\n        newline();\n    }\n\n    if( iTime > 3. && iTime < 8. ) \n    {\n        t_time = iTime - 3.;\n        newline(); \n        tex += E(r(coord)); add(); \n        tex += N(r(coord)); add();\n        tex += T(r(coord)); add();\n        tex += E(r(coord)); add();\n        tex += R(r(coord)); space();\n        tex += M(r(coord)); add();\n        tex += Y(r(coord)); add();\n        newline();\n        tex += L(r(coord)); add();\n        tex += A(r(coord)); add();\n        tex += I(r(coord)); add();\n        tex += R(r(coord)); add();\n        tex += STOP(r(coord)); add();\n        tex += STOP(r(coord)); add();\n        tex += STOP(r(coord)); add();\n    }\n\n    // Logo\n    if( iTime > 8. )\n    {\n        t_time = iTime - 8.;\n        newline();\n        tex += S1(r(coord)); add(); \n        tex += S2(r(coord)); add(); \n        tex += S3(r(coord)); add(); \n        tex += S4(r(coord)); add();\n        newline(); \n        tex += UL(r(coord)); add(); \n        tex += UM(r(coord)); add(); \n        tex += UM(r(coord)); add(); \n        tex += UR(r(coord)); add();\n    }\n    return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /**\n     * basic setup\n     */\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tuv.x = mix(-1.0, 1.0, uv.x);\n\tuv.y = mix(-1.0, 1.0, uv.y);\n\tuv.y *= iResolution.y / iResolution.x;\n\n    float distSpeed = .05;\n    float k = 1.0 * sin( iTime * distSpeed * .9 );\n    float kcube = .5 * sin( iTime * distSpeed );\n    float off = .1 * sin( iTime * distSpeed * .5 );\n\n    /**\n     * kaleidoscope\n     */\n    //vec2 lensedUV = lens_distortion( uv, k + off, kcube );\n    //vec2 kaleidUV = transform(kaleido(lensedUV)) * 4.0;\n    vec2 kaleidUV = transform(kaleido(uv)) * 4.0;\n    vec2 lensedUV = lens_distortion( kaleidUV, k + off, kcube );\n    vec4 kaleTex = texture(iChannel0, lensedUV); // < update here uv\n\n    /**\n     * dithering\n     */\n    vec3 rgb = kaleTex.rgb;\n    vec3 oldcolor = rgb + (rgb * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rgb);\n    vec3 dithered = floor(oldcolor);\n    dithered.g = .0;\n    dithered.b = .261;\n\n    /**\n     * render text\n     */\n\tfloat d = 0.;\n\tcaret = caret_origin;\n\n\t// Build up the text\n\td = getText(fragCoord);\n\n    // Vertical pixel lines\n    d = clamp(d* (.75+sin(fragCoord.x*PI*.5-iTime*4.3)*.5), 0.0, 1.0);\n\n    dithered += vec3(d*.5, d, d*.85);\n\n    /**\n     * vignette fx\n     */\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tdithered *= vec3(.4, .4, .4) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\n\n    fragColor = vec4(dithered, 1.0);\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2871, 2957, 3005, 3068, 3747], [3749, 3835, 3880, 3880, 4224], [4226, 4312, 4342, 4342, 4426], [4428, 4428, 4462, 4462, 4495], [4498, 4603, 4641, 4641, 4761], [4764, 4850, 4874, 4874, 4981], [4983, 5069, 5081, 5081, 5100], [5102, 5188, 5202, 5202, 5221], [5223, 5309, 5325, 5325, 5371], [5461, 5476, 5499, 5499, 5737], [5739, 5759, 5784, 5784, 5941], [5943, 5975, 6030, 6030, 6289], [6291, 6291, 6320, 6320, 7731], [7733, 7733, 7790, 7825, 9182]]}
{"id": "ldGyWR", "name": "Color lineyes", "author": "trbrmrdr", "description": "first shader from fun only!!", "tags": ["colors", "gradient"], "likes": 2, "viewed": 105, "published": "Public", "date": "1521574470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#if 0\n\n#define  thebookofshaders 1\n//thebookofshaders.com/edit.php\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define time (u_time*.5)\n#define mouse (u_mouse/u_resolution)\n#define resolution u_resolution\n\n#elif 1\n//https://www.shadertoy.com\n\n#define time (iTime*.5)\n#define mouse (u_mouse/iResolution)\n#define resolution iResolution\n\n#else\n\n#define  thebookofshaders 1\nuniform float iGlobalTime;\nuniform vec3 iMouse;\nuniform vec2 iResolution;\n\n#define time (iGlobalTime*.5)\n#define mouse (iMouse.xy)\n#define resolution iResolution\n\n#endif\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat sin01( in float angle ) { return .5 + .5*sin( angle ); }\nfloat cos01( in float angle ) { return .5 + .5*cos( angle ); }\nfloat cosft( in float from, in float to, in float val ) { return from + cos01( val )*(to - from); }\nfloat sinft( in float from, in float to, in float val ) { return from + sin01( val )*(to - from); }\n\nfloat RandFloat( int i ) { return (fract( sin( float( i ) ) * 43758.5453 )); }\nint RandInt( int i ) { return int( 100000.0*RandFloat( i ) ); }\n\nvec3 hsb2rgb( in vec3 c )\n{\n\tvec3 rgb = clamp( abs( mod( c.x*6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n\trgb = rgb * rgb*(3.0 - 2.0*rgb);\n\treturn c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\n\nvec3 HsvToRgb( vec3 c )\n{\n    float s = c.y;\n\tfloat s_n = c.z - s * .5;\n\treturn vec3( s_n ) + vec3( s ) * cos( 2.0 * pi * (c.x + vec3( 1.0, 0.6666, .3333 )) );\n}\n\n//####################\n//[-1;+1]\nfloat VFx_t( float x, float t,float id )\n{\n\t//return cos(x+-1.780);\n    float da = RandFloat(int(id)) * 1.;\n\tfloat amplitude = 1.;\n\tfloat frequency = 1.;\n\tfloat y = sin( x * frequency );\n\tfloat t_t = 0.01*(-t * 130.0);\n\ty += sin( x*frequency*(2.1+da) + t_t )*4.5;\n\ty += sin( x*frequency*(1.72+da) + t_t * 1.121 )*4.0;\n\ty += sin( x*frequency*(2.221+da) + t_t * 0.437 )*5.0;\n\ty += sin( x*frequency*(3.1122+da) + t_t * 4.269 )*2.5;\n\ty *= amplitude * 0.06;\n\treturn y;\n}\n\nfloat VFx_t01( float x, float t, float id){ return .5 + .5*VFx_t( x, t, id );}\n\nfloat Fx( float x, vec2 scale )\n{\n\n    const float d_sig = 5.;\n    float sc_y = scale.y/d_sig;\n\tfloat ret = smoothstep( -scale.x, 0., x ) - smoothstep( .0, +scale.x, x );\n\n\tret *= sc_y;\n\tfloat sig = sign( sc_y );\n\tret = smoothstep( .0, sig * d_sig, ret - sig ) * sc_y;\n\treturn ret;\n}\n\n//#undef time\n//#define time (10.*1.936)\n\n//#define TEST_ONCE\n#ifndef TEST_ONCE\n\n#define COUNT_L 15\n\nconst float max_w = 0.5 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*5.;\nconst vec2 d_uv = vec2( 0., -.3 );\n#else\n#define COUNT_L 8\n\nconst float max_w = .000025 / float( COUNT_L );\n\nconst vec2 scale = vec2( .1, 2. )*3.;\nconst vec2 d_uv = vec2(-0.150,-0.420);\n#endif\n\nvec3 color = vec3( 0 );\n//#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t(id , time )) )\n#define FUNC_VFX(id)\t ( max_w * (1. + VFx_t((id) + uv.y, uv.y - time, id )) )\nstruct Line\n{\n\tfloat id;\n\tfloat id_2;\n\n\tfloat xs;\n\tfloat Vx;\n\tfloat c_pos;\n\n\tfloat eye_l;\n\tfloat eye_r;\n\n\tfloat eye_fl;\n\tfloat eye_fr;\n    \n\tvec2 eye_pos;//todo ÑÐ´fÐ»Ð¸ÑÑ x ÑÑÐ¾ Ð²ÑÐµÐ³Ð´Ð° c_pos\n\n\tvec3 color_eye;\n\n\tvec2 scale_eye;\n};\n\nLine setLine(in Line line_in,in vec2 uv){\n    Line line = line_in;\n    line.xs = line.id / float( COUNT_L );\n\tline.id_2 = RandFloat( int(line.id) ) * 2.;\n\tline.Vx = FUNC_VFX( line.id_2 );\n\tline.c_pos = line.xs + line.Vx;\n    return line;\n}\n\nLine setLine( in vec2 uv )\n{\n    Line line;\n\tline.id = floor( uv.x * float( COUNT_L ) );\n    return setLine(line, uv);\n}\n\nLine setLine( in vec2 uv, in float id )\n{\n    Line line;\n\tline.id = id;\n    return setLine(line, uv);\n}\n\n//____________________________________________________________\n// https://www.shadertoy.com/view/MlXyWM\n//original type\n//const int recursionCount\t\t= 8;\t// how deep to recurse\nfloat GetRecursionFade( int recursionCount, int r, float timePercent )\n{\n\tif (r > recursionCount)\n\t\treturn timePercent;\n\n\t// fade in and out recusion\n\tfloat rt = max( float( r ) - timePercent, 0.0 );\n\tfloat rc = float( recursionCount );\n\treturn rt / rc;\n}\n\nvec3 CombinePixelColor( int recursionCount, vec3 color, float timePercent, int i, int r )\n{\n\tvec3 myColor = vec3\n\t(\n\t\tmix( -0.1, 0.1, RandFloat( i + r ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 100 ) ),\n\t\tmix( 0.0, 0.8, RandFloat( i + r + 200 ) )\n\t);\n\n\t// combine with my color\n\tfloat f = GetRecursionFade( recursionCount, r, timePercent );\n\tmyColor.y = pow( myColor.y, 4.0 );\n\tmyColor.z = pow( myColor.z, 4.0 );\n\tcolor += myColor * f;\n\treturn color;\n}\n\nvec3 FinishPixel( vec3 color, vec2 uv )\n{\n\t// color wander\n\tcolor.x += 0.02*time;\n\treturn HsvToRgb( color );\n}\n//____________________________________________________________\n\nbool get_eye( in Line line_in,out Line line, in vec2 uv )\n{\n    line = line_in;\n    //ÑÐºÐ¾ÑÐ¾ÑÑÑ ÑÐ°ÑÐºÑÑÑÐ¸Ñ\n\t//---\n    const vec2 max_scale = vec2( (4.32), (6.680) );\n\t//line.scale_eye = vec2(max_scale.x,1.15) ;\n\tline.scale_eye = max_scale * 1.;\n\n\tfloat udid = RandFloat( int( line.id ) );\n\t//t = .94;\n\t//t= .89+.04*sinft(.0,1.,line.id+t);\n\tfloat t_time = time * .3;\n\tline.scale_eye *= sinft( .0, 1.3, t_time + udid * scale.y );\n\t//line.scale_eye *= sinft(.0,1., t_time+line.id*t*scale.y );\n\n#ifdef TEST_ONCE\n\t//test open eye\n\tline.scale_eye = max_scale * clamp( 0.968, .0, 1. );\n    line.scale_eye = max_scale * sinft(.9,1.2,time*2.);//0.936;\n#endif\n\n\n\t//ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð¿ÐµÑÐµÐ´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ\n\tline.eye_pos.y = scale.y*(-1. + 3.*fract( .25*time*udid ));\n\tline.eye_pos.x = line.c_pos;\n\n#ifdef TEST_ONCE\n\t//test pos eye\n\tline.eye_pos.y = 0.084;\n#endif\n\n\tline.eye_fl = Fx( line.eye_pos.y - uv.y, -line.scale_eye );\n\tline.eye_fr = Fx( line.eye_pos.y - uv.y, line.scale_eye );\n\n\t//color += plot_Fy( pos_eye.x + fl ,color, uv);\n\t//color += plot_Fy( pos_eye.x + fr ,color, uv);\n\t//ÑÐ°Ð¼Ð° Ð»Ð¸Ð½Ð¸Ñ (line.xs + line.Vx) + Ð³Ð»Ð°Ð·\n\tline.eye_l = line.c_pos + line.eye_fl;\n\tline.eye_r = line.c_pos + line.eye_fr;\n\n\tconst float dw = .0001;\n\tfloat fill = smoothstep( line.eye_l, line.eye_l + dw, uv.x )\n\t\t- smoothstep( line.eye_r, line.eye_r + dw, uv.x );\n    \n\n\tif (fill > .00001)\n\t{\n        float t_l = smoothstep(line.eye_pos.x, line.eye_l, uv.x);\n        float t_r = smoothstep(line.eye_pos.x, line.eye_r, uv.x);\n        float to_dark_1 = pow(t_l + t_r, 2.9);\n        \n        \n        float max_r = pow(Fx( line.eye_pos.y , line.scale_eye ) , .04);\n        float to_dark_2 = \n             //smoothstep(.0, \n                            length( (line.eye_pos - uv) * line.scale_eye *vec2(2.,1.) / scale)// /max_r\n                        \n                        //, max_r*.25)\n            ;\n#if 0\n        //Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ ÑÐµÐ½ÑÑÐ°\n        \n        float it = to_dark_2*10.;\n        float ret = it - floor(it);\n        line.color_eye = vec3(\n        //to_dark_2\n            ret\n             //+\n            //smoothstep(line.eye_r, line.eye_pos.x, uv.x)\n        );\n        \n        //line.color_eye = plot_Fy(line.eye_pos.x ,line.color_eye ,uv);\n        //line.color_eye = plot_Fx(line.eye_pos.y ,line.color_eye ,uv);\n        \n        //line.color_eye = plot_Fy(line.eye_l ,line.color_eye ,uv);\n        //line.color_eye = plot_Fy(line.eye_r ,line.color_eye ,uv);\n        return true;\n#endif\n        \n\n        //__________________________________________________________________________________________\n        //Ð¿ÐµÑÐ²ÑÐ¹ Ð²Ð°ÑÐ¸Ð°Ð½Ñ\n\n\tvec3 ret_col1 = vec3(to_dark_2);\n#if 1\n\t{\n        ret_col1 = hsb2rgb(\n\t\t\tvec3(\n\t\t\t\tRandFloat( int(\n\t\t\t\t\tto_dark_2*30. + line.id_2*line.id + time * 10.\n\t\t\t\t\t) )\n\t\t\t\t,\n\t\t\t\t1., 1.-to_dark_1\n\t\t\t) );\n\t}\n\n#endif\n//ÑÐ² Ð²ÑÐ¾ÑÐ¾Ð¹)\nvec3 ret_col2 = vec3(.0);\n#if 1   \n\t{\n        float rand_id = RandFloat( int( line.id_2 ));\n\t\tfloat iterations = to_dark_2 * (25.*sinft( .5, 1., time ) + rand_id )+ time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + rand_id * time ), r );\n\n\t\tret_col2.x += time * 1.5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n#endif\n     \n        ret_col2 = mix(ret_col2,vec3(.0),to_dark_1);\n\t\tcolor = mix(\n            ret_col1,\n            ret_col2,\n            //0.\n            sinft(.0,1.,time*udid)\n        );\n\n        //color = vec3(to_dark_2);\n\n\n#if 0 //type eye\n\t\tif (mod( line.id, 2. ) > .5)return true;\n\t\tvec2 tuv = line.eye_pos - uv;\n\t\ttuv *= line.scale_eye / scale;\n\t\t//tuv.y *= line.scale_eye.y / (scale.y*.25);\n\n\t\tfloat angle = atan( tuv.y, tuv.x ) + time * 5.;\n\t\tfloat r = length( tuv ) / line.scale_eye.x*2.5;\n\n\n\t\tfloat sign = mod( r, sinft( .5, 1.000,\n\t\t\t\t\t\t\t\t\ttime*.5\n\t\t) ) >= 0.25 ? -1. : +1.;\n\t\t//sign = 1.;\n\n\t\tfloat it_sp = 100.*(-1.620 * sqrt( r ) + angle * (-.060 * sign));\n\n\t\tfloat sp = cos( it_sp );\n\t\tfloat sp_2 = sp;\n\t\tsp = sp > .5*r ? 1. : .0;\n\n\t\t//line.color_eye = vec3(sp);\n\t\t//line.color_eye = mix(vec3(sp), line.color_eye ,sinft(.0, 1., time*4.) );\n\t\t///*\n\t\tline.color_eye = mix(//hsb2rgb(vec3(sp,sp,to_dark)), \n\t\t\t\t\t\t\t  vec3( sp ),\n\t\t\t\t\t\t\t  hsb2rgb( vec3(\n\t\t\t\t\t\t\t\t  RandFloat( int(\n\t\t\t\t\t\t\t\t\t  sign*(r + time * .5)*10.\n\t\t\t\t\t\t\t\t\t  ) )\n\t\t\t\t\t\t\t\t  , 1., to_dark_2 ) ),\n\n\t\t\t\t\t\t\t  sinft( .0, 1.5, time ) * sp_2 * r );\n\t\t/**/\n\n\n\n#endif\n\t\treturn true;\n\t\t//line.color_eye = vec3(t_eye);\n\t}\n    return false;\n}\n\n\n\n#ifdef thebookofshaders\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    #else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#endif\n//###################################################\n    \n\tuv.x *= resolution.x / resolution.y;\n\n\tuv += d_uv;\n\tuv *= scale;\n\n    \n\tLine line_c = setLine( uv );\n\tLine line_l = setLine(uv, line_c.id - 1. );\n\tLine line_r = setLine(uv, line_c.id + 1. );\n\tfloat id2 = line_c.id;\n\tfloat t_s1 = line_c.c_pos;\n\tfloat t_s2 = line_r.c_pos;\n    bool hasEye = get_eye( line_c,line_c, uv );\n    color += line_c.color_eye;\n    \n\tif (uv.x < line_c.c_pos)\n\t{//l - c\n\t\tid2 = line_l.id;\n\t\tt_s1 = line_l.c_pos;\n\t\tt_s2 = line_c.c_pos;\n\n\t\thasEye = hasEye || get_eye(line_l, line_l, uv );\n\n\t\tcolor += line_l.color_eye;\n        \n\t\tt_s1 += line_l.eye_fr;\n\t\tt_s2 += line_c.eye_fl;\n\n\t}\n\telse\n\t{\n\t\t// c - r\n\t\thasEye = hasEye || get_eye(line_r, line_r, uv );\n\n        color += line_r.color_eye;\n        \n\t\tt_s1 += line_c.eye_fr;\n\t\tt_s2 += line_r.eye_fl;\n\t}\n\n\t\n\tfloat pct = smoothstep( t_s1, t_s2, uv.x );\n\t//color lines\n\t//pct - ÑÐ± Ð³ÑÐ°Ð´Ð¸ÐµÐ½Ñ Ð¾Ñ ÑÐµÐ½ÑÑÐ° (ÑÑÑ Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ Ð¿ÐµÑÐµÑÐ¾Ð´Ð°)\n\tpct = pow( 1.760*pct*(1.0 - pct), 1.1 );//0.376 );\n\t\t\t\t\t\t\t\t\t\t\t//pct = 1.-pct;\n\t\t\t\t\t\t\t\t\t\t\t///______________________\n\t\t\t\t\t\t\t\t\t\t\t//ÑÐ¸Ð¿ ÑÐ²ÐµÑÐ° Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐ°\n\t//Ð¿ÐµÑÐ²ÑÐ¹ Ð²Ð°ÑÐ¸Ð°Ð½Ñ\n\tvec3 ret_col1 = vec3(pct);\n#if 1\n\t{\n#define gen_col(val) VFx_t01( id2 + pct * uv.y + (val), (val) + uv.y + time + floor(pct*60.), id2)\n\t\tfloat r = gen_col( 0.450 );\n\t\tfloat g = gen_col( 1.3445 );\n\t\tfloat b = gen_col( 2.021 );\n\t\tret_col1 += (vec3( r, g, b )*pct) / (-.25888) + pct;\n\t\tret_col1 += hsb2rgb( vec3(\n\t\t\tRandFloat( int(\n\t\t\t(id2*10.0001 + pct * 3. + time * .1) / .1\n\t\t\t\t) ) + fract( time*.2 )\n\t\t\t, 1., pct ) );\n\t}\n\n//Ð²ÑÐ¾ÑÐ¾Ð¹)\nvec3 ret_col2 = vec3(.0);\n\t{\n\t\t//ÑÐ± Ð³ÑÐ°Ð´Ð¸ÐµÐ½Ñ ÑÐ¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ ÐµÐ³Ð¾ Ð¸ Ð´Ð²Ð¸Ð³Ð°ÐµÐ¼ ÑÐ¾ Ð²ÑÐµÐ¼ÐµÐ½ÐµÐ¼\n\t\t//float iterations =  pct*10. + u_time*-.5;//original\n\t\tfloat iterations = pct * (100.*sinft( .5, 1., time ) + RandFloat( int( id2 ) )) + time * -.5;\n\t\tfloat pct2 = iterations - floor( iterations );\n\t\t//_____\n\t\tconst int recursionCount = 5;\n\t\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t\t\tret_col2 = CombinePixelColor( recursionCount, ret_col2, pct2, int( iterations + id2 * time ), r );\n\t\t//original\n\t\t//new_color =  FinishPixel(new_color, uv);\n\n\t\t//color.x += 0.02*u_time;\n\t\t//return HsvToRgb(color);\n\n\t\tret_col2.x += time * .5;\n\t\tret_col2 = HsvToRgb( ret_col2 );\n\t}\n    if(!hasEye){\n\t\tcolor = mix(ret_col1,ret_col2,sinft(.0,\n                                            //3. * sinft(.125,1.,time)\n                                            1.\n                                            ,time));\n        //color = vec3(pow(.5,1.-pct));\n        //color =  ret_col2;\n    }\n    //else color = vec3(1.);\n    \n#else\n    color = vec3(pct);\n#endif\n\n#ifdef thebookofshaders\n\tgl_FragColor = vec4( color, 1.0 );\n#else\n    fragColor = vec4(color,1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[679, 679, 710, 710, 741], [742, 742, 773, 773, 804], [805, 805, 862, 862, 904], [905, 905, 962, 962, 1004], [1006, 1006, 1032, 1032, 1084], [1085, 1085, 1107, 1107, 1148], [1150, 1150, 1177, 1177, 1352], [1354, 1354, 1379, 1379, 1515], [1517, 1550, 1592, 1617, 2015], [2017, 2017, 2060, 2060, 2095], [2097, 2097, 2130, 2130, 2380], [2784, 3166, 3207, 3207, 3405], [3407, 3407, 3435, 3435, 3527], [3529, 3529, 3570, 3570, 3632], [3634, 3810, 3882, 3882, 4065], [4067, 4067, 4158, 4158, 4517], [4519, 4519, 4560, 4577, 4629], [4630, 4694, 4753, 4753, 9272]]}
{"id": "ldGyWw", "name": "timothy's totally cool gradient", "author": "timothy10583", "description": "its not cool", "tags": ["a"], "likes": 1, "viewed": 120, "published": "Public", "date": "1522185929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "ldGyz1", "name": "noise simplex - gradient", "author": "ilaschino", "description": "noise // senpai IQ", "tags": ["noise"], "likes": 1, "viewed": 81, "published": "Public", "date": "1520990345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1,0,0);\nvec3 green = vec3(0,1,0);\nvec3 blue = vec3(0,0,1);\n\nmat2 rotate(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle),cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x,0,0,value.y);\n}\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//====== GRADIENT ==============\nvec2 ghash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( ghash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( ghash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( ghash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( ghash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//=================================\n\n// ======  SIMPLEX ==================\nvec2 shash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,shash(i+0.0)), dot(b,shash(i+o)), dot(c,shash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nfloat circle(vec2 uv,float radius, vec2 shapePos)\n{\n     \n    float dist = distance(shapePos,uv);\n    float value = step(radius,dist);\n    \n    return value; \n}\n\n//=======================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    float ratio = iResolution.x / iResolution.y;\n    \n    //uv.x *= ratio;\n    \n    \n    float value;\n    float zoom = 9.;\n    vec3 color;\n   \tfloat scale = .02;\n    \n    //uv *= rotate(iTime);\n    \n    float offset = snoise(uv * 9. + iTime );\n    value = step(.4 + offset,uv.x) - step(.8 + offset,uv.x);\n\tcolor = mix(blue,red * iTime, value);\n\n    \n    \n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldGyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 102, 102, 168], [170, 170, 196, 196, 236], [238, 238, 258, 258, 330], [333, 366, 425, 425, 563], [565, 565, 592, 592, 994], [1033, 1071, 1129, 1129, 1250], [1252, 1252, 1279, 1279, 1737], [1739, 1739, 1790, 1790, 1899], [1901, 1943, 2000, 2050, 2486]]}
{"id": "ldKcRG", "name": "Unicorn Rings", "author": "nightfox", "description": "Playing around with rotation and custom lighting", "tags": ["squares"], "likes": 2, "viewed": 399, "published": "Public API", "date": "1522490504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 2.*acos(-1.)\n\nfloat rect(vec2 uv, vec2 bl, vec2 tr, float z) {\n \tfloat b = 0.005+.01*z*z;\n    float r = smoothstep(bl.x-b, bl.x+b, uv.x);\n    r *= smoothstep(bl.y-b, bl.y+b, uv.y);\n    r *= 1.-smoothstep(tr.x-b, tr.x+b, uv.x);\n    r *= 1.-smoothstep(tr.y-b, tr.y+b, uv.y);\n\treturn r;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv *= 2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    int numSquares = min(500, int(2.*iTime));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    for (int square = 0; square < numSquares; square++) {\n        float xShift = .8*sin(float(square)*TWOPI/float(numSquares));\n        float yShift = .8*cos(-iTime+float(square)*TWOPI/float(numSquares));\n        float zShift = .7+(sin(-iTime))*cos(iTime+float(square)*TWOPI/float(numSquares));\n    \tvec2 bl = vec2(-.1+xShift,-.1+yShift);\n    \tvec2 tr = vec2(.1+xShift,.1+yShift);\n        float angle = iTime;\n        vec2 sq_uv = mat2(cos(angle),-sin(angle), sin(angle), cos(angle))*uv;\n        float r = .5+.5*sin(6.*iTime+float(square)*TWOPI/float(numSquares));\n        float g = .5+.5*cos(.9*iTime+float(square)*TWOPI/float(numSquares));\n        float b = .5+.5*sin(iTime+float(square)*TWOPI/float(numSquares));\n        vec3 squareColour = vec3(r, g, b)*(1.-zShift)+1.*length(tr);\n    \tcol = mix(col, squareColour, zShift*rect(sq_uv*zShift, bl, tr, zShift));\n        xShift *= -1.5;\n        yShift *= -1.;\n        bl = vec2(-.1+xShift,-.1+yShift);\n    \ttr = vec2(.1+xShift,.1+yShift);\n        squareColour = vec3(r+g, g, b)*(1.-zShift)+1.*length(tr);\n        col = mix(col, squareColour, zShift*rect(sq_uv*zShift, bl, tr, zShift));\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 76, 76, 302], [304, 304, 361, 411, 1875]]}
{"id": "ldKyRz", "name": "AC Face Initials", "author": "GuntherRox", "description": "bored, made my initials only using circles", "tags": ["bored"], "likes": 0, "viewed": 52, "published": "Public", "date": "1520896051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//For Shapes\nbool circle (vec2 uv, vec2 p, float radius)\n{\n    \tfloat dist = sqrt((uv.x - p.x) * (uv.x -p.x) + (uv.y - p.y) * (uv.y - p.y)); \n    \tif (dist < radius) \n            return true;\n    \telse return false; \n    }\n    \n\\\n    \n    \n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  float sinTime = sin(iTime);\n  sinTime += 1.0;\n  sinTime *= 0.5;\n  \n  fragColor = vec4(sinTime,0.8,0.8,0.6);\n\n\n\n //Gradient that changes\n\n//Location of The Letter C\n    \n  vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  uv -= (.18,.18);\t\t\t\t//-0.5 < > 0.5\n  uv.x *= iResolution.x/iResolution.y; \n   \n  vec2 center = vec2(0.0, 0.0);\n    \n\n\n //Cloud Location\n     vec2 Cloud = vec2 (0.8, 0.30);\n // Cloud Size\n\tfloat Cloud1  = 0.6 * (1.0);\n // Cloud Color Design\n    bool isInCloud = circle (uv, Cloud, Cloud1);\n    if (isInCloud) fragColor = vec4 (0.9,0.9,0.85,1.0);\n\n  //Letter A\n     vec2 LetterA = vec2 (0.52, 0.32);\n // Letter A Size\n\tfloat LetterA1  = 0.18 * (1.0 + sin(iTime)) * 0.6;\n //Letter A Color Design\n    bool isInLetterA = circle (uv, LetterA, LetterA1);\n    if (isInLetterA) fragColor = vec4 (0.6,0.3,0.5,0.0);    \n    \n  //Letter ACover Up\n     vec2 LetterAC = vec2 (0.52, 0.32);\n // Letter A Size\n\tfloat LetterA1C  = 0.12 * (1.0 + sin(iTime)) * 0.6;\n //Letter A Color Design\n    bool isInLetterAC = circle (uv, LetterAC, LetterA1C);\n    if (isInLetterAC) fragColor = vec4 (0.9,0.9,0.85,1.0);  \n  \n    \n    //Letter A Little Leg\n     vec2 LetterAL = vec2 (0.7, 0.221);\n // Letter A Size\n\tfloat LetterA1L  = 0.060 * (1.0 + sin(iTime)) * 0.5;\n //Letter A Color Design\n    bool isInLetterAL = circle (uv, LetterAL, LetterA1L);\n    if (isInLetterAL) fragColor = vec4 (0.6,0.3,0.5,0.0);    \n \n//Letter A Little Leg CoverUP\n     vec2 LetterAL1 = vec2 (0.75, 0.225);\n // Letter A Size\n\tfloat LetterA1L2  = 0.048 * (1.0 + sin(iTime)) * 0.5;\n //Letter A Color Design\n   bool isInLetterAL1 = circle (uv, LetterAL1, LetterA1L2);\n    if (isInLetterAL1) fragColor = vec4 (0.9,0.9,0.85,1.0);  \n    \n\n       \n    \n    \n //Letter C\n     vec2 LetterC = vec2 (0.98, 0.32);\n // Letter C Size\n\tfloat LetterC1  = 0.19 * (1.0 + sin(iTime)) * 0.6;\n //Letter C Color Design\n    bool isInLetterC = circle (uv, LetterC, LetterC1);\n    if (isInLetterC) fragColor = vec4 (0.6,0.3,0.5,0.0);  \n    \n //Letter C CoverUP\n   vec2 LetterCU = vec2 (1.05, 0.32);\n // Letter C Size\n\tfloat LetterC1U  = 0.19 * (1.0 + sin(iTime)) * 0.6;\n //Letter C Color Design\n   bool isInLetterCU = circle (uv, LetterCU, LetterC1U);\n    if (isInLetterCU) fragColor = vec4 (0.9,0.9,0.85,1.0);\n    \n \n    \n    }\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 58, 58, 222], [246, 246, 303, 303, 2578]]}
{"id": "ldKyWz", "name": "Lake.", "author": "Pr0fed", "description": "Getting more point into mixing colors of different noises. Still 2DVoronoi + 3DPerlin though.\nHow is my cool zooming effect?)", "tags": ["proceduraltexture"], "likes": 0, "viewed": 184, "published": "Public", "date": "1521660916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-- 2D Worley noise. -------------------------------------------------------\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n//--------------------------------------------------------------------------\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// 3D Gradient noise by Iq.\nfloat noise3D( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f * f * (3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n#define NUM_OCTAVES 8\n\nfloat fbm ( in vec2 _st, float n) \n{\n    float v = 0.075;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.25), sin(1.25),\n                    -sin(1.25), cos(0.25));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * noise3D(vec3(_st, 0.5));\n        _st = rot * _st * 2.5;\n        \n        // Need to clamp, or it is very soft when camera is away and very sharp when near.\n        a *= clamp(n, 0.3, 0.65);\n    }\n    \n    return v;\n}\n\n// Colors.\nvec3 DirtyOrange = vec3(0.500, 0.375, 0.000);\nvec3 LightBlue = vec3(0.000, 0.478, 0.950);\nvec3 LightGreen = vec3(0.161, 0.739, 0.160);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Basic normalization.\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -0.95 + 2.0 * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Centering the lake.\n    uv.y += 0.2;\n    \n    \n    float n = (-sin(iTime * 0.2) * 3.);\n\t\n    // Not sure why it is 'n'. I guess i should name it 'z' for zoom or smth. else.\n    uv *= 4. + n;\n    \n    float w = worley2D(vec2(fbm(0.33 * uv, -(n / 3.)))) * fbm(uv * 0.65, -(n / 3.));\n    \n    float grass = fbm(uv * 0.5, -(n / 3.));\n        \t  \n    vec3 col = vec3(w * 4.0);\n    \n    vec3 grassCol = LightGreen * vec3(grass);\n\t\n    // LightBlue color tweaking works like a charm.\n    // But i still didn't get full idea behind mixing more then 2 colors.\n    // I mean, if you change LightGreen it won't work as if you change LightBlue one channels.\n    // (obviously cause i'm doing \"1.0 - \" but i didn't figure out how to make it correct yet. \n    // I mean all the blending, with keeping the color channels input stable and correct.\n    col = mix((DirtyOrange * 0.9) * ((1.0 - (grassCol + grassCol)) * 1.35),\n              LightBlue * 1.1,\n              clamp((col * col), 0., 1.));   \n\n    // Output to screen.\n    fragColor = vec4((col * col) * 2., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 97, 97, 136], [138, 138, 154, 154, 231], [233, 233, 260, 260, 639], [641, 760, 781, 781, 950], [952, 980, 1008, 1008, 1837], [1862, 1862, 1898, 1898, 2352], [2354, 2501, 2558, 2586, 3772]]}
{"id": "ldKyzw", "name": "Nebulous Shape", "author": "metabog", "description": "Riffing on an older idea.", "tags": ["lorenzattractor"], "likes": 1, "viewed": 71, "published": "Public", "date": "1521501244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n     //float pr = min(cos(uv.y* iTime),   sin(uv.x* iTime)) ;\n     float pr = 0.02;\n\t float r = cos(0.2*iTime)*10.0+5.8;\n\t float b = -iTime;\n\t float xn =(uv.x - 0.5) *4.0;\n\t float yn =(uv.y-0.5)*4.0;\n\t float zn = uv.x;\n        \n    float intens = 0.0;\n    //iterate at this pixel for a while and solve lorenz-ish oscillator equations\n    for(int i = 0; i <220; i++)\n    {\n        float xnn = xn*yn - xn + (pr * (yn - zn));\n\t\tfloat ynn = yn*zn*xn + (-xn * zn - yn);\n\t\tfloat znn = zn*yn*xn + (xn * zn);\n\t\txn = xnn + r;\n\t\tyn = ynn;\n\t\tzn = znn;\n        if(length(vec3(xnn,ynn,znn))>220.0)\n        {\n            intens = float(i)/220.0;\n            break;\n        }\n    }\n    \n\tfragColor = vec4(hsv2rgb(vec3(intens*0.5 + 0.25,0.8,0.8)),1.0) * pow(intens,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 605, 605, 1410]]}
{"id": "ldtcD2", "name": "Red Gradient", "author": "GuntherRox", "description": "testing", "tags": ["red"], "likes": 0, "viewed": 56, "published": "Public", "date": "1520833874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  float sinTime = sin(iTime);\n  sinTime += 1.0;\n  sinTime *= 0.5;\n  \n  fragColor = vec4(sinTime,0,0,1);\n}\n\n\n //Red Gradient that changes\n\n//yellow circle ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 165]]}
{"id": "ldVyDW", "name": "flowerthing", "author": "laney", "description": "repetition experiment", "tags": ["2d"], "likes": 7, "viewed": 161, "published": "Public", "date": "1522248630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdCircle(vec2 p, float r) {\n \treturn length(p) - r;\n}\n\nvec4 cRep4(vec2 p, float n) {\n    vec2 pn = p * n;\n \treturn vec4(fract(pn) * 2.0 - 1.0, floor(pn));   \n}\n\nvec2 cRot(vec2 xy, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n \treturn xy * mat2(c, -s, s, c);\n}\n\nfloat asLine(float d) {\n    return smoothstep(1.5,.0,abs(d));\n}\n\nfloat asFilled(float d) {\n    return smoothstep(1.5,0., d);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec4 m =  (2.*iMouse  - iResolution.xyxy) / iResolution.y;\n    \n    uv = cRot(uv,-iTime/10.0);\n    vec4 uv4 = cRep4(uv,1.0/(0.3 + sin(iTime*.6)*0.2));\n \n    uv = uv4.xy; \n    float dist = length(uv4.zw);\n    float id = 5.0*uv4.z+uv4.w;\n    vec3 bgColour = vec3(1.0+uv4.z/16.0, 0.5+uv4.w/16.0, dist/iTime);\n    \n\tfloat radius = 0.6 + sin(iTime * dist * max(1.0,3.0/(abs(id)+1.)) + atan(uv.x,uv.y)*min(10.0,abs(id)))*0.2;\n\n    float d = sdCircle(uv, radius);\n    uv = 1.-abs(uv); \n    d = uv.x>.1 && uv.y>.1 ? d / fwidth(d) : 1e5; \n    \n    fragColor = vec4(bgColour * (abs(id)<10. ? asLine(d) : asFilled(d)),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 60], [62, 62, 91, 91, 166], [168, 168, 201, 201, 288], [290, 290, 313, 313, 353], [355, 355, 380, 380, 416], [419, 419, 476, 476, 1153]]}
{"id": "ldVyWm", "name": "Euler line ", "author": "PiechureQ", "description": "euler line\n", "tags": ["geometry"], "likes": 0, "viewed": 76, "published": "Public", "date": "1522329423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://en.wikipedia.org/wiki/Euler_line\n//I've only implemented centroid and orthocenter of this triangle to create this line\n\nfloat a(vec2 A, vec2 B){ \n\treturn (B.y - A.y) / (B.x - A.x);   \n}\n\nfloat b(vec2 A, vec2 B){\n    return ((A.y * B.x) - (A.x * B.y)) / (B.x - A.x);\n}\n\nfloat perA(vec2 A, vec2 B){\n\treturn -1.0 / a(A, B);    \n}\n\nfloat perB(vec2 A, vec2 B, vec2 C){\n\treturn C.y - perA(A,B) * C.x;\n}\n\nvec2 weightCenter(vec2 A, vec2 B, vec2 C){\n\treturn vec2((A.x + B.x + C.x) / 3.0, (A.y + B.y + C.y) / 3.0);   \n}\n\nvec2 orthoCenter(vec2 A, vec2 B, vec2 C){\n    float x = (perB(A, C, B) - perB(A, B, C)) / (perA(A,B) - perA(A,C));\n    float y = (perA(A, B) * x) + perB(A, B, C); \n\treturn vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 10.0 * (fragCoord - .5  * iResolution.xy)/iResolution.y;\n    float x = uv.x;\n    float y = uv.y;\n    float time = iTime * .4;\n    vec3 col = 0.5 + 0.5*cos(iTime + (uv.xyx / 5.0)+vec3(0,2,4)) / 2.0;\n    \n    //triangle vertices coordinates\n    vec2 A = vec2(-4.0, -2.0);\n    vec2 B = vec2(4.0, -1.0);\n    vec2 C = vec2(2.0, 2.0);\n    \n    //animation\n    A.x += sin(time) * 4.;\n    A.y += sin(time);\n    B += sin(time) * 2.;\n    C.x += sin(time) * 3.0;\n    C.y += sin(time) + 1.0;\n    \n    vec2 center = weightCenter(A, B, C);\n    vec2 ortho = orthoCenter(A, B, C);\n   \n    if(y < a(ortho, center) * x + b(ortho, center))\n        col *= 0.3;\n    else\n        col *= 0.8;\n    \n    if(!(y < a(A, B)*x + b(A,B) || y > a(A, C)*x + b(A, C) || y > a(C, B)*x + b(C, B)))\n    \tcol = 0.5 + 0.5*cos(uv.xyx / 2.0+vec3(0,2,4));\n    \n    if(abs(a(ortho, center) * x + b(ortho, center) - y) < 0.02)\n        col = vec3(0.0);\n    \n    //uncomment to see centroid \n\t//if(pow(x - center.x, 2.0) + pow(y - center.y, 2.0) < 0.003)\n   \t//\tcol = vec3(1.0, 0.0, 0.0);\n    //uncomment to see othocenter\n    //if(pow(x - ortho.x, 2.0) + pow(y - ortho.y, 2.0) < 0.003)\n   \t//\tcol = vec3(0.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 130, 154, 154, 195], [197, 197, 221, 221, 277], [279, 279, 306, 306, 336], [338, 338, 373, 373, 406], [408, 408, 450, 450, 519], [521, 521, 562, 562, 706], [708, 708, 765, 765, 1979]]}
{"id": "ldVyzh", "name": "Doodling #3: Glass", "author": "lsdlive", "description": "Doodling session.\nThanks to iq, mercury, lj, aiekick, balkhan & all shadertoyers.\nGreets to all the shader showdown paris gang.\n\nPhantom mode from aiekick: https://www.shadertoy.com/view/MtScWW", "tags": ["raymarch", "doodling"], "likes": 21, "viewed": 341, "published": "Public", "date": "1521069033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r2d(float a) {\n    float c=cos(a),s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sc(vec3 p, float s) {\n    p=abs(p);\n    p=max(p,p.yzx);\n    return min(p.x,min(p.y,p.z)) - s;\n}\n\nvec2 amod(vec2 p, float c) {\n    float m = c/6.28;\n    float a = mod(atan(p.x,p.y)-m*.5, m)-m*.5;\n    return vec2(cos(a), sin(a)) * length(p);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p.x = abs(p.x) - d.x;\n    p.x = abs(p.x) - d.x;\n    if(p.y>p.x)p=p.yx;\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n    \n    vec3 q = p;\n    \n    p.xy *= r2d(iTime*.1);\n    \n    \n    q.xy += vec2(sin(q.z*2.+1.)*.2+sin(q.z)*.05, sin(q.z)*.4);\n    float c = length(max(abs(q+vec2(0,.05).xyx) - vec3(.01, .01, 1e6), 0.));\n    \n    p.xy *= r2d(p.z*.1);\n    p.xy = amod(p.xy, 19.);//8.\n    float d1 = 2.;\n    p.z = mod(p.z-d1*.5, d1) - d1*.5;\n    \n    \n    mo(p.xy, vec2(.1, .3));\n    mo(p.xy, vec2(.8, .9));\n    \n    p.x = abs(p.x) - .8;\n\n    p.xy *= r2d(.785);\n    mo(p.xy, vec2(.2, .2));\n    \n    \n    float d = sc(p, .1);\n    d = min(d, c);\n    g+=.01/(.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0,0,iTime*2.);\n    vec3 rd=normalize(vec3(uv,1));\n       \n    vec3 p;\n    float ri,t=0.;\n    for(float i=0.;i<1.;i+=.01) {\n        ri=i;\n        p=ro+rd*t;\n        float d = de(p);\n        if(t>30.) break;\n        d = max(abs(d), .0004);\n        t+=d*.5;\n    }\n\n    vec3 bg = vec3(.2, .1, .2);\n\n    vec3 col = bg;\n    if(t<=30.)\n\t    col = mix(vec3(.9, .3, .3), bg, uv.x+ri);\n\n    col+=g*.02;\n\n    col = mix(col, bg, 1.-exp(-.1*t*t));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 80], [82, 82, 109, 109, 183], [185, 185, 213, 213, 329], [331, 331, 362, 362, 439], [455, 455, 473, 473, 1035], [1037, 1037, 1094, 1094, 1672]]}
{"id": "ldVyzR", "name": "Marmaladey Rays", "author": "audiopixel", "description": "Climb the tower", "tags": ["raymarching", "rays", "lighting"], "likes": 2, "viewed": 119, "published": "Public", "date": "1520883710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Marmaladey Rays'\n// Created by hepp maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float t = iTime + 240.;\n    float k = (t * 4.)+ sin(t * .5) * 4.;\n    float r = 14.7072541 + sin(t * .4) * 6.;\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5.0, (20.))-10.; a = abs(o.y);\n    p.zy *= r2d(sign(a)*0.3998);\n    p.xz *= r2d(sign(a)*k * .25 - sin(t) * .4);\n    p.xz = amod(p.xz, 0.785398163375  - sin(t * .35) * .5);\n    p.xz = max(abs(p.xz)-(0.732119777+ sin(t) * .7), (-0.73844485 - sin(t * .3) * 1.2));\n    p.z = mod(p.z, 1.00980358)-0.50490179;\n    p.x = mod(p.x, r)-(r *.5);\n    p.y = mod(p.y+k, 15. + sin(iTime) * .014)-5.;\n    d = min(d, soc(max(abs(p)-0.183095666, 0.096382810)));\n    return (length(p*-0.34201)-1.3970756)*(0.2746 - sin(t * 1.) * .15) - (d * -2.);\n} \n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 ro = vec3(st, 12.5022423);\n    vec3 rd = normalize(vec3(st+vec2(0.), -0.41422437));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp); if (md <.001) break;\n        mp += (rd*.480739274206)*md*.838429808073;\n    }\n    vec3 c1 = vec3(-0.3 - (length(ro-mp) * .02496077) * -1.19102289690);\n    vec3 c2; vec3 light = vec3(0,0,0); vec3 p = ro + rd * (mp); vec3 normal = calcNormal(p);\n    float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n    dif *= 5. / dot(light - p, light - p);\n    c2 = vec3(pow(dif, .4545)); \n    c2 = vec3(normal.z * .75, 0., normal.y * .25);\n    c2 -= vec3(normal.y * 3., 1., 0.);\n    fragColor = vec4((c1 + max(c1, c2 * -0.5708 + sin(iTime * .34) * .25)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVyzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[160, 289, 308, 308, 383], [385, 385, 404, 404, 515], [517, 517, 545, 545, 630], [632, 632, 651, 651, 1349], [1352, 1352, 1380, 1380, 1572], [1574, 1574, 1630, 1630, 2437]]}
{"id": "ldycW1", "name": "sin wave 001", "author": "ykob", "description": "study to make mask pattern.", "tags": ["sin"], "likes": 3, "viewed": 110, "published": "Public", "date": "1521789218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat wave = sin((fragCoord.x + fragCoord.y) * 0.2 + iTime * 10.0);\n\n    vec3 waveColor = vec3((wave + 1.0) / 2.0);\n    \n    fragColor = vec4(waveColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 218]]}
{"id": "ldycWR", "name": "Another Collatz Fractal", "author": "Ebanflo", "description": "Reverse engineering [url=https://www.shadertoy.com/view/llcGDS]iq's awesome shader[/url]. Decided to add mouse interactivity for fun.", "tags": ["2d", "fractal", "collatz"], "likes": 2, "viewed": 405, "published": "Public API", "date": "1521577619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The Collatz sequence diverges for most of the complex plane\n//So how about look at the direction that it diverges in?\n//That's how this fractal is constructed\n\n#define derivative\n//#define ratio\n\n#define interactive\n#define sensitivity 2.0\n//#define grid\n#define gridThickness 0.001\n\n#define scale 1.0//exp(-5.5 - 5.5*sin(0.1*iTime))\n#define yShift 0.0\n#define xShift 0.0\n\n#define AA 2\n#define fractalIters 55\nconst float pi = 3.14159;\n\nvec2 cexp(vec2 z){return exp(z.x)*vec2(cos(z.y), sin(z.y));}\nvec2 cexpj(vec2 z){return exp(-z.y)*vec2(cos(z.x), sin(z.x));}\nvec2 cmul(vec2 a, vec2 b){return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );}\n\nvec2 m(float t){\n    return iMouse.xy == vec2(0) ? -0.25*vec2(cos(t), 1.0 - sin(t))\n    : sensitivity*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n}\n\nvec2 collatz(vec2 z){\n    #ifdef interactive\n    return 1.75*z + 2.0*m(iTime) - cmul(cexpj(pi*z), 1.25*z + vec2(0.5, 0));\n    #else\n    return 1.75*z + vec2(0.5, 0) - cmul(cexpj(pi*z), 1.25*z + vec2(0.5, 0));    \n    #endif\n}\n\nvec2 dCollatz(vec2 z){\n    return vec2(1.75, 0) - cmul(1.25*pi*vec2(-z.y, z.x) + vec2(1.25, 0) + vec2(0.5*pi, 0), cexpj(pi*z));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(vec2 xy){\n    #ifdef grid\n    vec2 f = fract(xy);\n    if(f.x < gridThickness || f.y < gridThickness) return vec3(0);\n    #endif\n    vec2 z = xy;\n    vec2 dz = vec2(1, 0);\n    for(int i = 0; i < fractalIters; i++){\n        dz = cmul(dz, dCollatz(z));\n        z = collatz(z);\n    }\n    #ifdef ratio\n    return vec3(length(z)/length(dz));\n    #endif\n    #ifdef derivative\n    float arg = atan(dz.y, dz.x);\n    #else\n    float arg = atan(z.y, z.x);\n    #endif\n    //return vec3(z == z);\n    //return vec3(abs(arg - 0.25*pi));\n    return hsv2rgb(0.5 + 0.5*sin(arg - vec3(0, 0.666666*pi, 1.333333*pi))).bgr;\n}    \n\nvec2 rect(vec2 frag){\n    return scale*(2.0*frag - iResolution.xy)/iResolution.y + vec2(xShift, yShift);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 px = rect(fragCoord + vec2(m, n)/float(AA));\n    \tcol += render(px);    \n    }\n    col /= float(AA*AA);\n#else\n        \n    col = render(rect(fragCoord));\n#endif            \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldycWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 439, 457, 457, 499], [500, 500, 519, 519, 562], [563, 563, 589, 589, 642], [644, 644, 660, 660, 795], [797, 797, 818, 818, 1022], [1024, 1024, 1046, 1046, 1153], [1155, 1155, 1177, 1177, 1340], [1342, 1342, 1363, 1363, 1957], [1963, 1963, 1984, 1984, 2069], [2071, 2071, 2128, 2128, 2454]]}
{"id": "ldyyD1", "name": "sin wave 003", "author": "ykob", "description": "study to make mask pattern.", "tags": ["sin"], "likes": 2, "viewed": 67, "published": "Public", "date": "1521794985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 u )\n{\n\tfloat w1 = sin(u.x * .02 + iTime * .5);\n\tfloat w2 = sin(u.x * .03 + iTime / .5) * .6;\n\tfloat w3 = sin(u.x * .04 + iTime / .1) * .3;\n\n\n    vec3 waveColor = vec3(.5 + (w1 + w2 + w3) / 3.8);\n    \n    O = vec4(waveColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 266]]}
{"id": "ldyyDh", "name": "Burial for Aliasing", "author": "ocb", "description": "An attempt to get rid of aliasing in raycasting, using only 1 ray.\nSome artifacts remains, however the image is globaly improved.\nSee program options lines 44 and 62\nSoft shadow & blurred reflection\nMouse enable.\nWhen split screen, left side is AA.", "tags": ["raytracing", "aliasing", "shadow", "aa"], "likes": 11, "viewed": 707, "published": "Public API", "date": "1521756622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: ocb\n// Title: Burial for Aliasing\n\n/************************************************************************************************************/\n// This is an attempt to get rid of aliasing in raycasting, maintaining good perfos.\n// Only 1 ray is used (no super sampling).\n// Primitives are modified + spÃ©cific process.\n//\n// I add textures for fun, but it's better to de-activate texture to have a better\n// view of the AA. (#define in the header line 46)\n// \n// There are three parts that need to be anti-aliased (AA):\n// 1- the visual outside contour of an object\n// 2- the line created by the intersection of 2 objects\n// 3- the internal lines created by a broken surface in a single object\n//    typically a cube, or a cone/cylinder with a cap.\n//\n// Case 1- the visual outside contour of an object:\n// The max depth reach by the ray into an object is used as a transparency factor.\n// This allow to mix the front object color with the backgroud object.\n// For simplified process and better perfos, only the first (closest) background object is consider.\n// It is a kind of \"first order anti aliasing\".\n// This may generate some artifacts, but not realy noticeable as AA involve only 2 or 3 pixels width.\n//\n// Case 2- the line created by the intersection of 2 objects:\n// Distance between the front and background surface of each interconnected object is the mixing factor.\n//\n// Case 3- Internal lines created by 2 surfaces (cube):\n// This must be done inside the primitive calculation.\n// The hit surface and the closest surface from the hit must be found.\n// The 2 normals are mixed related to the distance between the 2 surfaces.\n// Then the shadowing goes smoothly from a face to another.\n//\n// The objective is to do simple calculation for perfos. Then some aliasing or artifacts remain.\n// Overall smooth image is finally obtained in 90% of time.\n//\n// Shadows are just widely anti-aliased to obtain soft shadows using the same transparency factor.\n//\n// Code and algo can surely be optimized!\n//\n// Ok, now I must go back on my old shader for AA improvement...\n/***************************************************************************************************************/\n\n/***************************  PROGRAM OPTIONS  ***********************/\n\n// - Increase anti-aliasing thickness to enlarge AA\n// this allow to see the \"mixing\" process.\n// TH should be tuned to obtain 2 or 3 pixels width of AA\n//\n// - AA_AREA set in vivid color the AA involved area.\n// (Where d < 1)\n//\n// - SPLIT to split screen. \n\n/******  show Anti-aliased area  ********/\n//#define AA_AREA\n\tconst vec3 AREAcol = vec3(0.,1.,0.);\n\n/******   Anti-aliasing thickness  ******/\n#define TH 5.\n\n/******  Split screen for comparison ****/\n#define SPLIT\n\n/*********************************************************************/\n\n\n/*********************  Add-on process activation  ******************/\n\n#define ACTIVATE_TEXTURE\n\n#define ACTIVATE_SHADOW\n    /***    Shadow softness              ***/\n    #define SH .2\n    /***    Shadow darkness (0 to 1)     ***/\n    #define SC 1.\n\n#define ACTIVATE_REFLECT\n    /***    Reflect softness             ***/\n    #define RF 30.\n    /***    Reflect coef  (0 to 1)       ***/\n    #define RC .3\n\n/********************************************************************/\n\n\n// std needs\n#define PI 3.141592653589793\n#define PIdiv2 1.570796326794897\n#define INFINI 1000.\n\n// objects infos\n#define SKY -1\n#define SPH 1\n#define XCYL 2\n#define ZCYL 3\n#define BOX 4\n#define CONE 5\n\n#define spO vec3(.0)\n#define spR 1.\n#define spCol vec3(1.000,0.839,0.830)\n\n#define cyO vec2(.5)\n#define cyR .4\n#define cyCol vec3(0.928,1.000,0.932)\n\n#define boxO vec3(.0,.1,.1)\n#define boxD vec3(.2,1.2,.82)\n#define boxCol vec3(0.890,0.879,1.000)\n\n#define conO vec3(1.,-.1,.65)\n#define conR .4\n#define conH 1.5\n#define conCol vec3(1.000,0.325,0.402)\n\n\n// Classical raycast parameters\nstruct Type_Param{\tfloat t;\t// distance factor to the object\n            \t\tint hit;\t// ID of hit object\n            \t\tvec3 n;\t\t// normal of hit point\n            \t\tfloat d;\t// max depth reach by ray\n            \t};\n\n\n/************************  Standard cam setting  ************************/\nvec3 getCamPos(in vec3 camTarget){\n    vec3 cam;\n    float \trau = 3.,\n    \t\talpha = iMouse.x/iResolution.x*4.*PI,\n    \t\ttheta = iMouse.y/iResolution.y*PI+(PI/2.0001);\n    if(iMouse.x==0.) cam = rau*normalize(vec3(.2,.4,.5));\n    else cam = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n    \n    vec2 dcam = cam.xy-cyO;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n    if(length(dcam)<=cyR) cam.y = 1.1*sign(dcam.y)*sqrt(cyR*cyR-(dcam.x)*(dcam.x))+cyO.y;\t//  cylinder anti-collision\n    dcam = cam.zy-cyO;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n    if(length(dcam)<=cyR) cam.y = 1.1*sign(dcam.y)*sqrt(cyR*cyR-(dcam.x)*(dcam.x))+cyO.y;\t//\n    return cam;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\n/**************************  Modified primitives  ***********************/\n\nvec2 sphereImpact(in vec3 pos, in vec3 ray, in vec3 O, in float R, inout vec3 norm ){\n    float d=0., t = INFINI;\n    vec3 a = O - pos;\n    float b = dot(a, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(a,a) - R*R;\n    \td = b*b - c;\n    \tif (d >= 0.){\n        \tfloat sd = sqrt(d);\n            t = b - sd;\n            if (t < 0.001) b + sd;\n            norm = normalize(pos + t*ray - O);\n        }\n    }\n    \n    // The depth reach by the ray depends on the discriminant d.\n    // The depth vary from 0 to large value. We consider transparency factor is d when 0.<d<1.\n    // As AA concern only 1 or 2 pixels, we have to convert d related to 1 pixel.\n    // if object is far, 1 pixel can represent a large amount of sphere radius\n    // d must go from 0 to 1 in a pixel size.\n    d = max(0.,d);\n    return vec2(t, d*iResolution.x/R);\n}\n\nvec2 cylinderImpact(in vec2 pos,in vec2 ray, in vec2 O, in float R, inout vec2 norm){\n    float t=INFINI;\n    vec2 d = pos - O;\n    float a = dot(ray,ray);\n    float b = dot(d, ray);\n    float c = dot(d,d) - R*R;\n    float discr = b*b - a*c;\n    if (discr >= 0.){\n        t = (-b - sqrt(discr))/a;\n        if (t < 0.001) t = (-b + sqrt(discr))/a;\n        if (t < 0.001) t=INFINI;\n\n        norm = normalize(pos + t*ray - O);\n    }\n    discr = max(0.,discr);\n\treturn vec2(t,discr/a*iResolution.x/R);\n}\n\n\nvec2 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim, out vec3 norm) \n{\n    vec3 m = 1.0/ray;\n    vec3 n = m*(ctr-pos);\n    vec3 k = abs(m)*dim;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tmax = max( max( t1.x, t1.y ), t1.z );\n\tfloat tmin = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tmax > tmin || tmin < 0.0) return vec2(INFINI, 0.);\n\n    norm = -sign(ray)*step(vec3(tmax),t1);\n    \n    /********************************** AA process ******************************/\n    /*** visual outside contour ***/\n    // (tmin-tmax) represents the depth reach by the ray into the shape. \n    // larger is the diff between tmax and tmin, deeper into the shape goes the ray\n    // when d is small (<1), we use it as a transparency factor\n    //\n    // As the cube surface is flat and has no thickness (no transparency factor can be used when thickness = 0)\n    // we must apply a correction (corr) when visual angle is flat to emphasis the AA effect.\n    float corr = dot(ray,-norm);\n    corr = (.05+corr)*(1.2-corr*corr*corr);\n    float d = (tmin-tmax)*iResolution.x*corr;\n    \n    #ifdef SPLIT\n    if(gl_FragCoord.x > iResolution.x/2.+2.) return vec2(tmax, d);\n    #endif\n    \n    /*** inside the visual border's shape, where 2 faces connect (crest). ***/\n    // normals must be rotated progressively from one face to the other\n    // so the shading of each face are mixed when distance to the crest is small\n    // half way rotation is done (other half way is done when other face is hit)\n    t1 *= 1.-step(vec3(tmax),t1);\n    float tmed = max( max( t1.x, t1.y ), t1.z );\t// finding 2nd closest hit\n    vec3 norMed = -sign(ray)*step(vec3(tmed),t1);\t// normal of the adjacent face\n    corr = dot(ray,-norMed);\n    corr = (.05+corr)*(1.2-corr*corr*corr);\t\t\t// flat angle correction\n    norm = mix(norMed, norm, .5*min(1.,.5*(tmax-tmed)*corr*iResolution.x/tmax)+.5);\t// mixing the 2 normals\n    \n    d = max(0.,d);\n    return vec2(tmax, d);\n}\n\n// finished cone figure with bottom cap\nvec2 coneImpact(in vec3 pos, in vec3 ray, in vec3 O, in float H, in float R, inout vec3 norm){\n    vec3 tt = vec3(INFINI);\n    float t = INFINI;\n    float tmin,tmed,tmax;\n    vec3 normy = vec3(0.,-1.,0.);\n    float dmin = 0.;\n    vec3 d = O - pos;\n    float Dy = H + d.y;\n    float r2 = R*R/(H*H);\n    float a = dot(ray.xz,ray.xz) - r2*ray.y*ray.y;\n    float b = -dot(d.xz, ray.xz) + r2*Dy*ray.y;\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float disc = b*b - a*c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        tt.xy = (-b + vec2(sqdis,-sqdis))/a;\t\t// cone intercept\n        if(abs(ray.y) > 0.01) tt.z = d.y/ray.y;\t\t// bottom intercept\n        tt += step(tt,vec3(0.))*INFINI; \t\t\t// eliminate neg values\n\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t/*** AA process ***/\n        tmax = max(max(tt.x,tt.y),tt.z);\t\t\t\t// sort all tt (tmin, tmed, tmax)\n        tmin = min(min(tt.x,tt.y),tt.z);\t\t\t\t// needed for AA\n        vec3 ttemp = step(tt, vec3(tmin))*INFINI + tt;\t//\n    \ttmed = min(min(ttemp.x,ttemp.y),ttemp.z);\t\t//\n        \n        vec2 ofc = Dy - ray.y*tt.xy;\t\t\t\t\t\t// checking upper-lower bounary of the cone\n        tt.xy *= step(vec2(0.),ofc)*step(ofc,vec2(H));\n        tt.xy += step(tt.xy,vec2(0.))*INFINI;\t\t\t\t// eliminate outboud interception of cone\n        \n        tt.z += step(R,length(d.xz-tt.z*ray.xz))*INFINI;\t// eliminate outboud interception of bottom \n        \n        t = min(min(tt.x,tt.y),tt.z);\n        vec3 p = pos+t*ray;\n        \n        /********************************** AA process ******************************/\n        // 2 situations to deal with, depending on cone or bottom hit.\n        if(t != tt.z){\t\t// not bottom, so... cone surface\n        \tnorm = normalize(vec3(p.x-O.x, R*R/(H*H)*(H+O.y-p.y), p.z-O.z));\n            \n            // depth reached by the ray must be consider on the side of the cone or at the connection with the bottom cap\n            // we keep the min.\n            dmin = min( abs(disc/a)/(ofc.y*R/H),\t// distance inside a cone (by the sides)\n                       .5*(tt.z-t) )*iResolution.x;\t// distance at the border of the bottom cut\n            \n            #ifdef SPLIT\n    \t\tif(gl_FragCoord.x < iResolution.x/2.) \n            #endif\n            // mixing the cone and the bottom normals to anti-aliase the crest created by the junction of the two faces.\n            if(tt.x != INFINI) norm = mix(normy, norm, .5*min(1.,.25*abs(tmed-tmin)*iResolution.x/TH)+.5);\n        }\n        else{\t// bottom hit\n            norm = normy;\n            float corr = dot(ray,-norm);\n    \t\tcorr = (.05+corr)*(1.7-corr*corr*corr);\t\t// here we add correction (same issue as the cube flat surface)\n            dmin = .5*(tt.x-t)*corr*iResolution.x;\t\t// depth reach when entering by the bottom (exiting the blind face of the cone)\n            #ifdef SPLIT\n    \t\tif(gl_FragCoord.x < iResolution.x/2.) \n            #endif\n            // finallly, anti-aliase the crest created by the junction of the bottom with the cone.\n            // mixing normals with the bottom and the cone surface.\n            if(tt.x != INFINI) norm = mix( normalize(vec3(pos.x+tmed*ray.x-O.x, 0., pos.z+tmed*ray.z-O.z)) , norm, .5*min(1.,abs(tmed-tmin)*iResolution.x/t)+.5);\n        }\n    }\n    dmin = max(0.,dmin);\n\treturn vec2(t,dmin);\n}\n\n\n/****************************  AA process  ***************************/\n\nvoid setParam(in vec2 i, in int objID, in vec3 norm, in vec3 ray, inout Type_Param STD, inout Type_Param AA){\n    \n    // The setParam() function fills the standard parameters for ray tracing (t, norm, objID) + max depth reach by ray\n    // it fills also the AntiAliasing parameters AA.\n    // AA contains same parameters as STD ones but for the object immediatly behind \n    \n    if(i.x<STD.t){\n        // a closer object is found, the previous object is stored in AA param\n        // the new closest one in STD param\n        AA = STD;\n        float corr = max(.001,dot(ray,-norm));\n        corr = (.05+corr)*(1.7-corr*corr*corr);\n        STD.d = min( (STD.t-i.x)*iResolution.x     *corr,// flat angle correction\n                   \t  i.y);\n        STD.t = i.x;\n    \tSTD.hit = objID;\n        STD.n = norm;\n    }\n    else if(i.x<AA.t){\n        // No closest object hit but closest background one\n        // AA must be updated\n        AA.hit = objID;\n        AA.t = i.x;\n        AA.n = norm;\n    }\n}\n\nvoid trace(in vec3 pos, in vec3 ray, inout Type_Param STD, inout Type_Param AA){\n    // Raytrace all objects\n    // i keep the returned information\n    // i.x is t\n    // i.y is d the max depth reach by ray\n    // The setParam function fills the STD parameters and the AA parameters\n    vec3 norm = vec3(0.);\n    vec2 i;\n    \n    i = boxImpact(pos, ray, boxO, boxD, norm);\n    setParam(i, BOX, norm, ray, STD, AA);\n    \n    i = coneImpact(pos, ray, conO, conH, conR, norm);\n    setParam(i, CONE, norm, ray, STD, AA);\n    \n    i = sphereImpact(pos,ray,spO,spR, norm);\n    setParam(i, SPH, norm, ray, STD, AA);\n    \n    i = cylinderImpact(pos.yz, ray.yz, cyO, cyR, norm.yz);\n    setParam(i, XCYL, vec3(0.,norm.yz), ray, STD, AA);\n    \n    i = cylinderImpact(pos.xy, ray.xy, cyO, cyR, norm.xy);\n    setParam(i, ZCYL, vec3(norm.xy,0.), ray, STD, AA);\n}\n\n// simplified raytrace for shadow\nfloat shadowTrace(in vec3 pos, in vec3 ray){\n    \n    vec3 norm = vec3(0.);\n    vec2 i;\n    float shadow = 0., t = INFINI;\n    \n    // i.y is the depth reach by the ray.\n\t// Depth is used to smooth the shadow.\n    // From all encountered object, the deeper (biggest i.y) value is kept.\n\n    i = boxImpact(pos, ray, boxO, boxD, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = coneImpact(pos, ray, conO, conH, conR, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n\t\n    i = sphereImpact(pos,ray,spO,spR, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = cylinderImpact(pos.yz, ray.yz, cyO, cyR, norm.yz);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = cylinderImpact(pos.xy, ray.xy, cyO, cyR, norm.xy);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    \n    #ifdef SPLIT\n    if(gl_FragCoord.x < iResolution.x/2.)\n    #endif\n    \n    shadow /= max(20.,t*SH*iResolution.x);\t// expanding same way as anti-aliasing\n    \n    return min(1.,shadow);\n}\n\nvoid setColor(inout vec3 color, in vec3 pos, in vec3 ray, in vec3 light, in Type_Param PARAM){\n    // Set color to the front object...\n    \n    #ifdef ACTIVATE_TEXTURE\n    vec3 p = pos+PARAM.t*ray;\n    if(PARAM.hit == SKY) return;\n    else if(PARAM.hit == SPH) \n        color = .7*spCol+.3*texture(iChannel0,vec2(atan(p.x,p.z),asin(p.y-spO.y))).rgb;\n    else if(PARAM.hit == XCYL)\n        color = cyCol*(1.- min(vec3(.2),texture(iChannel0, vec2(.5*p.x,atan(p.y,p.z))).rgb));\n    else if(PARAM.hit == ZCYL)\n        color = cyCol*(1.-min(vec3(.2),texture(iChannel0, vec2(.5*p.z,atan(p.x,p.y))).rgb));\n    else if(PARAM.hit == BOX)\n        color = boxCol*texture(iChannel2,vec2(p.x+p.z,p.y+p.x)).rgb;\n    else if(PARAM.hit == CONE)\n        color = .5*(conCol*texture(iChannel3,vec2(.15*atan(p.x-conO.x,p.z-conO.z),p.y)).rgb);\n    \n    #else\n    if(PARAM.hit == SKY) return;\n    else if(PARAM.hit == SPH)  color = spCol;\n    else if(PARAM.hit == XCYL) color = cyCol;\n    else if(PARAM.hit == ZCYL) color = cyCol;\n    else if(PARAM.hit == BOX)  color = boxCol;\n    else if(PARAM.hit == CONE) color = conCol;\n    #endif\n        \n    color *= max(0.,dot(light,PARAM.n));\t\t// light shading\n}\n\nfloat backGround(in vec3 light, in vec3 ray){\t// background lighting\n    float lit = .5*dot(light,ray)+.5;\n    return .5*lit*lit+smoothstep(.99,1.,lit);\n}\n\nvec3 smoothReflect(in vec3 pos, in vec3 ray, in vec3 light, in Type_Param PARAM, in bool Noticeable, in vec3 stepOut){\n    vec3 col = vec3(0.);\n    vec3 p = pos + PARAM.t * ray + stepOut;\t// a little step back to avoid black dithering\n    vec3 refl = reflect(ray,PARAM.n);\n    float bkg = backGround(light,refl);\n    vec3 reflCol = vec3(bkg);\n    vec3 reflColAA = vec3(bkg);\n\n    Type_Param RFL = Type_Param(INFINI, SKY, vec3(0.), 1.);\n    Type_Param RFLAA = Type_Param(INFINI, SKY, vec3(0.), 1.);\n\n    trace(p, refl, RFL, RFLAA);\n    setColor(reflCol, p, refl, light, RFL);\n    setColor(reflColAA, p, refl, light, RFLAA);\n\n    \n    /*** shadow of reflection ***/\n    \n    // the reflection can be under shadow\n    // so we have to extend the ray... only if noticeable!\n    if(Noticeable){\n        if(RFL.t<INFINI){\n            vec3 p2 = p + RFL.t * refl + .001*(RFL.n+RFLAA.n);\n            float shad = shadowTrace(p2, light);\n            reflCol *= 1.-SC*shad;\n        }\n        if(RFLAA.t<INFINI){\n            vec3 p2 = p + RFLAA.t * refl + .01*(RFL.n+RFLAA.n);\n            float shad = shadowTrace(p2, light);\n            reflColAA *= 1.-SC*shad;\n        }\n    }\n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef SPLIT\n    /**/ if(gl_FragCoord.x > iResolution.x/2.) col = RC*reflCol;\n    /**/ else \n    /**/ #endif    \n    /*************************************************************************/\n    \n    col = RC*(reflCol*min(1.,RFL.d/(RFL.t+PARAM.t)/RF) + reflColAA*max(0.,(1.-RFL.d/(RFL.t+PARAM.t)/RF)));\n\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // camera def\n    vec3 camTarget = vec3(0.);\n    vec3 pos = getCamPos(camTarget);\n    vec3 ray = getRay(st, pos,camTarget);\n    \n    vec3 light = normalize(vec3(sin(iTime*.1),.3,cos(iTime*.1)));\n    float bg = backGround(light, ray);// background color\n    vec3 color = vec3(0.);\n    vec3 col = vec3(bg), \tcolAA = vec3(bg);\n    \n    // standard raytrace params (usually used)\n    Type_Param STD = Type_Param(\tINFINI,\t\t// distance to hit: t\n                      \t\t\t\tSKY,\t\t// hit object ID: hit\n                      \t\t\t\tvec3(0.),\t// normal of surface object: n\n                      \t\t\t\t1.\t\t\t// Max depth reach by the ray inside the object: d\n                     \t\t\t);\n    \n    // first order anti-aliasing params\n    Type_Param AA = Type_Param(\t\tINFINI,\t\t// distance to hit: t\n                      \t\t\t\tSKY,\t\t// hit object: hit\n                      \t\t\t\tvec3(0.),\t// normal of surface object: n\n                      \t\t\t\t1.\t\t\t// not used in AA\n                     \t\t\t);\n\n    /***********************  Main process ************************/\n    \n    trace(pos, ray, STD, AA);\n    setColor(col, pos, ray, light, STD); \t\t// Set color to the front object...\n    setColor(colAA, pos, ray, light, AA);\t\t//...and to the first background object (1st order AA)\n    \n    \n\n    /*----------------  All the following (till the dashed line below) -------------*/\t\t\t\t\t \n\t/*\t\t\t\tare visual options. not necessary to understand process         */\n\t/*------------------------------------------------------------------------------*/\n\n    /**************************  Shadow  ***************************/\n    \n    // soft shadow = big anti-aliasing on shadow\n    #ifdef ACTIVATE_SHADOW\n    if(STD.t<INFINI){\n    \tvec3 p = pos + STD.t * ray + .001*(STD.n+AA.n);\t// adding a little step-out\n        float shad = shadowTrace(p, light);\n        col *= 1.-SC*shad;\n    }\n\tif(AA.t<INFINI){\n    \tvec3 p = pos + AA.t * ray + .01*(STD.n+AA.n);\n        float shad = shadowTrace(p, light);\n        colAA *= 1.-SC*shad;\n    }\n    #endif\n    \n    /**************************  reflection  ************************/\n    \n    // reflections are anti-aliased too\n    #ifdef ACTIVATE_REFLECT\n    if(STD.t<INFINI) col += smoothReflect(pos, ray, light, STD, true, .001*(STD.n+AA.n));\t// last parameter used for a little step-out\n    if(AA.t<INFINI) colAA += smoothReflect(pos, ray, light, AA, false, .01*(STD.n+AA.n));\t// to avoid black dithering\n    #endif\n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef AA_AREA\n    /**/ if(STD.hit == BOX){\n    /**/ \t if(floor(abs(STD.n)) == vec3(0.)) col = AREAcol;\n    /**/ }\n    /**/ else if(STD.hit == CONE){\n\t/**/\t if(STD.n.y/length(STD.n.xz)+.001 < conR/conH && STD.n.y != -1.) col = AREAcol;\n    /**/ }\n    /**/ colAA += float(STD.hit != SKY)*AREAcol;\t\t// make visible the AA area involved\n    /**/ #endif\n\t/************************************************************************/\n    \n    /*-----------------------------------------------------------------------------------*/\n    /*\t\t\t\t\t\t\t\t\t end of options \t\t\t\t\t\t\t\t */\n    /*-----------------------------------------------------------------------------------*/\n    \n    \n    float blur = max(1.,.2*STD.t);\t// far distance blur (using enhanced AA depending on distance)\n    \n    // Finally, mix the color of front and background object\n    // depending on ray depth inside the front object (STD.d)\n    color = col*min(1.,STD.d/STD.t/TH/blur) + colAA*max(0.,(1.-STD.d/STD.t/TH/blur));\n\n    \n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef SPLIT\n    /**/ if(gl_FragCoord.x < iResolution.x/2.) color = col*min(1.,STD.d/STD.t/TH/blur) + colAA*max(0.,(1.-STD.d/STD.t/TH/blur));\n    /**/ else if(gl_FragCoord.x > iResolution.x/2.+2.) color = col;\n    /**/ else color = vec3(0.995,0.829,0.006);\n    /**/ #endif\n\t/************************************************************************/\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4109, 4184, 4218, 4218, 4824], [4826, 4826, 4882, 4882, 5107], [5110, 5186, 5271, 5271, 6083], [6085, 6085, 6170, 6170, 6584], [6587, 6587, 6672, 6672, 8537], [8539, 8579, 8673, 8673, 11832], [11835, 11908, 12017, 12279, 12906], [12908, 12908, 12988, 13190, 13756], [13758, 13792, 13836, 13836, 14870], [14872, 14872, 14966, 15006, 16055], [16057, 16057, 16102, 16125, 16211], [16213, 16213, 16331, 16331, 17794], [17797, 17797, 17851, 17851, 21936]]}
{"id": "ldyyRD", "name": "Green Hills (Raymarch)", "author": "Isaac175", "description": "This is my first GLSL shader ever, so I don't really know if it's working right or not :\\ Anyway, hope you enjoy! Btw, It'd be great if you could help me clean up my code. Thanks!", "tags": ["raymarch", "laggy", "firstpost"], "likes": 2, "viewed": 91, "published": "Public", "date": "1521175491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Name: Kinda Failed Raymarcher?\n// (c) Isaac C. 2018. (you can use any functions here, just do something different with them)\n\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define PI 3.14159265358979\n#define ACCELI 4.\n#define ELI 4.\n#define QUALITY 16\n\n// 1/(1+2^x)\n//--------------------------------------------------\n// hash function\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)),\n                   dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n//--------------------------------------------------\n// iqnoise //original algorithm by ÃÃ±igo QuÃ­lez\nfloat iqnoise( in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    float k = 1.;\n    float va = 0.0;\n    float wt = 0.0;\n    for (int j=-2; j<=2; j++) {\n        for (int i=-2; i<=2; i++) {\n            float ww = pow( 1.0-smoothstep(0.0,1.414,\n                    sqrt(dot(vec2(float(i),float(j)) - f +\n                   hash3(p + vec2(float(i),float(j))).xy,\n                             vec2(float(i),float(j)) - f +\n                   hash3(p + vec2(float(i),float(j))).xy))), k );\n            va +=  hash3(p + vec2(float(i),float(j))).z*ww;\n            wt += ww;\n        }\n    }\n    return va/wt;\n}\n//--------------------------------------------------\n//fbm\nfloat fbm (in vec2 x) {\n\tfloat f = 0.;\n    float w = .5;\n    for (int i=0; i<5; i++) {\n        f += w*iqnoise(x*1.5/*+u_time*/); x *= 2.05;\n        w *= .5;\n    }\n    return f;\n}\n//--------------------------------------------------\n// sdSphere\nfloat sdSphere(in vec3 p, in float size)\n{\n  return length(p)-size;\n}\n//--------------------------------------------------\n// sdNoisePlane\n// The part that generates the texture for the plane\nfloat sdPlaneN(in vec3 p, in float height, in float nHeight, in vec2 nSeed) {\n    return p.z-((fbm(vec2(p/*+u_time/5.*/))*nHeight)+height);\n\t// p.x+0./*u_time/*nSeed.x*/,p.y+u_time/10./*nSeed.y*/\n}\n// The way this works is interesting\n// it checks whether or not it is within range of the texture,\n// and if it is, it then returns the texture height\nfloat sdPlane(in vec3 p, in float height, in float nHeight, in vec2 nSeed) {\n    if (0.>p.z-(height+nHeight)) {\n        return sdPlaneN(p,height,nHeight, nSeed);\n    }\n    return p.z-(height+nHeight);\n}\n//--------------------------------------------------\n// converting radian trig functions to degrees\n// sin\nfloat degSin(in float x) {\n    return sin(x*PI/180.);\n}\n// cos\nfloat degCos(in float x) {\n    return cos(x*PI/180.);\n}\n//--------------------------------------------------\n// sigmoid\nfloat sigmoid(in float x) {\n    return 2./(1.+pow(1.05,x));\n}\n//--------------------------------------------------\n// cast ray\nfloat castRay(in vec3 cam, in vec2 uv) {\n    float distance = 0.; // distance from the camera\n    float radius = 0.; // distance from nearest shape\n    float oRadius = radius;\n    vec3 p = cam;\n    uv = uv*2.-2.; // adjusting the viewing fulcrum\n    vec3 mult = vec3(degSin(uv.x), // finding out the slope rates\n                     degCos(uv.x),\n                     degSin(uv.y));\n    for (int i = 0; i < QUALITY; i++) {\n        oRadius = radius;\n        radius = sdPlane(p,-2.,1.,vec2(0.,0.)); // finding the distance to the plane\n        if (radius < 0.) {\n            for (int j = 0; j < 1; j++) {\n                oRadius = abs(oRadius) * .5;\n                radius = sdPlane(p,-2.,1.,vec2(0.,0.)); // finding the distance to the plane\n                if (radius < 0.) {\n                    oRadius *= -1.;\n                }\n                distance += oRadius; // getting closer to 0\n                p = cam+(mult*distance); // moving the point\n                if (abs(radius) < ACCELI) {\n                    //return 1.-float(i+j)/float(QUALITY);\n                    return sigmoid(distance); // returns more 'exact' distance\n                }\n            }\n            //return 1.-float(i+8)/float(QUALITY);\n        \treturn sigmoid(distance);\n        }\n\t\t    if (radius < ELI) {\n            radius = ELI;\n        }\n        distance += radius;\n        p = cam+(mult*distance);\n    }\n\treturn 0.;\n}\n//--------------------------------------------------\n// main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = ((iMouse.xy/iResolution.xy)-1.)*2.;\n    st = vec2(st.x,st.y/1.5);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tfloat x = castRay(vec3(st.x,iTime/10.,st.y+.15),uv);\n    //x = fbm(uv);\n    fragColor = vec4(0.,x,x/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 336, 358, 358, 534], [535, 639, 666, 666, 1252], [1253, 1312, 1335, 1335, 1490], [1491, 1556, 1598, 1598, 1625], [1626, 1748, 1825, 1825, 1945], [1946, 2098, 2174, 2174, 2300], [2301, 2408, 2434, 2434, 2463], [2464, 2471, 2497, 2497, 2526], [2527, 2591, 2618, 2618, 2652], [2653, 2718, 2758, 2758, 4121], [4122, 4188, 4245, 4295, 4530]]}
{"id": "ldyyWD", "name": "Wispy Fog City", "author": "Carandiru", "description": "variant of original glow city", "tags": ["fog", "city"], "likes": 14, "viewed": 337, "published": "Public", "date": "1522002403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Grid marching from iq's Grid of Cylinders\n// https://www.shadertoy.com/view/4dSGW1\n\nconst float streetDistance = 0.6;\nconst vec3 streetColor = vec3(4.0, 4.0, 4.0);\n\nconst float fogDensity = 0.5;\n//const float fogDistance = 4.0;\nconst vec3 fogColor = vec3(0.5, 0.5, 0.5);\n\nconst float windowSize = 0.1;\nconst float windowDivergence = 0.2;\nconst vec3 windowColor = vec3(0.3, 0.3, 0.3);\n\nconst float beaconProb = 0.0003;\nconst float beaconFreq = 0.6;\nconst vec3 beaconColor = vec3(1.5, 0.2, 0.0);\n\nconst float c = 0.5f;\nconst float b = 0.5f;\n\nconst float tau = 6.283185;\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p2) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p2.x));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash2(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p2) {\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 castRay(vec3 eye, vec3 ray) {\n    vec2 block = floor(eye.xy);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 side = 0.5 + 0.5 * rs;\n    vec2 ris = ri.xy * rs.xy;\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\n    \n    float beacon = 0.0;\n    \n    for (int i = 0; i < 200; ++i) {\n        vec2 lo0 = vec2(block + 0.01);\n        vec2 loX = vec2(0.1, 0.1);\n        vec2 hi0 = vec2(block + 0.69);\n        vec2 hiX = vec2(0.4, 0.4);\n        float height = (0.5 + hash1(block)) * (2.0 + 4.0 * pow(noise1(0.1 * block), 2.5));\n        \n        float dist = 500.0;\n        float face = 0.0;\n        for (int j = 0; j < 3; ++j) {\n            float top = height * (1.0 - 0.1 * float(j));\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), 0.0);\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);            \n            float maxT = dot(dim, t);\n            float maxFace = 1.0 - dim.z;\n            \n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n        \n        float prob = beaconProb * pow(height, 3.0);\n        vec2 h = hash2(block);\n        if (h.x < prob) {\n            vec3 center = vec3(block + 0.5, height + 0.2);\n            float t = dot(center - eye, ray);\n            if (t < dist) {\n                vec3 p = eye + t * ray;\n               // float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n               // fog = exp(fogDensity * fog);\n\n                t = distance(center, p);\n                //fog *= smoothstep(1.0, 0.5, cos(tau * (beaconFreq * iTime + h.y)));\n                //beacon += fog * pow(clamp(1.0 - 2.0 * t, 0.0, 1.0), 4.0);\n            }\n        }\n        \n        if (dist < 400.0) {\n            return vec4(dist, beacon, face, 1.0);\n        }\n\n        float t = eye.z * ri.z;\n        vec3 p = eye - t * ray;\n        vec2 g = p.xy - block;\n        if (g.x > 0.0 && g.x < 1.0 && g.y > 0.0 && g.y < 1.0) {\n            return vec4(-t, beacon, 0.0, 1.0);\n        }\n        \n        vec2 dim = step(dis.xy, dis.yx); \n        dis += dim * ris;\n        block += dim * rs.xy;\n    }\n    \n    if (ray.z < 0.0) {\n        return vec4(-eye.z * ri.z, beacon, 0.0, 1.0);\n    }\n\n    return vec4(0.0, beacon, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 m = vec2(0.66f, 0.33);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= tau * vec2(1.0, 0.25);\n    \n    vec3 center = vec3(0.5, 0.5 * iTime, 3.0);\n    float dist = 15.0;\n    vec3 eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    float zoom = 4.0;\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    zoom *= iResolution.y;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    vec4 res = castRay(eye, ray);\n    if (res.w < 0.5) {\n        fragColor = vec4(fogColor + res.y * beaconColor, 1.0);\n        return;\n    }\n    \n    vec3 p = eye + res.x * ray;\n\n    vec2 block = floor(p.xy);\n    vec3 window = floor(p / windowSize);\n    float x = hash1(block, window.x);\n    float y = hash1(block, window.y);\n    float z = hash1(block, window.z);\n    vec3 color = windowColor + windowDivergence * (hash3(block) - 0.5);\n    color *= smoothstep(0.1, 0.9, fract(2.5 * (x * y * z)));\n    color += streetColor * exp(-p.z / streetDistance);\n\n    //vec3 buildingColor = vec3(0.1f, 0.1f, 0.1f);\n    vec3 level = 0.25 * streetColor * exp(-4.0 * p.z / streetColor);\n    color = clamp(mix(level, color, res.z), 0.0, 1.0);\n        \n    float fogDistance = max(1.0f, 4.6f * sin(p.z + iTime*1.1)) \n        \t\t\t    * noise1(p.xy) + distance(p, eye) * 1.0;\n    \n    fogDistance += max(1.0f, 5.6f * sin(p.y + iTime*1.5)) \n        \t\t\t    * noise1(p.xy) + distance(p, eye) * 1.0;\n    \n    fogDistance *= 0.5f;\n    \n    //float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;\n    \n    \n    float fog = 0.8f * exp(-eye.z*0.1f) * (1.0-exp( -fogDistance*ray.z*0.1f ))/ray.z;\n   \n    \n   // fog = exp(fogDensity*0.005f * fog);\n    \n    \n   // vec3  fogColor  = vec3(0.5,0.6,0.7);\n   // return mix( rgb, fogColor, fogAmount );\n    \n    color = mix(color, fogColor, fog);\n\n    color += res.y * beaconColor;\n    color += pow(res.y, 2.0);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 572, 594, 594, 734], [736, 736, 767, 767, 913], [915, 915, 936, 936, 1088], [1090, 1090, 1120, 1120, 1269], [1271, 1271, 1292, 1292, 1441], [1443, 1443, 1465, 1465, 1755], [1757, 1757, 1791, 1791, 4301], [4303, 4303, 4358, 4358, 6472]]}
{"id": "ls3cWs", "name": "Forest Temple", "author": "Flopine", "description": "J-22 !", "tags": ["raymarching", "modulo", "shapes", "zeldainspiration"], "likes": 5, "viewed": 221, "published": "Public", "date": "1520548826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and leon for teaching me! :)\n\n\n#define ITER 80.\n#define PI 3.141592\n#define TAU 2.*PI\n\n/////////////////// UTILITIES\nmat2 rot (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2 (c,s,-s,c);\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// iq's palette\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n/////////////////// PRIMARY SHAPES\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat cylY (vec3 p, float r)\n{\n    return length(p.xz)-r;\n}\n\n/////////////////// PRIMITIVES\nfloat prim1(vec3 p)\n{\n    p.yz *= rot(PI/2.);\n    return max(-sphe(vec3(p.x,p.y,p.z*0.9),1.06),sdHexPrism (p, vec2 (1.,0.5)));\n}\n\nfloat prim2 (vec3 p)\n{\n    p.xz *= rot(iTime+p.y);\n    p.xz = moda(p.xz, TAU/6.);\n    p.x -= .6;\n\n    return cylY(p,.1);\n}\n\nfloat gear1 (vec3 p, float per)\n{\n\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    p.xz *= rot(iTime);\n    return prim1(p);\n}\n\nfloat gear2 (vec3 p, float per)\n{\n    p.y -= per/2.;\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    p.xz *= rot(-iTime);\n    return prim1(p);\n}\n\nfloat pattern (vec3 p)\n{\n   return min(gear2(p,4.),min(gear1(p, 4.),prim2(p)));  \n}\n\n\n//////////////////// Raymarching field\nfloat SDF (vec3 p)\n{\n    float per = 2.;\n    \n    p.xy *= rot(iTime*0.3+(p.z*0.2));\n    p.z = mod(p.z-per/2.,per)-per/2.;\n    p.xy = moda(p.xy, TAU/4.);\n    p.x -= 4.;\n   return pattern(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.001,0.001,iTime);\n    vec3 dir = normalize(vec3 (uv*2.,1.));\n    \n    float shad = 0.;\n    vec3 col = vec3 (0.);\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            col = vec3(1.-shad)*palette(dir.z,\n                          vec3 (0.,0.5,0.),\n                          vec3 (0.,0.2,0.1),\n                          vec3 (0.2),\n                          vec3(iTime*0.3));;\n            break;\n        }\n\n        p+=d*dir*0.7;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3cWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 156, 176, 176, 250], [252, 252, 283, 283, 408], [410, 426, 498, 498, 541], [543, 578, 614, 614, 698], [700, 700, 730, 730, 756], [758, 758, 788, 788, 817], [819, 850, 871, 871, 978], [980, 980, 1002, 1002, 1102], [1104, 1104, 1137, 1137, 1223], [1225, 1225, 1258, 1258, 1363], [1365, 1365, 1389, 1389, 1448], [1451, 1490, 1510, 1510, 1681], [1683, 1683, 1740, 1790, 2500]]}
{"id": "lsccWX", "name": "egg", "author": "kaminate", "description": "egg for eric", "tags": ["egg"], "likes": 0, "viewed": 87, "published": "Public", "date": "1520375316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO\n// - switch everything to quadrance ( no radius )\n// - experiment with giving each yolk a differnet color\n//   and blending between them with a weighted sum\n// - Use more interesting movement functions\n//   ( think loading icon )\n\nvec2 uv;\nfloat ness;\nvec3 color;\n\nvec3 colorYolk = vec3( 0.0, 0.6, 0.5 );\nvec3 colorShell = vec3( 0.3, 0.4, 0.0 );\n\nstruct Circle\n{\n    vec2 origin;\n    float radius;\n};\n    \n    \nfloat square( float f )\n{\n    return f * f;\n}\n    \nfloat vec2quadrance( vec2 a, vec2 b )\n{\n    float dx = a.x - b.x;\n    float dy = a.y - b.y;\n    return square( dx ) + square( dy );\n}\n\nvoid DrawCircle( Circle circle )\n{\n    vec2 circleOrigin = circle.origin;\n    float radius = circle.radius;\n    float curPixelToPoint = distance( uv, circleOrigin );\n    \n\tness += square( radius ) /  vec2quadrance( uv, circleOrigin );\n    \n    if( abs( curPixelToPoint - radius ) < 0.005 )\n    {\n\t\tcolor = colorYolk;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = ( ( ( fragCoord / iResolution.xy ) * 2.0 ) - 1.0 );\n    uv.x *= iResolution.x / iResolution.y;\n    \n    Circle c0;\n    c0.origin = vec2( sin( iTime ), 0.5 * cos( iTime ) );\n    c0.radius = 0.2;\n    DrawCircle( c0 );\n    \n    Circle c1;\n    c1.origin = vec2( sin( iTime * 1.1 ), 0 );\n    c1.radius = 0.4;\n    DrawCircle( c1 );\n\n\tCircle c2;\n    c2.origin = vec2( 0, 0.1 * sin( iTime * 0.9 ) );\n    c2.radius = 0.3;\n    DrawCircle( c2 );\n    \n    color += colorShell * smoothstep( 0.8, 0.9, ness );\n    fragColor = vec4( color, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsccWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 419, 444, 444, 464], [470, 470, 509, 509, 603], [605, 605, 639, 639, 929], [931, 931, 988, 988, 1529]]}
{"id": "lsGcDz", "name": "Voroblob!", "author": "metabog", "description": "Just messing around.", "tags": ["raymarching", "voronoi", "audio"], "likes": 5, "viewed": 113, "published": "Public", "date": "1521592704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\nconst int MAX_ITER = 100; \nconst float MAX_DIST = 150.0; \nconst float EPSILON = 0.01;\nvec3 lightPosition1 = vec3(20.0,10.0,100.0);\nvec3 lightPosition2 = vec3(-200.0,100.0,-100.0);\n\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\n//voronoi seeds\nvec3 pointgen(uint i)\n{\n    vec3 nice;\n    nice.x += cos(iTime+wang(i+3u)*3.14f*2.0f);\n    nice.y += sin(iTime+wang(i)*3.14f*2.0f);\n    nice.z += cos(iTime+wang(i+5u)*3.14f*2.0f);\n    return normalize(2.0f*nice);\n}\n\n#define MAXPOINTS 32u\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat distfunc(vec3 pos, float ampenv)\n{    \n    float mainrad = 7.0;\n    float val = sphere(pos,mainrad);\n    \n    for(uint j = 0u; j<MAXPOINTS; j++)\n    {\n        vec3 vpos = pointgen(j)*ampenv*25.0;\n        vpos*=mainrad;  \n        val = smin(val,sphere(vpos-pos,0.4),0.9);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 startPoint = vec3(cos(iTime*0.25)*15.0f, 0.0, sin(iTime*0.25)*15.0f);\n    vec3 cameraDir = normalize(cameraTarget - startPoint);\n\tvec3 cameraRight = normalize(cross(upDirection, startPoint));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    //amplitude envelope\n    float audioEnvelope = (texture(iChannel0, vec2(iChannelTime[1],0.0))).x;\n   \tint c =0;\n  \tfor(float k = 0.0; k<0.02; k+=0.001)\n    {\n    \tc++;\n    \tfloat val = abs((texture(iChannel2, vec2(iChannelTime[1]+k,0.0))).x);\n    \taudioEnvelope+=  val*val;\n    }\n    \n    audioEnvelope = audioEnvelope/float(c);\n    \n    float totalDist = 0.0;\n\tvec3 pos = startPoint;\n\tfloat dist = EPSILON;\n    \n  \tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv*=0.5; //FOV\n    uv.x*= iResolution.x /iResolution.y;\n    \n    uv*= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * (uv.y) + cameraDir);\n    \n    for (int i = 0; i < MAX_ITER; i++)\n\t{\n    \n    if (dist < EPSILON || totalDist > MAX_DIST)\n        break; \n\n    \tdist = distfunc(pos,audioEnvelope); \n    \ttotalDist += dist;\n    \tpos += dist * rayDir; \n\t}\n    \n\tif (dist < EPSILON)\n\t{\n    \tvec2 eps = vec2(0.0, EPSILON);\n                    \n\t\t//VORONOI!\n    \tuint minknn = MAXPOINTS;\n   \t\tfloat minval = 100000.0;\n        \n        for(uint j = 0u; j<MAXPOINTS; j++)\n    \t{\n        \tvec3 vpos = pointgen(j)*audioEnvelope*25.0;\n            vpos*=7.0f;\n            \n        \tfloat len = length(vpos-pos);\n        \tif(len<minval)\n        \t{\n        \t    minval = len;\n        \t    minknn = j;\n        \t}\n    \t}\n        \n        vec3 normal_voronoi = pointgen(minknn) + cos(minval*3.0)*1.5*audioEnvelope;\n        \n\t\tvec3 normal = normalize(vec3(\n    \tdistfunc(pos + eps.yxx,audioEnvelope) - distfunc(pos - eps.yxx,audioEnvelope),\n   \t\tdistfunc(pos + eps.xyx,audioEnvelope) - distfunc(pos - eps.xyx,audioEnvelope),\n   \t\tdistfunc(pos + eps.xxy,audioEnvelope) - distfunc(pos - eps.xxy,audioEnvelope)));\n        \n        normal += normal_voronoi;\n        \n        vec3 lightVec1 = normalize(pos - lightPosition1);\n        vec3 lightVec2 = normalize(pos - lightPosition2);\n        \n   \t\tvec3 diffuse = vec3(0.0); \n        float redLight = max(0.0, dot(-lightVec1, normal))*0.5;\n        float blueLight = max(0.0, dot(-lightVec2, normal))*0.5;\n        diffuse += vec3(redLight*1.0,0.7*redLight,0.9*redLight);\n        diffuse += vec3(blueLight*0.3,blueLight*0.6,blueLight*0.73);\n        diffuse += vec3(0.2,0.2,0.2); //ambient\n        float specular1 = pow(redLight, 16.0);\n        float specular2 = pow(blueLight, 16.0);\n\n\t\tfragColor = vec4(diffuse+specular1+specular2, 1.0);\n\t}\n\telse\n\t{\n\t\t\tfragColor = vec4(1.0);\n\t}\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 283, 283, 543], [545, 561, 584, 584, 775], [800, 800, 841, 841, 912], [914, 914, 952, 952, 987], [989, 989, 1029, 1029, 1289], [1291, 1291, 1348, 1348, 4036]]}
{"id": "lsGcRD", "name": "gravity_field_3", "author": "tholzer", "description": "Simplified 'gravity field 2'.\nUse mouse.x to change coloring. ", "tags": ["field", "gravity"], "likes": 6, "viewed": 229, "published": "Public", "date": "1521185484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------- gravity_field_3 ---------------\n\n// simplified https://www.shadertoy.com/view/4slSWN\n\n#define POINTS 20  \t\t // number of stars\n\n#define t iTime\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\n//vec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\nvec2 P (int i)  // position of point[i]\n{\n  vec4 c = hash4(float(i));\n  return vec2( cos(t*c.x-c.z) +0.5*cos(2.765*t*c.y+c.w),\n\t\t\t ( sin(t*c.y-c.w) +0.5*sin(1.893*t*c.x+c.z)) / 1.5);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 R = iResolution.xy;\n  vec2 uv = (2.*fragCoord - R) / R.y;\n  vec2 mp = iMouse.xy / R;\n    \n  float my = 0.5*pow(.5*(1.-cos(0.1*t)),3.0);\n  float fMODE = (1.0-cos(3.1415*mp.x))/2.;\n\n  vec2 V = vec2(0.);\n  for (int i=1; i<POINTS; i++)\n  {\t\n    vec2 d = P(i) - uv;  // distance point->pixel\n\tV +=  d / dot(d,d);  // gravity force field\n  }\n  float c = (length(V)* 1./(9.*float(POINTS)))*(2.+210.*fMODE);\n  int MODE = int(3.*mp.x);\n  if (MODE==0) fragColor = vec4(.2*c)+smoothstep(.05,.0,abs(c-5.*my))*vec4(1,0,0,0);\n  if (MODE==1) fragColor = vec4(.5+.5*sin(2.*c));\n  if (MODE==2) fragColor = vec4(sin(c),sin(c/2.),sin(c/4.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 159, 181, 181, 225], [226, 286, 308, 308, 365], [369, 369, 410, 410, 553], [555, 555, 611, 611, 1246]]}
{"id": "lsGcWm", "name": "Metallic Polyhedron", "author": "dr2", "description": "Based on a slightly distorted rhombic triacontahedron; mouseable, and optional antialiasing", "tags": ["voronoi", "reflection", "polyhedron", "structure"], "likes": 6, "viewed": 517, "published": "Public API", "date": "1522230703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Metallic Polyhedron\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1    // antialiasing (0/1 - off/on)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir, vnCylOut;\nvec2 csI, csI2, csD, csD2;\nfloat tCur, dstFar, bCylRad, bCylHt, dCylOut;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec3 IcosSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 3.;\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), csI);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csI) > 0.) p.zy = Rot2Cs (p.zy, csI2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csI) > 0.) p.zy = Rot2Cs (p.zy, csI2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  float a, w;\n  w = 2. * pi / 5.;\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), vec2 (csD.x, - csD.y));\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n    p.xy = Rot2D (p.xy, - w);\n  }\n  if (dot (p.yz, csD) > 0.) p.zy = Rot2Cs (p.zy, csD2) * vec2 (1., -1.);\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, a, polyRad, spRad, cylLen, cylRad;\n  polyRad = 2.5;\n  spRad = 0.4;\n  cylRad = 0.15;\n  p.y -= polyRad + spRad - bCylHt + 1.65;\n  q = DodecSym (p);\n  q.z += polyRad;\n  d = PrSphDf (q, spRad);\n  q = IcosSym (p);\n  q.z += polyRad;\n  d = min (d, PrSphDf (q, spRad));\n  a = mod (atan (q.x, q.y) + pi / 3., 2. * pi / 3.);\n  q.yx = vec2 (cos (a), sin (a)) * length (q.xy);\n  q.yz = Rot2D (q.yz, -0.32);\n  cylLen = 0.33 * polyRad - spRad;\n  q.y -= cylLen + spRad;\n  return SmoothMin (d, PrCylDf (q.xzy, cylRad, cylLen + 0.3), 0.1);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd;\n  rd = normalize (vec3 (rd.x, max (0.001, rd.y), rd.z));\n  ro.xz += 5. * tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.), vec3 (0.9),\n     clamp (3. * (Fbm2 (0.01 * (rd.xz * (100. - ro.y) / rd.y + ro.xz)) - 0.5) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.8 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.2, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, b, a, sRotH, sRotV;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    a = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + a) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.4) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.7, 0.72, 0.6);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * a);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * a);\n      } else {\n        qw = 16. * vec2 (12. * a, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.5 + 0.5 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    HexVorInit ();\n    vc = HexVor (4. * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (vc.y, 2., vc.z)),\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.62) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.1 * Noisefv2 (128. * ro.xz)));\n    col = col * (0.3 + 0.7 * ObjSShadow (ro, sunDir) * max (dot (vn, sunDir), 0.));\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, rop, rdp;\n  float dstObj, refFac, dihedIcos, dihedDodec;\n  bCylRad = 16.;\n  bCylHt = 3.;\n  dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  csI = vec2 (cos (dihedIcos), - sin (dihedIcos));\n  csI2 = vec2 (cos (2. * dihedIcos), - sin (2. * dihedIcos));\n  dihedDodec = 0.5 * atan (2.);\n  csD = vec2 (cos (dihedDodec), - sin (dihedDodec));\n  csD2 = vec2 (cos (2. * dihedDodec), - sin (2. * dihedDodec));\n  refFac = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    refFac *= 0.9;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      refFac *= 0.9;\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      rop = ro;\n      rdp = rd;\n    } else {\n      rop = ro;\n      rdp = rd;\n    }\n  } else {\n    rop = ro;\n    rdp = rd;\n  }\n  col = refFac * BgCol (rop, rdp);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvd, ori, ca, sa;\n  float el, az, t, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.11 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    t = floor (0.3 * tCur) + smoothstep (0.85, 1., mod (0.3 * tCur, 1.));\n    az = -0.75 * pi + (1.2/16.) * pi * t;\n    el += 0.1 * pi * cos (0.2 * pi * t);\n  }\n  el = clamp (el, -0.2 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 1.6, -15.);\n  zmFac = 4.5 + 6. * abs (el);\n  dstFar = 40.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n#if ! AA\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n#else\n  col = vec3 (0.);\n  for (int iy = 0; iy <= 1; iy ++) {\n    for (int ix = 0; ix <= 1; ix ++) {\n      uvd = (0.5 / canvas.y) * (2. * vec2 (float (ix), float (iy)) - 1.);\n      rd = vuMat * normalize (vec3 (uv + uvd, zmFac));\n      col += ShowScene (ro, rd);\n    }\n  }\n  col *= 0.25;\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1. / sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcWm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 691, 714, 714, 1180], [1182, 1182, 1206, 1206, 1725], [1727, 1727, 1749, 1749, 2295], [2297, 2297, 2330, 2330, 2507], [2509, 2509, 2530, 2530, 2730], [2732, 2732, 2766, 2766, 3287], [3289, 3289, 3321, 3321, 3645], [3647, 3647, 3673, 3673, 4023], [4025, 4025, 4062, 4062, 4301], [4303, 4303, 4334, 4334, 6988], [6990, 6990, 7025, 7025, 7962], [7964, 7964, 8020, 8020, 9386], [9388, 9388, 9421, 9421, 9448], [9450, 9450, 9492, 9492, 9543], [9545, 9545, 9569, 9569, 9801], [9803, 9803, 9827, 9827, 9887], [9913, 9913, 9933, 9933, 10153], [10155, 10155, 10177, 10177, 10773], [10775, 10775, 10820, 10820, 10923], [10925, 10925, 10982, 10982, 11065], [11067, 11067, 11097, 11097, 11155], [11157, 11157, 11188, 11188, 11252], [11286, 11286, 11310, 11310, 11370], [11372, 11372, 11396, 11396, 11526], [11528, 11528, 11553, 11553, 11739], [11741, 11741, 11762, 11762, 11917]]}
{"id": "lsGcWW", "name": "Phased array", "author": "zakrent", "description": "A simple demonstration of phased array.", "tags": ["waves", "interference", "radar", "phase", "radio", "antenna"], "likes": 5, "viewed": 143, "published": "Public", "date": "1521983718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C 0.05\n//N = number of sources \n//N > 1\n#define N 48\n#define F 5.0\n#define PI 3.14159265358979323\n\nfloat getSignalValue(float t, float f, float Phi){\n    return cos(t*f*2.0*PI+Phi);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.y;\n    if(uv.x < 0.18){\n        fragColor = vec4(0.0f);\n    }\n    else{\n        float signalSum = 0.0;\n        float Psi = PI/8.0*sin(iTime);\n        float deltaY = 0.2/float(N-1);\n        float deltaPhi = (2.0*PI*deltaY*sin(Psi))/(C/F);\n        for(int i = 0; i < N; i++){\n            vec2 pos = vec2(0.2, 0.4)\n                +vec2(0.0, float(i)*deltaY);\n            float d = length(uv-pos);\n            float t = d/C;\n            float Phi = float(i)*deltaPhi;\n            signalSum += getSignalValue(iTime-t, F, Phi)*\n        \t\t (0.42659-\n                 0.49656*cos(2.*PI*float(i)/float(N-1))+\n                 0.076849*cos(4.*PI*float(i)/float(N-1))\n                 );\n\n        }\n        fragColor = vec4(signalSum);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 107, 157, 157, 191], [193, 193, 249, 249, 1019]]}
{"id": "lsGczh", "name": "silly creative coding circles", "author": "jrsa", "description": "just cos", "tags": ["shaderclub"], "likes": 1, "viewed": 398, "published": "Public API", "date": "1520980458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float oval(vec2 center, vec2 p) {\n\treturn distance(center, p);\n}\n\nfloat channel(vec2 c, vec2 p, float s1, float s2) {\n\treturn smoothstep(  oval(c, p), s1, s2);\n}\n\n\n// from https://github.com/msfeldstein/glsl-map\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 path(float t, float phi) {\n    float bound = 0.333;\n    return vec2( map(sin(iTime + phi), -bound, bound, 0.1, 0.9)\n               , map(cos(iTime + phi), -bound, bound, 0.1, 0.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n\n    float q = distance(uv, vec2(0.5, 0.5));\n\n    vec3 col = (vec3( channel( path(iTime, 0.33) * cos(q * 5.0), uv, q, q + cos(iTime)), \n                     channel( path(iTime, 0.5) * cos(q * 4.0) + 0.5, uv, q, q + cos(iTime * 0.73)), \n                     channel( path(iTime, 0.6) * cos(q * 3.0)+ 0.7, uv, q, q + cos(iTime * 0.34))) / 2.0);\n    \n    col += (vec3( channel( path(iTime, 0.1) * cos(q * 1.1), uv, q, q + cos(iTime)), \n                 channel( path(iTime, 0.2) * cos(q * 1.8), uv, q, q + cos(iTime * 0.73)), \n                 channel( path(iTime, 0.9) * cos(q * 0.9), uv, q, q + cos(iTime * 0.34))) / 2.0);\n    \n    fragColor = sqrt(mix(texture(iChannel0, uv + ((col.rb - 0.5) / 5.0)), vec4(col, 1.0), (length(col + 0.5))));\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 64], [66, 66, 117, 117, 161], [164, 212, 290, 290, 365], [367, 367, 398, 398, 555], [557, 557, 614, 614, 1423]]}
{"id": "lsGyRm", "name": "snow cash", "author": "lahwran", "description": "actually pretty fast integer-math thing", "tags": ["procedural", "random", "integer", "pure"], "likes": 3, "viewed": 109, "published": "Public", "date": "1521434470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// https://stackoverflow.com/a/37221804/1102705\nint cash(int x, int y, int seed){   \n    int h = seed + x*374761393 + y*668265263; //all constants are prime\n    h = (h^(h >> 13))*1274126177;\n    return h^(h >> 16);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int intensity = cash(int(fragCoord.x), int(fragCoord.y), int(iTime*1000.));\n    float i1 = float(intensity&0xff);\n    float i2 = float(intensity>>8 & 0xff);\n    float i3 = float(intensity>>16 & 0xff);\n    float i4 = float(intensity>>24 & 0xff);\n    fragColor = vec4(i1,i2,i3,i4)/float(0xff);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 49, 82, 82, 217], [219, 219, 276, 276, 579]]}
{"id": "lsGyzW", "name": "Prism6", "author": "jmaire", "description": "champ de triedre", "tags": ["repetition", "prisme", "hexagone"], "likes": 2, "viewed": 89, "published": "Public", "date": "1521153258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/////////////////\n// // Created by  Jamie Wong\n// 15/03/2018  jmaire: prisme de base hexagonale\n//\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI=3.14159;\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat hexagonSDF(vec3 p,float h,float r){\n    float ag=(p.y>0.0)? acos(p.x/length(p.xy)):2.0*PI - acos(p.x/length(p.xy));\n ag=ag+PI/6.0+iTime*2.0;\nfloat n=floor(ag/(PI/3.0));\nfloat b=ag-n*PI/3.0-PI/6.0  ;\nfloat inoutrayon= cos(b)*length(p.xy)-r;\nfloat inoutheight=abs(p.z)-h/2.0;\nfloat insideDistance=min(max(inoutrayon,inoutheight),0.0);\n float outsideDistance = length(max(vec2(inoutrayon, inoutheight), 0.0));\n    \n    return insideDistance + outsideDistance;\n\n}\n\n\n\nfloat pMod(float t, float d) {\n    return mod(t + d/2.0, d) - d/2.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    // Slowly spin the whole scene\n     p = rotateZ(sin(-iTime*0.05)) * p; \n   p = rotateX(cos(0.1*iTime))* p;\n  p = rotateY(cos(iTime*0.05 )) * p;\n \n \n  // p+=cos(iTime*0.1)*vec3(10.0,0.0,5.0);\n   p.z = pMod(p.z,1.1);\n  // p.y = pMod(p.y,5.8 );\n  p.x = pMod(p.x,1.1);\n    \n    //float cylinderRadius = 0.4 + (2.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 4.0;\n    float cylinderRadius =0.15;\n    float cylinderHeight = 1.2;\n    float cylinder1 = hexagonSDF(p, cylinderHeight, cylinderRadius);\n    float cylinder2 = hexagonSDF(rotateX(radians(90.0)) * p,(cos(iTime*0.3)*3.0+ 3.1)*cylinderHeight, cylinderRadius);\n    float cylinder3 = hexagonSDF(rotateY(radians(90.0)) * p, cylinderHeight, cylinderRadius);\n    \n    float cube = boxSDF(p, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(p, .2);\n    \n    //float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    //float ballRadius = 0.3;\n    //float balls = sphereSDF(p - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    //balls = unionSDF(balls, sphereSDF(p + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p - vec3(0.0, ballOffset, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p + vec3(0.0, ballOffset, 0.0), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p - vec3(0.0, 0.0, ballOffset), ballRadius));\n    //balls = unionSDF(balls, sphereSDF(p + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(sphere,//intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    //return unionSDF(balls, csgNut);\n    return unionSDF(cylinder1, unionSDF(cylinder2, cylinder3));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: iResolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\n\n\n/*\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n*/\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha*5.0));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = vec3(1.0, 0.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-4.0 * sin(iTime*0.05),\n                         0.0,\n                          4.0 * cos(iTime*0.05));\n    vec3 light1Intensity = vec3(1.0,0.0, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-4.0 * sin(0.07 * iTime),\n                          -2.0 * cos(0.07 * iTime),\n                          -4.0*sin(0.1*iTime));\n    vec3 light2Intensity = vec3(1.0, 1.0, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 pxy = fragCoord.xy - iResolution.xy / 2.0;\n    float z = iResolution.y /( tan(PI/4.0) / 2.0);\n    vec3 viewDir= normalize(vec3(pxy, -z));\n\n    vec3 eye = vec3(0.0, 42.0,0.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(5.0, 5.0, 5.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)*0.2) ;\n    vec3 K_d = K_a- vec3(1.0)*0.4 ;\n    vec3 K_s = vec3(1.0,1.0, 1.0);\n    float shininess = 30.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsGyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 658, 685, 685, 832], [834, 880, 907, 907, 1054], [1056, 1102, 1129, 1129, 1276], [1278, 1369, 1415, 1415, 1447], [1449, 1533, 1575, 1575, 1607], [1609, 1698, 1745, 1745, 1778], [1780, 1888, 1921, 1921, 2351], [2353, 2440, 2474, 2474, 2502], [2504, 2621, 2666, 2735, 3341], [3343, 3343, 3384, 3384, 3808], [3812, 3812, 3842, 3842, 3882], [3884, 4124, 4148, 4187, 5817], [5819, 6240, 6331, 6331, 6637], [6909, 7202, 7231, 7231, 7541], [7543, 8035, 8175, 8175, 8769], [8771, 9141, 9226, 9226, 10047], [10049, 10376, 10425, 10460, 10580], [10582, 10582, 10639, 10639, 11635]]}
{"id": "lsKcDD", "name": "Soft Shadow Variation", "author": "iq", "description": "Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!", "tags": ["3d", "raymarching"], "likes": 170, "viewed": 15924, "published": "Public API", "date": "1522130002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//    \n// Testing Sebastian Aaltonen's soft shadow improvement\n//\n// The technique is based on estimating a better closest point in ray\n// at each step by triangulating from the previous march step.\n//\n// More info about the technique at slide 39 of this presentation:\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\n//\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// Go to lines 54 to compare both.\n\n\n// make this 1 is your machine is too slow\n#define AA 2\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\n}\n\n//------------------------------------------------------------------\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = vec3(0.3);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\n        \n        // ambient light\n        float occ = calcAO( pos, nor );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\n        \n        // fog\n        col *= exp( -0.0005*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, technique);\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 616, 641, 641, 656], [658, 658, 689, 689, 780], [783, 853, 879, 879, 1076], [1078, 1148, 1241, 1241, 2096], [2098, 2098, 2130, 2130, 2330], [2332, 2332, 2373, 2373, 2942], [2944, 2944, 2986, 2986, 3247], [3249, 3249, 3305, 3305, 4277], [4279, 4279, 4331, 4331, 4508], [4510, 4510, 4567, 4582, 5502]]}
{"id": "lsKcRz", "name": "Mettalloy Rays", "author": "audiopixel", "description": "feeling like melting metal", "tags": ["raymarching", "rays", "lighting"], "likes": 2, "viewed": 116, "published": "Public", "date": "1520903361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Mettalloy Rays'\n// Created by hepp maccoy March/2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float s = ((-iTime) * 9.2) + sin(iTime * .27) * 9.2;\n    float d = 1.0; vec3 o = p;\n    float a=mod(o.y+5.0, (20.))-10.; a = abs(o.y);\n    p.yz *= r2d(sign(a)* -5.);\n    p.xz *= r2d(sign(a)*(s * .04));\n    p.xz = amod(p.xz, 3.7);\n    p.xz = max(abs(p.xz) + 0.0808, -3.3221);\n    p.z = mod(p.z, 5.)-2.5;\n    p.x = mod(p.x, 26.)-13.;\n    p.y = mod(p.y+s, 18.)-5.;\n    d = min(d, soc(max(abs(p)-.3999, .3565)));\n    return (length(p*-.0168)-.0097)* -3. - (d * -1.);\n}\n\nvec3 b(vec3 c1, vec3 c2){\n    return vec3((c1.r > 0.5) ? max(c2.r, 2.0 * (c1.r - 0.5)) : min(c2.r, 2.0 * c1.r), (c1.r > 0.5) ? max(c2.g, 2.0 * (c1.g - 0.5)) : min(c2.g, 2.0 * c1.g),(c1.b > 0.5) ? max(c2.b, 2.0 * (c1.b - 0.5)) : min(c2.b, 2.0 * c1.b));                                                                      { return c1 + c2; }                               // Add (default)\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.05;\n    return normalize( e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 l = vec3(-10);\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 ro = vec3(st, 5. + sin(iTime * .8) * 3.5);\n    vec3 rd = normalize(vec3(st+vec2(0.), .3662));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) { md = map(mp); if (md <.001) break; mp += rd*md; }\n    vec3 c1 = vec3(-0.3805 - (length(ro-mp) * (.035 + sin(iTime * .8) * .006)) * -1.8547), c2, c3;\n    vec3 p = ro + rd * (mp);\n    if (md > -0.7875) {\n        float dif = clamp(dot(calcNormal(p), normalize(l - p)), 0., 1.);\n        dif *= 5. / dot(l - p, l - p);\n        c2 = vec3(pow(dif, .053)); \n    } else {\n        c3 = vec3(p.x * .15);\n    }\n    c2 = b(c2, vec3((mp.z * 2.5) * (md * .05), 0, 0));\n    fragColor = vec4(abs((c2 + c3) - c1), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKcRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[165, 295, 314, 314, 425], [427, 427, 446, 446, 521], [523, 523, 551, 551, 636], [638, 638, 657, 657, 1126], [1128, 1128, 1153, 1153, 1517], [1519, 1519, 1547, 1547, 1708], [1710, 1710, 1766, 1766, 2528]]}
{"id": "lsKcWR", "name": "heart in cage", "author": "ooopsyi", "description": "heart tile", "tags": ["heart"], "likes": 1, "viewed": 50, "published": "Public", "date": "1521644931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 4.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        _st = rotate2D(_st,PI*0.75);\n    } else if(index == 2.0){\n        _st = rotate2D(_st,PI*-0.25);\n    } else if(index == 3.0){\n        _st = rotate2D(_st,PI*0.25);\n    } else {\n      _st = rotate2D(_st,PI*-0.75);\n    }\n\n    return _st;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\n   st = tile( st - fract(sin(iTime)/50.0)*0.2, 2.0 - fract(sin(iTime)/50.0)*2.8);\n   st = rotateTilePattern(st + fract(sin(iTime)/10.0)*0.2);\n   vec2 p = 2.0*st - vec2(1.0);\n   p.y -= 0.25;\n\n   // background color\n   float tt = mod(iTime,8.0)/2.0;\n   vec3 bcol = vec3(0.1+0.5*cos(iTime)*0.2);\n\n   // animate\n   p *= vec2(0.5,1.5) + tt*vec2(1.0,-1.0);\n\n   // shape\n   float a = atan(p.x,p.y)/PI;\n   float r = length(p);\n   float h = abs(a);\n   float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n\n   // color\n   float s = 1.0-0.5*clamp(r/d,0.0,1.0);\n   s = 0.75 + 0.75*p.x;\n   s *= 1.0-0.25*r;\n   s = 0.5 + 0.6*s;\n   s *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n   //vec3 hcol = vec3(0.3*r,0.1*s,0.5*s)*r*3.0;\n    vec3 hcol = vec3(1.0)*s;\n  \n\n   vec3 col = mix( bcol, hcol, smoothstep( -0.1, 0.01, d-r) );\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 75, 75, 215], [217, 217, 252, 252, 295], [297, 297, 330, 374, 906], [907, 907, 964, 1014, 1903]]}
{"id": "lsKyRw", "name": "layered animated figure (407 ch)", "author": "FabriceNeyret2", "description": "golfing fading-less version of [url]https://shadertoy.com/view/XsGyRm[/url]\nReproducing [url]https://www.facebook.com/CosmosUpp/videos/1001518269996955/[/url]\n\n", "tags": ["2d", "lines", "illusion", "points", "short", "reproduction", "animgif"], "likes": 5, "viewed": 440, "published": "Public API", "date": "1521495979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing fading-less version of https://shadertoy.com/view/XsGyRm\n\n#define P(i) cos(2.6914*(i)+T*.1 + vec2(0,11) ) // heptastar vertex i\n#define S(D) dot( A=(D)*R.y , A )               // smooth draw                                  \n#define L(b) 1./ S( -clamp(dot(B=b-Q, A=U-Q)/dot(B,B), 0.,1.) *B +A) // draw a line\n                                                // point(n,t) on heptastar \n#define p(d) mix( P(i= ceil( t= T/5.+ (n d)*.583)), P(--i), .5+.5*cos(3.*fract(t)) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 A,B,Q,R=iResolution.xy, U = ( u+u - R ) / R.y;\n    for ( float t,i,T=iTime, n=0.; n++ < 12.;\n        O.a += 30. / S( Q-U ) )               /* dots         */\n        Q = P(n),\n        O.rga += n>5. ? L( P(n+1.) ) : 0.,    /* yellow lines */\n        Q = p(),\n        O.ra += L( p(+4.) ),                  /* triangles    */\n        O.ba += L( p(+3.) );                  /* squares      */\n    O += 1.4-.7*O.a; }                        /* background   */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 482, 518, 518, 938]]}
{"id": "lsKyRy", "name": "raymarch pattern 01", "author": "Nitato_", "description": "3D raymarched pattern using torus", "tags": ["3d", "raymarch", "torus", "pattern"], "likes": 2, "viewed": 132, "published": "Public", "date": "1522497549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define opRep(p, c) mod(p,c)-.5*c\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nmat3 rotMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat map(vec3 p) {\n    mat3 rot = rotMatrix(vec3(1.,0.,0.), 190.);\n    rot *= rotMatrix(vec3(0.,1.,0.), sin(iTime)*3.);\n    p*=rot;\n    p = opRep(p, vec3(.5));\n\treturn sdTorus(p, vec2(.3, .02));\n}\nvec2 trace (vec3 o, vec3 r) {\n\tfloat t = 0.;\n    float i;\n    float precis = .01;\n    for (i = 0.; i < 64.; ++i) {\n        o.z *= sin(iTime);\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        if (d<precis) break;\n        t += d;\n    }\n    return vec2(t, i);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy )/iResolution.y;\n\tvec3 o = vec3(0.0, -0.015, -0.2);\n    vec3 r = normalize(vec3(uv, 1.));\n    vec2 t = trace(o, r);\n\n    vec3 col = vec3(.2,.1,.4)*cos(iTime)*0.5+0.1;\n\n    fragColor = vec4(col,1.0)*t.x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 68, 68, 133], [134, 134, 174, 174, 641], [642, 642, 661, 661, 839], [840, 840, 869, 869, 1108], [1109, 1109, 1166, 1166, 1414]]}
{"id": "lsKyW1", "name": "Wheels_2_Anvoker", "author": "Anvoker", "description": "Tiling rotating wheels. Improved thanks to FabriceNeyret2 <3\n\nTook to figure out how to draw hard edges instead of smoothstep. Still don't fully understand everything FabriceNeyret2 presented, but I'm getting there. Commenting everything for my own sake.", "tags": ["beginner", "circle", "wheel", "rotating", "tiling"], "likes": 0, "viewed": 97, "published": "Public", "date": "1521897355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Setup=========\nconst int n = 8;\nconst float rotSpeed = 0.5;\nconst float circleBorder = 0.75;\nconst float lineBorder = 0.025 / float(n);\nconst vec3 backCol = vec3(0.1, 0.1, 0.1);\nconst vec3 lineCol = vec3(0.0, 0.75, 0.0);\nconst vec3 circCol = vec3(0.75, 0.0, 1.0);\n//==============\n\nconst float nf = float(n);\nconst float r = 1.0 / float(n * 2);\nconst float rSqr = r * r;\nconst float rSqr2 = rSqr * circleBorder;\n\n#define M_PI 3.141593\n\nvec3 drawCircles(vec2 uv)\n{\n    // Tiles and shifts the coordinate system\n    uv = (fract(uv * nf) - 0.5) / nf;\n    \n    float t  = iTime,\n    // Outer Radius\n      rtime  = abs(cos(t * rotSpeed)) * rSqr,\n        \n    // Inner Radius\n      rtime2 = abs(cos(t * rotSpeed)) * rSqr2,\n        \n    // Short for uv.x * uv.x + uv.y * uv.y\n      circle = dot(uv,uv);\n    \n    // Rotates the coordinate system so the lines rotate\n    uv *= mat2(cos(t),-sin(t),sin(t),cos(t));\n\n    // First step gives 1.0 for every coord outside of the \n    // circle minus border thickness\n    \n    // Second step gives 1.0 for every coord inside the circle\n    \n    // Multiplied together they give 1.0 only for coords\n    // on the border of the circle\n#define CircleStep(v) step(rtime2, abs(v)) * step(abs(v), rtime) \n    \n    // I don't fully understand why this works\n#define LineStep(v) step(abs(v), lineBorder)\n    \n    float lines = LineStep(uv.x)\n        \t    + LineStep(uv.y)\n                + LineStep((uv.x+uv.y)*.707)\n                + LineStep((uv.x-uv.y)*.707);\n    \n    // Clamping prevents lines from drawing over each other\n    lines = clamp(lines, 0.0, 1.0);\n    \n    // Returns 1.0 only if the current coord is inside radius\n#define isInsideCircle(r) step(0.0, r - circle)\n\n    return backCol\n         + circCol * CircleStep(circle)\n         + lineCol * isInsideCircle(rtime2)\n                   * lines;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.x;\n    \n    vec3 col = drawCircles(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 438, 465, 511, 1840], [1842, 1842, 1897, 1897, 2013]]}
{"id": "lsKyzW", "name": "Canals", "author": "dila", "description": "A scene of nowhere in particular :)\nClick and drag with mouse to rotate!", "tags": ["raymarch"], "likes": 20, "viewed": 244, "published": "Public", "date": "1521493298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mapw = 0.0;\nfloat mapc = 0.0;\nfloat mapl = 0.0;\nfloat mapv = 0.0;\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat bump(vec3 p) {\n    vec2 uv = (p.xz - vec2(0.0, iTime * 1.2)) * 0.05;\n    uv.y -= cos(p.x * 3.141592 * 0.5) * 0.02;\n    float tex = dot(texture(iChannel1, uv).xyz, vec3(1.0)) / 3.0;\n    return (tex * 2.0 - 1.0) * 0.005;\n}\n\nvec2 wiremap(vec3 p) {\n    return p.xy * rot(0.6 + sin(p.z / 3.141592 * 4.0) * 0.125);\n}\n\nfloat vent(vec3 p) {\n\treturn max(abs(abs(p.x) - 2.0) - 0.02, abs((fract(p.y * 8.0 - 0.3) - 0.5) / 8.0) - 0.02);\n}\n\nfloat map(vec3 p) {\n    p.x += sin(p.z) * 0.5;\n\tfloat t = 2.0 - length(p.xy);\n    float f = p.y + bump(p);\n    float e = max(abs(abs(p.x) - 20.0) - 18.7, abs(p.y) - 0.3);\n    float c = length(vec2(p.y - 0.5, (fract(p.z / 3.0) - 0.5) * 3.0)) - 0.75;\n    vec2 k = wiremap(p);\n    float s = length(vec2(k.y - 1.9, abs(k.x) - 0.025)) - 0.015;\n    float l = length(vec3(k.y - 1.85, k.x, (fract(p.z / 4.0) - 0.5) * 4.0)) - 0.05;\n    float v = min(vent(p), vent(p.xzy));\n    t = max(t, -c);\n    t = min(t, e);\n    mapv = max(sign(t - v), 0.0);\n    t = min(t, v);\n    mapw = max(t - f, 0.0);\n    t = min(t, f);\n    mapc = max(sign(t - s), 0.0);\n    t = min(t, s);\n    mapl = max(sign(t - l), 0.0);\n    return min(t, l);\n}\n\nvec2 mapuv(vec3 p, vec3 sn) {\n    p.x += sin(p.z) * 0.5;\n\tfloat t = 2.0 - length(p.xy);\n    float f = p.y + bump(p);\n    float e = max(abs(abs(p.x) - 20.0) - 18.7, abs(p.y) - 0.3);\n    float c = length(vec2(p.y - 0.5, (fract(p.z / 3.0) - 0.5) * 3.0)) - 0.75;\n    float v = min(vent(p), vent(p.xzy));\n    t = max(t, -c);\n    vec2 bt = mix(p.yz, p.xz, max(sign(sn.y), 0.0));\n    t = min(t, f);\n    bt = mix(p.xz, bt, max(sign(t - e), 0.0));\n    t = min(min(t, f), e);\n    bt = mix(p.yz, bt, max(sign(v - t), 0.0));\n    return bt;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n        \nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nfloat fog(vec3 w, vec3 sn, float f) {\n    w.x += sin(w.z) * 0.5;\n    float h = max(2.3 - abs(w.x), 0.0);\n    return f * h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.2));\n    vec3 o = vec3(0.0, 1.0, iTime * 0.5);\n    \n    o.x -= sin(o.z) * 0.5;\n    o.y += sin(o.z * 4.0) * 0.02;\n    float ms = (iMouse.x / iResolution.x * 2.0 - 1.0) * sign(iMouse.z);\n    r.xz *= rot(sin(o.z) * 0.5 + ms);\n    r.xy *= rot(-sin(o.z) * 0.1);\n    \n    vec3 lcol = vec3(2.0, 2.0, 2.0);\n    \n    float t = trace(o, r);\n    float tw = mapw;\n    float tc = mapc;\n    float tl = mapl;\n    float tv = mapv;\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    vec3 tex = texture(iChannel0, mapuv(w, sn)).xyz;\n    tex *= tex;\n    tex = mix(tex, tex.xxx * 0.125, tv);\n    tex = mix(tex, vec3(0.7, 0.7, 0.0), tc);\n    tex *= max(dot(-r, sn), 0.0);\n    tex = mix(tex, lcol, tl);\n    float aoc = map(w + sn * 1.1);\n    tex *= 0.5 + aoc;\n    float f = 1.0 / (1.0 + t * t * 0.1);\n    \n\tvec3 rr = reflect(r, sn);\n    float rt = trace(w + rr * 0.01, rr);\n    float rtw = mapw;\n    float rtc = mapc;\n    float rtl = mapl;\n    float rtv = mapv;\n    vec3 rw = w + rr * rt;\n    vec3 rsn = normal(rw);\n    vec3 rtex = texture(iChannel0, mapuv(rw, rsn)).xyz;\n    rtex *= rtex;\n    rtex = mix(rtex, rtex.xxx * 0.125, rtv);\n    rtex = mix(rtex, vec3(0.7, 0.7, 0.0), rtc);\n    rtex = mix(vec3(0.0, 0.0, 0.0), rtex, 1.0-abs(dot(r,sn)));\n    rtex *= max(dot(-rr, rsn), 0.0);\n    rtex = mix(rtex, lcol, rtl);\n    float raoc = map(rw + rsn * 1.1);\n    rtex *= 0.5 + raoc;\n    float rf = 1.0 / (1.0 + rt * rt * 0.1);\n\n\ttex = mix(vec3(0.0), tex, fog(w, sn, f));\n\trtex = mix(vec3(0.0), rtex, fog(rw, rsn, rf * f));\n    \n    float twf = 1.0 / (1.0 + tw * 20.0);\n    vec3 wtex = texture(iChannel1, mapuv(w, sn)).xyz;\n    wtex *= wtex;\n    vec3 rfc = mix(rtex, wtex, pow(abs(dot(-r, sn)), 3.0));\n    vec3 fc = mix(rfc * vec3(0.2, 0.2, 0.1) * 8.0, tex, twf);\n    \n    float lt = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * lt;\n        p.x += sin(p.z) * 0.5;\n        p.xy = wiremap(p);\n        p.z = (fract(p.z / 4.0) - 0.5) * 4.0;\n        float ld = length(vec3(p.x, p.y - 1.85, p.z)) - 0.0125;\n        lt += ld * 0.4;\n    }\n    fc = mix(fc, lcol, 1.0 / (1.0 + lt * lt * 0.5));\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 92, 92, 144], [146, 146, 166, 166, 372], [374, 374, 396, 396, 462], [464, 464, 484, 484, 577], [579, 579, 598, 598, 1292], [1294, 1294, 1323, 1323, 1823], [1825, 1825, 1846, 1846, 2047], [2057, 2057, 2086, 2086, 2191], [2193, 2193, 2230, 2230, 2317], [2319, 2319, 2376, 2376, 4646]]}
{"id": "lstcDl", "name": "test3D", "author": "cailven", "description": "test", "tags": ["3d"], "likes": 2, "viewed": 70, "published": "Public", "date": "1520661155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nfloat doModel( vec3 p )\n{\n    //return length(p) - 1.0;\n    // return length(max(abs(p)-1.0,0.0));\n    float a=sdSphere(p,1.5);\n    float b=udBox(p,vec3(1.0));\n    float c=opS(a,b);\n    return c;\n    \n    \n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.2,0.07,0.01);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 332, 415, 415, 534], [537, 768, 795, 795, 830], [836, 1118, 1153, 1153, 1177], [1179, 1179, 1210, 1210, 1248], [1250, 1250, 1283, 1283, 1309], [1312, 1312, 1337, 1410, 1519], [1521, 1874, 1919, 1919, 1953], [1955, 2166, 2250, 2250, 2826], [2828, 2828, 2878, 2878, 3295], [3297, 3297, 3329, 3329, 3741], [3743, 3743, 3791, 3791, 4217], [4219, 4219, 4283, 4283, 4461], [4463, 4463, 4520, 4520, 5724]]}
{"id": "lstcRl", "name": "Beer + Snow", "author": "Del", "description": "beer + snow", "tags": ["beer"], "likes": 7, "viewed": 655, "published": "Public API", "date": "1519867375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// as if by magic... snow + beer\n// Del 01/03/2018\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.y-=time*2./scale;\n    uv.x+=sin(uv.y+time*.95)*0.025;\t///scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    d-= sin(f.y+time)*0.005;\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    c = clamp(c,0.0,1.0);\n    \n    vec3 background = vec3(0.75,0.65,0.2);\n    \n    head*=2.0;\n    head = clamp(head,-0.2,1.0);\n    background = mix(background,vec3(1.0),head);\n    \n    float bub_brightness = 1.6;\n    \n    vec3 scol = background * bub_brightness; //vec3(1.0,1.0,1.0);\n    scol = mix(background,scol,c);\n    scol = clamp(scol,0.0,1.0);\n    return scol;\n}\n\n\n//snow original -> http://glslsandbox.com/e#36547.1\nfloat snow(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n\tuv+=time/scale;\n    uv.y+=time*2./scale;\n    uv.x+=sin(uv.y+time*.5)/scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\n\nvec3 _Snow(vec2 uv,vec3 background)\n{\n\tfloat c = snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n    c = clamp(c,0.0,1.0);\n    vec3 scol = vec3(1.0,1.0,1.0);\n    scol = mix(background,scol,c);\n\treturn scol;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/ iResolution.y;\n\n    vec2 uv1 = uv+vec2(0.0,1.0);\n    float d = 0.25+length(uv1)*0.4;\n    vec3 col = vec3(0.3,0.2,0.25)*d*d;\n    col = _Snow(uv1*0.5,col); \n    \n    uv.y -= 1.0;\n    float scale = 2.9-uv.y;\n    if (scale<3.5)\n        scale=3.5;\n    \n    uv.x *= scale*0.55;\n    float c = abs(uv.x);\t\t// dirty shading bodge...\n    if (c-0.5 < 0.5 && uv.y <-0.5)\n    {\n\t\tuv.x = acos(uv.x)/3.14159;\n        c = acos(c);\n        float head = 0.9+(uv.y);\n        float headmod = 0.5+sin(uv.x*11.0 + iTime)*0.5;\n        head+=headmod*0.1;\n        float c2 = smoothstep(0.0,1.0,c);\n        col = Bubbles(uv*2.0, head)*(c2+0.4);\n    }\n    fragColor =vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 84, 84, 456], [458, 458, 492, 492, 994], [997, 1049, 1082, 1082, 1430], [1433, 1433, 1470, 1470, 1721], [1725, 1725, 1782, 1782, 2486]]}
{"id": "lstyWl", "name": "moon conspiracy", "author": "Del", "description": "moon", "tags": ["moon"], "likes": 18, "viewed": 1106, "published": "Public API", "date": "1520628629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// moon, now with a slightly less rubbish (twinkling) starfield.\n\nfloat _Stars(vec2 uv,float scale)\n{\n    uv.y+=2./scale;\n    uv.x+=sin(uv.y)/scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    float k=min(d,3.0);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 NewStars(vec2 uv,vec3 background)\n{\n    float twinkle = 0.5+sin(iTime*1.61+uv.x + uv.y*18.0)*0.5;\n    twinkle = (twinkle*0.35)+0.65;\n\tfloat c = _Stars(uv,30.)*.3;\n\tc+=_Stars(uv,16.6);\n\tc+=_Stars(uv,7.8);\n    vec3 scol = vec3(0.8,0.8,1.0)*twinkle;\n    scol = mix(background,scol,c);\n\treturn scol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float speed = iTime*0.01;\n    float spheresize = 0.2;\n    float texturescale = 0.31;\n\tvec2 p = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n\tvec4 col = vec4(0.0);\n    col.rgb = NewStars(p*0.51,col.rgb);\n    p.x-=0.275*(iResolution.x/iResolution.y);\t\t\t// offset sphere\n\n    float l = spheresize-dot(p,p);\n    //l = clamp(l,0.0,1.0);\n    vec3 r = vec3(p, sqrt(max(l,0.0)));\n    float s = smoothstep(.15,0.,r.z);\n    float light = max(r.x*.4+r.y*.91+r.z*.3+.4,.1);\n    float lum = texture(iChannel0,speed+texturescale*r.xy/sqrt(r.z)).g*1.05;\n    col = mix(vec4(lum*light),col ,s);\n\tfragColor = col;\n    \n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 101, 101, 381], [383, 383, 423, 423, 685], [687, 687, 742, 742, 1354]]}
{"id": "lsVcWz", "name": "Fractal da madrugada", "author": "Hikk", "description": "Eu devia ter estudado pra prova", "tags": ["fractal"], "likes": 3, "viewed": 111, "published": "Public", "date": "1521666338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 1.\n#define FACTOR 2.3\n#define PI 3.1415926535897932384626433832795\n#define SCALE 0.1\n#define POSX 0.81\n#define POSY 0.46\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = SCALE + 600.;\n    if (exp(iTime/3.) < 600.)\n    \tscale = SCALE + exp(iTime/3.) - 1.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 xy = (uv - 0.5) * 2.0;\n    xy.x *= iResolution.x/iResolution.y;\n    xy /= scale;\n    xy += vec2(POSX, POSY);\n    vec2 center = vec2(0.0, 0.0);\n    \n    vec3 col = vec3(0., 0., 0.);\n    float size = SIZE;\n    \n    for(int i =0; i < 100; i++)\n    {\n        float x = step(center.x - size/2., xy.x) - step(center.x + size/2., xy.x);\n        float y = step(center.y - size/2., xy.y) - step(center.y + size/2., xy.y);\n        if (x*y == 1.)\n        {\n            \n            col = vec3(sin(iTime)*length(xy)/2., length(xy)/2., length(xy)/2.);\n            break;\n        }\n        \n        float i_float = float(i) + 1.;\n        float xDist = xy.x - center.x;\n        float yDist = xy.y - center.y;\n        float xRot = xDist * cos(-PI/4.) - yDist * sin(-PI/4.);\n        float yRot = xDist * sin(-PI/4.) + yDist * cos(-PI/4.);\n        \n        if (sign(xRot) * sign(yRot) == 1.)\n        {\n        \tcenter.y = center.y + sign(xRot)*(size/2. + size/(2.*FACTOR));\n            //col = vec3(10./i_float, 0., 0.);\n        }\n        else if (sign(xRot) * sign(yRot) == -1.)\n        {\n            center.x = center.x + sign(xRot)*(size/2. + size/(2.*FACTOR));\n            //col = vec3(0., 10./i_float, 0.);\n        }\n        else\n            col += vec3(0., 0., 0.);\n        \n        size = size/FACTOR;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 193, 193, 1751]]}
{"id": "lsVyWW", "name": "splaaaaat", "author": "Nitato_", "description": "splodge pattern", "tags": ["2d", "test", "lines"], "likes": 3, "viewed": 72, "published": "Public", "date": "1522080074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rep(vec2 p, vec2 m) {\n\treturn mod(p,m);   \n}\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;\n}\nfloat asFilled(float d) {\n\t\treturn (smoothstep(0.,.01,d));\n}\nvec2 mov(vec2 xy, vec2 t) {\n\treturn xy - t;\n}\nvec2 scale(vec2 xy, vec2 s) {\n\treturn xy.xy/s.xy;\n}\nvec2 rot(vec2 xy, float ang) {\n\tfloat s = sin(ang);\n    float c = cos(ang);\n    return xy * mat2(c, -s, s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 uv = (fragCoord/iResolution.xy *2. - vec2(1.0)) * aspect;\n    vec4 m = vec4((iMouse.xy / iResolution.xy*2.0 - vec2(1.0)) * aspect,(iMouse.zw / iResolution.xy*2.0 - vec2(1.0)) * aspect);\n    vec3 coloure = vec3(0.5*sin(iTime)+0.5,mod(iTime,1.),0.5*sin(iTime)+0.5);\n    vec2 x = rep(uv, vec2(0.5,0.5)); \n    vec2 a = mov(x, vec2(0.25,0.25));\n    vec2 h = scale(a, vec2(sin(iTime)+2.)*.1);\n    vec2 s = rot(h, iTime);\n    float d = sdCircle(h, 0.7 + sin(atan(s.x,s.y)*10.)*.1);\n    float final = asFilled(d*sin(iTime)); \n\tfragColor = vec4(final*coloure, 1.);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVyWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 49], [50, 50, 83, 83, 108], [109, 109, 134, 134, 169], [170, 170, 197, 197, 215], [216, 216, 245, 245, 267], [268, 268, 298, 298, 380], [381, 381, 438, 438, 1062]]}
{"id": "lsycW1", "name": "a sunny day of sea", "author": "FishMan", "description": "a sunny day of sea", "tags": ["2d", "sea", "sun", "cloud"], "likes": 6, "viewed": 226, "published": "Public", "date": "1521792293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a sunny day of sea - by JiepengTan - 2018\n// jiepengtan@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define LAYER 22.0\n#define lerp mix\nfloat Wave(float layer,vec2 uv,float val){\n\tfloat amplitude =  layer*layer*0.00004;\n\tfloat frequency = val*200.*uv.x/layer;\n\tfloat phase = 9.*layer+ iTime/val;\n\treturn amplitude*sin(frequency+phase); \n}\nfloat Circle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\nfloat AngleCircle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat deg = atan(uv.y,uv.x) + iTime * -0.1;\n\tfloat len = length(uv);\n\tfloat offs =( sin(deg*9.)*3.+sin(deg*11.+sin(iTime*6.)*.5))*0.05;\n\treturn smoothstep(1.+offs,1.-blur+offs,len);\n}\nfloat Remap(float a,float b,float c,float d,float val){\n\treturn (val-a)/(b-a) * (d-c) + c;\n}\nfloat DrawCloud(vec2 uv,vec2 center,float size){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat col = Circle(uv,vec2(0.,0.),0.2,0.05);\n\tcol =col *  smoothstep(-0.1,-0.1+0.01,uv.y);\n\tcol += Circle(uv,vec2(0.15,-0.05),0.1,0.05);\n\tcol += Circle(uv,vec2(0.,-0.1),0.11,0.05);\n\tcol += Circle(uv,vec2(-0.15,-0.1),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.3,-0.08),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.2,0.),0.15,0.05);\n\treturn col;\n}\nfloat DrawClouds(vec2 uv){\n\tuv.x += 0.03*iTime;\n\tuv.x = fract(uv.x+0.5) - 0.5;\n\tfloat col = DrawCloud( uv,vec2(-0.4,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(-0.2,0.42),0.2);\n\tcol += DrawCloud( uv,vec2(0.0,0.4),0.2);\n\tcol += DrawCloud( uv,vec2(0.15,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(0.45,0.45),0.2);\n\treturn col;\n}\nvec4 DrawSun(vec2 uv,vec2 center){\n\tvec2 sunPos = center;\n\tfloat sun = Circle(uv,sunPos,0.06,0.05);\n\tfloat sunCircle = AngleCircle(uv,sunPos,0.08,0.05);\n\tvec3 col = sunCircle * vec3(0.9,0.6,0.15);\n\tcol = lerp( col ,vec3(0.98,0.9,0.1),sun);\n    return vec4(col,clamp(sun+sunCircle,0.,1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0,LAYER*.03,1.);\n    float num = 0.;\n    \n    //get the layer id\n    //ref :https://www.shadertoy.com/view/XlsXRM\n    for (float i=1.; i < LAYER; i++) {\n    \tfloat wave = 2.*Wave(i,uv,1.)+Wave(i,uv,1.8)+.5*Wave(i,uv,3.);\n    \tfloat layerVal = 0.2-0.03*i + wave;\n        if(uv.y <layerVal){\n            num = i;\n        }\n    }\n    num = LAYER - num;\n    //1.draw sea\n    col += num * vec3(.04,.013,.04);\n    \n\t//2.draw sky \n\tif(num ==LAYER){\n\t\tfloat ry = Remap(0.2,0.5,1.0,0.0,uv.y);\n\t\tcol = lerp(vec3(0.1,0.6,0.9),vec3(0.1,0.7,0.9),ry);\n\t\tcol += pow(ry,10.)*vec3(0.9,0.2,0.1)*0.2;\n\t}\n\t\n\t//3.draw sun\n    vec4 sunCol = DrawSun(uv,vec2(0.4,0.35));\n\tcol = lerp( col ,sunCol.xyz,sunCol.w);\n    \n\t//4.draw clouds\n\tcol += DrawClouds(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsycW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 194, 236, 236, 396], [397, 397, 453, 453, 548], [549, 549, 610, 610, 827], [828, 828, 883, 883, 920], [921, 921, 969, 969, 1334], [1335, 1335, 1361, 1361, 1649], [1650, 1650, 1684, 1684, 1940], [1941, 1941, 1998, 1998, 2882]]}
{"id": "lsyyRG", "name": "Archimedean spiral", "author": "wei", "description": "Archimedean spiral", "tags": ["archimedeanspiral"], "likes": 3, "viewed": 513, "published": "Public API", "date": "1522390182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    vec2 center = iResolution.xy / 2.0;\n    vec2 dist = center - fragCoord;\n    float r = length(dist);\n    float theta = sin(iTime)+atan(dist.y, dist.x)/(2.0*PI);\n\t\n    \n    float d = 25.;\n    r = r - d*theta;\n    float c = r/d - (floor(r/d));\n    \n    fragColor =  1.-vec4( smoothstep(.01,.04,abs(c-.025)));\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyyRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 428]]}
{"id": "lsyyW1", "name": "Cube & Sphere - Lambertian", "author": "nawafuji", "description": "first practice", "tags": ["practice"], "likes": 0, "viewed": 59, "published": "Public", "date": "1522334676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(1.0) - p) - 1.0;\n}\n\nfloat plane(vec3 p){\n    float s = -1.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   \tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,0,0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        vec3 pixelColour = computeLambert(hit, computeSurfaceNormal(hit), light, p);\n        \n    \treturn mix(vec3(0.1), pixelColour, fog(hit, p));\n    }\n    dist += nearest;\n  }\n  return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cameraDistance = 10.0;\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n    vec3 cameraPosition = vec3(10, 0, 10);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n    \n        \n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 346, 372, 372, 634], [636, 636, 655, 655, 781], [783, 783, 804, 804, 846], [848, 848, 868, 868, 941], [943, 943, 982, 982, 1238], [1240, 1240, 1274, 1274, 1491], [1493, 1493, 1545, 1545, 2174], [2176, 2176, 2219, 2219, 2912], [2915, 2915, 2972, 2972, 3923]]}
{"id": "Md3cWj", "name": "Simple Cylinder Ray Tracer", "author": "TekF", "description": "I wanted something more precise than SDF marching, so I made this. Will probably use it in another shader at some point but I thought I'd share as-is.", "tags": ["raytracing"], "likes": 6, "viewed": 659, "published": "Public API", "date": "1520181632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cylinder Ray Tracer\n// by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// list of cylinders\n// Each cylinder is decribed by a pair of vec4's:\n// vec4( start position, radius ), vec4( end pos, ignored )\nvec4 Scene[] = vec4[](\n    vec4(0,-1.3,0,10), vec4(0,-2,0,0),\n    vec4(0,-1,0,3.5), vec4(0,-2,0,0),\n    vec4(-.7071,-1.+.7071,0,1), vec4(.7071,-1.+3.*.7071,0,0),\n    vec4(0,-1,3,.2), vec4(0,4,3,0),\n    vec4(2.12,-1,2.12,.2), vec4(2.12,4,2.12,0),\n    vec4(3,-1,0,.2), vec4(3,4,0,0),\n    vec4(2.12,-1,-2.12,.2), vec4(2.12,4,-2.12,0),\n    vec4(0,-1,-3,.2), vec4(0,4,-3,0),\n    vec4(-2.12,-1,-2.12,.2), vec4(-2.12,4,-2.12,0),\n    vec4(-3,-1,0,.2), vec4(-3,4,0,0),\n    vec4(-2.12,-1,2.12,.2), vec4(-2.12,4,2.12,0),\n    vec4(0,4,0,3.5), vec4(0,5,0,0)\n    );\n\n\nvec3 Sky( vec3 ray )\n{\n    return vec3(.01);\n}\n\n\n\n#define FLT_MAX 1e38\n\nfloat IntersectCylinder( out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )\n{\n    vec3 m = (a.xyz+b.xyz)/2.;\n    \n    pos -= m; // centre all maths on the cylinder\n    \n    float radius = a.w;\n    vec3 n = (a.xyz-b.xyz)/2.;\n    float l = length(n);\n    n /= l;\n    \n    \n    // intersect infinite cylinder\n    // flatten everything along the axis\n    vec3 r = ray-dot(ray,n)*n;\n    vec3 p = pos-dot(pos,n)*n;\n    float rl = length(r);\n    r /= rl;;\n    float rdp = dot(r,p);\n    float pp = dot(p,p);\n    float q = pp - rdp*rdp;\n    if ( q >= radius*radius ) return FLT_MAX;\n    \n    float d = sqrt(radius*radius-q);\n    float front = (-rdp - d)/rl;\n    float back = (-rdp + d)/rl;\n    normal = normalize(p+front*r*rl);\n    \n    \n    // intersect facing plane\n    float rdn = dot(ray,n);\n    float pdn = dot(pos,n);\n    \n    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }\n    \n    float front2 = (-l-pdn)/rdn;\n    \n    if ( front2 > front )\n    {\n        front = front2;\n        normal = -n;\n    }\n\n    \n    // clip the back sides\n    if (\n        front > back || // clip to back of cylinder\n    \tpdn+rdn*front > l // clip to back plane\n        )\n        return FLT_MAX;\n    \n    return front;\n}\n\n\nfloat Trace( out vec3 normal, vec3 pos, vec3 ray )\n{\n    normal = vec3(0);\n    float t = FLT_MAX;\n    for ( int i=0; i < Scene.length(); i += 2 )\n    {\n        vec3 n;\n        float f = IntersectCylinder( n, Scene[i], Scene[i+1], pos, ray );\n        if ( f > 0. && f < t )\n        {\n            t = f;\n            normal = n;\n            // todo: remember object index for material lookup\n        }\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tvec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, 50./36. );\n    ray = normalize(ray);\n    \n    vec2 a = vec2(sin(iTime*.313)*.3+.08,iTime*.5);\n\tvec3 cam = 5.*vec3(sin(a.y)*cos(a.x),sin(a.x),cos(a.y)*cos(a.x));\n    vec3 target = vec3(-.5,.5,0);\n    \n    vec3 camk = normalize(target-cam);\n    vec3 cami = normalize(cross(vec3(0,1,0),camk));\n    vec3 camj = cross(camk,cami);\n    \n    ray = ray.x*cami + ray.y*camj + ray.z*camk;\n    \n    vec3 normal = vec3(0);\n    float t = Trace(normal,cam,ray);\n    \n    vec3 col = Sky(ray);\n    if ( length(normal) > 0. )\n    {\n        vec3 sun = normalize(vec3(-1,2,3));\n        vec3 testn = vec3(0);\n        Trace(testn,cam+ray*t,sun);\n        \n        vec3 light = vec3(.05,.065,.09)*(normal.y*.3+1.); // ambient\n        if ( length(testn) == 0. )\n        {\n        \tlight += max(0.,dot(normal,sun)) * vec3(1,.95,.92);\n        }\n        \n        col = light*vec3(1);\n        col *= smoothstep(.01,.02,abs(fract( cam+t*ray+.001 )-.5));\n    }\n    \n    fragColour = vec4(pow(col,vec3(1./2.2)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3cWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[210, 895, 917, 917, 941], [967, 967, 1047, 1047, 2168], [2171, 2171, 2223, 2223, 2591], [2594, 2594, 2652, 2652, 3702]]}
{"id": "MdccDS", "name": "Explore non-primes / multiples", "author": "gbirbilis", "description": "Click or Drag the mouse towards each of the four corners to change scale of X and Y axes.\nPress Play to increase X and/or Y (depending on SPEEDX and SPEEDY which can be zero) offset as frames pass.\n\nTry bottom-right corner for nice moire pattern", "tags": ["primes", "scaling"], "likes": 2, "viewed": 404, "published": "Public API", "date": "1519993494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define INT_MODE //uncomment this for integer mode\n\nconst vec2 SPEED = vec2(.001, .0001); //(SPEEDX, SPEEDY) //try *10 or *100 speed at INT_MODE\nconst vec2 ZERO = vec2(0, 0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 mousexy = iMouse.xy;\n    if (mousexy.xy==ZERO) mousexy = vec2(100.0, 1.0); //aesthetic workarround for total blackness at (0, 0)\n    \n    vec2 p = mousexy * (fragCoord/iResolution.xy + iTime*SPEED);\n  \n#ifdef INT_MODE\n    int c = int(p.x) % int(p.y);\n#else\n    float c = mod(p.x, p.y);\n#endif\n    \n    fragColor = vec4(c);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdccDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 178, 233, 233, 571]]}
{"id": "Mdcczf", "name": "After Burner 2 logo", "author": "indominator", "description": "this is my first try on z pass, i did this based on a game i played a lot, after burner 2 on sega saturn. the rendering in that was probably an array of pixels that would rotate.\n\nthis is my first test on rotation and z position. all done together", "tags": ["3d", "rotationmatrix"], "likes": 2, "viewed": 452, "published": "Public API", "date": "1521492016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(a) vec3(sin(a),cos(a),sin(a))\n\n#define C(a,b) clamp(a,0.,1.)*b\n#define PI 3.14159265358979323844\n\n/////////////////////////////////\n////////circles properties///////\n/////////////////////////////////\n\n\n//const float zcenter = 0.;\n\n///////////////////////////////////\n//////circles is red array////////\n//////////////////////////////////\n\nconst int isred[132] =  int[132]\n    (0,0,0,0,0,0,0,0,0,0,0,0, \t//1\n     0,0,0,0,0,0,0,0,0,0,0,0,\t//2\n     0,0,1,1,1,1,1,1,1,1,0,0,\t//3\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//4\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//5\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//6\n     0,0,0,0,1,0,0,1,0,0,0,0, \t//7\n     0,0,0,0,1,0,0,1,0,0,0,0,\t//8\n     0,0,1,1,1,1,1,1,1,1,0,0,\t//9\n     0,0,0,0,0,0,0,0,0,0,0,0,\t//10\n     0,0,0,0,0,0,0,0,0,0,0,0);\t//11\n\n\n/////////////////////////////////\n////////////functions///////////\n////////////////////////////////\n\n//////////////////////////////////////////// this is to get the direction of the whole batch\nvec3 o_dir = vec3(0.,0.,1.);\nvec3 dir_angle = vec3(0.,0.,0.);\nvec3 rot_angle = normalize(vec3(0.,1.,0.)); \nvec3 get_direction( float angle){\n    \n    float px =\n        o_dir.x* ( cos(angle) + pow(rot_angle.x,2.)*(1. - cos(angle) ) ) \n        +o_dir.y*( rot_angle.y*rot_angle.x* (1. - cos(angle)) + rot_angle.z* sin(angle) ) \n        +o_dir.z*(rot_angle.z*rot_angle.x*(1. - cos(angle)) - rot_angle.y* sin(angle) ) ;\n     float py = \n       o_dir.x*(rot_angle.x*rot_angle.y*(1. - cos(angle)) - rot_angle.z* sin(angle)) \n      +o_dir.y*(cos(angle) +pow(rot_angle.y,2.)*(1. - cos(angle)) )\n      +o_dir.z*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.x* sin(angle));\n     float pz = \n       o_dir.x*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.y* sin(angle)) \n      +o_dir.y*(rot_angle.z*rot_angle.z*(1. - cos(angle)) - rot_angle.x* sin(angle)) \n      +o_dir.z*(cos(angle) +pow(rot_angle.z,2.)*(1. - cos(angle)));\n    \n    return normalize(vec3(px,py,pz));\n    \n}\n\n/////// get position of center\nvec3 center = vec3(0.5,0.5,0.);\nfloat dist_fcenter = 0.;\nvec3 center2 = vec3(0.5,0.5,0.);\nfloat dist_fcenter2 = 0.;\n\nvec3 get_center_position(bool red){\n    if(!red)\n return center + dir_angle*dist_fcenter ;\n    else\n        return center2 + dir_angle*dist_fcenter2 ;\n}\n\nfloat noat = -1223233.4;\n\n/////ZPOS of a single sphere\nvec3 p_scale = vec3(50.,50.,0.);\nfloat radius =22.;   \n\nfloat s_ratio = 0.;\n\nfloat ZPOS_circle\n (int number,  float angle,   vec2 fragCoord, bool red){\n  int y = number/12;\n    int x = number%12;\n    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);\n float px =\n        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) \n        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))\n        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));\n       float py = \n       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) \n      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )\n      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));\n     float pz = \n       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) \n      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) \n      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));\n    \n    /// here recalc radius\n    \n  float  radius2 =  radius + (pz)*s_ratio;\n    \n    \n  \n    \n    \n    ///get X Y and if lenght() < radius\n     \n    if(\n        length (fragCoord - vec2(px ,py) - \n                (red? center2.xy: center.xy)*iResolution.xy  ) < radius2\n        )\n    return pz + center.z;\n        else return noat;\n}\n\n//vec3 p_scale = vec3(20.,20.,20.);\n\nint HighesZ_ofSpheres\n( float angle,   vec2 fragCoord){\n   float Mz = noat;\n    int num = -1;\n    for(int i =0; i < 132; i ++){\n        float tz =  ZPOS_circle( i,angle,fragCoord,isred[i]==0);\n        \n        if(tz != noat &&tz > Mz){Mz = tz; num=i;}\n    }\n        \n   return num;     \n}\n\n////XYZ pos of sphere  ///REMAKE /// INTo NORMAL\nvec3 normal(int number, float angle,vec2 fragCoord){\n int y = number/12;\n    int x = number%12;\n    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);\n float px =\n        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) \n        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))\n        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));\n       float py = \n       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) \n      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )\n      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));\n     float pz = \n       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) \n      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) \n      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));\n    \n  \n  float  radius2 =  radius + (pz)*s_ratio;\n    \n   //this is broken  \n    bool red = (isred[number]==1);\n    \n    vec2 cent = fragCoord - vec2(px ,py) - \n                (red? center2.xy: center.xy)*iResolution.xy;\n    \n     float z =sqrt( pow(radius2,2.) - pow(cent.x,2.) - pow(cent.y,2.));  //1. \n    \n\n    \n    return normalize( vec3(cent,z));\n}\n\n///////////////////////////\n\n\n\n//////////////////////////////////////////////\n//////////////////MAIN ///////////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    \n     float angle = iTime;        //rotation velocity //iTime*algo\n    \n    \n \t dir_angle = get_direction(angle); // rotation angle normalized\n    center = get_center_position(false);\n    center2 = get_center_position(true);\n  \n   int numero = HighesZ_ofSpheres(angle,fragCoord);\n    \n\n    \n    /////////////// COLOR SET//////////////\n     //////////////////////// LIGHT SET////////\n     if(numero > - 1){\n           vec3 normal =  normal(numero,angle,fragCoord);\n          vec3 ldir = (vec3(0.3,0.,1.1));\n          float cosTheta = clamp( dot( normal,ldir ), 0.3,1.0);\n         float  dis =1.- length( ldir - normal )/2. ;\n\n         vec3 light1col = vec3( 1.0, 2.0, 3.0 ); \n          if(isred[numero]==1)fragColor = vec4(1.,0.,0.,1.)* cosTheta;\n        else fragColor = vec4(0.,0.,1.,1.)* cosTheta;\n         \n      fragColor.rgb += light1col * pow( dis, 8.0);\n         \n\n    \n     }\n    \n   \n    \n    \n\n      \n \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdcczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[864, 1064, 1097, 1097, 1936], [1938, 2086, 2121, 2121, 2238], [2266, 2372, 2446, 2446, 3690], [3692, 3729, 3784, 3784, 4017], [4019, 4068, 4120, 4120, 5382], [5415, 5557, 5614, 5614, 6539]]}
{"id": "MdcyWs", "name": "sunglare", "author": "BadBadDog", "description": "simple sunglare example", "tags": ["sunglare"], "likes": 5, "viewed": 199, "published": "Public", "date": "1520554602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float mask = smoothstep( 0.3, 0.31, texture( iChannel0, uv ).x );\n\tmask = 1.0-mask;\n    \n    \n    vec2 sunpos = vec2( sin(iTime*0.2)+1.0, sin(iTime*0.4)+1.0 )*0.5;\n\n    //float sunl = texture( iChannel1, uv ).x;\n    float sunl = 1.0-distance( uv, sunpos );\n    sunl = smoothstep( 0.2, 0.97, pow(sunl,5.0) );\n    float sun = min( mask, smoothstep(0.98,0.99,sunl) );\n    \n    float dy = distance( uv.y,sunpos.y );\n    float dx = distance( uv.x,sunpos.x );\n    float dd = pow(1.0-distance( uv,sunpos ),5.0);\n    \n    float z1 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x,sunpos.y+0.01) ).x );\n    float z2 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x,sunpos.y-0.01) ).x );\n\tfloat sun1 = (z2*0.5+z1*0.5) * smoothstep( 0.98, 0.99, 1.0-distance(uv.x,sunpos.x) ) * dd;\n    \n    \n    float q1 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x-0.01,sunpos.y-0.01) ).x );\n    float q2 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x+0.01,sunpos.y-0.01) ).x );\n\tfloat sun2 = (q2*0.5+q1*0.5) * smoothstep( 0.97, 0.99, 1.0-distance(uv.y+dx,sunpos.y) ) * dd;\n\n    float w1 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x-0.01,sunpos.y+0.01) ).x );\n    float w2 = 1.0-smoothstep( 0.3, 0.35, texture( iChannel0, vec2(sunpos.x+0.01,sunpos.y+0.01) ).x );\n\tfloat sun3 = (w2*0.5+w1*0.5) * smoothstep( 0.97, 0.99, 1.0-distance(uv.y-dx,sunpos.y) ) * dd;\n\n    \n    float sunadd = pow(sunl,2.0)*(z2*0.2+z1*0.2+q2*0.2+q1*0.2+w2*0.2+w1*0.2)*0.7 + (sun1+sun2+sun3)*0.3;\n    //sunadd = pow(sunadd,5.0 );\n    \n //   sun = max( sun, sun1 );\n  //  sun = max( sun, sun2 );\n   // sun = max( sun, sun3 );\n    \n    float cld = (smoothstep( 0.3, 0.5, texture( iChannel0, uv ).x ))*0.5;\n    float cll = dd * (1.0-smoothstep( 0.3, 0.5, texture( iChannel0, uv ).x ))*(1.0-mask);\n    \n    float col = sun*0.5 + sunadd*0.9;\n    \n    vec3 sky = vec3( 0.0, 0.5, 0.7 );\n    vec3 skc = vec3( 0.0, 0.0, 0.0 );\n    skc = mix( skc, vec3(3.5)*(cll*3.0+cld), cld );\n    skc = mix( skc, vec3(1.0), col );\n    sky = skc+col*0.3 + sky*smoothstep( 0.9,0.0,skc );\n    \n    // Output to screen\n    fragColor = vec4( sky, 1.0 );\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 2337]]}
{"id": "MddcDB", "name": "Sometimes It Snows In April", "author": "Del", "description": "Sometimes It Snows In April", "tags": ["raymarch", "sdf", "snow", "twist", "symbol", "bend"], "likes": 7, "viewed": 587, "published": "Public API", "date": "1520123733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sometimes It Snows In April - Del 04/03/2018\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    mouse = vec2(0.0);\n    float an = 10.0*mouse.x;\n\tcamPos = vec3(1.2*sin(an),0.3+mouse.y*2.0,1.2*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n#define PI 3.141592\n#define\tTAU 6.28318\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// simple bend(Y) mod\nvec2 opBendTest( vec2 p, float angle, float xmod )\n{\n    p.x += xmod;\n    p = rotate( angle * p.x ) * p.xy;\n    p.x -= xmod;\n    return p;\n}\n// simple spriral(x) mod\nfloat spiral(vec2 p, float sa, float b)\n{\n  float a = atan(p.y, p.x);\n  float l = length(p);\n  float n = (log(l/sa)/b - a) / (2.*PI);\n  float upper_ray = sa * exp(b *(a + 2.*PI*ceil(n)));\n  float lower_ray = sa * exp(b *(a + 2.*PI*floor(n)));\n  return min(abs(upper_ray - l), abs(l-lower_ray));\n}\n\n// 2D-shapes (Trapezoid, Ring, Box, Triangle)\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y < 0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat ring(vec2 uv, float rad, float thickness)\n{\n    return abs(rad - length(uv)) - thickness;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n\treturn min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}    \n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat NewSymbol(vec2 uv)\n{\n    vec2 p = uv+vec2(0.27,0.09);\n\tfloat s1 = length(p)-0.2;\t\t\t\t\t\t// circle1\n  \tfloat s2 = length(p+vec2(-0.22,-0.01))-0.18;\t// circle2\n\tp.x = spiral(p.xy, PI*0.5, -0.33);\t\t\t\t// Spiral distort\n    float d = sdTrapezoid(p,0.015,0.015,0.08);\t\t// could just be a box...\n\td = max(d, s1);\t\t\t\t\t\t\t\t\t// subtract circle\n\td = max(d,-s2);\t\t\t\t\t\t\t\t\t// subtract circle\n\n    p = vec2(abs(uv.x),uv.y);\n    //d = min(d,sdTriangle(vec2(-0.155,0.1),vec2(-0.055,0.1),vec2(-0.105,0.05),p.yx)); // mid-cross tri\n    d = min(d, sdTrapezoid(p.yx+vec2(0.105,-0.075),0.0,0.05,0.025));   \t\t\t// mid-cross trapeziod!\n    d = min(d,sdBox(p+vec2(-0.05,0.105),vec2(0.025,0.025)));\t\t\t\t\t\t// mid-cross bar\n    d = min(d,sdTriangle(vec2(0.0, -0.425),vec2(0.1, -0.25),vec2(-0.025, -0.35),p.xy)); // bottom triangle\n    \n\tp = opBendTest(uv+vec2(0.16, -0.088),radians(77.0),-0.103);\n    d = smin(d, sdTrapezoid(p.yx,0.018,0.025,0.19), 0.012); // bent arm (attempted to smooth the join, needs work)\n\n    d = min(d,sdBox(uv+vec2(0.0,0.13),vec2(0.032,0.2)));\t// main body\n    d = min(d,sdBox(uv+vec2(-0.08,-0.085),vec2(0.09,0.025))); // horn1 (bar)\n\n    float cuts = length( uv+vec2(-0.17,-0.32))-0.21;\n    cuts = min(cuts,length( uv+vec2(-0.17,0.15))-0.21);\n    cuts = min(cuts,length( uv+vec2(-0.73,-0.085))-0.4);\n    p = uv+vec2(-0.26,-0.085);\n    d = min(max(sdTrapezoid(p.yx,0.025,0.13,0.09),-cuts),d); // horn2 (cutout)\n    \n    d = smin(d,ring(uv+vec2(0.0,-0.26),0.13,0.028),0.01);\t\t\t// top-ring\n    \n    \n    return d;\n}\n\n\n// signed box distance field\n//float sdBox(vec3 p, vec3 radius)\n//{\n//  vec3 dist = abs(p) - radius;\n//  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n//}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    p.y += 0.5;\n    float scale = sin(iTime*1.25)*0.15;\n    \n    float  c = cos(scale*p.y+scale);\n    float  s = sin(scale*p.y+scale);\n    mat2   m = mat2(c,-s,s,c);\n    p = vec3(m*p.zy,p.x);\n    p.y -= 0.5;\n    return p;\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2( sdPlane(p+vec3(0.0,0.45,0.0)), 1.0);\t// floor...\n    \n    float t1 = fract(iTime*0.15)*TAU;\n    float t2 = fract(iTime*0.31)*TAU;\n    \n    vec3 r1 = rotateY(p,t1)\t;//iTime*0.8);\n    if (iMouse.w>0.5)\n    {\n\t\tr1 = rotateY(r1, sin(t2+p.y*1.25));\n    \tr1 = opTwist(r1);\n    }\n    \n\tfloat symbolDist = NewSymbol(r1.xy);\n    float dep = 0.02;\n    vec2 e = vec2( symbolDist, abs(r1.z) - dep );\n    symbolDist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    symbolDist -= 0.01;        \n\n    res = opU(res,vec2(symbolDist,2.0));\n    return res;\n}\n\n//------------------------------------------------------------------------\n// Material \n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\nvec3 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        float f = mod( floor(1.5*pos.z) + floor(1.5*pos.x), 2.0);\n        vec3 col = 0.2 + 0.2*f+0.2*vec3(0.8,0.05,0.8);\n\t    return col;\n    }\n    return vec3(0.15,0.03,0.22);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.4,0.35,0.7));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    float _s = 1.5;\n\tfloat spec = pow(dif, 160.0) *_s;\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n        col+=spec;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 30.0;           // max trace distance\n\tconst float precis = 0.0001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<120; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h*0.75;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 50.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n//snow original -> http://glslsandbox.com/e#36547.1\nfloat snow(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n\tuv+=time/scale;\n    uv.y+=time*2./scale;\n    uv.x+=sin(uv.y+time*.5)/scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\n\nvec3 _Snow(vec2 uv,vec3 background)\n{\n\tfloat c = snow(uv,30.)*.3;\n\tc+=snow(uv,20.)*.5;\n\tc+=snow(uv,15.)*.8;\n\tc+=snow(uv,10.);\n\tc+=snow(uv,8.);\n\tc+=snow(uv,6.);\n\tc+=snow(uv,5.);\n    c = clamp(c,0.0,1.0);\n    vec3 scol = vec3(1.0,1.0,1.0);\n    scol = mix(background,scol,c);\n\treturn scol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // debug SVG\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    //return;\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\t//vec3 col = doBackground();\n  \tvec3 col = vec3(0.05);\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n\tcol = _Snow(p*0.5,col);\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 208, 289, 289, 432], [434, 599, 624, 624, 639], [681, 681, 703, 703, 770], [772, 772, 813, 813, 906], [908, 930, 982, 982, 1070], [1071, 1096, 1137, 1137, 1392], [1394, 1440, 1464, 1464, 1483], [1484, 1484, 1549, 1549, 1873], [1875, 1875, 1924, 1924, 1972], [1974, 1974, 2012, 2012, 2091], [2097, 2133, 2200, 2200, 2809], [2811, 2811, 2837, 2837, 4323], [4326, 4512, 4542, 4542, 4575], [4577, 4577, 4601, 4601, 4825], [4828, 4828, 4859, 4859, 4965], [4966, 4966, 4997, 4997, 5104], [5105, 5105, 5136, 5136, 5242], [5246, 5246, 5270, 5270, 5832], [5834, 6051, 6104, 6104, 6330], [6332, 6543, 6627, 6627, 7301], [7303, 7303, 7352, 7352, 7931], [7933, 7933, 7965, 7965, 8385], [8387, 8387, 8435, 8435, 8863], [8865, 8865, 8929, 8929, 9107], [9109, 9161, 9194, 9194, 9542], [9545, 9545, 9582, 9582, 9833], [9836, 9836, 9893, 9985, 11280]]}
{"id": "MddyWX", "name": "Confetti canon", "author": "Flopine", "description": "J - 23 !", "tags": ["raymarching", "repeat", "cosinepalette"], "likes": 32, "viewed": 4079, "published": "Public API", "date": "1520433491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind and leon for teaching me :)\n\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nmat2 rot (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\n\n// iq's palette http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos(TAU*(c*t+d));\n}\n\n\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    return length(max(abs(p)-c,0.));\n}\n\nfloat prim (vec3 p)\n{\n    float b = box(p, vec3(1.));\n    float s = sphe(p,1.3);\n    return max(-s, b);\n}\n\nfloat row (vec3 p, float per)\n{\n\tp.y = mod(p.y-per/2., per)-per/2.;\n    return prim(p);\n}\n\nfloat squid (vec3 p)\n{\n    p.xz *= rot(PI/2.);\n    p.yz = moda(p.yz, TAU/5.);\n    p.z += sin(p.y+iTime*2.);\n    return row(p,1.5);\n}\n\nfloat SDF(vec3 p)\n{\n    p.xz *= rot (iTime*.8);\n    p.yz *= rot(iTime*0.2);\n    p.xz = moda(p.xz, TAU/12.);\n    return squid(p);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3 (0.01,3.,-8.);\n    vec3 dir = normalize(vec3(uv*2.,1.));\n    \n    float shad = 1.;\n    \n    for (int i=0;i<60;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = float(i)/60.;\n            break;\n        }\n        p += d*dir*0.5;\n    }\n    \n    vec3 pal = palette(p.z,\n        \t\t\t\tvec3(0.5),\n                      vec3(0.5),\n                      vec3(.2),\n                      vec3(0.,0.3,0.5)\n                      );\n    // Time varying pixel color\n    vec3 col = vec3(1.-shad)*pal;\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddyWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 108, 128, 128, 201], [204, 204, 235, 235, 360], [362, 439, 511, 511, 548], [551, 551, 581, 581, 607], [609, 609, 637, 637, 676], [678, 678, 699, 699, 783], [785, 785, 816, 816, 874], [876, 876, 898, 898, 1008], [1010, 1010, 1029, 1029, 1140], [1144, 1144, 1201, 1251, 1956]]}
{"id": "Mddyzl", "name": "blue Sky", "author": "SourceW", "description": "2D sky", "tags": ["2d", "sun", "clouds", "sky", "blue"], "likes": 1, "viewed": 464, "published": "Public API", "date": "1519873437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\n\nvec4 calc_clouds( vec2 p) {\n\n\nvec2 uv = p*5.0;\n\tuv.x += iTime * 1.0;\n\n\tuv.y *= 0.75;\n\tfloat n  = noise(uv * vec2(0.5, 1.0)) * 0.5;\n\t\tuv += vec2(n * 0.5, 0.3) * 1.2; uv *= 2.50;\n\t\t  n += noise(uv) * 0.25;\n\t\tuv += vec2(n * 1.2, 0.2) * -1.2+ vec2(iTime * 0.01, 0.2); uv *= 3.01;\n\t\t  n += noise(uv) * 0.105;\n\t\tuv += vec2(n * 0.4, 0.1) *1.0 + vec2(iTime * 0.03, 0.1); uv *= 3.02;\n\t\t  n += noise(uv) * 0.06;\n\tn = smoothstep(0.0, 0.8, n);\n\n\treturn vec4(n);\n}\n\nfloat sun(float x,float y,float t){\n   float xx  =x + sin(t);\n   float yy = y + cos(t);\n   return 1.0/sqrt(xx*xx+yy*yy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   vec2 p =(fragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);\n\n   float a = sun(p.x,p.y,time);\n    \n   vec4 sun = vec4(2.0,2.0,0.2,1.0)*(a/10.0);\n   \n   vec4 sky = vec4(0.23,0.42,1.0,1.0);\n   \n   vec2 p2 = fragCoord.xy / iResolution.xy;\n   vec4 c = calc_clouds(p);\n\n   fragColor = sky+c;mix(sky,c,c.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mddyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 199], [201, 201, 227, 227, 682], [686, 686, 713, 713, 1137], [1139, 1139, 1174, 1174, 1261], [1263, 1263, 1320, 1320, 1648]]}
{"id": "MdGcD1", "name": "Blades", "author": "dr2", "description": "All done with magnets :)", "tags": ["geometry", "movement"], "likes": 3, "viewed": 423, "published": "Public API", "date": "1521801838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Blades\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, t, w;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 0.1);\n  DMINQ (4);\n  for (int k = 0; k < 3; k ++) {\n    q = p;\n    if (k == 1) q.xy = Rot2D (q.xy, 0.5 * pi);\n    else if (k == 2) q.yz = Rot2D (q.yz, -0.5 * pi);\n    d = PrTorusDf (q.xzy, 0.04, 2.);\n    DMINQ (4);\n    t = 1.5 * tCur;\n    if (k == 1) t += (2./3.) * pi;\n    else if (k == 2) t += (4./3.) * pi;\n    q.xz = Rot2D (q.xz, t);\n    w = q.x + 0.5 * abs (q.z) + 0.07;\n    d = max (max (PrCylDf (q.xzy, 1.93, 0.03 * (0.1 + 0.9 * min (1., -10. * w))), w),\n       0.2 - length (q.xz + vec2 (1.2, 0.)));\n    DMINQ (k + 1);\n  }\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = 32. / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk));\n  }\n  return qBlk;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  return vec3 (0.9, 0.9, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltPos[4], ltCol[4], ltDir, dfSumC, spSumC, col, vn;\n  vec2 qBlk;\n  float dstObj, dfSum, spSum, at, t;\n  ltPos[0] = 5. * vec3 (1., 1., 1.);\n  ltPos[1] = 5. * vec3 (-1., 1., -1.);\n  ltPos[2] = 5. * vec3 (1., -1., -1.);\n  ltPos[3] = 5. * vec3 (-1., -1., 1.);\n  t = 0.4 * tCur;\n  for (int k = 0; k < 4; k ++) {\n    ltPos[k].xy = Rot2D (ltPos[k].xy, t);\n    ltPos[k].yz = Rot2D (ltPos[k].yz, t);\n    ltPos[k].zx = Rot2D (ltPos[k].zx, t);\n  }\n  ltCol[0] = vec3 (1., 1., 0.3);\n  ltCol[1] = vec3 (1., 0.3, 0.3);\n  ltCol[2] = ltCol[1].zxy;\n  ltCol[3] = ltCol[1].yzx;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = ltCol[0];\n    else if (idObj == 2) col = ltCol[1];\n    else if (idObj == 3) col = ltCol[2];\n    else if (idObj == 4) col = ltCol[3];\n    if (idObj < 4) {\n      qBlk = step (0.1, mod (0.6 * BlkHit (ro, reflect (rd, vn)) + 0.1/2., 1.));\n      col4 = vec4 (col, 0.5) * mix (0.5 * mix (1., 0.7 + 0.3 * qBlk.x * qBlk.y,\n         1. - smoothstep (0.5, 0.7, - dot (rd, vn))), 1., \n         0.5 + 0.5 * SmoothBump (0.3, 0.7, 0.01, mod (4. * length (qHit.xz), 1.)));\n    } else col4 = vec4 (col * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1,\n       mod (128. * atan (qHit.z, qHit.x) / pi, 1.))), 0.5);\n    dfSum = 0.;\n    spSum = 0.;\n    dfSumC = vec3 (0.);\n    spSumC = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.7, 0.8, dot (normalize (ltPos[k] - ro), ltDir));\n      t = at * max (dot (vn, ltDir), 0.);\n      dfSum += t;\n      dfSumC += ltCol[k] * t;\n      t = at * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n      spSum += t;\n      spSumC += ltCol[k] * t;\n    }\n    col = mix (col4.rgb * (0.05 + 0.7 * dfSum) + 0.1 * spSum,\n       0.05 + 0.5 * dfSumC + 0.1 * spSumC, col4.a);\n  } else {\n    col = BgCol (rd);\n    qBlk = step (0.1, mod (0.5 * BlkHit (ro, rd) + 0.1/2., 1.));\n    col *= 0.95 + 0.05 * qBlk.x * qBlk.y;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el += 0.2 * pi * sin (0.04 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -8.);\n  rd = vuMat * normalize (vec3 (uv, 3.5));\n  dstFar = 25.;\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGcD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 463, 485, 485, 1116], [1118, 1118, 1151, 1151, 1328], [1330, 1330, 1351, 1351, 1551], [1553, 1553, 1585, 1585, 2071], [2073, 2073, 2095, 2095, 2169], [2171, 2171, 2206, 2206, 4226], [4228, 4228, 4284, 4284, 5189], [5191, 5191, 5224, 5224, 5251], [5253, 5253, 5295, 5295, 5346], [5348, 5348, 5394, 5394, 5451], [5453, 5453, 5510, 5510, 5593], [5595, 5595, 5625, 5625, 5683]]}
{"id": "MdGczW", "name": "mandelbulb", "author": "xxyxxy", "description": "cross-section of power eight", "tags": ["fractal"], "likes": 1, "viewed": 238, "published": "Public API", "date": "1521163809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INFINITY 10.0\n#define MAX_ITERATIONS 128\n\n//http://www.skytopia.com/project/fractal/mandelbulb.html\nint mandel(float x0, float y0, float z0) {\n    float x;\n    float y;\n    float z;\n    float r;\n    float theta;\n    float phi;\n    float xnew;\n    float ynew;\n    float znew;\n    \n    x = x0; y = y0; z = z0;\n    \n    // play with this\n    float n = 8.0;\n\n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        \n        r = sqrt(x*x + y*y + z*z);\n        theta = atan(sqrt(x*x + y*y), z);\n        phi = atan(y, x);\n        \n        xnew = x0 + pow(r, n) * sin(theta * n) * cos(phi * n);\n        ynew = y0 + pow(r, n) * sin(theta * n) * sin(phi * n);\n        znew = z0 + pow(r, n) * cos(theta * n);\n        \n        if (xnew*xnew + ynew*ynew + znew*znew > INFINITY) {\n            return i;\n        }\n        \n        x = xnew;\n        y = ynew;\n        z = znew;\n    }\n        \n    return MAX_ITERATIONS;\n}\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float x = fragCoord.x / iResolution.x;\n    float y = fragCoord.y / iResolution.y;\n    x = 2.0*x - 1.0;\n    y = 2.0*y - 1.0;\n    float z;\n    float t;\n            \n    fragColor = vec4(0.0);\n    \n    // regular\n    z = sin(0.5 * iTime);\n    t = float(mandel(x, y, z)) / float(MAX_ITERATIONS);            \n    fragColor.rgb += palette(0.5+0.5*cos(iTime), vec3(0.8,0.5,0.4),vec3(0.4,0.2,0.4),vec3(1.0,2.0,1.0),vec3(0.0,0.25,0.25) );\n    if (t < 1.0) {\n        fragColor.rgb *= 0.8;\n    }\n    \n    \n    // upside down and backwards... ish\n\tz = cos(0.5 * iTime);\n    t = float(mandel(y, x, z)) / float(MAX_ITERATIONS);            \n  \tfragColor.rgb += palette(0.5+0.5*sin(iTime), vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    if (t < 1.0) {\n        fragColor.rgb *= 0.4;\n    }       \n\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 108, 150, 150, 912], [914, 978, 1050, 1050, 1093], [1095, 1095, 1152, 1152, 1999]]}
{"id": "MdKcDh", "name": "Mandelbrot Zoom by zakrent", "author": "zakrent", "description": "Simple Mandelbrot set visualization with zoom.", "tags": ["mandelbrot", "zoom"], "likes": 1, "viewed": 63, "published": "Public", "date": "1521894536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0/exp(iTime/3.0);\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 initialValue = (uv-0.5)*3.0*zoom+vec2(\n        -0.36,\n        0.636005\n    );\n    vec2 currentValue = initialValue;\n    \n    float i;\n    for(i = 0.0; i < 2000.0; i++){\n        currentValue = mat2(currentValue,-currentValue.y,currentValue.x ) * currentValue + initialValue;\n        if(length(currentValue) > 2.0){\n            break;\n        }\n    }\n   \n    if(i >= 2000.0){\n        fragColor = vec4(1.0);\n    }\n    else{\n        fragColor = vec4(\n            min(i/500.0, 1.0), \n            max(1.0-(i/200.0), 0.0),\n            0.0,\n            1.0\n        );\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 715]]}
{"id": "MdKcDR", "name": "hierarchy - roll ( 214 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["kifs", "2tweets", "short", "golf"], "likes": 3, "viewed": 362, "published": "Public API", "date": "1521651356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://www.shadertoy.com/view/MdVyDR and https://shadertoy.com/view/MdVyDR \n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( vec2 R = iResolution.xy, U = ( u+u - R ) / R.y, V,\n               A = 4./(1.+sin(iTime)) +R-R;\n          V = pow(U=abs(R=U),A), O.w++<9. && pow(V+V.y,1./A).x<1.;\n          O += vec4(.11,.14,.2,0)\n        ) U = sign(R)*(U/.4-1.) * mat2(cos( iTime + vec4(0,55,33,0))); } \n        \n        \n\n        \n        \n/** // 223 chars\n\n#define mainImage(O,u)                                               \\\n    float a = 4./(1.+sin(iTime));                                    \\\n    for ( vec2 R = iResolution.xy, U = (u+u-R) / R.y;                \\\n          O.w++<9. && pow(pow(abs(U.x),a)+pow(abs(U.y),a),1./a)<1. ; \\\n          O += vec4(.11,.14,.2,0)                                    \\\n        ) U = sign(U)*(abs(U)/.4-1.) * mat2(cos( iTime + vec4(0,55,33,0))) \n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 128, 128, 407]]}
{"id": "MdKczD", "name": "Voronoi Rings", "author": "metabog", "description": "Mouse controlled.\n\nI can't really explain what's going on here, but it sure looks cool. I tried implementing my first ever voronoi shader by generating some random points and getting the nearest one for each pixel, and then I added some trig and... ", "tags": ["trigonometry", "voronoin", "knn"], "likes": 7, "viewed": 134, "published": "Public", "date": "1521328008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//wang from https://www.shadertoy.com/view/ldjczd\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\nvec2 pointgen(uint i)\n{\n    return vec2(wang(i), wang(i+10000u));\n}\n\n#define MAXPOINTS 512u\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y*=(iResolution.y/iResolution.x);\n    \n    uint minknn = MAXPOINTS;\n    float minval = 100000.0;\n        \n    float parameter1 = iMouse.x/iResolution.x;\n    float parameter2 = iMouse.y/iResolution.y + 1.0;\n    \n    uint escape = 128u;\n    \n    if(parameter1>0.0)\n        escape = uint(parameter1*parameter1*512.0f);\n    \n    for(uint i = 0u; i<MAXPOINTS; i++)\n    {\n        vec2 pos = pointgen(i);\n        pos = cos(pos*(iTime*0.05+16.0));\n        float len = cos(length(pos-uv)*parameter2*3.0 + parameter1*2.0); \n        if(len<minval)\n        {\n            minval = len;\n            minknn = i;\n        }\n        \n        if(i>escape)\n            break;\n    }\n\n    // Time varying pixel color\n    vec3 col = vec3(pointgen(minknn),1.0);\n\tcol = clamp(col+vec3(0.1),0.0,1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 70, 70, 330], [332, 332, 355, 355, 399], [425, 425, 482, 537, 1416]]}
{"id": "MdKczh", "name": "Underwater structure", "author": "Flopine", "description": "J - 15 !!", "tags": ["raymarching", "shapes", "training"], "likes": 8, "viewed": 287, "published": "Public", "date": "1521070576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon and lsdlive for teaching me ! :)\n\n\n#define ITER 80.\n#define PI 3.141592\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// iq's palette\nvec3 palette(float t,vec3 a, vec3 b, vec3 c, vec3 d)\n{\n\treturn a+b*cos(2.*PI*(c*t+d));    \n}\n\nfloat sc (vec3 p, float s)\n{\n p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-s;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    return length(max(abs(p)-c,0.));\n}\n\nfloat cyl (vec2 p, float r)\n{\n\treturn length(p)-r;    \n}\n\nfloat sphe (vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat wcube (vec3 p, float s)\n{\n    return max(-sc(p,s), box(p, vec3(s+0.09)));\n}\n\nfloat prim1 (vec3 p, float per)\n{\n    p.xz *= rot(p.y);\n    p.y = mod(p.y-per/2.,per)-per/2.;\n    \n    return wcube(p,.3);\n}\n\nfloat prim2 (vec3 p, float per)\n{\n    float c = cyl(p.xz,0.1);\n    p.y -= tan(iTime);\n    p.y = mod(p.y-per/2.,per)-per/2.;\n\n    float s = sphe(p, 0.2);\n    return min(c,s);\n}\n\nfloat elevators (vec3 p, float per)\n{\n    p.z = mod(p.z-per/2.,per)-per/2.;\n    p.xz = moda(p.xz, (2.*PI)/4.);\n    p.x -= sin(iTime)+3.;\n    return min(prim1(p,0.7),prim2(p,0.8));\n}\n\nfloat hex (vec3 p, float per)\n {\n     p.z = mod(p.z-per/2.,per)-per/2.;\n     p.xy *= rot(iTime);\n    p.xy = moda(p.xy, (2.*PI)/6.);\n    p.x -= 2.;\n    return min(prim1(p,0.7),prim2(p,0.8));\n} \n\n\nfloat SDF (vec3 p)\n{\n\n    return min(elevators(p,6.), hex(p,3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 p = vec3(0.001,.001,iTime*0.5);\n    vec3 dir = normalize(vec3(uv,1.));\n    \n    float shad = 0.;\n    vec3 col = vec3(0.);\n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {shad = i/ITER;\n         col = vec3(1.-shad)*palette(p.z*2.,\n                                    vec3(0.,0.3,0.7),\n                                    vec3(0.2,0.3,0.3),\n                                    vec3(.2),\n                                    vec3 (0.,0.2,iTime*0.5));\n         break;\n        }\n        else col = palette(length(uv),\n                          vec3 (0.,0.1,0.7),\n                           vec3(0.,0.5,0.3),\n                           vec3 (0.3),\n                           vec3(0.5));\n        p += d*dir*0.7;\n    }\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 118, 137, 137, 210], [212, 212, 243, 243, 360], [362, 378, 432, 432, 470], [472, 472, 500, 500, 573], [575, 575, 603, 603, 642], [644, 644, 673, 673, 700], [702, 702, 732, 732, 758], [760, 760, 791, 791, 841], [843, 843, 876, 876, 967], [969, 969, 1002, 1002, 1144], [1146, 1146, 1183, 1183, 1327], [1329, 1329, 1361, 1361, 1520], [1524, 1524, 1544, 1544, 1591], [1593, 1593, 1650, 1700, 2635]]}
{"id": "MdKyRw", "name": "kaleidoscopic iterative function", "author": "wyatt", "description": "many thanks to iq and his tutorials ", "tags": ["raymarching", "kifs"], "likes": 75, "viewed": 4215, "published": "Public API", "date": "1521493742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 light;\nfloat ui;\nmat2 m,n,nn;\nfloat map (vec3 p) {\n    float d = length(p-light.xyz)-light.w;\n    d = min(d,max(10.-p.z,0.));\n    float t = 2.5;\n    for (int i = 0; i < 13; i++) {\n        t = t*0.66;\n        p.xy = m*p.xy;\n        p.yz = n*p.yz;\n        p.zx = nn*p.zx;\n        p.xz = abs(p.xz) - t;\n\n    }\n    d = min(d,length(p)-1.4*t);\n\n    return d;\n}\nvec3 norm (vec3 p) {\n    vec2 e = vec2 (.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\nvec3 dive (vec3 p, vec3 d) {\n    for (int i = 0; i < 20; i++) {\n        p += d*map(p);\n    }\n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = fragCoord/iResolution.xy*2.-1.;\n\tv.x *= iResolution.x/iResolution.y;\n    ui = 100.*iTime;\n    float y = -0.001*ui;\n    m = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0035*ui;\n    n = mat2(sin(y),cos(y),-cos(y),sin(y));\n    y = 0.0023*ui;\n    nn = mat2(sin(y),cos(y),-cos(y),sin(y));\n    vec3 r = vec3(0,0,-15.+2.*sin(0.01*ui));\n    light = vec4(10.*sin(0.01*ui),2,-23,1);\n    vec3 d = normalize(vec3(v,5.));\n    vec3 p = dive(r,d);\n    d = normalize(light.xyz-p);\n    vec3 no = norm(p);\n    vec3 col = vec3(.7,.8,.9);\n    vec3 bounce = dive(p+0.01*d,d);\n    col = mix(col,vec3(0),dot(no, normalize(light.xyz-p)));\n    if (length(bounce-light.xyz) > light.w+0.1) col *= 0.2;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 360], [361, 361, 381, 381, 557], [558, 558, 586, 586, 666], [667, 667, 724, 724, 1448]]}
{"id": "MdKyzw", "name": "electric grid", "author": "laserdog", "description": "Testing an effect for an RTS game i'm working on. Borrowed some ideas from srtuss' digital brain.", "tags": ["game"], "likes": 15, "viewed": 468, "published": "Public", "date": "1521504015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\tfloat minDistance = 1.;\n    \n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n            vec2 rand = .5 + .5 * sin(iTime * 3. + 12. * rand2(p + b));\n\t\t\tvec2 r = vec2(b) - f + rand;\n\t\t\tminDistance = min(minDistance, length(r));\n\t\t}\n\t}\n\treturn minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n\tvec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float val = pow(voronoi(uv * 8.) * 1.25, 7.) * 2.;\n    float gridLineThickness = 2. / iResolution.y;\n    vec2 grid = step(mod(uv, .1), vec2(gridLineThickness));    \n\n    fragColor = vec4(0., val * (grid.x + grid.y), 0., 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 115], [117, 117, 143, 143, 487], [489, 489, 546, 546, 873]]}
{"id": "MdtcD2", "name": "Face e Heart", "author": "GuntherRox", "description": "tests", "tags": ["smileyface"], "likes": 0, "viewed": 59, "published": "Public", "date": "1520834121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nbool circle (vec2 uv, vec2 p, float radius)\n{\n    \tfloat dist = sqrt((uv.x - p.x) * (uv.x -p.x) + (uv.y - p.y) * (uv.y - p.y)); \n    \tif (dist < radius) \n            return true;\n    \telse return false; \n    \n    \n}\n\n\nvec4 heart(vec2 p, vec2 cen, float rad) { \n    \n    vec2 relative = p-cen; //relative position\n    float a = atan(relative.x, relative.y)/3.141593; //angle \n    float r = a*rad; //radius \n    float t;\n    float step = 1.0; \n    \n    if(relative.x > 0.0){\n        //right area \n       \n        float d = length(p-cen)-r*1.5; \n        t = smoothstep (0.5, step, d); \n        \n    }else{ \n        //left area\n        \n        float d = length(p-cen)-r*-1.5;\n        t = smoothstep (0.0, step, d);\n        \n    } \n    \n    return vec4(0.9,0.3,0.5,1.0-t);    //color\n    \n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= .5;\t\t\t\t//-0.5 < > 0.5\n\tuv.x *= iResolution.x/iResolution.y; \n    \n    vec2 center = vec2(0., 0.);\n    \n //heart \n    \n    \n    vec3 col = vec3(0.); \n    vec2 center1 = vec2(0.5, 0.8); \n  \n  \tvec4 heartColor = heart(fragCoord, center1.xy*iResolution.xy, 200.);\n    vec4 temp = vec4(col,1.0); \n    fragColor = mix(temp, heartColor,heartColor.a);\n\n\n    \n //green circle \n    \n    float radiusGreen = 0.22;\n       \n    bool isInGreenCircle = circle(uv,center, radiusGreen); \n    if (isInGreenCircle) fragColor = vec4 (0, 1, 0, 1); \n\n//yellow circle\n    \n    float radius = 0.2;\n\t\n\t\n\tbool isInCircle = circle(uv, center, radius); \n\tif (isInCircle) fragColor = vec4(1,1,0,1);\n\n// Mouth Draw \n    \n   vec2 mouthCenter1 = vec2(0., -0.09); \n   vec2 mouthCenter2 = vec2(0.,-0.06); \n    \n   float mouthRadius1 = 0.07 * (1.0 + sin(iTime)) * 0.4;\n   float mouthRadius2 = 0.06 * (1.0 + sin(iTime)) * 0.4;\n\t\n   bool isInMouth1 = circle(uv, mouthCenter1, mouthRadius1);\n   if (isInMouth1) fragColor = vec4(0, 1, 6, 3);\n    \n   bool isInMouth2 = circle(uv, mouthCenter2, mouthRadius2);\n   if (isInMouth2)fragColor = vec4(1, 1, 0, 1);\n    \n// Eyes Draw\n    \n    vec2 leftEye1 = vec2 (-0.09, 0.06);\n    vec2 rightEye2 = vec2 (0.09, 0.06);\n\n\tfloat leftEyeRadius1 = 0.1 * (1.0 + sin(iTime)) * 0.9;\n    float rightEyeRadius2 = 0.1 * (1.0 + sin(iTime)) * 0.9;\n    \n    bool isInlEye = circle (uv, leftEye1, leftEyeRadius1);\n    if (isInlEye) fragColor = vec4 (sin(iTime),0,0,1);\n\n\tbool isInrEye = circle (uv, rightEye2, rightEyeRadius2);\n    if  (isInrEye) fragColor = vec4 (sin(iTime),0,0,1); \n    \n //heart\n    \n    \n}   ", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 46, 46, 216], [219, 219, 260, 260, 787], [790, 790, 846, 846, 2508]]}
{"id": "MdtyDl", "name": "floating away", "author": "stellabialek", "description": "spheretraced dancing blob guys inside raytraced spheres", "tags": ["raytracing", "motionblur", "dof", "spheretracing", "blending"], "likes": 10, "viewed": 222, "published": "Public", "date": "1520681996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float PIHALF = PI / 2.0;\nconst float EPSILON = 0.00001;\nconst float INFINITY = 1000000000.0;\n\nconst int MOTIONBLURSAMPLES = 4;\nconst float MOTIONBLURDELTA = 0.01;\nconst int DOFSAMPLES = 4;\nconst float DOFDELTA = 0.01;\n\nconst float FOCUS = 4.0;\n\nconst int NUMLAYERS = 4;\nconst float[4] LAYERS = float[4](2.0, 4.0, 6.0, 12.0);\n\nconst vec3 ORB = vec3(0.9, 0.4, 0.0);\nconst vec3 GLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 BG = vec3(0.0, 0.1, 0.1);\n\nconst vec2 FOG = vec2(8.0, 20.0);\nconst vec3 MOVEMENT = vec3(0.2,-0.4,0.0);\n\nstruct ray{ vec3 o; vec3 d; };\nstruct result{ float t; vec3 n; };\n\nstruct sphere{ vec3 c; float r; };\nstruct plane{ vec3 n; float d; };\n\nvec3 getRayDirection(vec2 pos, vec2 res, float fov)\n{\n\tfloat fx = tan(radians(fov) * 0.5) / res.x;\n\tvec2 d = (2.0 * pos - res) * fx;\n\treturn normalize(vec3(d, 1.0));\n}\n\nresult intersectPlane(ray r, plane pl)\n{\n\tresult res;\n\tres.t = -INFINITY;\n\n\tfloat d = dot(pl.n, r.d);\n\tif(abs(d) < EPSILON)\n\t\treturn res;\n\tres.t = (-pl.d - dot(pl.n, r.o)) / d;\n\tres.n = pl.n;\n\treturn res;\n}\n\nresult intersectSphere(ray r, sphere s)\n{\n\tresult res;\n\tres.t = -INFINITY;\n\t\n\tvec3 v = r.o - s.c;\n\tfloat vd = dot(v, r.d);\n\tfloat d = vd * vd - (dot(v, v) - s.r * s.r);\n\tif(d < EPSILON)\n\t\treturn res;\n\tfloat q = sqrt(d);\t\n\tres.t = (-vd -q) > 0.0 ? -vd -q : -vd + q;\n\tres.n = normalize((r.o + r.d * res.t) - s.c);\n\treturn res;\n}\n\nfloat rand(float seed)\n{\t\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nvec2 rand2D(vec2 seed)\n{\n\tfloat r = rand(seed) * TWOPI;\n\treturn vec2(cos(r), sin(r));\n}\n\nfloat fresnel(vec3 v, vec3 n, float p)\n{\n\treturn clamp(pow(1.0 + dot(v,n),p),0.0,1.0);\n}\n\nfloat specular(vec3 v, vec3 n, vec3 l, float shininess)\n{\n\tvec3 r = reflect(l, n);\n\treturn pow(max(0.0, dot(r, v)), shininess);\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat distanceField(vec3 p, float t, sphere s, float seed)\n{\n\tp -= s.c;\n\n\tfloat rnd = rand(seed*100.0);\n\tt += rnd;\n\tt *= mix(2.0,8.0,rnd);\n\tt *= sign(rand(seed*20.0)-0.5);\n\n\trnd = rand(seed*200.0);\n\tfloat rot = p.y-s.r*0.2;\n\tp = rotateX(p, PI*(rnd-0.5)*0.4 + sin(t)*rot*2.0);\n\tp = rotateZ(p, PI*(rnd-0.5)*0.2 + cos(t)*rot);\n\tp = rotateY(p, t);\n\tvec3 op = p;\n\t\n\tp.y *= 0.8;\n\tp.xz *= 1.1;\n\tfloat body = distSphere(p,s.r*0.5);\n\t\n\tp = op;\n\tp.y -= s.r*0.06;\n\trot = pow(p.x,2.0)*10.0;\n\tp = rotateZ(p, rot*sin(t*2.0));\n\tp = rotateY(p, rot*cos(t*2.0));\n\tp.x *= 0.8;\n\tp.yz *= 3.0;\n\tfloat arms = distSphere(p,s.r*0.5);\n\t\n\tp = op;\n\tp.y -= s.r*0.2;\n\tp.z += s.r*0.4;\n\tp.x *= 2.0;\n\tfloat mouth = distSphere(p,s.r*0.1);\n\t\n\tp = op;\n\tp.yz += s.r*vec2(-0.3,0.3);\n\tvec3 o = s.r*vec3(0.2,0.0,0.0);\n\tfloat eyes = min(distSphere(p+o,s.r*0.1), distSphere(p-o,s.r*0.1));\n\t\n\tfloat d = smin(body,arms,0.008);\n\td = max(d, -mouth);\n\td = max(d, -eyes);\n\treturn d;\n}\n\nvec3 getNormal(vec3 p, float t, sphere s, float rnd)\n{\n\tvec2 d = vec2(0.01, 0.0);\n\tfloat dx = distanceField(p + d.xyy,t,s,rnd)\n\t\t\t\t- distanceField(p - d.xyy,t,s,rnd);\n\tfloat dy = distanceField(p + d.yxy,t,s,rnd)\n\t\t\t\t- distanceField(p - d.yxy,t,s,rnd);\n\tfloat dz = distanceField(p + d.yyx,t,s,rnd)\n\t\t\t\t- distanceField(p - d.yyx,t,s,rnd);\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat getInsideGlow(ray r, vec3 p, float t, sphere s, float rnd)\n{\n\tvec3 n = getNormal(p,t,s,rnd);\t\n\treturn fresnel(r.d,n,2.0);\n}\n\nfloat inside(ray r, float time, sphere s, float rnd)\n{\t\t\n\tfloat t = 0.0;\n\tvec3 p;\t\n\twhile(t <= s.r)\n\t{\n\t\tp = r.o + r.d * t;\n\t\tfloat d = distanceField(p, time, s,rnd);\t\t\n\t\tif(d <= EPSILON) \n\t\t{\n\t\t\tfloat glow = getInsideGlow(r,p,time,s,rnd);\n\t\t\tglow *= 1.0-t/(s.r*2.0);\n\t\t\treturn glow;\n\t\t}\n\t\tt += max(d, t * 0.0001);\n\t}\t\n\treturn 0.0;\n}\n\nvec4 getColor(ray r, result res, float t, float rnd, sphere s)\n{\n\tif(res.t < 0.0)return vec4(0.0);\n\t\n\tr.o = r.o + res.t * r.d;\n\t\t\t\t\n\tvec3 lPos = MOVEMENT*t + vec3(0.0, 2.0, 2.0);\n\tvec3 l = normalize(lPos-r.o);\n\t\n\tfloat glow = inside(r,iTime,s,rnd);\n\tglow *= smoothstep(0.4, 1.0, rand(rnd*40.0));\n\tglow *= 2.0;\n\tglow += (sin((t+TWOPI*rnd)*3.0)+1.0)*0.2;\n\tglow += specular(r.d, res.n, l, 16.0)*0.4;\n\t\n\tvec3 color = ORB + GLOW * glow;\n\t\n\tfloat a = 1.0;\n\ta *= pow(dot(r.d,-res.n),1.5);\n\ta *= rnd;\t\n\ta *=  1.0 - smoothstep(FOG.x,FOG.y,res.t);\n\treturn vec4(color,a);\n}\n\n\nvec3 spheres(ray r, float t, vec3 bg)\n{\n\tr.o += t*MOVEMENT;\n\tvec4 color = vec4(bg,0.0);\n\tfor(int i = 0; i < NUMLAYERS; i++)\n\t{\n\t\tplane pl = plane(vec3(0.0,0.0,-1.0),LAYERS[i]);\n\t\tvec3 p = r.o + intersectPlane(r,pl).t * r.d;\n\t\tp = vec3(floor(p.xy)+vec2(0.5),p.z);\n\t\t\n\t\tfloat rnd = rand(p.xy+float(i));\n\t\t\n\t\tfloat radius = mix(0.01, 0.3, rnd);\t\n\t\tvec2 offset = rand2D(p.xy+float(i));\n\t\toffset.x *= sin(3.0*radius*t+rnd);\n\t\tp.xy += offset*(0.5-radius);\n\t\t\n\t\tsphere s = sphere(p, radius);\t\n\t\tvec4 c = getColor(r,intersectSphere(r, s),t,rnd,s);\n\n\t\tfloat a = c.a*(1.0-color.a);\n\t\tcolor.rgb = mix(color.rgb, c.rgb, a);\n\t\tcolor.a += a;\n\t}\t\n\treturn color.rgb;\n}\n\nvec3 pow3D(vec3 x, float p)\n{\n\treturn vec3(pow(x.x,p),pow(x.y,p),pow(x.z,p));\n}\n\nfloat stars(vec2 uv, float amount, float radius)\n{\n\tuv = uv * amount;\n\tvec2 gridID = floor(uv);\n\tvec2 starPos = vec2(rand(gridID),rand(gridID+1.0));\n\tstarPos = (starPos - 0.5) * 2.0;\n\tstarPos = vec2(0.5) + starPos * (0.5 - radius * 2.0);\n\tfloat stars = distance(fract(uv), starPos);\n\tfloat size = rand(gridID)*radius;\n\tstars = 1.0 - smoothstep(0.0, size + radius, stars);\n\treturn stars;\n}\n\nvec3 background(vec2 uv)\n{\n\tfloat f = 1.0-(uv.y+1.0)/2.0;\n\tf += stars(uv, 4.0, 0.06)*0.3;\n\tvec3 bg = mix(pow3D(BG,4.0), BG, f/1.3);\n\treturn bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy;\n\tvec2 uv = vec2(2.0*coord - iResolution.xy)/iResolution.y;\n\tray r;\n\tr.o = vec3(0.0);\n\tr.d = getRayDirection(coord,iResolution.xy, 60.0);\n\t\t\n\tvec3 fp = r.o + intersectPlane(r,plane(vec3(0.0,0.0,-1.0),FOCUS)).t*r.d;\n\t\n\tvec3 bg = background(uv);\n\tvec3 color = vec3(0.0);\n\tfloat total;\n\tfor(int i = 0; i < MOTIONBLURSAMPLES; i++)\n\t{\n\t\tfloat t = iTime - MOTIONBLURDELTA*float(i);\n\t\tfloat falloff = pow(0.8, float(i));\n\t\ttotal += falloff;\t\n\t\tvec3 c = spheres(r,t,bg);\n\t\tfor(int j = 0; j < DOFSAMPLES; j++)\n\t\t{\n\t\t\tray r;\n\t\t\tr.o.xy = rand2D(vec2(float(j),rand(float(j))))*DOFDELTA;\n\t\t\tr.d = normalize(fp - r.o);\n\t\t\tc += spheres(r,t,bg);\n\t\t}\n\t\tcolor += c*falloff;\n\t}\n\tcolor /= total*float(DOFSAMPLES+1);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[743, 743, 796, 796, 910], [912, 912, 952, 952, 1118], [1120, 1120, 1161, 1161, 1446], [1448, 1448, 1472, 1472, 1513], [1515, 1515, 1538, 1538, 1589], [1591, 1591, 1615, 1615, 1678], [1680, 1680, 1720, 1720, 1768], [1770, 1770, 1827, 1827, 1899], [1901, 1901, 1936, 1936, 2043], [2045, 2045, 2080, 2080, 2185], [2187, 2187, 2222, 2222, 2327], [2329, 2329, 2364, 2364, 2389], [2391, 2391, 2430, 2430, 2520], [2522, 2522, 2582, 2582, 3458], [3460, 3460, 3514, 3514, 3835], [3837, 3837, 3903, 3903, 3966], [3968, 3968, 4022, 4022, 4301], [4303, 4303, 4367, 4367, 4865], [4868, 4868, 4907, 4907, 5520], [5522, 5522, 5551, 5551, 5601], [5603, 5603, 5653, 5653, 5991], [5993, 5993, 6019, 6019, 6138], [6140, 6140, 6197, 6197, 6952]]}
{"id": "MdVyDR", "name": "hierarchy - kaleido (204 chars)", "author": "FabriceNeyret2", "description": ".", "tags": ["kifs", "2tweets", "short", "golf"], "likes": 3, "viewed": 371, "published": "Public API", "date": "1521649497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/MsKyDR\n\nvoid mainImage(out vec4 O, vec2 u) {\n    for ( vec2 R = iResolution.xy, U = ( u+u - R ) / R.y, V,\n               A = 4./(1.+sin(iTime)) +R-R;\n          V = pow(U=abs(U),A), O.w++<9. && pow(V+V.y,1./A).x<1.;\n          O += vec4(.11,.14,.2,0)\n        ) U = (U/.4-1.) * mat2(cos( iTime + vec4(0,55,33,0))); }\n\n        \n        \n        \n        \n/** // 210 chars\n\n#define mainImage(O,u)                                       \\\n    float a = 4./(1.+sin(iTime));                            \\\n    for ( vec2 R = iResolution.xy, U = abs( (u+u-R) / R.y ); \\\n          O.w++<9. && pow(pow(U.x,a)+pow(U.y,a),1./a)<1. ;   \\\n          O += vec4(.11,.14,.2,0)                            \\\n        ) U = abs( (U/.4-1.) * mat2(cos( iTime + vec4(0,33,55,0))) ) \n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 85, 85, 354]]}
{"id": "MdVyWm", "name": "RT Julia Set Explorer", "author": "chronosis", "description": "Real-time Julia Set explorer.\n\n1024 Iterations with an orbit escape of 4\n\nHold-mouse down and drag to manually explore the set.\n\nPalette logic from IQ -- https://www.shadertoy.com/view/ll2GD3", "tags": ["fractal", "julia", "juliaset", "palette"], "likes": 1, "viewed": 74, "published": "Public", "date": "1522313286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 4.\n#define itr 1024.\n#define cen vec2(0.5, 0.5)\n#define escape 4.\n#define LEN(x) dot(x,x)\n\n//vec3 hsv2rgb(vec3 c) {\n//  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n//  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n//  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n//}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//float scalex(float v, float s) {\n//   return (v * s) - (s * (5. / 7.));\n//}\n\nfloat scaley(float v, float s) {\n   return (v * s) - (s * 0.5);\n}\n\nvec2 scalev(vec2 v, float s) {\n   return (v * s) - (s * 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 res = iResolution.xy,\n        off = cen * res,\n        uv = 0.5 + (fragCoord - off) / res,\n        m = 0.5 + (iMouse.xy - off) / res;\n   \t\n    if (iMouse.z <= 0.) {\n        float time = iTime * 1.5;\n        m = .5 + .3 * vec2(cos(time * .15), sin(time * .33));\n    }\n\n    // Julia/Mandlebrot is z(n) = z(n-1)^2 + c\n    // Julia: \n    //   Where z and c are points on the complex plane\n    //   z(0) is the point being drawn on the plane\n    //   c is an arbitrary point on the plane\n    // Mandlebrot:\n    //   Where z and c are points on the complex plane\n    //   z(0) is 0 + 0i (this can be an arbitrary point to further explore the set space)\n    //   c is the point being drawn on the plane\n    \n    // Complex numbers take the form (a + bi)\n    // Squared complex numbers take the following algebraic expansion\n    //   (x + yi) ^ 2\n\t//   ==> (x + yi)(x + yi)\n    //   ==> (x^2 + 2xyi + (yi)^2)\n    //   ==> (x^2 + 2xyi - y^2)\n    //   ==> (x^2 - y^2) + (2xy)i\n    //   ==> x' + y'i\n    // Where x' = (x^2 - y^2) and y' = 2xy\n    \n    // Julia\n    float xtemp = 0.;\n    vec2 z = scalev(uv, scale);\n\n    // Mandlebrot\n    //vec2 z = vec2(0.);\n\n    // Madlebrot (extended by mouse position)\n    //vec2 z = vec2(scalex(m.x, scale), scaley(m.y, scale));\n\n    float l = LEN(z);\n    float o = 0.;\n\n    for(float i = 1.; i <= itr; i++) {\n        vec2 s = scalev(m, scale);\n        //xtemp = (z.x * z.x) - (z.y * z.y) + s.x;\n        //z.y = (2. * z.x * z.y) + s.y;\n        //z.x = xtemp;\n        \n        // deMoivre Matrix forumlation basically does the above\n        // |  z.x z.y |   \n        // | -z.y z.x | * | z.x z.y | + s\n        //   ==> z.x = (z.x * z.x) - (z.y * -z.y) + s.x\n        //   ==> z.y = (z.x * z.y) + (z.x + z.y) + s.y\n        z = mat2(z, -z.y, z.x) * z + s;        \n        l = LEN(z);\n\n        if(l > escape) {\n            o = i;\n            break;            \n        }\n    }          \n    \n    if (distance(m, uv) < 0.005) {\n        // Draw Indicator\n        fragColor = vec4(1.);\n    }\n    else if (o == 0.) {\n        // Inside Set (Black regions)\n        fragColor = vec4(0.);\n    } else {\n        // Escaped value, color by number of orbits to escape\n        float t = o/float(itr / 64.) + (0.5*iTime);\n        vec3 cola = pal(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0,0.10,0.20) );\n        vec3 colb = pal(t, vec3(0.5), vec3(0.5), vec3(1.0,0.7,0.4), vec3(0.0,0.15,0.20) );\n        vec3 col = mix(cola, colb, (sin(0.1*iTime) + 1.) * 0.5);\n        fragColor = vec4(col, 1.);\n    }\n    \n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 302, 370, 370, 413], [415, 494, 526, 526, 559], [561, 561, 591, 591, 624], [627, 627, 684, 734, 3284]]}
{"id": "MdycRw", "name": "tiling rotate", "author": "lahwran", "description": "random thing", "tags": ["wip"], "likes": 1, "viewed": 109, "published": "Public", "date": "1521415136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 uv, float amount) {\n    vec2 prime = vec2( uv.x*cos(amount) + uv.y*sin(amount),\n                      -uv.x*sin(amount) + uv.y*cos(amount));\n    return prime;\n}\n#define M_PI 3.1415926535897932384626433832795\n\nfloat deg2rad(int deg) {\n    return (float(deg) * M_PI / 180.0);\n}\nfloat deg2rad(float deg) {\n    return ((deg) * M_PI / 180.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center (0,n) in screen\n    vec2 uv = fragCoord - vec2(iResolution.x/2.0,iResolution.y/2.0);\n    vec2 width = vec2(10.0,50.0);\n    \n    vec3 col = vec3(0.0);\n    float dist = length(uv);\n    float rad = length(width);\n    float box_size = max(width.x*2.,width.y*2.);\n    vec2 offset_pos = uv + box_size/2.;\n    vec2 aligned = vec2(floor(offset_pos.x/box_size), floor(offset_pos.y/box_size));\n    vec2 center = (aligned+0.5) * box_size;\n    \n    vec2 angled = rotate(uv, iTime*-0.0613)+vec2(rad,rad);\n    float box_size_ang = 2.*rad;\n    vec2 aligned_pos_ang = vec2(angled.x/(box_size_ang), angled.y/box_size_ang);\n    vec2 aligned_ang = floor(aligned_pos_ang);\n    vec2 center_ang = (aligned_ang+0.5) * box_size_ang;\n    vec2 center_rel_ang = angled-center_ang;\n    vec2 box_ang = fract(aligned_pos_ang) * box_size_ang;\n    \n    bool polarity = ((int(aligned.x) % 2 == int(aligned.y) % 2));\n    if (polarity) {\n        col += 0.2*vec3(0.0,0.0,1.0);\n    }\n    if (abs(dist-rad)<1.0) {\n        col = vec3(1.0);\n    }\n    if (polarity && abs(distance(center,offset_pos))<16.0) {\n        col = vec3(0.2,0.4,1.0);\n    }\n    if (\n        (box_ang.x < 1. || box_ang.x>box_size_ang-1. || box_ang.y > box_size_ang-1. || box_ang.y < 1.)) {\n        col = vec3(1.0, 0.0,0.0);\n    }\n    if (abs(distance(center_ang,angled))<8.0) {\n        col = vec3(1.0,0.4,0.2);\n    }\n    vec2 prime = rotate(center_rel_ang, iTime);\n    col =  vec3(float(prime.x <= width.x && prime.x >= -width.x && prime.y <= width.y && prime.y > -width.y));\n\n    // output color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 177], [226, 226, 250, 250, 292], [293, 293, 319, 319, 356], [358, 358, 415, 445, 1991]]}
{"id": "MdycW1", "name": "sin wave 002", "author": "ykob", "description": "study to make mask pattern.", "tags": ["sin"], "likes": 1, "viewed": 66, "published": "Public", "date": "1521790170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat wave1 = sin((fragCoord.x) * .1);\n\tfloat wave2 = sin((fragCoord.y) * .1 + iTime / .1);\n\n    vec3 waveColor = vec3(.5 + (wave1 + wave2) / 4.);\n    \n    fragColor = vec4(waveColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdycW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 249]]}
{"id": "MdyyDw", "name": "Spooky Newton", "author": "Ebanflo", "description": "Playing around with Newton's method. The fracture-like effect is caused by doing component-wise division instead of complex division on the first iteration. Mouse does stuff.", "tags": ["2d", "fractal", "newton"], "likes": 3, "viewed": 196, "published": "Public", "date": "1522209679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define zoom 2.0\n#define fractalIters 8\n//#define evenMoreFracture\nconst float pi = 4.0*atan(1.0);\n\nvec2 cinv(vec2 z){return vec2(z.x, -z.y)/dot(z, z);}\n\nvec2 csqr(vec2 z){return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);}\n\nvec2 ccube(vec2 z){\n    return vec2(z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y);\n}\n\nvec2 cmul(vec2 a, vec2 b){return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);}\n\nvec2 m(float t){\n    return vec2(16.0*iMouse.x/iResolution.x, 2.0*sin(t)*sin(t)*sin(t)*sin(t) + 3.0*sin(0.245*t) + sin(1.234*t));\n}\n\nvec2 f(vec2 z){return ccube(z) - m(iTime) + vec2(4);}\n\n#ifdef evenMoreFracture\nvec2 df(vec2 z){\n    vec2 e = vec2(0.0001);\n    return 10000.0*(f(z + e) - f(z));\n}\n#else\nvec2 df(vec2 z){return 3.0*csqr(z);}\n#endif\n\nfloat newton(vec2 p){\n    vec2 z = p, z1 = z - f(z)/df(z);\n    vec2 d;\n    for(int i = 0; i < fractalIters; i++){\n        d = abs(z - z1);\n        if(d.x < 0.05 || d.y < 0.05) break;\n        z = z1;\n        z1 = z1 - cmul(f(z1), cinv(df(z1)));\n    }\n    return smoothstep(0.0, 0.95, length(d));\n}\n\nvec3 render(vec2 p){\n    vec2 coords = zoom*(2.0*p - iResolution.xy)/iResolution.y;\n    if(length(coords) < 0.1) return vec3(0);\n    float mo = iMouse.y/iResolution.y;\n    coords = cmul(coords, vec2(cos(mo), sin(mo)));\n    float t = 0.2*smoothstep(0.5, 3.0, length(coords));\n    coords = cmul(coords, vec2(cos(t), sin(t)));\n    return vec3(newton(coords))*smoothstep(0.1, 1.0, dot(coords, coords));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ){\n        vec2 px = fragCoord + vec2(float(m),float(n))/float(AA);\n    \tcol += render(px);    \n    }\n    col /= float(AA*AA);\n#else\n    col = render(fragCoord);\n#endif\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 113, 131, 131, 165], [167, 167, 185, 185, 230], [232, 232, 251, 251, 332], [334, 334, 360, 360, 411], [413, 413, 429, 429, 544], [546, 546, 561, 561, 599], [760, 760, 781, 781, 1056], [1058, 1058, 1078, 1078, 1458], [1460, 1460, 1517, 1517, 1817]]}
{"id": "MdyyRy", "name": "Satellite", "author": "hamtarodeluxe", "description": "My second shader :)", "tags": ["2d", "sin"], "likes": 13, "viewed": 241, "published": "Public", "date": "1522497202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159\nvec3 circle(vec2 uv,float r,vec2 pos,float rBlur,float value){\n    vec3 col;\n    float l = length(uv-pos);\n    col= vec3(smoothstep(r,r-rBlur,l))*((0.2+value)); \n    return col;    \n}\n\nvec2 normalizeCoords(vec2 coords,float prop){\n    vec2 vecOut;\n    vecOut = ((coords/iResolution.xy)-0.5);\n    vecOut.x*=prop;\n    return vecOut;\n}         \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float prop = iResolution.x/iResolution.y;\n    vec2 uv = normalizeCoords(fragCoord.xy,prop);\n    //vec2 mousePos=normalizeCoords(iMouse.xy,prop); idea for a fun mouse input ?\n    vec3 col;\n    float rSpeed=0.5;\n\tfloat d =0.3 +0.06*sin(iTime*rSpeed);\n    float speed = 3.;\n    \n    vec3 background= circle (uv,d*1.5,vec2(0.),d*5.,1.);\n    background.xyz+=vec3(0.05,0.,0.15);\n\t \n    background*=circle (uv,1.5,vec2(0.),1.4,1.);;\n    \n    vec3 planet = 1.-circle(uv, d*0.7,vec2 (0),0.02,1.);\n    \n    for (float i=1.;i<25.;i++){\n        \n    \tfloat offset=.2;\n     \tfloat st = speed*iTime;\n        \n        // co is similar to the cos that define x coordinate\n        // but with some offset and remap to use as a radius factor\n\t\tfloat co=(cos(st+offset*i*1.5+M_PI*.5)+1.)/2.;\n        \n        float x=d*cos(st+offset*i*1.5);\n        float y=d*sin(st*0.6+offset*i*0.9);\n        \n        vec2 pos=vec2 (x,y);\n        \n        float r;\n         \n        r=0.02*co*co+0.0045*i; \n        \n        float a=1.-0.09*(20.-i);\n\n        vec3 colCircle=circle(uv, r,pos,0.03,co);\n        vec3 colCircle2=circle(uv, r,pos,0.3,co);\n        \n        colCircle.x/=(2.*a);\n        colCircle.y*=0.5;\n        \n        vec3 colCircleTot=(colCircle+colCircle2*a)*a;\n        \n        if(co<0.5)colCircleTot*=planet;\n        \n        \n        col = max (col,colCircleTot);\n        \n    }\n   \tcol+=background*planet;  \n    \n    // Output to screen\n    fragColor = vec4(col,1);\n    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 83, 83, 204], [206, 206, 251, 251, 353], [364, 364, 420, 420, 1881]]}
{"id": "MdyyzG", "name": "Tesla's Laboratory", "author": "dr2", "description": "High voltage...", "tags": ["plasma", "lightning", "electricity", "discharge"], "likes": 9, "viewed": 3329, "published": "Public API", "date": "1522400054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tesla's Laboratory\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2p (vec2 p);\n\nvec4 pth[4];\nvec3 qHit, qnBlk[2], bSize;\nfloat tCur, dstFar, illum, illumMin;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.y -= 4.6;\n  if (illum > 0.) {\n    for (int k = 0; k < 4; k ++) {\n      q = p;\n      q.xz = Rot2D (q.xz, (0.5 + float (k)) * 0.5 * pi);\n      q.y -= 0.2 * Fbm1 (5. * tCur);\n      q.z += 4.5;\n      q.yz = Rot2D (q.yz, 0.1 * pi);\n      d = PrCylDf (q, 0.85, 4.);\n      if (d < dMin) {\n        q.xy -= SmoothBump (-3.5, 3.9, 0.5, q.z) * (2. *\n           vec2 (Fbm2p (vec2 (0.4 * q.z, 0.) + pth[k].xy),\n           Fbm2p (vec2 (0.3 * q.z, 0.) + pth[k].zw)) - 1.);\n        d = PrCylDf (q, 0.015, 4.);\n        DMINQ (1);\n      }\n    }\n  }\n  dMin *= 0.5;\n  q = p;\n  q.y -= 1.4;\n  d = PrSphDf (q, 0.8);\n  DMINQ (2);\n  q.y -= -3.;\n  d = PrCylDf (q.xzy, 0.3 + 0.05 * abs (sin (4. * pi * q.y)), 3.);\n  DMINQ (3);\n  q.y -= -2.95;\n  d = PrCylDf (q.xzy, 1., 0.05);\n  DMINQ (4);\n  q = p;\n  q.xz = abs (q.xz) - 5.9;\n  q.y -= -1.2;\n  d = PrSphDf (q, 0.3);\n  DMINQ (2);\n  q.y -= -1.7;\n  d = PrCylDf (q.xzy, 0.15 + 0.02 * abs (sin (4. * pi * q.y)), 1.7);\n  DMINQ (3);\n  q.y -= -1.67;\n  d = PrCylDf (q.xzy, 0.5, 0.03);\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return vec2 (dMin, df);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, ltPos, ltDir, sCol;\n  vec2 dBlock, s;\n  float dstObj, f, spec, atten;\n  for (int k = 0; k < 4; k ++) {\n    f = 0.1 * float (k);\n    pth[k] = vec4 (4. + f + (1.5 + f) * tCur + (0.8 - f) * sin ((0.1 + 0.1 * f) * tCur),\n       sin ((0.11 + 0.1 * f) * tCur) + (0.3 + 0.2 * f) * sin ((0.17 + 0.5 * f) * tCur),\n       5. + 2. * f + (1.3 - f) * tCur + (0.5 + 0.3 * f) * sin ((0.15 - 0.2 * f) * tCur),\n       sin ((0.12 - 0.1 * f) * tCur) + (0.4 - 0.2 * f) * sin ((0.12 + 0.2 * f) * tCur));\n  }\n  illum = illumMin + (1. - illumMin) * smoothstep (0.3, 0.9, Fbm1 (4. * tCur));\n  ltPos.y = 5.5;\n  roo = ro;\n  dBlock = BlkHit (ro - vec3 (0., bSize.y, 0.), rd, bSize);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dBlock.y) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col = vec3 (0.9, 0.9, 0.6) * clamp (2. * (0.1 + 0.9 * illum) *\n         (1. - 0.3 * Fbm1 (5. * qHit.z)) - 0.2, 0., 1.);\n      col *= 0.2 + 1.2 * max (0.3 - dot (rd, vn), 0.);\n    } else {\n      if (idObj == 2) {\n        col = vec3 (0.5, 0.3, 0.1);\n      } else if (idObj == 3) {\n        col = vec3 (0.6, 0.7, 0.8) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (4. * qHit.y, 1.)));\n        spec = 0.1;\n      } else if (idObj == 4) {\n        col = vec3 (0.2, 0.5, 0.1) * (1. - 0.2 * Fbm2 (8. * ro.xz));\n        spec = 0.05;\n      }\n      sCol = vec3 (0.);\n      for (float k = 0.; k < 4.; k ++) {\n        ltPos.xz = Rot2D (vec2 (3., 0.), 0.5 * pi * (k + 0.5));\n        ltDir = ltPos - ro;\n        atten = 1.2 * step (0.02, -dot (rd, vn)) / (1. + 0.003 * pow (length (ltDir), 2.));\n        ltDir = normalize (ltDir);\n        sCol += atten * col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.));\n        if (idObj != 2) sCol += atten * spec * illum * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n        else sCol += atten * 0.5 * illum * pow (max (dot (vn, ltDir), 0.), 32.);\n      }\n      col = 0.25 * sCol * (0.1 + 0.9 * illum);\n      if (illum < 0.1 && idObj == 2) col += vec3 (0., 0., 0.2) * (0.5 + 0.5 * Fbm1 (64. * tCur)) *\n         (1. - smoothstep (0.05, 0.1, illum));\n    }\n  } else {\n    vn = qnBlk[1];\n    ro += rd * dBlock.y;\n    if (abs (vn.y) > 0.1) {\n      if (vn.y > 0.) {\n        s = abs (mod (2. * ro.xz + 0.5, 1.) - 0.5);\n        col =  mix (vec3 (0.3, 0.4, 0.3), vec3 (0.8, 0., 0.),\n           SmoothBump (0.1, 0.2, 0.05, length (ro.xz) - 2.) +\n           SmoothBump (0.1, 0.2, 0.05, length (abs (ro.xz) - 5.9) - 1.)) *\n           (1. - 0.3 * smoothstep (0.4, 0.45, max (s.x, s.y))) * (1. - 0.2 * Fbm2 (4. * ro.xz));\n      } else col = vec3 (0.3, 0.3, 0.1);\n    } else {\n      s = (abs (vn.x) > 0.1) ? ro.zy : ro.xy;\n      col = vec3 (0.4, 0.4, 0.3) * (1. - 0.2 * Fbm2 (s));\n      s = abs (mod (vec2 (0.5, 0.25) * s, 1.) - 0.5);\n      col *= 1. - 0.3 * smoothstep (0.46, 0.48, max (s.x, s.y));\n    }\n    sCol = vec3 (0.);\n    for (float k = 0.; k < 4.; k ++) {\n      ltPos.xz = Rot2D (vec2 (3., 0.), 0.5 * pi * (k + 0.5));\n      ltDir = ltPos - ro;\n      atten = 1.2 / (1. + 0.003 * pow (length (ltDir), 2.));\n      ltDir = normalize (ltDir);\n      sCol += atten * (col * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)));\n    }\n    col = 0.25 * sCol * (0.1 + 0.9 * illum);\n    if (illum < 0.1) col += vec3 (0.1, 0.1, 0.4) * (0.5 + 0.5 * Fbm1 (64. * tCur)) *\n       (1. - smoothstep (0.00005, 0.001, 1. - max (dot (normalize (vec3 (0., 6., 0.) - roo), rd), 0.))) *\n       (1. - smoothstep (0.05, 0.1, illum));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  illumMin = 0.;\n  if (canvas.x < 255.) illumMin = 0.4;\n  bSize = vec3 (20., 10., 20.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 1., -30.);\n  ro.y = clamp (ro.y, 0.3, 2. * bSize.y - 0.3);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  dstFar = 70.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2p (vec2 p)\n{\n  float f, a, s;\n  f = 0.;\n  s = 0.;\n  a = 1.;\n  for (int j = 0; j < 4; j ++) {\n    f += a * Noisefv2 (p);\n    s += a;\n    a *= 1./2.5;\n    p *= 2.5;\n  }\n  return f / s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyyzG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 566, 588, 588, 1663], [1665, 1665, 1698, 1698, 1875], [1877, 1877, 1898, 1898, 2098], [2100, 2100, 2144, 2144, 2648], [2650, 2650, 2685, 2685, 6144], [6146, 6146, 6202, 6202, 7119], [7121, 7121, 7154, 7154, 7181], [7183, 7183, 7225, 7225, 7276], [7278, 7278, 7335, 7335, 7418], [7420, 7420, 7450, 7450, 7508], [7542, 7542, 7566, 7566, 7619], [7621, 7621, 7645, 7645, 7775], [7777, 7777, 7802, 7802, 7948], [7950, 7950, 7975, 7975, 8161], [8163, 8163, 8185, 8185, 8339], [8341, 8341, 8362, 8362, 8517], [8519, 8519, 8541, 8541, 8713]]}
{"id": "Ms3yWs", "name": "CJ mystery hard edge - help!", "author": "chrisjj", "description": "Expected: no hard edge on arms, as ringed in green https://i.imgur.com/cGgsdxl.png\nObserved: a hard edge on one pair of arms, ringed in red. Why?", "tags": ["help"], "likes": 2, "viewed": 92, "published": "Public", "date": "1520544834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAY_STEPS 150\n\n#define detail .001\n#define t (iTime)\n#define tt (t/10.)\n\nfloat det=0.0;\n\n// 2D rotation\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec4 formula(vec4 p) {\n\tp.yz = -abs(p.yz);\n\tp.x = abs(p.x);\n\tp.xy *= rot(radians(-10.)); // pinch\n\tp.xz *= rot(radians(-10.)); // pinch - mystery hard edge alone front+back of arm\n\t// Transposing pinch moves the hard edge to the other arm pair\n\treturn p;\n}\n\n// Distance function\nfloat de(vec3 pos) {\n\tvec4 p = vec4(pos,1.);\n\tp=formula(p);\n\tfloat fr = length(max(p.xyz,.3259-.95))-1.0;\n\treturn fr/p.w/1.4;\n}\n\nvec3 origin;\n\n// Normal\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det*5.,0.0);\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n// Raymarch\nvec3 raymarch(in vec3 from, in vec3 dir, in vec3 ldir)\n{\n\tvec3 p;\n\tfloat d=100.;\n\tfloat totdist=0.,todistlimit=50./*was 25*/;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<todistlimit) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d;\n\t\t}\n\t}\n\tvec3 col = vec3(.8,.8,1); // material\n\tvec3 backg=vec3(0.,0.,0.);\n\tif (totdist>todistlimit) col=backg; // hit background\n\telse\n\t{\n\t\tp-=(det-d)*dir;\n\t\t// paint\n\t\tfloat pat = cos(p.y*12.) +cos(p.z*12.) >-.0?1.:0.\t\t\t\t\t;\n\t\tcol.rgb += pat;\n\t\t// Illumination\n\t\tldir = (ldir-p);\n\t\tvec3 lcol = vec3(1,1,0.7);\n\t\tvec3 norm=normal(p);\n\t\tfloat incid = max(0.0,dot(-norm, normalize(ldir)));\n\t\tcol *= .1\n\t\t\t\t+ lcol * pow(incid,6.)*.9;\n\t\t;\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec4 mouse=(iMouse.xyzw/iResolution.xyxy-.5)*3.;\n    mouse *= 0.;\n\n\tfloat fov=.6;\n\torigin=vec3(0,0,-6.);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\tvec3 from=origin;\n\n\tfrom.xz*=rot(mouse.x);dir.xz*=rot(mouse.x);\n\tfrom.yz*=rot(mouse.y);dir.yz*=rot(mouse.y); // Turn object\n    float a = 1.*26.*tt*4.,a2=a*2.*0.-80.;\n\tfrom.xz*=rot(radians(a2));\tdir.xz*=rot(radians(a2));\n\tfrom.yz*=rot(radians(a));\tdir.yz*=rot(radians(a));\n\n    vec3 ldir = (vec3(15,15,-20)); // lamp pos\n\tldir.xz*=rot(mouse.x);\n\tldir.yz*=rot(mouse.y);\n\tldir.xz*=rot(radians(a2));\n\tldir.yz*=rot(radians(a));\n\tvec3 col=raymarch(from,dir,ldir);\n\tfragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3yWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 112, 131, 131, 177], [179, 179, 201, 201, 435], [437, 458, 478, 478, 585], [601, 611, 632, 632, 824], [826, 838, 894, 894, 1569], [1571, 1571, 1628, 1628, 2346]]}
{"id": "MscyDj", "name": "raymarch 06plane", "author": "yxo", "description": "this is from youtube video about raymarching\n\"WebGL Paris 2015 - Raymarching en Live Coding\"", "tags": ["raymarch"], "likes": 1, "viewed": 100, "published": "Public", "date": "1520233007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c) * pos;\n}\n\nfloat plane(vec3 pos){\n    return pos.y+sin(pos.z*.25+iTime)*cos(pos.x*.25+iTime*2.)*2.;\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size){\n    return length(max(abs(pos)-size, .0));\n}\n\nfloat roundedBox(vec3 pos, vec3 size, float radius){\n    //pos.x += sin(iTime)*4.;\n    return length(max(abs(pos)-size, .0)) - radius;\n}\n\nfloat map(vec3 pos){\n    float planeDist = plane(pos);\n    \n    pos.xy = rotate(pos.xy, sin(iTime)*pos.z*0.02);\n    //pos.yz = rotate(pos.yz, sin(iTime)*pos.x*0.01);\n    //pos.x = abs(pos.x);\n    pos = mod(pos + 10., 20.) - 10.;\n    \n    pos.xy = rotate(pos.xy, iTime);\n    pos.xz = rotate(pos.xz, iTime*0.7);\n    \n    return min(planeDist, roundedBox(pos, vec3(2.), 3.));    \n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(.01, .0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nvec3 albedo(vec3 pos){\n    pos += .5;\n    \n    //return fract(pos.x) * fract(pos.y) * vec3(1.);\n    \n    float f = smoothstep(.34, .35, fract((pos.x*.3)+sin(pos.z)*.4))*fract((pos.z*.8)+cos(pos.x*.3)*.5);\n    \n    return f * vec3(1.);\n}\n\nvec3 lightDirection = normalize(vec3(1.,.6,-1.));\n\nfloat diffuse(vec3 normal){\n    return max(dot(normal, lightDirection), .0);\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), .0), 100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime;\n    vec3 camAnim = vec3(sin(time*.5)*2., cos(time*.4)*1.+4.,2.);\n    vec3 pos = vec3(.0, 5., -31.);\n    pos += camAnim;\n    \n    vec3 dir = normalize(vec3(uv, 1.));\n    //dir.xz *= mat2(cos(time), -sin(time), sin(time), cos(time));\n    \n    vec3 col = vec3(.0);\n    \n    for(int i; i<32; ++i){\n        float d = map(pos);\n        if (d<.01){\n            \n            vec3 norm = computeNormal(pos);\n            float diff = diffuse(norm);\n            float spec = specular(norm, dir);\n            \n            float lightDist = sphere(pos, 20.);\n            vec3 lightCol = vec3(.2,.4,.9);\n            \n            col = (diff+spec) * 20./(lightDist*lightDist)*lightCol*albedo(pos);\n            //col = (diff+spec) * lightCol*albedo(pos);\n        }\n        pos += d*dir;\n        \n    }\n    \n    //vec3 norm = computeNormal(pos);\n    //fragColor = vec4(norm,1.0);\n    //float c = diffuse(computeNormal(pos));\n    //float c = specular(computeNormal(pos), dir);\n    \n    float fogFactor = exp(-pos.z * .03);\n    col = mix(vec3(0.8,0.9,1.0), col, fogFactor);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 130], [132, 132, 154, 154, 222], [224, 224, 261, 261, 296], [298, 298, 329, 329, 374], [376, 376, 428, 458, 512], [514, 514, 534, 534, 892], [894, 894, 923, 923, 1140], [1142, 1142, 1164, 1164, 1378], [1431, 1431, 1458, 1458, 1509], [1511, 1511, 1549, 1549, 1636], [1638, 1638, 1695, 1695, 2917]]}
{"id": "MscyDs", "name": "Stick nest", "author": "chrisjj", "description": "Should show https://i.imgur.com/c44SEi1.png\n\nDrag mouse to rotate", "tags": ["art"], "likes": 1, "viewed": 108, "published": "Public", "date": "1520566291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RAY_STEPS 150\n\n#define detail .001\n#define t (iTime+2.)\n#define tt (t/10.)\n\nfloat det=0.0;\n\n// 2D rotation\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// Distance function\nfloat de(vec3 pos) {\n\tvec4 p = vec4(pos,1.);\n\tp *= 3.;\n\tp.xyz = -abs(p.xyz)+3.+sin(t/6.);\n\tp.xyz = -abs(p.xyz)+2.+sin(t/6.2)/3.;\n\tfloat fr = length(max(p.xyz,-0.78))-0.8;\n\treturn fr/p.w/1.4;\n}\n\n// Normals\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det*5.,0.0);\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n// Raymarch\nvec3 raymarch(in vec3 from, in vec3 dir, in vec3 ldir)\n{\n//\tfrom.z-=2.*scale; // centre\n\tvec3 p;\n\tfloat d=100.;\n\tfloat totdist=0.,todistlimit=50./*was 25*/;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d>det && totdist<todistlimit) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d;\n\t\t}\n\t}\n\tp-=(det-d)*dir;\n\tvec3 col = min(abs(p.xyz),6.);\n\tvec3 norm=normal(p);\n\n\tldir = (ldir-p);\n\tfloat incid = max(0.0,dot(-norm, normalize(ldir)));\n\tcol *= .2\n\t\t+ pow(incid,6.)*.2;\n\tcol += pow(incid,200.)*.5\n\t;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec4 mouse=(iMouse.xyzw/iResolution.xyxy-.5)*3.;\n\n\tfloat fov=.8;\n\tvec3 origin=vec3(0,0,-6.);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\n\tvec3 from=origin;\n\tfrom.xz*=rot(mouse.x);dir.xz*=rot(mouse.x);\n\tfrom.yz*=rot(mouse.y);dir.yz*=rot(mouse.y); // Turn object\n    float a = 1.*6.*tt*4.,a2=a*2.*1.;\n\tfrom.xz*=rot(radians(a2));\tdir.xz*=rot(radians(a2));\n\tfrom.yz*=rot(radians(a));\tdir.yz*=rot(radians(a));\n    vec3 ldir = (vec3(15,15,-20)); // lamp pos\n\tldir.xz*=rot(mouse.x);\n\tldir.yz*=rot(mouse.y);\n\tldir.xz*=rot(radians(a2));\n\tldir.yz*=rot(radians(a));\n\tvec3 col=raymarch(from,dir,ldir);\n\tfragColor = vec4(col,1.);\n}\n\n////////////////////\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 115, 134, 134, 180], [182, 203, 223, 223, 395], [397, 408, 429, 429, 621], [623, 635, 691, 722, 1174], [1176, 1176, 1233, 1233, 1932]]}
{"id": "MsdcWs", "name": "Making Waves", "author": "marsipan", "description": "Same learning experiments. ", "tags": ["wave"], "likes": 1, "viewed": 67, "published": "Public", "date": "1521494072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float normsin(float a)\n{\n\treturn 0.5*(sin(a)+1.0);\n\n}\n\n\nfloat normcos(float a)\n{\n\treturn 0.5*(cos(a)+1.0);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy-vec2(0.5,0.5);\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    float r = length(uv) ;\n    \n    float nc = normcos(0.001*uv.x*iTime) ;\n    float ns = normsin(0.01*uv.x*iTime) ;\n        \n    float f1 = 5.0 ;\n//    float f2 = 4.4 * nc ;\n//    float f3 = 7.0 * ns ; ;\n    float f2 = 4.4  ;\n    float f3 = 7.0  ;\n    float p1 = 20.0 ;\n    float p2 = 20.0 * nc;\n    float p3 = 12.0*normcos(0.5*6.28*iTime)+12.0;\n\n    // Time varying pixel color\n    float w1 = normcos(5.0*6.28*iTime+uv.y+20.0*uv.y*6.28)  ;\n    \n    float w2 = normcos(f2*6.28*iTime+uv.x+p2*uv.x*6.28)  ;\n    \n    float w3 = normcos(f3*6.28*iTime-p3*r*6.28)  ;\n\n    vec3 col = vec3(0, 0.5*w3+0.0*w2, 0) ;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 53], [56, 56, 80, 80, 109], [112, 112, 169, 275, 984]]}
{"id": "MsGcDz", "name": "3DTutorial", "author": "kylecox", "description": "https://www.youtube.com/watch?v=dKA5ZVALOhs", "tags": ["simple", "basic", "tutorial"], "likes": 1, "viewed": 61, "published": "Public", "date": "1521592711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3 (0.,0.,-2.);\n\tvec3 rd = vec3(uv.x, uv.y, 0.)-ro;\n    \n    \n    float t = iTime;\n    vec3 p = vec3(sin(t), 0., 2.+cos(t));\n    float d = DistLine(ro, rd, p);\n    \n    d = smoothstep(.1, .09, d);\n                   \n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 88], [90, 90, 147, 147, 510]]}
{"id": "MsKyRh", "name": "Doodling #1: Rose", "author": "lsdlive", "description": "Doodling session.\nThanks to iq, mercury, lj, balkhan & all shadertoyers.\nGreets to all the shader showdown paris gang.", "tags": ["raymarch", "doodling"], "likes": 9, "viewed": 161, "published": "Public", "date": "1521059680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat2 r2d(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid amod(inout vec2 p, float m) {\n    float a = mod(atan(p.x,p.y)-m*.5,m) - m*.5;\n    p = vec2(cos(a),sin(a)) * length(p);\n}\n\nfloat sc(vec3 p){\n    p=abs(p);\n    p=max(p,p.yzx);\n    return min(p.x,min(p.y,p.z)) - .2;\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p.y = abs(p.y) - d.x;\n    p.x = abs(p.x) - d.y;\n    if(p.y>p.x) p.xy=p.yx;\n}\n\nfloat g=0.;\nfloat de(vec3 p) {\n    vec3 q = p;\n    q.x += sin(q.z)*.4;\n    float s = length(mod(q+iTime+vec2(0,sin(iTime*.2)*4.).yxx-1., 2.)-1.) - .04 - sin(iTime*30.)*.003;\n    \n    p.xy*=r2d(-3.14*.25);\n    p.zy*=r2d(3.14*.03);\n    \n    p.xz*=r2d(iTime);\n    p.y-=length(p.xz)*.3;\n    \n\tamod(p.xz, .785);\n    \n    mo(p.xz, vec2(.33, .05));\n    \n    float s2 = length(p.yz) -.28;\n    \n    float d = sc(p);\n    d = min(d,s);\n    d = min(d,s2);\n    g+=.01/(.01+d*d);\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(1,1,-3.5);\n    vec3 rd=normalize(vec3(uv, 1));\n\n    vec3 p;\n    float t=0.,ri;\n    for(float i=0.;i<1.;i+=.01){\n        ri=i;\n    \tp=ro+rd*t;\n        float d=de(p);\n        if(d<.01)break;\n        t+=d*.5;\n    }\n\n    vec3 bg = vec3(.2, .18, .27);\n    vec3 col = mix(vec3(.9, .2, .3), bg, ri);\n    col+=g*.05;\n    \n    col = mix(col, bg, 1.-exp(-.01*t*t));\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 19, 77], [79, 79, 113, 113, 204], [206, 206, 223, 223, 298], [300, 300, 331, 331, 412], [426, 426, 444, 444, 892], [894, 894, 951, 951, 1445]]}
{"id": "MsKyWw", "name": "Compact Disk - Diffraction ", "author": "nawafuji", "description": "tested diffraction prop", "tags": ["practice"], "likes": 0, "viewed": 118, "published": "Public", "date": "1522335006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst float S = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n/*\nfloat distanceToNearestSurface(vec3 p){\n  return length(p) - 1.0;\n}\n*/\n\nconst float eta = 0.66;\nconst float etaR = 0.65;\nconst float etaG = 0.67;\nconst float etaB = 0.69;\n\nconst float fresnelPower = 5.0;\nconst float F = ((1.0-eta)*(1.0-eta))/((1.0+eta)*(1.0+eta));\n\n//const float gratingSpacing = 100.0 * pow(0.1, 9.0);\nconst float gratingSpacing = 100.0 * 1.0E-9;\nconst float surfaceRoughness = 1.0;\n\n// map a visible wavelength[nm] to OpenGL's RGB representation\nvec3 lambda2rgb(float lambda)\n{\n    const float ultraviolet = 400.0;\n    const float infrared = 700.0;\n    \n    float a = (lambda - ultraviolet) / (infrared - ultraviolet);\n    \n    const float C = 7.0;\n    vec3 b = vec3(a) -vec3(0.75, 0.5, 0.25);\n    return max((1.0-C*b*b),0.0);\n}\n\nfloat fog(vec3 p, vec3 e){\n    bool useFogCoordinate = true;\n    float fdepth;\n    if(useFogCoordinate)\n        fdepth = length(p-e);\n    else\n        fdepth = abs(p.z);\n        \n    float fog;\n    float density = 0.02;\n    fog = exp(-density * fdepth);\n    return clamp(fog, 0.0, 1.0);\n}\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float rad){\n    return length(vec3(0.0) - p) - rad;\n}\n\nfloat plane(vec3 p){\n    float s = 0.0;\n    float d = abs(p.z - s);\n    return max(d,0.0);\n}\n\n\nfloat distanceToNearestSurface(vec3 p){\n\n    float dist = 10.0;\n   //\tvec3 q = vec3(mod(p.x, dist) - dist/2.0, p.yz);\n//    return min(min(cube(q), sphere(q)),plane(q));\n    //return min(cube(q), sphere(q));\n    //return plane(p);\n    //return cube(p)/sphere(p);\n\t//return max(-sphere(p),cube(p));\n    return max(sphere(p,2.0), max(plane(p), -sphere(p,0.5)));\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\nvec2 computeSphereTexCoord(vec3 p){\n    float longitude = acos(dot(vec2(0,-1), normalize(p.xz)));\n    if(p.x > 0.0)\n        longitude = 2.0*PI - longitude;\n    longitude /= 2.0*PI;\n    \n    float latitude = acos(dot(vec2(1,0), normalize(p.yz)));\n    latitude /= PI;\n    \n    return vec2(longitude, latitude);\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e){\n\n    \n    vec3 lightVector = normalize(l-p);\n    vec3 eyeVector = normalize(e-p);\n    vec3 halfVector = normalize(lightVector + eyeVector);\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(ambient + diffuse + specular, vec3(1.0));\n}\n\nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  float dist = 0.0;\n  for(int i = 0; i < 20; i++){\n    float nearest = distanceToNearestSurface(p + dir*dist);\n    if(nearest < 0.01)\n    {\n        //return (vec3(1.0)+computeSurfaceNormal(p+dir*dist))/2.0;\n    \tvec3 hit = p+dir*dist;\n                //vec3 light = vec3(100.0,\n                  //          30.0,\n                    //        50.0);\n        vec3 light = vec3(100.0*sin(iTime),\n                            30.0*cos(iTime),\n                            50.0*(1.5+cos(iTime)));\n        vec3 normal = computeSurfaceNormal(hit);\n        vec3 pixelColor = computeLambert(hit, normal, light, p);\n        vec2 texcoord = computeSphereTexCoord(hit);\n        \n        vec3 L = normalize(light - hit);\n        vec3 V = -dir;\n        vec3 H = L+V;\n        \n        vec3 T = cross(normalize(hit),normal);\n        float u = abs(dot(T,H));\n        \n        vec3 diffColor = vec3(0.0);\n        \n        const int numSpectralOrders = 3;\n        \n        for (int m=1; m<= numSpectralOrders; ++m)\n        {\n         \tfloat lambda = gratingSpacing * u / float(m);\n            diffColor += lambda2rgb(lambda);\n        }\n            \n        float w = dot(normal, H);\n        float e = surfaceRoughness * u / w;\n        vec3 hilight = exp(-e*e)*vec3(1.0,1.0,1.0);\n        \n        const float diffAtten = 0.8;\n        vec3 color = diffAtten*diffColor+hilight;\n        return color;\n        \n    } \n    dist += nearest;\n  }\n  //return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 cameraPosition = vec3( cameraDistance*sin(iTime), 0.0, cameraDistance*cos(iTime));\n\t//vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0,-1.0*cos(iTime));\n\n    vec2 mouseUV = vec2(0.5,0.5);\n    if(iMouse.z>0.0)  \n        mouseUV = 2.0*iMouse.xy/iResolution.xy-1.0;\n  \n    float d = 10.0;\n    float z = d*cos(mouseUV.y*PI/2.0);\n    vec3 cameraPosition = vec3(sin(mouseUV.x*PI/2.0) * z, d*sin(mouseUV.y*PI/2.0), cos(mouseUV.x*PI/2.0)*z);\n\tvec3 cameraDirection = -normalize(cameraPosition);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n    cameraUp = normalize(cross(nright, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n\n\tvec3 pixelColour = intersectsWithWorld(cameraPosition, rayDirection);\n            \n\n    fragColor = vec4(pixelColour, 1.0);\n}\n\n\n/** \n\n\tthe screenshot is here:\n    https://www.dropbox.com/s/ya2hhxvz1ixqipv/localShadertoysTextures.jpg?dl=0\n\n\trun fiddler (http://www.telerik.com/fiddler)\n    enable HTTPS ( & decrypt ) in fiddler options\n    go to tab shown on screenshot (autoresponder) and set options\n    add rule, then enter url to capture\n    in this example: https://www.shadertoy.com/presets/tex00.jpg\n    (first in textures set)\n\tand\n    enter url for redirect to ( could be file://... or /usr/user/...\n    \n    in this example \n    http://ogario.wpload.com/skins/amiga.png\n\n\n    image dimensions must be power of 2.\n    load image (thumbnail won't be changed) into channel\n    use iChannel as always\n\n    FB Post: \n    https://www.facebook.com/photo.php?fbid=10153170819997409&set=o.163777690435874&type=3&pnref=story\n**/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 739, 770, 770, 1021], [1023, 1023, 1049, 1049, 1311], [1313, 1313, 1332, 1332, 1458], [1460, 1460, 1492, 1492, 1534], [1536, 1536, 1556, 1556, 1628], [1631, 1631, 1670, 1670, 1992], [1994, 1994, 2028, 2028, 2245], [2247, 2247, 2282, 2282, 2557], [2559, 2559, 2611, 2611, 3244], [3246, 3246, 3289, 3289, 4732], [4735, 4735, 4792, 4956, 6001]]}
{"id": "MstcWs", "name": "Helix Distance", "author": "tdhooper", "description": "Non-warped helix distance", "tags": ["spiral", "helix", "twist"], "likes": 28, "viewed": 1024, "published": "Public API", "date": "1520684612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nHelix Distance\n--------------\n\nI've been wanting to create nice even helix shapes, most of the methods\nI've seen usually twist some geometry around an axis, but this leads to\na squashed cross-section with large radiuses.\n\nInstead, here I'm finding an approximate closest point on the helix and\nusing that to calculate the distance. To see how this looks, enable\nVISUALISE_CLOSEST below and click around the canvas.\n\nI'm also constructing 'helix coordinates' which you can see visualised\nas the uv texture. These can also be used for twisting regular geometry\naround the helix.\n\nThere's a seam that appears for small radii, for which I don't think\nthere's a neat solution. The problem is, as you approach the central\naxis of a helix, the closest point could be on the opposite side, this\nvaries with the thickness of the pipe geometry too.\n\nThese Wikipedia pages are helpful when thinking about the geometry\nof helices:\n\n* https://en.wikipedia.org/wiki/Helix_angle\n* https://en.wikipedia.org/wiki/Lead_(engineering)\n\n*/\n\n//#define VISUALISE_CLOSEST\n\n// --------------------------------------------------------\n// Structs\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec2 uv;\n    int id;\n};\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    vec3 rayDirection;\n};\n\n\n// --------------------------------------------------------\n// Utilities\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n    \n// Repeat space along one axis\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\nvec3 intersectPlane(vec3 rayOrigin, vec3 rayDirection, vec3 normal, float offset) {\n\tfloat dist = dot(normal, normal * offset - rayOrigin) / dot(normal, rayDirection);\n\treturn rayOrigin + rayDirection * dist;\n}\n\n// Cartesian to polar coordinates\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\n// Polar to cartesian coordinates\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\n// Closest of two points\nvec3 closestPoint(vec3 pos, vec3 p1, vec3 p2) {\n    if (length(pos - p1) < length(pos - p2)) {\n        return p1;\n    } else {\n        return p2;\n    }\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n// --------------------------------------------------------\n// Helix\n// --------------------------------------------------------\n\nvec2 closestPointOnRepeatedLine(vec2 line, vec2 point){\n\n    // Angle of the line\n    float a = atan(line.x, line.y);\n\n    // Rotate space so we can easily repeat along\n    // one dimension\n    pR(point, -a);\n\n    // Repeat to create parallel lines at the corners\n    // of the vec2(lead, radius) polar bounding area\n    float repeatSize = sin(a) * line.y;\n    float cell = pMod1(point.x, repeatSize);\n\n    // Rotate space back to where it was\n    pR(point, a);\n\n    // Closest point on a line\n    line = normalize(line);\n    float d = dot(point, line);\n    vec2 closest = line * d;\n\n    // Part 2 of the repeat, move the line along it's\n    // perpendicular by the repeat cell\n    vec2 perpendicular = vec2(line.y, -line.x);\n    closest += cell * repeatSize * perpendicular;\n\n    return closest;\n}\n\n// Closest point on a helix\nvec3 closestHelix(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnRepeatedLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n\n// Cartesian to helix coordinates\nvec3 helixCoordinates(vec3 p, vec3 closest, float lead, float radius) {\n    float helixAngle = atan((2. * PI * radius) / lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x / lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    return vec3(x,y,z);\n}\n\nvec3 mousePos;\nbool mouseDown;\n\nModel visualiseClosest(vec3 p) {\n    float lead = 3.;\n    float radius = 1.5;\n    \n    vec3 helix = closestHelix(p, lead, radius);\n    float d = length(p - helix) - .1;\n    \n    vec3 testPoint = vec3(sin(iTime * .75) * 3., cos(iTime * .75) * .8, 0.);\n    if (mouseDown) {\n    \ttestPoint = mousePos;\n    }\n\n    vec3 testHelix = closestHelix(testPoint, lead, radius);\n\n    d = min(d, length(p - testHelix) - .2);\n    d = min(d, length(p - testPoint) - .1);\n    d = min(d, fCapsule(p, testPoint, testHelix, .05));\n\n    return Model(d, vec2(0), 0);\n}\n\nModel map(vec3 p) {\n    #ifdef VISUALISE_CLOSEST\n\t\treturn visualiseClosest(p);\n   \t#endif\n    \n    float phase = iTime * PI * 2. / 8. - .5;\n    float lead = mix(1., 8., sin(phase) * .5 + .5);\n    float radius = mix(0.001, 1.8, cos(phase) * .5 + .5);\n\n    vec3 helix = closestHelix(p, lead, radius);\n    float d = length(p - helix) - .5;\n    \n    vec3 hp = helixCoordinates(p, helix, lead, radius);\n\tvec2 uv = vec2(hp.x, atan(hp.y, hp.z) / PI / 2.);\n    \n    return Model(d, uv, 0);\n}        \n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    vec3 col;\n    if (hit.isBackground) {\n        col = vec3(.1);\n    } else {\n        vec2 uv = hit.model.uv;\n        uv *= vec2(4., 8.);\n        uv = cos(uv * PI * 2.);\n        uv = smoothstep(.5, .55, uv);\n        col = vec3(1.-uv.yx, 1.);\n        #ifdef VISUALISE_CLOSEST\n        col = vec3(1);\n        #endif\n        vec3 light = normalize(vec3(.5,1,0));\n\t    vec3 diffuse = vec3(dot(hit.normal, light) * .5 + .5);\n\t\tcol *= diffuse;\n    }\n    #ifndef VISUALISE_CLOSEST\n    if (hit.isBackground || hit.pos.z > 0.) {\n\t\tvec3 debugPlanePos = intersectPlane(\n            hit.rayOrigin, hit.rayDirection, vec3(0,0,1), 0.\n        );\n        float dist = map(debugPlanePos).dist;\n        vec3 meter = vec3(mod(dist, 1./4.));\n        col = mix(col, meter, .5);\n    }\n    #endif\n\treturn col;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .1;\n\n\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - FUDGE_FACTOR);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(model, pos, isBackground, normal, rayOrigin, rayDirection);\n}\n\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n\n\tvec3 camPos = vec3(0,0,-6);\n    vec3 camTar = vec3(0);\n    vec3 camUp = vec3(0,1,0);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n\n    float focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 mouseRayDirection = normalize(camMat * vec3(m, focalLength));\n    mousePos = intersectPlane(camPos, mouseRayDirection, vec3(0,0,1), 0.);\n    mouseDown = iMouse.z > 0.;\n    \n    Hit hit = raymarch(camPos, rayDirection);\n\n    vec3 color = render(hit);\n   \tcolor = pow(color, vec3(1. / 2.2)); // Gamma\n    fragColor = vec4(color,1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1377, 1575, 1607, 1607, 1652], [1658, 1689, 1729, 1729, 1862], [1864, 1948, 1992, 1992, 2104], [2106, 2178, 2227, 2227, 2267], [2269, 2340, 2370, 2370, 2451], [2453, 2453, 2536, 2536, 2663], [2665, 2699, 2725, 2725, 2915], [2917, 2951, 2977, 2977, 3063], [3065, 3090, 3137, 3137, 3243], [3245, 3314, 3359, 3359, 3829], [3832, 3962, 4017, 4043, 4760], [4762, 4790, 4843, 4843, 5105], [5108, 5142, 5213, 5213, 5573], [5607, 5607, 5639, 5639, 6153], [6155, 6155, 6174, 6174, 6638], [6649, 6783, 6804, 6804, 7593], [7596, 7938, 7964, 7964, 8221], [8223, 8223, 8271, 8271, 9027], [9030, 9030, 9080, 9080, 9223], [9225, 9225, 9280, 9280, 9991]]}
{"id": "Mstczs", "name": "weather: rainy", "author": "alfredzhenyu", "description": "rainy", "tags": ["weather", "rainy"], "likes": 6, "viewed": 589, "published": "Public API", "date": "1519908214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\n\nfloat rand(float x) { return fract(sin(x) * 71523.5413291); }\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(13.4251, 15.5128))); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    f *= f*(3.-2.*f);\n    return mix(mix(rand(i), rand(i+vec2(1,0)), f.x),\n               mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n{\n    return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*iTime))-(1.0-density)), 1.0-sharpness);\n}\n\n\n#define NUM_LIGHTS 12\n\nvec4 lightArray[NUM_LIGHTS];\nvec3 lightColours[NUM_LIGHTS];\n\nconst float kPI = 3.141592654;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\nC_Ray ray;\n\nvec2 coord;\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b )\n{\n    float k = 1.5;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n//-----------------------------------------------------------------------------------------\nvec3 RotateY( const in vec3 vPos, const in float ang)\n{\n\tfloat s = sin(ang);\n\tfloat c = cos(ang);\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n\n//-----------------------------------------------------------------------------------------\nfloat Hash(in vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(27.16898, 28.90563))) * 44549.5473453);\n}\n\n//-----------------------------------------------------------------------------------------\nfloat Noise(in vec2 p)\n{\n\tvec2 f;\n\tf = fract(p);\t\t\t// Separate integer from fractional\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\t// Cosine interpolation approximation\n    float res = mix(mix(Hash(p),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b)\n{\n\treturn length(max(abs(p)-b,0.0))-.5;\n}\n\n//-----------------------------------------------------------------------------------------\nfloat GetDistanceBox(const in vec3 vPos, const in vec3 vDimension)\n{\n\treturn length(max(abs(vPos)-vDimension,0.0));\n}\n\n//-----------------------------------------------------------------------------------------\nfloat MapToScene( const in vec3 vPos )\n{   \n\tfloat fResult = 1000.0;\n\t\n\tfloat fFloorDist = vPos.y + 3.2;\t\n\tfResult = min(fResult, fFloorDist);\n\t\n\n\t\n\tvec3 vBuilding2Pos = vec3(60.0, 0.0, 55.0);\n\tconst float fBuilding2Radius = 100.0;\n\tvec3 vBuilding2Offset = vBuilding2Pos - vPos;\n\tfloat fBuilding2Dist = length(vBuilding2Offset.xz) - fBuilding2Radius;\n\tfBuilding2Dist = max(vBuilding2Offset.z - 16.0, -fBuilding2Dist); // back only\n\t\n\tfResult = min(fResult, fBuilding2Dist);\n\n\t\n\tvec3 vCabDomain = vPos;\n\tvCabDomain -= vec3(-1.4, -1.55,29.5);\n\tvCabDomain = RotateY(vCabDomain, 0.1);\n\tfloat fCabDist = RoundBox(vCabDomain+vec3(0.0, .85, 0.0), vec3(.8, .54, 2.5));\n\tfResult = min(fResult, fCabDist);\n\tfCabDist = RoundBox(vCabDomain, vec3(.6, 1.2, 1.2));\n\tfResult = sMin(fResult, fCabDist);\n\n\tvec3 vBusDomain = vPos;\n\tvBusDomain -= vec3(-15., 0.0, 29.5);\n\tvBusDomain = RotateY(vBusDomain, 0.35);\n\tfloat fBusDist = RoundBox(vBusDomain, vec3(.55, 1.8, 4.0));\n\t\t\n\tfResult = min(fResult, fBusDist);\n\t\t\n\tvec3 vBusShelter = vPos;\n\tvBusShelter -= vec3(7.5, -2.0, 30.0);\n\tvBusShelter = RotateY(vBusShelter, 0.3);\n\tfloat fBusShelterDist = RoundBox(vBusShelter, vec3(.725, 5.3, 1.7));\n\t\t\n\tfResult = min(fResult, fBusShelterDist);\n\t\n\n\t\n\treturn fResult;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Raymarch( const in C_Ray ray )\n{        \n    float fDistance = .1;\n    bool hit = false;\n    for(int i=0;i < 50; i++)\n    {\n\t\t\tfloat fSceneDist = MapToScene( ray.vOrigin + ray.vDir * fDistance );\n\t\t\tif(fSceneDist <= 0.01 || fDistance >= 150.0)\n\t\t\t{\n\t\t\t\thit = true;\n                break;\n\t\t\t} \n\n        \tfDistance = fDistance + fSceneDist;\n\t}\n\t\n\treturn fDistance;\n}\n\n//----------------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------------\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\n    vec2 vUV = coord.xy;\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\t\n\n\tvViewCoord.y *= -1.0;\n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vWorldUp, vForwards));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    \n}\n\n//----------------------------------------------------------------------------------------\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vInterest - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, ray);\n}\n\n//----------------------------------------------------------------------------------------\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\nvec2 hash2b(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p+4.5476351));\n}\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 fbm2(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += abs(noise2(x)+.5 )* a;\n        x *= 2.;\n        a *= .5;\n    }\n     \n    return r;\n}\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.2, 1. );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\n\n\nfloat thunderbolt(vec2 x,vec2 tgt)\n{\n    vec2 r = tgt;\n    float d=1000.;\n    float dist=length(tgt-x);\n     \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= (noise2(r+iTime)+vec2(0.,.7))*2.;\n        dist = dseg(s,x-r);\n        d=min(d,dist);\n        \n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return exp(-5.*d)+.2*exp(-1.*dist);\n   \n}\n\n\n\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Yes, that's right, this is done for EVERY pixel! Haha - *gulp*\n\t// X, Y, Z, POWER...\n\t\n\t// R, G, B...\n\t\n    vec3 vCameraPos = vec3(0.0, 0.0, 9.8);\n\tfloat ang = iTime * .3 + 3.4;\n\tfloat head = pow(abs(sin(ang*8.0)), 1.5) * .15;\n\tvCameraPos += vec3(cos(ang) * 2.5, head,  sin(ang) * 8.5);\n    coord = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 vCameraIntrest = vec3(-1.0, head, 25.0);\n\tGetCameraRayLookat( vCameraPos, vCameraIntrest, ray);\n\tvec3 originalRayDir = ray.vDir;\n\n    //float fHitDist = Raymarch(ray);\n\t//vec3 vHitPos = ray.vOrigin + ray.vDir * fHitDist;\n\t//vec3 vHitPos = vCameraPos + ray.vDir * fHitDist;\n\tvec3 normal;\n\tvec3 col = vec3(0.0);\n\t\n\n\t\n\t// Twelve layers of rain sheets...\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tfloat dis = 1.;\n    //col = vec3(0.5,0.5,0.5);\n    col = mix(rgb(151., 176., 201.), rgb(105, 117, 135), coord.y);//sky\n\tfor (int i = 0; i < 2; i++)//iä¸ºå¤§å°\n\t{\n\t\t//vec3 plane = vCameraPos + originalRayDir * dis;\n\t\t//plane.z -= (texture(iChannel3, q*iTime).x*3.5);\n\t\t//if (plane.z < vHitPos.z)\n\t\t//{\n\t\t\tfloat f = 1.;\n\n\t\t\tvec2 st =  f * (q * vec2(-3.5, .05)+vec2(-iTime*.1+q.y*.11, iTime*.07));//y*.2é£å¤§å°\n            //vec2 st =  f * (q * vec2(1.5, .05)+vec2(-iTime*.1+q.y*.2, iTime*.12));\n\t\t\tf = (texture(iChannel3, st * .5, -99.0).x + texture(iChannel3, st*.5, -99.0).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 25.0) * 10.0, 0.00, q.y*.4+.05);//yæ¹åè¶ä¸å°åºé¨ï¼éæåº¦éä½\n            //f = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, q.y*.4+.05);//29.0è½è§åº¦\n\n\t\t\tvec3 bri = vec3(.15);//é¨å¯è§åº¦\n\n\t\t\tcol += bri*f;\n\t\t//}\n\n\t}\n\t//col = clamp(col, 0.0, 1.0);\n\t\t\t\n\t//col = mix(vec3(0), col, smoothstep(2.25, 4.0, iTime));\n\t//col = pow(col, vec3(1.1));\n    col = mix(col, vec3(0.9), 0.7*cloud(coord,4.,10.,1.9,0.95,0.05) * cloud(coord,2.,2.,0.5,0.15,0.025)*coord.y);\n    \n    float cpos2 = coord.y - 0.2;\n    float cloudPos2 = exp(-10.*cpos2*cpos2);\n    col = mix(col, vec3(0.8), 0.8 * cloud(coord,2.,2.5,0.50,0.15,0.01)*cloudPos2);\n    \n    /*\n    vec2 p = 2.*fragCoord.xy/iResolution.yy-1.;\n    vec2 d;\n    vec2 tgt = vec2(1., -8.);\n    float c=0.;\n    \n        \n    float t = hash(floor(5.*iTime));\n    tgt+=8.*hash2b(tgt+t);\n    if(hash(t+2.3)>.8)\n\t{\n\t\tc= thunderbolt(p*10.+2.*fbm2(5.*p),tgt);\t\n\t\tcol+=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\t\n\t}\n*/\n    \n    \n\t\n\tfragColor = vec4(col, 1.0);\n}\n\t", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mstczs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 96, 96, 136], [138, 138, 158, 158, 205], [207, 207, 228, 228, 417], [419, 419, 438, 438, 598], [600, 600, 695, 695, 803], [998, 1089, 1121, 1121, 1227], [1229, 1321, 1376, 1376, 1520], [1522, 1614, 1637, 1637, 1709], [1711, 1803, 1827, 1827, 2138], [2140, 2231, 2264, 2264, 2304], [2306, 2398, 2466, 2466, 2515], [2517, 2609, 2649, 2649, 3847], [3849, 3940, 3978, 3978, 4311], [4405, 4496, 4600, 4600, 4911], [4913, 5004, 5090, 5090, 5215], [5217, 5309, 5330, 5330, 5377], [5378, 5378, 5404, 5404, 5461], [5463, 5463, 5483, 5483, 5541], [5542, 5542, 5563, 5563, 5618], [5647, 5647, 5668, 5668, 5902], [5904, 5904, 5923, 5923, 6107], [6109, 6109, 6141, 6141, 6228], [6230, 6230, 6266, 6266, 6455], [6458, 6458, 6494, 6494, 6958], [6963, 7054, 7111, 7217, 9445]]}
{"id": "MstyRl", "name": "fck your eyes", "author": "domegod", "description": "best full-screen", "tags": ["brutal"], "likes": 2, "viewed": 69, "published": "Public", "date": "1519860818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float offset = fragCoord.x + (iResolution.x * 500.0 * fragCoord.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 10.0*cos(offset + iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 381]]}
{"id": "Mstyzl", "name": "dunno01", "author": "Del", "description": "dunno", "tags": ["dunno"], "likes": 9, "viewed": 116, "published": "Public", "date": "1519875085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// dunno\n// Del 01/03/2018\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.y-=time*2./scale;\n    //uv.x += time*0.2;\n    uv.x+=sin(uv.y+time*.95)*0.025;\t///scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head,float d)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    //vec3 background = vec3(0.3,0.3,0.3);\n    vec3 background2 = vec3(1.0-d*d,0.3,0.35);\n    float bub_brightness = 2.5+head+d;\n    vec3 scol = background2 * bub_brightness; //vec3(1.0,1.0,1.0);\n    scol = mix(background2,scol,c);\n    return scol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy)/ iResolution.y;\n\n    float d = length(uv);\n    float head = 1.0-length(uv);\n    d+=(0.5+sin(iTime*2.0)*0.5)*0.25;\n    uv *= 0.25;\n    vec3 col = Bubbles(uv*(d+0.5), head,d);\n    fragColor =vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mstyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 60, 60, 427], [429, 429, 471, 471, 854], [856, 856, 913, 913, 1165]]}
{"id": "MsVcDm", "name": "repeating sound sensitive cube", "author": "Nitato_", "description": "cube visualiser ", "tags": ["3d", "raymarch", "cube", "visualiser"], "likes": 9, "viewed": 437, "published": "Public", "date": "1522337063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float audioLevel;\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nmat3 rotMatrixFinal(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float a = 1.0 - c;\n    float a2 = a*a;\n    float c2 = c*c;\n    float s2 = s*s;\n   return mat3(c2*(a+c), -s*(a2+2.*c*a+c2), -s*(c*a + c2),\n               -s2*a+s*c2-s2*c, c2*a+c2*c, -s*c*a - s*c2 - s2*c,\n               s*c*a+s*c2+s2*c, s*c*a+s*c2, c2*a+c2*c-s2*s);\n}\nvec3 opRep( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\nfloat map (vec3 p) {\n    mat3 rot = rotMatrixFinal(iTime);\n    vec3 p2 = opRep(p*rot, vec3(.5));\n    float d1 = sdBox(p2, vec3(.7,.7,.7)*(audioLevel*0.09+0.1));\n    return d1;\n}\nvec2 trace (vec3 o, vec3 r) {\n\tfloat t = 0.;\n    float i;\n    float precis = .01;\n    for (i = 0.; i < 14.; ++i) {\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        if (d<precis) break;\n        t += d;\n    }\n    return vec2(t, i);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    audioLevel = texture(iChannel0, vec2(.1,.25)).x;\n    vec2 uv = (2.*fragCoord-iResolution.xy )/iResolution.y;\n\tvec4 m = vec4(2.*iMouse - iResolution.xyxy ) /iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.));\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    \n    vec3 col = vec3(0.2,0.3,0.5*cos(iTime)+0.5)*(0.5*audioLevel);\n\tvec3 col1 = vec3(0.4,0.4,0.5*sin(iTime)+.5);\n    \n    vec2 t = trace(o, r);\n   \n    vec3 finalC = t.x>100. ? col : col1*t.x;\n    \n    fragColor = vec4(finalC,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 137], [138, 138, 172, 172, 494], [495, 495, 525, 525, 570], [571, 571, 591, 591, 748], [749, 749, 778, 778, 994], [995, 995, 1052, 1052, 1539]]}
{"id": "MsVcWR", "name": "HypnoCol", "author": "pomb", "description": "I don't know what I'm doing... but look deep into my eyes!", "tags": ["rings"], "likes": 3, "viewed": 399, "published": "Public", "date": "1521646716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nray GetRay(vec2 uv, vec3 campos, vec3 lookat, float zoom)\n{\n    ray a;\n    a.origin = campos;\n\tvec3 forward = normalize(lookat-campos);\n    vec3 right = cross(vec3(0.,1.,0.), forward);\n    vec3 up = cross(forward, right);\n    vec3 center = a.origin + forward * zoom;\n    vec3 intersectionPoint = center + uv.x * right + uv.y * up;\n    \n    a.direction = normalize(intersectionPoint-a.origin);\n    \n    return a;\n}\n\nvec3 ClosestPoint(ray r, vec3 p)\n{\n\treturn r.origin + max(0., dot(p-r.origin, r.direction))*r.direction;\n}\n\nfloat DistRay(ray r, vec3 p)\n{\n\treturn length(p-ClosestPoint(r, p));\n}\n\nfloat Ring(ray r, vec3 p, float size, float blur)\n{\n    \n    float d = DistRay(r, p);\n    \n    float c = S(size, size*(1.-blur), d);\n    c *= S(size*.8, size*.99, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    \n    vec3 camPos = vec3(0, .2, 0);\n    vec3 lookat = vec3(0, .2, 1.);\n    \n    float circleMoveSize = 0.02;\n    float circleMoveSpeed = iTime * 2.0f;\n    \n    lookat.x += sin(circleMoveSpeed) * circleMoveSize;\n    lookat.y += cos(circleMoveSpeed) * circleMoveSize;\n    \n    camPos.x += cos(iTime) * .2;\n    camPos.y += cos(iTime + 5.) * .1;\n\n    float speed = .05f;\n    float t = iTime * speed;\n    float s = 1./100.;\n    ray r = GetRay(uv, camPos, lookat, 2.);\n    float m = 0.;\n    \n    for(float i=0.; i<1.; i+=s)\n    {    \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =  ti * ti * ti * ti;\n        float focus = S(.8, 1., ti);\n        vec3 p = vec3(mouse.x, mouse.y, z);    \n        float size = mix(1.5, 10., focus * .02);         \n    \tm += Ring(r, p, size, .05) * fade;\t                \n    }\n    \n    float bgRing = S(0.95, .01, length(uv));     \n    vec3 bg = vec3(1., .9, .9) * bgRing;        \n    vec3 mask = (bg * .2) + m;\n        \n    vec3 col = 0.5 + 0.5 * sin(iTime-uv.xyx+vec3(2,4,0));\n    vec3 col2 = vec3(0.8, .85, .86);    \n    col = mix(col, col2, mask);\n    col *= mask;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 150, 150, 504], [506, 506, 540, 540, 612], [614, 614, 644, 644, 684], [686, 686, 737, 737, 868], [870, 870, 927, 927, 2266]]}
{"id": "MsVczR", "name": "Hypertori Rays", "author": "audiopixel", "description": "Light in the middle", "tags": ["raymarching", "rays", "lighting"], "likes": 7, "viewed": 185, "published": "Public", "date": "1520891338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Hypertori Rays'\n// Created by hepp maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nfloat map(vec3 p) {\n    float t = (iTime * 12.) + sin(iTime * .9) * 20.;\n    float a1 = -13. + sin(iTime * .8) * .3;\n    float a2 = -14.5 + sin(iTime * .9) * .2;\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5., (20.))-10.; a = abs(o.y);\n    p.yz *= r2d(sign(a)* .2);\n    p.xz *= r2d(sign(a)*(t * .04));\n    p.xz = amod(p.xz, 0.38205625 + sin(iTime * .7) * .13);\n    p.xz = max(abs(p.xz)-14.552, -14.0311);\n    p.z = mod(p.z, a1)-(a1 *.5);\n    p.x = mod(p.x, a2)-(a2 *.5);\n    p.y = mod(p.y+t, 12.)-5.;\n    d = min(d, soc(max(abs(p) + 2., -2.)));\n    return (length(p*-0.3637)-0.4866)*1.1851 - (d * (1.8873 + sin(iTime * 5.4) * .03));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.8;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 l = vec3(0, 0, -15);\n    vec3 ro = vec3(st, -18. + sin(iTime * .8) * 1.5);\n    vec3 rd = normalize(vec3(st+vec2(0.), 0.4 + sin(iTime * .6) * .14));\n    vec3 mp; mp = ro;\n    float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp); if (md <.001) break; mp += rd*md;\n    }\n    vec3 p = ro + rd * (mp);\n    vec3 normal = calcNormal(p);\n    float dif = clamp(dot(normal, normalize(l - p)), 0., 1.);\n    dif *= 5. / dot(l - p, l - p);\n    vec3 c2 = vec3(pow(dif, .2424));\n    c2 += vec3((mp.z * 2.5) * (md * .05), 0, 0 );\n    fragColor = vec4(c2, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVczR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[159, 288, 307, 307, 382], [384, 384, 412, 412, 497], [499, 499, 518, 518, 629], [631, 631, 650, 650, 1274], [1276, 1276, 1304, 1304, 1496], [1498, 1498, 1554, 1554, 2187]]}
{"id": "MsVyD1", "name": "A.T.Field...?", "author": "g2_xpf", "description": "You can draw a n-sided polygon by changing \"split\"(Default: 8).\n(split < 3) might show unexpected result.", "tags": ["polygon"], "likes": 1, "viewed": 104, "published": "Public", "date": "1521917921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\nconst float TWO_PI = PI * 2.;\nconst int split = 8;\n\nfloat getPolygon(vec2 v, int split){\n    float angle = atan(v.y, v.x) - PI / 2. +PI / float(split);\n    float angle2 = mod(angle, TWO_PI / float(split));\n    float r = length(v);\n    float angle3 = PI * (0.5 - 1. / float(split));\n    float len = r * sin(PI - angle3 - angle2) / sin(angle3);\n    if(len < 0.05) return 0.;\n    return max(0., mod(12.*len-iTime, 1.) - 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    \n    // Time varying pixel color\n    float diff = getPolygon(uv, split);\n    \n    // Output to screen\n    fragColor = vec4(diff, diff/8., 0.0, 0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 115, 115, 451], [453, 453, 509, 559, 781]]}
{"id": "MsVyRh", "name": "Doodling #2: Ghost", "author": "lsdlive", "description": "Doodling session.\nThanks to iq, mercury, lj, shane, balkhan & all shadertoyers.\nGreets to all the shader showdown paris gang.", "tags": ["tunnel", "raymarch", "doodling"], "likes": 37, "viewed": 1144, "published": "Public", "date": "1521062915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 path(float t) {\n    float a = sin(t*.2+1.5),b=sin(t*.2);\n    return vec2(a*2., a*b);\n}\n\nmat2 r2d(float a) {\n    float c=cos(a),s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p.x = abs(p.x) - d.x;\n    p.y = abs(p.y) - d.y;\n    if(p.y>p.x)p=p.yx;\n}\n\nfloat g=0.;\nfloat de(vec3 p) {\n   \n    vec3 q = p;\n    q.x += q.z*.1;\n    q.z += iTime*.1;\n    q = mod(q-1., 2.)-1.;\n    float s = length(q) - .001 + sin(iTime*30.)*.005;\n    \n    p.xy -= path(p.z);\n    \n    p.xy *= r2d(p.z*.9);\n    mo(p.xy, vec2(.6, .12));\n    mo(p.xy, vec2(.9, .2));\n    \n    p.xy *= r2d(p.z*.5);\n    \n    mo(p.zy, vec2(.1, .2));\n    p.x = abs(p.x) - .4;\n    float d = length(p.xy) - .02 - (.5+.5*sin(p.z))*.05;\n    \n    d = min(d, s);\n    \n    \n    g+=.01/(.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy -.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float dt = iTime * 6.;\n    vec3 ro = vec3(0,0, -3. + dt);\n    vec3 ta = vec3(0, 0, dt);\n    \n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n    \n    vec3 fwd = normalize(ta -ro);\n    vec3 left = cross(vec3(0,1,0),fwd);\n    vec3 up = cross(fwd, left);\n    \n    vec3 rd = normalize(fwd + left*uv.x+up*uv.y);\n\n    vec3 p;\n    float ri,t=0.;\n    for(float i=0.;i<1.;i+=.01) {\n    \tri = i;\n        p=ro+rd*t;\n        float d = de(p);\n        if(d<.001) break;\n        t+=d*.2;\n    }\n\tvec3 bg =  vec3(.2, .6, .6)*.2; \n    vec3 col = mix(vec3(.4, .5, .5), bg,ri);\n    col += g*.02;\n    \n    col = mix(col, bg, 1.-exp(-.01*t*t));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 91], [93, 93, 112, 112, 173], [175, 175, 206, 206, 283], [297, 297, 315, 315, 787], [789, 789, 846, 846, 1597]]}
{"id": "MsVyRW", "name": "kale mash", "author": "derive_by", "description": "mix of \n\nhttps://www.shadertoy.com/view/ltl3Dj\nand\nhttps://www.shadertoy.com/view/Xd2GzR", "tags": ["mandelbrot", "kaleidoscope", "complex"], "likes": 3, "viewed": 159, "published": "Public", "date": "1522089638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec4 dcAdd( vec4 a, vec4 b )\n{\n    return a + b;\n}\n\nvec4 dcMul( vec4 a, vec4 b )\n{\n    return vec4( a.x*b.x - a.y*b.y, \n\t\t\t\t a.x*b.y + a.y*b.x,\n\t\t\t\t a.x*b.z + a.z*b.x - a.y*b.w - a.w*b.y,\n\t\t\t\t a.x*b.w + a.w*b.x + a.z*b.y + a.y*b.z );\n}\n\nvec4 dcSqr( vec4 a )\n{\n    return vec4( a.x*a.x - a.y*a.y, \n\t\t\t\t 2.0*a.x*a.y,\n\t\t\t\t 2.0*(a.x*a.z - a.y*a.w),\n\t\t\t\t 2.0*(a.x*a.w + a.y*a.z) );\n}\n\n//--------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.14159265359;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    p = kale(p, pi/6.0, iTime*0.1*pi, pi/2.0);\n    // animation\t\n\tfloat tz = 0.5 + cos(0.0111225*iTime);\n    float zo = pow( 0.5, 1.0*tz );\n\t\n    vec4 c = vec4( vec2(-0.05,.6805) + p*zo, 1.0, 0.0 );\n\n\tfloat m2 = 1.0;\n    float co = 0.0;\n\t\n\tvec4 z = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\t\t\t\n        // Z -> ZÃÂ² + c\t\t\n\t\tz = dcAdd( dcSqr(z), c );\n\t\t\n\t\tm2 = dot( z.xy, z.xy );\n        co += 1.0;\n    }\n\n    // distance\t\n\t// d(c) = |Z|ÃÂ·log|Z|/|Z'|\n\tfloat d = 0.0;\n\tif( co<256.0 ) d = sqrt( dot(z.xy,z.xy)/dot(z.zw,z.zw) )*log(dot(z.xy,z.xy));\n\n\t\n    // do some soft coloring based on distance\n\td =  4.0*d/zo, 0.0, 1.0 ;\n\td = pow( d, 0.825 );\n    vec3 col = vec3( d );\n    \n    \n    vec2 q = p;\n\n    // Time varying pixel color\n    vec3 bol = 0.8 + 0.2*sin(iTime+p.xxx+vec3(0,2,6)) - 0.2*cos(iTime+p.yyy+vec3(6,1,3));\n    \n    float r = 0.5 + 0.4 * cos(atan(q.y,q.x)*16.0*sin(iTime+q.x-q.y) - 32.0*q.x*q.y*(cos(iTime+q.x-q.y)));\n    bol *= smoothstep(d, r-0.1-zo, length(q-d+1.0));\n    \n    fragColor = vec4(bol, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 218], [220, 220, 250, 250, 270], [272, 272, 302, 302, 455], [457, 457, 479, 479, 598], [600, 654, 711, 711, 1924]]}
{"id": "MsycD1", "name": "lightsweep 2.0", "author": "Sleicreider", "description": "lightsweep effect testing around", "tags": ["effect", "lightsweep"], "likes": 2, "viewed": 130, "published": "Public", "date": "1521808566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = fragCoord.xy/iResolution.xy;  \n    r.y = 1.0 - r.y;\n    \n    vec2 t = r;\n    t.y = sin(t.x * 4. + iTime*2.);\n    \n    vec4 a = mix(texture(iChannel0,r.xy),vec4(1.), t.y);\n    vec4 col = clamp(a,texture(iChannel0, r.xy), vec4(1.));\n\n    fragColor = col;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsycD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 322]]}
{"id": "MsycDR", "name": "Quaternion Collatz Cross Section", "author": "rodolphito", "description": "Quaternion Collatz Cross Section, try the mouse.\n\nThe mouse changes what cross section of the 4D fractal to display.\n\nComment line 41 to get the more familiar side view.", "tags": ["fractal", "quaternion", "collatz"], "likes": 0, "viewed": 100, "published": "Public", "date": "1521583505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi  = 4.0*atan(1.0);\n\n#define fractalIters 7\n\nvec4 qadd(vec4 a, float b)\n{\n    return vec4(a.xyz,a.w+b);\n}\n\nvec4 qmul(vec4 a, vec4 b)\n{\n\treturn vec4(\n        b.x*a.w + b.w*a.x + b.z*a.y - b.y*a.z,\n        b.y*a.w - b.z*a.x + b.w*a.y + b.x*a.z,\n        b.w*a.w - b.x*a.x - b.y*a.y - b.z*a.z,\n        b.z*a.w + b.y*a.x - b.x*a.y + b.w*a.z\n    );\n}\n\nvec4 qmulj(vec4 q)\n{\n    return vec4(-q.z, q.w, q.x, -q.y);\n}\n\nvec4 qexp(vec4 q)\n{\n    float len = length(q.xyz);\n    q.xyz /= len;\n    return exp(q.w)*vec4(q.xyz*sin(len), cos(len));\n}\n\nvec3 project(vec4 n)\n{\n    return n.yzw*inversesqrt(n.x*2.0 + 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 z = 2.5*(vec4(fragCoord, iMouse.xy) * 2.0 - iResolution.xyxy) / iResolution.y;\n    if (iMouse.xy == vec2(0.0,0.0)) z.zw = 0.1*sin(iTime + vec2(0.0, pi*0.5));\n    z = z.xwyz;  //Comment for side view\n    vec4 dz = vec4(0.0,0.0,0.0,1.0);\n    for(int i = 0; i < fractalIters; i++)\n    {\n        vec4 pz, z4, nz;\n        z4 = qadd(1.25*z, 0.5 );\n        pz =-qexp(qmulj(pi*z));\n        nz = qmulj(pi*z4);\n        nz = qadd(    nz, 1.25);\n        nz = qmul(    nz, pz  );\n        nz = qadd(    nz, 1.75);\n        dz = qmul(    nz, dz  );\n        //if (dz != dz) break;\n        z  = qadd(1.75*z, 0.5 );\n        z += qmul(    pz, z4  );\n    }\n    vec3 col = project(normalize(z)) * 0.5 + 0.5;\n    fragColor = vec4(1.0-pow(1.0-col,vec3(1.0-0.00000000000001*dot(z,z))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsycDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 86, 86, 118], [120, 120, 147, 147, 357], [359, 359, 379, 379, 420], [422, 422, 441, 441, 544], [546, 546, 568, 568, 615], [617, 617, 672, 672, 1449]]}
{"id": "MsyyDD", "name": "Checkerboard FX (237b)", "author": "merry", "description": "A simple checkerboard effect in less than 256 bytes.", "tags": ["2d", "demoscene", "checkerboard"], "likes": 7, "viewed": 511, "published": "Public API", "date": "1522193714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n\tc = vec4(0);   \n    for (float i = 5.; i < 55.; i*= 1.9)\n    {\n\t    vec2 r = iResolution.xy, v = floor(p.xy * vec2(r.x/r.y, 1) / r.xy * i + sin(iTime / vec2(2,3)) * 9.);\n        c+= vec4(mod(v.x + v.y, 2.)) * (1. - c.a) * vec4(pow(20./i, .9) * vec3(.3,.4,.1) * p.y/r.y, 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 319]]}
{"id": "Mt33RM", "name": "sdf Tunnel", "author": "XDargu", "description": "Tunnel test", "tags": ["sdftunnel"], "likes": 14, "viewed": 209, "published": "Public", "date": "1520173494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n   I wanted to make some basic material blending capable of blending materials using only \n   the material ID, without the actual colour. This is my clumsy first attempt. \n   Currently it can't blend more than two materials, and it's probably much more expensive\n   than it shoud be. Artifacts are evident when it tries to blend three or more colours.\n   \n   The way it works is having two material IDs and a blend amount between them. The first id\n   is always the dominant material of the surface, using the blend amount to mix between the\n   materials. In the render function we can get the material info of the current surface and\n   set the colour using the material ID. This is done for both materials, and then both colours\n   are mixed in order to produce the final value.\n\n Sources:\n - http://mercury.sexy/hg_sdf/\n - http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n*/\n#define BLEND_SIZE 0.2\n#define PI 3.14159\n\n#define CAMSPEED 2.0\n\n//#define VIEW_BLEND\n//#define VIEW_SECOND_COL\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// SDF result struct\nstruct SDFRes\n{\n    float d; // distance\n    float m; // material\n    float m2; // secondary material\n    float b; // blend amount: 0=m, 1=m2\n};\n    \nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat getBlend(float d1, float d2)\n{\n    float diff = -abs(d1 - d2);\n    float blend = diff / BLEND_SIZE;\n    blend = saturate((blend + 1.0) * 0.5);\n    return blend;\n}\n\n// Domain modifiers\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Operations\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat add(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat substract(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nSDFRes addSDF(in SDFRes f1, SDFRes f2 )\n{\n    if (f1.d < f2.d)\n    \treturn f1;\n    return f2;\n}\n\nSDFRes substractSDF(SDFRes f1, SDFRes f2 )\n{\n    float t = substract(f1.d, f2.d);\n    return SDFRes(t, (t < f2.d) ? f1.m : f2.m, 0.0, 0.0);\n}\n\nSDFRes blendSDF(SDFRes f1, SDFRes f2, float k)\n{\n    // Branching a lot :( Needs more work\n    \n   \tSDFRes closest  = f1;\n    SDFRes furthest = f2;\n\t\n\tfloat diff = float(f1.d > f2.d);\n    \n\tclosest.d =  mix(f1.d, f2.d,   diff);\n\tclosest.m =  mix(f1.m, f2.m,   diff);\n\tclosest.m2 = mix(f1.m2, f2.m2, diff);\n\tclosest.b =  mix(f1.b, f2.b,   diff);\n\t\n\tfurthest.d =  mix(f2.d, f1.d,   diff);\n\tfurthest.m =  mix(f2.m, f1.m,   diff);\n\tfurthest.m2 = mix(f2.m2, f1.m2, diff);\n\tfurthest.b =  mix(f2.b, f1.b,   diff);\n    \n\t// Dominant materials\n\tfloat mf1 = mix(closest.m2, closest.m, float(closest.b < 0.5));\n\tfloat mf2 = mix(furthest.m2, furthest.m, float(furthest.b < 0.5));\n    \n    // New distance\n    float t  = smin(f1.d, f2.d, k);\n    \n    // New blend\n    float bnew = getBlend(f1.d, f2.d);\n    float b = max(closest.b, bnew);\n    float bhigher = float(b > bnew);\n\n\tfloat m  = mix(mf1, closest.m,  bhigher);\n\tfloat m2 = mix(mf2, closest.m2, bhigher);\n    \n    return SDFRes(t, m, m2, b);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(in vec3 p, in float size )\n{\n    return length(p) - size;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdFloor( vec3 p, vec2 b )\n{\n  \tvec2 d = abs(p.xy) - b;\n    float t = p.y - b.y;\n    \n    //float h = 0.7 + 0.12 * (sin(p.x*8.3 - 1.));\n    float h = 0.7 + (sin(p.z) + 1.0) * 0.06;\n    float tiles = max(\n        \tpow(abs(sin(p.x*17.0 + 0.2)) * h, 18.0),\n        \tpow(abs(sin(p.z*17.0 + 0.2)) * h, 18.0)\n        );    \n    t -= 0.05 - tiles;\n    \n\treturn t;\n}\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nvec3 path(in float t)\n{\n    vec3 ret = vec3(0.0);\n    ret.x -= sin(t*0.5) * 0.8;\n    //ret.y -= sin(t*0.5) * 0.0;\n    return ret;\n}\n\nfloat sdTunnel( vec3 p )\n{   \n    p.y += sin(54.0*cos(p.x))*0.05;\n    //p.x -= sin(p.z) * sign(p.x) * 0.03;\n    \n    float t = 1.0 - length(p.xy);\n    \n  \treturn t;\n}\n\nSDFRes map(in vec3 pos )\n{   \n    pos -= path(pos.z);\n    SDFRes plane = SDFRes( sdTunnel(  pos - vec3(0.0, 0.0, 0.0) ), 0.5, 0.0 ,0.0);\n    \n    vec3 p = pos - vec3(0.0, 0.44, 3.0);\n    pMod1(p.z, 1.0);\n    \n    plane = addSDF( plane,\n                  SDFRes( udRoundBox(p, vec3(1.0, 0.05, 0.1), 0.01 ), 5.0, 0.0, 0.0)\n                  );\n    \n    p = pos - vec3(0.0, -0.2, 3.0);\n    pMod1(p.z, 1.5);\n    \n    plane = substractSDF( plane,\n                  SDFRes( sdBox(p, vec3(1.6, 0.5, 0.65) ), 0.5, 0.0, 0.0)\n                  );\n    \n    plane = blendSDF( plane,\n                  SDFRes( sdFloor(pos - vec3(0.0, -1.0, 0.0), vec2(1.0, 0.2) ), 2.0, 0.0, 0.0)\n                     , 16.0\n                  );\n    \n    /*plane = addSDF( plane,\n                  SDFRes( sdFloor(pos - vec3(0.0, -1.0, 0.0), vec2(1.0, 0.2) ), 2.0, 0.0, 0.0)\n                  );*/\n    \n    return plane;\n}\n\nvec3 getNormal(in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nSDFRes castRay(in vec3 ro, in vec3 rd, in float tmin)\n{    \n    float tmax = 30.0;    \n    \n    SDFRes p;\n    p.d = tmin;\n    p.m = 0.0;\n    p.m2 = 0.0;\n    p.b = 0.0;\n    \n\tfloat precis = 0.00000001;\n    \n    for (int i=0; i<50; i++)\n    {\n        SDFRes s = map( ro + rd * p.d );\n        if (s.d < precis || s.d > tmax)\n        {\n            break;\n        }\n        \n        p.m = s.m;\n        p.m2 = s.m2;\n        p.b = s.b;\n        p.d += s.d;\n    }\n    \n    if (p.d > tmax)\n        p.m = -1.0;\n    \n    return p;\n}\n\n\nfloat shadows(in vec3 ro, in vec3 rd, in float tmin)\n{\n    //return 1.0;\n    const float tmax = 0.95;\n    float res = 1.0;\n    float k = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<50; i++)\n    {\n        SDFRes h = map(ro + rd*t);\n        if( h.d<0.0001 )\n            return 0.0;\n        if (t > tmax)\n            return res*1.0;\n        \n        res = min( res, k*h.d/t );\n        t += h.d;\n    }\n    return res;\n}\n\nfloat occlusion(in vec3 ro, in vec3 rd)\n{\n    float occ = 0.0;\n    float sca = 1.4;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  rd * hr + ro;\n        float dd = map( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvoid getMaterialData(in float m, in vec3 pos, inout vec3 nor, inout vec3 col, inout float spow )\n{\n    col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    spow = 256.0;\n    \n    if ( m < 100.0 )\n        spow = 2.0;\n    \n    if( m<5.5 && m >= 4.5 )\n    {\n        col = tex3D(iChannel2, pos, nor);\n        spow = 256.0;\n    }\n    \n    if( m<1.5 && m != 0.0 )\n    {\n        vec3 opos = pos;\n        \n        pos.x -= path(pos.z).x;\n        pos.z *= 0.1;\n        pos *= 10.0;\n        float f = mod( floor(2.0*pos.z) + floor(2.0*pos.x), 2.0);\n        col = 0.4 + 0.1*f*vec3(1.0);\n        spow = 32.0 + 240.0 * (1.0 - f);\n        spow = 1.0;\n        \n        if (pos.y > 0.0)\n        {            \n            if (abs(pos.x) > 9.5)\n            {\n                col = vec3(1.0);\n                nor = doBumpMap( iChannel1, opos.xyz, nor, 0.01);\n                //col.x *= smoothstep(0.0, 0.3, abs(pos.y - 1.5) * 1.0);\n            }\n            else if (abs(pos.x) > 8.0)\n            {\n                col = vec3(0.0, 1.0, 1.0);\n                col = tex3D(iChannel2, opos, nor);\n                nor = doBumpMap( iChannel2, opos, nor, 0.01);\n                spow = 256.0;\n            }\n            else if (abs(pos.x) > 6.2)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n                col = tex3D(iChannel1, pos, nor);\n                //col = vec3(1.0, 0.7, 0.0) * 1.0;\n                spow = 256.0;\n            }\n            else {\n                nor = doBumpMap( iChannel1, opos.xyz, nor, 0.01);\n                col = tex3D(iChannel2, opos, nor) * 0.5;\n                spow = 256.0;\n            }\n            /*else if (abs(pos.x) > 4.0)\n            {\n                col = vec3(0.0, 1.0, 0.0);\n                \n            }\n            else\n            {\n                col = vec3(0.0, 0.0, 1.0);\n            }*/\n        }\n        else\n        {\n          if (abs(pos.x) > 8.9)\n            {\n                col = vec3(1.0);\n                //col = vec3(getGrey(tex3D(iChannel0, opos, nor)));\n                nor = doBumpMap( iChannel1, opos, nor, 0.01);\n                \n            }\n            else if (abs(pos.x) > 7.2)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n                col = tex3D(iChannel2, opos, nor);\n                nor = doBumpMap( iChannel2, opos, nor, 0.01);\n                spow = 256.0;\n            }\n            else\n            {\n                col = vec3(0.4, 0.2 , 0.0);\n                spow = 256.0;\n            }\n        }\n    }\n    \n    if( m < 2.5 && m > 1.5 )\n    {\n        nor = doBumpMap( iChannel1, pos, nor, 0.01);\n        \n        pos -= path(pos.z);\n        pos.z *= 0.5;\n        pos *= 2.0;\n        col = texture(iChannel0, pos.xz).xyz;\n        vec3 col2 = texture(iChannel1, pos.xz).xyz * vec3(0.6, 0.6, 0.5);\n        col = mix(col2, col, abs(cos(pos.x*1.0)));\n        spow = 100.0;\n        //spow = pow(((col.x + col.y + col.z) / 3.0), 2.0) * 256.0;\n        col = tex3D(iChannel3, pos, nor);\n        //col = vec3(1.0, 1.0, 1.0) * 0.9;\n    }\n    \n    // 200, 245, 240\n}\n\nvec3 getFinalColour(in vec3 pos, in float m, in float m2, in float b, inout vec3 nor, inout float spow)\n{\n    vec3 col;\n    \n    getMaterialData(m, pos, nor, col, spow);\n    vec3 col2;\n    float spow2;\n    vec3 nor2;\n    getMaterialData(m2, pos, nor2, col2, spow2);\n\n    #ifdef VIEW_SECOND_COL\n    col = col2;\n    #endif\n\n    col = mix(col, col2, b);\n    spow = mix(spow, spow2, b);\n    nor = mix(nor, nor2, floor(b));\n\n    #ifdef VIEW_BLEND\n    col = mix(vec3(col), vec3(0.0, 1.0, 0.0), b*2.0);\n    #endif\n    \n    return col;\n}\n\nvec3 getColour(in vec3 ro, in vec3 rd, in float tmin)\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;  \n    vec3 dlig = normalize( vec3(0.6, 0.5, 0.7) );\n    \n    SDFRes ray = castRay(ro, rd, tmin);\n    float t = ray.d;\n    float m = ray.m;\n    float m2 = ray.m2;\n    float b = ray.b;\n    float spow = 128.0;\n\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = getNormal(pos);\n        vec3 ref = reflect( rd, nor );\n\n        col = getFinalColour(pos, m, m2, b, nor, spow);\n        \n        // repeat the point light\n        float ld = 10.0;\n        float lp = round(pos.z / ld) * ld;        \n        // Light in front of you\n        lp = iTime*CAMSPEED + 3.0 + sin(iTime) * 2.0;\n        vec3 lightPos = vec3( 0.0, 0.0, lp );\n        lightPos -= path(lightPos.z + PI*2.0);\n        vec3 lig = normalize(lightPos - pos);\n\n        // point light\n        float ldist = length(lightPos - pos);\n        float kc = 1.0;\n        float kq = 0.9;\n\n        // light attenuation\n        float att = 1.0 / ( kc + pow(kq*ldist, 4.0));\n        float dif = att * dot(nor, lig) * 3.0;\n\n        \n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),spow);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n\n        float shadow = shadows(pos, lig, 0.1);\n        float occ = occlusion(pos, nor);\n\n        dif *= shadow;\n        dom *= shadows(pos, nor, 0.01);        \n\n        vec3 lin = vec3(0.0);\n        lin += dif*occ; // I shouldn't use the occlusion here, but I like the result\n        lin += spe*dif*occ;\n        //lin += fre*0.03*occ;\n        //lin += amb*0.02*occ;\n        //lin += dom*0.1*occ;\n        //lin = vec3(occ);\n        \n        //col = vec3(spe);\n\n        col = col * lin;\n    }\n    \n    //col /= ray.d;\n    \n    return vec3(col);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd )\n{\n    return getColour(ro, rd, 0.1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 15.0 + iTime;\n    \n    // camera\t\n\tvec3 ro = vec3( 0.0, 0.0, iTime*CAMSPEED );\n    ro -= path(ro.z + PI*2.0);\n\tvec3 ta = ro + vec3(0.0, 0.0, 1.0);\n    ta -= path(ro.z)*0.3;\n    \n    \n    mat3 camera = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = camera * normalize( vec3(p.xy, 2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) ); // gamma\n\n    fragColor=vec4( col, 1.0 );\n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt33RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[970, 1018, 1040, 1040, 1084], [1086, 1152, 1202, 1202, 1402], [1404, 1486, 1559, 1559, 2023], [2025, 2196, 2221, 2221, 2254], [2256, 2256, 2292, 2292, 2424], [2447, 2591, 2631, 2631, 2752], [2754, 2768, 2809, 2809, 2880], [2882, 2882, 2913, 2913, 2939], [2941, 2941, 2978, 2978, 3005], [3007, 3007, 3048, 3048, 3102], [3104, 3104, 3148, 3148, 3245], [3247, 3247, 3295, 3337, 4235], [4237, 4237, 4270, 4270, 4335], [4337, 4337, 4380, 4380, 4411], [4413, 4413, 4444, 4444, 4540], [4542, 4542, 4587, 4587, 4627], [4629, 4629, 4662, 4662, 4992], [4994, 4994, 5019, 5019, 5037], [5039, 5039, 5062, 5062, 5170], [5172, 5172, 5198, 5198, 5338], [5340, 5340, 5366, 5366, 6231], [6233, 6233, 6263, 6263, 6487], [6489, 6489, 6544, 6544, 7009], [7012, 7012, 7066, 7084, 7434], [7436, 7436, 7477, 7477, 7773], [7775, 7775, 7873, 7873, 10818], [10820, 10820, 10925, 10925, 11349], [11351, 11351, 11406, 11406, 13233], [13236, 13236, 13274, 13274, 13311], [13313, 13313, 13365, 13365, 13542], [13544, 13544, 13601, 13601, 14213]]}
{"id": "Xd2BRm", "name": "Halftone Lines & Dots Filter", "author": "cacheflowe", "description": "A special effect from a past project", "tags": ["lines", "halftone", "dots"], "likes": 18, "viewed": 1054, "published": "Public API", "date": "1522523552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Copyright 2020 Justin Gitlin\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfloat colorSteps = 8.;\nfloat scale = 0.25;\nfloat timeFactor = 0.03;\nfloat blur = 1.;\n\nfloat rgbToGray(vec4 rgba) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgba.xyz, W);\n}\n\nvec2 rotateCoord(vec2 uv, float rads) {\n    uv *= mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n\treturn uv;\n}\n\nfloat halftoneDots(vec2 uv, float rows, float curRadius, float curRotation, float invert) {\n    // update layout params\n    // get original coordinate, translate & rotate\n    uv = rotateCoord(uv, curRotation);\n    // calc row index to offset x of every other row\n    float rowIndex = floor(uv.y * rows);\t\t\n    float oddEven = mod(rowIndex, 2.);\n    // create grid coords\n    vec2 uvRepeat = fract(uv * rows) - 0.5;\t\t\n    if(oddEven == 1.) {\t\t\t\t\t\t\t// offset x by half\n        uvRepeat = fract(vec2(0.5, 0.) + uv * rows) - vec2(0.5, 0.5);\t\n    }\n    // adaptive antialiasing, draw, invert\n    float aa = iResolution.y * rows * 0.00001; \t\n    float col = smoothstep(curRadius - aa, curRadius + aa, length(uvRepeat));\n    if(invert == 1.) col = 1. - col;\t\t\t\n    return col;\n}\n\nfloat halftoneLines(vec2 uv, float rows, float curThickness, float curRotation, float invert) {\n    // get original coordinate, translate & rotate\n    uv = rotateCoord(uv, curRotation);\n    // create grid coords\n    vec2 uvRepeat = fract(uv * rows);\t\t\n    // adaptive antialiasing, draw, invert\n    float aa = iResolution.y * 0.0003; \t\n    float col = smoothstep(curThickness - aa, curThickness + aa, length(uvRepeat.y - 0.5));\n    if(invert == 1.) col = 1. - col;\t\t\t\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n\tvec2 uvDraw = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 1. - uv.x; // mirror\n\n    // get texture color\n\tvec4 color = texture(iChannel0, uv);\n    \n    if(blur == 1.) {\n    \t// get samples around pixel for averaged color\n    \tfloat stepH = 1.;\n    \tfloat stepV = 1.;\n\t\tvec4 colors[9];\n    \tfloat stepX = stepH/iResolution.x;\n    \tfloat stepY = stepV/iResolution.y;\n    \tcolors[0] = texture(iChannel0, uv + vec2(-stepX, stepY));\n\t\tcolors[1] = texture(iChannel0, uv + vec2(0, stepY));\n\t\tcolors[2] = texture(iChannel0, uv + vec2(stepX, stepY));\n\t\tcolors[3] = texture(iChannel0, uv + vec2(-stepX, 0));\n\t\tcolors[4] = texture(iChannel0, uv);\n\t\tcolors[5] = texture(iChannel0, uv + vec2(stepX, 0));\n\t\tcolors[6] = texture(iChannel0, uv + vec2(-stepX, -stepY));\n\t\tcolors[7] = texture(iChannel0, uv + vec2(0, -stepY));\n\t\tcolors[8] = texture(iChannel0, uv + vec2(stepX, -stepY));\n    \n    \t// apply color steps to original color\n    \tcolor = vec4(0.);\n    \tfor(int i=0; i < 9; i++) {\n    \t    color += colors[i];\n    \t}\n    \tcolor = vec4((color.rgb / 9.), 1.);\n    }\n    \n    // color = vec4(vec3(1. - uv.x), 1.); // test gradient\n    float luma = rgbToGray(color) * 1.;\n    float lumaIndex = floor(luma * colorSteps);\n   \tfloat lumaFloor = lumaIndex / colorSteps;\n    \n    // time\n    float time = iTime * timeFactor;\n    \n    // posterize -> halftone gradient configurations\n    float halftoneCol = 0.;\n    if(lumaIndex == 0.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 50., 0.1, 0.2 + time, 1.);\n    } else if(lumaIndex == 1.) {\n   \t\thalftoneCol = halftoneLines(uvDraw, scale * 84., 0.08, 2. - time, 1.);\n    } else if(lumaIndex == 2.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 120., 0.45, 0.8 + time, 0.);\n\t} else if(lumaIndex == 3.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 60., 0.37, 0.5 - time, 1.);\n  \t} else if(lumaIndex == 4.) {\n\t\thalftoneCol = halftoneLines(uvDraw, scale * 40., 0.18, 2. + time, 0.);\n    } else if(lumaIndex == 5.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 60., 0.34, 0.5 - time, 0.);\n    } else if(lumaIndex == 6.) {\n\t\thalftoneCol = halftoneLines(uvDraw, scale * 84., 0.15, 2. + time, 0.);\n\t} else if(lumaIndex >= 7.) {\n\t\thalftoneCol = halftoneDots(uvDraw, scale * 50., 0.1, 0.2 - time, 0.);\n    } \n    fragColor = vec4(vec3(halftoneCol),1.0);\n}\n\n\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2BRm.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[0, 685, 713, 713, 790], [792, 792, 831, 831, 906], [908, 908, 999, 1078, 1679], [1681, 1681, 1776, 1827, 2166], [2168, 2168, 2225, 2239, 4586]]}
{"id": "Xd3yDB", "name": "mobius kifs", "author": "wyatt", "description": "Raymarching is fun", "tags": ["raymarching", "mobius", "kifs"], "likes": 11, "viewed": 242, "published": "Public", "date": "1519948386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rot (vec3 s) {\n    float \tsa = sin(s.x),\n        ca = cos(s.x),\n        sb = sin(s.y),\n        cb = cos(s.y),\n        sc = sin(s.z),\n        cc = cos(s.z);\n    return mat3 (\n        vec3(cb*cc, -cb*sc, sb),\n        vec3(sa*sb*cc+ca*sc, -sa*sb*sc+ca*cc, -sa*cb),\n        vec3(-ca*sb*cc+sa*sc, ca*sb*sc+sa*cc, ca*cb)\n    );\n}\nmat3 mm;\nvec4 light;\nvec3 grp;\nfloat ui;\nfloat map (vec3 p) {\n    float d = length(p-light.xyz)-light.w;\n    d = min(d,max(30.-p.z,0.));\n    grp=p*0.01;\n    \n    p = mm*p;\n    for (int i = 0; i < 5; i++) {\n        float t = abs(p.y);\n        p.y = p.x;\n        p.x = t;\n        p = mm*(p-.1);\n    }\n    float q = 5.;\n    float a = 1.5*((atan(p.x,p.z)))+0.05*ui;\n    mat2 mn = mat2(sin(a),cos(a),-cos(a),sin(a));\n    vec2 u = mn*vec2(length(p.xz)-2.,p.y);\n    float d1 = d;\n    vec2 w = max(abs(u)-vec2(0.1,0.5),0.);\n    d = min(d,length(w)-0.1-0.01*(sin(50.*(dot(u,u))+sin(20.*atan(p.x,p.z)))));\n    if (d1 != d) grp = vec3(u,atan(p.x,p.z));\n    return d;\n}\nvec3 norm (vec3 p) {\n    vec2 e = vec2 (.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\nvec3 dive (vec3 p, vec3 d) {\n    for (int i = 0; i < 35; i++) {\n        p += d*map(p);\n    }\n    return p;\n}\nvec3 color (vec3 no, vec3 p) {\n    return vec3(.8+0.2*(sin(30.*p*p.zxy+no)*0.5+0.5))*0.9;\n}\nvoid mainImage (out vec4 fragColor, vec2 vv) {\n    vec2 v = (vv/iResolution.xy)*2.-1.;\n    v.x *= iResolution.x/iResolution.y;\n    ui = 30.*iTime;\n    vec3 r = vec3(0,0,-15.);\n    light = vec4(10.*sin(0.005*ui),2,-23,1);\n    vec3 d = normalize(vec3(v,3.));\n    mm = rot((0.005*ui)+vec3(1,2,3));\n    vec3 p = dive(r,d);\n    d = normalize(light.xyz-p);\n    vec3 no = norm(p);\n    vec3 col = color(no,grp);\n    vec3 bounce = dive(p+0.01*d,d);\n    col *= dot(no, normalize(light.xyz-p));\n    if (length(bounce-light.xyz) > light.w+0.1) col *= 0.2;\n    if (length (p-r)>4e2) col *= 0.;\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3yDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 328], [370, 370, 390, 390, 986], [987, 987, 1007, 1007, 1183], [1184, 1184, 1212, 1212, 1292], [1293, 1293, 1323, 1323, 1384], [1385, 1385, 1431, 1431, 1996]]}
{"id": "XdGcRw", "name": "PhasePortraitOnSphere", "author": "soma_arc", "description": "Phase portrait on the sphere and hemisphere views.\nMove the camera by mouse.\nReference:\nVisual Complex Functions: An Introduction with Phase Portraits by Elias Wegert\n", "tags": ["2d", "3d", "complex", "phaseportrait"], "likes": 8, "viewed": 423, "published": "Public API", "date": "1521947454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\nconst float TWO_PI = 2. * PI;\nconst float FOUR_PI = 4. * PI;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst float CIRCLE_RADIUS = 0.02;\nconst float OUTER_CIRCLE_GRAY_SCALE = 0.4;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\n\n// Suggestions by FabriceNeyret2.\n#define gammaCorrect(rgb)  min( pow( rgb, vec3(DISPLAY_GAMMA_COEFF) ), 1.)\n#define degamma(rgb)       min( pow( rgb, vec3(GAMMA_COEFF) ), 1.)\n#define compProd(a,b)      mat2(a,-a.y,a.x) * b\n#define compQuot(a,b)      mat2(a,(a).y,-(a).x)  * (b) / dot(b, b)\n\nvec2 compFunc(vec2 position){\n\treturn position = compQuot(position - vec2(1. + sin(iTime), 0.4 + cos(iTime)), compProd(position, position) + position + vec2(1, 0)); \n\t//return position = compQuot(position - vec2(1., 0.), compProd(position, position) + position + vec2(1, 0));         \n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float GRAY_SCALE = 0.6;\nfloat computeGrayComponent(vec2 position, out float arg) {\n    float absModulus = 2. * log(length(position));\n    float modulusG = mix(1., fract(absModulus), GRAY_SCALE);\n        \n    arg = atan(position.y, position.x) / TWO_PI;\n    float argG = mix(1., fract(arg * 10.), GRAY_SCALE);\n    \n    return modulusG * argG;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(radians(fov) * .5);\n    vec3 v = normalize(target - eye);\n    vec3 focalXAxis = normalize(cross(v, up));\n    vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n    return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nconst float EPSILON = 0.0001;\nvec4 intersectSphere(int objId, int mtl,\n                     vec3 sphereCenter, float radius,\n                     vec3 rayOrigin, vec3 rayDir,\n                     vec4 isect, inout int outObjId){\n    vec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 intersection = (rayOrigin + t * rayDir);\n            outObjId = objId;\n            return vec4(t, normalize(intersection - sphereCenter));\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(int objId, int mtl,\n                    vec3 p, vec3 n,\n                    vec3 rayOrigin, vec3 rayDir, vec4 isect,\n                   \tinout int outObjId){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        outObjId = objId;\n        return vec4(t, n);\n    }\n    return isect;\n}\n\nconst float NO_HIT = 99999999.;\nconst int MTL_DIFFUSE = 0;\nconst int MTL_TRANSPARENT = 1;\n\nconst int OBJ_PLANE = 0;\nconst int OBJ_SPHERE = 1;\n\nvec4 getIntersection(vec3 eye, vec3 ray, out int outObj){\n    outObj = -1;\n    vec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(OBJ_PLANE, MTL_DIFFUSE,\n                           vec3(0, -2, 0), vec3(0, 1, 0),\n                           eye, ray, isect, outObj);\n    isect = intersectSphere(OBJ_SPHERE, MTL_DIFFUSE,\n                            vec3(0), 1.,\n                            eye, ray, isect, outObj);\n    return isect;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n    vec3 v = lightPos - p;\n    float d = dot(n, normalize(v));\n    float r = length(v);\n    return (d > 0. )//&& visible(p + EPSILON * n, lightPos)) \n        ?\n        (lightPower * (d / (FOUR_PI * r * r))) * diffuseColor\n        : BLACK;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.y), p.z / (1. - p.y));\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));\nconst vec3 LIGHT_POS = vec3(3, 5, 0);\nconst vec3 LIGHT_POWER = vec3(300.);\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\n\nvec3 castRay(vec3 eye, vec3 ray) {\n    vec3 l = BLACK;\n    int objId;\n    vec4 isect = getIntersection(eye, ray, objId);\n\tif(isect.x != NO_HIT){\n\t\tvec3 matColor = WHITE;\n        vec3 normal = isect.yzw;\n\t\tvec3 intersection = eye + isect.x * ray;\n\t\tif(objId == OBJ_PLANE){\n\t\t\tmatColor = LIGHT_GRAY;\n\t\t}else if(objId == OBJ_SPHERE){\n            vec2 position = stereoProject(intersection);\n            if (abs(length(position) - 1.) < 0.02) {\n                matColor = BLACK;\n            } else {\n            \tposition = compFunc(position); \n            \n            \tfloat arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n\t\t\t\tmatColor = degamma(hsv2rgb(vec3(arg, 1., g)));\n            }\n\t\t}\n\t\t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse = clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n\t\tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n\t\t\t\t\t\t\t\t\t   LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * AMBIENT_FACTOR;\n\t\tl += (diffuse + ambient);\n\t}  \n    return l;\n}\n\n\n\nconst int SAMPLE_NUM = 20;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    const vec3 up = vec3(0, 1, 0);\n    const float fov = 60.;\n    \n    for(int i = 0 ; i < SAMPLE_NUM ; i++){        \n        if(fragCoord.x < iResolution.x/2.){\n            float my = 3. * (iMouse.y - iResolution.y * 0.5) / iResolution.y + 0.5;\n            float r =  1. + 2. * iMouse.x / iResolution.x;\n            vec3 eye = vec3(r * sin(iTime), r * sin(atan(my, 1.)), r * cos(iTime));\n    \t\tvec3 target = vec3(0, 0, 0);\n        \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t   iResolution.x/2., iResolution.y,\n                         \t   fragCoord.xy + rand2n(fragCoord.xy, float(i)));\n        \tsum += castRay(eye, ray);\n        }else{\n            vec2 size = iResolution.xy / 2.;\n        \tvec2 p = 2. * (vec2(fragCoord.x - size.x, fragCoord.y) - size * 0.5) / size.y\n                     + 2. * rand2n(fragCoord.xy, float(i)) / size.y;\n            if(p.y <= 1.){\n                vec2 position = p * 1.1;\n                if (abs(length(position) - 1.) < CIRCLE_RADIUS) continue;\n                float s = length(position) > 1. ? OUTER_CIRCLE_GRAY_SCALE : 1.;\n\n                position = compFunc(position);\n                \n                float arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n\t\t\t\tsum += hsv2rgb(vec3(arg, 1., g * s));\n            } else {\n                p.y -= 2.;\n\t\t\t\tvec2 position = p * 1.1;\n                if (abs(length(position) - 1.) < CIRCLE_RADIUS) continue;\n                float s = length(position) > 1. ? OUTER_CIRCLE_GRAY_SCALE : 1.;\n\n\t\t\t\tposition = compFunc(compQuot(vec2(1, 0), position)); // 1 / z\n                \n                float arg;\n\t\t\t\tfloat g = computeGrayComponent(position, arg);\n                sum += hsv2rgb(vec3(arg, 1., g * s));\n            }\n        }\n        \n    }\n    \n    if(fragCoord.x < iResolution.x/2.){\n    \tfragColor = vec4(gammaCorrect(sum/float(SAMPLE_NUM)), 1.);\n    } else {\n    \tfragColor = vec4((sum/float(SAMPLE_NUM)), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 561, 602, 602, 891], [977, 1269, 1298, 1298, 1555], [1557, 1557, 1579, 1579, 1754], [1786, 1786, 1844, 1844, 2105], [2107, 2107, 2273, 2273, 2693], [2725, 2725, 2923, 2923, 3399], [3401, 3401, 3578, 3578, 3793], [3938, 3938, 3995, 3995, 4373], [4375, 4375, 4514, 4514, 4755], [4757, 4757, 4784, 4784, 4836], [5007, 5007, 5041, 5041, 6010], [6041, 6041, 6098, 6098, 8118]]}
{"id": "XdGcRz", "name": "first marcher", "author": "expertmouser", "description": "originally written in OSX \"Fragment\", which uses different input/output stuff, hence the funky adapter stuff.\ni think i don't understand something about normals & SDFs.", "tags": ["raymarcher"], "likes": 1, "viewed": 74, "published": "Public", "date": "1520740227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 oColor;\nvec2 vTexcoord;\nfloat iGlobalTime;\nfloat iAspect;\n\n\nconst float kMaxFloat = 1000000000.; // lol\n\nconst float maxDist  = 2.0;\n\nconst float floorAmt    = -0.02;\nconst float floorHeight = 3.;\n\nconst float PI = 3.14159265359;\nconst float degToRad = PI * 2.0 / 360.0;\nconst float radToDeg = 360.0 / PI / 2.0;\n\nvec3 rotZ(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.y * c,\n               v.x * c + v.y * s,\n               v.z);\n}\n\nvec3 rotY(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.z * c,\n               v.y,\n               v.x * c + v.z * s);\n}\n\nvec4 sdfSphere(vec3 p) {\n  float f = iGlobalTime * 0.1;\n  p = rotY(p, f * 2.);\n  vec3 q = p;\n  const float overallDistortionMagnitude = 17.;\n  const float mag2 = .2;\n  const float freq = 20.;\n  float mag = sin(iGlobalTime * 0.1) * overallDistortionMagnitude;\n  q.x += cos(p.z         * mag * 0.9 + f) * 0.1;\n  q.y += sin(p.z         * mag * 0.8 + f) * 0.1;\n  q.z += sin((p.x * p.y) * mag * 1.0 + f * 10.) * 0.1;\n  float dx = sin(p.z * freq) * mag2;\n  float dy = sin(p.x * freq) * mag2;\n  float dz = sin(p.y * freq) * mag2;\n  dx *= dx * dx * dx;\n  dy *= dy * dy * dy;\n  dz *= dz * dz * dz;\n  q.x += dx;\n  q.y += dy;\n  q.z += dz;\n  return vec4(length(q) - 0.75, p.x, p.y, p.z);\n}\n\nvec4 sdfSceneSingle(vec3 p) {\n  vec4 ret = sdfSphere(p);\n  return ret;\n}\n\nvec4 sdfSceneDual(vec3 p) {\n  float sep = 1.25;\n  p.x += sep / 2.;\n  vec4 ret1 = sdfSphere(p);\n  p.x -= sep;\n  vec4 ret2 = sdfSphere(p);\n  vec4 ret;\n  if (ret1.x < ret2.x) {\n    ret = ret1;\n  }\n  else {\n    ret = ret2;\n  }\n  return ret;\n}\n\nvec4 sdfScene(vec3 pt) {\n  return sdfSceneSingle(pt);\n}\n\nvec3 sdfNormal(vec3 p) {\n  const float epsilon = 0.001;\n  vec3 v = vec3(\n    sdfScene(vec3(p.x + epsilon, p.y, p.z)).x - sdfScene(vec3(p.x - epsilon, p.y, p.z)).x,\n    sdfScene(vec3(p.x, p.y + epsilon, p.z)).x - sdfScene(vec3(p.x, p.y - epsilon, p.z)).x,\n    sdfScene(vec3(p.x, p.y, p.z + epsilon)).x - sdfScene(vec3(p.x, p.y, p.z - epsilon)).x\n  );\n\n  return normalize(v);\n}\n\nbool approximatelyEqualEps(float a, float b, float epsilon) {\n  float d = abs(a - b);\n  return d < epsilon ? true : false;\n}\n\nbool approximatelyEqual(float a, float b) {\n  const float epsilon = 0.0001;\n  return approximatelyEqualEps(a, b, epsilon);\n}\n\n// todo: generalize to any plane\nvec3 intersectRayXZPlane(vec3 pt, vec3 dir) {\n  if (approximatelyEqual(dir.y, 0.)) {\n    return vec3(kMaxFloat, 0, kMaxFloat);\n  }\n\n  float s = pt.y / dir.y;\n  return pt + dir * s;\n}\n\nfloat subfloor(vec3 groundPt) {\n  groundPt = rotY(groundPt, 45.0 * degToRad);\n  groundPt += vec3(\n    sin(iGlobalTime * 0.12  ) * 10.,\n    1,\n    sin(iGlobalTime * 0.1211) * 10.\n  );\n  float f = sin(groundPt.x * 1.2) * sin(groundPt.z * 1.2);\n  f *= f * f;\n  return f * 1.9 + 1.5;\n}\n\nfloat floorCheck(vec3 pt, vec3 rayDir) {\n  rayDir = rotY(rayDir, iGlobalTime * 0.031);\n  vec3 floorOffset = vec3(0, floorHeight, iGlobalTime * -4.1);\n  vec3 groundPt = intersectRayXZPlane(pt + floorOffset, rayDir);\n  float f = sin(groundPt.x) + sin(groundPt.z) - sin(iGlobalTime * 0.51) * 0.8;\n  float rf;\n  if (approximatelyEqualEps(f, 0., 0.07)) {\n    rf = 0.18;\n  }\n  else if (f < 0.) {\n    rf = 0.12;\n  }\n  else {\n    rf = subfloor(groundPt) * 0.1;\n  }\n\n  return rf;\n}\n\nvoid otherMain(void)\n{\n  vec3  lightDir = normalize(vec3(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0, -0.2));\n\n  lightDir = normalize(vec3(\n    cos(iGlobalTime * 1.13) * 2.0,\n    sin(iGlobalTime * 1.13) * 2.0,\n    sin(iGlobalTime * 0.5 ) * 1.2));\n\n  vec3  camPos = vec3(0, 0, -4.0);\n  float screenDist = 3.5;\n\n  vec2 tmp = vTexcoord * 2.0 - 1.0;\n  vec3 pxlPos;\n  if (iAspect > 1.0) {\n    pxlPos = vec3(tmp.x * iAspect, tmp.y, camPos.z + screenDist);\n  }\n  else {\n    pxlPos = vec3(tmp.x, tmp.y / iAspect, camPos.z + screenDist);\n  }\n\n  vec3 rayDir = normalize(pxlPos - camPos);\n\n  float maxZ = pxlPos.z + maxDist;\n\n  vec3 pt = pxlPos;\n\n  float finalDist;\n\n  int steps = 0;\n\n  bool hitSomething = false;\n\n  const float skyBrightness = 0.2;\n\n  oColor = vec4(skyBrightness);\n\n\n  while (length(pt) < maxZ) {\n    vec4 sdf = sdfScene(pt);\n    finalDist = sdf.x;\n    if (finalDist <= 0.0001) {\n      hitSomething = true;\n      vec3  n = sdfNormal(pt);\n      float d = dot(n, lightDir);\n      vec3 refl = reflect(rayDir, n);\n      float edgeness = 1. - abs(dot(n, rayDir));\n      float rf = 0.;\n      if (refl.y < floorAmt) {\n        rf = floorCheck(pt, refl) * 0.6;\n      }\n      oColor = vec4(\n        (sin(sdf.w * 60.) * 0.2 + 0.7) * d,\n        (sin(sdf.x * 80.) * 0.2 + 0.7) * d,\n        (sin(sdf.y * 60.) * 0.2 + 0.6) * d,\n        1.0);\n      oColor = vec4(\n        max(oColor.x, rf),\n        max(oColor.y, rf),\n        max(oColor.z, rf),\n        1\n      );\n      float e = edgeness;\n      e = e * e * e * e;\n      e = e * e;\n      oColor -= vec4(e);\n      break;\n    }\n    const float minStep = 0.002;\n    float step = max(finalDist * 0.5, minStep);\n    // pt.z += step;\n    pt += rayDir * step;\n  }\n\n  if (!hitSomething) {\n    if (rayDir.y < floorAmt) {\n      float rf = floorCheck(camPos, rayDir);\n      oColor = vec4(rf, rf, rf, 1);\n\n    }\n  }\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iAspect     = iResolution.x / iResolution.y;\n    iGlobalTime = iTime;\n    vTexcoord = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    otherMain();\n    fragColor = oColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 319, 353, 353, 496], [498, 498, 532, 532, 675], [677, 677, 701, 701, 1354], [1356, 1356, 1385, 1385, 1428], [1430, 1430, 1457, 1457, 1668], [1670, 1670, 1694, 1694, 1725], [1727, 1727, 1751, 1751, 2102], [2104, 2104, 2165, 2165, 2228], [2230, 2230, 2273, 2273, 2354], [2356, 2389, 2434, 2434, 2571], [2573, 2573, 2604, 2604, 2854], [2856, 2856, 2896, 2896, 3328], [3330, 3330, 3352, 3352, 5209], [5212, 5212, 5269, 5269, 5466]]}
{"id": "XdGczw", "name": "Tetrahedron and Parallelepiped", "author": "mla", "description": "A tetrahedron contains an octahedron with parallel opposite edges, and can also be inscribed uniquely in a parallelepiped sharing its vertices.\n\nMouse to move, 'o' and 'p' toggle display of octahedron and parallelepiped.", "tags": ["raytrace", "tetrahedron", "parallelepiped"], "likes": 11, "viewed": 523, "published": "Public API", "date": "1521360341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018\n//\n// A tetrahedron contains an octahedron with parallel opposite\n// edges (between the midpoints of the edges of the tetrahedron),\n// and can also be inscribed uniquely in a parallelepiped\n// sharing its vertices. The octahedron and parallelepiped\n// are dual.\n\n// Mouse to move, 'o' and 'p' toggle display of octahedron\n// and parallelepiped.\n//\n// Raytraced spheres and cylinders, solved analytically\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dointernal = true;\nbool doexternal = true;\n\nconst float PI = 3.14159;\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  int id;\n};\n\nstruct Cylinder {\n  float r2;      // radius squared\n  // points s and t are end points of cylinder\n  vec3 s,t;\n  int id;\n};\n\n// Use vec2 return?\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic0(float A, float B, float C, out float x0, out float x1) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x0 = (-B-D)/A;\n   x1 = C/(A*x0);\n   if (B < 0.0) {\n     // return smallest root first\n     float t = x0; x0 = x1; x1 = t;\n   }\n   return true;\n}\n\nbool quadratic(float A, float B, float C, out float x) {\n  float x1,x2;\n  if (!quadratic0(A,B,C,x1,x2)) return false;\n  if (x1 > 0.0) x = x1;\n  else if (x2 > 0.0) x = x2;\n  else return false;\n  return true;\n}\n\nbool intersectSphere(Sphere s, Ray ray, inout Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float A = 1.0;\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+c2-r2;\n  float t;\n  if (!quadratic(A,B,C,t)) return false;\n  if (t < 0.0 || t >= hit.t) return false;\n  // Normal is the radial vector of sphere\n  // We normalize it later\n  hit = Hit(t, q+t*d-p, s.id);\n  return true;\n}\n\nbool cylinder(vec3 q, vec3 s, float r2, vec3 p, vec3 r, out float t, out vec3 normal) {\n  vec3 n = s-q; // Line direction\n  float k2 = dot(n,n);\n  vec3 p1 = p-q; // Move p to line space\n  float rs = dot(r,n);\n  float ps = dot(p1,n);\n  float pr = dot(p1,r);\n  float pp = dot(p1,p1);\n  float A = 1.0 - rs*rs/k2;\n  float B = pr - ps*rs/k2;\n  float C = pp - ps*ps/k2 - r2;\n  if (!quadratic(A,B,C,t)) {\n    return false;\n  } else {\n    p1 += t*r; // Final point in line space\n    float lambda = dot(p1,n)/k2;\n    if (lambda < 0.0 || lambda > 1.0) return false;\n    normal = p1-lambda*n;\n    return true;\n  }\n}\n\nbool intersectCylinder(Cylinder c, Ray ray, inout Hit hit) {\n  vec3 s0 = c.s;\n  vec3 s1 = c.t;\n  float r2 = c.r2;\n  vec3 q = ray.q, d = ray.d;\n  float t;\n  vec3 normal;\n  if (!cylinder(s0,s1,r2,q,d,t,normal) || t >= hit.t) {\n    return false;\n  } else {\n    // Normal is the radial vector of cylinder\n    hit = Hit(t, normal, c.id);\n    return true;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nbool intersectScene(Ray ray, out Hit hit) {\n  vec4 A4 = vec4(1,0,0,0);\n  vec4 B4 = vec4(0,1.5,0,0);\n  vec4 C4 = vec4(0,0,1.1,0);\n  vec4 D4 = vec4(0,0,0,1.2);\n  // Quaternion, w is real part\n  float t = 0.2*iTime;\n  vec4 Q = vec4(sin(t)*vec3(1,0.618,0),cos(t));\n  A4 = qmul(A4,Q);\n  B4 = qmul(B4,Q);\n  C4 = qmul(C4,Q);\n  D4 = qmul(D4,Q);\n  vec3 A = A4.xyz;\n  vec3 B = B4.xyz;\n  vec3 C = C4.xyz;\n  vec3 D = D4.xyz;\n  {\n    // Put centroid at origin\n    vec3 X = 0.25*(A+B+C+D);\n    A -= X; B -= X; C -= X; D -= X; X -= X;\n  }\n  hit = Hit(1e8,vec3(0),0);\n  float s2 = 0.04*0.04;\n  float c2 = 0.015*0.015;\n  // Draw centroid at origin\n  if (dointernal) intersectSphere(Sphere(s2,vec3(0),1),ray,hit);\n  vec3 points[4];\n    points[0] = A;\n    points[1] = B;\n    points[2] = C;\n    points[3] = D;\n  for (int i = 0; i < 4; i++) {\n    vec3 X = points[i];\n    intersectSphere(Sphere(s2,X,0),ray,hit);\n#if __VERSION__ < 300\n      // My phone miscompiles this version\n    for (int j = 0; j < 4; j++) {\n      if (j <= i) continue; // WebGL 1.0\n#else\n    for (int j = i+1; j < 4; j++) {\n#endif\n      vec3 Y = points[j];\n      intersectCylinder(Cylinder(c2,X,Y,1),ray,hit);\n      if (dointernal) {\n        vec3 XY = 0.5*(X+Y);\n        intersectSphere(Sphere(s2,XY,2),ray,hit);\n        for (int k = 0; k < 4; k++) {\n          if (k == i || k == j) continue;\n          // The lines on the faces between edge midpoints\n          // These assemble into an octahedron\n          vec3 Z = points[k];\n          vec3 XZ = 0.5*(X+Z);\n          vec3 YZ = 0.5*(Y+Z);\n          intersectCylinder(Cylinder(c2,XY,XZ,4),ray,hit);\n          intersectCylinder(Cylinder(c2,XY,YZ,4),ray,hit);\n        }\n      }\n    }\n  }\n  // The diagonals\n  if (dointernal) {\n    intersectCylinder(Cylinder(c2,0.5*(A+B),0.5*(C+D),3),ray,hit);\n    intersectCylinder(Cylinder(c2,0.5*(A+C),0.5*(B+D),3),ray,hit);\n    intersectCylinder(Cylinder(c2,0.5*(A+D),0.5*(B+C),3),ray,hit);\n  }\n\n  if (doexternal) {\n    // The containing parallelepiped. Just invert the points in\n    // the origin (which is the centroid).\n    for (int i = 0; i < 4; i++) {\n      vec3 X = -points[i];\n      intersectSphere(Sphere(s2,X,1),ray,hit);\n      for (int j = 0; j < 4; j++) {\n        if (i == j) continue;\n        vec3 Y = points[j];\n        intersectCylinder(Cylinder(c2,X,Y,3),ray,hit);\n      }\n    }\n  }\n  return hit.t < 1e8;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(0,1,0);\n  if (i == 3) return vec3(0,0,1);\n  if (i == 4) return vec3(0,1,1);\n  return vec3(1,1,1);\n}\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = 0.7*getColor(hit.id);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),2.0);\n    color += 0.5*specular*vec3(1.0,1.0,1.0);\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord,\n             vec3 fragRayOrigin, vec3 fragRayDir) {\n  float t = 0.5*iTime;\n  light = normalize(vec3(0.5,1.0,-1.0));\n  ambient = 0.5;\n  diffuse = 1.0-ambient;\n  fragColor = solve(Ray(fragRayOrigin,fragRayDir));\n}\n\n\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\n\nbool keypress(int key) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dointernal = !keypress(CHAR_O);\n  doexternal = !keypress(CHAR_P);\n  vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n  vec3 p = vec3(0,0,-4.0);\n  // \"screen\" coordinate\n  vec3 s = 0.8*vec3(iResolution.x/iResolution.y * uv.x, uv.y, 0);\n  vec3 d = s-p; // Direction from camera to screen point\n  p = transform(p);\n  d = transform(d);// normalize after rotation!\n  d = normalize(d);\n  mainVR(fragColor,fragCoord,p,d);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1139, 1187, 1259, 1259, 1501], [1503, 1503, 1559, 1559, 1711], [1713, 1713, 1769, 1769, 2178], [2180, 2180, 2267, 2267, 2784], [2786, 2786, 2846, 2846, 3141], [3143, 3143, 3173, 3173, 3225], [3227, 3227, 3254, 3254, 3561], [3563, 3597, 3624, 3624, 3711]]}
{"id": "XdGyzG", "name": "scrollarrows", "author": "johh", "description": "procedural downwards arrows", "tags": ["arrows"], "likes": 2, "viewed": 67, "published": "Public", "date": "1522343456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define NUM_STRIPES 32.0\n#define STRIPE_WIDTH .1\n#define ANGLE_STRIPES PI * .25\n#define CLAMP_TOP .315\n#define CLAMP_BOTTOM .155\n#define SMOOTH_WIDTH .04\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat easeInExpo(float t) {\n\treturn t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUv = fragCoord/iResolution.xy;\n    vec2 rotatedUv = vUv;\n  \t\n    // rotate context\n    rotatedUv -= vec2(0.5);\n    if ( rotatedUv.x < 0.0 ) {\n    \trotatedUv *= rotate2d( ANGLE_STRIPES );\n    } else {\n        rotatedUv *= rotate2d( -ANGLE_STRIPES );\n    }\n    rotatedUv += vec2(0.5);\n    \n    vec2 stripeUv = rotatedUv;\n\n    \n    if ( stripeUv.y < CLAMP_BOTTOM || stripeUv.y > 1.0 - CLAMP_TOP ) discard;\n    stripeUv.y = 1.0 - fract( stripeUv.y * NUM_STRIPES );\n    // vUv.y = fract( vUv.y + iTime );\n    \n    float stripes = smoothstep( ( 1. - STRIPE_WIDTH ) - SMOOTH_WIDTH, ( 1. - STRIPE_WIDTH ) + SMOOTH_WIDTH, stripeUv.y);\n    stripes -= 1.0 - smoothstep( 1.0, 1.0 - SMOOTH_WIDTH * 2.0, stripeUv.y);\n    \n    float gradient = 1.0 - fract( floor( ( rotatedUv.y ) * NUM_STRIPES ) / NUM_STRIPES + iTime );\n\n    float col = stripes * gradient;\n\n\n    // Output to screen\n    fragColor = vec4( col );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGyzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 209, 209, 295], [297, 297, 324, 324, 377], [380, 380, 437, 487, 1397]]}
{"id": "XdKyRR", "name": "analytic quartic solver", "author": "mattz", "description": "Nearby & multiple roots are a torture test when working with limited precision! Red dots are known roots; blue circles are successfully detected roots returned by the root finder. Watch them go nuts when the quartic just barely kisses the x-axis.", "tags": ["test", "solver", "quartic", "polynomial"], "likes": 25, "viewed": 853, "published": "Public API", "date": "1520892012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \"analytic quartic solver\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   I hunted around a little bit on Shadertoy but couldn't find any\n   examples of a standalone, single-function quartic solver \n   capable of returning all real roots of a 4th-degree polynomial.\n\n   The result is the solve_quartic function below, feel free to \n   use it in your own projects under the license linked above.\n\n   With respect to testing, I wanted to make sure to test\n   all eight cases of root distribution (see generate_roots below).\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\nfloat poly4(vec4 p, float x) {\n    return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// follows notes in http://web.cs.iastate.edu/~cs577/handouts/polyroots.pdf\n// with some special-case code (because triple & quadruple roots are \n// really numerically unstable)\n//\n// the four quartic polynomial coefficients supplied are assumed to follow\n// a leading 1 coefficient.\n//\n// returned boolean should have 0, 2, or 4 true's corresponding to # of real\n// quartic roots.\n\nbvec4 solve_quartic(in vec4 coeffs,\n                    out vec4 roots) {\n        \n    const float TOL = 1e-4;\n\n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n\n    ////////////////////////////////////////////////////////////\n    // check for quadruple root\n    \n    float x = -p/4.;\n    \n    if (abs(poly4(coeffs, x)) < TOL &&\n        abs(q - 6.*x*x) < TOL) {\n        roots = vec4(x);\n        return bvec4(true);\n    }\n\n    ////////////////////////////////////////////////////////////\n    // check for triple root\n    \n    float d = 9.*p*p - 24.*q;\n    \n    if (d >= 0.) {\n\n        float x1 = -p/4. - sqrt(d)/12.;\n        float x2 = -p/4. + sqrt(d)/12.;\n        \n        float px1 = abs(poly4(coeffs, x1));\n        float px2 = abs(poly4(coeffs, x2));\n        \n        x = px1 < px2 ? x1 : x2;\n\n        float y = -p - 3.*x;\n        \n        roots = vec4(max(x,y),x,x,min(x,y));\n        \n        if (min(px1, px2) < TOL &&\n            abs(poly4(coeffs, y)) < TOL &&\n            abs(r + x*x*x + 3.*x*x*y) < TOL) {\n            \n            return bvec4(true);\n\n        }\n\n    }\n    \n    ////////////////////////////////////////////////////////////\n\t// form resolvent cubic and solve it to obtain one real root\n        \n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    \n    // coefficients of normal form\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    \n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    \n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= -TOL) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= -TOL);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= -TOL);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= -TOL);\n    bool E_ok = R_ok && (foo - bar >= -TOL);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n    return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat noise(vec2 xc) {\n    \n    float x0 = floor(xc.x);\n    float t = fract(xc.x);\n    \n    float a = hash12(vec2(x0-1., xc.y));\n    float b = hash12(vec2(x0, xc.y));\n    float c = hash12(vec2(x0+1., xc.y));\n    float d = hash12(vec2(x0+2., xc.y));\n    \n    float t2 = t*t;\n    float t3 = t2*t;\n    \n    float h00 = (2.*t3 - 3.*t2 + 1.);\n    float h01 = (t3 - 2.*t2 + t);\n    float h10 = (-2.*t3 + 3.*t2);\n    float h11 = (t3 - t2);\n    \n    return (h00*b + h01*(c-a) + h10*c + h11*(d-b))*2. - 1.;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// generate coefficients for 4th degree quartic from roots\n// note that c is the complex part of roots 0 & 1 and 2 & 3\n// if c[0] != 0, then we expect r[0] == r[1] and similarly\n// if c[1] != 0\n\nvec4 poly_from_roots(vec4 r, vec2 c) {\n    \n    float s01 = r[0] + r[1];\n    float p01 = r[0] * r[1] + c[0] * c[0];\n    float s23 = r[2] + r[3];\n    float p23 = r[2] * r[3] + c[1] * c[1];\n    \n    return vec4(-s01 - s23,\n                p01 + s01*s23 + p23,\n                -p01*s23 - s01*p23,\n                p01*p23);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// for a quartic with real coefficients, there are eight different\n// cases for roots, which we cycle through over time:\n//               \n//   case timestep #real multiplicity\n//     A  0-0.99       4   4 single           \n//     B  1-1.99       4   1 double, 2 single \n//     C  2-2.99       4   2 double\n//     D  3-3.99       4   1 triple, 1 single \n//     E  4-4.99       4   1 quad\n//     F  5-5.99       2   2 single\n//     G  6-6.99       2   1 double\n//     H  7-7.99       0   no real roots\n//\n//        8-8.99   repeat case C to move smoothly back to A\n//\n\nvoid generate_roots(out vec4 r, out vec2 c) {\n    \n    float t = 0.1*iTime;\n    float d = 2.2;\n\n    r = vec4(noise(vec2(t, 10.)),\n                  noise(vec2(t, 1.)),\n                  noise(vec2(t, 12.)),\n                  noise(vec2(t, 3.)))*d;\n    \n    vec3 cc = vec3(noise(vec2(t, 14.))+0.2*d,\n                   noise(vec2(t, 5.))+0.2*d,\n                   0);\n    \n    t = 0.05*iTime;\n    \n    float rep = floor(t/9.);\n    \n    float phase = mod(t, 9.);\n    float u = smoothstep(0.8, 1.0, fract(phase));\n    \n    c = vec2(0);\n            \n    if (phase < 1.) { \n        r = mix(r, r.xxzw, u); // A -> B\n    } else if (phase < 2.) {\n        r = mix(r.xxzw, r.xxzz, u); // B -> C\n    } else if (phase < 3.) {\n        r = mix(r.xxzz, r.xxxz, u); // C -> D\n    } else if (phase < 4.) {\n        r = mix(r.xxxz, r.xxxx, u); // D -> E\n    } else if (phase < 5.) {\n        r = mix(r.xxxx, r.xxzw, u); // E -> F\n        c = mix(cc.zz, cc.xz, u);\n    } else if (phase < 6.) {\n        r = mix(r.xxzw, r.xxzz, u); // F -> G\n        c = cc.xz;\n    } else if (phase < 7.) {\n        r = r.xxzz; // G -> H\n        c = mix(cc.xz, cc.xy, u);\n    } else if (phase < 8.) {\n        r = r.xxzz; // H -> C\n        c = mix(cc.xy, cc.zz, u);\n    } else {\n        r = mix(r.xxzz, r, u); // C -> A\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n    vec2 p0 = vec2(p.x, fdf.x);\n    vec2 n = normalize(vec2(-fdf.y, 1));\n    return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float scl = 6. / iResolution.x;\n    \n    vec2 p = (fragCoord - 0.5 - vec2(0.5, 0.28)*iResolution.xy)*scl;\n    \n    vec4 r; vec2 c;\n    generate_roots(r, c);\n    \n    vec4 poly = poly_from_roots(r, c);\n    \n    vec4 solved_roots; \n    bvec4 is_root = solve_quartic(poly, solved_roots);\n    \n    vec4 pder = vec4(4,3,2,1) * vec4(1, poly.xyz);\n    \n    const float Y_ZOOM = 0.5;\n\n    vec2 fdf = Y_ZOOM*vec2(poly4(poly, p.x), \n                           poly3(pder, p.x));\n\n    vec3 color = vec3(1, 0.97, .87);\n\n    // grid lines\n    vec2 gp0 = .5*floor(2.*p + 0.5);\n    vec2 gp = fract(abs(p - gp0));\n    color = mix(color, vec3(0.6, 0.75, 0.6), smoothstep(scl, 0., min(gp.x, gp.y)));\n    \n    // axis line\n    vec2 ap = abs(p);\n    color = mix(color, vec3(0.37, 0.55, 0.37)*.9, 0.8*smoothstep(scl, 0., min(ap.x, ap.y)-.75*scl));      \n    \n    // plot line\n    float dline = dist_to_plot(p, fdf);\n    color = mix(color, vec3(.5, .03, .03), smoothstep(scl, 0., dline-.5*scl));\n    \n    // known roots\n    for (int i=0; i<4; ++i){\n        int j = i/2;\n        if (c[j] == 0.) {\n            float dc = length(p - vec2(r[i], 0));\n            color = mix(color, vec3(.25, .02, .02), smoothstep(scl, 0., dc-3.*scl));\n        }\n    }\n    \n    // solved roots\n    for (int i=0; i<4; ++i){\n        if (is_root[i]) {\n            float dc = length(p - vec2(solved_roots[i], 0));\n            color = mix(color, vec3(0, 0, 0.4), smoothstep(scl, 0., abs(dc-8.*scl)-.25*scl));\n        }\n    }\n    \n    // stole iq's vingette code\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n    color *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1);\n    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKyRR.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[611, 746, 776, 776, 832], [834, 1288, 1361, 1361, 4095], [4097, 4224, 4254, 4254, 4304], [4306, 4487, 4509, 4509, 4631], [4633, 4705, 4727, 4727, 5209], [5211, 5477, 5515, 5515, 5803], [5805, 6444, 6489, 6489, 7734], [7736, 7939, 7977, 7977, 8094], [8096, 8168, 8225, 8225, 10001]]}
{"id": "XdKyzD", "name": "StereoRayMarch 3D ", "author": "Ouid", "description": "Stereographic projection of anything ?", "tags": ["raymarch", "stereographic"], "likes": 7, "viewed": 182, "published": "Public", "date": "1521239939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Mathieu Simon aka Ouid (2018)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ref : https://www.shadertoy.com/view/4sfGzS (noise)\n// ref : http://iquilezles.org/www/articles/palettes/palettes.htm (color)\n\n//#define DEBUG\n\nconst float PI = 3.14159265359;\n\nconst float GOLDEN_RATIO = 1.6180339887498;\n\nconst float DEG_TO_RAD = 0.0174533;\n\nconst float MAX = 10000.0;\n\n#define FOV 25.0\n\n#define WITH_SHADOW 1\n#define WITH_STEREO_NORMAL 0\n\n#define PLANE(_Vec3Point,_Vec3Normal) pointAndNormToPlane ( ( vec4(_Vec3Point,1.0) ).xyz, ( vec4(normalize(_Vec3Normal),0.0) ).xyz )\n#define CENTRIC_PLANE(_dist,_Vec3Normal) pointAndNormToPlane ( ( vec4(_dist*_Vec3Normal,1.0) ).xyz, ( vec4(normalize(_Vec3Normal),0.0) ).xyz )\n\n\n//All planes (I'm using /* */ tricks to make new-line)\n//Object(10+x) are used to detect plane and select color\n\n#define COLOR_COUNT 12\n\n#if 0\n// tetrahedron\n\n#define CENTER(_x,_y,_z) (((_x)+(_y)+(_z))/3.0)\n#define P1 vec3(1.0,1.0,1.0)\n#define P2 vec3(1.0,-1.0,-1.0)\n#define P3 vec3(-1.0,1.0,-1.0)\n#define P4 vec3(-1.0,-1.0,1.0)\n\n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P2,P3)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P3,P4)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P1,P2,P4)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(1.0,CENTER(P2,P3,P4)), Object(13))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 4\n    \n#elif 0\n//cube\n\n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(1.0,0.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(-1.0,0.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,0.0,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(1.0,vec3(0.0,0.0,-1.0)), Object(15))\n\n#undef COLOR_COUNT\n#define COLOR_COUNT 6\n\n#elif 1 \n//dodecahedron\n    \nconst float GOLDEN_DIST = (GOLDEN_RATIO*GOLDEN_RATIO) / (GOLDEN_RATIO*GOLDEN_RATIO+2.0);\n    \n#define FOREACH_PLANES(_Call) /*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(GOLDEN_RATIO,1.0,0.0)), Object(10))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-GOLDEN_RATIO,1.0,0.0)), Object(11))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(GOLDEN_RATIO,-1.0,0.0)), Object(12))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-GOLDEN_RATIO,-1.0,0.0)), Object(13))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,1.0)), Object(14))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,1.0)), Object(15))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,GOLDEN_RATIO,-1.0)), Object(16))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(0.0,-GOLDEN_RATIO,-1.0)), Object(17))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(1.0,0.0,GOLDEN_RATIO)), Object(18))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(1.0,0.0,-GOLDEN_RATIO)), Object(19))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-1.0,0.0,GOLDEN_RATIO)), Object(20))/*\n*/\t_Call(CENTRIC_PLANE(GOLDEN_DIST,vec3(-1.0,0.0,-GOLDEN_RATIO)), Object(21))\n    \n#undef COLOR_COUNT\n#define COLOR_COUNT 12\n    \n#endif\n    \n#define SPHERE_SIZE 1.0\n#define SPHERE_OBJECT_RATIO 1.0\n\n// structures (I love structures, sorry, C/C++ habits)\n\nstruct Ray\n{\n    vec3 p;\t\t\t// start of the ray\n    vec3 d;    \t\t// direction of the ray, intersect functions need \"normalized\" dir\n};\n\nstruct Camera\n{ \n    mat4\tmatrix;\t// this matrix can be \"Left\" or \"Right\" handed...just used to compute viewRay\n};\n    \nstruct Object\n{\n    int\t\tid;\t\t// just an id, to find material after all raycasts\n};\n    \nstruct RayResult\n{\n    float\tt;\t\t// distance from origin of the ray that cause the result\n    Object\to;\t// object intersected\n};\n    \nstruct Lighting\n{\n    vec3\tambient; \t// xyz = color\n    vec2\tshading;\n};\n    \nstruct Light\n{\n    vec3\tp;\t\t// pition of the light    \n    vec4\tspec;\t\t// xyz = color, w = intensity\n};\n    \nstruct World\n{\n    float \tobject_scale;\n    mat4\tobject_trf;   \t// matrix of the object\n    mat4\tobject_trf_inv;\n};\n    \nWorld world;\n\n// util funcs\n\nfloat maxPerElem ( in vec2 _v )\n{\n    return max(_v.x,_v.y);\n}\n\nfloat maxPerElem ( in vec3 _v )\n{\n    return max(_v.z,maxPerElem(_v.xy));\n}\n\nfloat maxPerElem ( in vec4 _v )\n{\n    return max(_v.w,maxPerElem(_v.xyz));\n}\n\nmat4 rotationX ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,cos(_angle),sin(_angle),0.0);\n    mat[2] = vec4(0.0,-sin(_angle),cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);    \n    return mat;\n}\nmat4 rotationY ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),0.0,-sin(_angle),0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(sin(_angle),0.0,cos(_angle),0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\nmat4 rotationZ ( float _angle )\n{\n    mat4 mat;\n    mat[0] = vec4(cos(_angle),sin(_angle),0.0,0.0);\n    mat[1] = vec4(-sin(_angle),cos(_angle),0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 scale (vec3 _scale)\n{\n    mat4 mat;\n    mat[0] = vec4(_scale.x,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,_scale.y,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,_scale.z,0.0);\n    mat[3] = vec4(0.0,0.0,0.0,1.0);\n    return mat;\n}\n\nmat4 translate (vec3 _translation)\n{\n    mat4 mat;\n    mat[0] = vec4(1.0,0.0,0.0,0.0);\n    mat[1] = vec4(0.0,1.0,0.0,0.0);\n    mat[2] = vec4(0.0,0.0,1.0,0.0);\n    mat[3] = vec4(_translation,1.0);\n    return mat;\n}\n\nvec4 pointAndNormToPlane ( in vec3 _p, in vec3 _n )\n{\n    return vec4 ( _n, -dot(_p,_n) );\n}\n\nRayResult sdSphere(vec3 p, float r, Object o)\n{\n    return RayResult ( length(p) - r, o);\n}\n\nRayResult sdPlane(vec3 p, vec4 n, Object o)\n{\n    return RayResult ( dot(p,n.xyz) + n.w, o);\n}\n\n\nRayResult sdBox( vec3 p, vec3 b, Object o )\n{\n    vec3 d = abs(p) - b;\n    return RayResult(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o);\n}\n\nRayResult inv ( RayResult r )\n{\n    return RayResult(-r.t, r.o);\n}\n\nRayResult mul(RayResult r, float s)\n{\n    return RayResult(r.t * s, r.o);\n}\n\nRayResult add(RayResult r, float v)\n{\n    return RayResult(r.t + v, r.o);\n}\n\nRayResult opU( RayResult r1, RayResult r2 )\n{\n    if ( r1.t < r2.t )\n        return RayResult(r1.t, r1.o);    \n    else\n        return RayResult(r2.t, r2.o);\n}\n\n\nRayResult opI( RayResult r1, RayResult r2 )\n{\n    if ( r1.t > r2.t )\n        return RayResult(r1.t, r1.o);    \n    else\n        return RayResult(r2.t, r2.o);\n}\n\n\nRayResult opS( RayResult r1, RayResult r2 )\n{\n    return opI(r1, inv(r2));\n}\n\n\nRayResult opRepBox( vec3 p, vec3 bs, vec3 c, in Object o )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox( q, bs, o );\n}\n\n/*RayResult main_object(vec3 p, float scale)\n{\n    vec3 p2 = p / scale;\n    RayResult r = RayResult(-1.0, Object(-1));\n    \n\t#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) r=opI(r, sdPlane ( p2, _Plane, _PlaneId ));\n\tFOREACH_PLANES(INTERSECT_PLANE_RANGE) \n        \n    r = opS ( r, sdSphere(p2,1.15, Object(2)) );\n        \n    return mul(r, scale);\n}*/\n\nRayResult main_object(vec3 p, float scale)\n{\n    vec3 p2 = p / scale;\n        \n    //RayResult r =  sdSphere(p2, 1.0, Object(10));\n    RayResult r =  sdBox(p2, vec3(0.7), Object(10));\n    \n    float box_size = 1.0 / 3.0; //0.05;\n    \n    RayResult box = opRepBox(p2, vec3(box_size*0.15), vec3(box_size), Object(10));\n    \n    r = opI ( r, box);\n    \n    //r = opS ( r,  sdSphere(p2, 1.0-box_size*0.25*sqrt(2.0), Object(10)));\n    //r = opS ( r,  sdSphere(p2, 0.9, Object(10)));\n    r = opS ( r,  sdBox(p2, vec3(0.5), Object(10)));    \n        \n    return mul(r, scale);\n}\n\n\n\nRayResult map(vec3 p, in Object _except)\n{\n    vec3 p2 = (world.object_trf_inv * vec4(p,1.0f)).xyz;\n    \n    RayResult r = main_object(p2, world.object_scale);\n\n\tif ( _except.id != 2 )\n    \tr = opU ( r, sdPlane(p, vec4(0.0,1.0,0.0,0.0), Object(2)));\n\t\n\treturn r;\n}\n\nRayResult map(vec3 p)\n{\n    return map(p, Object(-1));\n}\n\n// normal : copy from https://www.shadertoy.com/view/Xds3zN\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.00001;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n}\n\nRayResult intersect(in Ray ray, in Object _except, float _precis, float _max)\n{\n    RayResult r;\n    float t=0.0;\n    float tmax = _max;\n    for ( int i=0; i<128; ++i )\n    {\n        float precis = _precis;\n        \n        RayResult curr = map(ray.p + t * ray.d, _except);\n        \n        if( curr.t<precis || t>tmax ) break;\n                \n        t += curr.t;\n        r = curr;\n    }\n    \n    if (t>tmax)\n        return RayResult(-1.0,Object(-1));\n    \n    return RayResult(t, r.o);\n}\n\n// Stereographic projection\n\nRay stereographicRay ( in World _world, in vec3 _p )\n{\n    // x;y;z;0 on hyperplane w=0\n    // on sphere of radius 1 => (2x/(R+1);2y/(R+1);2x/(R+1);R-1/R+1) where R = xÂ²+yÂ²+zÂ²\n    \n    float R = dot(_p.xz,_p.xz);\n    \n    vec3 onSphere = vec3(2.0*_p.x,R-1.0,2.0*_p.z) / vec3(R+1.0);\n    \n    // STC : SphereToCube\n    Ray raySTC;\n    raySTC.p = _world.object_trf[3].xyz;\n    raySTC.d =  normalize( onSphere - _world.object_trf[3].xyz );\n    \n    return raySTC;\n}\n\n\n// standard [image -> screen -> view -> world] funcs\n\nvec2 imageToScreen ( in vec2 _uv )\n{\n    vec2 ratioUV = _uv.xy / iResolution.xy;\n    vec2 ratio = 2.0*iResolution.xy/vec2(min(iResolution.x,iResolution.y));\n    vec2 xy = (ratioUV*2.0-1.0)*ratio;\n    return xy;\n}\n\nvoid screenToWorld ( in Camera _camera, in vec2 _screenp, float _z, out vec3 _p )\n{\n    _p = (_camera.matrix * vec4(_screenp,_z,1.0)).xyz;    \n}\n\nvoid screenToRay ( in Camera _camera, in vec2 _screenp, out Ray _ray )\n{\n    vec3 rayPoint;\n    \n    //fov is hardcoded here (distance of Z plane)\n    screenToWorld ( _camera, _screenp, 1.0 / tan ( DEG_TO_RAD * FOV / 2.0), rayPoint );        \n    \n    _ray.p = _camera.matrix[3].xyz;\n    _ray.d = normalize(rayPoint-_ray.p);\n}\n\nCamera cameraLookAt ( in vec3 _eye, in vec3 _lookAtp, in vec3 _up )\n{\n    Camera _camera;\n    \n    vec3 front = normalize(_lookAtp-_eye);    \n    vec3 left = normalize(cross(front, _up));\n    vec3 up = normalize(cross(left,front));\n    _camera.matrix[0] = vec4(left,0.0);\n    _camera.matrix[1] = vec4(up,0.0);\n    _camera.matrix[2] = vec4(front,0.0);\n    _camera.matrix[3] = vec4(_eye,1.0);\n    \n    return _camera;\n}\n\n// color funcs\n\nvec3 computeMaterial ( in World _world, in Ray _ray, in RayResult _rayResult )\n{\n    vec3 _material;\n    \n    if ( _rayResult.o.id == 1 )\n    {\n        _material = vec3(1.0);\n    }\n    else if ( _rayResult.o.id == 2 )\n    {\n        _material = vec3(0.5);\n    }\n    else if ( _rayResult.o.id >= 10  )\n    {\n        float ratio = mod(float(_rayResult.o.id-9)+5.0,float(COLOR_COUNT)) / float(COLOR_COUNT);\n        vec3 a = vec3(0.28,0.5,0.5)*1.3;\n        vec3 b = vec3(0.5,0.2,0.5);\n        vec3 c = vec3(1.0,1.0,0.0);        \n        vec3 d = vec3(0.5,0.3, 0.25);\n        \n        //http://iquilezles.org/www/articles/palettes/palettes.htm\n        _material = a+b*cos(2.0*3.141592*(c*ratio+d));\n        \n        vec3 pos = _ray.p + _rayResult.t * _ray.d;\n        _material = (world.object_trf_inv * vec4(normal(pos), 0.0)).xyz * 0.5 + vec3(0.5);\n\n    }\n    else   \n    {\n        _material = vec3(0.0);\n    }\n    \n    return _material;\n}\n\n// softShadow : copy from https://www.shadertoy.com/view/Xds3zN\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).t;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.001, 0.05 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// AO : copy from https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup world, cam & light\n\n    mat4 rot = rotationZ ( iTime*1.278914) * rotationY(iTime) * rotationX(iTime*0.332567);\n    mat4 inverseRot = rotationX(-iTime*0.332567) * rotationY(-iTime) * rotationZ ( -iTime*1.278914) ;\n    \n    world.object_scale = 0.5;\n    world.object_trf = translate (vec3(0.0,0.5,0.0)) * rot;\n    world.object_trf_inv = inverse(world.object_trf);\n    \n    vec2 eye = vec2(0.0);\n    \n#ifndef DEBUG\n    eye = iMouse.xy/iResolution.xy;\n#endif\n    \n    Camera cam = cameraLookAt ( vec3(2.5-5.0*(eye.x),2.0+5.0*(eye.y),2.5), vec3(0.0,0.5,0.0), vec3(0.0,1.0,0.0) );\n    \n    // compute raytrace\n    vec2 xy = imageToScreen ( fragCoord );    \n        \n    Ray ray;\n    \n    screenToRay ( cam, xy, ray );\n    \n    RayResult res = intersect ( ray, Object(-1), 0.0001, 100.0 );\n    \n    vec3 pos = ray.p + ray.d * res.t;\n\tvec3 nor = normal( pos );\n\tvec3 ref = reflect( ray.d, nor );\n     \n    vec3 col = computeMaterial ( world, ray, res );   \n    \n    // if plane => stereographicProj to obtain color\n    if ( res.o.id == 2 )\n    {\n        Ray stRay = stereographicRay ( world, pos );\n        RayResult stInter = intersect(stRay, Object(2), 0.0001, 1.0);\n            \n        vec3 stereoCol = computeMaterial ( world, stRay, stInter );\n        \n        col = stereoCol * stInter.t;\n    }\n        \n    // lighting : copy from https://www.shadertoy.com/view/Xds3zN\n    float occ = 1.0f; //calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n    vec3  hal = normalize( lig-ray.d );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,ray.d),0.0,1.0), 2.0 );\n\n    dif *= calcSoftshadow( pos, lig, 0.02, 10.0 );\n    dom *= calcSoftshadow( pos, ref, 0.02, 10.0 );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,ray.d),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30*dif*vec3(1.00,0.80,0.65);\n    lin += 0.40*amb*vec3(0.60,0.80,1.00)*occ;\n    lin += 0.50*dom*vec3(0.60,0.80,1.00)*occ;\n    lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n    lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 10.00*spe*vec3(1.00,0.90,0.70);\n\n    col = col; //mix( col, vec3(0.,0.0,.0), 1.0-exp( -0.0002*res.t*res.t*res.t ) );\n\n    fragColor = vec4(col, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKyzD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[3956, 3971, 4004, 4004, 4033], [4035, 4035, 4068, 4068, 4110], [4112, 4112, 4145, 4145, 4188], [4190, 4190, 4223, 4223, 4436], [4437, 4437, 4470, 4470, 4679], [4680, 4680, 4713, 4713, 4922], [4924, 4924, 4950, 4950, 5141], [5143, 5143, 5179, 5179, 5356], [5358, 5358, 5411, 5411, 5450], [5452, 5452, 5499, 5499, 5543], [5545, 5545, 5590, 5590, 5639], [5642, 5642, 5687, 5687, 5792], [5794, 5794, 5825, 5825, 5860], [5862, 5862, 5899, 5899, 5937], [5939, 5939, 5976, 5976, 6014], [6016, 6016, 6061, 6061, 6175], [6178, 6178, 6223, 6223, 6337], [6340, 6340, 6385, 6385, 6416], [6419, 6419, 6479, 6479, 6540], [6542, 6896, 6940, 6940, 7467], [7471, 7471, 7513, 7513, 7735], [7737, 7737, 7760, 7760, 7793], [7795, 7855, 7883, 7883, 8085], [8087, 8087, 8166, 8166, 8577], [8579, 8608, 8662, 8786, 9073], [9076, 9130, 9166, 9166, 9342], [9344, 9344, 9427, 9427, 9488], [9490, 9490, 9562, 9562, 9816], [9818, 9818, 9887, 9887, 10235], [10237, 10253, 10333, 10333, 11187], [11189, 11253, 11331, 11331, 11593], [11595, 11651, 11693, 11693, 11992], [11994, 11994, 12051, 12080, 14572]]}
{"id": "XdKyzR", "name": "Rainbow World", "author": "GuntherRox", "description": "having fun", "tags": ["rainbow"], "likes": 0, "viewed": 55, "published": "Public", "date": "1520892163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//For Clouds\nbool circle (vec2 uv, vec2 p, float radius)\n{\n    \tfloat dist = sqrt((uv.x - p.x) * (uv.x -p.x) + (uv.y - p.y) * (uv.y - p.y)); \n    \tif (dist < radius) \n            return true;\n    \telse return false; \n    \n   \n    \n    \n}\n\n\n//Sky Gradient that changes\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  float sinTime = sin(iTime);\n  sinTime += 0.5;\n  sinTime *= 0.5;\n  \n  fragColor = vec4(sinTime,9,2,1);\n    \n \n //Sky Code ends here   \n    \n \t\n    \n\n//Location of White Cloud 1\n    \n  vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  uv -= (.18,.18);\t\t\t\t//-0.5 < > 0.5\n  uv.x *= iResolution.x/iResolution.y; \n   \n  vec2 center = vec2(0.0, 0.0);\n    \n    \n\n\n// Rainbow\n    \n\n     //Red Cloud Location\n     vec2 RedCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n    \n     //Orange Cloud Location\n     vec2 OrangeCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n    \n     //Yellow Cloud Location\n     vec2 YellowCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n    \n     //Green Cloud Location\n     vec2 GreenCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n    \n     //Blue Cloud Location\n     vec2 BlueCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n    \n    //PurpleCloud Location\n    vec2 PurpleCloud = vec2 (0.2, 0.25 * (1.0 + sin(iTime)) * 0.5);\n\n  //SPHERES\n    //Red Cloud Size\n\tfloat RedCloud1 = 0.33 * (1.0);\n    \n    //OrangeCloud Size\n    float OrangeCloud1 = 0.29 * (1.0);\n    \n    //YellowCloud Size\n    float YellowCloud1 = 0.24 * (1.0);\n    \n    //GreenCloud Size\n    float GreenCloud1 = 0.20 * (1.0);\n    \n    //BlueCloud Size\n    float BlueCloud1 = 0.15 * (1.0);\n    \n    //PurpleCloud Size\n    float PurpleCloud1 = 0.10* (1.0);\n    \n   //COLOR DESIGN \n    //Red Cloud Color Design\n    bool isInRedC = circle (uv, RedCloud, RedCloud1);\n    if (isInRedC) fragColor = vec4 (sin(iTime),0.3,0.5,1.0);\n    \n    //Orange Cloud Color Design\n \tbool isInOrangeC = circle (uv, OrangeCloud, OrangeCloud1);\n    if  (isInOrangeC) fragColor = vec4(sin(iTime),0.5,0.5,1.0);\n    \n    //Yellow Cloud Color Design\n \tbool isInYellowC = circle (uv, YellowCloud, YellowCloud1);\n    if  (isInYellowC) fragColor = vec4(sin(iTime),0.8,0.6,1.0);\n    \n    //Green Cloud Color Design\n \tbool isInGreenC = circle (uv, GreenCloud, GreenCloud1);\n    if  (isInGreenC) fragColor = vec4(sin(iTime),.9,0.7,1.0);\n   \n    //Blue Cloud Color Design\n \tbool isInBlueC = circle (uv, BlueCloud, BlueCloud1);\n    if  (isInBlueC) fragColor = vec4(sin(iTime),0.9,0.9,1.0);\n    \n    //Purple Cloud Color Design\n    bool isInPurpleC = circle (uv, PurpleCloud, PurpleCloud1);\n    if  (isInPurpleC) fragColor = vec4(sin(iTime),0.5,0.8,1.0);\n    \n    \n  //White circle Cloud\n    \n   //float radiusGreen = (0.175);\n       \n  //bool isInGreenCircle = circle(uv,center, radiusGreen); \n  // if (isInGreenCircle) fragColor = vec4 (1, 1, 1, 1); \n    \n //Cloud1\n    \n    //WhiteCloud  Location\n      vec2 WhiteCloud1 = vec2 (-0.05, 0.1 * (2.0 * sin(iTime)) * 0.8);\n    //WhiteCloud Size\n\tfloat WhiteCloud_1 = 0.2 * (0.9);\n    \n    \n    //White Clouds  Color Design\n    bool isWhiteC1 = circle (uv, WhiteCloud1, WhiteCloud_1);\n    if (isWhiteC1) fragColor = vec4 (sin(iTime),sin(iTime),sin(iTime),sin(iTime));\n    \n  //Cloud2\n    \n    //WhiteCloud  Location\n      vec2 WhiteCloud2 = vec2 (0.19, 0.06 * (2.0 * sin(iTime)) * 0.8);\n     \n    //WhiteCloud Size\n\tfloat WhiteCloud_2 = 0.25 * (0.9);\n    \n    \n    //White Clouds  Color Design\n    bool isWhiteC2 = circle (uv, WhiteCloud2, WhiteCloud_2);\n    if (isWhiteC2) fragColor = vec4 (sin(iTime),sin(iTime),sin(iTime),sin(iTime));\n        \n  //Cloud3\n    \n    //WhiteCloud  Location\n      vec2 WhiteCloud3 = vec2 (0.42, 0.087 * (2.0 * sin(iTime)) * 0.8);\n     \n    //WhiteCloud Size\n\tfloat WhiteCloud_3 = 0.2 * (0.9);\n    \n    \n    //White Clouds  Color Design\n    bool isWhiteC3 = circle (uv, WhiteCloud3, WhiteCloud_3);\n    if (isWhiteC3) fragColor = vec4 (sin(iTime),sin(iTime),sin(iTime),1.0);\n        \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 58, 58, 237], [240, 268, 324, 324, 3971]]}
{"id": "XdsfD8", "name": "Orange", "author": "sfbatchelor", "description": "Experiment in raymarching shadow colours. I tried to make the feeling of eerie natural movement just with trig funcs and a sphere.\n", "tags": ["mouse", "raymarch", "shadow", "abstract", "interaction", "smooth", "union", "click", "softshadow"], "likes": 5, "viewed": 123, "published": "Public", "date": "1522256291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON1 0.1\n#define EPSILON2 0.0001\n\n\nfloat sdPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float bgPlane = sdPlane(p, normalize(vec3(0,0,-1)), 1. );\n    vec3 sp1Pos = p+ vec3(cos(iTime*0.3)*57.,sin(iTime*0.56)*36., 30. + sin(iTime*0.115)*100.); \n    float sp1 = sdSphere(sp1Pos, 100.);\n    float o = smin(sp1, bgPlane, 0.9);\n    o = min(o, fOpUnionRound(sp1, bgPlane, 0.2));\n    \n        \n \treturn o;   \n}\n\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON2, p.y, p.z)) - map(vec3(p.x - EPSILON2, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON2, p.z)) - map(vec3(p.x, p.y - EPSILON2, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON2)) - map(vec3(p.x, p.y, p.z - EPSILON2))\n    ));\n}\n\n\nfloat ss( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0000;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.0001 )\n            return 0.0000;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 blue = vec4(0.03,0.,1.,1.);\n    vec4 orange = vec4(0.8,0.39,0.387,1.);\n    vec4 shcol = blue; \n\n    \n\tvec2 uv = ((fragCoord.xy*2.) / iResolution.xy) -1.;\n    // Blue/ Orange blend - bit too pinched in the corners still\n    float i1, i2, o1, o2;\n    float inner = mix(0.7, 0.78, sin(iTime));\n    float outer = mix(1.4, 1.2, sin (iTime));\n    float mixvalX = smoothstep(inner, outer, length(uv.x));\n    float mixvalY = smoothstep(inner, outer, length(uv.y));\n    float mixval = mixvalX+mixvalY;\n    fragColor = mix(orange, blue, mixval);\n    \n  \n    // cam setup\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 eye = vec3(0.,0., -550.);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 interest = vec3 (0.);\n    vec3 lookDir = normalize(eye - interest); \n    vec3 right = cross(up, lookDir);\n    float f = 2.9;\n    vec3 p = eye + f*lookDir + uv.x*right + uv.y*up;\n    vec3 rayDir = normalize(eye - p);\n    \n    // interact\n    float xm = iMouse.x - (iResolution.x/2.);\n    float ym = iMouse.y - (iResolution.y/2.);\n    xm *= -1.;\n    ym *= 1.;\n    if(iMouse.z < .5)\n    {\n        xm = sin(iTime*0.8)*380.;\n        ym = cos(iTime*0.7)*300.;\n    }\n    \n    vec3 light = vec3( xm, ym, -800.5);\n    vec3 lightDir = normalize(light - interest);\n    \n    float far = 1000.;\n    float near = 0.;\n    float t = 0.;\n    float d = 0.;\n    int maxS = 190;\n    \n    // raymarch\n    for(int i = 0; i < maxS; i++)\n    {\n        d = map(p + rayDir*t);\n        if(d <= EPSILON1)\n        {\n            vec3 hit = p + rayDir*t; \n            vec3 n = getNorm(hit);\n            float pn = ss(hit, lightDir, 0., 3000., 1.8);\n            fragColor = mix(mix(fragColor, shcol, (1.-pn)), fragColor, pn);\n            break;\n        }\n        \n        t += d;\n        if(t >= far)\n        {\n         \tbreak;   \n        }\n        \n    }\n          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 104, 104, 146], [148, 148, 183, 183, 207], [209, 288, 336, 336, 421], [423, 459, 500, 500, 593], [595, 595, 614, 614, 933], [935, 935, 957, 957, 1243], [1246, 1246, 1315, 1315, 1537], [1540, 1540, 1597, 1597, 3419]]}
{"id": "XdtyzX", "name": "Multiverse", "author": "patu", "description": "Reusing noise (\"stars\")  function from totally different shader. \nexperiment.\n\n", "tags": ["raymarching", "noise"], "likes": 15, "viewed": 334, "published": "Public", "date": "1519862543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// multiverse by Patu\n//\n// https://github.com/patuwwy/ShaderToy-Chrome-Plugin\n\n#define FOV 40.0\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n// Modified \"stars\" function from great shader of user Nimitz.\n// https://www.shadertoy.com/view/XsyGWV :\n// \"Very happy with this star function, cheap and smooth\"\nvec3 stars(in vec3 p)\n{\n    float res = 1000.;        \n\t\n    vec3 q = fract(p*(.15*res))-0.5;\n    vec3 id = floor(p*(.15*res));\n    vec2 rn = hash33(id).xy / 3.;\n    float c2 = 1.-smoothstep(0.,.73,length(q * .998));\n    c2 *= step(rn.x,.00+0.05);    \n\n    return abs(c2*c2*vec3(.57));\n}\n\nfloat map(vec3 p) {\n    return (stars(p * 0.009).r - .14) * .6;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    vec2 t = vec2(-.2, 0.);\n    for (int i = 0; i < 236; i++) {\n        float d = map(ro + rd * t.x);\n        if (abs(d) < 0.015) break;\n        t.x += d;         \n    }\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = .01;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist) * 1.;\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p) {\n    const vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001); \n    ld /= lDist; \n    float atten = 1. / (1.0 + lDist * 0.525+ lDist * lDist * .15);\n\n    float diff = max(dot(sn, ld), .3);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 14.0);\n    vec3 objCol = abs(sin(sp));\n    sceneCol += (objCol * (diff + 0.15) + abs(sin(sp)) * spec * 9.) * atten;\n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = \n        (fragCoord.xy - iResolution.xy * .5) / iResolution.y\n\t\t* tan(radians (FOV) / 2.0) * .75;\n    \n    float t = iTime,\n    \t  sk = sin(t * .2) * 1.0,\n       \t  ck = cos(t * .12) * 1.0;\n    \t\n    vec3 \n        sceneColor = vec3(0.),\n    \n        vuv = normalize(vec3(0., 1., 0.)),\n    \tro = vec3(ck * 3., 99., ck + iTime * .1) - 10.,\n    \tvrp =  ro - vec3(sk, ck + 10., 10.),\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        lp = ro - 1.;\n    \n    for (int i = 1; i < 4; i++) {\n        vec2 t = trace(ro, rd);\n\n        ro += rd * t.x;\n        vec3 sn = getNormal(ro);\n       \n        sceneColor += doColor(ro, rd, sn, lp, 0.) * 20. / float(i) - t.x / 1320.;\n        sceneColor *= softShadow(ro, lp, 0.2);\n\n        rd = mix(rd, reflect(rd, sn), .6);\n    }\n\n    fragColor = vec4(clamp(sceneColor * 3., 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 119, 119, 262], [264, 428, 451, 451, 715], [717, 717, 736, 736, 782], [784, 784, 814, 814, 1000], [1002, 1002, 1047, 1047, 1624], [1626, 1698, 1726, 1726, 1922], [1924, 1924, 1998, 1998, 2421], [2423, 2423, 2478, 2478, 3473]]}
{"id": "XdVcRm", "name": "Animated Procedural Wood", "author": "microwerx", "description": "An animated procedural wood texture map", "tags": ["texture", "wood", "proceduralgeneration", "proceduraltechniques"], "likes": 0, "viewed": 284, "published": "Public API", "date": "1521481713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 makeColor256(int r, int g, int b)\n{\n    return vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0);\n}\n\n\nvec3 lerp(float mix, vec3 a, vec3 b)\n{\n    return mix * a + (1.0 - mix) * b;\n}\n\n\nfloat wrap(float x, float xmin, float xmax)\n{\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec4 perlin = texture(iChannel0, 0.25 * uv);\n    \n    float numCycles = 8.0 * 3.14159;\n    float size = (0.5 * sin(iTime) + 0.5) * 4.0 + 2.0;\n    float numCyclesY = numCycles;\n    float sizeY = size;\n    \n    vec3 color1 = makeColor256(201, 176, 69);\n    vec3 color2 = makeColor256(130, 82, 13);\n    \n    float marble = sin(numCycles * uv.x + size * perlin.x) * sin(numCyclesY * uv.x + sizeY * perlin.y);\n    col = lerp(0.5 * marble + 0.5, color1, color2);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);// * perlin;\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 107], [110, 110, 148, 148, 188], [191, 191, 236, 236, 254], [257, 257, 314, 369, 1053]]}
{"id": "XdVcRW", "name": "p6mm kaleidoscope", "author": "truename", "description": "click the bottom left corner to see the kaleidoscope as a function of time. click anywhere else to see it evaluated at a particular time.", "tags": ["2d", "kaleidoscope", "tiling", "p6mm"], "likes": 10, "viewed": 3619, "published": "Public API", "date": "1521564384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// resolution independent p6mm tiling kaleidoscope with worley noise\n// this was inspired by a filter from the program Filter Forge.\n// 'Escher Cube' https://www.filterforge.com/filters/293.html\n// Filter Forge calls manhattan distance worley noise 'pyramid noise'\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n){return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat manh_distance(vec2 a, vec2 b) {\n    vec2 c = abs(a - b);\n    return c.x + c.y;\n}\n\nfloat pyramids(vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float mind = 2.0;\n    for (int i=-1;i<2;i++)\n    for (int j=-1;j<2;j++)\n    {\n        vec2 off = vec2(i,j);\n        vec2 top = vec2( rand(n+off), rand(n+off+234.1) );\n        float dist = manh_distance(f,top+off);\n        if (dist < mind) {\n            mind = dist;\n        }\n    }\n    return (2.0 - mind) / 2.0;\n}\n\n#define SQ3 1.7320508076\n\nmat2 rot2d(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\nvec2 p6mmmap(vec2 uv, float repeats) {\n    // clamp to a repeating box width 6x height 2x*sqrt(3)\n    uv.x /= SQ3;\n    uv = fract(uv * repeats - 0.5) - 0.5;\n    uv.x *= SQ3;\n\n    uv = abs(uv);\n    \n    vec2 st = uv;\n    \n    vec2 uv330 = rot2d(radians(330.)) * uv;\n    if (uv330.x < 0.0){\n        st.y = (st.y - 0.5) * -1.0;\n        st.x *= SQ3;\n        return st * 2.0;\n    }\n    else if (uv330.x > 0.5){\n        st.x = (st.x - 0.5 * SQ3) * -1.0 * SQ3;\n        return st * 2.0;\n    }\n    \n    vec2 uv30 = rot2d(radians(30.)) * uv;\n    if (uv30.y < 0.0 && uv30.x >= 0.5) st = vec2(1.0,1.0);\n    else if (uv30.y >= 0.0 && uv30.x >= 0.5) st = vec2(-1.0,1.0);\n    else if (uv30.y < 0.0 && uv30.x < 0.5) st = vec2(1.0,-1.0);\n    else st = vec2(-1.0,-1.0);\n    \n    uv30.x = uv30.x - 0.5;\n    uv = rot2d(radians(270.))* uv30;\n    st = uv * st;\n    st.x *= SQ3;\n    return st * 2.0;\n}\n\nfloat uc(float a) { return clamp(a,0.,1.); }\nfloat ns(float a, float t) { return noise(a+t); }\n\nvec3 square_noise(vec2 uv, float t) {\n    // 3 octaves of manhattan distance worley noise\n    float p1 = ns(pyramids(uv)*15.,t);\n    float p2 = ns(pyramids(uv+135.)*31.,t);\n    float p3 = ns(pyramids(uv+25.)*63.,t);\n    \n    float v = uc((p1*p2*p3-0.09)*41.);\n\n    vec3 res = hsv2rgb(vec3(uc(uc(p3)-0.2),uc(uc(p2)-0.2),v));\n\n\treturn res;\n}\n\nvec4 animate_noise(vec2 uv, float t) {\n\treturn vec4(square_noise((rot2d(radians(t*12.7))*(uv-0.25)+0.25)+t*0.06,t*0.2),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale fragCoord to 0 centered, resolution independent square coords\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= iResolution.x / 2000.0;\n\n    uv = p6mmmap(uv,2.) * 0.65;\n\n    float t = floor(iMouse.x/10.)*4.+4.*iResolution.x/10.*floor(iMouse.y/10.)-100000.;\n    fragColor = animate_noise(uv,t>-100000. ? t : iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVcRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 266, 286, 286, 324], [325, 325, 344, 344, 407], [408, 408, 429, 429, 518], [520, 579, 601, 601, 770], [772, 772, 809, 809, 858], [860, 860, 884, 884, 1249], [1277, 1277, 1298, 1298, 1343], [1345, 1345, 1383, 1442, 2223], [2225, 2225, 2244, 2244, 2269], [2270, 2270, 2298, 2298, 2319], [2321, 2321, 2358, 2410, 2660], [2662, 2662, 2700, 2700, 2788], [2790, 2790, 2847, 2922, 3226]]}
{"id": "XdVcWW", "name": "Confetti Drop", "author": "Passion", "description": "reference: https://www.youtube.com/watch?v=52TMliAWocY", "tags": ["2d", "grid", "tiling"], "likes": 9, "viewed": 341, "published": "Public", "date": "1522040434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = acos(-1.0);\nconst float TwoPI = PI * 2.0;\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\nfloat rand (float r){\n    return fract(sin(r*768.65)*7589.89);\n}\nfloat triangle(vec2 uv, float i){\n  // Number of sides of your shape\n  int N = int(i);\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TwoPI/float(N);\n\n  // Shaping function that modulate the distance\n  return cos(floor(.5+a/r)*r-a)*length(uv);\n}\n\nvec3 effect(vec2 uv, float t){\n    t*=2.;\n    uv*=3.5;\n    \n    vec2 a = vec2(3., 1.);\n    vec2 a2 = vec2(1.0, 2.0);\n    \n    vec2 st = vec2(uv*a);\n    vec2 id = floor(st);\n    \n    float n = rand(id.x);  //fract(sin(id.x*714.65)*7426.56);\n    st.y += t*.3;\n    st.y += n;\n\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t += rand(id.x+id.y)*TwoPI; //fract(sin(id.x*72.45+id.y*1488.88)*765.23)*TwoPI; //6.284;\n    \n    float y = -sin(t+sin(t+sin(t)*.5))*.40;\n    float x = .5* rand(id.y)-.24; //fract(sin(id.y*768.34)*7689.43)-.24;\n    \n    vec2 p1 = vec2(x, y);\n    vec2 p1t = ((st-p1) / a) * r2((-y*2.)+t*.5);\n    float d = triangle(p1t, n*4.+3.);\n    float m1 = smoothstep(.07, .0524, d);\n        \n    if(iMouse.z>0.1)\n        m1 = (st.x > .44 || st.y > .49) ? 1.0 : m1;\n    \n    vec3 rcol = vec3(rand(id.x+id.y),\n                     rand(id.x),\n                     rand(id.y));\n    \n    return mix(vec3(m1), rcol, m1);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord/iResolution.xy) - .5;\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n\n    //uv.x *= iResolution.x / iResolution.y;\n    uv /= 1.3-dot(uv,uv)*.33;\n    float t = iTime;//*.75;\n    uv.x += sin(t/5.)*4.;\n    uv.y -= cos(t/6.)*2.;\n    \n    \n    vec3 col = effect(uv*.8, t*1.8);\n    \n    uv*=r2(1.7);  //+sin(t/4.)\n    col+=effect(uv*1.3, t*1.75);\n    \n    uv*=r2(1.12);\n    uv.x += iTime*.25;\n    col+=effect(uv*1.2, t*1.25);\n    \n    uv*=r2(1.6);\n    uv.x-=iTime*.15;\n    col+=effect(uv*1.7, t*2.);\n    \n    \n    // Output to screen\n    //col = st; //vec3(st,0.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 77, 77, 153], [154, 154, 175, 175, 218], [219, 219, 252, 287, 507], [509, 509, 539, 539, 1443], [1445, 1445, 1502, 1601, 2187]]}
{"id": "XdycRz", "name": "hungry cube", "author": "expertmouser", "description": "getting CSG going", "tags": ["raymarching", "csg"], "likes": 1, "viewed": 353, "published": "Public API", "date": "1520747332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 oColor;\nvec2 vTexcoord;\nfloat iAspect;\n\n//-----------------------------------------------------------\n\n\nfloat myTime = 0.0;\n\nconst float kMaxFloat = 1000000000.; // lol\n\nconst float maxDist  = 4.0;\n\nconst float floorAmt    = -0.02;\nconst float floorHeight = 3.0;\n\nconst float MYPI = 3.14159265359;\nconst float degToRad = MYPI * 2.0 / 360.0;\nconst float radToDeg = 360.0 / MYPI / 2.0;\n\nvec3 rotZ(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.y * c,\n               v.x * c + v.y * s,\n               v.z);\n}\n\nvec3 rotY(vec3 v, float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return vec3( v.x * s - v.z * c,\n               v.y,\n               v.x * c + v.z * s);\n}\n\nvec2 msdfUnion(vec2 A, vec2 B) {\n  return A.x < B.x ? A : B;\n}\n\nvec2 msdfInter(vec2 A, vec2 B) {\n  return A.x > B.x ? A : B;\n}\n\nvec2 msdfMinus(vec2 A, vec2 B) {\n  return A.x > -B.x ? A : -B;\n}\n\n// cube of \"radius\" 1.\n// a sphere of radius 1 fits inside.\nfloat sdfCube(vec3 p) {\n  const float radius = 0.5;\n  float distxn  =  -p.x - radius;\n  float distxp  =   p.x - radius;\n  float distyn  =  -p.y - radius;\n  float distyp  =   p.y - radius;\n  float distzn  =  -p.z - radius;\n  float distzp  =   p.z - radius;\n\n  float distx   = max(distxn, distxp);\n  float disty   = max(distyn, distyp);\n  float distz   = max(distzn, distzp);\n\n  float distxy  = max(distx , disty);\n  float distxyz = max(distxy, distz);\n\n  return distxyz;\n}\n\nfloat sdfSphere(vec3 p) {\n  return length(p) - 1.0;\n}\n\nfloat sdfModSphere(vec3 p) {\n  return sdfSphere(fract(p / 3.0));\n}\n\nfloat sdfWarpSphere(vec3 p) {\n  float f = myTime * 0.1;\n  vec3 q = p;\n  const float overallDistortionMagnitude = 0.1;\n  const float mag2 = .2;\n  const float freq = 20.;\n  float mag = sin(myTime * 0.1) * overallDistortionMagnitude;\n  q.x += cos(p.z         * mag * 0.9 + f) * 0.1;\n  q.y += sin(p.z         * mag * 0.8 + f) * 0.1;\n  q.z += sin((p.x * p.y) * mag * 1.0 + f * 10.) * 0.1;\n  float dx = sin(p.z * freq) * mag2;\n  float dy = sin(p.x * freq) * mag2;\n  float dz = sin(p.y * freq) * mag2;\n  dx *= dx * dx * dx;\n  dy *= dy * dy * dy;\n  dz *= dz * dz * dz;\n  q.x += dx;\n  q.y += dy;\n  q.z += dz;\n  return length(q) - 0.75;\n}\n\nvec2 msdfSceneSingle(vec3 p) {\n  vec2 ret = vec2(sdfCube(p), 1.0);\n  return ret;\n}\n\nvec2 msdfScene(vec3 pt) {\n  // return sdfSceneSingle(pt);\n  pt = rotZ(pt, myTime * 0.11);\n  pt = rotY(pt, myTime * 0.13);\n\n\n  // return vec2(sdfModSphere(pt), 8.0);\n\n  vec2 c1 = vec2(sdfCube(pt), 3.0);\n  pt = rotY(pt, myTime * 0.321);\n  pt = rotZ(pt, myTime * 0.4321);\n  const float orbit = 0.65;\n  const float orbitSpeed = 0.5;\n  vec3 p2 = vec3(\n    sin(myTime * orbitSpeed * 1.0),\n    sin(myTime * orbitSpeed * 1.0),\n    sin(myTime * orbitSpeed * 1.1)\n  ) * orbit;\n  vec2 c2 = vec2(sdfSphere((pt + p2) * 3.0) / 3.0, 2.0);\n  vec2 d3 = msdfMinus(c1, c2);\n  d3 = msdfInter(d3, vec2(sdfSphere(pt * 1.42) / 1.42, 5.0));\n  d3 = msdfMinus(d3, vec2(sdfSphere(pt * 1.65) / 1.65, 7.0));\n  d3 = msdfUnion(d3, vec2(sdfCube(rotY((pt + p2) * 8.0, myTime * 2.0)) / 8.0, 6.0));\n  return d3;\n}\n\nvec3 sdfNormal(vec3 p) {\n  const float epsilon = 0.001;\n  vec3 v = vec3(\n    msdfScene(vec3(p.x + epsilon, p.y, p.z)).x - msdfScene(vec3(p.x - epsilon, p.y, p.z)).x,\n    msdfScene(vec3(p.x, p.y + epsilon, p.z)).x - msdfScene(vec3(p.x, p.y - epsilon, p.z)).x,\n    msdfScene(vec3(p.x, p.y, p.z + epsilon)).x - msdfScene(vec3(p.x, p.y, p.z - epsilon)).x\n  );\n\n  return normalize(v);\n}\n\nbool approximatelyEqualEps(float a, float b, float epsilon) {\n  float d = abs(a - b);\n  return d < epsilon ? true : false;\n}\n\nbool approximatelyEqual(float a, float b) {\n  const float epsilon = 0.0001;\n  return approximatelyEqualEps(a, b, epsilon);\n}\n\n// todo: generalize to any plane\nvec3 intersectRayXZPlane(vec3 pt, vec3 dir) {\n  if (approximatelyEqual(dir.y, 0.)) {\n    return vec3(kMaxFloat, 0, kMaxFloat);\n  }\n\n  float s = pt.y / dir.y;\n  return pt + dir * s;\n}\n\nfloat subfloor(vec3 groundPt) {\n  groundPt = rotY(groundPt, 45.0 * degToRad);\n  groundPt += vec3(\n    sin(myTime * 0.12  ) * 10.,\n    1,\n    sin(myTime * 0.1211) * 10.\n  );\n  float f = sin(groundPt.x * 1.2) * sin(groundPt.z * 1.2);\n  f *= f * f;\n  return f * 1.9 + 1.5;\n}\n\nfloat floorCheck(vec3 pt, vec3 rayDir) {\n  rayDir = rotY(rayDir, myTime * 0.031);\n  vec3 floorOffset = vec3(0, floorHeight, myTime * -4.1);\n  vec3 groundPt = intersectRayXZPlane(pt + floorOffset, rayDir);\n  float f = sin(groundPt.x) + sin(groundPt.z) - sin(myTime * 0.51) * 0.8;\n  float rf;\n  if (approximatelyEqualEps(f, 0., 0.07)) {\n    rf = 0.18;\n  }\n  else if (f < 0.) {\n    rf = 0.12;\n  }\n  else {\n    rf = subfloor(groundPt) * 0.1;\n  }\n\n  return rf;\n}\n\nvoid otherMain(void)\n{\n  vec3  lightDir = normalize(vec3(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0, -0.2));\n\n  lightDir = normalize(vec3(\n    cos(myTime * 1.13) * 2.0,\n    sin(myTime * 1.13) * 2.0,\n    sin(myTime * 0.5 ) * 1.2));\n\n  vec3  camPos = vec3(0, 0, -4.0);\n  float screenDist = 3.0;\n\n  vec2 tmp = vTexcoord * 2.0 - 1.0;\n  vec3 pxlPos;\n  if (iAspect > 1.0) {\n    pxlPos = vec3(tmp.x * iAspect, tmp.y, camPos.z + screenDist);\n  }\n  else {\n    pxlPos = vec3(tmp.x, tmp.y / iAspect, camPos.z + screenDist);\n  }\n\n  const float zoom = 0.75;\n  pxlPos.x *= zoom;\n  pxlPos.y *= zoom;\n\n  vec3 rayDir = normalize(pxlPos - camPos);\n\n  float maxZ = pxlPos.z + maxDist;\n\n  vec3 pt = pxlPos;\n\n  float finalDist;\n\n  int steps = 0;\n\n  bool hitSomething = false;\n\n  const float skyBrightness = 0.2;\n\n  oColor = vec4(skyBrightness);\n\n  while (length(pt) < maxZ) {\n    vec2 sdf = msdfScene(pt);\n    finalDist = sdf.x;\n    if (finalDist <= 0.0001) {\n      hitSomething = true;\n      vec3  n = sdfNormal(pt);\n      float d = dot(n, lightDir);\n      vec3 refl = reflect(rayDir, n);\n      float edgeness = 1. - abs(dot(n, rayDir));\n      float rf = 0.;\n      if (refl.y < floorAmt) {\n        rf = floorCheck(pt, refl) * 0.96;\n      }\n      oColor = vec4 (\n        d,\n        d,\n        d,\n        1.0\n      );\n      // oColor = vec4(\n      //   (sin(sdf.w * 60.) * 0.2 + 0.7) * d,\n      //   (sin(sdf.x * 80.) * 0.2 + 0.7) * d,\n      //   (sin(sdf.y * 60.) * 0.2 + 0.6) * d,\n      //   1.0);\n      // oColor = vec4(\n      //   max(oColor.x, rf),\n      //   max(oColor.y, rf),\n      //   max(oColor.z, rf),\n      //   1\n      // );\n      oColor.xyz += rf;\n\n      oColor *= vec4(\n        sdf.y == 5.0 ? 0.5 : 1.0,\n        sdf.y == 3.0 ? 0.5 : 1.0,\n        sdf.y / 3.0,\n        1.0\n      );\n\n      float e = edgeness;\n      // e = e * e * e * e;\n      // e = e * e;\n      // oColor -= vec4(e);\n      break;\n    }\n    const float minStep = 0.0001;\n    float step = max(finalDist, minStep);\n    // pt.z += step;\n    pt += rayDir * step;\n  }\n\n  if (!hitSomething) {\n    if (rayDir.y < floorAmt) {\n      float rf = floorCheck(camPos, rayDir);\n      oColor = vec4(rf, rf, rf, 1);\n\n    }\n  }\n}\n\n\n\n//-----------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iAspect     = iResolution.x / iResolution.y;\n    myTime      = iTime;\n    vTexcoord = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    otherMain();\n    fragColor = oColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdycRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 391, 425, 425, 568], [570, 570, 604, 604, 747], [749, 749, 781, 781, 811], [813, 813, 845, 845, 875], [877, 877, 909, 909, 941], [943, 1003, 1026, 1026, 1474], [1476, 1476, 1501, 1501, 1529], [1531, 1531, 1559, 1559, 1597], [1599, 1599, 1628, 1628, 2227], [2229, 2229, 2259, 2259, 2311], [2313, 2313, 2338, 2370, 3091], [3093, 3093, 3117, 3117, 3474], [3476, 3476, 3537, 3537, 3600], [3602, 3602, 3645, 3645, 3726], [3728, 3761, 3806, 3806, 3943], [3945, 3945, 3976, 3976, 4216], [4218, 4218, 4258, 4258, 4675], [4677, 4677, 4699, 4699, 6879], [6883, 6947, 7004, 7004, 7201]]}
{"id": "XdycWm", "name": "circle patterns", "author": "Nitato_", "description": "2d circle patterns\nmouse controlled\n", "tags": ["2d", "circle", "snake"], "likes": 3, "viewed": 384, "published": "Public API", "date": "1522170348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sdCircle(p, r) length(p)-r\n#define dAdd(d1, d2) min(d1,d2)\n#define mov(xy, t) xy-t\n#define asLine(d, thickness) smoothstep(thickness,0.,abs(d))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy )/iResolution.y;\n\tvec4 m = vec4(2.*iMouse - iResolution.xyxy ) /iResolution.y;\n\t\n    float objects = max(mod(m.x, 500.)+100., mod(m.y, 500.))+20.;\n    float d = 1000.;\n    float ds = d;\n    \n    for(float i=0.;i<objects;++i) {\n    \tfloat fi = float(i);\n        vec2 loc = mov(uv, vec2(sin(fi/mod(m.x,9.)+iTime)*1.9, sin(fi/mod(m.y,9.)+iTime*.5))*.8);\n    \tds = dAdd(ds,sdCircle(loc,.2));\n    }\n    \n    d = asLine(ds,0.3);\n   \n    fragColor = vec4(vec3(sin(iTime)*0.5, 0.5*d, 0.7*ds), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdycWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 210, 210, 745]]}
{"id": "XdyyDD", "name": "Takenoko", "author": "blackspotbear", "description": "Modified version of https://www.shadertoy.com/view/Xtd3z7\nWhat's takenoko: https://goo.gl/C8TwcW\nTakenoko equation: https://mobile.twitter.com/tompng/status/974333032495640576", "tags": ["raymarching"], "likes": 0, "viewed": 89, "published": "Public", "date": "1521982348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// see: https://mobile.twitter.com/tompng/status/974333032495640576\nfloat takenokoSDF(vec3 p) {\n    const float e = 2.71828182846;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    \n    float lhs = 1.0;\n    lhs += 2.0 * p.z;\n    lhs += pow(e, -p.z - 4.0);\n    lhs += pow(e, -8.0 * p.z - 48.0);\n    lhs += -8.0;\n    lhs += sqrt(1.0 / 8.0 + x2 + y2 + 2.0 * (x2 + y2) * (x2 + y2));\n    \n    float rhs = 1.0;\n    rhs *= 1.0 / (1.0 + pow(e, -16.0 * p.z - 72.0));\n    rhs *= max(\n        1.0 / (1.0 + pow(e, 8.0 * (p.z + p.x))) + 1.0 / (1.0 + pow(e, 8.0 * (p.z + p.x + 3.0))) + 1.0 / 2.0,\n        1.0 / (1.0 + pow(e, 8.0 * (p.z - p.x))) + 1.0 / (1.0 + pow(e, 8.0 * (p.z - p.x + 3.0)))\n    );\n    \n    return (lhs - rhs) * 0.024;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return takenokoSDF(samplePoint);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0 * sin(iTime),\n                          5.0,\n                          10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(10.0, 10.0, 10.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 24.0, 0.0);\n\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(-1.0, 0.0, 1.0));\n\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.4 + 0.2 * sin(iTime), 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.5, 0.25, 0.25);\n    vec3 K_d = vec3(0.7, 0.4, 0.4);\n    vec3 K_s = vec3(1.0, 0.8, 0.8);\n    float shininess = 4.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 193, 220, 220, 860], [862, 862, 896, 896, 935], [937, 937, 1028, 1028, 1334], [1336, 1336, 1401, 1401, 1533], [1535, 1535, 1564, 1564, 1874], [1876, 1876, 2016, 2016, 2450], [2452, 2452, 2537, 2537, 3240], [3242, 3242, 3291, 3291, 3517], [3519, 3519, 3576, 3576, 4337]]}
{"id": "XdyyRK", "name": "Gas giant.", "author": "Pr0fed", "description": "Really just a worley-perlin noise with another layer of worley noise which controls overall \"chunks\" animation with the help of cycling vertical line. I suppose i must switch some other noises as well :)", "tags": ["noise", "fbm", "perlin", "vorno"], "likes": 9, "viewed": 328, "published": "Public", "date": "1522522073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.40,  1.00, -1.00,  1.40 );\n\n// Time simplification and easier overall speed control.\n#define time iTime * 0.35\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return smoothstep(0.0, 1.35, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// 2D gradient noise\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n// Four octave worley FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * worley2D( p ); p = p * 2. * m;\n    f += 0.2500 * worley2D( p ); p = p * 2. * m;\n    f += 0.1250 * worley2D( p ); p = p * 2. * m;\n    f += 0.0625 * worley2D( p );\n    return f;\n}\n\n// Six octave perlin FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron, out vec2 rk)\n{\n    // Base motion.\n    float ql = length( q * m );\n    q += 0.05 * (0.5 + 0.5 * sin(time + ql * 1.05));\n\n    // First layer.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second layer.\n    vec2 n;\n    n = vec2(fbm6(q + fbm4( vec2(2.0 * o + vec2(2.)))));\n    \n    // Third layer.\n    vec2 k;\n    \n    // Line movement.\n    k = sin(0.25 * q.x - time) * vec2(fbm4(q * fbm4( vec2(2.0 * n + vec2(2.)))));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n + 8.0 * k ;\n    float f = 0.5 + 0.5 * fbm6( p ) ;\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.55 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n    rk = vec2(k);\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    vec2 k = vec2(0.0);\n    \n    float f = GetFBM(p, on, k);\n    \n    vec3 col = vec3(0.0);\n    \n    // Our 'background' bluish color.\n    col = mix( vec3(0.18, 0.45, 0.86), vec3(0.0, 0.0, 0.41), f );\n    \n    // Dark orange front layer.\n    col = mix( col, vec3( 0.91, 0.55, 0.0), dot(on.xy, on.zw));\n    \n    // Touch of cyan.\n    col = mix( col, vec3(0.0, 0.33, 0.62), 0.2 * smoothstep(0.8, 1.6, abs(k.x) + abs(k.y)));\n    \n    return col * col * 7. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p*= 4.;\n    \n    vec3 col = GetColor( p );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyyRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[191, 275, 298, 298, 469], [471, 492, 520, 520, 926], [928, 928, 946, 946, 985], [987, 987, 1003, 1003, 1080], [1082, 1082, 1109, 1109, 1488], [1490, 1517, 1539, 1539, 1754], [1756, 1782, 1804, 1804, 2207], [2209, 2209, 2259, 2279, 3185], [3187, 3218, 3241, 3241, 3731], [3733, 3733, 3790, 3830, 4003]]}
{"id": "XdyyzK", "name": "Light Snow", "author": "AlphaRogue", "description": "Little script making it snow.", "tags": ["2d", "snow"], "likes": 6, "viewed": 158, "published": "Public", "date": "1522532604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOD .02\n#define BLUE vec4(.11, .15, .2, 1.)\n#define WHITE vec4(1., .98, .9, 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 lM = vec2(max(iResolution.x, iResolution.y), min(iResolution.x, iResolution.y));\n\tvec2 pos = (fragCoord -.5 * lM) / lM.x;\n\t\n    float time = iTime * .001;\n\tfloat x = pos.x * 1.2 + time * 2.;\n\tx = .1 * sin(10. * cos(x / 2.) + cos((12. + sin(time * 7.)) * x) / 4. - sin((-28. + cos(time * 9.)) * x) / 9.) - .2 + mod(time, .6);\n\tif (pos.y < x) fragColor = mix(BLUE, WHITE, smoothstep(x, x - .005, pos.y));\n\telse {\n\t\tfloat size = MOD * .2;\n\t\tfloat decal = floor(pos.x / MOD);\n\t\tfloat pseudoRand = sin(decal * MOD * 100000.);\n\t\tfloat amplitude = pseudoRand * .5 + .5;\n\n\t\tpos.x = mod(pos.x + .5, MOD) - MOD / 2. + sin(iTime * 5. + decal) * (MOD / 2. - size) * amplitude;\n\n\t\tpos.y += iTime * (.2 + .2 * (sin(decal) * .5 + .5));\n\t\tpos.y = mod(pos.y + .5 + pseudoRand, .6) - size;\n\n\t\tsize /= 2.;\n\t\tsize += size * amplitude;\n\n\t\tfloat dist = length(pos);\n\t\tfragColor = length(pos) < size ? mix(BLUE, WHITE, smoothstep(size, size * .4, dist)) : BLUE;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 146, 146, 1096]]}
{"id": "Xs3cDj", "name": "sky and sun 2d", "author": "lz", "description": "simple 2d sky and sun. Mouse x value switches between 2d and 3d look.", "tags": ["2d", "fbm", "sky", "warp"], "likes": 9, "viewed": 252, "published": "Public", "date": "1520160644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI 3.14\n\nvec2 hash2(in vec2 uv)\n{\n  return fract(vec2(sin(uv.x*1834538.331),\n               sin(uv.y*617678.44)));\n}\n\nfloat hash(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat hash(in vec3 p)\n{\n  return fract(sin(dot(p,\n    vec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\n  vec3 pi = floor(p);\n  vec3 pf = fract(p);\n\n  pf = pf*pf*(3.-2.*pf);\n\n  float a = hash(pi + vec3(0., 0., 0.));\n  float b = hash(pi + vec3(1., 0., 0.));\n  float c = hash(pi + vec3(0., 1., 0.));\n  float d = hash(pi + vec3(1., 1., 0.));\n\n  float e = hash(pi + vec3(0., 0., 1.));\n  float f = hash(pi + vec3(1., 0., 1.));\n  float g = hash(pi + vec3(0., 1., 1.));\n  float h = hash(pi + vec3(1., 1., 1.));\n\n  return mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\n  mix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n  float f = .5*noise(uv);\n  vec2 off = vec2(0.01, 0.01);\n  f += .25*noise(uv*2.02 + off);\n  f += .125*noise(uv*4.01 + off);\n  f += .065*noise(uv*8.03 + off);\n  f += .0325*noise(uv*16.012 + off);\n\n  return f;\n}\n\n#define red vec3(1.,0.,0.)\n#define yellow vec3(1.,1.,0.)\n#define blue vec3(0.,0.,1.)\n#define white vec3(1.,1.,1.)\n#define ocean vec3(0.,0.6,0.93)\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 tuv = iMouse.xy/iResolution.xy;\n\n  uv.x *= iResolution.x/iResolution.y;\n  vec2 sc = uv-vec2(0.7,0.7);\n  float sr = dot(sc,sc);\n  float af = atan(sc.y, sc.x);\n  \n  vec3 sun = vec3(1.,1.,1.)*(1.-smoothstep(sr, 0.00,0.01));\n// sun = clamp(sun, 0.,1.);\n\n  vec2 duv = uv;\n    if (tuv.x > .5 && iMouse.z > 0.5) {\n        duv = vec2(uv.x*2. - 1., 1.)/(uv.y+0.1*(1.-uv.y));\n    }\n  float f = fbm(duv+tuv*4.);\n  float tt = 0.1*iTime;\n  float anf = noise(vec2(af*10. + tt*5., tt*4.));\n  float f2 = fbm(duv+2.*vec2(cos(f) + cos(tt), sin(f)+sin(tt)) );\n  vec3 sky = vec3(0.,0.,max(blue.b*(1.-sr), 0.));\n  vec3 col1 = mix(yellow, red, f);\n  vec3 col2 = mix(sky, white,\n    f2);\n  vec3 col = mix(col2, col1, f*f2);\n\n  //col = mix(vec3(0.,0.,0.), col, 2.*(  col.r*col.g));\n  col += sun*(4.*(1.-col.g)*exp(-col.g*4.));\n  //col = mix(col, sun, clamp(4.*(1.-col.g-col.r)*exp((-col.g-col.r)*4.), 0.,1.));\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3cDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 137, 137, 220], [222, 222, 246, 246, 363], [365, 365, 388, 388, 466], [468, 468, 493, 493, 996], [999, 999, 1025, 1025, 1534], [1536, 1536, 1556, 1556, 1766], [1918, 1918, 1975, 1975, 2942]]}
{"id": "Xs3cWj", "name": "n-ploy circles spinning", "author": "Stoteles_Harry", "description": "Variation by Chris M. Thomasson", "tags": ["math", "nausea"], "likes": 1, "viewed": 92, "published": "Public", "date": "1520138442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float V;\nfloat pi=radians(180.);\nfloat sqrt2=sqrt(2.);\n\nvec4 splat(vec2 D) {\n    float a = 10. + abs(sin(iTime * .4)) * 100.;\n    D /= V/a;            // splats radius \n    return exp(-.5*dot(D,D) ) * vec4(1,.7,.4,0)*2.; // colored Gaussian\n}\n\nvoid mainImage( out vec4 Out, vec2 In )\n{\n     float t=iTime+1.;\n     vec2 R = iResolution.xy; vec2 P;\n     V=max(R.x,R.y)/sqrt2;\n\n     float M=floor(t);\n     float K=t-M;\n     for (float j=0.; j<14.; j++) {\n         float F=2.*pi/(M+j);\n         float U=V-(j-K)*V/14.;\n         for (float i=0.; i<M+j; i++) {\n             P.x=R.x/2.+cos(F*i+cos(iTime))*U;\n             P.y=R.y/2.+sin(F*i+sin(iTime * .5))*U;\n             Out += splat(In-P);\n         }\n     }\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3cWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 76, 76, 242], [244, 244, 285, 285, 705]]}
{"id": "XsccDl", "name": "Pos To Color", "author": "Pr0fed", "description": "Further understanding of patterns.", "tags": ["patternsnoise"], "likes": 2, "viewed": 119, "published": "Public", "date": "1520502125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nconst vec3 ColorA = vec3(0.101961, 0.619608, 0.666667);\nconst vec3 ColorB = vec3(0.666667, 0.336667, 0.498039);\n\nvec2 random2( vec2 p ) \n{\n    return fract(sin(vec2(dot(p,vec2(0.1123, 0.7453)),dot(p,vec2(1.1235, 0.3123)))) * 0.5453);\n}\n\nvec3 PosToColor(vec2 st)\n{\n    return mix(ColorA, ColorB, vec3(random2(st).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    st *= 25.;\n    \n    vec2 st_i = floor(st);\n    st = fract(st) - 0.4;\n    \n\n    // Number of sides of a shape\n    int N = 3;\n\n    // Angle and radius from the current pixel\n    float a = atan(st.x, st.y) + PI;    \n    float r = TWO_PI / float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5 + a / r) * r - a) * length(st * 2.);\n\n    color = vec3(1.0 - smoothstep(.3, .5, d));\n    color *= PosToColor(st_i * iTime * 0.1);\n  \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsccDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 207, 207, 304], [306, 306, 332, 332, 387], [390, 390, 447, 497, 1104]]}
{"id": "XsccWs", "name": "Kreis_HalbrÃ¤ume", "author": "gerdich", "description": "Kreis mit doppeltem Halbraum", "tags": ["kreismithalbrumen"], "likes": 0, "viewed": 87, "published": "Public", "date": "1520529661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float xdivy=cos(2.0*iTime)*iResolution.x/iResolution.y;\n    float R=0.6*iResolution.y*abs(cos(1.5*iTime));\n    float r=0.4*abs(cos(3.0*iTime));\n    float angle=1.0*cos(0.5*iTime);\n    vec3 col=vec3(abs(cos(iTime)),uv.x,uv.y);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 center=vec2(0.5*(1.0+r*cos(4.0*iTime))*iResolution.x,0.5*(1.0+r*sin(4.0*iTime))*iResolution.y);\n    float nx=fragCoord.x-center.x;\n    float ny=fragCoord.y-center.y;\n    float a=nx*cos(angle)+ny*sin(angle);\n    float b=xdivy*(nx*sin(angle)-ny*cos(angle));\n    float ci=abs(cos(iTime));\n    if((nx*nx+ny*ny)<R*R)col=vec3(ci,uv.x,uv.y);else col=vec3(uv.x,ci,uv.y);\n    if(a<b)col.x=1.0-col.x;\n    if(a<-b)col.y=1.0-col.y;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsccWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 881]]}
{"id": "XscyDl", "name": "Petals", "author": "dr2", "description": "Exercise in variable curvature", "tags": ["flower", "leaf", "curvature", "petal"], "likes": 11, "viewed": 485, "published": "Public API", "date": "1520497751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Petals\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, h, r, y, s;\n  dMin = dstFar;\n  h = 2.;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * ((length (q.xz) > 0.) ? atan (q.z, - q.x) /\n     (2. * pi) : 0.) + 0.5) / 6.));\n  q.x += 3.1;\n  q.xy = Rot2D (q.xy, -0.33 * pi);\n  r = length (q.xz);\n  qq = q;\n  for (float k = 0.; k < 2.; k ++) {\n    q = qq;\n    q.y -= 0.1 * step (0.5, k);\n    q.xz = Rot2D (q.xz, sign (k - 0.5) * pi / 6.);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * ((r > 0.) ?\n       atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5) / 3.));\n    y = 0.5 * (1. + q.y / h);\n    s = 1. - 0.9 * cos (0.5 * pi * y);\n    d = max (PrCylAnDf (q.xzy, 0.3 + 0.5 * y + s * (1. + 0.5 * s) - 0.01 * step (0.5, k), 0.01, h),\n       abs (q.z) - 1.55 + 1.4 * (1. - (0.12 + y) * (0.88 - y)));\n    DMINQ (1);\n  }\n  dMin *= 0.5;\n  q = qq;  q.y += 1.75;\n  d = max (PrSphDf (q, 0.6), q.y - 0.4);\n  DMINQ (2);\n  q = qq;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (12. * ((r > 0.) ? atan (q.z, - q.x) /\n     (2. * pi) : 0.) + 0.5) / 12.));\n  q.y += 1.;\n  q.x = abs (q.x + 0.1 + 0.2 * q.y * (1. + q.y)) - 0.04;\n  d = 0.3 * PrCylDf (q.xzy, 0.01, 0.4);\n  DMINQ (3);\n  q = qq;  q.xy += vec2 (0.5, 2.35);\n  d = max (PrTorusDf (q, 0.05, 0.5), q.y);\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  d = max (d, - q.y);\n  DMINQ (4);\n  q.xy -= vec2 (0.5, -1.3);\n  d = PrCylDf (q.xzy, 0.05, 1.3);\n  DMINQ (4);\n  q = p;  q.y += 4.4;\n  d = PrCylDf (q.xzy, 1.5, 0.5 * (1. - 0.1 * length (q.xz) / 1.5));\n  DMINQ (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[3], ltCol[3], col, vn, ltDir, dfSum, spSum;\n  vec2 vf;\n  float dstObj, spec, cv, at, r, a;\n  for (int k = 0; k < 3; k ++) {\n    a = 2. * pi * float (k) / 3.;\n    ltPos[k] = 10. * vec3 (cos (a), 0.5, sin (a));\n  }\n  ltCol[0] = vec3 (1., 1., 0.4);\n  ltCol[1] = vec3 (1., 0.4, 0.4);\n  ltCol[2] = vec3 (0.4, 0.4, 1.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    spec = 0.;\n    if (idObj == 1) {\n      cv = (1. - 0.3 * (1. - 0.4 * (SmoothBump (0.4, 0.6, 0.05, mod (6. * (abs (qHit.z) -\n         0.3 * abs (qHit.x) - 0.6 * qHit.x * qHit.x), 1.)) + 1. - smoothstep (0., 0.02,\n         abs (qHit.z))))) * (1. - 0.3 * smoothstep (0.4, 0.5, abs (qHit.z) +\n         0.1 * abs ((qHit.x + 0.3) * (1. - (qHit.x + 0.3))))) *\n         (1. - 0.3 * smoothstep (-0.8, -0.5, qHit.x - 0.5 * abs (qHit.z)));\n      col = HsvToRgb (vec3 (floor (6. * (atan (ro.z, - ro.x) / (2. * pi) + 0.5) + 0.5) / 6., 0.7, cv));\n      spec = 0.1;\n      vf = vec2 (128., 0.1);\n    } else if (idObj == 2) {\n       if (qHit.y < 0.35) {\n        col = vec3 (0.3, 0.9, 0.2) * (1. - 0.3 * SmoothBump (0.4, 0.6, 0.05,\n           mod (12. * ((length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) : 0.), 1.)));\n        spec = 0.1;\n        vf = vec2 (64., 0.5);\n      } else {\n        r = length (qHit.xz);\n        qHit.xz = Rot2D (qHit.xz, 5. * tCur);\n        col = mix (vec3 (0.5, 0.5, 0.1), vec3 (0.4, 0.2, 0.1), SmoothBump (0.2, 0.8, 0.1,\n           mod (16. * r + ((r > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) : 0.), 1.)));\n        spec = 0.05;\n        vf = vec2 (32., 2.);\n      }\n    } else if (idObj == 3) {\n      col = mix (vec3 (0.9, 0.9, 0.2), vec3 (1., 0.1, 0.1), step (0.35, qHit.y));\n      spec = 0.1 - step (0.35, qHit.y);\n    } else if (idObj == 4) {\n      col = mix (vec3 (0.2, 0.3, 0.2), vec3 (0.2, 0.7, 0.1), smoothstep (-1., 0., qHit.y));\n      spec = 0.1;\n      vf = vec2 (64., 0.5);\n    } else if (idObj == 5) {\n      if (length (ro.xz) < 1.4) {\n        col = vec3 (0.25, 0.15, 0.1) * (0.5 + 0.5 * step (0.1, length (Rot2D (ro.xz, 2. * pi *\n           (floor (6. * atan (ro.z, - ro.x) / (2. * pi) + 0.5) / 6.)) + vec2 (0.25, 0.))));\n        vf = vec2 (32., 1.);\n      } else {\n        col = vec3 (0.7, 0.7, 0.9);\n        vf = vec2 (128., 0.2);\n      }\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (spec >= 0.) {\n      dfSum = vec3 (0.);\n      spSum = vec3 (0.);\n      for (int k = 0; k < 3; k ++) {\n        ltDir = normalize (ltPos[k]);\n        at = smoothstep (0.7, 0.8, dot (normalize (ltPos[k] - ro), ltDir));\n        dfSum += ltCol[k] * at * max (dot (vn, ltDir), 0.);\n        spSum += ltCol[k] * at * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n      }\n      col = col * (0.2 + 0.7 * dfSum) + spec * spSum;\n    }\n  } else {\n    col = vec3 (1., 1., 0.8) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az += 0.02 * pi * tCur;\n  }\n  el = clamp (el, 0.05 * pi, 0.4 * pi);\n  ro = 20. * vec3 (cos (el) * cos (az), sin (el), cos (el) * sin (az));\n  vd = normalize (vec3 (0., -1., 0.) - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  zmFac = 4.4 - 0.8 * abs (el);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 40.;\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col *= 0.8 + 0.2 * pow (1. - 0.5 * length (uvs * uvs), 4.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscyDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 579, 601, 601, 2072], [2074, 2074, 2107, 2107, 2284], [2286, 2286, 2307, 2307, 2507], [2509, 2509, 2544, 2544, 5487], [5489, 5489, 5545, 5545, 6527], [6529, 6529, 6562, 6562, 6589], [6591, 6591, 6633, 6633, 6684], [6686, 6686, 6739, 6739, 6800], [6802, 6802, 6848, 6848, 6905], [6907, 6907, 6964, 6964, 7047], [7049, 7049, 7079, 7079, 7137], [7139, 7139, 7163, 7163, 7299], [7333, 7333, 7357, 7357, 7487], [7489, 7489, 7514, 7514, 7700], [7702, 7702, 7731, 7731, 7943], [7945, 7945, 7984, 7984, 8164]]}
{"id": "XscyDS", "name": "Gabor - bad random", "author": "FabriceNeyret2", "description": "mouse.x:  frequency   mouse.y: direction\n\nleft: pure random splat locations.  right: quantized random splat locations.\nCorrelation in rand causes overshoots and extra variance.", "tags": ["random", "gabor", "bias"], "likes": 0, "viewed": 387, "published": "Public API", "date": "1519929620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/XsBGDc\n\n#define Q 20.       // random quantization on right\n#define NB 1000     // number or gabor blobs\n#define SIZE .22    // size of gabor blobs\n                    // freq and dir tuned by mouse.x\n#define PI 3.1416\n\n#define gauss(x)  exp(-(x*x)/(SIZE*SIZE))\n\n// chose texture vs procedural rand :\n//#define Rnd(i,j) texture( iChannel1, (.5+vec2(i,j)) / iChannelResolution[1].x ).r\n#define Rnd(i,j) fract(sin(dot(vec2(i,j), vec2(12.9898, 78.233))) * 43758.5453)\n \n#define rnd(i,j) ( U.x < 0. ? Rnd(i,j) : round( Rnd(i,j) *Q ) / Q )\n\nfloat gabor(vec2 pos, vec2 dir) {          // Gabor splat\n    vec2 G = gauss(pos);\n    float s = .5*sin( dot(pos,dir)*6.28 -10.*iTime );\n\treturn G.x*G.y *s ;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy/R, pos,dir;\n         U = (U+U-R)/R.y;\n    if (M==vec2(0)) M = vec2(.16);\n    O -= O;  \n    float f = 3.+20.* M.x,                 // frequency\n          a = PI/2. * M.y;                 // direction\n    dir = vec2(cos(a),sin(a));\n    \n    for (int i=0; i<NB; i++) {\n        pos = ( 2.* vec2( rnd(i,0), rnd(i,1) ) - 1. ) * R/R.y;\n        O += gabor(U-pos, f*dir );\n    }\n    O = .5+.5*O *8./sqrt(float(NB));\n    \n         if( O.r > 1.) O = vec4(1,0,0,0);  // show overshoots\n    else if ( O.r <0.) O = vec4(0,0,1,0);\n}\n                  \n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscyDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 577, 610, 634, 736], [738, 738, 776, 776, 1346]]}
{"id": "XsGcDh", "name": "JZYX", "author": "challenge", "description": "JZYX", "tags": ["jzyx"], "likes": 3, "viewed": 203, "published": "Public", "date": "1521709720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Disition(vec3 ro, vec3 rd, vec3 p) {\n \treturn length(cross(p-ro, rd))/length(rd);   \n}\n\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n    float d = Disition(ro, rd, p);\n    d = smoothstep(0.06, 0.05, d);\n    return d;\n}\n\nvec3 DrawRectangle(float k, float is, float ie, float js, float je, vec3 color, vec3 ro, vec3 rd) {\n \tvec3 col = vec3(0.0);\n    for(float i = is; i <= ie; i += 0.2) {\n        for(float j = js; j <= je; j += 0.2) {\n            if(i == is || i == ie || \n               j == js || j == je ||\n               k == 0.0 || k == 1.0) {\n\n                col += DrawPoint(ro, rd, vec3(i, j, k)) * color;\n            }\n        }       \n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = ( fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(3.0*sin(t), sin(t), -8.0*cos(t));\n    float zoom = 1.0;\n    \n    vec3 lookAt = vec3(0.5);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i - ro;\n    \n    float d = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for(float k = 0.0; k <= 1.0; k += 0.2) {\n        \n        col += DrawRectangle(k, 0.0, 2.0, -1.0, 0.0, vec3(0.99, 0.20, 0.58), ro, rd);\n        col += DrawRectangle(k, -1.0, 0.0, -2.0, 0.0, vec3(0.0, 0.75, 0.94), ro, rd);\n\t\tcol += DrawRectangle(k, -2.0, 0.0, 0.0, 1.0, vec3(0.21, 0.81, 0.33), ro, rd);\n\t\tcol += DrawRectangle(k, 0.0, 1.0, 0.0, 2.0, vec3(1.0, 0.91, 0.28), ro, rd);\n\n    }   \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 92], [95, 95, 138, 138, 224], [226, 226, 325, 325, 674], [676, 676, 733, 733, 1619]]}
{"id": "XsGcWw", "name": "day2.0", "author": "Nitato_", "description": "Circle, rectangle, triangle, hexagon, rounded rectangle and various transformation functions. \nMouse do color change.", "tags": ["2d", "test"], "likes": 3, "viewed": 132, "published": "Public", "date": "1522156898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rep(vec2 p, float n) {\n\treturn fract(p*n)*2.-1.;\n}\nvec2 rep(vec2 p, vec2 n) {\n    float r = n.x/n.y;\n    vec2 a = (r<1. ? vec2(1./r,1.) : vec2 (1.,r));\n\treturn fract(p*n)*a*2.-a;\n}\nvec4 rep4(vec2 p, float n) {\n    vec2 pn = p * n;\n \treturn vec4(fract(pn) * 2.0 - 1.0, floor(pn));   \n}\nvec2 rot(vec2 xy, float ang) {\n\tfloat s = sin(ang);\n    float c = cos(ang);\n    return xy * mat2(c, -s, s, c);\n}\nfloat sdCircle(vec2 p, float r) {\n\treturn length(p) - r;\n}\nfloat sdTri(vec2 p, float h) {\n\tvec2 q = abs(p);\n    return max(q.x*0.866025+p.y*0.5,-p.y)-h*0.5;\n}\nfloat sdRect(vec2 p, vec2 d) {\n    vec2 pd = abs(p)-d;\n\treturn min(max(pd.x,pd.y),0.)+length(max(pd,0.));\n}\nfloat sdHex(vec2 p, vec2 h){\n    vec2 q = abs(p);\n    return max(q.x*0.866025+q.y*0.5,q.y)-h.x;\n}\nfloat udRoundRect(vec2 p, vec2 b, float r) {\n  \treturn length(max(abs(p)-b,0.0))-r;\n}\nfloat udRect(vec2 p, vec2 d) {\n   \treturn length(max(abs(p)-d, 0.));\n}\nfloat asLine(float d, float thickness) {\n\treturn (1. - smoothstep(0.,thickness,abs(d)));\n}\nvec2 scale(vec2 xy, vec2 s) {\n\treturn xy.xy/s.xy;\n}\nfloat correct(float d) {\n      float e = 2.0/iResolution.y;\n      return d<0.1 ? d/length(vec2(dFdx(d),dFdy(d))/e) : d;\n}\nvec2 mov(vec2 xy, vec2 t) {\n\treturn xy - t;\n}\nfloat asFilled(float d) {\n\treturn (1. - smoothstep(0.,.01,d));\n} \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 uv = (fragCoord/iResolution.xy *2. - vec2(1.0)) * aspect;\n    vec4 m = vec4((iMouse.xy / iResolution.xy*2.0 - vec2(1.0)) * aspect,(iMouse.zw / iResolution.xy*2.0 - vec2(1.0)) * aspect);\n\tvec4 uv4 = rep4(uv, 3.);    \n    uv = uv4.xy;    \n    float s = mod(uv4.z+uv4.w, 5.);\n    float d = 0.0;\n    if(s > 3.) {\n        uv = rot(uv, iTime*-1.);\n\t    uv = rep(uv, sin(iTime)+1.5);\n        d = sdCircle(uv, .75);\n    \td = correct(d);\n    \td = asLine(d, .02);\n    } else if(s > 2.)  {\n        uv = rot(uv, iTime);\n    \td = sdRect(uv, vec2(.65));\n        d = asLine(d, .13);\n    } else if(s>1.) {\n        uv = mov(uv,  vec2(0.,-.26));\n    \tuv = scale(uv, vec2(sin(iTime)*0.2+1.));\n        d = sdTri(uv, .85);\n        d = asLine(d, .13);\n    } else if(s>0.) {\n        uv = rot(uv, iTime);\n        uv = rep(uv, sin(iTime)*0.5+0.75);\n    \td = sdHex(uv, vec2(.75));\n        d = asLine(d,.13);\n    } else {\n    \td = udRoundRect(uv, vec2(.7), .13);\n        d = asLine(d, 0.13);\n    }   \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(sin(m.x)*0.5+0.5,2.*uv4.z*(sin(iTime)*.5+.5),4.*uv4.w*(cos(m.x)*0.5+0.5)));\n    fragColor = vec4(col,1.0)*d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 55], [56, 56, 82, 82, 185], [186, 186, 214, 214, 289], [290, 290, 320, 320, 402], [403, 403, 436, 436, 461], [462, 462, 492, 492, 561], [562, 562, 592, 592, 669], [670, 670, 698, 698, 767], [768, 768, 812, 812, 853], [854, 854, 884, 884, 924], [925, 925, 965, 965, 1015], [1016, 1016, 1045, 1045, 1067], [1068, 1068, 1092, 1092, 1189], [1190, 1190, 1217, 1217, 1235], [1236, 1236, 1261, 1261, 1300], [1302, 1302, 1359, 1359, 2557]]}
{"id": "XsGyRm", "name": "layered animated figure", "author": "FabriceNeyret2", "description": "Reproducing [url]https://www.facebook.com/CosmosUpp/videos/1001518269996955/[/url]\n\nSome people consider it's a kind of optical illusion, but I really disagree: just layering.", "tags": ["2d", "lines", "illusion", "points", "short", "reproduction", "animgif"], "likes": 26, "viewed": 849, "published": "Public API", "date": "1521383004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R       iResolution\n#define P(i)    vec2( cos(k*(i)+T/10.), sin(k*(i)+T/10.) )           // heptastar vertex i\n#define S(D,w)  smoothstep( 3., 0.,  length(D)*R.y - w )             // smooth draw\n#define F(t,dt) smoothstep(.2,-.2, abs(t+.5-mod(T/3.-2.,14.))-dt/2.) // fading\nfloat   T , k = 6.28*3./7.;                                // angle between heptastar vertices\n\nfloat line(vec2 p, vec2 a, vec2 b) {                       // draw a line\n    b -= a; p -= a;\n    return S( p - b * clamp(dot(b,p)/dot(b,b), 0., 1.) , 0. );\n}\n\nvec2 point(float n) {                                      // point(n,t) on heptastar \n    float t = mod(T/5.+ n*7./12.,7.), i = floor(t);\n    return mix( P(i), P(i+1.), .5-.5*cos(3.14*fract(t)) );\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U = ( U+U - R.xy ) / R.y;\n    T = iTime;\n    O -= O;\n    for (float i=0.; i<7.; i++)\n        O.rga += line( U, P(i), P(i+1.) ) * F(9.,7.);      // yellow lines\n\n    for (float n=0.; n<12.; n++) {  \n        vec2 P0 = point(n),\n             P1 = point(n+4.),\n             P2 = point(n+3.);\n            \n        O.a += S( P0-U, 8. ) ;                             // dots\n        O.ra += line( U, P0, P1 ) * (F(2.,1.)+F(9.,3.));   // triangles\n        O.ba += line( U, P0, P2 ) * (F(4.,1.)+F(9.,5.));   // squares\n    }\n    O += (1.-O.a) * .7;                                    // background\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 378, 414, 451, 536], [538, 538, 559, 624, 737], [739, 739, 778, 778, 1373]]}
{"id": "XsGyzR", "name": "2D Dynamic Noise ", "author": "ircss", "description": "A fun noise function I was developing to understand the whole noise thing better. The base 2D noise was from book of shaders, this is a 3D version of it for a 2D surface. ", "tags": ["2d", "noise", "gradient", "dynamic"], "likes": 4, "viewed": 173, "published": "Public", "date": "1520772254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 random3(vec3 st)\n{\n    st = vec3( dot(st,vec3(127.1,311.7,211.2)),\n            \tdot(st,vec3(269.5,183.3, 157.1)), dot(st,vec3(269.5,183.3, 17.1))  );\n   \treturn -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise3D(vec3 st) \n{\n\tvec3 i = floor(st) ;\n  \tvec3 f = fract(st);\n\t\t\n    vec3 u = smoothstep(0.,1.,f);\n    \n\tfloat valueNowxy01 =mix( mix( dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y);\n\tfloat valueNowxy02 =mix( mix( dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                    \t\t \t dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                \t\tmix( dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                     \t\t \t dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y);\n\n    return abs(mix(valueNowxy01, valueNowxy02, u.z));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float _Time = iTime /*+ smoothstep(0.0, 0.25, abs(uv.x - abs(fract(iTime * 0.1)*2.-1.)))*/;\n\n    // Time varying pixel color\n    float refNoise = noise3D(vec3(uv.xy*7., _Time*0.8)) ;\n    \n    vec2 N=vec2(refNoise,refNoise);\n    \n   \n    \n    float index=0.1;\n    float dotProduct=dot(N,uv);\n    \n    float constant1=1.-pow(index, 2.1)*(1.-pow(dotProduct,2.1));\n    uv= index*uv  - (index*dotProduct+sqrt(constant1))*N;\n    \n    \n    vec3 col = clamp(vec3(noise3D(vec3(uv.xy*2. + 100., _Time/4.))*1.,\n                    noise3D(vec3(uv.xy*2. + 5220., _Time/4.))*1.0,\n                    noise3D(vec3(uv.xy*2. + 6200., _Time/5.)))*2.+0.5,0.,1.);\n    col.y = min(col.z, max(col.y, col.x))*col.x;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 209], [211, 211, 236, 236, 1131], [1134, 1134, 1191, 1241, 2047]]}
{"id": "XsKcRz", "name": "Slow Drops", "author": "dr2", "description": "Merging, reflecting droplets moving slowly", "tags": ["reflection", "gravity", "droplet", "coalescence"], "likes": 4, "viewed": 462, "published": "Public API", "date": "1520855406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Slow Drops\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_SPHR 8\n\nvec3 sunDir, vnCylOut;\nfloat htSphr[N_SPHR], rSphr[N_SPHR], dstFar, tCur, tCyc, sFac, rHole, bCylRad, bCylHt, dCylOut;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvoid SphrSetup ()\n{\n  float t, s, g, h0, v0, hMax;\n  tCyc = 10.;\n  t = mod (tCur, tCyc);\n  sFac = (t < 0.5 * tCyc) ? 0.3 : 0.1;\n  rHole = 0.01 + 0.3 * SmoothBump (0.45, 0.55, 0.05, mod (t / tCyc + 0.5, 1.));\n  h0 = -5.1;\n  for (int k = 0; k < N_SPHR; k ++) {\n    s = float (k) + 2.;\n    hMax = - h0 + 0.5 * pow (s, 1.5);\n    g = 8. * hMax / (tCyc * tCyc);\n    v0 = sqrt (2. * g * hMax); \n    htSphr[k] = 0.4 * (h0 + v0 * t - 0.5 * g * t * t);\n    rSphr[k] = 0.4 * (0.2 + 0.03 * pow (s, 1.5));\n  }\n}\n  \nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.y -= - (bCylHt - 1.75);\n  q = p;  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 3., 0.2);\n  q = p;\n  d = - SmoothMin (- d, PrSphDf (q - vec3 (0., 0.18, 0.), rHole), 0.5 * rHole);\n  for (int k = 0; k < N_SPHR; k ++) {\n    q = p;  q.y -= htSphr[k];\n    d = SmoothMin (d, PrSphDf (q, rSphr[k]), sFac * rSphr[k]);\n  }\n  DMIN (1);\n  q = p;  q.y -= 0.22;\n  d = PrRoundBox2Df (vec2 (length (q.xz) - 3.1, q.y), vec2 (0.1, 0.22), 0.03);\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y) + 0.001;\n  return mix (vec3 (0.2, 0.3, 0.65) + 0.2 * pow (max (dot (rd, sunDir), 0.), 256.),\n     vec3 (0.8), clamp (3. * (Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz + tCur)) -\n     0.4) * rd.y + 0.2, 0., 1.));\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (0.3, 3. * h);\n    if (sh < 0.001) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV, r, s, sh;\n  InCylHit (ro + vec3 (0., - bCylHt + 1.25, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = (ro.y - 1.75) / bCylHt;\n    hhy = abs (hy) - 0.43;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else col = vec3 (0.5, 0.5, 0.4) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.5 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.7, 0.72, 0.6);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        qw = 16. * vec2 (12. * aa, hy);\n        rg = ShStagGrid (qw);\n        col *= rg.y * (1. - 0.3 * Noisefv2 (8. * qw));\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, sunDir), 0.)) +\n         0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    r = length (ro.xz);\n    vn = vec3 (0., 1., 0.);\n    if (r < 1.) col = SkyCol (ro, reflect (rd, vn));\n    else {\n      b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n      col = vec3 (0.75, 0.72, 0.72);\n      s = b * SmoothBump (0.45, 0.55, 0.04, mod (2. * r, 1.));\n      col *= 1. - 0.05 * s;\n      vn.y = 1. - 0.05 * s;\n      vn.xz = - sign (s) * sqrt (1. - vn.y * vn.y) * ro.xz / r;\n      col *= (1. - 0.2 * b * Noisefv2 (128. * ro.xz));\n      sh = ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, cRefl;\n  float dstObj, s, r, sh;\n  dstObj = ObjRay (ro, rd);\n  cRefl = vec3 (1.);\n  if (dstObj < dstFar && idObj == 1) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (ro.y < 0.41 - (bCylHt - 1.75)) {\n      r = length (ro.xz);\n      s = 0.001 * sin (2. * pi * (4. * r - 0.5 * tCur)) / (r * r);\n      vn.y = 1. - abs (s);\n      vn.xz = - sign (s) * sqrt (1. - vn.y * vn.y) * ro.xz / r;\n      vn = VaryNf (8. * ro + 0.2 * tCur * vec3 (0., 0., 1.), vn, 0.05);\n    } else cRefl *= vec3 (1., 0.95, 1.);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar && idObj == 1) {\n    cRefl *= vec3 (1., 0.95, 1.);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = SkyCol (ro, reflect (rd, vn));\n    else if (idObj == 2) {\n      col = vec3 (0.6, 0.5, 0.5) * (1. - 0.2 * SmoothBump (0.45, 0.55, 0.03,\n         mod (32. * atan (ro.z, - ro.x) / pi, 1.)));\n      vn = VaryNf (32. * ro, vn, 1.);\n      sh = ObjSShadow (ro, sunDir);\n      col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n    }\n  } else {\n    col = BgCol (ro, rd);\n  }\n  col *= cRefl;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  SphrSetup ();\n  bCylRad = 16.;\n  bCylHt = 3.;\n  ro = vec3 (0.2, 6., -12.);\n  vd = normalize (vec3 (0., max (0.4 * htSphr[N_SPHR - 1], -0.2), 0.) - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  rd = vuMat * normalize (vec3 (uv, 4.5));\n  dstFar = 50.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKcRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 692, 711, 711, 1190], [1194, 1194, 1216, 1216, 1709], [1711, 1711, 1744, 1744, 1921], [1923, 1923, 1944, 1944, 2144], [2146, 2146, 2180, 2180, 2701], [2703, 2703, 2735, 2735, 2976], [2978, 2978, 3004, 3004, 3354], [3356, 3356, 3393, 3393, 3631], [3633, 3633, 3664, 3664, 6520], [6522, 6522, 6557, 6557, 7867], [7869, 7869, 7925, 7925, 8552], [8554, 8554, 8601, 8601, 8648], [8650, 8650, 8683, 8683, 8710], [8712, 8712, 8754, 8754, 8805], [8807, 8807, 8852, 8852, 8955], [8957, 8957, 9014, 9014, 9097], [9099, 9099, 9129, 9129, 9187], [9221, 9221, 9245, 9245, 9375], [9377, 9377, 9402, 9402, 9588], [9590, 9590, 9611, 9611, 9766], [9768, 9768, 9797, 9797, 10009], [10011, 10011, 10050, 10050, 10230]]}
{"id": "XsKczR", "name": "Nelumbo Rays", "author": "audiopixel", "description": "Raymarching with some lighting techniques", "tags": ["raymarching", "rays", "lighting", "lotus"], "likes": 3, "viewed": 167, "published": "Public", "date": "1520842828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Nelumbo Rays'\n// Created by Hepp Maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nfloat t;\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5.0+t, (20.))-10.; a = abs(o.y);\n    float ss = t * .4 + sin(t) * .6 ; \n    p.yz *= r2d(sign(a)* (2.*.011 + (ss*.02)) - .2 + (-.1821 - sin(t * .09) * .315 + sin(t * .3) * .6));\n    p.xz *= r2d(sign(a)*ss);\n    p.xz = amod(p.xz, 0.8853975);\n    p.xz = max(abs(p.xz)-(-0.1527 + sin(t) * 2.7), -0.7384 - sin(t * .3) * 1.2);\n    p.z = mod(p.z, -1.4761)-(-0.73805);\n    float s1 = 8.7073 + sin(t * .4) * 6.;\n    p.x = mod(p.x, s1)-(s1 *.5);\n    p.y = mod(p.y+2., 22. + sin(t) * .014)-5.;\n    d = min(d, soc(max(abs(p)-0.1831, 0.1593)));\n    return (length(p*-0.1409)-1.3971)*.2746 - (d * -2.);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    t = iTime + 65.;\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n\n    vec3 ro = vec3(st, 10.5022);\n    vec3 rd = normalize(vec3(st+vec2(0.), -0.4142));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp);\n        if (md <.001) break;\n        mp += (rd * 0.4807)*md*0.8384;\n    }\n    vec3 c1 = vec3(-0.2386 - (length(ro-mp) * .025) * -1.291), c2, c3;\n    vec3 p = ro + rd * (mp);\n    if (md > 0.0964) {\n        vec3 l = vec3(0);\n        float dif = clamp(dot(calcNormal(p), normalize(l - p)), 0., 1.);\n        dif *= 5. / dot(l - p, l - p);\n        c2 = vec3(pow(dif, .4545)); \n    } else { c3 = vec3(p.x * .15); }\n\n    vec3 c4 = vec3((mp.z * 2.5) * (md * .05), 0, 0); c2 = vec3((c2.r > 0.5) ? max(c4.r, 2.0 * (c2.r - 0.5)) : min(c4.r, 2.0 * c2.r), (c2.r > 0.5) ? max(c4.g, 2.0 * (c2.g - 0.5)) : min(c4.g, 2.0 * c2.g),(c2.b > 0.5) ? max(c4.b, 2.0 * (c2.b - 0.5)) : min(c4.b, 2.0 * c2.b));\n    fragColor = vec4(abs(c1 - (c2 - c3)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKczR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[157, 296, 315, 315, 426], [428, 428, 447, 447, 522], [524, 524, 552, 552, 637], [639, 639, 658, 658, 1302], [1304, 1304, 1332, 1332, 1494], [1496, 1496, 1552, 1552, 2546]]}
{"id": "XsKczw", "name": "Moebius thingy", "author": "Ultraviolet", "description": "My go at the classical Moebius / torus  mutant.\nClick to select the number of sides and of twists.\nPress space to visualise strands.", "tags": ["triangle", "illusion", "penrose"], "likes": 9, "viewed": 138, "published": "Public", "date": "1521534939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Penrose Triangle II\" by Ultraviolet. https://shadertoy.com/view/XdccDX\n// 2018-03-19 15:09:36\n\n\n#define PI\t\t\t\t3.1415926535\n#define LIGHT_DIR\t\tnormalize(vec3(1., 2., 1.5))\n\n//#define CAM_PARAM\t\tsmoothstep( 0., 1., max(mod(iTime*.2, 1.)-.8, 0.)*5.)\n//#define CAM_PARAM\t\t(iTime*.3)\n#define CAM_PARAM\t\t0.\n#define CAM_POS \t\tvec3(2./sqrt(2.)*1.5*cos(CAM_PARAM*2.*PI+PI*.25), 1.5, 2./sqrt(2.)*1.5*sin(CAM_PARAM*2.*PI+PI*.25))\n\n#define WIDTH\t.1\n#define SIZE\t1.25\n\n#define CAM_CTRL\tfalse\n\n#define NB_SIDES\t4.\n#define NB_LOOPS\t.5\n\n#define AA\t\t2.\n\n\nfloat polyDist(vec2 p, float n, float rad, out vec2 norm, out float mat)\n{    \n    float alpha = atan(p.y, p.x)*.5/PI+.5;\n    float alpha0 = (floor(alpha*n)/n-.5)*2.*PI;\n    float alpha1 = (ceil(alpha*n)/n-.5)*2.*PI;\n    \n    vec2 p0 = rad*vec2(cos(alpha0), sin(alpha0));\n    vec2 p1 = rad*vec2(cos(alpha1), sin(alpha1));\n    \n\tvec2 pa = p-p0, ba = p1-p0;\n    norm = normalize(ba.yx)*vec2(-1., 1.);\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h )*sign(dot(pa, norm));\n    \n    mat = alpha0/PI*.5+.5;\n    \n    if(texelFetch(iChannel0, ivec2(32, 2), 0).x < .5)\n    \treturn -d;\n    \n    vec2 pp = rad*vec2(cos((alpha0+alpha1)*.5), sin((alpha0+alpha1)*.5));\n    norm = -normalize(p-pp);\n    return length(p-pp)-0.03;\n}\n\n\n\nvec2 sdBeam(vec3 p, out vec3 n)\n{\n    vec3 p_circle = normalize(p*vec3(1., 0., 1.));\n    vec3 dif = p-p_circle;\n    \n    n = normalize(dif);\n    float d = length(dif)-.2;\n    \n    vec3 X = normalize(p_circle);\n    vec3 Y = vec3(0., 1., 0.);\n    vec3 Z = cross(X, Y);\n    \n    float nb_side = 1.+ceil(0.01+iMouse.x/iResolution.x*7.);\n    float nb_loops = round(2.*iMouse.y/iResolution.y*nb_side)/nb_side;\n    \n    if(CAM_CTRL)\n    {\n        nb_side  = NB_SIDES;\n        nb_loops = NB_LOOPS;\n    }\n    else if(length(iMouse.xy)<1.)\n    {\n        nb_side  = 4.;\n        nb_loops = 3./4.;\n    }\n    \n    float alpha = atan(p_circle.z, p_circle.x)*nb_loops+iTime*.3;\n    X = cos(alpha)*X+sin(alpha)*Y;\n    Y = cross(Z, X);\n    \n    vec2 norm2d;\n    float mat;\n    d = polyDist(vec2(dot(dif, X), dot(dif, Y)), nb_side, .2, norm2d, mat);\n    \n    n = -norm2d.x*X-norm2d.y*Y;\n    \n    if(nb_loops*nb_side > .5)\n      mat += (alpha/nb_loops/PI*.5+.5)*nb_loops;\n    \n    return vec2(d, mat);\n}\n\n\nvec2 map(vec3 p, out vec3 n )\n{\n    vec2 res = vec2( 1000., 1.0 );\n        \n    res = sdBeam(p,  n);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 n )\n{\n    float tmin = 0.1;\n    float tmax = 20.0;\n   \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t, n );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*.75;\n        //t += 0.05;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    \n    return vec2( t, m );\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 colorMap(float t)\n{\n    return hsv2rgb(vec3(t, 1., 1.));\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = .6+.4*vec3(pow(max(0., dot(rd, LIGHT_DIR)), 2.));\n    \n    vec3 nor;\n    vec2 res = castRay(ro,rd, nor);\n    if( res.y>-0.5 )\n    {\n        col = colorMap(res.y);\n        //col = vec3(1.);\n        col = (.1+.9*max(0., dot(nor, LIGHT_DIR))) * (.2+.8*col);\n        \n        //col = nor;\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    //*\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\t/*/\n    vec3 cv = normalize(cp - dot(cp, cw)*cw);\n    vec3 cu = vec3(1., 0.,0.);\n    cu = normalize(cu-dot(cu, cv)*cv-dot(cu, cw)*cw);\n    cu *= -determinant(mat3( cu, cv, cw ));\n    //*/\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n        \n    // ray computation\n    vec3 ro = vec3(0.,1.,0.) + 2.*vec3(cos(mo.x*PI*2.)*cos(mo.y*.5*PI), sin(mo.y*.5*PI), sin(mo.x*PI*2.)*cos(mo.y*.5*PI));\n    if(!CAM_CTRL)\n        ro = CAM_POS;\n    \n    vec3 ta = vec3(0.);\n    mat3 m = setCamera(ro, ta, 0.0);\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    ro = ro + m[0]*p.x + m[1]*p.y;\n    rd = m[2];\n    \n    // scene rendering (using oversampling)\n    vec3 col;\n    \n    \n    for(float ii=0.; ii<AA; ii+=1.)\n    for(float jj=0.; jj<AA; jj+=1.)\n    {\n    \tcol += render( ro, rd+(m[0]*ii+m[1]*jj)/AA/iResolution.y/2.);\n    }\n    col /= AA*AA;\n    \n    // gamma correction\n    col = sqrt(col);\n    \n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 550, 624, 624, 1303], [1307, 1307, 1340, 1340, 2290], [2293, 2293, 2324, 2324, 2416], [2418, 2418, 2470, 2470, 2829], [2831, 2831, 2858, 2858, 3036], [3038, 3038, 3062, 3062, 3101], [3104, 3104, 3141, 3141, 3470], [3473, 3473, 3525, 3525, 3899], [3901, 3901, 3958, 3958, 4752]]}
{"id": "XsKyW1", "name": "Wheels_Anvoker", "author": "Anvoker", "description": "Tiling rotating wheels", "tags": ["beginner", "circle", "wheel", "rotating", "tiling"], "likes": 0, "viewed": 84, "published": "Public", "date": "1521839761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Setup=========\nconst int n = 12;\nconst float rotSpeed = 0.5;\nconst float circleBorder = 0.8;\nconst float lineBorder = 0.0025;\nconst vec3 backCol = vec3(0.0, 0.0, 0.0);\nconst vec3 lineCol = vec3(0.0, 0.75, 0.0);\nconst vec3 circCol = vec3(0.75, 0.0, 1.0);\n//==============\n\nconst float nf = float(n);\nconst float r = 1.0 / float(n * 2);\nconst float lengthLine = r * 0.9;\nconst float rSqr = r * r;\nconst float rSqr2 = rSqr * circleBorder;\n\n#define M_PI 3.141593\n\nvec3 drawCircles(in vec2 uv)\n{\n    vec3 col = backCol;\n    \n    // Time based radius\n    float rtime = abs(cos(iTime * rotSpeed)) * rSqr;\n    float rtime2 = abs(cos(iTime * rotSpeed)) * rSqr2;\n    \n    // Shift the coordinate system by the radius\n    // Otherwise everything is drawn in the bottom left corner instead of the center of the circle\n    uv.x = uv.x - r;\n    uv.y = uv.y - r;\n    \n    // Get the x coord of center of the circle closest to our current coord\n    float i = round(uv.x * nf);\n    float a = i / nf;\n    \n    // Get the y coord of center of the circle closest to our current coord\n    float j = round(uv.y * nf);\n    float b = j / nf;\n    \n    // Circle Equation\n    float ax = uv.x - a;\n    float by = uv.y - b;\n    float circle = by * by + ax * ax;\n    \n    //Line Coords\n    float x = ax;\n    float y = by;\n    \n    //Controls the rotational offset of the lines\n    float iTime2 = iTime + M_PI / 2.0;\n    float iTime3 = iTime + M_PI / 4.0;\n    float iTime4 = iTime - M_PI / 4.0;\n    \n    //Line Equations\n    float lineEq1 =   sin(iTime) * x - cos(iTime) * y\n                    + cos(iTime) * x + sin(iTime) * y;\n    \n    float lineEq2 =   sin(iTime2) * x - cos(iTime2) * y\n                    + cos(iTime2) * x + sin(iTime2) * y;\n    \n    float lineEq3 =   sin(iTime3) * x - cos(iTime3) * y\n                    + cos(iTime3) * x + sin(iTime3) * y;\n    \n    float lineEq4 =   sin(iTime4) * x - cos(iTime4) * y\n                    + cos(iTime4) * x + sin(iTime4) * y;\n\n    // Circle color\n    col += circCol * max(sign(rtime - circle ), 0.0) \n                   * max(sign(circle - rtime2), 0.0);\n\n    // Line Color\n    col += lineCol * max(sign(rtime2 - circle), 0.0) \n        *  (  max(sign(lineBorder - abs(lineEq1)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq2)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq3)), 0.0)\n           +  max(sign(lineBorder - abs(lineEq4)), 0.0));\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = drawCircles(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 462, 492, 492, 2406], [2408, 2408, 2463, 2463, 2578]]}
{"id": "XstyDj", "name": "Menger Sponge Insides", "author": "chronosis", "description": "Inside a Menger Sponge", "tags": ["raymarching", "fractal", "menger"], "likes": 1, "viewed": 137, "published": "Public", "date": "1520241514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Based on Inigo Quilez Menger Sponge\n// http://www.iquilezles.org/www/articles/menger/menger.htm\n\n#define levels 7.\n#define steps 250\n\n// light\nvec3 light = normalize(vec3(1.0, 0.9, 0.3));\n\nfloat msize = pow(3., (levels - 3.));\n\nfloat maxcomp(in vec3 pos) { return max(pos.x, max(pos.y, pos.z));}\nint msteps = steps;\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 delta = abs(pos) - size;\n  float mc = maxcomp(delta);\n  return min(mc, length(max(delta, 0.0)));\n}\n\nvec4 map(in vec3 pos)\n{\n    float d = sdBox(pos, vec3(msize));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float size = (-3. / msize);\n    for( float lvl = 0.; lvl < levels; lvl++ )\n    {\n        // \n        vec3 a = mod( pos * size, 2.0 ) - 1.0;\n        // Increase size by 3 each level\n        size *= 3.0;\n        vec3 r = abs(3.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / size;\n\n        // if point is outside box\n        if( c > d )\n        {\n          d = c;\n          res = vec4( d, min(res.y, 0.2 * da * db * dc), (1.0 + float(lvl)) / levels, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i < msteps; i++ )\n    {\n\t\tif( h.x < 0.001 || t > msize ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t > msize ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i = 0; i < msteps; i++ )\n    {\n        h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n\t\tt += clamp(h, 0.0005, 0.1);\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background color\n    float f = rd.y * 0.5 + 0.5;\n    vec3 col = mix( vec3(0.8, 0.3, 0.2), vec3(0.7, 0.7, 0.2), f);\n    vec2 r = rd.xy;\n    r.x = abs(abs(r.y) - abs(r.x));\n    col *= vec3(texture(iChannel0, r.xy).x);\n\t\n    vec4 tmat = intersect(ro, rd);\n    if( tmat.x > 0.0 )\n    {\n        vec3  pos = ro + tmat.x * rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow(pos, light, 0.1, 128.0);\n\n\t\tfloat dif = max(0.1 + 0.9 * dot(nor, light), 0.0);\n\t\tfloat sky = 0.5 + 0.5 * nor.y;\n        float bac = max(0.4 + 0.6 * dot(nor, vec3(-light.x, light.y, -light.z)), 0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00 * dif * vec3(1.10, 0.85, 0.60) * sha;\n        lin += 0.50 * sky * vec3(0.10, 0.20, 0.40); // * occ;\n        lin += 0.10 * bac * vec3(1.00, 1.00, 1.00) * (0.5 + 0.5 * occ);\n        lin += 0.25 * occ * vec3(0.15, 0.17, 0.20);\t \n\n        vec3 matcol = vec3(\n            0.6 + 0.5 * cos(2.0 + 2.0 * tmat.z),\n            0.5 + 0.5 * cos(1.0 + 1.0 * tmat.z),\n            0.5 + 0.5 * cos(0.0 + 0.0 * tmat.z) );\n        col = matcol * lin;\n    }\n\n    //return col;\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    vec3 ro = 10. * vec3(0.5 * sin(0.25 * ctime), 1.0 + 1.0 * cos(.13 * ctime), 0.5 * cos(0.25 * ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww ));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize( p.x * uu + p.y * vv + 2.5 * ww );\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "ltXSRr", "previewfilepath": "https://soundcloud.com/chronosis/orthogonal", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/chronosis/orthogonal", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstyDj.jpg", "access": "shaders20k", "license": "mit", "functions": [[156, 250, 278, 278, 317], [339, 339, 373, 373, 479], [481, 481, 504, 504, 1201], [1203, 1203, 1245, 1245, 1526], [1528, 1528, 1593, 1593, 1830], [1832, 1832, 1862, 1862, 2102], [2104, 2104, 2141, 2165, 3308], [3310, 3310, 3367, 3367, 3882]]}
{"id": "XsVcDW", "name": "Big SETI", "author": "dr2", "description": "Seeking \"intelligence\" (i.e. radio users) in the cosmos; auto/manual day/night views, mouseable", "tags": ["grid", "radio", "antenna", "telescope"], "likes": 7, "viewed": 448, "published": "Public API", "date": "1522052615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Big SETI\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA   1   // optional antialiasing (0/1 - off/on)\n\nfloat PrEllips2AnDf (vec3 p, vec2 r, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HexGrid (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, ltPos, ltAx;\nvec2 gId;\nfloat tCur, dstFar, hgSize, hgLim, antAz, antEl, netAz, netEl;\nint idObj;\nbool isNt;\nconst int idBase = 1, idRng = 2, idLegB = 3, idJnt = 4, idMesh = 5, idLegR = 6,\n   idRefl = 7, idDsk = 8;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 rAnt;\n  float dMin, d, r, w;\n  dMin = dstFar;\n  rAnt = vec2 (2.7, 2.);\n  w = 0.015;\n  d = dMin;\n  p.xz -= HexToPix (gId * hgSize);\n  q = p;  q.y -= 0.5;\n  d = PrCylDf (q.xzy, 1.55, 0.5);\n  DMINQ (idBase);\n  q.y -= 0.55;\n  qq = q;\n  qq.xz = Rot2D (qq.xz, antAz);\n  q = qq;\n  d = PrCylAnDf (q.xzy, 1.4, 0.1, 0.05);\n  DMINQ (idRng);\n  q.y -= 2.8;\n  d = PrCylDf (q.xzy, 0.35, 0.05);\n  DMINQ (idRng);\n  q = qq;  q.y -= 3.1;\n  r = length (q);\n  q.xz = Rot2D (q.xz, pi / 6.);\n  q.xz = Rot2D (q.xz, ((r > 0.) ? 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) +\n     0.5) / 6.) : 0.));\n  q.y -= -0.6;\n  q.xy = Rot2D (q.xy, 0.13 * pi);\n  q.xy -= vec2 (-0.3, -1.35);\n  d = PrCylDf (q.xzy, 0.05, 1.5);\n  DMINQ (idLegB);\n  q = qq;  q.y -= 2.8;\n  d = max (max (PrFlatCylDf (q.yxz, 0.27, 0.2, 0.25), - q.y), 0.05 - abs (abs (q.z) - 0.1));\n  DMINQ (idJnt);\n  qq.y -= 3.1;\n  qq.xy = Rot2D (qq.xy, antEl);\n  q = qq;  q.y -= 0.17;\n  d = max (PrFlatCylDf (q.yxz, 0.17, 0.18, 0.15), 0.05 - abs (q.z));\n  DMINQ (idJnt);\n  qq.y -= rAnt.y + 0.45;\n  r = length (qq);\n  if (r > 0.) {\n    q = qq;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (netAz * atan (q.z, - q.x) / (2. * pi) + 0.5) / netAz));\n    d = abs (q.z) - w;\n    q = qq;\n    q.xz = Rot2D (q.xz, pi / netAz);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (netAz * atan (q.z, - q.x) / (2. * pi) + 0.5) / netAz));\n    q.xy = Rot2D (q.xy, 0.5 * pi * (floor (netEl * asin (q.y / r) / (0.5 * pi) + 0.5) / netEl));\n    d = min (d, abs (q.y) - w);\n    q = qq;\n    d = max (max (d, PrEllips2AnDf (q.xzy, rAnt, w)), q.y - w);\n    q.y -= 2.5 * w;\n    d = min (d, PrTorusDf (q.xzy, 1.5 * w, rAnt.x));\n    DMINQ (idMesh);\n    q = qq;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (3. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 3.));\n    q.x -= - rAnt.x;\n    q.xy = Rot2D (q.xy, 0.3 * pi);\n    q.y -= 1.5;\n    d = PrCylDf (q.xzy, 0.03, 1.5);\n    DMINQ (idLegR);\n    q = qq;  q.y -= 1.8;\n    d = PrCylAnDf (q.xzy, 0.25, 0.03, 0.05);\n    DMINQ (idRefl);\n    q = qq;  q.y -= 0.02 - rAnt.y;\n    d = PrCylDf (q.xzy, 0.5, 0.07 * (1. - dot (q.xz, q.xz) / 0.3));\n    DMINQ (idDsk);\n  }\n  return dMin;\n}\n\nvoid SetGrdConf ()\n{\n  antAz = pi * sin (0.1 * tCur);\n  antEl = 0.25 * pi * (1. + 0.8 * sin (tCur));\n  if (gId.x == 0. && gId.y == 0.) {\n    antEl = 0.1 * pi;\n    antAz *= 0.5;\n  } else if (gId.y == 0.) {\n    antAz *= -1.;\n  } else if (gId.x + gId.y == 0.) {\n    antEl = 0.5 * pi - antEl;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) <= hgLim) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetGrdConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + 0.001;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.1;\n  for (int j = 0; j < 60; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) > hgLim) break;\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += min (0.18, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, rds, mDir, vn;\n  float mRad, bs, ts;\n  if (isNt) {\n    mDir = normalize (vec3 (-1., 0.1, 0.));\n    mRad = 0.01;\n    col = vec3 (0.02, 0.02, 0.04) + vec3 (0.06, 0.04, 0.02) *\n       pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n    bs = dot (rd, mDir);\n    ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n    if (ts > 0.) {\n      ts = bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - mDir) / mRad);\n        col += 0.8 * vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (0.5, 0.4, -0.77), vn) *\n           (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n      }\n    }\n    if (ts < 0.) {\n      rds = floor (2000. * rd);\n      rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n      for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n      col += smoothstep (0.01, 0.04, rd.y) * vec3 (0.8, 0.8, 0.6) *\n         min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n    }\n  } else {\n    rd.y = abs (rd.y) + 0.001;\n    col = mix (vec3 (0.2, 0.3, 0.5) + 0.3 * pow (max (dot (rd, sunDir), 0.), 8.), vec3 (1.),\n       0.2 + 0.8 * rd.y * Fbm2 (2. * rd.xz / rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, rg, ltDir;\n  float dstObj, spec, a, r, h, sh, atten;\n  bool isBg, isLit;\n  netAz = 84.;\n  netEl = 24.;\n  dstObj = ObjRay (ro, rd);\n  isBg = true;\n  isLit = false;\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    spec = 0.1;\n    r = length (qHit.xz);\n    a = atan (qHit.z, - qHit.x) / (2. * pi);\n    if (idObj == idBase) {\n      col = vec3 (0.6, 0.3, 0.1);\n      h = smoothstep (-0.45, -0.35, qHit.y);\n      if (vn.y < 0.01) {\n        rg = ShStagGrid (vec2 (a, qHit.y), vec2 (32., 8.));\n        col *= rg.y * (1. - 0.2 * Noisefv2 (16. * vec2 (8. * a, qHit.y) + 17. * gId));\n        if (rg.x == 0.) {\n          vn.y = rg.z * h;\n          vn.xz *= sqrt (1. - vn.y * vn.y * h);\n        } else vn.xz = Rot2D (vn.xz, - rg.x * h);\n      } else col *= 0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (6. * r, 1.));\n      col = mix (vec3 (0.45, 0.4, 0.1) * (1.-\n         0.3 * Noisefv2 (64. * vec2 (8. * a, qHit.y))), col, h);\n      vn = VaryNf (32. * qHit, vn, 0.5);\n      spec = 0.05;\n    } else if (idObj == idRng) {\n      col = vec3 (0.4, 0.43, 0.4) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (36. * a, 1.)));\n    } else if (idObj == idLegB) {\n      col = vec3 (0.4, 0.43, 0.4) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (8. * qHit.y, 1.)));\n    } else if (idObj == idJnt) {\n      col = vec3 (0.5, 0.5, 0.55);\n      if (abs (qHit.z) > 0.24 && length (qHit.xy - vec2 (0., 0.27)) < 0.08) col *= 0.5;\n    } else if (idObj == idMesh) {\n      col = vec3 (0.6, 0.6, 0.65);\n      spec = 0.2;\n    } else if (idObj == idLegR) {\n      col = vec3 (0.6, 0.5, 0.4) * (0.5 +\n         0.5 * SmoothBump (0.1, 0.9, 0.02, mod (8. * qHit.y, 1.)));\n    } else if (idObj == idRefl) {\n      if (isNt) {\n        col = vec3 (1., 0.7, 0.2) * (0.3 +\n           0.7 * SmoothBump (0.4, 0.6, 0.02, mod (18. * a, 1.)));\n        isLit = true;\n      } else col = vec3 (0.6, 0.5, 0.4) * (0.5 +\n         0.5 * SmoothBump (0.05, 0.95, 0.02, mod (36. * a, 1.)));\n    } else if (idObj == idDsk) {\n      col = vec3 (0.7, 0.6, 0.4);\n      if (qHit.y > 0.) col *= 0.7 +\n         0.3 * SmoothBump (0.1, 0.9, 0.02, mod (16. * r + a, 1.));\n    }\n  } else if (rd.y < 0.) {\n    isBg = false;\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    col = 0.7 * mix (vec3 (0.35, 0.4, 0.2), vec3 (0.45, 0.4, 0.1),\n       smoothstep (0.3, 0.7, Fbm2 (ro.xz)));\n    spec = 0.;\n    vn = VaryNf (ro, vec3 (0., 1., 0.), 2.);\n  }\n  if (isBg) {\n    col = SkyCol (rd);\n  } else if (! isLit) {\n    if (isNt) {\n      ltDir = ltPos - ro;\n      atten = 1.2 * smoothstep (0.1, 0.2, dot (ltAx, - ltDir)) /\n         (1. + 0.002 * pow (length (ltDir), 1.5));\n      ltDir = normalize (ltDir);\n    }\n    sh = (dstObj < dstFar) ? ObjSShadow (ro, (isNt ? ltDir : sunDir)) : 1.;\n    if (isNt) {\n      col = mix (col, Maxv3 (col) * vec3 (1., 1., 0.8), 0.5);\n      col = atten * (col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         2. * spec * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    } else {\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      col = mix (col, SkyCol (rd), smoothstep (0.5, 1., dstObj / dstFar));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvd, ori, ca, sa, mMid, ut, mSize;\n  float el, az, asp, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  isNt = (mod (0.05 * tCur, 2.) < 1.);\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (1. / mSize.y, 1. / mSize.y - 1.) * mSize * vec2 (1. - 1./6., -1.);\n  ut = abs (uv - mMid) - mSize;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    isNt = isNt = ! isNt;\n  }\n  hgSize = 10.;\n  hgLim = 7.;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0. && (mPtr.x < 0.5 - 1./6. || mPtr.y > -0.5 + 1./6.)) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.01 * pi * tCur;\n    el += 0.15 * pi * cos (0.02 * pi * tCur);\n    if (mPtr.z > 0. && ! (mPtr.x < 0.5 - 1./6. || mPtr.y > -0.5 + 1./6.)) isNt = ! isNt;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 6. - 4. * abs (el);\n  ro = vuMat * vec3 (0., 0., -40.);\n  if (ro.y < 1.) {\n    ro.y = 1.;\n    ro.xz *= sqrt (1599.) / length (ro.xz);\n  }\n  dstFar = 300.;\n  sunDir = normalize (vec3 (cos (0.02 * pi * tCur), 1., sin (0.02 * pi * tCur)));\n  ltPos = ro + vuMat * vec3 (3., 3., 0.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n#if ! AA\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n#else\n  col = vec3 (0.);\n  for (int iy = 0; iy <= 1; iy ++) {\n    for (int ix = 0; ix <= 1; ix ++) {\n      uvd = (0.5 / canvas.y) * (2. * vec2 (float (ix), float (iy)) - 1.);\n      rd = vuMat * normalize (vec3 (uv + uvd, zmFac));\n      col += ShowScene (ro, rd);\n    }\n  }\n  col *= 0.25;\n#endif\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0.1, 0.1, 0.8);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrEllips2AnDf (vec3 p, vec2 r, float w)\n{\n  return max ((length (p / (r.xxy + w)) - 1.) * (min (r.x, r.y) + w),\n            - (length (p / (r.xxy - w)) - 1.) * (min (r.x, r.y) - w));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p = p - HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVcDW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1150, 1172, 1172, 3299], [3301, 3301, 3321, 3321, 3595], [3597, 3597, 3630, 3630, 5022], [5024, 5024, 5045, 5045, 5245], [5247, 5247, 5284, 5284, 5788], [5790, 5790, 5824, 5824, 6178], [6180, 6180, 6203, 6203, 7318], [7320, 7320, 7355, 7355, 10688], [10690, 10690, 10746, 10746, 12784], [12786, 12786, 12833, 12833, 12976], [12978, 12978, 13020, 13020, 13071], [13073, 13073, 13126, 13126, 13187], [13189, 13189, 13248, 13248, 13388], [13390, 13390, 13436, 13436, 13493], [13495, 13495, 13540, 13540, 13643], [13645, 13645, 13702, 13702, 13785], [13787, 13787, 13809, 13809, 13847], [13849, 13849, 13871, 13871, 13909], [13911, 13911, 13941, 13941, 13999], [14001, 14001, 14025, 14025, 14255], [14257, 14257, 14281, 14281, 14341], [14343, 14343, 14366, 14366, 14502], [14536, 14536, 14560, 14560, 14690], [14692, 14692, 14716, 14716, 14936], [14938, 14938, 14963, 14963, 15149], [15151, 15151, 15176, 15176, 15401], [15403, 15403, 15424, 15424, 15579], [15581, 15581, 15602, 15602, 15757], [15759, 15759, 15788, 15788, 16000], [16002, 16002, 16041, 16041, 16221]]}
{"id": "XsVczh", "name": "EnhancedPhasePortrait", "author": "soma_arc", "description": "Hello, Phase Portrait\nReference:\nVisual Complex Functions: An Introduction with Phase Portraits by Elias Wegert", "tags": ["2d", "complex", "phaseportrait"], "likes": 6, "viewed": 181, "published": "Public", "date": "1521339717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\n\n// Suggestions by FabriceNeyret2. Thank you.\n#define gammaCorrect(rgb)  min( pow( rgb, vec3(DISPLAY_GAMMA_COEFF) ), 1.)\n#define degamma(rgb)       min( pow( rgb, vec3(GAMMA_COEFF) ), 1.)\n#define compProd(a,b)      mat2(a,-a.y,a.x) * b\n#define compQuot(a,b)      mat2(a,(a).y,-(a).x)  * (b) / dot(b, b)\n#define hue(h)  ( .6 + .6 * cos( 6.3 *  (h)  + vec4(0,23,21,0)  ) )\n\n/*\nvec3 gammaCorrect(vec3 rgb) {\n  return min(pow(rgb, vec3(DISPLAY_GAMMA_COEFF)), 1.);\n}\n\nvec3 degamma(vec3 rgb) {\n  return min(pow(rgb, vec3(GAMMA_COEFF)), 1.);\n}\n\n/*\nvec2 compProd(const vec2 a, const vec2 b){\n\treturn vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n*/\n\nconst float PI = 3.141592;\nconst float TWO_PI = 2. * PI;\nconst int SAMPLE_NUM = 20;\nconst float GRAY_SCALE = 0.6;\nconst float CANVAS_SCALE = 4.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 sum = vec3(0);\n    vec2 initPosition = 2. * ( (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.y );\n    \n    for(int i = 0 ; i < SAMPLE_NUM ; i++){\n        vec2 position = initPosition + 2. * rand2n(fragCoord.xy, float(i)) / iResolution.y;\n        position = position * CANVAS_SCALE;\n        \n        position = compQuot(position - vec2(1. + sin(iTime), 0.4 + cos(iTime)),\n                            compProd(position, position) + position + vec2(1, 0)); \n        //position = compQuot(position - vec2(1., 0.), compProd(position, position) + position + vec2(1, 0)); \n        \n        float absModulus = 2. * log(length(position));\n        float modulusG = mix(1., fract(absModulus), GRAY_SCALE);\n        \n        float arg = atan(position.y, position.x) / TWO_PI;\n        float argG = mix(1., fract(arg * 10.), GRAY_SCALE);\n        sum += hsv2rgb(vec3(arg, 1., argG * modulusG));\n    }\n    fragColor = vec4((sum/float(SAMPLE_NUM)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 130, 130, 419], [421, 421, 443, 443, 618], [1075, 1685, 1742, 1742, 2696]]}
{"id": "XsVczW", "name": "Halley's method convergence", "author": "NinjaKoala", "description": "Use mouse to change parameters, click lower left corner to autoplay.\n", "tags": ["iterative", "root", "halley"], "likes": 0, "viewed": 355, "published": "Public API", "date": "1521227189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nVisualize convergence of Halley's method on the real axis.\nTop row is reference color, lower rows are consecutive halley iterations.\nVertical lines are roots of the derivatives and outer root bounds.\nConvergence basin's of Halley's method seem to be exactly determined by the roots\nof the derivatives.\nNewton's method and also all higher Householder Method's don't share this property.\nComment out in line 562 and following to try other methods.\n*/\n\nconst float eps = .000005;\nconst float pi = 3.1416;\nconst float zoom = 3.5;\nconst float it_num = 30.;\n\nvec3 x_to_col(float x){\n\treturn .5+.5*vec3(sin(x),sin(x+2./3.*pi),sin(x+4./3.*pi));\n}\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tfloat min1=min(roots[0],roots[1]);\n\tfloat min2=min(roots[2],roots[3]);\n\n\tfloat max1=max(roots[0],roots[1]);\n\tfloat max2=max(roots[2],roots[3]);\n\n\tfloat maxmin=max(min1,min2);\n\tfloat minmax=min(max1,max2);\n\n\ttmp[0]=min(min1,min2);\n\ttmp[1]=min(maxmin,minmax);\n\ttmp[2]=max(minmax,maxmin);\n\ttmp[3]=max(max1,max2);\n\n\troots=tmp;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0]=min(roots[0],min(roots[1],roots[2]));\n\ttmp[1]=max(roots[0],min(roots[1],roots[2]));\n\ttmp[2]=max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots2(inout vec2 roots){\n\tvec2 tmp;\n\n\ttmp[0]=min(roots[0],roots[1]);\n\ttmp[1]=max(roots[0],roots[1]);\n\n\troots=tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\nfloat eval_poly4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly3(vec3 coeffs, float x){\n\n\tfloat f = ((x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly2(vec2 coeffs, float x){\n\n\tfloat f = (x + coeffs[1]) * x + coeffs[0];\n\n\treturn f;\n}\n\nfloat eval_poly1(float coeff, float x){\n\n\tfloat f = x + coeff;\n\n\treturn f;\n}\n\nfloat sixth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\tfloat f5 = 120.;\n\n\treturn x - 6.*(120.*f*f1*f1*f1*f1*f1 - 240.*f*f*f1*f1*f1*f2 + 90.*f*f*f*f1*f2*f2 - 10.*f*f*f*f*f1*f4 + f*f*f*f*f*f5 + 20.*(3.*f*f*f*f1*f1 - f*f*f*f*f2)*f3)/(720.*f1*f1*f1*f1*f1*f1 - 1800.*f*f1*f1*f1*f1*f2 + 1080.*f*f*f1*f1*f2*f2 - 90.*f*f*f*f2*f2*f2 + 20.*f*f*f*f*f3*f3 + 12.*f*f*f*f*f1*f5 + 120.*(4.*f*f*f1*f1*f1 - 3.*f*f*f*f1*f2)*f3 - 30.*(3.*f*f*f*f1*f1 - f*f*f*f*f2)*f4);\n}\n\nfloat fifth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\tfloat f5 = 120.;\n\n\treturn x - 5.*(24.*f*f1*f1*f1*f1 - 36.*f*f*f1*f1*f2 + 6.*f*f*f*f2*f2 + 8.*f*f*f*f1*f3 - f*f*f*f*f4)/(120.*f1*f1*f1*f1*f1 - 240.*f*f1*f1*f1*f2 + 90.*f*f*f1*f2*f2 - 10.*f*f*f*f1*f4 + f*f*f*f*f5 + 20.*(3.*f*f*f1*f1 - f*f*f*f2)*f3);\n}\n\nfloat fourth_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\tfloat f4 = 120. * x + 24. * a4;\n\n\treturn x-4.*(6.*f*f1*f1*f1 - 6.*f*f*f1*f2 + f*f*f*f3)/(24.*f1*f1*f1*f1 - 36.*f*f1*f1*f2 + 6.*f*f*f2*f2 + 8.*f*f*f1*f3 - f*f*f*f4);\n}\n\nfloat third_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\n\treturn x-3.*(2.*f*f1*f1 - f*f*f2)/(6.*f1*f1*f1 - 6.*f*f1*f2 + f*f*f3);\n}\n\nfloat laguerre_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\tfloat G=f1/f;\n\tfloat H=G*G-f2/f;\n\tfloat a=5./(G+sign(G)*sqrt(abs(4.*(5.*H-G*G))));\n\n\treturn x - a;\n}\n\nfloat second_irrational_householder_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\tfloat f3 = (60. * x + 24. * a4) * x + 6. * a3;\n\n\tfloat b=(3.*f1*f2-f*f3)/(3.*f2);\n\n\treturn x - 2.*f/(b+sign(b)*sqrt(abs(b*b-4.*((3.*f2*f2-2.*f1*f3)/(f2*6.))*f)));\n}\n\nfloat third_irrational_householder_iteration5(float coeffs[5], float x){\n\n\tfloat f = ((((x + coeffs[4]) * x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = (((5. * x + 4. * coeffs[4]) * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = ((20. * x + 12. * coeffs[4]) * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\tfloat f3 = (60. * x + 24. * coeffs[4]) * x + 6. * coeffs[3];\n\tfloat f4 = 120. * x + 24. * coeffs[4];\n\n\tfloat q1=(f*f4-2.*f2*f3)/(6.*f2*f2-4.*f1*f3);\n\tfloat q2=(3.*f2*f3-4.*f3*f3)/(24.*f1*f3+36.*f2*f2);\n\n\tfloat a=f2/2.+f1*q1+f*q2;\n\tfloat b=f1+f*q1;\n\tfloat c=f;\n\n\treturn x - 2.*f/(b+sign(b)*sqrt(abs(b*b-4.*a*c)));\n}\n\nfloat irrational_halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x-(2.*f)/(f1+sign(f1)*sqrt(abs(f1*f1-2.*f*f2)));\n}\n\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x-(2.*f*f1)/(2.*f1*f1-f*f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat newton_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\n\treturn x-f/f1;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n    \n\treturn 3;\n}\n\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n\n\t\t//s[old_num] = tmp[0];\n\t\t//s[old_num+1] = tmp[1];\n\n\t\tif(old_num == 0){\n            s[0] = tmp[0];\n            s[1] = tmp[1];\n        }\n        else{//old_num == 2\n            s[2] = tmp[0];\n            s[3] = tmp[1];\n        }\n\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n    float border = 2./iResolution.y;\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tmouse *= zoom;\n\n\tfloat a0 = -6. / 89.;\n\tfloat a1 = 158. / 267.;\n\tfloat a2 = 34. / 89.;\n\tfloat a3 = -464. / 267.;\n\tfloat a4 = -65. / 267.;\n\n\tfloat t0 = mod(iTime,6.*pi);\n\n\ta0 += sin(t0)*.3;\n\ta1 += sin(t0*2./3.)*.7;\n    \n    //mouse condition copied from mattz (https://www.shadertoy.com/view/4dyyR1)\n    if(max(iMouse.x, iMouse.y) > 20.){\n        a0=mouse.y;\n        a1=mouse.x;\n    }\n\n\tvec4 c1 = vec4(a1,2.*a2,3.*a3,4.*a4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tfloat val = eval_poly5(a0,a1,a2,a3,a4,uv.x);\n\tfloat drv = eval_poly4(c1,uv.x)*5.;\n\n\t//float val = eval_poly4(c1,uv.x);\n\t//float drv = eval_poly3(c2,uv.x)*4.;\n\n\t//float val = eval_poly3(c2,uv.x);\n\t//float drv = eval_poly2(c3,uv.x)*3.;\n\n\t//float val = eval_poly2(c3,uv.x);\n\t//float drv = eval_poly1(c4,uv.x)*2.;\n\n\tfloat d0 = abs(val-uv.y)/length(vec2(drv,1.));\n\n\td0 = min(d0,abs(uv.y));\n\n\tint num_intervals = 0;\n\n\tvec4 roots_drv=vec4(1e38);\n\n\tfloat ub = upper_bound_lagrange5(a0,a1,a2,a3,a4);\n\tfloat lb = lower_bound_lagrange5(a0,a1,a2,a3,a4);\n\n\td0 = min(d0,abs(uv.x - ub));\n\td0 = min(d0,abs(uv.x - lb));\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfor(int i=0;i<4;i++){\n\t\tif(i < num_roots_drv){\n\t\t\td0 = min(d0,abs(uv.x - roots_drv[i]));\n\t\t}\n\t}\n\tif(num_roots_drv != 4){\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots_snd_drv){\n\t\t\t\td0 = min(d0,abs(uv.x - roots_snd_drv[i]));\n\t\t\t}\n\t\t}\n\t\tif(num_roots_snd_drv != 3){\n\t\t\tvec2 roots_trd_drv = vec2(1e38);\n\t\t\tint num_roots_trd_drv = solve_quadric(c3,roots_trd_drv);\n\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tif(i < num_roots_trd_drv){\n\t\t\t\t\td0 = min(d0,abs(uv.x - roots_trd_drv[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat x = uv.x;\n\n\tfloat j = floor((1.-(uv.y/zoom+.5))*it_num);\n\n\tfor(float i=0.;i<it_num;i+=1.){\n\t\tif(i<j){\n\t\t\t//x = newton_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\tx = halley_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = irrational_halley_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = laguerre_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = second_irrational_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = third_irrational_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = third_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = fourth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = fifth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t\t//x = sixth_householder_iteration5(a0,a1,a2,a3,a4,x);\n\t\t}\n\t}\n\n\tvec3 col = x_to_col(x);\n\n\tfragColor = vec4(mix(vec3(0),col,smoothstep(0., border, d0)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 556, 579, 579, 641], [643, 746, 824, 824, 1417], [1419, 1478, 1556, 1556, 2152], [2154, 2154, 2189, 2189, 2527], [2529, 2529, 2564, 2564, 2729], [2731, 2731, 2766, 2766, 2857], [2859, 2859, 2935, 2935, 3013], [3015, 3015, 3054, 3054, 3149], [3151, 3151, 3190, 3190, 3267], [3269, 3269, 3308, 3308, 3367], [3369, 3369, 3408, 3408, 3445], [3447, 3447, 3541, 3541, 4221], [4223, 4223, 4317, 4317, 4850], [4852, 4852, 4947, 4947, 5364], [5366, 5366, 5460, 5460, 5784], [5786, 5786, 5871, 5871, 6175], [6177, 6177, 6283, 6283, 6650], [6652, 6652, 6724, 6724, 7325], [7327, 7327, 7421, 7421, 7682], [7684, 7684, 7767, 7767, 8008], [8010, 8010, 8056, 8056, 8332], [8334, 8334, 8417, 8417, 8573], [8575, 8696, 8745, 8783, 8996], [8998, 8998, 9041, 9041, 10060], [10062, 10062, 10107, 10107, 12074], [12076, 12076, 12130, 12130, 14943]]}
{"id": "XsVyDw", "name": "colors and symmetry", "author": "DJDoomz", "description": "///////////////", "tags": ["2d"], "likes": 11, "viewed": 4296, "published": "Public API", "date": "1522257468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    uv = vec2(length(uv)*(8.+2.*sin(iTime*.1)), sin(atan(uv.x,uv.y)*floor(5.+mod(iTime*.2,6.)) + iTime*.3) );\n    \n    vec3 col = vec3(0);\n    \n    uv+=sin(uv.yx*(sin(iTime*.3)*2.)+iTime*.6*vec2(1,.9));\n    \n    col += 1.-smoothstep(0.1,.2, length(uv-vec2(uv.x,0)));\n    col += 1.-smoothstep(0.2,.3, length(uv-vec2(floor(uv.x+.5),uv.y)));\n\n    col *= .5+.5*cos(6.28*vec3(0,.33,.66)+uv.y+iTime + col*2. );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 638]]}
{"id": "XsVyRh", "name": "Popping  Isocubes", "author": "duvengar", "description": "Originally Inspired by this [url=https://assets.catawiki.nl/assets/2017/11/10/d/4/5/d45245d2-c5f8-11e7-8f41-64eeb6a38205.jpg]Vasarely artwork[/url] and 100% based on @Shane's [url=https://www.shadertoy.com/view/Xljczw]Minimal Hexagonal Grid[/url] \n\n", "tags": ["2d", "hexagon", "tiling", "spherize"], "likes": 30, "viewed": 413, "published": "Public", "date": "1521044868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Popping isocubes by @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n///////////////////////////////////////////////////////////////////////////////////////////\n// I've finaly found some time to play with the Minimal Hexagonal Grid example from @Shane.\n// https://www.shadertoy.com/view/Xljczw\n\n\n#define M(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define SAT(a) clamp(.0, .1, a)\n#define T iTime\n#define PI acos(-1.)\n#define TWO_PI (PI * 2.)\n\nconst float LOWRES = 100.;\n\nfloat hash2(vec2 p)\n{\n    // hash2 taken from Dave Hoskins \n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rem(vec2 iR)\n{\n    float slices = 17. * floor(iR.y / LOWRES);\n  \n    return  sqrt(slices);\n}\n\n// taken from:\n// Minimal Hexagonal Grid - Shane\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Helper vector.\n// 30-60-90 triangle, which has sides of 1, sqrt(3) and 2.\n\nconst vec2 s = vec2(1, 1.7320508);\n\n// The 2D hexagonal isosuface function\nfloat hex(in vec2 p)\n{\n    \n    p = abs(p);\n    return max(dot(p, s *.5), p.x ); // Hexagon.\n    \n    //equivalent to:\n    //return max(p.x *.5 + p.y *.866025, p.x); \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n\nvec4 getHex(vec2 p)\n{  \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1)) / s.xyxy) + .5;\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point. Note that a random constant has been added to \n    // \"hC.zw\" to further distinguish it from \"hC.xy.\"\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + vec2(.5, 1));\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // store global sound amplitude\n    \n    \n    // Normalized domains\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv2 = ( fragCoord.xy -.5  / iResolution.xy) / iResolution.y;\n    \n    // initialize some variables\n    float motion = 325.543 + T * .5;\t\t   // a speed\n    vec3 col = vec3(.7, .66, 1.55) + .1;       // a weird base color\n    float blr = .002;\t\t\t\t           // a blur value\n \t// scale and twist and rotate the domain\n    uv *= M(.4 * cos(PI) * 1.5 * length(uv));\n    uv *= 1.35;\n   \tuv *= M(PI);\n    // spherize\n    if(length(uv) < 1.)\n    {    \n        float d = mix(1.,1. + ( 1. - dot(uv, uv)),  1.); \n        blr = blr * d; \n   \t\tuv = uv / d;   \n    }\n\t// get a screen scaling ratio (for the stripe pattern scaling along resolutions);\n    float dens = rem(iResolution.xy) ;\n\n    // Finally make some the Hexagons\n    vec2 pos = vec2(.0,.0);\n    pos  -= motion + .1 * iMouse.xy / 10.;  // add motion and mouse interaction\n    vec4 h = getHex( pos + 5. * uv + s.yx); // hexagons center\n    float eDist = hex(h.xy);                // hexagone Edge distance.\n    \n\t//float cDist = length(h.xy);           // @Shane: cDist = dot(h.xy, h.xy);\n    \n    \n    float tilt  = hash2(h.zw*2376.345791);  // random value depending on cel ids\n    // float yoyo = .0;\t\t\t\t        // animation factor to rescale \n    \t\t\t\t\t\t\t\t\t\n    // rotate hexa tiles depending on their unique random number\n    // and animate the unique hexagon radius at the same time;\n    // initialize color, flip et texture attribute.\n    \n    float red, flip, tex = .0;\n \n    // vertical stripes pattern\n    /////////////////////////////////////////////////////////////////////////////////\n    //vec2 pat =   h.xy + motion;\n   \n    vec2 pat = h.xy;\n\t// hashed pattern with diferent angle;\n    // vertical one\n    float p2 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    // two obliques\n    pat *= M(PI*.33);\n    float p3 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    pat *= M(PI*.33);\n    float p4 = .08*smoothstep(.2, .1-blr,  length(fract(pat.x * dens * 1.75)-.5));\n    \n    // sorting the cubes\n    ///////////////////////////////////////////////////////////////////////////////////\n\n   \n    // wich tile are flipped?\n    if( cos(5.* motion * sin(h.z - h.w)*tilt) > .0)\n    {\n       flip = 1.;\n       h.xy *= M(PI);   \n    } \n    // wich tile are orange?\n    \n    if(tilt > .7 && flip != .0){\n        red = 1.;\n    }\n  \n    \n    // get polar coordinates in order cut the 3 faces form the hagagon\n    // in order to create the cubes/(Rhombic effect) inside the tiling.\n    vec2 pol  = vec2(atan(h.x, h.y) / TWO_PI + .5, length(uv));\n    vec2 ang = vec2(.3333, .6666);\n    \n    //////////////////////////////////////////////////////////////////\n\n    // Paint orange or gray cube\n        \n    if(red == 1. && flip != .0)\n    {\n        col += vec3(.7,-.1,-.35);\n        col -= .1 * smoothstep(.45,.45-blr, eDist);\n        tex = 1.;\n        \n    } else \n    {\n        col -= .3;     \n    }\n    \n\n    // shading the cubes faces\n    // face 01 (left)\n    if(pol.x <=  ang.x)\n    {\n    \tcol -= .2; \n        col += tex == 1. ? .0 : p2;\n    }\n    // face 02 (right)\n    if(pol.x >= ang.y)\n    {    \n        col -= .375;\n        col += tex == 1. ? .0 : p2;\n    }\n    // face 03 (top)\n    if(pol.x > ang.x && pol.x < ang.y)\n    {\n     col += tex == 1. ? .0 : .25 * (p4+p3);\n    }\n     \n    // face 04 (inside)\n    vec2 ang2 = ang + vec2(-.1665,.1665);\n    if(pol.x  <= ang2.x  || pol.x >= ang2.y ){\n        \n        col += red == 1. && flip == 1. ? .075 : .0; // only for red cubes\n    }\n    \n    // Edges\n    \n    // drawing some tiny dark lines along the inner cubes edges and\n    // simulate three partialy visible cubes.\n    // and drawing the same three lines for the outer cubes to make their edges shinier\n    if( flip == .0){\n       col -= h.y < .0 ? .3 * smoothstep(.02,.0,length(h.x)) : .0; \n       vec2 hr = M(PI*.333) * h.xy;\n       col -= h.y > .0 ? .3 * smoothstep(.02,.0,length(hr.x)) : .0; \n       hr = M(PI*.666) * h.xy;\n       col -= h.y > .0 ? .3 * smoothstep(.02,.0,length(hr.x)) : .0; \n       \n    } else if( red == 1. && flip == 1. ){\n       col += h.y < .0 ? .3 * smoothstep(.015,.0,length(h.x)) : .0; \n       vec2 hr = M(PI*.333) * h.xy;\n       col += h.y > .0 ? .3 * smoothstep(.015,.0,length(hr.x)) : .0; \n       hr = M(PI*.666) * h.xy;\n       col += h.y > .0 ? .3 * smoothstep(.015,.0,length(hr.x)) : .0; \n        \n    }\n    \n    \n    \n    \n    // postprocessing\n  \n    col -= .2 * smoothstep(.49,.5,length(eDist));               // draw a light outline on hexagons\n    if( flip == 1. && red == .0){\n    col -= .2 * smoothstep(.48,.5,length(eDist)); \n    }\n    vec3 fao = vec3((smoothstep(.0,2.,eDist)));                  // Fake lightning gradient \n    col -= flip > .0 ?  fao+.25 :  .5 - fao;                     // apply it as a shadow or light on the cubes\n    col -= flip > .0 ? .05*smoothstep(.0,.5,length(eDist)) : .0;  \n    col -= vec3(-.7, -.85, .0) + smoothstep(.0,4.0,length(uv));  // color correction gradualy from the center \n    col *= 1. - .1 * length(dot(uv,uv));                         // vigneting \n    col  = pow(col, vec3(1.5));                                  // gamma \n\n    // color output\n    //col -= vec3(p2+p3+p4);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyRh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 526, 547, 630, 747], [749, 749, 769, 769, 847], [1113, 1152, 1174, 1174, 1320], [1322, 1548, 1569, 1946, 2764], [2765, 2864, 2921, 2993, 8272]]}
{"id": "XsVyz1", "name": "Paternoster", "author": "dr2", "description": "The paternoster is a continuous elevator - fun to ride but hazardous", "tags": ["architecture", "android", "elevator"], "likes": 15, "viewed": 1536, "published": "Public API", "date": "1521047088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Paternoster\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat dstFar, tCur, flHt, spd, rAngA;\nint idObj;\nconst int idFlCl = 1, idFrm = 2, idPat = 3, idLt = 4, idWl = 5, idRob = 6, idEye = 7;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat RobDf (vec3 p, float dMin, float szFac)\n{\n  vec3 q;\n  float d;\n  p /= szFac;\n  dMin /= szFac;\n  p.xz = - p.xz;\n  q = p;  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p;  q.y -= 1.55;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = p;  q.x = abs (q.x) - 0.3;  q.y -= 3.1;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;  q.x = abs (q.x) - 1.05;  q.y -= 2.1;\n  q.yz = Rot2D (q.yz, rAngA);\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;  q.x = abs (q.x) - 0.4;  q.y -= 0.475;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.55));\n  DMIN (idRob);\n  q = p;  q.x = abs (q.x) - 0.4;  q.yz -= vec2 (2.7, 0.7);\n  d = PrSphDf (q, 0.15);\n  DMIN (idEye);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, sy;\n  dMin = dstFar;\n  sy = p.y - sign (p.x) * (spd + 32. * flHt) + flHt;\n  q = p;  q.y = mod (q.y - 0.2, 2. * flHt) - flHt;\n  d = PrBoxDf (q, vec3 (20., 0.3, 5.));\n  q.x = abs (q.x) - 0.8;\n  d = max (d, - PrBox2Df (q.xz, vec2 (0.41, 0.51)));\n  DMIN (idFlCl);\n  q = p;  q.z = abs (q.z) - 5.;\n  d = max (abs (q.z) - 0.1, 0.);\n  DMIN (idWl);\n  qq = p;  qq.y = mod (qq.y + flHt, 2. * flHt) - flHt;\n  q = qq;  q.x = abs (abs (q.x) - 0.8) - 0.44;  q.z -= -0.5;\n  d = PrCylDf (q.xzy, 0.04, flHt);\n  DMIN (idFrm);\n  q = qq;  q.x = abs (q.x) - 0.8;  q.yz -= vec2 (1.1, -0.5);\n  d = max (PrCylDf (q.yzx, 0.04, 0.42), q.z);\n  DMIN (idFrm);\n  q = qq;  q.x = abs (q.x) - 0.8;  q.y -= 1.3;\n  d = PrBoxDf (q - vec3 (0., 0., -0.51), vec3 (0.42, 0.2, 0.01));\n  DMIN (idFrm);\n  q = qq;  q.x = mod (q.x, 2.) - 1.;  q.y -= 1.4;  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.xzy, 0.2, 0.05);\n  DMIN (idLt);\n  q = qq;\n  d = PrBoxDf (q, vec3 (2., flHt, 0.5));\n  qq = p;  qq.x = abs (qq.x) - 0.8;  qq.y = mod (sy, 2. * flHt) - flHt;\n  q = qq;\n  d = max (d, - PrBoxDf (q + vec3 (0., 0., 0.02), vec3 (0.4, 1., 0.5)));\n  DMIN (idPat);\n  q = qq;  q.y -= 0.97;\n  d = PrCylDf (q.xzy, 0.15, 0.03);\n  DMIN (idLt);\n  if (Hashff (77.7 * floor (sy / (2. * flHt))) > 0.2) {\n    q = qq;  q.y -= -0.97;\n    dMin = RobDf (q, dMin, 0.15 + 0.15 * Hashff (37.7 * floor (sy / (2. * flHt))));\n  }\n  dMin = max (dMin, max (abs (p.y) - 3. * flHt, abs (p.x) - 20.));\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.7 + 0.3 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.03, 0.06, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltPos[3], rg;\n  vec2 vf;\n  float dstObj, spec, wdPos, s, h, dfSum, spSum, at, ao;\n  ltPos[0] = vec3 (1.5, 1., -2.);\n  ltPos[1] = vec3 (-1.5, 1., -2.);\n  ltPos[2] = vec3 (0., 1., 2.);\n  flHt = 1.5;\n  spd = 0.3 * tCur;\n  rAngA = 2. * pi * (0.5 - abs (mod (0.3 * tCur, 1.) - 0.5));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == idPat) {\n    vec3 ror;\n    ror = ro + dstObj * rd;\n    vn = ObjNf (ror);\n    if (vn.z < 0. && abs (abs (ror.x) - 0.8) < 0.3 && \n       abs (mod (ror.y - sign (ror.x) * spd + flHt, 2. * flHt) - flHt - 0.2) < 0.6) {\n      ro = ror;\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlCl) {\n      if (abs (vn.y) < 0.001) col4 = vec4 (0.2, 0.2, 0.2, 0.);\n      else if (abs (ro.z + 0.5) < 0.1 && vn.y > 0.001 && abs (abs (ro.x) - 0.8) < 0.4)\n         col4 = vec4 (0.8, 0.8, 0.85, -1.);\n      else {\n        s = length (vec2 (mod (ro.x, 2.) - 1., abs (ro.z) - 2.));\n        if (vn.y > 0.001) col4 = mix (vec4 (0.3, 0.2, 0.1, -1.), vec4 (0.27, 0.15, 0., -1.),\n           smoothstep (0.4, 0.5, Fbm2 (vec2 (2., 16.) * ro.xz))) * (1. - 0.2 *\n           SmoothBump (0.03, 0.07, 0.01, mod (2. * ro.z, 1.))) * (1. - 0.2 * smoothstep (0.4, 1., s));\n        else col4 = vec4 (0.3, 0.3, 0.25, -1.) * (1. - 0.1 * smoothstep (0.4, 0.9, s));\n      }\n    } else if (idObj == idWl) {\n      s = mod (ro.x + 2., 4.) - 2.;\n      if (abs (s) < 0.4 && ro.y < 0.8) {\n        if (abs (s) < 0.35 && abs (ro.y - 0.4) < 0.15) col4 = vec4 (0.8, 0.6, 0.2, -1.) *\n           (1. - 0.1 * SmoothBump (0.3, 0.7, 0.1, mod (32. * length (vec2 (0.5 * s, ro.y - 0.4)), 1.)));\n        else if (length (vec2 (s, ro.y) - vec2 (0.28, -0.2)) < 0.06) col4 = vec4 (0.3, 0.1, 0., 0.1);\n        else col4 = vec4 (0.4, 0.2, 0., 0.1);\n      } else if (ro.z < 0. && (step (abs (abs (abs (ro.x) - 1.2) - 0.1), 0.03) *\n         step (abs (ro.y - 0.3), 0.2) > 0. || abs (length (vec2 (abs (ro.x) - 1.2, ro.y - 0.3)) -\n         0.35) < 0.03)) {\n        col4 = vec4 (1., 0.4, 0., 0.2);\n      } else {\n        col4 = vec4 (0.5, 0.6, 0.4, 0.2);\n        rg = ShStagGrid (ro.xy, (3./1.2) * vec2 (1., 2.));\n        col4 *= rg.y;\n        rg.xz *= sign (vn.z);\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n    } else if (idObj == idFrm) {\n      if (vn.z < 0. && abs (abs (ro.x) - 0.8) < 0.4 &&\n         abs (mod (ro.y + flHt, 2. * flHt) - flHt) > 1.13) {\n        col4 = vec4 (0.8, 0.8, 0.9, 0.3);\n        vn.yz = Rot2D (vn.yz, -0.1 * pi * (1. + sin (2. * pi * mod (32. * ro.y, 1.))));\n      } else {\n        col4 = vec4 (0.5, 0.3, 0., 0.3);\n      }\n    } else if (idObj == idPat) {\n      wdPos = -99.;\n      s = mod (ro.y - sign (ro.x) * spd + flHt, 2. * flHt) - flHt;\n      h = 17.1 * Hashff (33.3 * floor ((ro.y - sign (ro.x) *\n         (spd + 32. * flHt) + flHt) / (2. * flHt)));\n      if (abs (abs (ro.x) - 0.8) > 0.4 || ro.z > 0.5) {\n        if (abs (ro.y) < 0.01) {\n          col4 = vec4 (0.8, 0.8, 0.8, 0.3);\n          if (vn.z < 0.) vn.yz = Rot2D (vn.yz, 0.1 * pi * (1. + sin (8. * pi * ro.y)));\n        } else if (ro.y > 0.) {\n          col4 = vec4 (0.7, 0.5, 0.2, 0.1);\n          if (step (abs (abs (ro.x) - 0.04), 0.02) * step (abs (ro.y - 0.7), 0.1) > 0. ||\n             abs (length (vec2 (ro.x, ro.y - 0.7)) - 0.15) < 0.02) col4 *= 0.5;\n          else vf = vec2 (32, 0.5);\n        } else {\n          col4 = vec4 (0.2, 0.4, 0.3, 0.1) * (1. - 0.1 * Noisefv2 (64. * ((abs (vn.x) > 0.1) ?\n             ro.yz : ro.yx)));\n        }\n      } else if (abs (vn.y) > 0.9) {\n        if (vn.y > 0.) {\n          col4 = vec4 (0., 0.3, 0., 0.);\n          vf = vec2 (64., 0.5);\n        } else {\n          col4 = vec4 (0.7, 0.7, 0.75, -1.) * (1. - 0.2 * smoothstep (0.2, 0.4,\n             length (vec2 (abs (ro.x) - 0.8, ro.z))));\n        }\n      } else if (abs (vn.x) > 0.01) {\n        wdPos = ro.z;\n      } else if (ro.z < 0.) {\n        if (abs (s) > flHt - 0.46) {\n          col4 = vec4 (0.6, 0.3, 0.2, 0.1);\n          vn.xz = Rot2D (vn.xz, 0.1 * pi * (1. + sin (2. * pi * mod (32. * ro.x, 1.))));\n        } else col4 = mix (vec4 (1., 0., 0., 0.1), vec4 (0.1, 0., 0., 0.1),\n           step (0.6, mod (16. * (abs (ro.x) - 0.8), 1.)));\n      } else if (ro.z < 0.5) {\n        wdPos = ro.x;\n      }\n      if (wdPos != -99.) col4 = mix (vec4 (0.4, 0.1, 0., 0.1), vec4 (0.3, 0.1, 0., 0.1),\n         smoothstep (0.4, 0.5, Fbm2 (h + 2. * vec2 (16., 4.) * vec2 (wdPos, s))));\n    } else if (idObj == idLt) {\n      col4 = vec4 (0.9, 0.9, 0.5, -2.);\n    } else if (idObj == idRob) {\n      col4 = vec4 (HsvToRgb (vec3 (Hashff (33.3 * floor ((ro.y - sign (ro.x) *\n         (spd + 32. * flHt) + flHt) / (2. * flHt))), 0.8, 0.8)), 0.2);\n    } else if (idObj == idEye) {\n      col4 = mix (vec4 (0., 1., 0., -2.), vec4 (0.7, 0., 0.3, -2.),\n         smoothstep (0.9, 0.95, - dot (vn, rd)));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      ao = ObjAO (ro, vn);\n      dfSum = 0.;\n      spSum = 0.;\n      for (int k = 0; k < 3; k ++) {\n        ltDir = normalize (ltPos[k]);\n        at = smoothstep (0.3, 0.5, dot (normalize (ltPos[k] - ro), ltDir));\n        dfSum += at * max (dot (vn, ltDir), 0.);\n        spSum += at * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n      }\n      col = ao * (col * (0.1 + 0.4 * dfSum) + col4.a * step (dot (vn, rd), -0.05) * spSum);\n    } else if (col4.a == -2.) col *= 0.7 - 0.3 * dot (vn, rd);\n  } else col = vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  float az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  if (mPtr.z > 0.) az -= 0.4 * pi * mPtr.x;\n  az = clamp (az + 0.5 * pi, - 0.15 * pi, 0.15 * pi) - 0.5 * pi;\n  ro = vec3 (4.8 * cos (az), 0.4, 4.8 * sin (az));\n  vd = normalize (vec3 (0., 0.2, 0.) - ro);\n  ro.x += 0.8 * SmoothBump (0.25, 0.75, 0.1, mod (0.1 * tCur, 1.)) *\n     (2. *  floor (mod (0.1 * tCur, 2.)) - 1.);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.7));\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVyz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 758, 805, 805, 1562], [1564, 1564, 1586, 1586, 3049], [3051, 3051, 3084, 3084, 3261], [3263, 3263, 3284, 3284, 3484], [3486, 3486, 3518, 3518, 3716], [3718, 3718, 3752, 3752, 4108], [4110, 4110, 4145, 4145, 9805], [9807, 9807, 9863, 9863, 10710], [10712, 10712, 10744, 10744, 10844], [10846, 10846, 10879, 10879, 10968], [10970, 10970, 11003, 11003, 11030], [11032, 11032, 11074, 11074, 11125], [11127, 11127, 11184, 11184, 11348], [11350, 11350, 11407, 11407, 11490], [11492, 11492, 11522, 11522, 11580], [11582, 11582, 11606, 11606, 11742], [11776, 11776, 11800, 11800, 11837], [11839, 11839, 11863, 11863, 11993], [11995, 11995, 12020, 12020, 12206], [12208, 12208, 12229, 12229, 12384], [12386, 12386, 12415, 12415, 12627], [12629, 12629, 12668, 12668, 12848]]}
{"id": "XsycRw", "name": "hello world", "author": "krshock", "description": "Hello world shadertoy!", "tags": ["2d", "helloworld"], "likes": 1, "viewed": 361, "published": "Public API", "date": "1521350735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//krshock 2018\nfloat clr(vec2 uv, float uno, float dos){\n    vec2 c = vec2(0,0);\n    return cos(distance(c, uv)*uno) * cos(dos*(uv.x*uv.y));\n}\n\n\nvec3 cmap(float val, vec3 c1, vec3 c2, float f1, float f2){\n    if(val>f1)\n        return c1;\n    if(val>f2)\n        return c2;\n    return vec3(0.1,0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy + vec2(-.5, -.5);\n    uv.y *= iResolution.y/iResolution.x;\n    uv.xy *= 1.0;\n    float t = iTime*.1;\n    float w1 = sin(1.0+t)*+cos(1.5+t*3.5);           //wave 1\n    float w2 = 1.0+sin(2.0+t*5.0)+cos(4.0+t*7.0)*.5; //wave 2\n\tfloat uno=100.0+w1*50.0;    //\n    float dos = 200.0+100.0*w2;\n    float value = sin(t+cos(t))*.2+clr(uv, uno,dos);\n\tvec3 col = 0.8-cmap(value*value, vec3(.0,.0,.0), vec3(.7,.08,.08), .7,.4)*value;\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsycRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 56, 56, 142], [145, 145, 204, 204, 304], [306, 306, 363, 363, 860]]}
{"id": "Xsyczh", "name": "One-Pass Voronoi", "author": "dr2", "description": "Free isolines for Shane - based on an earlier Voronoi demo", "tags": ["voronoi"], "likes": 17, "viewed": 3117, "published": "Public API", "date": "1520937364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"One-Pass Voronoi\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\n\nfloat tCur;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec3 ShowScene (vec2 p)\n{\n  vec4 vc, col4;\n  vec3 col, ltDir, vn;\n  ltDir = normalize (vec3 (0., 1., 0.7));\n  ltDir.xz = Rot2D (ltDir.xz, -0.2 * tCur);\n  HexVorInit ();\n  vc = HexVor (p - 0.2 * tCur);\n  vc.yz *= smoothstep (0.1, 0.15, vc.x);\n  vn = normalize (vec3 (vc.y, 0.6, vc.z));\n  col4 = vec4 (HsvToRgb (vec3 (mod (0.1 * tCur + atan (vn.z, - vn.x) / (2. * pi), 1.), 0.9, 1.)), 0.2);\n  col4 = mix (vec4 (0.3, 0.5, 0.3, 0.5), col4, smoothstep (0.1, 0.2, vc.x));\n  col4 *= 0.6 + 0.4 * mix (SmoothBump (0.25, 0.75, 0.05, mod (12. * vc.x, 1.)),\n     SmoothBump (0.25, 0.75, 0.05, mod (2. * vc.x / (1. - 0.8 * vn.y), 1.)), smoothstep (0.1, 0.2, vc.x));\n  col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n     col4.a * pow (max (dot (normalize (ltDir + vn), vn), 0.), 32.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, p;\n  float pSize;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 20.;\n  pSize = canvas.x / 200.;\n  p = pSize * uv;\n  fragColor = vec4 (ShowScene (p), 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.65;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 0.5 * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.2) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsyczh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 477, 502, 502, 1275], [1277, 1277, 1330, 1330, 1595], [1597, 1597, 1621, 1621, 1851], [1853, 1853, 1877, 1877, 1937], [1963, 1963, 1983, 1983, 2203], [2205, 2205, 2227, 2227, 2832], [2834, 2834, 2858, 2858, 2994], [2996, 2996, 3041, 3041, 3144], [3146, 3146, 3203, 3203, 3286], [3288, 3288, 3318, 3318, 3376], [3410, 3410, 3434, 3434, 3494], [3496, 3496, 3520, 3520, 3650]]}
{"id": "XsyyDD", "name": "rainbow noise 2", "author": "FabriceNeyret2", "description": "Perlin noise type is controlled by MOD: auto-change between unsigned, signed, abs(), 1.-abs\nTry uncomment one of the intensity scheme", "tags": ["noise", "perlin", "rainbow", "hue"], "likes": 19, "viewed": 2080, "published": "Public API", "date": "1521970715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired from \"rainbow noise\" by violetforest. https://shadertoy.com/view/4dyyDW\n\n#define MOD int(mod(iTime/3.,4.))\n\n#define hash(p) fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123)\n\nfloat noise (vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix( mix(hash(i+vec3(0,0,0)),hash(i+vec3(1,0,0)),f.x),\n                       mix(hash(i+vec3(0,1,0)),hash(i+vec3(1,1,0)),f.x), f.y), \n                  mix( mix(hash(i+vec3(0,0,1)),hash(i+vec3(1,0,1)),f.x),\n                       mix(hash(i+vec3(0,1,1)),hash(i+vec3(1,1,1)),f.x), f.y), f.z);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat fbm (vec3 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37 + iTime/1e4);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p.xy *= R, p.yz *= R,\n        v += a * noise(p);\n\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.y;\n    O = .5+ .55* cos( 9.*fbm(vec3(U,iTime/3.))+ vec4(0,23,21,0)); // hue\n  //O *= abs(fract(3.*fbm(vec3(U,iTime/3.)+.5))*2.-1.);           // intensity\n  //O *= abs(fract(3.*fbm(vec3(U,iTime/3.)))*2.-1.);              // intensity\n  //O *= .5+fbm(vec3(U,iTime/3.)+.5);                             // intensity\n    if ( length(U*4.-vec2(.1,.2*float(MOD+1)))<.1 ) O--;          // MOD\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 194, 216, 216, 731], [784, 784, 804, 804, 987], [989, 989, 1027, 1027, 1436]]}
