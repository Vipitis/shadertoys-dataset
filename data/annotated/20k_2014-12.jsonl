{"id": "4lf3RH", "name": "Meta Experiment 3", "author": "aiekick", "description": "Two metaholes with one texture. \nYou can try another texture. may be funny !", "tags": ["experiment", "meta", "hole", "metahole"], "likes": 2, "viewed": 1170, "published": "Public API", "date": "1418318534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 getPos(vec2 p){\n    float ratio = iResolution.x/iResolution.y;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.);//centering -1->0->1 x & y\n}\nfloat metahole(vec2 p, vec2 o, float radius, float thick){\n    vec2 po = p-o;\n\treturn thick / dot(po+radius, po-radius);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = getPos(fragCoord.xy);\n    float t = sin(iTime*0.3);\n    vec3 tex = texture(iChannel0, uv).xyz;\n    float h1 = metahole(uv, vec2(t,0.), 0.5, 0.4);\n\tfloat h2 = metahole(uv, vec2(-t,0.), 0.6, -0.2);\n\tfloat o = h1+h2;\n\tfragColor.rgb = smoothstep(tex, vec3(o), vec3(t)); ;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3RH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 137, 157, 157, 285], [286, 286, 344, 344, 408], [409, 409, 465, 465, 749]], "test": "untested"}
{"id": "4lfGRH", "name": "Multi-Sphere Raytrace", "author": "Steel_Neuron", "description": "Nothing spectacular really, just learning the basics of ray tracing! I wanted to do a variable number of spinning spheres. I'm a bit confused because modifying ro at line 33 doesn't make the camera go back as I'd expect. What am I misunderstanding there? ", "tags": ["test", "raytracer", "basic", "learning"], "likes": 2, "viewed": 234, "published": "Public", "date": "1418303199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793238\n#define SPHERES 4.0\n#define SPHERE_SHINE 30.0\n\nfloat iSphere (vec3 ro, vec3 rd, vec3 c, float r, out float t){\n\n    float B = 2.0* dot(ro - c,rd);\n    float C = pow(length(ro -c),2.0) -pow(r,2.0);\n    float d = pow(B,2.0) - 4.0*C;\n    if (d < 0.0){\n    \treturn -1.0;\n    }\n    \n    t = (-B - sqrt(d))/2.0;    \n    return 1.0;\n\t\n}\n\nvec3 nSphere(vec3 pos, vec3 c){\n\n    return normalize(pos-c);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n    float ar = iResolution.x / iResolution.y;\n    vec2 r =  vec2(uv.x * ar,uv.y);\n    \n    vec3 ro = vec3(0.0,0.0,3.0);\n\tvec3 rd = normalize(vec3(r.xy,-3.0));\n\n    \n    vec3 l_1pos = vec3(0.0,sin(iTime),0.0);\n    float l_1kd = 0.6;\n    float l_1ks = 0.3;\n    \n    vec3 l_2pos = vec3(2.0*ar*sin(iTime*1.523),0.0,2.0*ar*cos(iTime*1.523));\n    float l_2kd = 0.6;\n    float l_2ks = 0.3;\n    \n    float ka = 0.02;\n    \n    float shading1 = 0.0;\n    float shading2 = 0.0;\n    float t = -1.0;\n    float t_temp = -1.0;\n\n    for (float i = 0.0;i<SPHERES;i+=1.0){\n        vec3 s_c = vec3((ar/2.0)*cos(iTime+i*2.0*PI/SPHERES),\n                        0.0,(ar/2.0)*sin(iTime+i*2.0*PI/SPHERES));\n        float s_r = 0.3 + 0.1*i;\n        \n        if ((iSphere(ro,rd,s_c,s_r,t_temp) > 0.5) &&\n        (((t_temp < t) && (t_temp > 0.0)) || (t < 0.0))){\n        \tt = t_temp;\n        \tvec3 pos = ro + t*rd;\n            vec3 Lm = normalize(l_1pos-pos);\n            vec3 N = nSphere(pos,s_c);\n            vec3 Rm = 2.0*dot(Lm,N)*N - Lm;\n            vec3 Lm_2 = normalize(l_2pos-pos);\n\t\t\tvec3 Rm_2 = 2.0*dot(Lm_2,N)*N - Lm_2;\n\n        \tshading1 = ka + max(0.0,l_1kd*dot(Lm,N)) + max(0.0,l_1ks *pow(dot(Rm,-rd),SPHERE_SHINE));\n            shading2 = l_2kd*dot(Lm_2,N) + max(0.0,l_2ks *pow(dot(Rm_2,-rd),SPHERE_SHINE));\n            \n    \t\t}\n    \n        }\n    \n\n    \n    vec3 col = vec3(shading1,shading2,0.0);\n    \n\tfragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 142, 142, 361], [363, 363, 394, 394, 431], [435, 435, 492, 492, 1974]], "test": "untested"}
{"id": "4lsGR4", "name": "time", "author": "mbanquiero", "description": "test distance field\nBased on IÃ±igo quilez distance field articles\nhttps://www.shadertoy.com/view/Xds3zN", "tags": ["timepinkfloyd"], "likes": 1, "viewed": 134, "published": "Public", "date": "1419220928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n#define DISTMARCH_STEPS 60\n#define DISTMARCH_MAXDIST 400.\n#define REP_XZ 45.\n#define REP_Y 25.\n#define CLOCK_R 15.\n#define CLOCK_H 1.\n\n// Based on IÃ±igo Quilez articles:\n// https://www.shadertoy.com/view/Xds3zN\n\nconst float fov = PI / 4.0;\nvec3 LigthPos = vec3(0.0,0.0,0.0);\n    \nfloat clock( vec3 p, float r, float h )\n{\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat map( vec3 pos)\n{\n    pos.y += REP_Y;\n\tvec3 c = vec3(REP_XZ);\n    vec3 p = mod(pos,c)-0.5*c;    \n    pos.xz = p.xz;\n    float da = clock(pos,CLOCK_R,CLOCK_H);\n    pos.y -= REP_Y*2.0;\n    float db = clock(pos,CLOCK_R,CLOCK_H);\n    \n    return min(da,db);\n}\n\nfloat distmarch( vec3 ro, vec3 rd)\n{   \n    float dist = 10. * SMALL_FLOAT;\n    float t = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < SMALL_FLOAT || t > DISTMARCH_MAXDIST ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        dist = map( ro + t * rd);\n    }\n\n    return t;\n}\n\nvec3 texture2d( in vec3 pos )\n{\n    //return vec3(1.0);\n    \n\tvec3 c = vec3(REP_XZ);\n    vec3 p = mod(pos,c)-0.5*c;    \n    pos.xz = p.xz;\n    \n    \n    float len = length(pos.xz);\n    if(len<1.0)\n        return vec3(0.0);\n    \n    if(len>CLOCK_R-1.0)\n        return vec3(0.7,0.7,0.2);\n        \n    \n    float ep = 0.05;\n    float alfa =atan(pos.z,pos.x);\n    float an = abs(alfa);\n    if((abs(an)<ep || abs(an-PI)<ep || abs(an-PI/2.0)<ep || abs(an-PI/4.0)<ep\n       || abs(an-3.0*PI/4.0)<ep )\n       && len>CLOCK_R-5.0)\n        return vec3(0.2,0.2,0.6);\n\n    float min = mod(iTime*15.0,2.0*PI) - PI;\n    if(abs(alfa-min)<ep)\n        return vec3(0.0);\n    \n    if(len<4.0)\n    {\n    \tfloat hour = mod(iTime*3.0,2.0*PI) - PI;\n        if(abs(alfa-hour)<ep)\n            return vec3(0.0);\n    \n    }\n       \n\n    \n    \n    return vec3(0.5 + len / CLOCK_R);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat x = 2.0*uv.x-1.0;\n    float y = 2.0*uv.y-1.0;\n\tfloat time = iTime*2.5;\n    \n    \n \tvec3 vLookFrom = vec3(30.0*time,2.0,21.0);\n \tvec3 vLookAt = vec3(30.0*time+10.0,0.0,21.0);\n\tvec3 LigthPos = vec3(30.0*time,0.0,12.0);\n    \n    vec3 N = normalize(vLookAt-vLookFrom);\n    vec3 V = normalize(cross( N , vec3(0.0,1.0,0.0)));\n    vec3 U = cross(V , N);\n    float k = 2.0*tan(fov/2.0);\n\tvec3 Dy = U*(k*iResolution.y/iResolution.x);\n\tvec3 Dx = V*k;\n\t// direccion de cada rayo\n\tvec3 D = normalize(N + Dx*x + Dy*y);\n    \n\tfloat dist = distmarch( vLookFrom,D);\n    vec3 rgb;\n    if(dist < DISTMARCH_MAXDIST)\n    {\n        // computo n dot l \n        vec3 Ip = vLookFrom + D*dist;\n        vec3 Ld = normalize(LigthPos - Ip);\n        vec3 Normal = calcNormal(Ip);\n        float Kd = 0.2 + clamp(dot(Normal , Ld) , 0.0 , 1.0);\n        rgb = texture2d(Ip) *Kd;\n    }\n    else\n    {\n        rgb = texture( iChannel0, ((uv+ 0.5)+iTime*0.15)/16.0).rgb;\n    \n    }\n\n    vec3 final_color = mix(vec3(0.85,0.85,1.0),rgb, \n\t\tsmoothstep(0.0,0.65,abs(y-0.4)));\n\tfragColor = vec4(final_color, 1.0);    \n\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 356, 397, 397, 504], [508, 508, 530, 530, 768], [770, 770, 806, 806, 1112], [1114, 1114, 1145, 1169, 1968], [1970, 1970, 2002, 2002, 2211], [2214, 2214, 2271, 2271, 3400]], "test": "untested"}
{"id": "4lsGzN", "name": "Simple Waves", "author": "Maddius", "description": "Simple waves", "tags": ["waves", "wave", "sin"], "likes": 2, "viewed": 153, "published": "Public", "date": "1419345760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float DBL_PI = PI * 2.0;\nconst float TIME_MOD = 10.0;\nconst float AMP_SCALE = 0.03;\nconst float THICKNESS = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.y = -((1.0 - uv.y) - 0.5);\n    \n    float ampMod = ((sin(iTime) + 0.25) + 1.0) / 2.0;\n    float thickMod = ((sin(iTime * (TIME_MOD * 0.1)) + 0.1) + 1.0) / 2.0;    \n    vec2 ptOnWave = vec2(uv.x, sin((uv.x * DBL_PI) + iTime * TIME_MOD) * (AMP_SCALE * ampMod));    \n    float distToPt = length(uv - ptOnWave);    \n    float col = floor(((1.0 + (THICKNESS * thickMod)) - distToPt));\n    \n    fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 209, 209, 692]], "test": "untested"}
{"id": "4tf3zM", "name": "Distance field tutorial part 2", "author": "sebastien", "description": "The second part of the distance field raymarching tutorial, where we focus on point lighting with a simplistic shading model.", "tags": ["raymarching", "distancefield", "tutorial", "lighting"], "likes": 14, "viewed": 671, "published": "Public", "date": "1419869343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * # Raymarched distance-field renderer tutorial\n * # Part 2: Lighting\n *\n * ```\n * Author:  SÃ©bastien Pierre   \n * Website: http://sebastienpierre.ca\n * Twitter: @ssebastien\n * License: BSD License\n * ```\n *\n * This is the second part of the Raymarched Distance-Field Renderer tutorial.\n * In the first part <https://www.shadertoy.com/view/XtXGzM>, \n * we've seen the `map`, `interesect` and `main` functions that constitute the base\n * of the renderer. We've created a sphere\n * with a very simple lighting model. \n *\n * In this part of the tutorial, we're going going to add light\n * sources of different colors and \"shade\" our sphere so that it does not\n * look grey anymore.\n *\n * Have a look at [CFT], and espectially the `GetObjectLighting` if you'd like\n * to see how to implement more visual properties on top of this model.\n *\n * References:\n *\n * - [PART1] https://www.shadertoy.com/view/XtXGzM\n * - [LIGT] http://www1.cs.columbia.edu/~cs4162/slides/lecture16.pdf\n * - [CFT] https://www.shadertoy.com/view/lssGzn\n*/\n\n/**\n  * Distance field function for a sphere at [0,0,0] of radius `s`\n*/\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n/**\n  * Returns the distance to the closest object in the scene to the given point.\n*/\nfloat map( in vec3 p )\n{\n\treturn sdSphere(p, 1.0);\t\n}\n\n\n/**\n  * Returns the distance on the ray with origin `ro` and delta `rd`\n  * to the closest object in the scene.\n*/\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 20.0;\n\tfloat h          = 1.0;\n    float t          = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\n/**\n  * `pointlight` is the basic function to evaluate the effect of\n  * a light source at a given point. It takes the point position `pos`,\n  * the light position `lgt`, the light color `col` and the light\n  * `intensity`, and returns the corresponding color.\n  *\n  * Note that this does not do any shadow casting, so it does not take\n  * into account any object that might be between the light and the\n  * point.\n*/\nvec3 pointlight( in vec3 pos, in vec3 lgt, in vec3 col, float intensity ){\n    // We start by calculating the distance between the current point\n    // and the light source. As light's intensity decreases (ie. is\n    // attenuated according to distance), we need this as the primary\n    // value.\n    float distance    = length(lgt - pos);\n    // What we want to calculate next is how the intensity decreases with\n    // the distance. In that case, we use a quadratic attenuation, meaning\n    // that we divide the intensity by the distance^2. This shading model\n    // is super smiple but already gives good results.\n    float attenuation = intensity / (distance * distance);\n    // We return the corresponding color.\n    vec3 color        = col * attenuation;\n    return color;\n}\n\n/**\n  * `lighting` creates three point lights, one red, one green and one blue\n  * and return the composite value. The blue light follows the mouse pointer.\n*/\nvec3 lighting( in vec3 pos ) {\n    // In order to make the lighting interesting, we'll make the lights revolve\n    // aroud the Y axis at different speeds. This will allow to show how the\n    // emitted light blends together. You can adjust the speed of the revolution\n    // by changing `s`. Set it to 0.0 to have the lights still.\n    float s  = 1.0;\n    float a1 = 0.0 * 3.1416 / 3.0 + s*0.5*iTime;\n    float a2 = 1.0 * 3.1416 / 3.0 + s*0.3*iTime;\n    float a3 = 1.0 * 3.1416 / 3.0 + s*0.1*iTime;\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    return pointlight(pos, vec3(r1 * cos(a1), 1.0, r1 * sin(a1)), vec3( 1.0, 0.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r2 * cos(a2), 1.0, r2 * sin(a2)), vec3( 0.0, 1.0, 0.0), 2.0)\n    +      pointlight(pos, vec3(r3 * cos(a3), 1.0, r3 * sin(a3)), vec3( 0.0, 0.0, 1.0), 2.0)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // `q` is the normalized position of the current shaded pixel\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    // `p` is positioned so that [0,0] is at the center of the screen\n    vec2 p = 2.0 * q - 1.0;\n    // sets aspect ration to `p \n    p.x *= iResolution.x/iResolution.y;  \n    \n    // `ro` is the camera origin where the rays are cast\n\tvec3 ro = vec3(0.0, 0.0, 2.0 );\n    \n    // `rd` is the ray delta, ie. it's normalized direction\n    vec3 rd = normalize( vec3(p,-1.0) );\n\t\n    // col is the color of the pixel, black by default.\n\tvec3 col = vec3(0.0);\n\n    // `t` will hold the distance to the intersection with the scene\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        // `pos` is the point found by interesect, ie. the point of \n        // where the ray interseted the scene.\n        vec3 pos = ro + t*rd;\n        // We call the basic `lighting` function to see the point lights\n        // in action.\n        col  = lighting(pos);\n    }\n\t// We assign the color we've just computed.\n    fragColor = vec4( col, 1.0 );\n}\n\n// EOF", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tf3zM.jpg", "access": "shaders20k", "license": "bsd-new", "functions": [[1034, 1107, 1142, 1142, 1165], [1167, 1254, 1278, 1278, 1307], [1310, 1425, 1468, 1468, 1716], [1718, 2136, 2210, 2432, 2917], [2919, 3079, 3109, 3411, 3925], [3927, 3927, 3984, 4050, 5028]], "test": "untested"}
{"id": "4tfGRr", "name": "Supernovae", "author": "guil", "description": "inspired by https://www.shadertoy.com/view/ls2SDd", "tags": ["3d", "fractal"], "likes": 87, "viewed": 3257, "published": "Public", "date": "1417685582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n   // b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\n\nvec3 pow4( vec3 z){\n\tz=dmul(z,z);return dmul(z,z);\n}\n\nvec3 pow3( vec3 z){\n    float r2 = dot(z,z);\n    vec2 a = z.xy;a=csqr(a)/dot( a,a);\n    vec2 b = z.yz;b=csqr(b)/dot( b,b); \n    vec2 c = z.xz;c=csqr(c)/dot( c,c);\n    z.xy = cmul(a,z.xy);   \n    z.yz = cmul(b,z.yz);      \n    z.xz = cmul(c,z.xz);\n    return r2*z;\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat zoom=4.;\n\n\n\nfloat field(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n\t\t\n        p = abs(p) / dot(p,p) -1.;\n        p = dmul(p,p)+.7;\n\t\tres += exp(-6. * abs(dot(p,c)-.15));\n\t\t\n\t}\n\treturn max(0., res/3.);\n}\n\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 6.0;\n    float dt = .05;\n    vec3 col= vec3(0.);\n    for( int i=0; i<64; i++ )\n\t{\n        \n        float c = field(ro+t*rd);               \n        t+=dt/(.35+c*c);\n        c = max(5.0 * c - .9, 0.0);\n        col = .97*col+ .08*vec3(0.5*c*c*c, .6*c*c, c);\n\t\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(1.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n\n\t// raymarch\n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( sqrt(col), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 91, 121, 121, 176], [177, 177, 199, 199, 248], [250, 250, 280, 280, 449], [452, 452, 471, 471, 504], [506, 506, 525, 525, 771], [773, 773, 792, 792, 839], [859, 859, 883, 883, 1088], [1092, 1092, 1129, 1129, 1431], [1434, 1434, 1491, 1491, 2207]], "test": "untested"}
{"id": "4tl3Rn", "name": "\"meta circles\"", "author": "luutifa", "description": "Looks sort of nice.", "tags": ["2d", "metaballs"], "likes": 17, "viewed": 904, "published": "Public", "date": "1417970766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float roundLookingBlob(vec2 fragCoord, vec2 tPos, float r) {\n    vec2 pos = fragCoord.xy/iResolution.yy - vec2(0.5);\n    pos.x -= ((iResolution.x-iResolution.y)/iResolution.y)/2.0;\n    return pow(max(1.0-length(pos-tPos), 0.0) , r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat v = roundLookingBlob(fragCoord,vec2(sin(iTime)*0.4, cos(iTime)*0.4), 7.0);\n    v += roundLookingBlob(fragCoord,vec2(sin(iTime*0.6)*0.2, cos(iTime)*0.3), 6.0);\n    v += roundLookingBlob(fragCoord,vec2(cos(iTime*0.8)*0.7, sin(iTime*1.1)*0.4), 5.0);\n    v += roundLookingBlob(fragCoord,vec2(cos(iTime*0.2)*0.2, sin(iTime*0.9)*0.5), 8.0);\n    v = clamp((v-0.5)*1000.0, 0.0, 1.0);\n\tfragColor = vec4(v, v, v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 234], [236, 236, 293, 293, 711]], "test": "untested"}
{"id": "4tlGz8", "name": "Spinning Tree", "author": "dr2", "description": "A spinning, flapping mechanical tree.", "tags": ["raymarching", "rotation"], "likes": 2, "viewed": 694, "published": "Public API", "date": "1418551733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Spinning Tree\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.5 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat AngQnt (float a, float s1, float s2, float nr)\n{\n  return (s1 + floor (s2 + a * (nr / (2. * pi)))) * (2. * pi / nr);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, qLevl;\nconst float dstFar = 150.;\n\nfloat ObjDf (vec3 p)\n{\n  const float tLen = 8., tRad = 0.6, bhLen = 1., blLen = 3., dt = 0.15;\n  float d, mt1, mt2, sFac, kf, tSeq, r;\n  vec3 q = p;\n  float dHit = dstFar;\n  d = PrCylDf (q.xzy, tRad, tLen);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 2; }\n  q.y -= -1.05 * tLen;\n  d = PrCylDf (q.xzy, 6. * tRad, 0.05 * tLen);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 3; }\n  q.y -= 2.05 * tLen + 1.4 * tRad;\n  d = PrSphDf (q, 1.5 * tRad);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 4; }\n  tSeq = mod (tCur, 10.) / 10.;\n  for (int k = 0; k < 7; k ++) {\n    kf = float (k);\n    sFac = 1. - 0.1 * kf;\n    q = p;  q.y -= (-0.3 + 0.21 * kf) * tLen;\n    mt1 = tSeq - 0.3;\n    mt2 = 0.9 - tSeq;\n    q.xz = Rot2D (q.xz, pi * (0.1 * (1. + kf) + (1. + 0.5 * kf) *\n      (mt1 * step (abs (mt1 - dt), dt) + mt2 * step (abs (mt2 - dt), dt))));\n    q.xz = Rot2D (q.xz, AngQnt (atan (q.z, - q.x), 0.5, 0., 12.));\n    q.x -= - sFac * bhLen;\n    d = PrBoxDf (q, sFac * vec3 (bhLen, 0.1 * bhLen, 0.5 * bhLen));\n    if (d < dHit) { dHit = d;  qHit = q;  idObj = 1; }\n    q.x -= - sFac * bhLen;\n    q.xy = Rot2D (q.xy, pi * (-0.36 + 0.25 * smoothstep (0.25, 0.4, tSeq - 0.01 * kf) *\n       (1. - smoothstep (0.8, 0.95, tSeq + 0.01 * kf))) * (1. + 0.08 / sFac));\n    q.x -= - sFac * blLen;\n    r = 0.5 * (1. - q.x / (sFac * blLen));\n    d = PrBoxDf (q, sFac *\n       vec3 (blLen, 0.1 * bhLen * (1. - 0.8 * r), 0.5 * bhLen * (1. + 0.7 * r)));\n    if (d < dHit) { dHit = d;  qHit = q / (sFac * blLen);  idObj = 1;  qLevl = kf; }\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.1;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.1;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  if (idObj == 1) {\n    if (length (vec2 (qHit.x + 0.85, qHit.z)) < 0.1)\n       col = HsvToRgb (vec3 (mod (0.5 * tCur - qLevl / 7., 1.), 1., 1.));\n    else col = vec3 (0.1, 1., 0.1);\n  } else if (idObj == 2) col = WoodCol (3. * qHit.xzy, n);\n  else if (idObj == 3) col = WoodCol (qHit, n);\n  else if (idObj == 4) col = HsvToRgb (vec3 (mod (0.3 * tCur, 1.), 1., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol, col;\n  float dstHit, dif;\n  int idObjT;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit >= dstFar) col = vec3 (0., 0., 0.04);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    col = objCol * (0.2 + max (0., dif) * ObjSShadow (ro, ltDir) *\n       (dif + pow (max (0., dot (ltDir, reflect (rd, vn))), 128.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  float dist = 30.;\n  float az = 0.;\n  float el = 0.2;\n  float cEl = cos (el);\n  float sEl = sin (el);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  mat3 vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n     mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n  vec3 rd = normalize (vec3 (uv, 2.4)) * vuMat;\n  vec3 ro = - vec3 (0., 0., dist) * vuMat;\n  ltDir = normalize (vec3 (-0.5, 0.8, -0.4));\n  vec3 col = ShowScene (ro, rd);\n  float vv = dot (uv, uv);\n  col = mix (col, vec3 (1., 1., 0.1), smoothstep (0.8, 1., vv * vv));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGz8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 268, 292, 292, 339], [341, 341, 366, 366, 545], [547, 547, 568, 568, 705], [707, 707, 738, 738, 950], [952, 952, 976, 976, 1107], [1109, 1109, 1139, 1139, 1213], [1215, 1215, 1269, 1269, 1339], [1341, 1341, 1373, 1373, 1468], [1470, 1470, 1503, 1503, 1530], [1532, 1532, 1574, 1574, 1625], [1703, 1703, 1725, 1725, 3244], [3246, 3246, 3279, 3279, 3482], [3484, 3484, 3505, 3505, 3713], [3715, 3715, 3752, 3752, 3962], [3964, 3964, 3986, 3986, 4381], [4383, 4383, 4418, 4418, 4950], [4952, 4952, 5009, 5009, 5688]], "test": "untested"}
{"id": "4tlGzn", "name": "Cottony thing", "author": "guil", "description": "Ray marching from background to foreground. By varying the exponential smoothing parameter in line 77, the background is more or less forgotten.", "tags": ["3d", "fractal"], "likes": 4, "viewed": 190, "published": "Public", "date": "1417982011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat ti = sin (.6*iTime);\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\n\nvec3 pow4( vec3 z){\n\tz=dmul(z,z);return dmul(z,z);\n}\n\nvec3 pow3( vec3 z){\n    float r2 = dot(z,z);\n    vec2 a = z.xy;a=csqr(a)/dot( a,a);\n    vec2 b = z.yz;b=csqr(b)/dot( b,b); \n    vec2 c = z.xz;c=csqr(c)/dot( c,c);\n    z.xy = cmul(a,z.xy);   \n    z.yz = cmul(b,z.yz);      \n    z.xz = cmul(c,z.xz);\n    return r2*z;\n}\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\nvec3 f(vec3 z,vec3 c){\n\t \n   return pow3(z)+c;\n\n}\n\n\n\n\nvec3 map(in vec3 p) {\n\tp*=1.5;\n\tvec3 res =vec3(1.);\n\tfloat r2;\n    vec3 c = p;\n\tfor (int i = 0; i <12; ++i) {\n\t\tr2 =dot(p,p);\n        if(r2>1e15)return vec3(0.);\n       \t\n        p = f(p,c);\n\t\t\n        res=min(res,abs(p));\n\t\t\n\t}\n\t\n    return 15.*res*exp(-8.*r2);\n\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 5.5;\n    float dt = .039;\n    vec3 col= vec3(0.);\n    for( int i=0; i<64; i++ )\n\t{                         \n        t-=dt;      \n        col = (.72+.25*ti)*col+ .08*map(ro+t*rd); \n\t\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tfloat zoom=1.;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*2.*vec3(1.);\n    ro.yz*=rot(m.y+.07*time);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n\n\t// raymarch\n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    \n    col = clamp(col,0.,1.);\n    fragColor = vec4( sqrt(col), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGzn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 117, 147, 147, 202], [203, 203, 225, 225, 274], [276, 276, 306, 306, 473], [476, 476, 495, 495, 528], [530, 530, 549, 549, 795], [797, 797, 816, 816, 863], [867, 867, 889, 889, 916], [921, 921, 942, 942, 1186], [1188, 1188, 1225, 1225, 1451], [1454, 1454, 1511, 1511, 2230]], "test": "untested"}
{"id": "4ts3R8", "name": "print", "author": "FMS_Cat", "description": "print tool. bad accuracy :(", "tags": ["tool"], "likes": 9, "viewed": 461, "published": "Public", "date": "1418527785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 v=vec2(0.,1.);\n\nvec2 fragCoord;\nvec4 fragColor;\nvoid rect(vec4 _p,vec3 _c)\n{\n\tvec2 p=fragCoord.xy;\n    if((_p.x<p.x&&p.x<_p.x+_p.z&&_p.y<p.y&&p.y<_p.y+_p.w))fragColor=vec4(_c,0.);\n}\n\nvoid print(float _i,vec2 _f,vec2 _p,vec3 _c)\n{\n    bool n=(_i<0.)?true:false;\n    _i=abs(_i);\n    if(fragCoord.x<_p.x-5.-(max(ceil(log(_i)/log(10.)),_f.x)+(n?1.:0.))*30.||_p.x+6.+_f.y*30.<fragCoord.x||fragCoord.y<_p.y||_p.y+31.<fragCoord.y)return;\n    \n    if(0.<_f.y){rect(vec4(_p.x-5.,_p.y,11.,11.),vec3(1.));rect(vec4(_p.x-4.,_p.y+1.,9.,9.),_c);}\n    \n    float c=-_f.y,m=0.;\n    for(int i=0;i<16;i++)\n    {\n        float x,y=_p.y;\n        if(0.<=c){x=_p.x-35.-30.*c;}\n        else{x=_p.x-25.-30.*c;}\n        if(int(_f.x)<=int(c)&&_i/pow(10.,c)<1.&&0.<c)\n        {\n            if(n){rect(vec4(x,y+10.,31.,11.),vec3(1.));rect(vec4(x+1.,y+11.,29.,9.),_c);}\n            break;\n        }\n        float l=fract(_i/pow(10.,c+1.));\n        if(l<.1){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+15.,y+10.,1.,11.),vec3(1.));}\n        else if(l<.2){rect(vec4(x+5.,y,21.,31.),vec3(1.));rect(vec4(x,y,31.,11.),vec3(1.));rect(vec4(x,y+20.,6.,11.),vec3(1.));rect(vec4(x+6.,y+1.,19.,29.),_c);rect(vec4(x+1.,y+1.,29.,9.),_c);rect(vec4(x+1.,y+21.,5.,9.),_c);}\n        else if(l<.3){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+15.,y+10.,15.,1.),vec3(1.));rect(vec4(x+1.,y+20.,15.,1.),vec3(1.));}\n        else if(l<.4){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+1.,y+10.,15.,1.),vec3(1.));rect(vec4(x+1.,y+20.,15.,1.),vec3(1.));}\n        else if(l<.5){rect(vec4(x,y+5.,15.,26.),vec3(1.));rect(vec4(x+15.,y,16.,31.),vec3(1.));rect(vec4(x+1.,y+6.,14.,24.),_c);rect(vec4(x+16.,y+1.,14.,29.),_c);rect(vec4(x+15.,y+6.,1.,10.),_c);}\n        else if(l<.6){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+1.,y+10.,15.,1.),vec3(1.));rect(vec4(x+15.,y+20.,15.,1.),vec3(1.));}\n        else if(l<.7){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+10.,y+10.,11.,1.),vec3(1.));rect(vec4(x+10.,y+20.,20.,1.),vec3(1.));}\n        else if(l<.8){rect(vec4(x,y+10.,15.,21.),vec3(1.));rect(vec4(x+15.,y,16.,31.),vec3(1.));rect(vec4(x+1.,y+11.,14.,19.),_c);rect(vec4(x+16.,y+1.,14.,29.),_c);rect(vec4(x+15.,y+20.,1.,10.),_c);}\n        else if(l<.9){rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+10.,y+10.,11.,1.),vec3(1.));rect(vec4(x+10.,y+20.,11.,1.),vec3(1.));}\n        else{rect(vec4(x,y,31.,31.),vec3(1.));rect(vec4(x+1.,y+1.,29.,29.),_c);rect(vec4(x+1.,y+10.,20.,1.),vec3(1.));rect(vec4(x+10.,y+20.,11.,1.),vec3(1.));}\n        c+=1.;\n    }\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 iFragCoord )\n{\n    fragCoord = iFragCoord;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    print(iMouse.x,vec2(1.,0.),vec2(iResolution.x+4.,30.),vec3(1.,0.,.3));\n    print(iMouse.y,vec2(1.,0.),vec2(iResolution.x+4.,0.),vec3(1.,0.,.0));\n    \n    print(iTime,vec2(4.,2.),vec2(125.,0.),vec3(.0));\n    oFragColor = fragColor;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 81, 81, 186], [188, 188, 234, 234, 2692], [2694, 2694, 2753, 2753, 3107]], "test": "untested"}
{"id": "4ts3RN", "name": "Land of Gloss", "author": "thismatt", "description": "Displacement landscape thing based on @PauloFalcao's 704 and @P_Malin's blank slate framework.\n", "tags": ["raymarcher"], "likes": 2, "viewed": 202, "published": "Public", "date": "1419904306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lumpy displacement creature by @thismatt based on @PauloFalcao's 704 on @P_Malin's\n// blank slate framework.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float rate;\nuniform vec2 mouse;\nvec2 resolution = vec2(iResolution.x, iResolution.y);\nuniform sampler2D backbuffer;\n\n// somehow these enable pan/zoom controls (using magic)\n// uniform vec2 surfaceSize;\n// varying vec2 surfacePosition;\n\nfloat kPI = acos(0.0);\nfloat kHalfPi = asin(1.0);\nfloat kTwoPI = kPI * 2.0;\nvec2 surfaceSize = vec2(0.0, 0.0);\nvec2 surfacePosition = vec2(0.0, 0.0);\n\n// Removed so that it works again\n//float cos(float v) // workaround for AMD Radeon on OS X\n//{\n//  return sin(v+kHalfPi);\n//}\n\n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_POINT_LIGHT\n//#define FLOATING\n#define ENABLE_POINT_LIGHT_FLARE\n\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n\nvoid CalcPixelRandom()\n{\n  // Nothing special here, just numbers generated by bashing keyboard\n  vec4 s1 = sin(iTime * 3.3422 + fragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n  vec4 s2 = sin(iTime * 1.3422 + fragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n  gPixelRandom = fract(2142.4 + s1 + s2);\n  gRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n#endif\n\nstruct C_Ray\n{\n  vec3 vOrigin;\n  vec3 vDir;\n};\n\nstruct C_HitInfo\n{\n  vec3 vPos;\n  float fDistance;\n  vec3 vObjectId;\n};\n\nstruct C_Material\n{\n  vec3 cAlbedo;\n  float fR0;\n  float fSmoothness;\n  vec2 vParam;\n};\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n  return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n  return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n  float s = sin(fAngle);\n  float c = cos(fAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n\n  return vResult;\n}\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n  //if(v1.x < v2.x) return v1; else return v2;\n  return mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n  return mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n  return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n  vec3 vResult = vPos;\n  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n  vTile = floor(vTilePos + 1000.0);\n  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n  return vResult;\n}\n\nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n  vec3 vResult = vPos;\n  vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n  vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n  return vResult;\n}\n\nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n  vec3 vResult = vPos;\n  vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n  return vResult;\n}\n\nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n  float angle = atan( vPos.x, vPos.z );\n\n  float fScale = fSteps / (kTwoPI);\n  float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\n  float s = sin(-steppedAngle);\n  float c = cos(-steppedAngle);\n\n  vec3 vResult = vec3( c * vPos.x + s * vPos.z,\n    vPos.y,\n    -s * vPos.x + c * vPos.z);\n\n    return vResult;\n  }\n\n  float GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n  {\n    vec2 q = vec2(length(p.xy)-r1,p.z);\n    return length(q)-r2;\n  }\n  float GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n  {\n    vec2 q = vec2(length(p.yz)-r1,p.x);\n    return length(q)-r2;\n  }\n  float GetDistanceCylinderY(const in vec3 vPos, const in float r)\n  {\n    return length(vPos.xz) - r;\n  }\n  float GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n  {\n    vec3 vDist = (abs(vPos) - vSize);\n    return max(vDist.x, max(vDist.y, vDist.z));\n  }\n\n  float GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n  {\n    vec3 vClosest = max(min(vPos, vSize), -vSize);\n    return length(vClosest - vPos) - fRadius;\n  }\n\n  // result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\n  vec4 GetDistanceScene( const in vec3 vPos )\n  {\n    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n    float tt=iTime*(2.0)+10.0;\n    vec4 vDistFloor1 = vec4(vPos.y + sin(vPos.x*0.2) * sin(vPos.z*0.2+tt), 1.0, vPos.xz);\n    vec4 vDistFloor2 = vec4(vPos.y + sin(vPos.x*0.4) * sin(vPos.x+tt), 1.0, vPos.xz);\n    vResult = DistCombineUnion(vResult, vDistFloor1);\n    vResult += DistCombineUnion(vResult, vDistFloor2);\n    return vResult;\n  }\n\n  C_Material matCheckerboard(const in vec3 vPos  ) {\n    C_Material mat;\n    mat.fR0 = 0.01;\n    mat.fSmoothness = 0.0;\n    if (fract(vPos.x*0.5)>0.5)\n    if (fract(vPos.z*0.5)>0.5)\n    mat.cAlbedo=vec3(0,0,0);\n    else\n    mat.cAlbedo=vec3(1,1,1);\n    else\n    if (fract(vPos.z*.5)>.5)\n    mat.cAlbedo = vec3(1,1,1);\n    else\n    mat.cAlbedo = vec3(0,0,0);\n    return mat;\n  }\n\n  C_Material matSphere(const in vec3 vPos) {\n    C_Material mat;\n    // sphere\n    mat.fR0 = 0.5;\n    mat.fSmoothness = 0.9;\n    float tt=iTime*0.05+10.0;\n    float d=length(vPos);\n    // mat.cAlbedo = vec3((sin(d*.25-tt*4.0)+1.0)/2.0,(sin(tt)+1.0)/2.0,(sin(d-tt*4.0)+1.0)/2.0);\n    // sin(1.0*vPos.y+tt)*sin(1.0*vPos.z+tt)\n    float foo = mod(vPos.x*20.0,2.0);\n    mat.cAlbedo = vec3(1.0,1.0,1.0) + sin(vPos.y*2.0+(iTime*2.0))/3.0;\n    return mat;\n  }\n\n  C_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n  {\n    C_Material mat;\n\n    if(vObjId.x < 1.5)\n    {\n      mat.fSmoothness = 1.0;\n      mat.fR0 = 0.00;\n      mat.cAlbedo = vec3(1.0,1.0,1.0);\n      return mat;\n\n    }\n    else\n    if(vObjId.x < 2.5)\n    {\n      return matSphere(vPos);\n    }\n\n    return mat;\n  }\n  vec3 GetSkyGradient( const in vec3 vDir )\n  {\n    float fBlend = vDir.y * 1.0 + 0.5;\n    return mix(vec3(0.3, 0.4, 0.9), vec3(0.0, 0.0, 0.0), fBlend);\n\n  }\n  vec3 GetLightPos()\n  {\n    vec3 vLightPos = vec3(-9.0, 9.0, -10.0);\n    #ifdef ENABLE_MONTE_CARLO\n    vLightPos += gRandomNormal * 0.2;\n    #endif\n    return vLightPos;\n  }\n  vec3 GetLightCol()\n  {\n    return vec3(32.0, 6.0, 1.0) * 10.0;\n  }\n\n  vec3 GetAmbientLight(const in vec3 vNormal)\n  {\n    return GetSkyGradient(vNormal);\n  }\n\n  #define kFogDensity 0.035\n  void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n  {\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(intersection.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    col = mix(cFog, col, 0.6);\n    #endif\n\n\n    // glare from light (a bit hacky - use length of closest approach from ray to light)\n    #ifdef ENABLE_POINT_LIGHT_FLARE\n    vec3 vToLight = GetLightPos() - ray.vOrigin;\n    float fDot = dot(vToLight, ray.vDir);\n    fDot = clamp(fDot, 0.0, intersection.fDistance);\n\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;\n    float fDist = length(vClosestPoint - GetLightPos());\n    col += GetLightCol() * 0.01/ (fDist * fDist);\n    #endif\n  }\n  vec3 GetSceneNormal( const in vec3 vPos )\n  {\n    // tetrahedron normal\n    float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n  }\n\n  #define kRaymarchEpsilon 0.01\n  #define kRaymarchMatIter 256\n  #define kRaymarchStartDistance 0.1\n\n  void Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n  {\n    result.fDistance = kRaymarchStartDistance;\n    result.vObjectId.x = 0.0;\n\n    for(int i=0;i<=kRaymarchMatIter;i++)\n    {\n      result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n      vec4 vSceneDist = GetDistanceScene( result.vPos );\n      result.vObjectId = vSceneDist.yzw;\n\n      if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n      {\n        break;\n      }\n\n      result.fDistance = result.fDistance + vSceneDist.x;\n    }\n\n    if(result.fDistance >= fMaxDist)\n    {\n      result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n      result.vObjectId.x = 0.0;\n      result.fDistance = 1000.0;\n    }\n  }\n\n  float GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n  {\n    C_Ray shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n\n    C_HitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n\n    return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );\n  }\n\n\n  float Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n  {\n    float fDot = dot(vNormal, -vView);\n    fDot = min(max((1.0 - fDot), 0.0), 1.0);\n    float fDot2 = fDot * fDot;\n    float fDot5 = fDot2 * fDot2 * fDot;\n    return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n  }\n\n  float GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n  {\n    return max(0.0, dot(vLightDir, vNormal));\n  }\n\n  float GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n  {\n    vec3 vHalf = normalize(vLightDir - ray.vDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n\n    float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n    float fSpecIntensity = (fSpecPower + 4.0) * 0.125;\n\n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n  }\n\n\n  float GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n  {\n    vec3 vPos = intersection.vPos;\n\n    float fAmbientOcclusion = 1.0;\n\n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n      fDist += 0.1;\n\n      vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\n      fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );\n    }\n\n    return fAmbientOcclusion;\n  }\n\n  vec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n  {\n    vec3 cScene ;\n\n    vec3 vSpecularReflection = vec3(0.0);\n    vec3 vDiffuseReflection = vec3(0.0);\n\n    float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n    vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n\n    vDiffuseReflection += vAmbientLight;\n\n    vSpecularReflection += cReflection * fAmbientOcclusion;\n\n    #ifdef ENABLE_POINT_LIGHT\n    vec3 vLightPos = GetLightPos();\n    vec3 vToLight = vLightPos - intersection.vPos;\n    vec3 vLightDir = normalize(vToLight);\n    float fLightDistance = length(vToLight);\n\n    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n\n    float fShadowBias = 0.1;\n    float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );\n    vec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;\n\n    vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;\n    vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n    #endif\n\n    vDiffuseReflection *= material.cAlbedo;\n\n    #ifdef ENABLE_SPECULAR\n    float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n\n    return cScene;\n  }\n\n  vec3 GetSceneColourSimple( const in C_Ray ray )\n  {\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 16.0, 32);\n\n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n      cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n      C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n      vec3 vNormal = GetSceneNormal(intersection.vPos);\n\n\n      vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n\n\n      cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n  }\n\n  vec3 GetSceneColour( const in C_Ray ray )\n  {\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 60.0, 256);\n\n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n      cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n      C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n      vec3 vNormal = GetSceneNormal(intersection.vPos);\n\n      #ifdef ENABLE_MONTE_CARLO\n      vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n      #endif\n\n      vec3 cReflection;\n      #ifdef ENABLE_REFLECTIONS\n      {\n        // get colour from reflected ray\n        float fSepration = 0.05;\n        C_Ray reflectRay;\n        reflectRay.vDir = reflect(ray.vDir, vNormal);\n        reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n\n        cReflection = GetSceneColourSimple(reflectRay);\n      }\n      #else\n      cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n      #endif\n      // apply lighting\n      cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n  }\n\n  void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\n  {\n    vec2 vPixelCoord = fragCoord.xy;\n    #ifdef ENABLE_MONTE_CARLO\n    vPixelCoord += gPixelRandom.zw;\n    #endif\n    vec2 vUV = ( vPixelCoord / resolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\n    vViewCoord *= 0.75;\n\n    float fRatio = resolution.x / resolution.y;\n\n    vViewCoord.y /= fRatio;\n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n\n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);\n  }\n\n  void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\n  {\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n  }\n\n  vec3 OrbitPoint( const in float fHeading, const in float fElevation )\n  {\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n  }\n\n  vec3 Gamma( const in vec3 cCol )\n  {\n    return cCol * cCol;\n  }\n\n  vec3 InvGamma( const in vec3 cCol )\n  {\n    return sqrt(cCol);\n  }\n\n\n  vec3 Tonemap( const in vec3 cCol )\n  {\n    // simple Reinhard tonemapping operator\n    vec3 vResult = cCol / (1.0 + cCol);\n\n    return Gamma(vResult);\n  }\n\n  vec3 InvTonemap( const in vec3 cCol )\n  {\n    vec3 vResult = cCol;\n    vResult = clamp(vResult, 0.01, 0.99);\n    vResult = InvGamma(vResult);\n    return - (vResult / (vResult - 1.0));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    #ifdef ENABLE_MONTE_CARLO\n    CalcPixelRandom();\n    #endif\n\n    C_Ray ray;\n\n    const float fCamreaInitialHeading = -20.5;\n    const float fCamreaInitialElevation = 0.5;\n    const float fCamreaInitialDist = 20.0;\n    const float fCameraHeight = 0.01;\n    const float fOrbitSpeed = 1.0;\n\n    // This magic stolen from other 3d pan/zoom examples\n    float fZoom = surfaceSize.y * 0.5 + 0.4;\n\n    vec2 vCenterPosition = (0.5 - ( fragCoord.xy / resolution )) * surfaceSize + surfacePosition;\n    float fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\n    float fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n\n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n\n    vCameraPos += vec3(0.0, -fCameraHeight, 0.0);\n    #ifdef ENABLE_MONTE_CARLO\n    float fDepthOfField = 0.001;\n    vCameraPos += gRandomNormal * fDepthOfField;\n    #endif\n\n    GetCameraRayLookat( vCameraPos, vec3(0.0, 0.0, -iTime), fragCoord, ray); // TODO: temporary camera movement\n    //GetCameraRayLookat(vec3(0.0, 0.0, -5.0), vec3(0.0, 0.0, 0.0), ray);\n\n    vec3 cScene = GetSceneColour( ray );\n\n    float fExposure = 10.5;\n    cScene = cScene * fExposure;\n\n    #ifdef ENABLE_MONTE_CARLO\n    vec3 cPrev = texture(backbuffer, fragCoord.xy / resolution).xyz;\n    // add noise to pixel value (helps values converge)\n    cPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n    cPrev = InvTonemap(cPrev);\n    // converge speep\n    float fBlend = 0.1;\n    vec3 cFinal = mix(cPrev, cScene, fBlend);\n    #else\n    vec3 cFinal = cScene;\n    #endif\n\n    cFinal = Tonemap(cFinal);\n\n    float fAlpha = 1.0;\n\n    fragColor = vec4( cFinal, fAlpha );\n  }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[806, 1568, 1627, 1627, 1782], [1784, 1784, 1843, 1843, 1998], [2000, 2000, 2059, 2059, 2214], [2216, 2216, 2277, 2324, 2366], [2368, 2368, 2433, 2433, 2474], [2476, 2476, 2540, 2540, 2598], [2600, 2600, 2689, 2689, 2863], [2865, 2865, 2931, 2931, 3069], [3071, 3071, 3135, 3135, 3237], [3239, 3239, 3311, 3311, 3633], [3637, 3637, 3722, 3722, 3791], [3794, 3794, 3879, 3879, 3948], [3951, 3951, 4019, 4019, 4055], [4058, 4058, 4125, 4125, 4215], [4219, 4219, 4308, 4308, 4409], [4413, 4530, 4577, 4577, 4967], [4971, 4971, 5021, 5021, 5346], [5350, 5350, 5392, 5392, 5800], [5804, 5804, 5880, 5880, 6140], [6143, 6143, 6188, 6188, 6298], [6301, 6301, 6323, 6323, 6473], [6476, 6476, 6498, 6498, 6542], [6546, 6546, 6593, 6593, 6633], [6665, 6665, 6758, 6758, 7392], [7395, 7395, 7440, 7466, 8043], [8148, 8148, 8250, 8250, 8916], [8920, 8920, 9017, 9017, 9299], [9304, 9304, 9416, 9416, 9629], [9633, 9633, 9710, 9710, 9760], [9764, 9764, 9889, 9889, 10161], [10166, 10166, 10271, 10271, 10611], [10615, 10615, 10774, 10774, 12150], [12154, 12154, 12205, 12205, 12786], [12790, 12790, 12835, 12835, 13957], [13961, 13961, 14086, 14086, 14602], [14606, 14606, 14713, 14713, 14860], [14864, 14864, 14937, 14937, 15041], [15045, 15045, 15081, 15081, 15109], [15113, 15113, 15152, 15152, 15179], [15184, 15184, 15222, 15266, 15338], [15342, 15342, 15383, 15383, 15529], [15533, 15533, 15592, 15592, 17280]], "test": "untested"}
{"id": "4tX3R4", "name": "Meta Experiment 7", "author": "aiekick", "description": "Meta Experiment 7", "tags": ["2d", "experiment", "spiral", "meta", "paper", "milk", "strawberry"], "likes": 54, "viewed": 3108, "published": "Public API", "date": "1418905227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 uv;\nvec2 mo;\nfloat ratio;\n\nfloat metaline(vec2 p, vec2 o, float thick, vec2 l)\n{\n    vec2 po = 2.*p+o;\n    return thick / dot(po,vec2(l.x,l.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.3;\n    float t0 = iTime*speed;\n    float t1 = sin(t0);\n    float t2 = 0.5*t1+0.5;\n    float zoom=25.;\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;uv.x*=ratio;uv*=zoom;\n    //vec2 mo = iMouse.xy / iResolution.xy*2.-1.;mo.x*=ratio;mo*=zoom;\n\n\t// cadre\n    float thick=0.5;\n    float inv=1.;\n\tfloat bottom = metaline(uv,vec2(0.,2.)*zoom, thick, vec2(0.0,1.*inv));\n\tfloat top = metaline(uv,vec2(0.,-2.)*zoom, thick, vec2(0.0,-1.*inv));\n\tfloat left = metaline(uv,vec2(2.*ratio,0.)*zoom, 0.5, vec2(1.*inv,0.0));\n\tfloat right = metaline(uv,vec2(-2.*ratio,0.)*zoom, 0.5, vec2(-1.*inv,0.0));\n\tfloat rect=bottom+top+left+right;\n    \n    // uv / mo\n    vec2 uvo = uv;//-mo;\n    float phase=1.1;\n    float tho = length(uvo)*phase+t1;\n    float thop = t0*20.;\n    \n    // map spiral\n   \tuvo+=vec2(tho*cos(tho-1.25*thop),tho*sin(tho-1.15*thop));\n    \n    // metaball\n    float mbr = 8.;\n    float mb = mbr / dot(uvo,uvo);\n\n\t//display\n    float d0 = mb+rect;\n    \n    float d = smoothstep(d0-2.,d0+1.2,1.);\n    \n\tfloat r = mix(1./d, d, 1.);\n    float g = mix(1./d, d, 3.);\n    float b = mix(1./d, d, 5.);\n    vec3 c = vec3(r,g,b);\n    \n    fragColor.rgb = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3R4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 170, 223, 223, 289], [291, 291, 348, 348, 1564]], "test": "untested"}
{"id": "4tX3R8", "name": "Meta Experiment 2", "author": "aiekick", "description": "Meta Experiment 2\nuncomment the line 4 if you want a full rotate. but it take some time for 360&deg;", "tags": ["experiment", "meta"], "likes": 1, "viewed": 1126, "published": "Public API", "date": "1418251652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define full_rotate\nvec2 getPos(vec2 p, float zoom){\n    float ratio = iResolution.x/iResolution.y;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.)*zoom;\n}\nfloat meta(vec2 p, vec2 o, float thick){\n    vec2 po = p-o;\n\treturn thick / dot(po, p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t = 0.5*sin(iTime*0.2)+0.5;\n\tfloat t3 = 0.7*sin(iTime*0.2);\n#ifdef full_rotate\n    float t2 = iTime*0.1;\n#else \n    float t2 = 0.7*sin(iTime*0.2);\n#endif\n    vec2 uv = getPos(fragCoord.xy, 1.);\n    float d=0.;\n    for (float j=0.; j<20.;j++){\n        float a = j*t2*0.5;\n        d+=meta(uv, vec2(cos(a),sin(a))*j, 0.02);\n    }\n    float r = mix(1./d, d, abs(t3));\n    float g = mix(r, d, abs(t3));\n    float b = mix(g, d, abs(t3));\n    vec3 c = vec3(r,g,b);\n\tfragColor.rgb = vec3(c-t*2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3R8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[138, 160, 192, 192, 299], [300, 300, 340, 340, 389], [390, 390, 446, 446, 944]], "test": "untested"}
{"id": "llf3RN", "name": "My tree", "author": "Lio", "description": "The starting material - https://www.shadertoy.com/view/lts3zr  https://www.shadertoy.com/view/4dlGRn\nSimply decorate the Christmas tree :)\n", "tags": ["raytracing"], "likes": 10, "viewed": 888, "published": "Public", "date": "1419137809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 camUp = vec3(0.0, 1.0, 0.0);\nvec3 camDir= vec3(0.0, 0.0, 1.0);\nvec3 camPos= vec3(0.0, -0.96, -1.76);\n\nvec3 lightPos= vec3(-2.36, 5.75, -7.3);\n\n\n#define TAO 6.283\nconst int MAX_ITER = 100;\nfloat PI=3.14159265;\n//--------------------------------------------------\n#define time iTime\n\nvec3 getNormal(in vec3 p);\n\n//ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ\n//-------------------------------------------------Ð›Ð°Ð¼Ð±ÐµÑ€Ñ‚\nvec3 getlightingLambert(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n  //  const vec3 diffColor = vec3 ( 0.5, 0.0, 0.0 );\n\n    vec3 n2   = normalize ( normal);\n    vec3 l2   = normalize ( lightDir-pos );\n    vec3 diff = color * max ( dot ( n2, l2 ), 0.0 );   \n    return diff;\n}\n//-------------------------------------------------Ð¿Ð¾ Ð¤Ð¾Ð½Ð³Ñƒ\nvec3 getlightingPhong(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   vec3 specColor = vec3(1.0, 0.97, 0.94);\n   float  specPower = 36.0;\n       \n    vec3   l = normalize (lightDir-pos);   \n    vec3   v = normalize(pos-pos);\n\n    vec3   n = normalize (normal);        \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = specColor * pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    \n    return diff + spec;\n}\n//------------------------------------------\nvec2 rot(vec2 p,float r){\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n//------------------------------------------\nvec2 rotsim(vec2 p,float s){\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n//------------------------------------------\nvec3 sim(vec3 p,float s){\n   vec3 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n//------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//--------------------------------------------------\nfloat trunkCone( vec3 p, float c )\n{\n float q = length(p.xz);\n return q + p.y * c;\n\n}\n//----------------------------------------------------\nvec3 background(vec3 rd)\n{\n\n   float sky = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n   float ground = max(0.0, -dot(rd,  vec3(0.0, 6.7, 2.0)));\n   vec3 bFon =  pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +   pow(sky, 1.) * vec3(0.4, 0.3, 0.2);\n   return bFon ;\n\n}\n//-------------------------------------------------- \nvec3 getmaterial( in vec3 p,  in float mat)\n{\n \n vec3 pos = p; \n vec3 color = vec3(1.);\n  \n\n vec3 colorObject = vec3(0.5, 0.4, 0.3);\n vec3 colorObject1;\n   \n   if (mat == 0.)\n      return vec3(0.4662, 0.4565, 0.4488);\n   else if (mat == 1.)\n      return vec3(1.0, 1.0, 1.0);   \n   else if (mat == 2.)\n   {\n\n     float r = pow(colorObject.r, cos(iTime * 0.5)); \n     float g = pow(colorObject.g, cos(iTime * 0.3));\n     float b = pow(colorObject.b, cos(iTime * 0.7));  \n     colorObject1 = vec3(r, g, b);\n     return colorObject1;         \n   }\n    else if (mat == 3.) // ÑÑ‚Ð²Ð¾Ð»\n      return vec3(0.7218, 0.4581, 0.0983);  \n   else if (mat == 4.) // Ð¸Ð³Ð»Ñ‹\n      return vec3(0.5, 0.6, 0.2);     \n   \n   else   \n      return vec3(0.3, 0.9,0.5);\n}\n\n//------------------------------------------------\n//ÐžÐ±ÑŠÐµÐºÑ‚Ñ‹\n//----------------------------------------------------\nvec2 rotate1(vec2 v, float angle) \n{return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nvec2 kaleido(vec2 v, float power)\n{return rotate1(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\nvec2 kaleido6(vec2 v)\n{return rotate1(v,floor(0.5+atan(v.x,-v.y)*0.95493)*1.0472);}\n\nvec2 kaleido12(vec2 v)\n{return rotate1(v,floor(0.5+atan(v.x,-v.y)*1.90986)*0.5236);}\n\n\nmat2 r45=mat2(0.7071,0.7071,-0.7071,0.7071);\nmat2 r30=mat2(0.866,0.5,-0.5,0.866);\nmat2 rtrn=mat2(0.9689,-0.2474,0.2474,0.9689);\n//----------------------------------------------------Ð’ÐµÑ‚ÐºÐ¸ Ñ‘Ð»ÐºÐ¸\nfloat branch(in vec3 pos, inout float trunk )\n{\n float d = 1.0;\n\n   for(int i=0;i<2;i++)\n   {\n      vec3 z=pos;\n\n      float c=floor(z.y*4.); \n      z.yz=rotate1(z.yz,-z.z*0.79*(1.0+c*0.1)); \n      float bm = -z.y - 2.0;\n      z.y=mod(z.y,0.25)-0.05;      \n      if(i==1)                    \n        z.xz=z.xz*rtrn;\n      z.xz=kaleido(z.xz,2.0-c); \n      z.yz=rtrn*z.yz;\n      bm=max(bm,-z.z+c*0.086);\n      trunk=min(trunk,max(max(abs(z.x),abs(z.y)),bm))-0.001-z.z*0.003;\n      float c2=floor(z.z * 16.0); \n      z.z=mod(z.z,0.0625)-0.049; \n      z.xy=rotate1(z.xy,c2*0.25);  \n      z.xy=kaleido12(z.xy);\n      z.yz=z.yz*r30;   \n      d=min(d,max(max(max(abs(z.x),abs(z.z)),-z.y-0.05+c*0.005),bm));\n   }\n \n \n return d;\n}\n\n//----------------------------------------------------\nvec2 tree(in vec3 pos)\n{\n   float d=1.;\n   float material = 0.;\n   float trunk = trunkCone( pos, 0.025 );  // Ð¡Ñ‚Ð²Ð¾Ð»\n   d =  branch(pos, trunk );               // Ð’ÐµÑ‚ÐºÐ¸\n   if(trunk<d)\n   {\n      d=trunk;\n      material = 3.;\n   }\n   else\n   {\n      material = 4.;\n   }\n   float result = max(0.0,max(d,max(pos.y,-pos.y-2.0)));\n   return vec2(result, material);\n}\n//----------------------------------------------------\n//Star\nvec2 star(vec3 p)\n{\n  p.y=p.y - 0.07;\n  p= p * 10.0;\n  float l=length(p);\n  if (l  < 2.0)\n  {\n  p.xy=rotsim(p.xy,5.0);\n  p.y=p.y-2.0; \n  p.z=abs(p.z);\n  p.x=abs(p.x);\n  return vec2(dot(p,normalize(vec3(2.0,1,3.0))) / 10.0, 2.);\n  } else return vec2((l-1.9)/4.0, 2.0);\n}\n//----------------------------------------------------\n//Snow\nfloat makeshowflake(vec3 p)\n{\n  return length(p)- 0.02;\n}\n//----------------------------------------------------\nfloat makeShow(vec3 p,float tx,float ty,float tz)\n{\n  p.y=p.y+time*tx;\n  p.x=p.x+time*ty;\n  p.z=p.z+time*tz;\n  p=sim(p,8.0);\n  return makeshowflake(p);\n}\n//----------------------------------------------------\nvec2 show(vec3 p)\n{\n  float f=makeShow(p,1.11, 1.03, 1.38);\n  f=min(f,makeShow(p,1.72, 0.74, 1.06));\n  f=min(f,makeShow(p,1.93, 0.75, 1.35));\n\n  return vec2(f,1.0);\n}\n//----------------------------------------------------\nvec4 swag(vec2 pos)\n{\n \n  vec3 camSide = cross(camDir, camUp);\n  mat4 cm=mat4(\n    camUp.x,   camUp.y,   camUp.z,   -dot(camUp,camPos),\n    camSide.x,   camSide.y,   camSide.z,   -dot(camSide,camPos),\n    camDir.x, camDir.y, camDir.z, -dot(camDir,camPos),\n    0.0,   0.0,   0.0,   1.0);\n\n  vec4 pc=vec4(0,0,0,0);\n  const float maxl=64.0;\n  for(float i=0.0;i<maxl;i++)\n  {\n\n   vec4 pt=vec4(\n    sin(i*PI*2.0*7.0/maxl) * 0.75 * (1.0-i/maxl), /* Ð¨Ð¸Ñ€Ð¸Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾ X  */\n    i/maxl * 2.1, /*Ð’Ñ‹ÑÐ¾Ñ‚Ð° ÐºÐ¾Ð½ÑƒÑÐ° */\n    cos(i*PI*2.0*7.0/maxl) * 0.75 * (1.0-i/maxl),  /* Ð¨Ð¸Ñ€Ð¸Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾ Z */\n    1.0);\n    \n  pt=pt*cm;\n  vec2 vPos = pos;\n vPos.y += 1.28;\n\n  vec2 xy=(pt/(-pt.z )).yx + vPos;\n\n  float c;\n  c= 0.2/length(xy); \n\n pc+=vec4(\n          (sin(i*5.0+time*10.0)*0.5 + 0.5) * c,\n          (cos(i*3.0+time*8.0)*0.5 + 0.5) * c,\n          (sin(i*6.0+time*9.0)*0.5 + 0.5) * c ,0.0);\n  }\n  pc=pc/maxl; \n\n  pc=smoothstep(0.0,1.0,pc); \n  \n  return pc;\n \n}\n//----------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nvec2 renderFunction(in vec3 pos)\n{\n  vec2 result;\n  vec3 pos1 = pos;\n //   pos1 = rotationCoord(pos, 3.);\n  vec2 treeMy = tree(pos1);\n  vec2 starMy = star(pos1);\n  vec2 showMy = show(pos1);\n\n\n  if(treeMy.x < starMy.x)\n      result = treeMy;\n  else\n      result = starMy;  \n  if(result.x > showMy.x)\n      result = showMy; \n \n \n  return result;\n}\n//-------------------------------------------------\nvec3 getNormal(in vec3 p)\n{\n  const float e = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(e,0.0,0.0)).x - renderFunction(p+vec3(-e,0.0,0.0)).x,\n        renderFunction(p+vec3(0.0,e,0.0)).x - renderFunction(p+vec3(0.0,-e,0.0)).x,\n        renderFunction(p+vec3(0.0,0.0,e)).x - renderFunction(p+vec3(0.0,0.0,-e)).x\n      )\n    );\n}\n//-------------------------------------------------\nfloat rndStart(vec2 co)\n{return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n//-------------------------------------------------\nvec4 render(in vec3 posOnRay, in vec3 camPos, in vec3 rayDir, out vec2 object)\n{ \n  vec4 color = vec4(0.0);\n  float t = 0.0;\n  vec3 normal;\n  vec3 lightDir = lightPos;\n  vec4 colorMirror = vec4(0.);\n  \n  //--------------Ð¦Ð²ÐµÑ‚ Ñ„Ð¾Ð½Ð°\n  vec3 bcol = background(rayDir);                      \n                      \n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay); // ÐžÐ±ÑŠÐµÐºÑ‚ Ð¸ ÐµÐ³Ð¾ Ñ†Ð²ÐµÑ‚\n//------------------    \n\n  if(abs(object.x) < 0.004)\n  {\n    normal = normalize(getNormal(posOnRay));   \n    //----------------- \n    vec3 materialColor = getmaterial(posOnRay.xyz, object.y); \n    if(object.y == 2.0)\n       color.rgb = getlightingPhong(posOnRay, normal, lightDir, materialColor); // ÐŸÐ¾ Ð¤Ð¾Ð½Ð³Ñƒ\n    else \n       color.rgb = getlightingLambert(posOnRay, normal, lightDir, materialColor); \n\n    return color;\n  }    \n//------------------\n    t = object.x;\n   posOnRay = posOnRay + t*rayDir;  \n  }\n\n  \n  color.rgb+=bcol*(1.0-clamp(color.w,0.0,1.0));\n  return vec4(color.rgb, 1.0);\n}\n//-------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pos =   ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n  vec3 camSide = cross(camDir, camUp);\n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir);\n\n  float t = 0.0, s = 0.1;\n  vec2 object = vec2(1., 1.);\n//------------------------------\n  vec3 posOnRay = camPos;\n//------------------------------ \n  vec4 color = vec4(0.);\n\n  color= render(posOnRay, camPos, rayDir, object);\n//------------------------------\n   vec3 light_color = vec3(0.9, 0.5, 0.1);\n   float c = 0.075/(length(pos - vec2(0.48, 0.66)));\n   //Ð»ÑƒÐ½Ð°\n   vec4 moon = smoothstep(0.95,1.05,c) * vec4(1.0) + vec4(vec3(c) * light_color, 1.0);\n//-----------------------------\nvec4 swagMy =  swag(pos); // Ð³Ð¸Ñ€Ð»ÑÐ½Ð´Ð°\n//-----------------------------\n\n     fragColor =color + moon + swagMy; \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llf3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 438, 525, 578, 735], [736, 817, 902, 902, 1295], [1296, 1341, 1366, 1366, 1456], [1457, 1502, 1530, 1530, 1637], [1638, 1683, 1708, 1708, 1785], [1786, 1932, 1968, 1968, 2017], [2018, 2073, 2099, 2099, 2331], [2332, 2386, 2431, 2431, 3156], [3158, 3297, 3333, 3333, 3380], [3382, 3382, 3417, 3417, 3481], [3483, 3483, 3506, 3506, 3566], [3568, 3568, 3592, 3592, 3652], [3783, 3878, 3925, 3925, 4599], [4601, 4656, 4680, 4680, 5049], [5050, 5112, 5131, 5131, 5381], [5382, 5444, 5473, 5473, 5501], [5502, 5557, 5608, 5608, 5710], [5711, 5766, 5785, 5785, 5932], [5933, 5988, 6009, 6009, 7078], [7079, 7189, 7223, 7223, 7534], [7535, 7587, 7614, 7614, 7956], [7957, 8009, 8034, 8034, 8099], [8100, 8152, 8232, 8232, 9244], [9245, 9298, 9355, 9355, 10168]], "test": "untested"}
{"id": "llf3z8", "name": "Tetrahedronator", "author": "eiffie", "description": "I don't even know how to work this polygon software anymore. Where is the code window?", "tags": ["3d", "tesellation"], "likes": 22, "viewed": 699, "published": "Public", "date": "1418413898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Tetrahedronator by eiffie\n//This is an attempt at the 3d (or 4d?) version of Triangulator by Nimitz https://www.shadertoy.com/view/lllGRr\n\n//The idea is still simple: find the tetrahedral section of the cube we are in\n//then get 4 samples and compute distance using barycentric coords (4d version).\n//The implementation is not so simple. Tiling with good tetrahedra that are fairly regular\n//is tricky (unless your knighty) and the 4d version of barycentric coords requires \n//a matrix inverse every DE check. So many shortcuts have been taken. \n//It does produce only flat surfaces made of polys but with VERRRY irregular sizes.\n \n\n#define time iTime\n#define size iResolution\n\n//for comparison\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\n/*vec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return abs(vec3(u,v,w));\n}*/\n\n//my own tet weighting function cause why not (actually i didn't want to do the mat inv thingy)\nvec4 eiffieCentricCoords(vec3 a, vec3 b, vec3 c, vec3 d, vec3 p) \n{\n\tb -= a; c -= a; d -= a, p -= a;\n\tvec3 B = cross(c,d), C=cross(b,d), D=cross(b,c);\n\tfloat y = dot(p,B)/(dot(b,B));\n\tfloat z = dot(p,C)/(dot(c,C));\n\tfloat w = dot(p,D)/(dot(d,D));\n\treturn abs(vec4(1.0-y-z-w,y,z,w));\n}\n\n//from iq, this version removes the mix\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\n\nfloat DO(in vec3 z){//the object's distance estimate\n\tfloat bowl=length(max(vec2(abs(length(z.xyz)-0.9),z.y),0.0))-0.1;\n\tfloat d=smin(bowl,length(z+vec3(-1.5,0.5,0.0))-0.5,0.5);\n\treturn d;\n}\n\nfloat rez,hrez;//the tesellation scale, and half it \nvec4 wt;\nfloat DE(in vec3 p){\n\tvec3 c=floor(p/rez)*rez+vec3(hrez);//tile the space into cubes and find the center\n\tfloat d0=DO(c);//get the approx distance and return if far away\n\tif(d0>rez*4.0)return d0-rez*1.5;\n\t\n\t//find 4 points in space surrounding point p, we know one will be c the center of the cube\n\t//we will find the three other corners of the cube that enclose our point\n\tvec3 o1=vec3(1.0),o2=vec3(-1.0),o3;//offsets for the other \"vertices\"\n\tvec3 tp=p-c,abp=abs(tp),sp=sign(tp);//get our position within the cube\n\tif(abp.x>abp.y && abp.x>abp.z){//now tile the cube into 12 tetrahedrons (very irregular) and find the one we are in\n\t\to1.x=sp.x;o2.x=sp.x;//the first 2 vertices we only need to know which side of the cube it is on\n\t\to3=vec3(sp.x,vec2(1.0,-1.0)*sign(tp.y-tp.z));//the third vertex is chosen from a diagonal\n\t}else if(abp.y>abp.z){//we are on one of the \"Y\" sides of the cube\n\t\to1.y=sp.y;o2.y=sp.y;//which y side is determined by the sign of y obviously\n\t\tif(tp.x>tp.z)o3=vec3(1.0,sp.y,-1.0);//now spilt this pyramid shape in 2 diagonally\n\t\telse o3=vec3(-1.0,sp.y,1.0);\n\t}else{//the \"Z\" sides, same same\n\t\to1.z=sp.z;o2.z=sp.z;\n\t\to3=vec3(vec2(1.0,-1.0)*sign(tp.x-tp.y),sp.z);\n\t}\n\to1*=hrez;o2*=hrez;o3*=hrez;//scale the offsets to the tetrahedron's vertices\n\t//eiffie centric coords are just like barycentric only they work like sh!@!T!\n\twt=eiffieCentricCoords(c,c+o1,c+o2,c+o3,p);\n\t//now use these points to determine the weighted avg distance\n\tvec4 pd=vec4(d0,DO(c+o1),DO(c+o2),DO(c+o3));//get the distances\n\tpd*=wt;//apply the weights\n\treturn pd.x+pd.y+pd.z+pd.w; //and wala! ...crappy tesellation\n}\nfloat meshy=0.0;\nvec3 scene( vec3 ro, vec3 rd, vec2 fragCoord ){\n\tfloat t=0.0,d,dm=100.0,tm,px=1.0/size.y,ff=0.75+0.25*cos(time*0.1);\n\tfor(int i=0;i<48;i++){\n\t\td=DE(ro+rd*t)*ff;\n\t\tif(d<dm){dm=d;tm=t;if(d<0.00001)break;}\n\t\tt+=d+px*t;\n\t\tif(t>5.0)break;\n\t}\n\tvec3 col=vec3(fragCoord.y/size.y*0.2);\n\tpx*=tm;\n\tif(dm<px){\n\t\tro+=rd*tm;\n\t\tfloat d=DE(ro);\n\t\tfloat w=min(wt.x,min(wt.y,min(wt.z,wt.w))),dif=0.5,spec=0.0;\n\t\tif(meshy<0.8){\n\t\t\tvec2 v=vec2(px*0.66,0.0);\n\t\t\tvec3 dn=vec3(DE(ro-v.xyy),DE(ro-v.yxy),DE(ro-v.yyx));\n\t\t\tvec3 dp=vec3(DE(ro+v.xyy),DE(ro+v.yxy),DE(ro+v.yyx));\n\t\t\tvec3 nor=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\t\t\tvec3 litDir=normalize(vec3(0.7,0.4,0.7));\n\t\t\tdif=0.5+0.5*dot(nor,litDir);\n\t\t\tspec=0.25*pow(max(0.0,dot(reflect(rd,nor),litDir)),4.0);\n\t\t\tvec3 scol=vec3(0.5);//vec3(0.6,0.3,0.3+dot(nor,rd)*0.1);\n\t\t\tscol=clamp(dif*scol+spec*vec3(1.0),0.0,1.0);\n\t\t\tcol=mix(scol,col,clamp(dm/px+meshy*2.0,0.0,1.0));\n\t\t}\n\t\tcol=mix(vec3(0.0,0.5,0.0),col,smoothstep(0.0,12.0*px,1.0-meshy+w));\n\t}\n\treturn col;\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nvec2 ch_p;\nfloat ch_d;\nvoid ch(int i){\n\tconst float ch_sv=0.4,ch_sh=0.2;\n\tif(i > 127){i-=128;ch_d=min(ch_d,max(abs(ch_p.x),abs(ch_p.y)-ch_sv));}\n\tif(i > 63){i-=64;ch_d=min(ch_d,max(abs(ch_p.x-ch_sh),abs(ch_p.y-ch_sh)-ch_sh));}\n\tif(i > 31){i-=32;ch_d=min(ch_d,max(abs(ch_p.x-ch_sh),abs(ch_p.y+ch_sh)-ch_sh));}\n\tif(i > 15){i-=16;ch_d=min(ch_d,max(abs(ch_p.x+ch_sh),abs(ch_p.y-ch_sh)-ch_sh));}\n\tif(i > 7){i-=8;ch_d=min(ch_d,max(abs(ch_p.x+ch_sh),abs(ch_p.y+ch_sh)-ch_sh));}\n\tif(i > 3){i-=4;ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y-ch_sv)));}\n\tif(i>1){i-=2;ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y)));}\n\tif(i>0)ch_d=min(ch_d,max(abs(ch_p.x)-ch_sh,abs(ch_p.y+ch_sv)));\n\tch_p.x-=ch_sv*1.5;\n}\nfloat cursor(vec2 uv, vec2 ms){\n\tfloat d=max(abs(uv.x-ms.x)*abs(uv.y-ms.y),max(abs(uv.x-ms.x)-0.015,abs(uv.y-ms.y)-0.02));\n\treturn smoothstep(0.0,0.01,sqrt(d));\n}\nvec2 mstsk(float t){\n\tif(t<0.0)return vec2(0.9,0.5);\n\tif(t==0.0 || t==4.0)return vec2(0.375,0.025);\n\tif(t==1.0)return vec2(0.9,0.6);\n\tif(t==2.0 || t==6.0)return vec2(0.77,0.5);\n\tif(t==3.0)return vec2(0.9,0.9);\n\tif(t==5.0)return vec2(0.9,0.7);\n\treturn vec2(0.9,0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\trez=0.01;\n\tfloat clk=1.0,tim=time,maxRez=0.15,minRez=0.01;\n\tvec2 slider=vec2(0.375,0.5), ms=slider;\n\tfloat tm=mod(tim,5.0),tsk=mod(floor(tim/5.0),8.0);\n\tif(tsk>1.0 && tsk<8.0)rez=maxRez;\n\tif(tsk==4.0)meshy=1.0;\n\tms=mstsk(tsk);\n\tif(tm<1.0){//moving mouse to task\n\t\tms=mix(mstsk(tsk-1.0)+vec2(-0.3,1.0)*tm,ms,tm);\t\n\t\tif(tsk==5.0)meshy=1.0;\n\t}else{//perform task\n\t\ttm-=1.0;tm*=0.25;\n\t\tif(ms.y<0.03){ms.x+=sin(tm*6.283)*0.3;slider.x=ms.x;}\n\t\telse if(ms.x==0.77){ms.y+=sin(tm*6.283)*0.4;slider.y=ms.y;}\n\t\t//if(tm<0.04)clk=0.0;\n\t\tif(tsk==1.0)rez=minRez+tm*(maxRez-minRez);\n\t\telse if(tsk==7.0)rez=maxRez-tm*(maxRez-minRez);\n\t\tif(tsk==3.0)meshy=tm;\n\t\tif(tsk==5.0)meshy=1.0-tm;\n\t\tclk=sin(time*50.0);\n\t}\n\tvec2 uv=fragCoord.xy/size.xy;\n\tvec3 color;\n\tif(uv.x<0.75 && uv.y>0.05){\n\t\t\n\t\threz=0.5*rez;\n\t\tfloat a=-slider.x*3.0,b=slider.y*3.0;\n\t\tvec3 ro=vec3(0.0,0.0,1.5),rd=vec3((vec2(2.5)*fragCoord.xy-size.xy)/size.y,1.5);\n\t\tro.xz=rotate(ro.xz,a);\n\t\tro.xy=rotate(ro.xy,b);\n\t\trd=lookat(vec3(0.0,-1.0,0.0)-ro,vec3(0.0,1.0,0.0))*normalize(rd);\n\t\tcolor=scene(ro,rd,fragCoord);\n\t}else{\n\t\tcolor=vec3(0.4);\n\t  \tif(uv.x>0.79 && uv.y<0.95 && uv.y>0.45){\n\t\t\tfloat sz=30.0;\n\t\t\tch_d=100.0;\n            const int _A=126, _C=29,_D=125,_E=31,_F=30,_H=122,_I=128,_L=25,_M=252,_P=94, _S=55,_T=132,_U=121;\n\t\t\tch_p=(uv-vec2(0.86,0.9))*sz;\n\t\t\tch(_M);ch(_E);ch(_S);ch(_H);\n\t\t\tch_p=(uv-vec2(0.83,0.8))*sz;\n\t\t\tch(_D);ch(_I);ch(_F);ch(_F);ch(_U);ch(_S);ch(_E);\n\t\t\tch_p=(uv-vec2(0.82,0.7))*sz;\n\t\t\tch(_S);ch(_P);ch(_E);ch(_C);ch(_U);ch(_L);ch(_A);ch(_A);\n\t\t\tch_p=(uv-vec2(0.81,0.6))*sz;\n\t\t\tch(_T);ch(_E);ch(_S);ch(_E);ch(_L);ch(_L);ch(_A);ch(_T);ch(_E);\n\t\t\tch_p=(uv-vec2(0.84,0.5))*sz;\n\t\t\tch(_S);ch(_M);ch(_D);ch(_D);ch(_T);ch(_H);\n\t\t\tfloat y=mod(uv.y+0.04,0.1);\n\t\t\tif(abs(uv.x-0.89)<0.1 && y<0.08)color=vec3(0.5+y*4.0);\n\t\t\tcolor=mix(vec3(0.0),color,smoothstep(0.0,0.1,ch_d));\n\t  \t}else if(uv.y<0.045 && uv.x<0.75){\n\t\t\tcolor=vec3(0.4+uv.y*5.0+max(0.0,0.4-abs(uv.x-slider.x)*60.0));\n\t\t}else if(uv.y>0.05 && uv.x>0.755 && uv.x<0.785){\n\t\t\tcolor=vec3(0.6+(0.755-uv.x)*5.0+max(0.0,0.4-abs(uv.y-slider.y)*40.0));\n\t\t}\t\t\n\t}\n\tcolor=mix(vec3(0.0),color,cursor(uv,ms));\n\tuv-=vec2(0.004);\n\tif(clk>0.5)color=mix(vec3(1.0),color,cursor(uv,ms));\n\tfragColor = vec4(color,1.0);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llf3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1078, 1174, 1241, 1241, 1458], [1460, 1500, 1536, 1536, 1599], [1601, 1601, 1621, 1653, 1791], [1808, 1855, 1875, 1875, 3470], [3488, 3488, 3535, 3535, 4490], [4491, 4491, 4520, 4520, 4605], [4606, 4606, 4640, 4640, 4687], [4712, 4712, 4727, 4727, 5386], [5387, 5387, 5418, 5418, 5549], [5550, 5550, 5570, 5570, 5817], [5818, 5818, 5875, 5875, 8099]], "test": "untested"}
{"id": "llfGRn", "name": "BlackBerry Logo", "author": "mlepage", "description": "Playing with raymarching for the first time. I altered Inigo Quilez's raymarching primitives example to produce a cube of BlackBerry logos.", "tags": ["procedural"], "likes": 0, "viewed": 191, "published": "Public", "date": "1417739635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Marc Lepage in Dec 2014\n// by hacking up Inigo Quilez's raymarching demo:\n// https://www.shadertoy.com/view/Xds3zN\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b, 0.0)) - r;\n}\n\n// h.x is radius, h.y is length\nfloat sdDrupelet( vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(length(p-vec3(0.0, 0.0, h.y))-h.x, min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// A B\n//     C\n// D E\n//     F\n//   G\nfloat sdLogo( vec3 p, float r)\n{\n    // TODO need to figure out the exact skew\n    // TODO need to figure out the exact vertical position of third column\n    // TODO need to center it better (it's off by half a drupelet sphere)\n\n    // Rotate by r radians\n    float c = cos(r);\n    float s = sin(r);\n\tfloat x = -(p.x*c + p.z*s);\n\tfloat z = -(p.x*s - p.z*c);\n    p.x = x;\n    p.z = z;\n        \n    // Skew\n    p.z -= p.y/8.0;\n\n    float d = sdDrupelet( p, vec2(0.1,0.1) ); // E\n    d = min(d, sdDrupelet( p-vec3(0.0,  0.3,  0.0), vec2(0.1,0.1) )); // B\n    d = min(d, sdDrupelet( p-vec3(0.0, -0.3,  0.0), vec2(0.1,0.1) )); // G\n    d = min(d, sdDrupelet( p-vec3(0.0,  0.3, -0.4), vec2(0.1,0.1) )); // A\n    d = min(d, sdDrupelet( p-vec3(0.0,  0.0, -0.4), vec2(0.1,0.1) )); // D\n    d = min(d, sdDrupelet( p-vec3(0.0,  0.125, 0.4), vec2(0.1,0.1) )); // C\n    d = min(d, sdDrupelet( p-vec3(0.0, -0.175, 0.4), vec2(0.1,0.1) )); // F\n    return d;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( udRoundBox(  pos-vec3( 0.0,2.0,0.0), vec3(1.0), 0.1 ), 2.0 ) );\n\n   \tres = opU( res, vec2( sdLogo(  pos-vec3(-1.1, 2.0, 0.0), 0.0), 4.0 ) );\n    \n   \tres = opU( res, vec2( sdLogo(  pos-vec3( 1.1, 2.0, 0.0), M_PI), 4.0 ) );\n\n    res = opU( res, vec2( sdLogo(  pos-vec3( 0.0, 2.0, -1.1), M_PI/2.0), 4.0 ) );\n\n    res = opU( res, vec2( sdLogo(  pos-vec3( 0.0, 2.0, 1.1), -M_PI/2.0), 4.0 ) );\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.0001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{        \n    vec3 col = vec3(0.9, 0.9, 0.9);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.5,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        else if (m == 2.0)\n        {\n            // box\n            col = vec3(0.05, 0.05, 0.05);\n        }\n        else if (m == 4.0)\n        {\n            // drupelet\n            col = vec3(0.75, 0.75, 0.75);\n        }\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 40.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.4+3.2*cos(0.1*time + 6.0*mo.x), 2.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 1.5, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\n    // gamma\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 178, 203, 203, 221], [223, 223, 268, 268, 313], [315, 347, 382, 382, 525], [527, 527, 557, 557, 590], [592, 631, 663, 886, 1575], [1577, 1577, 1602, 1602, 2085], [2087, 2087, 2127, 2127, 2448], [2450, 2450, 2482, 2482, 2703], [2705, 2705, 2747, 2747, 3046], [3048, 3048, 3122, 3122, 3382], [3384, 3384, 3423, 3423, 5235], [5237, 5237, 5294, 5294, 5943]], "test": "untested"}
{"id": "lll3R4", "name": "Android 5.0", "author": "smb02dunnal", "description": "A tribute to android lollipop, modification of Simon Greens original android shader.", "tags": ["android", "lollipop", "50"], "likes": 4, "viewed": 205, "published": "Public", "date": "1419384447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// distance field ray caster\n// simon green 06/01/2011\n// alex dunn - lollipop\n// \n// based on Inigo Quilezles's:\n// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n// \n// Google Android robot:\n// http://www.android.com/branding.html\n\nprecision mediump float;\n\n#define SKY_COLOR vec3(0.1,0.4,0.9)\n#define HORIZON_COLOR vec3(0.8, 0.8, 0.8)\n#define SUN_COLOR vec3(1.0,1.0,0.8)\n\n#define MIN_DISTANCE 0.01\n\n#define SKIP_PRIMITIVES 0\n\n#if SKIP_PRIMITIVES\n#define EARLY_OUT if(d<MIN_DISTANCE) return d;\n#else \n#define EARLY_OUT\n#endif\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n//    return max(a, -b);\n\treturn max(a, 0.0-b); // work around PowerVR bug\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat plane(vec3 p, vec3 planeN, vec3 planePos)\n{\n    return dot(p - planePos, planeN);\n}\n\nfloat box(vec3 p, vec3 abc )\n{\n    vec3 di=max(abs(p)-abc, 0.0);\n    return dot(di,di);\n    //return length(di);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\n// given segment ab and point c, computes closest point d on ab\n// also returns t for the position of d, d(t) = a + t(b-a)\nvec3 closestPtPointSegment(vec3 c, vec3 a, vec3 b, out float t)\n{\n    vec3 ab = b - a;\n    // project c onto ab, computing parameterized position d(t) = a + t(b-a)\n    t = dot(c - a, ab) / dot(ab, ab);\n    // clamp to closest endpoint\n    t = clamp(t, 0.0, 1.0);\n    // compute projected position\n    return a + t * ab;\n}\n\n// generic capsule\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    float t;\n    vec3 c = closestPtPointSegment(p, a, b, t);\n    return length(c - p) - r;\n}\n\nfloat cylinderY(vec3 p, float r, float h)\n{\n     float d = length(vec2(p.x, p.z)) - r;\n     d = intersect(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, h, 0.0)));\n     d = intersect(d, plane(p, vec3(0.0, -1.0, 0.0), vec3(0.0)));\n     return d;\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    \n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nfloat halfSphere(vec3 p, float r)\n{\n    return difference( \n               sphere(p, r),\n               plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0)) );\n}\n\nfloat sceneInterp() \n{\n    const float speed=0.5;\n\n    return clamp(sin(iTime*speed)*1.75,-1.0,1.0) *0.5+0.5;\n}\n\nfloat droid(vec3 p)\n{\n    float d;\n\n    p.x = abs(p.x);  // mirror in X to reduce no. of primitives\n\n    vec3 hp = p;\n\n    // head\n    d = halfSphere(hp, 1.0);\n\n    EARLY_OUT\n\n    // eyes\n    d = _union(d, sphere(hp - vec3(0.3, 0.3, 0.9), 0.1));\n    \n    EARLY_OUT\n\n    // antenna\n    d = _union(d, capsule(hp, vec3(0.4, 0.7, 0.0), vec3(0.75, 1.2, 0.0), 0.05));\n\n    EARLY_OUT\n\n    // body\n    d = _union(d, capsuleY((p*vec3(1.0, 4.0, 1.0) - vec3(0.0, -4.6, 0.0)), 1.0, 4.0));\n\n    EARLY_OUT\n\n    // arm\n    d = _union(d, capsuleY(p - vec3(1.2, -0.9, 0.0), 0.2, 0.7));\n    \n    EARLY_OUT\n\n    // legs\n    d = _union(d, capsuleY(p - vec3(0.4, -1.8, 0.0), 0.2, 0.5));\n\n    return d;\n}\n\nfloat lollipop(vec3 p)\n{\n    float d = capsuleY(p - vec3(0.0, -2.0, 0.0), 0.02, 2.0);\n\n    EARLY_OUT\n\n    d = _union(d, cylinderY(vec3(p.x,-p.z,p.y) - vec3(0.0, -0.1, 0.0), 0.9, 0.2)); // hand rotate by 90 in X\n    \n    return d;\n}\n\n\n// distance to scene\nfloat scene(vec3 p)\n{\n    return mix(droid(p),lollipop(p),sceneInterp());\n}\n\n// calculate scene normal\nvec3 sceneNormal( in vec3 pos, in float d )\n{\n    float eps = 0.14;\n    vec3 n;\n#if 1\n    // central difference\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;//scene( vec3(pos.x, pos.y-eps, pos.z) );\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );\n#else\n    // forward difference\n   // float d = scene( vec3(pos.x, pos.y, pos.z) );\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n#endif\n\n return normalize(dot(n,n) == 0.0 ? vec3(1.0) : n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const float delta = 0.5;\n    const float weight = 1.0;\n    const float d = 0.5 * delta; \n\n    float a = weight*(d - scene(p + n*d));    \n    \n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    const vec3 lightPos = vec3(5.0, 10.0, 5.0);\n\n    vec3 color1 = vec3(0.643, 0.776, 0.223);\n\n    vec3 p=pos;\n    float x=1.0-clamp(length(p),0.0,1.0);\n    float t=cos(sin(atan(p.y,p.x)*3.0+9.0*x+iTime*2.0)*2.0)*x;\n    float m=clamp(t,0.0,1.0);\n\n    vec3 color2 = mix(mix(vec3(1.0),vec3(1.0,0.6,0.9),clamp(x*10.0,0.0,1.0)), vec3(1.0,0.0,0.0), m+(x*x*x));\n\n    vec3 color=mix(color1,color2,sceneInterp());\n\n    vec3 specColor = mix(HORIZON_COLOR, SKY_COLOR,n.y*0.5+0.5);\n    const float shininess = 30.0;\n\n    vec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    \n    float diff = dot(n, l);\n    float spec = dot(h, n);\n\n    vec2 light = max(vec2(0.0), vec2(diff, spec));\n    light = pow(light, vec2(1.0,shininess));\n    \n    \n    diff = light.x;\n    spec = light.y;\n    diff = 0.5+0.5*diff;\n\n    float fresnel = pow(1.0 -dot(n, v), 3.0);\n    float ao = ambientOcclusion(pos, n);\n\n    //return vec3(diff) * color + vec3(spec + fresnel*0.5);\n    return diff*ao*SUN_COLOR * color + vec3(spec+fresnel) * specColor * 0.5;\n   // return vec3(ao);\n   // return vec3(fresnel);\n   // return vec3(diff);\n   //return vec3(spec*specColor);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit, out float d)\n{\n    const int maxSteps = 32;\n    hit = false;\n    vec3 pos = ro + rd;\n\n    for(int i=maxSteps; i >= 0; --i)\n    {\n        d = scene(pos);\n\n        hit = d<MIN_DISTANCE;\n        if(hit) break;\n\t\t\n        pos += d*rd;\n    }\n    return pos;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(HORIZON_COLOR, SKY_COLOR, rd.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxRes = max(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord.xy / maxRes) * vec2(2.0) - vec2(1.0);\n\t\n    // compute ray origin and direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, -2.0));\n    vec3 ro = vec3(0.0, 1.0, 7.5);\n\n   \t// move camera\n    float a;\n    a = iTime*0.5;\n    rd = rotateY(rd, a);\n    ro = rotateY(ro, a);\n\n    // trace ray\n    bool hit;\nfloat d;\n    vec3 pos = trace(ro, rd, hit, d);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // calc normal\n        vec3 n = sceneNormal(pos, d);\n        // shade\n        rgb = shade(pos, n, ro);\n\n#if 0\n        // reflection\n        vec3 v = normalize(ro - pos);\n        float fresnel = 0.1 + 0.4*pow(1.0 - dot(n, v), 5.0);\n\n        ro = pos + n*0.01; // offset to avoid self-intersection\n        rd = reflect(-v, n);\n        pos = trace(ro, rd, hit);\n\n        if (hit) {\n            vec3 n = sceneNormal(pos);\n            rgb += shade(pos, n, ro) * vec3(fresnel);\n        } else {no\n            rgb += background(rd) * vec3(fresnel);\n        }\n#endif \n\n     } else {\n        rgb = background(rd);\n     }\n\n    // vignetting\n   // rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\n    fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 561, 593, 593, 617], [619, 619, 654, 654, 678], [680, 680, 716, 741, 793], [795, 886, 935, 935, 975], [977, 977, 1007, 1007, 1091], [1093, 1093, 1124, 1124, 1152], [1154, 1175, 1217, 1217, 1276], [1278, 1401, 1466, 1466, 1722], [1724, 1743, 1791, 1791, 1884], [1886, 1886, 1929, 1929, 2128], [2130, 2144, 2175, 2175, 2318], [2320, 2320, 2351, 2351, 2500], [2502, 2502, 2537, 2537, 2651], [2653, 2653, 2675, 2675, 2764], [2766, 2766, 2787, 2787, 3448], [3450, 3450, 3474, 3474, 3681], [3684, 3705, 3726, 3726, 3780], [3782, 3808, 3853, 3853, 4504], [4506, 4541, 4581, 4581, 4766], [4768, 4780, 4823, 4823, 6009], [6011, 6045, 6102, 6102, 6342], [6344, 6344, 6370, 6370, 6421], [6423, 6423, 6480, 6480, 7668]], "test": "untested"}
{"id": "lll3z4", "name": "Gardner Cos Clouds", "author": "fab", "description": "A simple 2D cloud pattern algorithm. Poorly suited for large sky textures, but does a fair job if seen through a small enough aperture.", "tags": ["2d", "clouds"], "likes": 1, "viewed": 444, "published": "Public", "date": "1419443093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Gardner Cos Clouds\n *\n * Translated/adapted from the RenderMan implementation in\n * Texturing & Modeling; a Procedural Approach (3rd ed, p. 50)\n *\n * This technique seeks to avoid visible pattern redundancy\n * by shifting the frequencies and phase several times while\n * computing the cloud density component. It fails somewhat\n * miserably as soon as you zoom out; set the ZOOM param to 0.1\n * and see for yourself.\n *\n */\n\n#define PI 3.16\n#define NTERMS 3.0\n#define ZOOM 1.0\n\nvec3 getLightPosition(){\n\treturn vec3(5.0*sin(iTime), 3, -5);    \n}\n\nvec3 getEyePosition(){\n    return vec3(0,0,-5);\n}\n\nvec4 shadePoint(vec3 pointPosition, vec4 textureColour){\n    return textureColour;\n}\n\n\nvec4 getTextureColour(vec2 fragCoord, vec2 uv){\n    float cloudDensity = 0.0;\n    float amplitude = 0.45;\n    float xphase = 0.9*iTime;\n    float yphase = 0.7;\n    float xfreq = 2.0*PI*0.023;\n    float yfreq = 2.0*PI*0.021;\n    \n    float offset = 0.5;\n    float xoffset = 37.0;\n    float yoffzet = 523.0;\n    \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    float scale = 1.0/iResolution.x * 60.0 * 1.0/ZOOM;\n    x = x*scale + offset + iTime;\n    y = y*scale + offset - iTime/2.3;\n    \n    for(float i = 0.0; i < NTERMS; i++){\n        float fx = amplitude * (offset + cos(xfreq * (x + xphase)));\n        float fy = amplitude * (offset + cos(yfreq * (y + yphase)));\n        cloudDensity += fx * fy;\n        xphase = PI/2.0 * 0.9 * cos(yfreq * y);\n        yphase = PI/2.0 * 1.1 * cos(xfreq * x);\n        amplitude *= 0.602;\n        xfreq *= 1.9 + i * .01;\n        yfreq *= 2.2 - i * 0.08;\n    }\n    \n    return mix(vec4(0.5, 0.55, 0.96, 1.0), vec4(1.0, 1.0, 1.0, 1.0), cloudDensity);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 point = vec3(fragCoord.xy, 0.0);\n\tfragColor = shadePoint(point, getTextureColour(fragCoord,uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 484, 508, 508, 551], [553, 553, 575, 575, 602], [604, 604, 660, 660, 688], [691, 691, 738, 738, 1693], [1695, 1695, 1751, 1751, 1901]], "test": "untested"}
{"id": "lls3zn", "name": "searching perfect noise", "author": "frankiezafe", "description": "trying to find a way to make a perfectly random end constant motion noise, looking like old tv with no signal", "tags": ["noise", "random", "randomness"], "likes": 2, "viewed": 103, "published": "Public", "date": "1418167441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\nconst vec2 k = vec2(23.1406926327792690,2.6651441426902251);\nfloat rnd0( vec2 uv ) {return dot(uv,k); }\nfloat rnd1( vec2 uv ) { return 1e-7 + 256. + dot(uv,k); }\nfloat rnd2( vec2 uv ) { return mod( 123456789., 1e-7 + 256. * dot(uv,k) ); }\nfloat rnd3( vec2 uv ) { return cos( mod( 123456789., 1e-7 + 256. * dot(uv,k) ) ); }\n\n// We can even tweak the formula\nfloat rnd4( vec2 uv ) { return fract( cos( mod( 1234., 1024. * dot(uv,k) ) ) ); }\nfloat rnd5( vec2 uv ) { return fract( cos( mod( 12345., 1024. * dot(uv,k) ) ) ); }\nfloat rnd6( vec2 uv ) { return fract( cos( mod( 123456., 1024. * dot(uv,k) ) ) ); }\nfloat rnd7( vec2 uv ) { return fract( cos( mod( 1234567., 1024. * dot(uv,k) ) ) ); }\nfloat rnd8( vec2 uv ) { return fract( cos( mod( 12345678., 1024. * dot(uv,k) ) ) ); }\nfloat rnd9( vec2 uv ) { return fract( cos( mod( 123456780., 1024. * dot(uv,k) ) ) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mediump vec2 uv = fragCoord.xy;\n    mediump vec2 vu = vec2( uv.y, uv.x );\n    float smallTime = iTime * rnd3(vu);\n    uv /= smallTime;\n    uv /= iResolution.xy;\n    // mediump vec2 uv = fragCoord.xy / iResolution.xy;\n    float i = rnd9(uv);\n    fragColor = vec4(i,i,i,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 168, 191, 191, 210], [211, 211, 234, 234, 268], [269, 269, 292, 292, 345], [346, 346, 369, 369, 429], [431, 464, 487, 487, 545], [546, 546, 569, 569, 628], [629, 629, 652, 652, 712], [713, 713, 736, 736, 797], [798, 798, 821, 821, 883], [884, 884, 907, 907, 970], [972, 972, 1029, 1029, 1308]], "test": "untested"}
{"id": "llsGzr", "name": "Meta Experiment 1", "author": "aiekick", "description": "Some Hazard experiment with funny Meta Shape.", "tags": ["meta", "shape"], "likes": 1, "viewed": 1090, "published": "Public API", "date": "1418231883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nprecision highp float;\n#define nblob 15.\n#define speed 0.3\nvec2 gCP(vec2 p){\n    float ratio = iResolution.x/iResolution.y;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.);// -1 0 1 x & y\n}\n//--------META PRIMITIVES-----------------------------\nfloat metaball(vec2 p, vec2 o, float r){\n    vec2 po = p-o;\n\treturn r / dot(po, po);\n}\nfloat metahole(vec2 p, vec2 o, float radius, float thick){\n    vec2 po = p-o;\n\treturn thick / dot(po+radius, po-radius);\n}\nfloat metaquad(vec2 p, vec2 o, vec2 l){\n\tvec2 po = p-o;\n    return l.x / length(max(abs(po)-l,0.0));\n}\n//--------OP------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = gCP(fragCoord.xy);\n    float t = sin(iTime*speed);\n    float tmb = abs(t)*0.5+0.4;\n \tfloat tmq = abs(t)*0.1+0.1;\n    float mbs=0.;\n    for(float i=0.; i<6.2831; i+=6.2831/nblob){\n        mbs+=metaball(uv, vec2(cos(i),sin(i))*tmb, 0.05);\n    }\n   \tfloat h1 = metahole(uv, vec2(t, 0.), 0.4, 0.4);\n\tfloat h2 = metahole(uv, vec2(-t,0.), 0.5, -0.2);\n\tfloat mq = metaquad(uv, vec2(0.), vec2(tmq));\n    float o = (h1+h2+mbs+mq)/2.3-0.3;\n    float r = mix(0.5,o, t);\n    float g = mix(1.,o, t);\n    float b = mix(1.5,o, t);\n    \n    fragColor.rgb = vec3(r, g, b)*0.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsGzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 196, 213, 213, 330], [331, 386, 426, 426, 472], [473, 473, 531, 531, 595], [596, 596, 635, 635, 698], [699, 754, 810, 810, 1386]], "test": "untested"}
{"id": "llX3Rn", "name": "Ruined Waterpaint Painting", "author": "Zartos", "description": "Waterpaint, flowing.", "tags": ["perlinnoise", "waterpaint"], "likes": 15, "viewed": 679, "published": "Public", "date": "1418036005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float RAINBOW_SPLINE_SIZE = 6.0;\n\n\n/**\n * Lookup table for rainbox colors. Workaround as GLSL does not support arrays.\n * @param i: Array index; Should be integer.\n * @return The color at the given index.\n */\nvec3 GetRainbowColor(float i){\n\tif(i == 0.0){\n\t\treturn vec3(1.0, 0.0, 0.0); // Red\n\t}\n    else if(i == 1.0){\n\t\treturn vec3(1.0, 0.5, 0.0); // Orange\n\t}\n\telse if(i == 2.0){\n\t\treturn vec3(1.0, 1.0, 0.0); // Yellow\n\t}\n\telse if(i == 3.0){\n\t\treturn vec3(0.0, 1.0, 0.0); // Green\t\n    }\n\telse if(i == 4.0){\n\t\treturn vec3(0.0, 0.0, 1.0); // Blue\t\n\t}\n\telse if (i == 5.0){\n        return vec3(0.27, 0.0, 0.51); // Purple\n\t}\n\telse if (i == 6.0){\n\t\treturn vec3(0.57, 0.0, 1.0); // Violet\t\n\t}\n\n\treturn vec3(1.0, 1.0, 1.0); // should never get here.\n}\n\n/**\n * Perform Catmull-Rom spline interpolation between support points v1 and v2.\n * @param x: Interpolation factor between v1 and v2; Range[0.0,1.0]\n * @param v0: left most control point.\n * @param v1: left support point.\n * @param v2: right support point.\n * @param v3: right most control point.\n * @return The interpolated value.\n */\nvec3 CatmullRomSpline(float x, vec3 v0, vec3 v1, vec3 v2, vec3 v3) \n{\n    // Note: this spline will go through it's support points.\n\tvec3 c2 = -.5 * v0\t\t\t\t+ 0.5 *v2;\n\tvec3 c3 = \t\tv0\t+ -2.5*v1 \t+ 2.0 *v2 + -.5*v3;\n\tvec3 c4 = -.5 * v0\t+ 1.5 *v1 \t+ -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\n\n/**\n * Evaluates the rainbox texture in UV-space using a Catmull-Rom spline.\n */\nvec3 EvaluateRainbowSpline(float x){\n    // x must be in range [0.0,1.0]\n    float scaledX = clamp(x, 0.0, 1.0) * RAINBOW_SPLINE_SIZE;\n    \n    // Determine which 'rainbox segment' we are evluating:\n    float segmentIndex = floor(scaledX);\n    \n    // Note that you evaluate between v1 and v2, using v0 and v3 as control points:\n    vec3 v0 = GetRainbowColor(segmentIndex-1.0);\n    vec3 v1 = GetRainbowColor(segmentIndex+0.0);\n    vec3 v2 = GetRainbowColor(segmentIndex+1.0);\n    vec3 v3 = GetRainbowColor(segmentIndex+2.0);\n    \n    return CatmullRomSpline(fract(scaledX), v0,v1,v2,v3);\n}\n\n\n\n/**\n * Creates a hashkey based on a 2D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash(in vec2 p){\n    // Transform 2D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec2(12.34, 56.78));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise( in vec2 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec2 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec2 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix(hash(i + vec2(0.0,0.0)), \n                    hash(i + vec2(1.0,0.0)), u.x),\n                mix(hash(i + vec2(0.0,1.0)), \n                    hash(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94)\n */\nfloat fractalSumNoise(in vec2 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 10; i++){\n        value += perlinNoise(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value;\n}\n\n\n/**\n * Creates a hashkey based on a 3D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash3(in vec3 p){\n    // Transform 3D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec3(123.45, 678.91, 234.56));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise3( in vec3 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec3 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec3 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float dx1 = mix(hash3(i + vec3(0.0,0.0,0.0)), \n                    hash3(i + vec3(1.0,0.0,0.0)), u.x);\n    float dx2 = mix(hash3(i + vec3(0.0,1.0,0.0)), \n                    hash3(i + vec3(1.0,1.0,0.0)), u.x);\n    float dy1 = mix(dx1, dx2, u.y);\n    \n    float dx3 = mix(hash3(i + vec3(0.0,0.0,1.0)), \n                    hash3(i + vec3(1.0,0.0,1.0)), u.x);\n    float dx4 = mix(hash3(i + vec3(0.0,1.0,1.0)), \n                    hash3(i + vec3(1.0,1.0,1.0)), u.x);\n    float dy2 = mix(dx3, dx4, u.y);\n    \n    return mix(dy1, dy2, u.z);\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94/2)\n */\nfloat fractalSumNoise3(in vec3 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 5; i++){\n        value += perlinNoise3(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value/2.0;\n}\n\nfloat pattern( in vec3 p )\n  {\n      vec3 q = vec3( fractalSumNoise3( p + vec3(0.0,0.0,0.0)),\n                     fractalSumNoise3( p + vec3(5.2,1.3,0.7)),\n                     fractalSumNoise3( p + vec3(6.7,2.6,1.2)));\n\n      return fractalSumNoise3( p + 4.0*q );\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // TODO: Add code to create your texture based on perline noise.\n    // Some idea's:\n    // * Start with visualizing the fractal sum and play around with the number of iterations and factors.\n    // * Experiment with coloring the noise texture based on the noise value. (Use for example a spline: https://www.shadertoy.com/view/MdBXzG)\n    // * Experiment using different coordinates in the perlinNoise function.\n    // * Experiment with creating your own hash function.\n    // * Experiment with creating a 3D animated noise texture.\n    // * Experiment with using domain warping: http://www.iquilezles.org/www/articles/warp/warp.htm\n    // * Experiment with combining raymarching and 3D solid texturing like in the marble example: https://www.shadertoy.com/view/ldjSz3\n    \n\tfragColor = vec4(pattern(vec3(5.0*uv,0.5+0.5*sin(0.3*iTime))),\n                        pattern(vec3(5.0*uv,0.5+0.5*cos(0.3*iTime))),\n                        pattern(vec3(0.5+0.5*sin(0.3*iTime),5.0*uv)),\n                        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 215, 245, 245, 753], [755, 1092, 1161, 1223, 1401], [1403, 1484, 1520, 1556, 2073], [2077, 2245, 2267, 2395, 2669], [2671, 2857, 2889, 3002, 3484], [3486, 3626, 3659, 3659, 4023], [4026, 4194, 4217, 4345, 4629], [4631, 4817, 4850, 4963, 5786], [5788, 5930, 5964, 5964, 6332], [6334, 6334, 6364, 6364, 6603], [6605, 6605, 6662, 6662, 7720]], "test": "untested"}
{"id": "llX3z7", "name": "mb-bf", "author": "brianfrench", "description": "mandelbrot test", "tags": ["2d"], "likes": 3, "viewed": 123, "published": "Public", "date": "1419978552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tm=iTime*0.3;\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float p=1./((1.-fragCoord.y/iResolution.y)+.125);\n    float x=p*(sin(tm*0.1)*0.5 + fragCoord.x / iResolution.y)*2.-1.5,\n        y=p*(sin(tm*0.13)*.5 + fragCoord.y / iResolution.y)*2.-1.,\n        t;\n    t=x;\n    \n    x=x*cos(tm) + y*sin(tm);\n    y=y*cos(tm) - t*sin(tm);\n    float a=x,b=y,m=0.;\n    int j=0;\n    for(int i=0; i<11;i++){\n        m=x*x+y*y;\n        if(m>16.){j++;continue;}\n        t=x;\n        x=x*x-y*y+a;\n        y=2.*t*y+b;\n    }\n    //fragColor=vec4(sin(x)*0.5+0.5,sin(y)*0.5+0.5,0.,1.);\n    m=log(log(m))*1.49+float(j);\n    \n    fragColor=vec4(\n        vec3(sin(x)*0.5+0.5,cos(y)*0.5+0.5,0.5-sin(m)*0.5)*(sin(m*0.2)*0.25+0.75)\n       \t,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 839]], "test": "untested"}
{"id": "llX3zr", "name": "Space Jewels", "author": "Dave_Hoskins", "description": "Uses a stack of 8 samples on each pixel to render the fractal. Please watch in full-screen if your GPU is up to it!! :)\nIt uses near field out of focus effects.", "tags": ["3d", "raymarching", "antialiasing", "dof", "kleinian", "spacejewels", "soundcloud"], "likes": 46, "viewed": 3961, "published": "Public API", "date": "1417882206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Space Jewels. December 2014\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/llX3zr\n\n//--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(0.07, 0.05, 0.05)\n#define MOD2 vec2(443.8975,397.2973)\n\nvec3 CSize;\nvec4 aStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\n//----------------------------------------------------------------------------------------\n// From https://www.shadertoy.com/view/4djSRW\nfloat Hash(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\t\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.z-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n\t\tfloat k = max((1.1)/(r2), .03);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(1.647,-1.0,4.9)));\n}\n\n//--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tfloat scale = 1.0;\n\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max((1.1)/(r2), .03);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) / (length(p))-.1);\n\treturn (rxy) / abs(scale);\n}\n\n\n\n//--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 6; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(7.0*h / t, res);\n\t\tt += h+.01;\n\t}\n    return max(res, 0.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n    vec3 sunLight  = normalize( vec3(  0.5, 0.2,  0.3 ) );\n\tfloat sh = Shadow(pos,  sunLight);\n    // Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    //col += mat * vec3(0.1, .0, .0)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); // Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 25.0)  * SUN_COLOUR * 1.5 *sh;\n    // Abmient..\n    col += mat * .2 * max(normal.z, 0.0);\n    col = mix(FOG_COLOUR,col, min(exp(-d*d*.05), 1.0));\n    \n\treturn col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n//--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n\tif (t< 1.4) t= (1.4-t) * 4.5;\n\tt = t*0.04;\n\treturn max(t*t, 16.0/iResolution.x);\n}\n\n//--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n    //float t = 0.0;\n\tfloat t = .1 * Hash(fcoord*fract(iTime));\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (hits == 8 || alphaAcc >= 1.0 || t > 10.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n        // Is it within the sphere?...\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t// Accumulate the alphas with the scoop of geometry from the sphere...\n            // Think of it as an expanding ice-cream scoop flying out of the camera! \n\t\t\tfloat alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);\n\t\t\t// put it on the 2 stacks, alpha and distance...\n\t\t\taStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;\n\t\t\taStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n\t\t\tdStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\talphaAcc += alpha;\n\t\t\thits++;\n\t\t}\n\t\tt +=  h*.85+t*.001;\n        \n\t}\n\t\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t// Then...\n\t#define CONTRAST 1.3\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t// Vignette...\n\trgb *= .5+0.5*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n//--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel0, pos*.1, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-13.0 +3.4 * sin(t),-0.+4.5 * cos(t),-1.1+.3 * sin(2.3*t+2.0) );\n\treturn p;\n} \n    \n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n    // Animate...\n    CSize = vec3(.808, .99-sin((gTime+35.0)*.5)*.3, 1.151-sin((gTime+16.0)*.78)*.3);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime + 0.0);\n\tvec3 camTarget \t= vec3 (-12., .0, -2.0);\n\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir);\n\t\n    \n    // Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            float d = dStack[s][i];\n            if (d < 0.0) continue;\n            float sphereR = SphereRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 alb = Albedo(pos, normal);\n            col += DoLighting(alb, pos, normal, dir, d)* aStack[s][i];\n        }\n    }\n    // Fill in the rest with fog...\n   col += FOG_COLOUR *  (1.0-alpha);\n   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XsSGRD", "previewfilepath": "https://soundcloud.com/in-an-electronic-way-1/arrival", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/in-an-electronic-way-1/arrival", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3zr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[432, 569, 589, 589, 675], [677, 768, 790, 790, 1060], [1062, 1140, 1161, 1161, 1478], [1482, 1559, 1598, 1598, 1781], [1783, 1860, 1947, 1947, 2488], [2491, 2568, 2607, 2607, 2805], [2807, 2884, 2916, 2916, 3000], [3002, 3079, 3116, 3137, 4086], [4089, 4166, 4203, 4222, 4569], [4571, 4648, 4701, 4701, 4888], [4890, 4967, 5000, 5000, 5094], [5097, 5174, 5202, 5202, 5298], [5306, 5383, 5440, 5440, 6800]], "test": "untested"}
{"id": "llXGR4", "name": "Antialiasing (sort of)", "author": "iq", "description": "More worms like in [url=https://www.shadertoy.com/view/XsjXR1]XsjXR1[/url], but edge-antialiased (more or less)", "tags": ["procedural", "3d", "raymarching", "distancefield", "antialias", "conetracing"], "likes": 198, "viewed": 14433, "published": "Public API", "date": "1418975438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2014 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// An edge antialising experiment (not multisampling used)\n\n#define ANTIALIASING\n\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa-ba*h ), h );\n}\n\nvec3 opU( vec3 d1, vec3 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 map( vec3 p )\n{\n    vec2 id = floor( (p.xz+1.0)/2.0);\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    \n    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));\n    \n    p.xz += 0.5*sincos(1.0+0.5*iTime+(p.y+11.0*ph)*0.8);\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iTime+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);\n    \n    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment(p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment(p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    \n    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0/3.0, h1.y), \n                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iTime*4.0), ph + 1.0/3.0, h2.y) ), \n                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0/3.0, h3.y) );\n}\n\n//-------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float dt )\n{\n    vec2 e = vec2(1.0,-1.0)*dt;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.15;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.5*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d);\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\n//-------------------------------------------------------\nvec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )\n{\n    float px = 0.0001;//(2.0/iResolution.y)*(1.0/3.0);\n    float eps = px*t;\n\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, eps );\n    float occ = calcOcc( pos, nor );\n\n    vec3 col = 0.5 + 0.5*cos( m*vec3(1.4,1.2,1.0) + vec3(0.0,1.0,2.0) );\n    col += 0.05*nor;\n    col = clamp( col, 0.0, 1.0 );\n    col *= 1.0 + 0.5*nor.x;\n    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);\n    col *= 1.4;\n    col *= occ;\n    col *= exp( -0.15*t );\n    col *= 1.0 - smoothstep( 15.0, 35.0, t );\n    \n    return col;\n}\n\n//-------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n\tvec3 ro = 0.6*vec3(2.0,-3.0, 4.0);\n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 1.0;\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(1.0,0.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n    float px = (2.0/iResolution.y)*(1.0/fl);\n    \n    vec3 col = vec3(0.0);\n\n    //---------------------------------------------\n    // raymach loop\n    //---------------------------------------------\n    const float maxdist = 32.0;\n\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    #ifdef ANTIALIASING\n    vec3 oh = vec3(0.0);\n    vec4 tmp = vec4(0.0);\n    #endif\n    \n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map( ro + t*rd );\n        float th1 = px*t;\n        #ifndef ANTIALIASING\n        th1 *= 1.5;\n        #endif\n        res = vec3( t, h.yz );\n        if( h.x<th1 || t>maxdist ) break;\n\n        \n        #ifdef ANTIALIASING\n        float th2 = px*t*2.0;\n        if( (h.x<th2) && (h.x>oh.x) )\n        {\n            float lalp = 1.0 - (h.x-th1)/(th2-th1);\n            vec3  lcol = shade( t, oh.y, oh.z, ro, rd );\n            tmp.xyz += (1.0-tmp.w)*lalp*lcol;\n            tmp.w   += (1.0-tmp.w)*lalp;\n            if( tmp.w>0.99 ) break;\n        }\n        oh = h;\n        #endif\n        \n        t += min( h.x, 0.5 )*0.5;\n    }\n    \n    if( t < maxdist )\n        col = shade( res.x, res.y, res.z, ro, rd );\n    \n    #ifdef ANTIALIASING\n\tcol = mix( col, tmp.xyz/(0.001+tmp.w), tmp.w );\n    #endif\n \n    //---------------------------------------------\n    \n    col = pow( col, vec3(0.5,0.7,0.5) );\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXGR4.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[642, 724, 748, 748, 781], [783, 783, 834, 834, 956], [958, 958, 988, 988, 1020], [1022, 1022, 1042, 1042, 1947], [1949, 2008, 2053, 2053, 2250], [2252, 2252, 2295, 2295, 2632], [2634, 2692, 2766, 2766, 3280], [3282, 3341, 3398, 3398, 5198]], "test": "untested"}
{"id": "lsjSDd", "name": "Light dot cylinder", "author": "Nrx", "description": "Simple mapping of light dots over a cylinder.", "tags": ["light", "cylinder", "dot"], "likes": 11, "viewed": 742, "published": "Public API", "date": "1417505818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t1.2\n#define DOT_COUNT\t\t\t100.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t3.14159265359\n\n// PRNG\nfloat rand (in vec2 seed) {\n\treturn fract (sin (dot (seed, vec2 (12.9898, 78.233))) * 137.5453);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH);\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Define the number of rows\n\tfloat dotRowCount = floor (20.0 + 60.0 * soundTreble * soundBass) * 2.0;\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = cos (iTime * 2.0);\n\tfloat pitchAngle = 2.0 * PI * cos (iTime * 0.2 + soundTreble * 0.4);\n\t#ifdef MOUSE\n\tyawAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * (1.0 - iMouse.y / iResolution.y);\n\t#endif\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the position of the camera\n\tfloat cameraDist = -2.0 * (cos (iTime) * cos (iTime * 3.5) + soundBass);\n\tvec3 cameraPosition = cameraOrientation [2] * cameraDist;\n\n\t// Compute the intersection point (ray / cylinder)\n\tfloat a = dot (ray.xz, ray.xz);\n\tfloat b = dot (cameraPosition.xz, ray.xz);\n\tfloat c = b * b - a * (dot (cameraPosition.xz, cameraPosition.xz) - 1.0);\n\tfloat ok = step (0.0, c);\n\tc = sqrt (c);\n\tvec3 hit;\n\tif (b < -c) {\n\t\thit = cameraPosition - ray * (b + c) / a;\n\t\tif (abs (hit.y * DOT_COUNT / PI + 1.0) > dotRowCount) {\n\t\t\thit = cameraPosition - ray * (b - c) / a;\n\t\t}\n\t} else {\n\t\thit = cameraPosition - ray * (b - c) / a;\n\t}\n\tvec2 frag = vec2 ((atan (hit.z, hit.x) + PI) * DOT_COUNT, hit.y * DOT_COUNT + PI) / (2.0 * PI);\n\n\t// Compute the fragment color\n\tvec2 id = floor (frag);\n\tfloat random = rand (id);\n\tvec3 color = hsv2rgb (vec3 (iTime * 0.05 + id.y * 0.005, 1.0, 1.0));\n\tcolor += 0.5 * cos (random * vec3 (1.0, 2.0, 3.0));\n\tcolor *= smoothstep (0.5, 0.1, length (fract (frag) - 0.5));\n\tcolor *= 0.5 + 1.5 * step (0.9, cos (random * iTime * 5.0));\n\tcolor *= 0.5 + 0.5 * cos (random * iTime + PI * 0.5 * soundTreble);\n\tcolor *= smoothstep (dotRowCount, 0.0, (abs (id.y + 0.5) - 1.0) * 2.0);\n\tfragColor = vec4 (color * ok, 1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 169, 196, 196, 267], [269, 283, 311, 311, 646], [648, 665, 721, 772, 3192]], "test": "untested"}
{"id": "lsSXzt", "name": "boksit 3", "author": "janneasdf", "description": "lots of boxes", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 136, "published": "Public", "date": "1419792178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//vec3 ambientLight = vec3(.2 + .2 * sin(iTime), .2 + .2 * cos(iTime), 0.2) * .2;\nvec3 ambientLight = vec3(0.0);\nvec3 dirLightColor = vec3(0.5, 0.5, 0.5) * 3.0;\nvec3 dirLightDir;\nfloat c = 2.;\nfloat r = 0.05;\nvec3 b = vec3(0.5);\n\nfloat dBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\nfloat map(vec3 p)\n{\n    float dist = b.x;\n    vec2 texcoords = mod(floor(p.xz / c), 256.) / 256.;\n    //p.y += 6.0 * texture(iChannel0, texcoords).x;\n    vec3 q = vec3(\n        mod(p.x, c) - 0.5 * c,\n        p.y,\n        //mod(p.y, c) - 0.5 * c,\n        mod(p.z, c) - 0.5 * c);\n    return dBox(q, b);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float threshold = 0.001;\n\tvec2 t = vec2(0.0, threshold);\n    vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),\n           \t  map(pos + t.xyx) - map(pos - t.xyx),\n              map(pos + t.xxy) - map(pos - t.xxy));\n    return normalize(n);\n}\n\nbool getDepth(vec3 rayPos, vec3 rayDir, inout float depth)\n{\n    const int max_iters = 128;\n    float phase = (.5 + .5 * sin(iTime));\n    float eps = 0.0005;\n    vec3 p = rayPos;\n    float d;\n    float d_total = 0.0;\n    for (int i = 0; i < max_iters; ++i)\n    {\n        d = map(p);\n        d_total += d;\n        p += d * rayDir;\n        if (d < eps)\n            break;\n    }\n    depth = d_total;\n    return d < eps;\n}\n\nbool intersect(vec3 rayPos, vec3 rayDir, inout vec3 color, inout vec3 normal)\n{\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    \n    float depth;\n    bool hit = getDepth(rayPos, rayDir, depth);\n    \n    normal = vec3(0.0);\n    vec3 hitPoint = rayPos + depth * rayDir;\n    if (hit)\n    {\n        normal = getNormal(hitPoint);\n        //vec3 kd = vec3(0.1, 0.1, 0.1);\n        vec3 kd;\n        float dotX = abs(dot(normal, vec3(1.0, 0.0, 0.0)));\n        float dotY = abs(dot(normal, vec3(0.0, 1.0, 0.0)));\n        float dotZ = abs(dot(normal, vec3(0.0, 0.0, 1.0)));\n        float maxDot = max(dotX, max(dotY, dotZ));\n        if (maxDot == dotX)\n            kd = texture(iChannel1, hitPoint.yz).xyz;\n        else if (maxDot == dotY)\n            kd = texture(iChannel1, hitPoint.xz).xyz;\n        else\n            kd = texture(iChannel1, hitPoint.xy).xyz;\n            \n        vec3 ka = ambientLight;\n        color = ka + kd * dirLightColor * max(dot(normal, -dirLightDir), 0.0);\n        color /= depth * 0.3;\n        return true;\n    }\n    else\n    {\n\t    color = bg;\n        normal = vec3(0.0);\n        return false;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    dirLightDir = normalize(vec3(sin(iTime), -0.3, 1.0));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    vec3 camPos = vec3(2.0 + cos(iTime), 3.0, -10. + 0.2 * sin(iTime));\n    vec3 camTarget = vec3(0., 0., 10.);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    float zNear = 0.0;\n    rayPos += zNear * rayDir;\n    \n    vec3 c;\n    vec3 n;\n    bool hit = intersect(rayPos, rayDir, c, n);\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 230, 258, 258, 357], [359, 359, 378, 378, 661], [663, 663, 689, 689, 935], [937, 937, 997, 997, 1355], [1357, 1357, 1436, 1436, 2473], [2475, 2475, 2532, 2532, 3294]], "test": "untested"}
{"id": "ltf3R8", "name": "Static Shadow", "author": "Steel_Neuron", "description": "I wanted to learn how to do 2d shadows, and played a bit with static-looking noise. Hopefully it looks half-decent! I'm not sure how to anti-aliasing with anything other than circles and rectangles, but that's next on the list :)", "tags": ["2d", "shadows", "static"], "likes": 4, "viewed": 341, "published": "Public", "date": "1418423894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AAS 0.02\n#define PI 3.14159265359\n#define TRIANGLE_NUMBER 6\n\n//#define MOUSE\n\nstruct triangle_t{\n\tvec2 a;\n   \tvec2 b;\n    vec2 c;\n};\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//returns the pseudo-cross product in two dimensions.\nfloat cross2(vec2 v1, vec2 v2){\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n\nfloat direction(vec2 p1, vec2 p2, vec2 p3){\n\treturn cross2(p3-p1,p2-p1);\n\n}\n\n//returns 1.0 if the segments a and b intersect strictly.\nfloat intersect(vec2 a1, vec2 a2, vec2 b1, vec2 b2){\n    \n    float d1 = direction(b1,b2,a1);\n    float d2 = direction(b1,b2,a2);\n    float d3 = direction(a1,a2,b1);\n    float d4 = direction(a1,a2,b2);\n    \n\tif ( (((d1 > 0.0) && (d2 < 0.0)) || ((d1 < 0.0) && (d2 > 0.0))) &&\n        (((d3 > 0.0) && (d4 < 0.0)) || ((d3 < 0.0) && (d4 > 0.0))) ){\n    \treturn 1.0;\n    }\n    \n    return 0.0;\n}\n\n\n\nfloat inside_tri (vec2 p, triangle_t t){\n\t\n    float ca = cross2(t.a-t.b,t.a-p);\n    float cb = cross2(t.b-t.c,t.b-p);\n    float cc = cross2(t.c-t.a,t.c-p);\n        \n    float sa = sign(ca);\n    float sb = sign(cb);\n    float sc = sign(cc);\n        \n    if((sa == sb) && (sb == sc)){\n    \treturn 1.0;\n    };\n    \n    return 0.0;\n                                      \n\t\n}\n\nvec2 rotate(vec2 p, float angle){\n\treturn vec2(cos(angle)*p.x+sin(angle)*p.y,\n                -sin(angle)*p.x+cos(angle)*p.y);\n\n}\n\ntriangle_t rotate(triangle_t t, float angle){\n\ttriangle_t ret;\n    ret.a = rotate(t.a,angle);\n    ret.b = rotate(t.b,angle);\n    ret.c = rotate(t.c,angle);\n    \n    return ret;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n    float ar = iResolution.x / iResolution.y;\n    vec2 r =  vec2(uv.x * ar,uv.y);\n    vec2 mouse = vec2(-1.0 + 2.0*iMouse.xy / iResolution.xy);\n    \n#ifdef MOUSE    \n    \n    vec2 mouser = vec2(mouse.x * ar,mouse.y);\n    \n#else    \n    vec2 mouser = vec2 (cos(0.89*iTime),0.8*sin(0.5*iTime));\n     \n#endif    \n    \n    float staticn = rand(r*cos(iTime));\n    float staticn2 = rand(r*sin(iTime));\n\n    triangle_t triangles[TRIANGLE_NUMBER];\n    \n        \n    triangles[0].a = vec2(-ar/2.0,0.0);\n    triangles[0].b = vec2(-ar/2.0 + 0.4,0.0);\n    triangles[0].c = vec2(-ar/2.0 + 0.2,sqrt(0.4)/2.0);\n    \n    triangles[0] = rotate(triangles[0],0.2*iTime);\n    for(int i = 1;i<TRIANGLE_NUMBER;i++){\n    \ttriangles[i] = rotate(triangles[i-1],2.0*PI/float(TRIANGLE_NUMBER));\n\n    }\n    \n    \n    vec2 lightpos = mouser;\n    \n    float shade = 0.0;\n\n    for(int i = 0;i<TRIANGLE_NUMBER;i++){\n\t\tshade += intersect(triangles[i].a,triangles[i].b,lightpos,r);\n        shade += intersect(triangles[i].a,triangles[i].c,lightpos,r); \n        shade += intersect(triangles[i].b,triangles[i].c,lightpos,r);        \n        \n    }\n\n    \n    \n    float shape = 0.0;\n    float lightshape = 0.0;\n\n    for(int i = 0;i<TRIANGLE_NUMBER;i++){\n        float s = inside_tri(r,triangles[i]);\n        shape += s;\n        \n        if (s > 0.5){\n        \tlightshape += inside_tri(mouser,triangles[i]);\n        }\n    }\n\n    \n\n    \n    \n    float col = 0.6 + 0.2*(1.0-length(r));\n    col +=1.0- smoothstep(0.0,staticn/3.0,length(mouser-r));\n    col += 0.5 -clamp(length(mouser-r)*5.0,0.0,0.5);\n    col += 0.2 - clamp(length(mouser-r)/2.0,0.0,0.2);\n    \n    if (shade > 0.5) col = staticn;\n    if (shape > 0.5) col = staticn*staticn2;\n    if (lightshape > 0.5) col = 1.0;\n    \n   \n\n    fragColor=vec4(vec3(col),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltf3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 142, 162, 162, 234], [236, 290, 321, 321, 357], [360, 360, 403, 403, 435], [437, 495, 547, 547, 885], [889, 889, 929, 929, 1260], [1262, 1262, 1295, 1295, 1391], [1393, 1393, 1438, 1438, 1576], [1580, 1580, 1637, 1637, 3481]], "test": "untested"}
{"id": "ltfGRN", "name": "Oilspill", "author": "daeken", "description": "Just messing around with raymarching refractive terrain.", "tags": ["raymarching", "shaderforth"], "likes": 4, "viewed": 215, "published": "Public", "date": "1419117612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m , ;\n\n: rotationmat ( axis:vec3 angle:float -> mat4 )\n\taxis normalize =axis\n\tangle sin =s\n\tangle cos =c\n\t1 c - =>oc\n\n\t[\n\t\toc axis .x * axis .x * c +           , oc axis .x * axis .y * axis .z s * - , oc axis .z * axis .x * axis .y s * + , 0\n\t\toc axis .x * axis .y * axis .z s * + , oc axis .y * axis .y * c +           , oc axis .y * axis .z * axis .x s * - , 0\n\t\toc axis .z * axis .x * axis .y s * - , oc axis .y * axis .z * axis .x s * + , oc axis .z * axis .z * c +           , 0\n\t\t0                                    , 0                                    , 0                                    , 1\n\t]m\n;\n\n:m rotate ( p axis angle ) [ p 1 ] axis angle rotationmat * .xyz ;\n\n:m sphere ( p s ) p length s - ;\n:m torus ( p t ) [ p .xy length t .x - p .z ] length t .y - ;\n: box ( p:vec3 b:vec3 -> float )\n\tp abs b - =d\n\td \\max 0 min\n\td 0 max length +\n;\n: cyl ( p:vec3 s:vec2 -> float )\n\t( p .xz s .xx - length s .y - )\n\t\t\tp .xz length s .x -\n\t\t\tp .y neg s .y -\n\t\tmax\n\t\tp .y s .y -\n\tmax\n;\n:m plane ( p n ) p n .xyz dot n .w + ;\n\n:m union \\min ;\n:m hitunion \\{ ( $a $b ) a b a .distance b .distance < select } ;\n:m subtract \\{ ( d1 d2 ) d1 neg d2 max } ;\n:m intersect \\max ;\n:m repeat ( block p c ) p c mod 0.5 c * - *block ;\n\n:m time iTime ;\n\n:m tx ( p t ) p [ t 0 0 ] + ;\n:m ty ( p t ) p [ 0 t 0 ] + ;\n:m tz ( p t ) p [ 0 0 t ] + ;\n\n:struct hit\n\t@float =distance\n\t@float =material\n;\n\n:struct marched\n\t@float =distance\n\t@float =obj-distance\n\t@vec3 =origin\n\t@vec3 =pos\n\t@float =material\n\t@vec3 =color\n;\n\n: morph ( p:vec3 dim:vec2 v:float -> float )\n\t\tp dim .xyx box\n\t\tp dim cyl\n\t\tv\n\tmix\n;\n\n: scene ( p:vec3 -> hit )\n\t[\n\t\tp .xz iTime + snoise-2d .05 * p .y .05 + - abs\n\t\tp .x 10 * sin p .z 15 * sin + iTime 5 * +\n\t] hit\n;\n\n:struct material\n\t@vec4 =color\n\t@float =ambient\n\t@float =diffuse\n\t@float =specular\n\t@float =reflection\n\t@float =refraction\n;\n\n: get-material ( id:float -> material )\n\t[\n\t\t[ [ id 360 5 / * 1 1 ] hsv->rgb 1 ]\n\t\t.3 1 1 10 5\n\t] material\n;\n\n:m getnormal ( p )\n\t[\n\t\tp eps     tx scene .distance\n\t\tp eps neg tx scene .distance -\n\t\tp eps     ty scene .distance\n\t\tp eps neg ty scene .distance -\n\t\tp eps     tz scene .distance\n\t\tp eps neg tz scene .distance -\n\t] normalize\n;\n\niResolution frag->position =pos\n\n3 =>focus\n:m far 20 ;\n:m close 0.01 ;\n\n[ 0 0 5 ] =origin\n[ 0 0 0 ] =>ct\n\nct origin - normalize =>cd\n[ 0 0.5 0 ] =cu\ncd cu cross =>cs\ncs pos .x * cu pos .y * + cd focus * + normalize =dir\n\n[ 0 0 0 ] =c\n\n: shade ( cur:marched normal:vec3 level:float -> vec4 )\n\tcur .pos =>ray\n\n\t[ 0 1 -5 ] =>lightpos\n\t[ 1 1 1 ] =>lightcolor\n\tlightpos ray - normalize =ivec\n\tivec normal dot 0 max =incidence\n\tlightcolor incidence * =>diffuse\n\t0.1 =>ambient\n\n\tcur .material get-material =mat\n\n\t0 =specular\n\t{\n\t\tivec cur .origin + normalize normal dot\n\t\t0 max mat .specular pow\n\t\tlightpos ray - length / =specular\n\t} mat .specular 0 != incidence 0 > and when\n\n\t[ mat .color .rgb.a * diffuse mat .diffuse * ambient mat .ambient * + specular + * level mat .reflection pow * mat .reflection ]\n;\n\n: skip-bulk ( ray:vec3 dir:vec3 mat:float -> vec3 )\n\t{\n\t\tray scene =cur\n\t\tray dir cur .distance 0.05 max * + =ray\n\t\t{ break } cur .distance 0.01 > cur .material mat != or when\n\t} #100 times\n\tray\n;\n\n: march ( ray:vec3 dir:vec3 -> marched )\n\tray =origin\n\t0 =dist\n\t[ 0 0 0 ] =color\n\t1 =trans\n\t{\n\t\tray scene =cur\n\t\tdist cur .distance + far min =dist\n\t\tray dir cur .distance * + =ray\n\n\t\t{ break } dist far >= when\n\n\t\tcur .material get-material =mat\n\t\t{\n\t\t\t{ break }\n\t\t\t{\n\t\t\t\tray getnormal =normal\n\t\t\t\t{\n\t\t\t\t\tdir normal reflect normalize =rdir\n\t\t\t\t\tray dir cur .distance * + =rorigin\n\t\t\t\t\trorigin dir march-one color + =color\n\t\t\t\t} mat .reflection 0 > when\n\t\t\t\t[ dist cur .distance origin ray cur .material color ] marched =>cm\n\t\t\t\tcm normal 1 shade =>shaded\n\t\t\t\tshaded .rgb trans * color + =color\n\t\t\t\tmat .color .a trans * =trans\n\t\t\t\tdir normal 1 mat .refraction / refract =dir\n\t\t\t\tray dir cur .material skip-bulk =ray\n\t\t\t\tdir normal mat .refraction refract =dir\n\t\t\t} mat .refraction 0 == if\n\t\t} cur .distance close < when\n\t} #50 times\n\t[\n\t\tdist far cur .distance close < select\n\t\tcur .distance\n\t\torigin\n\t\tray\n\t\tcur .material\n\t\tcolor\n\t] marched\n;\n\n: march-one ( ray:vec3 dir:vec3 -> vec3 )\n\tray =origin\n\t0 =dist\n\t[ 0 0 0 ] =color\n\t{\n\t\tray scene =cur\n\t\tdist cur .distance + far min =dist\n\t\tray dir cur .distance * + =ray\n\n\t\t{ break } dist far >= when\n\t\t{ break } cur .distance close < when\n\t} #10 times\n\t[\n\t\tdist far cur .distance close < select\n\t\tcur .distance\n\t\torigin\n\t\tray\n\t\tcur .material\n\t\tcolor\n\t] marched =mcur\n\t{\n\t\tray getnormal =normal\n\t\tmcur normal 0.9 shade =shaded\n\t\tshaded .rgb =color\n\t} cur .distance far < when\n\tcolor\n;\n\n#10 =>iters\n{\n\tfloat iters float / 1 swap - =level\n\n\torigin dir march =cur\n\tc cur .color + =c\n\n\t{\n\t\tcur .pos getnormal =normal\n\t\tcur normal level shade =shaded\n\t\tc shaded .rgb + =c\n\n\t\t{\n\t\t\tdir normal reflect normalize =dir\n\t\t\tcur .pos dir cur .obj-distance * + =origin\n\t\t} {\n\t\t\tbreak\n\t\t} shaded .w 0 != if\n\t} {\n\t\tbreak\n\t} cur .distance far < if\n} iters times\n\nc ->fragcolor\n*/\n\nstruct marched {\n\tfloat distance;\n\tfloat obj_distance;\n\tvec3 origin;\n\tvec3 pos;\n\tfloat material;\n\tvec3 color;\n};\nstruct material {\n\tvec4 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat reflection;\n\tfloat refraction;\n};\nstruct hit {\n\tfloat distance;\n\tfloat material;\n};\nvec3 snoise_permute(vec3 x) {\n\treturn mod((x * 34. + 1.) * x, 289.);\n}\nfloat snoise_2d(vec2 v) {\n\tvec4 C = vec4(.211324865405187, .366025403784439, -.577350269189626, .024390243902439);\n\tvec2 i = floor(dot(v, C.yy) + v);\n\tvec2 x0 = v - i + dot(i, C.xx);\n\tvec2 i1 = x0.x > x0.y ? vec2(1., 0.) : vec2(0., 1.);\n\tvec4 x12 = x0.xyxy + C.xxzz - vec4(i1, 0., 0.);\n\ti = mod(i, 289.);\n\tvec3 p = snoise_permute(snoise_permute(vec3(0., i1.y, 1.) + i.y) + i.x + vec3(0., i1.x, 1.));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n\tm = m * m * m * m;\n\tvec3 x = 2. * fract(p * C.www) - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 ox = floor(x + .5);\n\tvec3 a0 = x - ox;\n\tm = (1.79284291400159 - .85373472095314 * (a0 * a0 + h * h)) * m;\n\treturn dot(m, vec3(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw)) * 130.;\n}\nhit scene(vec3 p) {\n\treturn hit(abs(snoise_2d(p.xz + iTime) * .05 - (p.y + .05)), sin(p.x * 10.) + sin(p.z * 15.) + iTime * 5.);\n}\nvec3 skip_bulk(vec3 ray, vec3 dir, float mat) {\n\tray;\n\tfor(int temp_16 = 0; temp_16 < 100; ++temp_16) {\n\t\thit cur = scene(ray);\n\t\tray = ray + dir * max(cur.distance, .05);\n\t\tif(cur.distance > .01 || cur.material != mat) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ray;\n}\nvec3 hsv_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nmaterial get_material(float id) {\n\treturn material(vec4(hsv_rgb(vec3(id * 72., 1., 1.)), 1.), .3, 1., 1., 10., 5.);\n}\nvec4 shade(marched cur, vec3 normal, float level) {\n\tfloat specular;\n\tvec3 ivec = normalize(vec3(0., 1., -5.) - cur.pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tmaterial mat = get_material(cur.material);\n\tspecular = 0.;\n\tif(mat.specular != 0. && incidence > 0.) {\n\t\tspecular = pow(max(dot(normalize(ivec + cur.origin), normal), 0.), mat.specular) / length(vec3(0., 1., -5.) - cur.pos);\n\t}\n\treturn vec4(mat.color.rgb * mat.color.a * (vec3(1., 1., 1.) * incidence * mat.diffuse + .1 * mat.ambient + specular) * pow(level, mat.reflection), mat.reflection);\n}\nvec3 march_one(vec3 ray, vec3 dir) {\n\thit cur;\n\tfloat dist;\n\tray;\n\tvec3 color;\n\tvec3 origin = ray;\n\tdist = 0.;\n\tcolor = vec3(0., 0., 0.);\n\tfor(int temp_7 = 0; temp_7 < 10; ++temp_7) {\n\t\tcur = scene(ray);\n\t\tdist = min(dist + cur.distance, 20.);\n\t\tray = ray + dir * cur.distance;\n\t\tif(dist >= 20.) {\n\t\t\tbreak;\n\t\t}\n\t\tif(cur.distance < .01) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tmarched mcur = marched(cur.distance < .01 ? dist : 20., cur.distance, origin, ray, cur.material, color);\n\tif(cur.distance < 20.) {\n\t\tvec3 normal = normalize(vec3(scene(ray + vec3(.00001, 0., 0.)).distance - scene(ray + vec3(-.00001, 0., 0.)).distance, scene(ray + vec3(0., .00001, 0.)).distance - scene(ray + vec3(0., -.00001, 0.)).distance, scene(ray + vec3(0., 0., .00001)).distance - scene(ray + vec3(0., 0., -.00001)).distance));\n\t\tvec4 shaded = shade(mcur, normal, .9);\n\t\tcolor = shaded.rgb;\n\t}\n\treturn color;\n}\nmarched march(vec3 ray, vec3 dir) {\n\tvec3 color;\n\thit cur;\n\tfloat dist;\n\tray;\n\tvec3 origin = ray;\n\tdist = 0.;\n\tcolor = vec3(0., 0., 0.);\n\tfloat trans = 1.;\n\tfor(int temp_9 = 0; temp_9 < 50; ++temp_9) {\n\t\tcur = scene(ray);\n\t\tdist = min(dist + cur.distance, 20.);\n\t\tray = ray + dir * cur.distance;\n\t\tif(dist >= 20.) {\n\t\t\tbreak;\n\t\t}\n\t\tmaterial mat = get_material(cur.material);\n\t\tif(cur.distance < .01) {\n\t\t\tif(mat.refraction == 0.) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tvec3 normal = normalize(vec3(scene(ray + vec3(.00001, 0., 0.)).distance - scene(ray + vec3(-.00001, 0., 0.)).distance, scene(ray + vec3(0., .00001, 0.)).distance - scene(ray + vec3(0., -.00001, 0.)).distance, scene(ray + vec3(0., 0., .00001)).distance - scene(ray + vec3(0., 0., -.00001)).distance));\n\t\t\t\tif(mat.reflection > 0.) {\n\t\t\t\t\tvec3 rdir = normalize(reflect(dir, normal));\n\t\t\t\t\tvec3 rorigin = ray + dir * cur.distance;\n\t\t\t\t\tcolor = march_one(rorigin, dir) + color;\n\t\t\t\t}\n\t\t\t\tcolor = shade(marched(dist, cur.distance, origin, ray, cur.material, color), normal, 1.).rgb * trans + color;\n\t\t\t\ttrans = mat.color.a * trans;\n\t\t\t\tdir = refract(dir, normal, 1. / mat.refraction);\n\t\t\t\tray = skip_bulk(ray, dir, cur.material);\n\t\t\t\tdir = refract(dir, normal, mat.refraction);\n\t\t\t}\n\t\t}\n\t}\n\treturn marched(cur.distance < .01 ? dist : 20., cur.distance, origin, ray, cur.material, color);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 c;\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec3 origin = vec3(0., 0., 5.);\n\tvec3 cu = vec3(0., .5, 0.);\n\tvec3 dir = normalize(cross(normalize(vec3(0., 0., 0.) - origin), cu) * pos.x + cu * pos.y + normalize(vec3(0., 0., 0.) - origin) * 3.);\n\tc = vec3(0., 0., 0.);\n\tfor(int temp_8 = 0; temp_8 < 10; ++temp_8) {\n\t\tfloat level = 1. - float(temp_8) / 10.;\n\t\tmarched cur = march(origin, dir);\n\t\tc = c + cur.color;\n\t\tif(cur.distance < 20.) {\n\t\t\tvec3 normal = normalize(vec3(scene(cur.pos + vec3(.00001, 0., 0.)).distance - scene(cur.pos + vec3(-.00001, 0., 0.)).distance, scene(cur.pos + vec3(0., .00001, 0.)).distance - scene(cur.pos + vec3(0., -.00001, 0.)).distance, scene(cur.pos + vec3(0., 0., .00001)).distance - scene(cur.pos + vec3(0., 0., -.00001)).distance));\n\t\t\tvec4 shaded = shade(cur, normal, level);\n\t\t\tc = c + shaded.rgb;\n\t\t\tif(shaded.w != 0.) {\n\t\t\t\tdir = normalize(reflect(dir, normal));\n\t\t\t\torigin = cur.pos + dir * cur.obj_distance;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfragColor = vec4(c, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 5434, 5463, 5463, 5504], [5505, 5505, 5530, 5530, 6271], [6272, 6272, 6291, 6291, 6402], [6403, 6403, 6450, 6450, 6656], [6657, 6657, 6681, 6681, 6800], [6801, 6801, 6834, 6834, 6918], [6919, 6919, 6970, 6970, 7483], [7484, 7484, 7520, 7520, 8357], [8358, 8358, 8393, 8393, 9700], [9701, 9701, 9758, 9758, 10851]], "test": "untested"}
{"id": "ltl3RH", "name": "Material Design", "author": "okro", "description": "Wanted to animate the papers so they make a flourishing motion but lost interest.", "tags": ["material", "design"], "likes": 38, "viewed": 2508, "published": "Public", "date": "1418845716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nfloat slope(float x, float m, float b) {\n\treturn m*x + b;\n\n}\n\n\nfloat noise(vec2 uv) {\nreturn fract(sin(dot(uv.xy ,vec2(532.1231,1378.3453))) * 53211.1223);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n    vec3 topred_col = vec3(.96, 0.26, 0.25);\n    vec3 bigpurp_col = vec3(0.58, .2, .72);\n\n    vec3 midred_col = vec3(.96, 0.3, 0.38);\n    vec3 botred_col = vec3(.95, .33, 0.4);\n    vec3 bg_col = vec3(0.41, .17, .5);\n    vec3 almost_bg_col = vec3(0.48, .16, .58);\n\n   \tvec3 cyan_col = vec3(.93, .78, 1.0);\n\tvec3 whiteish_col = vec3(.95, .84, 1.0);\n    \n    float topred_mover = cos(time)/30.-.02;\n    float bigpurp_mover = cos(time)/100.-.02;\n\n    float bigpurp =smoothstep(1., 1.0001, abs(uv.y-slope(uv.x, -2., .5+bigpurp_mover)));\n    float topred =  smoothstep(1.01, 1.0, abs(uv.y - slope(uv.x, -5.2, .4+topred_mover)));\n    float midred =  smoothstep(2.5, 2.49, abs(uv.y - slope(uv.x, 17., -1.8)));\n    float botred =smoothstep(1.21, 1.2, abs(uv.y - slope(uv.x, 7., -.5)));\n    float bg = smoothstep(1., 1.01, abs(uv.y-slope(uv.x, 2., 1.)));\n    float cyan = smoothstep(2.001, 2., abs(uv.y-slope(uv.x, 3., 1.312)));\n    float white = smoothstep(2.008, 2., abs(uv.y-slope(uv.x, 2.3, 1.49)));\n    float almost_bg = smoothstep(2.01, 2., abs(uv.y-slope(uv.x, 1.8, 1.61)));\n    \n    float t = .0026;\n    float h = .013;\n    float y = .923*aspect;\n    float line =  step(length(uv.y - .13+t), t*aspect);\n    float line2 = step(length(uv.x -.923), t);\n/*\n    float hz =.908;\n    float vz = .1;\n    if (uv.x > hz && uv.x < hz+.03 && uv.y > vz && uv.y < vz+.03*aspect)\n    \tcol -= max(line, line2)*vec3(1., 0., .0);\n\n    float circle = smoothstep(.1, .09, length(vec2(uv.x*aspect, uv.y) - vec2(.923*aspect, .13)));\n\tfloat circle_shadow = smoothstep(.12, .07, length(vec2(uv.x*aspect, uv.y) - vec2(.923*aspect, .121)))/6.;\n\t*/\n    float bigpurp_shadow = smoothstep(.14+bigpurp_mover, .0, abs(uv.y-slope(uv.x, -2., 1.49-bigpurp_mover)))/13.;\n\tfloat topred_shadow = smoothstep(.2-topred_mover, .0, abs(uv.y-slope(uv.x, -5.2,1.3-topred_mover)))/2.;\n\tfloat midred_shadow = smoothstep(.06, .0, abs(uv.y-slope(uv.x, 17.,-4.32)))/3.;\n\tfloat botred_shadow = smoothstep(.04, .0, abs(uv.y-slope(uv.x, 7.,-1.7)))/3.;\n\tfloat cyan_shadow = smoothstep(.01, .0, abs(uv.y-slope(uv.x, 3.,-.699)))/3.;\n\tfloat almost_bg_shadow = smoothstep(.02, .0, abs(uv.y-slope(uv.x, 1.8,-.39)))/3.;\n\n   \n    col += bigpurp_col * bigpurp;\n    col += topred_col * topred;\n        float f = .5;\n\n    //col += vec3(1., -.1, -.5)*circle;                          \t\n\t//if (circle < f)\n      //  col -= circle_shadow;\n\n    if (bigpurp < f && topred < f) {\n        \n        col -= topred_shadow;\n        col -= bigpurp_shadow;\n        col += midred_col * midred;\n        if (midred < f) {\n            \n            col -= midred_shadow;\n            col -= bigpurp_shadow;\n            col += botred_col * botred;\n            if (botred < f) {\n                col-=botred_shadow;\n                col += cyan_col * cyan;\n            \tif (cyan < f) {\n                    col -= cyan_shadow;\n                    col += whiteish_col * white;\n                    if (white < f){\n                        col += almost_bg_col * almost_bg;\n                        if (almost_bg < f) {\n                        \tcol -= almost_bg_shadow;\n                \t\t\tcol += bg_col * bg;\n                        }\n                    }\n                }\n            }\n        }\n    }\n        \tcol += noise(uv)/18.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 59, 59, 79], [82, 82, 104, 104, 176], [178, 178, 235, 235, 3627]], "test": "untested"}
{"id": "ltlGzN", "name": "Stroked ellipse in rect", "author": "yglukhov", "description": "Draw ellipse in a quad!\nBUG: black color appears between red and green on the right side of the screen. Where does it come from? Does anyone know?", "tags": ["ellipserectstroke"], "likes": 1, "viewed": 247, "published": "Public", "date": "1419539597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 rect = vec4(0,0,iResolution); // uniform\nvec4 fillColor = vec4(1,0,0,1); // uniform\nvec4 strokeColor = vec4(0,1,0,1); // uniform\nfloat strokeWidth = abs(sin(iTime)) * 40.0; // uniform\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vertCoord = fragCoord.xy; // varying\n\n    \n    vec2 ab = rect.zw / 2.0;\n\tvec2 center = rect.xy + ab;\n    vec2 pos = vertCoord  - center;\n    pos *= pos;\n    float outerDist = dot(pos, 1.0 / (ab * ab));\n\n\tab -= strokeWidth / 2.0;\n    float innerDist = dot(pos, 1.0 / (ab * ab));\n    float outerDelta = fwidth(outerDist) * 0.8;\n    float innerDelta = fwidth(innerDist) * 0.8;\n\n    float innerAlpha = smoothstep(1.0 - innerDelta, 1.0 + innerDelta, innerDist);\n    float outerAlpha = smoothstep(1.0 - outerDelta, 1.0 + outerDelta, outerDist);\n    \n    vec4 sc = strokeColor * 1.0;//step(innerDelta, strokeWidth);\n\n    fragColor = mix(sc, vec4(1, 1, 1, 1), outerAlpha);\n\tfragColor = mix(fillColor, fragColor, innerAlpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 191, 248, 248, 973]], "test": "untested"}
{"id": "lts3R8", "name": "IQ Demo/Cycles", "author": "Slyth", "description": "watched a video of iq's to understand how the math really works behind some of this stuff. It's very interesting and fun to play around with..", "tags": ["2d"], "likes": 0, "viewed": 193, "published": "Public", "date": "1418697811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define BOBMARLEY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - vec2(0.34, 0.7);\n\t\n    vec3 col = mix(vec3(1.0, 0.4, 0.1), vec3(1.0, 0.8, 0.3), sqrt(p.y) * p.y);\n    col *= smoothstep(1.0, 0.0, length(p - vec2(sin(iTime / 3.0) / 2.0 + 0.5, cos(iTime / 3.0) / 2.0)));\n    \n    float b = smoothstep(0.4, 0.2, length(p - vec2(sin(iTime / 3.0) / 2.0 + 0.5, cos(iTime / 3.0) / 2.0)));\n    col = mix(col, vec3(1.0, 0.9, 0.3), b * sqrt(p.y));\n    \n    float r = 0.2 + 0.1 * cos(atan(q.y, q.x) * 10.0 + q.x * 20.0 + 1.0);    \n    col *= smoothstep(r, r + 0.01, length(q));\n    \n    r = 0.015 * cos(q.y * 110.0) * 0.1 + 0.015;\n    r += exp(p.y * -40.0);\n    col *= 1.0 - (1.0 - smoothstep(r, r + 0.002, abs(q.x - 0.2 * sin(q.y * 2.0)))) * (1.0 - smoothstep(0.0, 0.1, q.y));\n\n    #ifdef BOBMARLEY\n    col *= texture(iChannel0, -p*2.0).xyz * 4.0;\n    #endif\n    \n    fragColor = vec4(col, 1.0);    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lts3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 78, 78, 962]], "test": "untested"}
{"id": "ltsGz4", "name": "llamels", "author": "eiffie", "description": "Creating the creatures evolution didn't dare dream of.", "tags": ["zjoint"], "likes": 54, "viewed": 4471, "published": "Public API", "date": "1419434227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//llamels by eiffie (Z joints)\n//license: use at your own peril\n#define time iTime\n#define size iResolution\n\nfloat tim;\n\n/* for reference since the rest of the code is messy here are the joint solvers\nvec3 jsolve( vec3 a, vec3 b, float l1, float l2, vec3 rt )//from iq\n{//single joint\n\tvec3 p=b-a,q=p*(0.5+0.5*(l1*l1-l2*l2)/dot(p,p) );\n\treturn a+q+sqrt(max(0.0,l1*l1-dot(q,q)))*normalize(cross(p,rt));\n}\nvoid djsolve( vec3 a, vec3 b, vec3 l, vec3 rt, out vec3 j1, out vec3 j2 )//mod of iq's\n{//double joint\n\tfloat l2=(l.y+l.z)*sqrt(length(a-b)/(l.x+l.y+l.z));\n\tvec3 p=b-a,q=p*(0.5+0.5*(l.x*l.x-l2*l2)/dot(p,p));\n\tj1=a+q+sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(p,rt));\n\tp=b-j1;q=p*(0.5+0.5*(l.y*l.y-l.z*l.z)/dot(p,p));\n\tj2=j1+q+sqrt(max(0.0,l.y*l.y-dot(q,q)))*normalize(cross(p,rt));\n}\nvoid zjsolve( vec3 j0, vec3 j3, vec3 l, vec3 rt, out vec3 j1, out vec3 j2 )//mod of iq's\n{//Z joint, faster version\n\tfloat lx2z=l.x/(l.x+l.z),l2=l.y*lx2z;//scale to ratio of l.x to l.z and solve first joint\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-l2*l2)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\n\tj1=j0+q;j2=j3-q*(1.0-lx2z)/lx2z;//for j2 flip q and rescale to the length of l.z\n\n}*/\n\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}//from iq\n\nfloat leg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\n\tu=p-j0;q=j1-j0;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\n\tu=p-j1;q=j2-j1;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\n\tu=p-j2;q=j3-j2;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\n}\n\nfloat DE(in vec3 p){//this is discontinous and inaccurate :)\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\n\tp.y-=sin(p.x*1.3+sin(p.z*0.7))*0.125+sin(p.x*0.2+sin(p.z*0.3));//big cheat\n\tp.x-=tim*0.07;\n\tfloat dG=p.y+0.25;\n\tvec2 c=floor(p.xz);\n\tfloat sa=sin(c.x*2.0+c.y*4.5+tim*0.05)*0.15;\n\tp.xz=fract(p.xz)-vec2(0.5);\n\tfloat b=0.83-abs(p.z);\n\tp.xz+=vec2(0.125+sa,sa);\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+tim,ca=cos(a);\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\n\tfloat dL=leg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\n\tp.y-=0.03;\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\n\ta=c.x+117.0*c.y+tim;ca=cos(a);sa*=0.4;\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\n\tfloat dH=leg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\n\tdB=smin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\n\ta=max(abs(p.z),p.y)+0.05;\n\treturn min(min(dB,min(a,b)),dG);\n}\n\nfloat rnd(vec2 co){return fract(sin(dot(co,vec2(13.42,117.853)))*412.453);}\nfloat noyz(vec2 p){\n\tvec2 c=floor(p),f=fract(p),v=vec2(1.0,0.0);\n\treturn mix(mix(rnd(c),rnd(c+v.xy),f.x),mix(rnd(c+v.yx),rnd(c+v.xx),f.x),f.y);\n}\nvec3 mcol;\nfloat CE(vec3 p){\n\tfloat d=DE(p);\n\tfloat h=sin(p.x*1.3+sin(p.z*0.7))*0.125+sin(p.x*0.2+sin(p.z*0.3));\n\tp.y-=h;\n\tfloat dG=p.y+0.25;\n\tvec3 col=vec3(0.0);\n\tvec2 v;\n\tif(dG<0.01){\n\t\tcol=vec3(0.12,0.3,0.1)*(0.5+0.4*h);\n\t\tv=p.xz;\n\t}else{//llamel\n\t\tif(dG>0.03){\n\t\t\tcol=vec3(0.9,0.4,0.3);\n\t\t}\n\t\tp.x-=tim*0.07;\n\t\tv=vec2(p.x,p.z);\n\t}\n\tfloat n=noyz(v*160.0);\n\tcol+=vec3(0.3,0.3,0.0)*n;\n\tmcol+=col;\n\treturn d-n*0.004;\n}\n\nfloat shadao(vec3 ro, vec3 rd, float px){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=px*10.0;\n\tfor(int i=0;i<12;i++){\n\t\td=max(0.0,DE(ro+rd*t)*1.5);\n\t\tt+=d;\n\t\tif(d<px*2.5)return 0.0;\n\t\tres=min(res,22.0*d/t);\n\t}\n\treturn res;\n}\n\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    tim = time*5.0;\n\tvec3 ro=vec3(17.0,1.3,-1.5);\n\tvec3 dr=vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0);\n\tvec3 rd=normalize(dr);\n\tfloat px=2.5/(size.y*dot(rd,dr));\n\trd=lookat(vec3(-0.25,-0.3,0.5))*rd;\n\tvec3 col=mix(vec3(1.0,0.7,0.3),vec3(0.3,0.7,1.0),0.5+rd.y);\n\tfloat t=DE(ro)*(0.5+0.5*rnd(fragCoord.xy)),d,dm=10.0,tm;\n\tfor(int i=0;i<48;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>100.0 || d<0.00001)break;\n\t}\n\tdm=max(0.0,dm);\n\tif(dm<px*tm){\n\t\tro+=rd*tm;\n\t\tmcol=vec3(0.0);\n\t\tvec2 e=vec2(px*tm,0.0);\n\t\tfloat d0=CE(ro);\n\t\tvec3 dn=vec3(CE(ro-e.xyy),CE(ro-e.yxy),CE(ro-e.yyx));\n\t\tvec3 dp=vec3(CE(ro+e.xyy),CE(ro+e.yxy),CE(ro+e.yyx));\n\t\tmcol*=0.143;\n\t\tvec3 N=(dp-dn)/(length(dp-vec3(d0))+length(vec3(d0)-dn));\n\t\tvec3 L=normalize(vec3(-0.11,0.74,0.19)),H=normalize(L-rd);\n\t\tfloat h=max(0.001,dot(N,H)),l=max(0.001,dot(N,L)),v=max(0.001,dot(N,-rd));\n\t\tfloat shad=0.0;\n\t\tif(l>0.001)shad=shadao(ro,L,px*tm);\n\t\tshad=clamp(shad+0.1,0.0,1.0);\n\t\tvec3 scol=(mcol*vec3(0.4+0.2*h,0.5,0.6-0.2*h) + (1.5-v)*pow( h, 6.0))*shad*l;\n\t\tcol=mix(clamp(scol,0.0,1.0),col,clamp(1.0-exp(-0.1*tm)+dm/(px*tm),0.0,1.0));\n\t}\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 1209, 1245, 1245, 1308], [1308, 1319, 1380, 1407, 1894], [1896, 1896, 1916, 1956, 2880], [2882, 2882, 2901, 2901, 2957], [2958, 2958, 2977, 2977, 3103], [3115, 3115, 3132, 3132, 3521], [3523, 3523, 3564, 3593, 3752], [3755, 3755, 3776, 3776, 3876], [3878, 3878, 3934, 3934, 5067]], "test": "untested"}
{"id": "ltX3RH", "name": "Meta Experiment 5", "author": "aiekick", "description": "Meta Experiment 5", "tags": ["experiment", "meta", "quad", "metaquad"], "likes": 5, "viewed": 1189, "published": "Public API", "date": "1418430791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 getPos(vec2 p){\n    float ratio = iResolution.x/iResolution.y;\n    float t = cos(iTime*1.)*10.;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.)*2.;//centering -1->0->1 x & y\n}\nfloat metaquad(vec2 p, vec2 o, vec2 l){\n\tvec2 po = p-o;\n    float t = sin(iTime*1.);\n    return min(l.x, l.y) / length(max(abs(po)-l,0.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = sin(iTime)-0.3;\n    vec2 uv = getPos(fragCoord.xy);\n    float mqs=0.;\n    for(float i=-3.; i<=3.; i+=0.7){\n    \tfor(float j=-1.5; j<=1.5; j+=0.7){\n        \tmqs+=metaquad(uv.xx+length(uv.yy+1.)+1.*t, vec2(i,j), vec2(0.022,0.022));\n        \tmqs+=metaquad(uv.xx-length(uv.yy-1.)-1.*t, vec2(i,j), vec2(0.022,0.022));\n    \t}\n    }\n    float d=mqs;\n    float r = mix(1./d, d, 1.);\n    float g = mix(1./d, d, 2.);\n    float b = mix(1./d, d, 3.);\n    vec3 c = vec3(r,g,b);\n\tfragColor.rgb = vec3(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltX3RH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 137, 157, 157, 321], [322, 322, 361, 361, 463], [464, 464, 520, 520, 1027]], "test": "untested"}
{"id": "Md2SDt", "name": "Simplicity Clouds", "author": "runouw", "description": "3d flythrough of JoshP's Simplicity https://www.shadertoy.com/view/lslGWr\nI wanted to see what it would look like in 3d.", "tags": ["fractalclouds"], "likes": 15, "viewed": 435, "published": "Public", "date": "1417417328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3d flythrough of the fractal in https://www.shadertoy.com/view/lslGWr\n\nconst int MAX_RAY_STEPS = 64;\n\nvec2 mouse() {\n\treturn iMouse.xy / iResolution.xy - vec2(.5);\n}\n\nfloat field(in vec3 p) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime * 0.2) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-0.5, -0.4, -1.2);\n\t\tfloat w = exp(-float(i) / 5.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .9);\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.4);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(80.0, 12.0 * sin(iTime / 4.7), -12.0);\n\t\t\n    \n    rayDir.y += .2 * sin(iTime / 4.7);\n    rayDir = normalize(rayDir);\n    \n\trayPos.xz = rotate2d(rayPos.xz, iTime / 10.0 + mouse().y);\n\trayDir.xz = rotate2d(rayDir.xz, iTime / 10.0 + mouse().y);\n    \n    \n    float dis = 0.0;\n    \n    vec3 col = vec3(0);\n    for(int i=0;i<MAX_RAY_STEPS;i++){\n        \n        \n        float t = field(rayPos * .013);\n        \n        col += sqrt(dis) * .05 * vec3(0.5 * t * t * t, .6 * t * t, .7 * t);\n        \n        dis += 1.0 / float(MAX_RAY_STEPS);\n        \n        rayPos += rayDir * 0.8;\n    }\n    \n    vec2 q = screenPos;\n    \n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2SDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 105, 119, 119, 168], [170, 170, 194, 194, 587], [589, 589, 621, 621, 732], [734, 734, 791, 791, 1768]], "test": "untested"}
{"id": "MdBSDt", "name": "Bacterium", "author": "vgs", "description": "Bacterium, bacteria, bacterias...\nMy first try at anti-aliasing thanks to eiffie and his shader AA methods.", "tags": ["raymarch", "antialiasing", "antialias", "bacteria"], "likes": 160, "viewed": 6856, "published": "Public", "date": "1417478282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// This shader needs some serious work on collision avoidance :D\n// http://viniciusgraciano.com/blog/making-of-bacterium/\n\n#define STEPS 64\n#define EPS 0.002\n#define FAR 18.0\n#define PI 3.14159265359\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec2 rep(vec2 p) {\n    float a = atan(p.y, p.x);\n    a = mod(a, 2.0*PI/18.) - PI/18.;\n    return length(p)*vec2(cos(a), sin(a));\n}\n\nfloat spikedBall(vec3 p) {\n    p = mod(p, 8.0) - 4.0;\n    float d = length(p) - 1.2;\n    p.xz = rep(p.xz); p.xy = rep(p.xy); \n    return smin(d, length(p.yz)-.1+abs(.15*(p.x-1.0)), 0.1);\n}\n\nfloat capsules(vec3 p) {\n    vec3 q = floor(p/4.0);\n    p = mod(p, 4.0) - 2.0;\n    p.yz = p.yz*cos(iTime + q.z) + vec2(-p.z, p.y)*sin(iTime + q.z);\n    p.xy = p.xy*cos(iTime + q.x) + vec2(-p.y, p.x)*sin(iTime + q.x);\n    p.zx = p.zx*cos(iTime + q.y) + vec2(-p.x, p.z)*sin(iTime + q.y);\n    \n    float angle = .3*cos(iTime)*p.x;\n    p.xy = cos(angle)*p.xy + sin(angle)*vec2(-p.y, p.x); p.x += 1.0; \n    float k = clamp(2.0*p.x/4.0, 0.0, 1.0); p.x -= 2.*k;\n    return length(p) - .5;\n}\n\nfloat map(vec3 p) {   \n   return min(spikedBall(p), capsules(p));\n}\n\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return normalize(vec3(map(p + q.yxx) - map(p - q.yxx),\n                          map(p + q.xyx) - map(p - q.xyx),\n                          map(p + q.xxy) - map(p - q.xxy)));\n}\n\nfloat cubeMap(vec3 p, vec3 n) {\n    float a = texture(iChannel0, p.yz).r;\n    float b = texture(iChannel0, p.xz).r;\n    float c = texture(iChannel0, p.xy).r;\n    n = abs(n);\n    return (a*n.x + b*n.y + c*n.z)/(n.x+n.y+n.z);   \n}\n\nvec3 bumpMap(vec3 p, vec3 n, float c) {\n    vec2 q = vec2(0.0, .5);\n\tvec3 grad = -1.0*(vec3(cubeMap(p+q.yxx, n), cubeMap(p+q.xyx, n), cubeMap(p+q.xxy, n))-c)/q.y;\n    vec3 t = grad - n*dot(grad, n);\n    return normalize(n - t);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + t*rd, n = normal(p);\n   \n    vec3 green = pow(vec3(93,202,49)/255., vec3(2.2));\n    vec3 yellow = pow(vec3(255,204,0)/255., vec3(2.2));\n    \n    float k = cubeMap(.5*p, n);\n    n = bumpMap(.5*p, n, k);\n    \n    vec3 col = mix(green, yellow, k)*(1.0-dot(-rd,n));\n    if (spikedBall(p) < capsules(p)) {\n    \tp = mod(p, 8.0) - 4.0;\n        col *= 1.0/(1.0 + .5*dot(p, p));\n    }\n        \n    return col*exp(-.008*t*t);\n}\n\nmat3 lookat(vec3 p, vec3 t) {\n    vec3 z = normalize(p - t);\n    vec3 x = cross(z, vec3(0.0, 1.0, 0.0));\n    return mat3(x, cross(x, z), z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    uv *= 1.0 + .1*dot(uv,uv);\n    \n    vec3 ro = vec3(iTime, iTime, cos(iTime));\n    vec3 rd = normalize(lookat(ro, ro+vec3(cos(.1*iTime), sin(.1*iTime), 1.0))*vec3(uv, -1.0)); // direÃ§Ã£o do raio.\n    \n    // based on eiffie's antialiasing method (https://www.shadertoy.com/view/XsSXDt)\n    vec3 col = vec3(0.0);\n    vec4 stack = vec4(-1.0); bool grab = true;\n    float t = 0.0, d = EPS, od = d, pix = 4.0/iResolution.x, w = 1.8, s = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (w > 1.0 && (od + d < s)) {\n            s -= w*s; w = 1.0;\n        } else {\n            s = d * w;   \n        \tif (d <= od) grab = true;\n        \telse if (grab && stack.w < 0. && od < pix*(t-od)) {\n            \tstack.w = t-od; stack = stack.wxyz; \n            \tgrab = false;\n        \t}\n        \tif (d < EPS || t > FAR) break;\n        }\n        od = d; t += s; \n    }\n    col = d < EPS ? shade(ro, rd, t) : col;\n    \n    for (int i = 0; i < 4; ++i) {\n        if (stack[i] < 0.0) break;\n        d = map(ro + stack[i]*rd);\n        col = mix(shade(ro, rd, stack[i]), col, clamp(d/(pix*stack[i]), 0.0, 1.0));\n    }\n    \n    col = smoothstep(0., .7, col);\n    col = pow(col, vec3(1.0/2.2));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdBSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 251, 290, 290, 373], [375, 375, 393, 393, 505], [507, 507, 533, 533, 695], [697, 697, 721, 721, 1180], [1182, 1182, 1201, 1201, 1249], [1251, 1251, 1272, 1272, 1482], [1484, 1484, 1515, 1515, 1712], [1714, 1714, 1753, 1753, 1943], [1945, 1945, 1984, 1984, 2420], [2422, 2422, 2451, 2451, 2564], [2566, 2566, 2623, 2623, 3931]], "test": "untested"}
{"id": "MdjXDd", "name": "Plasma #1", "author": "beam", "description": "plasma first", "tags": ["2d"], "likes": 5, "viewed": 158, "published": "Public", "date": "1417530530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// plasma #1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float factor1 = 5.0;\n    float factor2 = 6.0;\n    \n    float blah =(sin(uv.y*factor2-iTime))+sin(uv.x*factor1-iTime*2.0);\n    float blah2 =(sin(uv.x*factor2-iTime*2.0))+sin(uv.y*factor1-iTime*2.0);\n    \n\tfragColor = vec4(uv, uv.y, 1.0) +\n        \t\t   vec4(blah-0.5,blah-0.5,blah+0.5,1.0)*\n        \t\t   vec4(blah2-0.5,blah2+0.3,blah2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdjXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 72, 72, 464]], "test": "untested"}
{"id": "Mlf3R4", "name": "Stractium", "author": "otaviogood", "description": "It's just a whole lot of rotations and sine waves ray marched. I tried to make it look natural by keeping textures less saturated and having hard sunlight with shadows.", "tags": ["procedural", "fractal", "raymarch"], "likes": 40, "viewed": 1378, "published": "Public API", "date": "1419115410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// Set this to change detail level. [1 - 10] is a good range.\nconst int NUM_SIN_REPS = 9;\nconst int MAX_MARCH_REPS = 250;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\n\nfloat localTime = 0.0;\n\n// some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\n\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\n\treturn sunCol * sunIntensity*0.0425;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat SinRep(float a)\n{\n    float h = 0.0;\n    float mult = 1.0;\n    for (int i = 0; i < NUM_SIN_REPS; i++)\n    {\n        h += (cos(a*mult)/(mult));\n        mult *= 2.0;\n    }\n    return h;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    float material = 0.0;\n    float h = 0.0;\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\n    material = h;\n    //h += SinRep(RotateX(p, p.y).z);\n    //h += SinRep(RotateZ(p, sin(h)).y);\n    //h += SinRep(RotateY(p, h*1.0).x);\n    //h += SinRep(p.x+h)*0.5;\n    //h += SinRep(p.y+h)*0.5;\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 1.6;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\tvec3 iA, iB;\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 110.0;\n\tvec3 pos = vec3(0,0,0);\n    // start and end the camera ray at the sphere intersections.\n    camPos = iA;\n    maxDepth = distance(iA, iB);\n\t// ray marching time\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.2;\n\t\tfor (int i = 0; i < 10; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*10.0);\n            if (tempDist <= 0.0) break;\n            iter *= 1.5;\t// constant is more reliable than distance-based\n            //iter += max(0.2, tempDist)*1.2;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // ------ Calculate texture color of the rock ------\n        // base texture can be swirled noise.\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\n        n = saturate(n*0.25 * 0.95 + 0.05);\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\n\n        // fade to reddish texture on outside\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\n        // give it green-blue texture that matches the shape using normal length\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\n        // Give it a reddish-rust color in the middle\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\n        // make sure it's not too saturated so it looks realistic\n        texColor = max(vec3(0.02),texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        // sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog that fades to sun color so that fog is brightest towards sun\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        // add the sun\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n    }\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3R4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[753, 777, 798, 798, 833], [834, 834, 857, 857, 980], [981, 981, 1001, 1001, 1059], [1060, 1060, 1083, 1083, 1169], [1171, 1171, 1212, 1212, 1257], [1259, 1259, 1300, 1300, 1353], [1355, 1355, 1396, 1396, 1439], [1440, 1440, 1479, 1479, 1522], [1524, 1524, 1566, 1566, 1617], [1656, 1656, 1683, 1683, 1935], [1936, 1936, 1960, 1960, 2227], [2228, 2228, 2250, 2250, 2835], [2859, 2859, 2882, 2882, 2911], [2912, 2912, 2935, 2935, 2964], [2965, 2965, 2990, 2990, 3019], [3021, 3021, 3054, 3054, 3268], [3269, 3269, 3302, 3302, 3516], [3517, 3517, 3550, 3550, 3695], [3698, 3884, 3938, 3938, 4360], [4361, 4361, 4410, 4410, 4664], [4771, 4771, 4794, 4794, 4962], [4964, 4964, 4995, 4995, 5529], [5553, 5553, 5672, 5733, 6427], [6430, 6430, 6487, 6487, 13965]], "test": "untested"}
{"id": "Mlf3Rn", "name": "Let's Do Raymarching", "author": "Slyth", "description": "Just learning shtuff.", "tags": ["raymarching"], "likes": 3, "viewed": 428, "published": "Public", "date": "1417740250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 normal(sampler2D sampler, in vec2 uv)\n{\n    //uv.y = 1.0 - uv.y;\n\tfloat x=1.;\n\tfloat y=1.;\n\t\n\tfloat M =abs(texture(sampler, uv + vec2(0., 0.)/ iResolution.xy).r); \n\tfloat L =abs(texture(sampler, uv + vec2(x, 0.)/ iResolution.xy).r);\n\tfloat R =abs(texture(sampler, uv + vec2(-x, 0.)/ iResolution.xy).r);\t\n\tfloat U =abs(texture(sampler, uv + vec2(0., y)/ iResolution.xy).r);\n\tfloat D =abs(texture(sampler, uv + vec2(0., -y)/ iResolution.xy).r);\n\tfloat X = ((R-M)+(M-L))*.5;\n\tfloat Y = ((D-M)+(M-U))*.5;\n\t\n\tfloat strength =.01;\n\tvec4 N = vec4(normalize(vec3(X, Y, strength)), 1.0);\n\n\treturn vec3(N.xyz * 0.5 + 0.5);\n}\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n\t\treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+7.0,0);\n}\n\nvec2 obj_sphere(in vec3 p)\n{\n  \tfloat d = length(p)-1.9;\n  \treturn vec2(d,1);\n}\n\nvec2 obj_roundBox(in vec3 p){\n  \treturn vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\nvec2 opTwist( vec3 p )\n{\n    float c = cos(sin(iTime)*p.y);\n    float s = sin(sin(iTime)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return obj_roundBox(q);\n}\n\nvec2 op_rep(vec3 p, vec3 c)\n{\n  \tvec3 q = mod(p,c)-0.5*c;\n  \treturn opTwist(q);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n  \treturn obj_union(obj_floor(p), op_rep(p, vec3(8.0, 8.0, 8.0)));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t );\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\nvec3 floor_color(in vec3 p)\n{\n    return texture(iChannel0, vec2(p.x/20.0, p.z/20.0)).xyz;\n  \tif (fract(p.x*0.2)>0.2)\n  \t{\n   \t\tif (fract(p.z*0.2)>0.2)\n      \t\treturn vec3(0,0.1,0.2);\n    \telse\n      \t\treturn vec3(1,1,1);\n  \t}\n  \telse\n  \t{\n    \tif (fract(p.z*.2)>.2)\n      \t\treturn vec3(1,1,1);\n    \telse\n      \t\treturn vec3(0.3,0,0);\n   \t}\n}\n\nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(0.6,0.6,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,0,0);\n\n\tvec3 prp = vec3(sin(iTime*0.5),sin(iTime*0.5),cos(iTime*0.5)); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(-sin(iTime)*8.0,sin(iTime),cos(iTime)*8.0);\n    \n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p/20.0);\n            N = normal(iChannel0, vec2(p.x/20.0, p.z/20.0));\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n    \tfloat b=dot(N,normalize(lightPos-p));\n        \n        float r = 15.;\n        float d = max(length(lightPos-p) - r, 0.0);\n        float denom = d/r + 1.0;\n    \tfloat attenuation = 1.0 / (denom*denom);\n        \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0625, length(lightPos-p), 32.0 );\n        \n        float ambient = 0.015;\n        \n    \tfragColor = vec4((b*c+pow(b,16.0))*(1.0-f*.01)*attenuation*vis+ambient,1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 69, 619], [621, 621, 665, 665, 731], [733, 733, 760, 760, 787], [789, 789, 817, 817, 868], [870, 870, 899, 899, 961], [963, 963, 987, 987, 1149], [1151, 1151, 1180, 1180, 1232], [1234, 1234, 1267, 1267, 1336], [1338, 1338, 1409, 1409, 1694], [1697, 1697, 1726, 1726, 2039], [2041, 2041, 2065, 2065, 2096], [2098, 2098, 2155, 2155, 3801]], "test": "untested"}
{"id": "Mlf3zr", "name": "Op art onion", "author": "smokris", "description": "3 layers of simple 2D rings.", "tags": ["2d", "rings"], "likes": 2, "viewed": 149, "published": "Public", "date": "1417905965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2014.12.06, steve@vuo.org\n// License: CC BY 4.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(.5,.5);\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    float ringColor[3];\n    for (int i=0; i<3; ++i)\n    {\n\t    vec2 center = vec2(\n            cos(iTime/4. +float(i*20)       )/2.,\n            sin(iTime/4.3+float(i*20) + 100.)/2.);\n\n        float dist = distance(uv,center);\n        float frequency = (sin(iTime/4.7+float(i*3))/2.+.6)*32.;\n   \t\tfloat sdist = sin(dist*frequency + 3.14/2.);\n   \t\tfloat delta = fwidth(sdist);\n        float pulseWidth = sin(iTime/5.+float(i*13))/1.01;\n   \t\tringColor[i] = smoothstep(sdist-delta,sdist,pulseWidth);\n    }\n    \n\tfragColor = vec4(\n        ringColor[0],\n        ringColor[1],\n        ringColor[2],\n        1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3zr.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 52, 109, 109, 850]], "test": "untested"}
{"id": "MlfGR4", "name": "Voxel Pac-Man", "author": "Nrx", "description": "An attempt to do something like [url=https://upload.wikimedia.org/wikipedia/en/f/f0/PixelsOfficialPoster.jpg]this[/url]... Use the mouse to rotate when in 3D :).\n\nA slightly different version is [url=https://www.shadertoy.com/view/ltGyWz]there[/url]...", "tags": ["voxel", "pacman"], "likes": 123, "viewed": 14128, "published": "Public API", "date": "1419250088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n//  GGGG IIIII  AAA  N   N TTTTT     PPPP   AAA   CCCC     M   M  AAA  N   N //\n// G       I   A   A NN  N   T       P   P A   A C         MM MM A   A NN  N //\n// G  GG   I   AAAAA N N N   T       PPPP  AAAAA C     --- M M M AAAAA N N N //\n// G   G   I   A   A N  NN   T       P     A   A C         M   M A   A N  NN //\n//  GGGG IIIII A   A N   N   T       P     A   A  CCCC     M   M A   A N   N //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n\n// Parameters\n#define VOXEL_RESOLUTION\t1.5\n#define VOXEL_LIGHTING\n#define SHADOW\n#define GROUND\n#define GHOST\n#define MOUSE\n#define HSV2RGB_FAST\n\n#define CAMERA_FOCAL_LENGTH\t8.0\n#define DELTA\t\t\t\t0.01\n#define RAY_LENGTH_MAX\t\t500.0\n#define RAY_STEP_MAX\t\t100.0\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t2.0\n#define SPECULAR_INTENSITY\t0.3\n#define SHADOW_LENGTH\t\t150.0\n#define SHADOW_POWER\t\t3.0\n#define FADE_POWER\t\t\t1.0\n#define BACKGROUND\t\t\t0.7\n#define GLOW\t\t\t\t0.4\n#define GAMMA\t\t\t\t0.8\n\n// Math constants\n#define PI\t\t3.14159265359\n#define SQRT3\t1.73205080757\n\n// Global variable to handle the glow effect\nfloat glowCounter;\n\n// PRNG (from https://www.shadertoy.com/view/4djSRW)\nfloat rand (in vec3 seed) {\n\tseed = fract (seed * vec3 (5.3983, 5.4427, 6.9371));\n\tseed += dot (seed.yzx, seed.xyz + vec3 (21.5351, 14.3137, 15.3219));\n\treturn fract (seed.x * seed.y * seed.z * 95.4337);\n}\n\n// Distance to the voxel\nfloat distVoxel (in vec3 p) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Rounded box\n\tconst float voxelRadius = 0.25;\n\treturn length (max (abs (p) - 0.5 + voxelRadius, 0.0)) - voxelRadius;\n}\n\n// Distance to the scene and color of the closest point\nvec2 distScene (in vec3 p, out vec3 P) {\n\n\t// Update the glow counter\n\t++glowCounter;\n\n\t// Scaling\n\tp *= VOXEL_RESOLUTION;\n\n\t// Velocity, period of the waves, spacing of the gums\n\tfloat v = VOXEL_RESOLUTION * floor (iTime * 100.0 / VOXEL_RESOLUTION);\n\tconst float k1 = 0.05;\n\tconst float k2 = 60.0;\n\n\t// Giant Pac-Man\n\tfloat body = length (p);\n\tbody = max (body - 32.0, 27.0 - body);\n\tfloat eyes = 6.0 - length (vec3 (abs (p.x) - 12.5, p.y - 19.5, p.z - 20.0));\n\tfloat mouthAngle = PI * (0.07 + 0.07 * cos (2.0 * v * PI / k2));\n\tfloat mouthTop = dot (p, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 2.5;\n\tfloat mouthBottom = dot (p, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacMan = max (max (body, eyes), min (mouthTop, mouthBottom));\n\tvec2 d = vec2 (pacMan, 0.13);\n\tP = p;\n\n\t// Gums\n\tvec3 q = vec3 (p.xy, mod (p.z + v, k2) - k2 * 0.5);\n\tfloat gum = max (length (q) - 6.0, -p.z);\n\tif (gum < d.x) {\n\t\td = vec2 (gum, 0.35);\n\t\tP = q;\n\t}\n\n\t// Ground\n\t#ifdef GROUND\n\tq = vec3 (p.xy, p.z + v);\n\tfloat ground = (q.y + 50.0 + 14.0 * cos (q.x * k1) * cos (q.z * k1)) * 0.7;\n\tif (ground < d.x) {\n\t\td = vec2 (ground, 0.55);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Ghost\n\t#ifdef GHOST\n\tv = VOXEL_RESOLUTION * floor ((130.0 + 60.0 * cos (iTime * 3.0)) / VOXEL_RESOLUTION);\n\tq = vec3 (p.xy, p.z + v);\n\tbody = length (vec3 (q.x, max (q.y - 4.0, 0.0), q.z));\n\tbody = max (body - 28.0, 22.0 - body);\n\teyes = 8.0 - length (vec3 (abs (q.x) - 12.0, q.y - 10.0, q.z - 22.0));\n\tfloat bottom = (q.y + 28.0 + 4.0 * cos (p.x * 0.4) * cos (p.z * 0.4)) * 0.7;\n\tfloat ghost = max (max (body, eyes), -bottom);\n\tif (ghost < d.x) {\n\t\td = vec2 (ghost, 0.76);\n\t\tP = q;\n\t}\n\t#endif\n\n\t// Scaling\n\td.x /= VOXEL_RESOLUTION;\n\treturn d;\n}\n\n// Distance to the (voxelized?) scene\nvec4 dist (inout vec3 p, in vec3 ray, in float voxelized, in float rayLengthMax) {\n\tvec3 P = p;\n\tvec2 d = vec2 (1.0 / 0.0, 0.0);\n\tfloat rayLength = 0.0;\n\tfloat rayLengthInVoxel = 0.0;\n\tfloat rayLengthCheckVoxel = 0.0;\n\tvec3 raySign = sign (ray);\n\tvec3 rayDeltaVoxel = raySign / ray;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\tif (rayLength < rayLengthInVoxel) {\n\t\t\td.x = distVoxel (fract (p + 0.5) - 0.5);\n\t\t\tif (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (rayLength < rayLengthCheckVoxel) {\n\t\t\tvec3 rayDelta = (0.5 - raySign * (fract (p + 0.5) - 0.5)) * rayDeltaVoxel;\n\t\t\tfloat dNext = min (rayDelta.x, min (rayDelta.y, rayDelta.z));\n\t\t\td = distScene (floor (p + 0.5), P);\n\t\t\tif (d.x < 0.0) {\n\t\t\t\trayDelta = rayDeltaVoxel - rayDelta;\n\t\t\t\td.x = max (rayLengthInVoxel - rayLength, DELTA - min (rayDelta.x, min (rayDelta.y, rayDelta.z)));\n\t\t\t\trayLengthInVoxel = rayLength + dNext;\n\t\t\t} else {\n\t\t\t\td.x = DELTA + dNext;\n\t\t\t}\n\t\t} else {\n\t\t\td = distScene (p, P);\n\t\t\tif (voxelized > 0.5) {\n\t\t\t\tif (d.x < SQRT3 * 0.5) {\n\t\t\t\t\trayLengthCheckVoxel = rayLength + abs (d.x) + SQRT3 * 0.5;\n\t\t\t\t\td.x = max (rayLengthInVoxel - rayLength + DELTA, d.x - SQRT3 * 0.5);\n\t\t\t\t}\n\t\t\t} else if (d.x < DELTA) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trayLength += d.x;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d.x * ray;\n\t}\n\treturn vec4 (d, rayLength, rand (P));\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p, in float voxelized) {\n\tvec2 h = vec2 (DELTA, -DELTA);\n\tvec3 n;\n\tif (voxelized > 0.5) {\n\t\tp = fract (p + 0.5) - 0.5;\n\t\tn = h.xxx * distVoxel (p + h.xxx) +\n\t\t\th.xyy * distVoxel (p + h.xyy) +\n\t\t\th.yxy * distVoxel (p + h.yxy) +\n\t\t\th.yyx * distVoxel (p + h.yyx);\n\t} else {\n\t\tn = h.xxx * distScene (p + h.xxx, n).x +\n\t\t\th.xyy * distScene (p + h.xyy, n).x +\n\t\t\th.yxy * distScene (p + h.yxy, n).x +\n\t\t\th.yyx * distScene (p + h.yyx, n).x;\n\t}\n\treturn normalize (n);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Define the rendering mode\n\tfloat modeTiming = iTime * 0.234;\n\tfloat modeAngle = PI * cos (iTime * 0.2);\n\tmodeAngle = dot (frag - vec2 (cos (iTime * 2.0), 0.0), vec2 (cos (modeAngle), sin (modeAngle)));\n\tfloat modeVoxel = step (0.5, fract (modeTiming / (4.0 * PI)));\n\tmodeTiming = cos (modeTiming);\n\tfloat mode3D = smoothstep (0.8, 0.5, modeTiming);\n\tfloat modeSwitch = smoothstep (0.995, 1.0, modeTiming) + smoothstep (0.02, 0.0, abs (modeAngle)) * modeVoxel;\n\tmodeVoxel = 1.0 + (step (0.0, modeAngle) - 1.0) * modeVoxel;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, mix (8.0, CAMERA_FOCAL_LENGTH, mode3D)));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\t#ifdef MOUSE\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n\t#endif\n\tyawAngle = mix (PI * 1.5, yawAngle, mode3D);\n\tpitchAngle *= mode3D;\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = mix (300.0, 195.0 + 150.0 * cos (iTime * 0.8), mode3D);\n\tvec3 origin = (vec3 (0.0, 0.0, 40.0 * sin (iTime * 0.2)) - cameraOrientation [2] * cameraDist) / VOXEL_RESOLUTION;\n\n\t// Compute the distance to the scene\n\tglowCounter = 0.0;\n\tvec4 d = dist (origin, ray, modeVoxel, RAY_LENGTH_MAX / VOXEL_RESOLUTION);\n\n\t// Set the background color\n\tvec3 finalColor = hsv2rgb (vec3 (0.2 * ray.y + 0.4 * modeVoxel - 0.37, 1.0, mode3D * BACKGROUND));\n\tvec3 glowColor = GLOW * vec3 (1.0, 0.3, 0.0) * glowCounter / RAY_STEP_MAX;\n\tif (d.x < DELTA) {\n\n\t\t// Set the object color\n\t\tvec3 color = hsv2rgb (vec3 (d.y + 0.1 * d.w * modeVoxel, 0.5 + 0.5 * modeVoxel, 1.0));\n\n\t\t// Lighting\n\t\tvec3 l = normalize (mix (vec3 (1.0, 0.0, 0.0), vec3 (1.25 + cos (iTime * 0.2), 1.0, 1.0), mode3D));\n\t\t#ifdef VOXEL_LIGHTING\n\t\tif (modeVoxel > 0.5) {\n\t\t\tvec3 n = normal (floor (origin + 0.5), 0.0);\n\t\t\tfloat diffuse = max (0.0, dot (n, l));\n\t\t\tfloat specular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\t\t}\n\t\t#endif\n\t\tvec3 n = normal (origin, modeVoxel);\n\t\tfloat diffuse = dot (n, l);\n\t\tfloat specular;\n\t\tif (diffuse < 0.0) {\n\t\t\tdiffuse = 0.0;\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow (max (0.0, dot (reflect (ray, n), l)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\t#ifdef SHADOW\n\t\t\torigin += n * DELTA * 2.0;\n\t\t\tvec4 shadow = dist (origin, l, modeVoxel, SHADOW_LENGTH / VOXEL_RESOLUTION);\n\t\t\tif (shadow.x < DELTA) {\n\t\t\t\tshadow.z = pow (min (1.0, shadow.z * VOXEL_RESOLUTION / SHADOW_LENGTH), SHADOW_POWER);\n\t\t\t\tdiffuse *= shadow.z;\n\t\t\t\tspecular *= shadow.z;\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\tcolor = (AMBIENT + diffuse) * color + specular;\n\n\t\t// Fading\n\t\tfloat fade = pow (max (0.0, 1.0 - d.z * VOXEL_RESOLUTION / RAY_LENGTH_MAX), FADE_POWER);\n\t\tfinalColor = mix (finalColor, color, fade);\n\t}\n\n\t// Set the fragment color\n\tfinalColor = mix (pow (finalColor, vec3 (GAMMA)) + glowColor, vec3 (1.0), modeSwitch);\n\tfragColor = vec4 (finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1346, 1399, 1426, 1426, 1604], [1606, 1631, 1660, 1689, 1828], [1830, 1886, 1926, 1955, 3611], [3613, 3651, 3733, 3733, 5008], [5010, 5037, 5082, 5082, 5518], [5520, 5534, 5562, 5562, 5897], [5899, 5916, 5972, 5994, 9538]], "test": "untested"}
{"id": "MlfGz8", "name": "Game Logo", "author": "vladstorm", "description": "a game logo for my game #printedmars\nstill gotta test it on different systems ... ", "tags": ["text", "logo", "glow", "font", "pixels"], "likes": 50, "viewed": 1386, "published": "Public", "date": "1418406513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TODO length squared ? \n//also there is another aproach to set a position and use distance then \n//here:https://www.shadertoy.com/view/Msf3z7\n\nvec2 cur = vec2(0.);\nvec3 cl = vec3(0.);\n\nfloat wave = 0.;\nfloat cshift = 0.1;\nbool bSmall = false;\n\nfloat focus = .5;\nfloat size = 1.;\n\n//float focus_c = .0;\n//float size_c = 0.;\n\n\n//https://www.shadertoy.com/view/4sXSWs strength= 16.0\nvec3 filmGrain(vec2 uv, float strength ){       \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\treturn  vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n\n}\n\nfloat hash(vec2 p){\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\n\n\nvec3 circleGlow( vec2 pos ){ //, float size, float focus\n\n    //c = pow(c, focus);\n    //vec3 col = vec3(c );    \n    \n    //float c = 20. / length(pos*size_c);\n    //vec3 col = vec3(\n    //\tpow(c, focus_c - .5),\n    //    pow(c, focus_c ),\n    //    pow(c, focus_c + .5)\n    //);\n\n    //float c = 20. / length(pos*size_c);\n\n    vec3 col = vec3(\n    \tpow(20. / length((pos+vec2(cshift,0.))*size), focus - .5),\n        pow(20. / length(pos*size), focus ),\n        pow(20. / length((pos-vec2(cshift,0.))*size), focus + .5)\n    );\n    \n\treturn col;\n}\n\n\nvec3 bm(vec3 c1, vec3 c2){\n\treturn 1.- (1.-c1)*(1.-c2);\n}\n\nvoid C(vec2 fragCoord, bool s){\n\tcur.x--;\n    if(!s) return;\n    //if(s){\n        //48 - is the length\n        vec2 pos = vec2((fragCoord.xy - iResolution.xy/2. + (cur+vec2(48.2/2., -2.5))*10.) / 15.);\n        \n        \n        //focus_c = floor( focus *  sin(fragCoord.y - iResolution.y) *1.)/1.;\n        //size_c = size*filmGrain(cur, 1.0).x*1000.; //floor( size *  sin(fragCoord.x - iResolution.x) *1.)/1. ;\n        \n        //float var = clamp(hash(cur)*10., .1, 1.); //variations\n        float var = hash(cur)*.5;\n        //float var = hash2(cur)*.5;\n\n        \n        float t = var + iTime;\n        \n        if(bSmall) {\n            wave = 4.*abs( sin(t)*sin(t*3.) );\n            cshift = .12;\n        }else{\n        \twave = .4*sin(t)*sin(t*3.);\n        \tcshift = .0; //.1?\n        }\n        \n        size = 200.*( 1.-.3+ wave); //br =.4\n        focus = 2.*(.82 + .02*sin(t*40.)*sin(30.+t*20.)); \n        \n        vec3 c = circleGlow(pos);\n        cl = bm(cl, c);\n        //cl = cl*c;         \n        //cl = cl+c;         \n        //cl = max(cl*.5, circleGlow( pos ));\n\n    //}\n} \n\n//next line\nvoid NL(){\n    cur.y++;\n    cur.x=0.;\n}\n\n\n#define X C(fragCoord,true);\n#define _ C(fragCoord,false);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t\n    //size =200.*(1.-iMouse.x/iResolution.x); //size\n    //focus = 2.*(iMouse.y/iResolution.y); // focus\n\n    //prev pulse\n    //size = 200.*(1.-.3+ .4*sin(iTime)*sin(iTime*3.));\n    //focus = 2.*(.82 + .02*sin(iTime*40.)*sin(30.+iTime*20.)); //\n    \n    //flicker - pulse\n    //y = mod(iTime, 1.);\n    \n\ncur = vec2(0.);\ncl = vec3(.0);\n\n// arc\ncur.y-=10.;\nbSmall = true;\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;X;X;_;_;_;X;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;X;X;_;_;_;_;_;_;_;_;_;_;_;X;X;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;X;_;_;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\t_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;NL();\n\t\t\t\t\tNL();\n\t\t\t\t\tNL();\n\t\t\t\t\tNL();\n\t\t\t\t\t  \n\t\t\t\t\t//printed mars    \n\t\t\t\t\tbSmall = false;\n\t\t\t\t\tX;X;_;_;X;X;_;_;X;X;X;_;X;_;_;X;_;X;X;X;_;X;X;X;_;X;X;_;_;_;_;X;_;_;_;X;_;_;X;_;_;X;X;_;_;X;X;_;NL();\n\t\t\t\t\t_;_;X;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;_;_;_;_;_;_;_;_;_;_;_;X;_;_;_;_;NL();\n\t\t\t\t\tX;X;_;_;X;X;_;_;_;X;_;_;X;X;_;X;_;_;X;_;_;X;X;X;_;_;_;X;_;_;_;X;X;_;X;X;_;X;X;X;_;X;X;_;_;X;X;_;NL();\n\t\t\t\t\tX;_;_;_;_;X;_;_;_;X;_;_;X;_;X;X;_;_;X;_;_;X;_;_;_;_;_;X;_;_;_;X;_;X;_;X;_;X;_;X;_;_;X;_;_;_;_;X;NL();\n\t\t\t\t\tX;_;_;_;_;_;X;_;X;X;X;_;X;_;_;X;_;_;X;_;_;X;X;X;_;X;X;_;_;_;_;X;_;X;_;X;_;X;_;X;_;_;_;X;_;X;X;_;NL();\n\t\t\t\t\tNL();    \n\t\t\t\t\tNL();\n\t\t\t\t\tNL();\n\t\t\t\t\t    \n\t\t\t\t\t//chapter one    \n\t\t\t\t\tbSmall = true;\n\t\t\t\t\t_;_;X;X;X;_;X;_;X;_;_;X;_;_;X;X;X;_;X;X;X;_;X;X;X;_;X;X;X;_;_;_;_;_;X;X;X;_;X;X;X;_;X;X;X;_;_;NL();\n\t\t\t\t\t_;_;X;_;_;_;X;X;X;_;X;X;X;_;X;X;X;_;_;X;_;_;X;X;_;_;X;_;_;_;_;_;_;_;X;_;X;_;X;_;X;_;X;X;_;_;_;NL();\n\t\t\t\t\t_;_;X;X;X;_;X;_;X;_;X;_;X;_;X;_;_;_;_;X;_;_;X;X;X;_;X;_;_;_;_;_;_;_;X;X;X;_;X;_;X;_;X;X;X;_;_;NL();\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 fg = filmGrain(uv,  20.0);\n    cl = bm(cl, fg);//1.- (1.-cl)*(1.-fg); \n    fragColor = vec4(cl, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 381, 422, 422, 583], [585, 585, 604, 604, 671], [675, 675, 703, 998, 1222], [1225, 1225, 1251, 1251, 1282], [1284, 1284, 1315, 1315, 2370], [2373, 2385, 2395, 2395, 2424], [2487, 2487, 2544, 2846, 4944]], "test": "untested"}
{"id": "Mll3RH", "name": "Instant Trip", "author": "tomachi", "description": "// WARNING can cause dizziness or convulsions\n// THIS WILL TAX YOUR RETINAL GANGLION NERVES\n// Do not look at this for long, your eyes will get hot.\n// PAUSE the video transport is best or LOOK AWAY\n// MAY CAUSE PERMANENT DAMAGE TO RETINAL GANGLION ", "tags": ["psychedelicsinewavefractalinterfereancepatternzoom"], "likes": 8, "viewed": 827, "published": "Public API", "date": "1418761674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// STAND AWAY FROM THE MONITOR\n// WARNING can cause dizziness or convulsions do not look at!\n// PAUSE the video transport is best or LOOK AWAY\n// MAY CAUSE PERMANENT DAMAGE TO RETINAL GANGLION \n// Some drugs like beta blockers can do this: https://www.ncbi.nlm.nih.gov/pubmed/10416759 \n// Instead check out my band \"The Triptonites\": http://www.triptonites.com/ \n// 25 seconds into The Trip interference patterns will cease to exist on most monitor screens..\n// causing a fairly harsh moire! 45 seconds in you will pass through the eye ofthe storm\n// but that is of no assistance because now you run the whole thing in reverse\n// which if anything is gonna mess you up even more. \n// Seriously though, please do not show to young kids, even teenagers.\n// I **did** look at this too long one night while developing it and well, lets put it this way\n// Blood flow in the brain is a dynamic thing. \n// Don't mess with things you only partly understand if they can mess you up, know why this is.\n// The mind is not just a neaural circuit of 0 and 1s. The voltage can build too across the synapse. \n// Some speak of a man in the jungle of Papaua New Guinea or somewhere who can list fires\n// purely with his hands and mind. I sure do not want this guy to see it.\n// If he can light fires with his hands then.... \n\n\n// to begin to learn how to code try:\n// const float divs = 2.0;\nfloat divs = 3.0;\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n    \n{\n    \n    \t\n    // run time backwards:\n    \n    // this is really cool:\n    //float t = 800.0 - iTime;\n    \n    \n    \n    // 8.0 is a good speed\n    float speed = 4.0;\n    \n    // best time is 400 for sure - \"how far out to start\"\n    float t = 180.0 - (iTime * speed);\n    \n    \n    // create staggered / staged division:\n    divs += t / 1.0;\n    \n    \n\tvec2 div = vec2( divs, divs*iResolution.y/iResolution.x );\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    // center on screen\n    \n    uv -= 0.5;\n    //+ (iTime*0.01);\t\t\t\t\t\t\t\t\t\n    float b = 4.0*divs/iResolution.x;\t\t\t// blur over 2.4 pixels\n    vec2 xy = div*uv;\n    \n    vec2 S;\n\tS.x = (xy.x + xy.y)*(xy.x - xy.y)*0.5;\t\t// \"velocity potential\"\n    S.y = xy.x*xy.y;\t\t\t\t\t\t\t// stream function\n\t\n    // speed of the dots\n    S.x -= iTime*4.0;\t\t\t\t\t\t// animate stream\n    \n    vec2 sxy = sin(3.14159*S);\n    float a = sxy.x * sxy.y;\t\t\t\t\t// combine sine waves using product\n    \n    a = 0.5*a + 0.5;\t\t\t\t\t\t\t// remap to [0..1]\n\ta = smoothstep( 0.85-b, 0.85+b, a );\t\t// threshold\n    \n    float c = sqrt( a );\t\t\t\t\t\t// correct for gamma\n\t\n    //fragColor = vec4(sxy.x, c, sxy.y, 1.0);\n    \n    \n    // blue lines yellow and white balls\n    // fragColor = vec4(c, c, sxy.y, 1.0);\n    \n    \n    // blue lines yellow and white balls\n    fragColor = vec4(c*2.0, c, sxy.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1310, 1399, 1466, 1610, 2795]], "test": "untested"}
{"id": "Mll3RN", "name": "Cross ", "author": "akaitora", "description": "Merry Christmas Everyone!  Have a Happy New Year!", "tags": ["christmas", "cross", "merrychristmas"], "likes": 3, "viewed": 197, "published": "Public", "date": "1419532238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Merry Christmas Everyone!\n// By: Brandon Fogerty\n// bfogerty at gmail dot com\n\n// \"â€œGlory to God in the highest, and on earth peace among those with whom He is pleased!â€ - Luke 2:14\n// \"But he was pierced for our transgressions,\n//  he was crushed for our iniquities;\n//  the punishment that brought us peace was on him,\n//  and by his wounds we are healed.\" - Isaiah 53:5-6\n\n// Special Thanks to my Beautiful Wife, Naomi, for the design!\n\n\n#define Resolution\t\t\t\tiResolution\n#define Time\t\t\t\t\tiTime\n\n#define GloryGlowColor\t\t\t\tvec3(0.26, 0.16, 0.06)\n#define VerticalBarWidth\t\t\t0.09\n#define VerticalBarHeight\t\t\t0.9\n#define HorizontalBarWidth\t\t\t0.7\n#define HorizontalBarHeight\t\t\t0.07\n#define HorizontalBarVerticalOffset\t\t0.4\n\n#define ChristsCrossColor\t\t\tvec3( 1.0, 1.0, 1.0 )\n#define UnrepentantThiefsCrossColor\t\tvec3( 0.45, 0.45, 0.45 )\n#define RepentantThiefsCrossColor\t\tvec3( 0.90, 0.90, 0.90 )\n\n#define CrossGlowScale\t\t\t\t0.02\n#define CrossGloryGlowMin\t\t\t0.35\n#define CrossGloryGlowMax\t\t\t1.00\n\n\nfloat hash( float x )\n{\n    return fract( sin( x ) * 43758.5453 );\n}\n\nfloat noise( vec2 uv )  // Thanks Inigo Quilez\n{\n    vec3 x = vec3( uv.xy, 0.0 );\n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float offset = 57.0;\n    \n    float n = dot( p, vec3(1.0, offset, offset*2.0) );\n    \n    return mix(\tmix(\tmix( hash( n + 0.0 ), \t\thash( n + 1.0 ), f.x ),\n        \t\t\t\tmix( hash( n + offset), \thash( n + offset+1.0), f.x ), f.y ),\n\t\t\t\tmix(\tmix( hash( n + offset*2.0), hash( n + offset*2.0+1.0), f.x),\n                    \tmix( hash( n + offset*3.0), hash( n + offset*3.0+1.0), f.x), f.y), f.z);\n}\n\nfloat snoise( vec2 uv )\n{\n    return noise( uv ) * 2.0 - 1.0;\n}\n\n\nfloat perlinNoise( vec2 uv )\n{   \n    float n = \t\tnoise( uv * 1.0 ) \t* 128.0 +\n        \t\tnoise( uv * 2.0 ) \t* 64.0 +\n        \t\tnoise( uv * 4.0 ) \t* 32.0 +\n        \t\tnoise( uv * 8.0 ) \t* 16.0 +\n        \t\tnoise( uv * 16.0 ) \t* 8.0 +\n        \t\tnoise( uv * 32.0 ) \t* 4.0 +\n        \t\tnoise( uv * 64.0 ) \t* 2.0 +\n        \t\tnoise( uv * 128.0 ) * 1.0;\n    \n    float noiseVal = n / ( 1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0 + 64.0 + 128.0 );\n    noiseVal = abs(noiseVal * 2.0 - 1.0);\n    \n    return \tnoiseVal;\n}\n\nfloat fBm( vec2 uv, float lacunarity, float gain )\n{\n    float sum = 0.0;\n    float amp = 1.0;\n    \n    for( int i = 0; i < 10; ++i )\n    {\n        sum += ( perlinNoise( uv ) ) * amp;\n        amp *= gain;\n        uv *= lacunarity;\n    }\n    \n    return sum;\n}\n\nfloat pulse( float value, float minValue, float maxValue )\n{\n\tfloat t = step( minValue, value ) - step( maxValue, value );\n\t\n\treturn t;\n}\n\nvec3 cross( \tvec2 uv,\n\t\tfloat verticalBarWidth, \n\t    \tfloat verticalBarHeight, \n\t    \tfloat horizontalBarWidth, \n\t    \tfloat horizontalBarHeight,\n\t    \tfloat horizontalBarVerticalOffset,\n\t   \tvec2 position,\n\t   \tfloat scale,\n\t  \tvec3 color )\n{\n\tverticalBarWidth \t\t*= scale;\n\tverticalBarHeight \t\t*= scale;\n\thorizontalBarWidth \t\t*= scale;\n\thorizontalBarHeight \t\t*= scale;\n\thorizontalBarVerticalOffset \t*= scale;\n\t\n\tfloat verticleBar = pulse( uv.x, -verticalBarWidth + position.x, verticalBarWidth + position.x );\n\tverticleBar *= pulse( uv.y, -verticalBarHeight + position.y, verticalBarHeight + position.y );\n\t\n\tfloat horizontalBar = pulse( uv.x, -horizontalBarWidth + position.x, horizontalBarWidth + position.x );\n\thorizontalBar *= pulse( uv.y, -horizontalBarHeight  + horizontalBarVerticalOffset + position.y, horizontalBarHeight + horizontalBarVerticalOffset + position.y );\n\t\n\tfloat intensity = clamp(verticleBar + horizontalBar, 0.0, 1.0);\n\t\n\tvec3 finalColor = (color * intensity);\n\t\n\treturn  finalColor;\n}\n\nvec3 gloryGlow( vec2 uv, vec3 glowColor, float minGlow, float maxGlow, float noiseFactor, float speed )\n{\n\tfloat t = sin( Time ) * 0.50 + 0.50;\n\tfloat glowAmount = mix( minGlow, maxGlow, t );\n\tvec2 glowUV = uv + vec2( 0.0, 0.0 );\n\tfloat glowPulse = sin( glowUV.x * glowAmount );\n\tvec3 color = glowColor * abs( 1.0 / glowPulse ) * noiseFactor;\n\treturn color;\n}\n\nvec3 beam( vec2 uv, vec3 glowColor, float noiseFactor, float offset, float speed )\n{\n\tfloat t = sin( Time * speed ) * 0.50 + 0.50;\n\tfloat glowAmount = mix( 0.20, 1.0, t );\n\tvec2 glowUV = uv + vec2( 0.0, 0.0 );\n\tfloat glowPulse = sin( glowUV.x * glowAmount );\n\tfloat t2 = sin( Time * 0.50 ) * 0.50 + 0.50;\n\tfloat lengthOfBeam = mix( -1.0, 0.70, 1.0 - t2 );\n\tglowUV = uv + vec2( -1.24 - sin(offset + Time + uv.y * speed) * 0.10, 0.0 );\n\tglowPulse = sin( glowUV.x * 0.7  );\n\tfloat glowFactor = (( abs( 0.2 / glowPulse  ) * noiseFactor)) * (sin(uv.y + lengthOfBeam) * 1.0);\n\tvec3 color = clamp( glowColor *  glowFactor, 0.0, 1.50);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 uv = ( fragCoord.xy / Resolution.xy ) * 2.0 - 1.0;\n\tuv.x *= ( Resolution.x / Resolution.y );\n\t\n\tvec3 finalColor = vec3( 0.0, 0.0, 0.0 );\n\t\n\tfloat noiseFactor = fBm( uv * 1.0, 2.0, 0.9 );\n\t\n\tfinalColor += gloryGlow( uv, GloryGlowColor, CrossGloryGlowMin, CrossGloryGlowMax, noiseFactor, 1.0 );\n\t\n\tvec3 beamColor = vec3( 0.0, 0.0, 0.0 );\n\tbeamColor += beam( uv, vec3( 0.03, 0.03, 0.13), noiseFactor, 0.0, 2.4 );\n\tbeamColor += beam( uv, vec3( 0.03, 0.13, 0.03), noiseFactor, 0.2, 3.5 );\n\tbeamColor += beam( uv, vec3( 0.13, 0.13, 0.03), noiseFactor, 0.4, 4.6 );\n\tbeamColor += beam( uv, vec3( 0.13, 0.03, 0.03), noiseFactor, 1.0, 6.7 );\n\tbeamColor += beam( uv, vec3( 0.13, 0.03, 0.13), noiseFactor, 2.7, 8.7 );\n\t\n\tfloat t = sin( Time + (uv.y / 2.0) ) * 0.5 + 0.5;\n\tfinalColor += (beamColor * t);\n\t\n\tfinalColor += cross( \tuv, \n\t\t\t    \tVerticalBarWidth, \n\t\t\t    \tVerticalBarHeight, \n\t\t\t    \tHorizontalBarWidth + 0.05, \n\t\t\t    \tHorizontalBarHeight, \n\t\t\t    \tHorizontalBarVerticalOffset,\n\t\t\t    \tvec2( 0.0, 0.0 ),\n\t\t\t    \t1.0,\n\t\t\t   \tChristsCrossColor );\n\t\n\tfinalColor += cross( \tuv, \n\t\t\t    \tVerticalBarWidth, \n\t\t\t    \tVerticalBarHeight, \n\t\t\t    \tHorizontalBarWidth, \n\t\t\t    \tHorizontalBarHeight, \n\t\t\t    \tHorizontalBarVerticalOffset,\n\t\t\t    \tvec2( -1.2, -0.5 ),\n\t\t\t    \t0.2,\n\t\t\t   \tUnrepentantThiefsCrossColor );\n\t\n\tfinalColor += cross( \tuv, \n\t\t\t    \tVerticalBarWidth, \n\t\t\t    \tVerticalBarHeight, \n\t\t\t    \tHorizontalBarWidth, \n\t\t\t    \tHorizontalBarHeight, \n\t\t\t    \tHorizontalBarVerticalOffset,\n\t\t\t    \tvec2( 1.2, -0.5 ),\n\t\t\t    \t0.2,\n\t\t\t   \tRepentantThiefsCrossColor );\n\t\n\tfinalColor *= mix( 0.7, 1.0, uv.y );\n\tfinalColor *= mix( 0.7, 1.0, -abs(uv.x));\n\t\n\tfragColor = vec4( finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 1009, 1032, 1032, 1077], [1079, 1079, 1127, 1127, 1651], [1653, 1653, 1678, 1678, 1716], [1719, 1719, 1749, 1749, 2219], [2221, 2221, 2273, 2273, 2480], [2482, 2482, 2542, 2542, 2619], [2621, 2621, 2865, 2865, 3632], [3634, 3634, 3739, 3739, 3993], [3995, 3995, 4079, 4079, 4639], [4641, 4641, 4699, 4699, 6394]], "test": "untested"}
{"id": "MlsGR8", "name": "Kind of Mandelbrot", "author": "guil", "description": "A 3d fractal generated by the Mandelbrot equation z = zÂ²+c with an exotic multiplication", "tags": ["3d", "fractal"], "likes": 8, "viewed": 233, "published": "Public", "date": "1418689096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \nconst int MaxIter = 16;\nfloat preci;\nfloat zoom;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n\nvec4 map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tvec3 ot = vec3(1000.0);\n        float ot1=1.;\n\tfloat r2;\n\n        vec3 c= p;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(p,p);\n            if(r2>16.)continue;\n\t\t\n            ot = min( ot, abs(p) );\n            ot1=min(ot1,r2);\n            dr=2.*sqrt(r2)*dr+1.0;\n            p=dmul(p,p)+c;\t\t\t\t\t\t\n\t}\t\n\tfloat d =.5*length(p)*log(length(p))/dr;\t\n        return vec4(ot/(.3+ot1),d);\t\n}\n\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\n\tvec4 col = vec4(0, 0, 0, 0);\n\n\tfloat t = tminmax.x;\n        float dt = 1.;\n\tfor(int i=0; i<128; i++)\n\t{\n\t\t\n        if( t>tminmax.y || dt<=preci*t ) continue;\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\tcol = map( pos );\n\t\tdt = col.a;\t\t\n                t += dt;                        \t\t\n\t}\n        col =clamp( col, 0.0, 1.0 );\n\tcol.a = min(0.002/col.a,1.);\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n    \n    preci = .3/min(iResolution.x,iResolution.y);\n\tzoom = 1.+.4*sin(.1*iTime);\n\n    vec3 ro = zoom*3.0*vec3(cos(an), 0.5*cos(2.*an), sin(an));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    vec3 col = vec3(0.08,0.09,0.18);\n    vec2 seg = iSphere( ro, rd, vec4(0.0,0.0,0.0,2.0) );\n\tif( seg.x<0.0 )seg.x=0.;\n    if( seg.y>0.0 )\n\t\t{\n        \tvec4 res = raymarch( ro, rd, seg );\n            vec3 col1 =.5*(res.xyz+res.yxz);\n            col1.r+=.5*col1.g-.3*col1.b;            \n\t    \tcol = mix( col, col1, res.a );\n\t\t}\n\t\n\tcol = pow( col, vec3(0.4) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 142, 172, 172, 227], [228, 228, 250, 250, 299], [301, 301, 331, 331, 498], [501, 501, 554, 554, 740], [743, 743, 762, 762, 1184], [1188, 1188, 1247, 1247, 1605], [1608, 1608, 1665, 1665, 2688]], "test": "untested"}
{"id": "MlX3R7", "name": "Bad Trip", "author": "daeken", "description": "Boredom led to making a smiley face.", "tags": ["shaderforth"], "likes": 1, "viewed": 132, "published": "Public", "date": "1419909048", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ distance-2d ]\n\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\n: distance ( p:vec2 -> float )\n\t[ time sin time cos ] .01 * =look\n\t[\n\t\tp .6 circle\n\t\tp [ -.2 -.2 ] + .1 time 50 * sin .01 * + circle\n\t\tp [ .2 -.2 ] + .1 time 35 * sin .01 * + circle\n\t\tp [ -.2 -.2 ] look + + .02 time sin .01 * abs + circle\n\t\tp [ .2 -.2 ] look + + .02 circle\n\t\t$[-.25:+.25:.025] /{ ( i )\n\t\t\tp [ i .3 i 4 * cos abs .1 * .1 - time sin * + ] + .1 circle\n\t\t} union\n\t] /abs union\n;\n\niResolution frag->position =p\n\n&distance p gradient =d\n\t\td 150 * abs\n\t\td neg 150 * 0 1 clamp\n\t- abs\n\t0 1\nclamp =val\n\tval [ 0 0 0 ] *\n \t[ 1 1 1 ]\n\tval\nmix ->fragcolor\n*/\n\nfloat distancef(vec2 p) {\n\tvec2 look = vec2(sin(iTime), cos(iTime)) * .01;\n\treturn min(min(min(min(min(abs(length(p) - .6), abs(length(p + vec2(-.2, -.2)) - (.1 + sin(iTime * 50.) * .01))), abs(length(p + vec2(.2, -.2)) - (.1 + sin(iTime * 35.) * .01))), abs(length(p + vec2(-.2, -.2) + look) - (.02 + abs(sin(iTime) * .01)))), abs(length(p + vec2(.2, -.2) + look) - .02)), abs(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(length(p + vec2(-.25, .3 + (abs(cos(-1.00)) * .1 - .1) * sin(iTime))) - .1, length(p + vec2(-.225, .3 + (abs(cos(-.900)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.200, .3 + (abs(cos(-.800)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.175, .3 + (abs(cos(-.700)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.150, .3 + (abs(cos(-.600)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.125, .3 + (abs(cos(-.500)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.100, .3 + (abs(cos(-.400)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.075, .3 + (abs(cos(-.300)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.050, .3 + (abs(cos(-.200)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(-.025, .3 + (abs(cos(-.100)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(0., .3 + (abs(cos(0.)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.025, .3 + (abs(cos(.100)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.050, .3 + (abs(cos(.200)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.075, .3 + (abs(cos(.300)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.100, .3 + (abs(cos(.400)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.125, .3 + (abs(cos(.500)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.150, .3 + (abs(cos(.600)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.175, .3 + (abs(cos(.700)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.200, .3 + (abs(cos(.800)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.225, .3 + (abs(cos(.900)) * .1 - .1) * sin(iTime))) - .1), length(p + vec2(.250, .3 + (abs(cos(1.000)) * .1 - .1) * sin(iTime))) - .1)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec2 h = vec2(.00001, 0.);\n\tfloat d = distancef(p) / abs(length(vec2(distancef(p + h) - distancef(p - h), distancef(p + h.yx) - distancef(p - h.yx)) / (2. * h.x)));\n\tfloat val = clamp(abs(abs(d * 150.) - clamp(-d * 150., 0., 1.)), 0., 1.);\n\tfragColor = vec4(mix(val * vec3(0., 0., 0.), vec3(1., 1., 1.), val), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 734, 759, 759, 2806], [2807, 2807, 2864, 2864, 3277]], "test": "untested"}
{"id": "MlX3RH", "name": "4k raytracer", "author": "TomSalter", "description": "WebGL port of a raytracer I wrote a few years back for a 1 day coding contest.\n\nThere's currently a bug where the secondary bounces are brighter than the primary, but I've implemented a \"workaround\" ;)", "tags": ["raytracer", "4k"], "likes": 25, "viewed": 5297, "published": "Public", "date": "1418434277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constant state data\n\n#define NUM_SPHERES 6\n#define NUM_PLANES 5\n#define NUM_ITERATIONS 4\n#define SRO ((curr_iteration == 0) ? 4.0 : 1.0)\n#define SHADOW_RAYS (SRO*SRO*SRO)\n\nvec4 g_spheres[NUM_SPHERES];\nvec4 g_sphereColors[NUM_SPHERES];\nvec4 g_planes[NUM_PLANES];\nvec4 g_planeColors[NUM_PLANES];\n\n// Variable global state\nint curr_iteration;\nvec4 g_light;\n\nbool isect_sphere(vec3 o, vec3 d, vec3 c, float rsq, out float t)\n{\n    vec3 l = c-o;\n    float tca = dot(l,d);\n    if (tca < 0.0) return false;\n    float dsq = -tca*tca + dot(l,l);\n    if (dsq > rsq) return false;\n    float thc = sqrt(rsq - dsq);\n    t = tca - thc;\n    return true;    \n}\n\nfloat fmod(float x, float y)\n{\n  return x - y * floor(x/y);\n}\n\nbool shadowRayCast(vec3 r, vec3 light_pos)\n{\n    vec3 d = light_pos - r;\n    \n    float lowest_t = length( d );\n\n    d = normalize(d);\n    \n    bool hit = false;\n    \n    for( int j = 0; j < NUM_SPHERES - 1; ++j )\n    {\n\t\tfloat t;\n        if( isect_sphere( r, d, g_spheres[j].xyz, g_spheres[j].w, t ) )\n        {\n\t\t\tif( t < lowest_t )\n            {\n                lowest_t = t; hit = true;\n            }\n        }\n    }\n    \n    for( int j = 0; j < NUM_PLANES; ++j )\n    {\n\t\tvec3 np = g_planes[j].xyz;\n        float np_dot_d = dot(np, d);\n        if( abs(np_dot_d) > 0.001 )\n        {\n            float t = (g_planes[j].w - dot(np, r)) / np_dot_d;\n            if( t > 0.0 && t < lowest_t )\n            {\n\t\t\t\tlowest_t = t; hit = true;\n            }\n        }\n    }\n    \n    return hit;\n}\n\nfloat getShadowTerm(vec3 r)\n{\n\tfloat light_amount = 1.0;\n    \n    if( curr_iteration == 0 )\n    { \n        for( int i=0; i < 64; ++i )\n        {\n            vec3 light_pos = g_light.xyz;\n\t\t\tfloat ofsx = fmod(float(i), SRO);\n        \tfloat ofsy = (float(i)*SRO)/SRO;\n    \t\tfloat ofsz = fmod(float(i)*SRO*SRO, SRO);\n    \t\tvec3 offset = 1.0 * vec3(ofsx, ofsy, ofsz);\n    \t\tlight_pos += offset;\n        \n        \tif( shadowRayCast(r, light_pos) ) \n        \t{\n\t\t\t\tlight_amount -= 1.0 / 64.0;\n        \t}\n  \t  \t}\n    }\n    else\n    {\n        // LOLHAX!!!!\n        light_amount = 0.33;\n        if( shadowRayCast(r, g_light.xyz) )\n        {\n\t\t\tlight_amount = 0.0;\n        }\n    }\n   \n    return light_amount;\n}\n\nvec4 isect( inout vec3 r, inout vec3 d, inout float reflectance )\n{\n\tfloat lowest_t = 10000000.0;\n    bool hit = false;\n    vec3 n = vec3(0, 1, 0);\n    vec3 p = vec3(0, 0, 0);\n    vec3 c = vec3(0, 0, 0);\n    \n    for( int i = 0; i < NUM_SPHERES; ++i )\n    {\n\t\tfloat t;\n        if( isect_sphere( r, d, g_spheres[i].xyz, g_spheres[i].w, t ) )\n        {\n         \tif( t < lowest_t )\n            {\n\t\t\t\tp = r + d * t;\n                n = normalize(p - g_spheres[i].xyz);\n                c = g_sphereColors[i].rgb;\n                reflectance = g_sphereColors[i].w;\n                lowest_t = t;\n                hit = true;\n            }\n        }\n    }\n    \n    for( int i = 0; i < NUM_PLANES; ++i )\n    {\n\t\tvec3 np = g_planes[i].xyz;\n        float np_dot_d = dot(np, d);\n        \n        if( abs(np_dot_d) > 0.001 )\n        {\n\t\t\tfloat t = (g_planes[i].w - dot(np, r)) / np_dot_d;\n            if( t > 0.0 && t < lowest_t )\n            {\n\t\t\t\tp = r + (d * t);\n                n = np;\n                bool xeven = fract(p.x * 0.1) > 0.5;\n                bool zeven = fract(p.z * 0.1) > 0.5;\n                \n                c = g_planeColors[i].rgb;\n                reflectance = g_planeColors[i].w;\n                lowest_t = t; hit = true;\n            }\n        }\n    }\n\n    if( hit )\n    {\n\t\tvec3 l = (g_light.xyz - p);\n        float dist = length( l );\n        l = l / dist;\n        \n        float ndotl = dot(n, l) * clamp(1.0 / dist*dist, 0.0, 1.0);\n        vec3 ambient = clamp(c.rgb * 0.25, 0.0, 1.0);\n        vec3 diffuse = clamp(ndotl * c.rgb, 0.0, 1.0);\n        float fresnel = 1.0 - clamp( abs( dot( n, d ) ), 0.0, 0.5);\n        reflectance = fresnel*fresnel * reflectance;\n        \n        vec3 inc = normalize(p-r);\n        r = p + n;\n        d = normalize( reflect(inc, n) );\n        \n        vec3 rl = reflect( l, n );\n        float rdotv = pow( clamp( dot( rl, d ), 0.0, 1.0 ), 3.0 );\n        vec3 specular = vec3(rdotv, rdotv, rdotv);\n        vec3 result = ambient.rgb;\n        result += getShadowTerm( r ) * (diffuse.rgb + specular.rgb);\n        \n        return vec4( result.rgb, 1 );\n    }\n    \n    reflectance = 0.0;\n    return vec4( 0, 0, 0, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize variables   \n    float time = 3.0;\n    float s0 = 0.5 * sin(iTime * time);\n    float s1 = 0.5 * cos(iTime * time);\n    \n    float bounce0 = abs( sin(iTime * time * 1.1) );\n    float bounce1 = abs( cos(iTime * time * 1.0) );\n    float bounce2 = abs( sin(iTime * time * 0.7) );\n    float bounce3 = abs( sin(iTime * time * 0.35) );\n    \n    float cx = sin(iTime);\n    float cz = cos(iTime);\n    g_light = vec4(cx * 40.0, bounce3 * 0.0 + 50.0, 100.0 + cz * 40.0, 1.0);\n    \n    g_spheres[0] = vec4(-50.0, bounce2 * 40.0 - 10.0, 100.0, 20.0*20.0);// + vec4(0.0, 0.0, s1 * 20.0, 0);\n\tg_spheres[1] = vec4(-15.0, bounce1 * 15.0 - 15.0, 100.0, 10.0*10.0);\n\tg_spheres[2] = vec4(0.0, bounce0 * 25.0 - 20.0, 100.0,  5.0*5.0);\n\tg_spheres[3] = vec4(15.0, bounce1 * 15.0 - 15.0, 100.0, 10.0*10.0);\n\tg_spheres[4] = vec4(50.0, bounce2 * 40.0 - 10.0, 100.0, 20.0*20.0);// + vec4(0.0, 0.0, s0 * 20.0, 0);\n    g_spheres[5] = vec4(g_light.x, g_light.y, g_light.z, 3.0);\n    \n    g_sphereColors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n\tg_sphereColors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n\tg_sphereColors[2] = vec4(0.0, 0.0, 1.0, 1.0);\n    g_sphereColors[3] = vec4(0.0, 1.0, 0.0, 1.0);\n\tg_sphereColors[4] = vec4(1.0, 0.0, 0.0, 1.0);\n    g_sphereColors[5] = vec4(10.0, 10.0, 10.0, 0.0);\n        \n    // bottom\n\tg_planes[0] = vec4(0.0, 1.0, 0.0, -25.0);\n\tg_planeColors[0] = vec4(0.77, 0.64, 0.3, 0.7);\n    // left\n    g_planes[1] = vec4(1.0, 0.0, 0.0, -100.0);\n    g_planeColors[1] = vec4(1.0, 0.15, 0.15, 0.1);\n\t// top\n\tg_planes[2] = vec4(0.0,-1.0, 0.0, -75.0);\n    g_planeColors[2] = vec4(0.77, 0.64, 0.38, 0.1);\n\t//right\n\tg_planes[3] = vec4(-1.0, 0.0, 0.0, -100.0);\n    g_planeColors[3] = vec4(0.15, 1.0, 0.15, 0.1);\n\t// back\n\tg_planes[4] = vec4(0.0, 0.0, -1.0, -200.0);\n    g_planeColors[4] = vec4(0.77, 0.64, 0.38, 0.1);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Calc initial ray\n    vec3 o = vec3(0.0, 25.0, -50.0);\n    float rx = mix(-0.8, 0.8, uv.x);\n    float ry = mix(-0.45, 0.45, uv.y);\n    vec3 d = normalize( vec3(rx, ry, 1.0) );\n    \n    vec4 final_color = vec4(0.5, 0.0, 0.0, 0.0);\n    float reflectance = 1.0;\n    float this_refl = reflectance;\n    \n    for( int i = 0; i < NUM_ITERATIONS; ++i )\n    {\n\t\tcurr_iteration = i;\n        this_refl *= reflectance;\n        vec4 new_color = isect( o, d, reflectance );\n        final_color = mix( final_color, new_color, this_refl );\n        if( reflectance < 1e-3) break;\n    }\n        \n    fragColor = vec4(final_color.rgb, 1.0 );\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 358, 425, 425, 647], [649, 649, 679, 679, 710], [712, 712, 756, 756, 1499], [1501, 1501, 1530, 1530, 2202], [2204, 2204, 2271, 2271, 4366], [4368, 4368, 4425, 4456, 6960]], "test": "untested"}
{"id": "MlX3RN", "name": "tgc_test", "author": "mbanquiero", "description": "test de raytracing", "tags": ["raytracingcharacters"], "likes": 0, "viewed": 204, "published": "Public", "date": "1419122268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fov = 3.1415 / 4.0;\nconst float EP = 0.05;\nconst float box_r = 1.5;\nconst mat4 mT = mat4(\t2.0,0.0,\n                     \t2.0,1.0,\n                     \t2.0,2.0,\n                     \t2.0,3.0,\n                    \t0.0,3.0,\n                     \t1.0,3.0,\n                    \t3.0,3.0,\n                     \t4.0,3.0);\n\nconst mat4 mG = mat4(\t0.0,1.0,\n                     \t0.0,2.0,\n                     \t1.0,0.0,\n                     \t1.0,3.0,\n                    \t2.0,0.0,\n                     \t2.0,3.0,\n                    \t3.0,0.0,\n                     \t3.0,1.0);\n\nconst mat4 mC = mat4(\t0.0,1.0,\n                     \t0.0,2.0,\n                     \t1.0,0.0,\n                     \t1.0,3.0,\n                    \t2.0,0.0,\n                     \t2.0,3.0,\n                    \t3.0,0.0,\n                     \t3.0,3.0);\n    \n    \n    \nfloat rand(vec3 x)\n{\n\tfloat n = dot(x , vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453) - 0.5;\n}\n\nbool ray_aabb(vec3 org,vec3 dir,vec3 lb, vec3 rt,out float dist)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        rta = true;\n        dist = tmin;\n    }\n\treturn rta;\n}\n\n\nbool ray_edge(vec3 org,vec3 dir,vec3 lb, vec3 rt)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        int cant = 0;\n\t\tvec3 Ip = org + dir*tmin;\n        vec3 Ta = abs(Ip - lb);\n        vec3 Tb = abs(Ip - rt);\n        if( Ta.x < EP)\n            cant++;\n        if( Ta.y < EP)\n            cant++;\n        if( Ta.z < EP)\n            cant++;\n        \n        if( Tb.x < EP)\n            cant++;\n        if( Tb.y < EP)\n            cant++;\n        if( Tb.z < EP)\n            cant++;\n        \n        rta = cant>=2 ? true : false;\n    }\n\treturn rta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat x = 2.0*uv.x-1.0;\n    float y = 2.0*uv.y-1.0;\n\tfloat time = iTime*2.0;\n    vec3 vLookFrom = vec3(30.0*sin(time),10.0*cos(time),30.0*cos(time));\n    vec3 vLookAt = vec3(0.0,0.0,0.0);\n    vec3 N = normalize(vLookAt-vLookFrom);\n    vec3 V = normalize(cross( N , vec3(0.0,1.0,0.0)));\n    vec3 U = cross(V , N);\n    float k = 2.0*tan(fov/2.0);\n\tvec3 Dy = U*(k*iResolution.y/iResolution.x*0.8);\n\tvec3 Dx = V*k;\n    \n\t// direccion de cada rayo\n\tvec3 D = normalize(N + Dx*x + Dy*y);\n    vec3 box_dim = vec3(box_r,box_r,box_r);\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    float min_dist = 1000000.0;\n    for(float s=0.0;s<3.0;++s)\n    for(int i=0;i<4;++i)\n    for(int j=0;j<2;++j)\n    {\n        float rnd = rand(vec3(uv,time));\n\t\tfloat dist;\n        vec3 box_or;\n        if(s==0.0)\n        \tbox_or = vec3(mT[i][j*2],mT[i][j*2+1],0.0) * box_dim*1.5; \n       \telse\n        if(s==1.0)\n        \tbox_or = vec3(mG[i][j*2],mG[i][j*2+1],0.0) * box_dim*1.5;\n        else\n        \tbox_or = vec3(mC[i][j*2],mC[i][j*2+1],0.0) * box_dim*1.5;\n            \n \t\tbox_or += vec3(box_r*8.0 * (s-1.0) , -box_r , 0.0);            \n        box_or +=  rnd*box_dim;\n        bool hit_edge = ray_edge(vLookFrom,D , box_or-box_dim, box_or+box_dim);\n        \n        if(hit_edge)\n        {\n            fragColor = vec4(0.75,0.8,1.0,1.0);            \n        }\n        else\n        {\n        \tbox_or +=  rnd*box_dim*3.0;\n            bool hit = ray_aabb(vLookFrom,D , box_or-box_dim, box_or+box_dim, dist);\n\n            if(hit && dist<min_dist)\n            {\n                min_dist = dist;\n                vec3 Ip = vLookFrom + D*dist;\n                float d = length(Ip-box_or) / (2.0 * box_r);\n                d = pow(d,3.0);\n                fragColor = vec4(d,d,0,1.0);            \n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[838, 838, 858, 858, 947], [949, 949, 1015, 1015, 1373], [1376, 1376, 1427, 1427, 2172], [2174, 2174, 2231, 2231, 4070]], "test": "untested"}
{"id": "MlXGRH", "name": "Meta Experiment 4", "author": "aiekick", "description": "Meta Experiment 4", "tags": ["meta", "metaholeexperiment"], "likes": 2, "viewed": 1087, "published": "Public API", "date": "1418426963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define nMetaHole 17. // must be odd number (also not factor of five)\nvec2 getPos(vec2 p){\n    float ratio = iResolution.x/iResolution.y;\n    float t = cos(iTime*1.)*10.;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.)*2.;//centering -1->0->1 x & y\n}\nfloat metahole(vec2 p, vec2 o, float r1, float r2, float thick){\n    vec2 po = p-o;\n\tfloat t =  sin(iTime*1.);\n  \treturn (thick/dot(p*t, o*t)) / length(vec2(dot(po+r1, po-r1),dot(po+r2, po-r2)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = getPos(fragCoord.xy);\n\tfloat t = 0.5*sin(iTime*0.3)+0.5;\n    float t2 = sin(iTime*0.3);\n\tfloat t3 = 0.7*sin(iTime*0.3);\n    float d=0.;\n    for(float i=0.; i<6.2831; i+=6.2831/nMetaHole){\n        d+=metahole(uv, vec2(cos(i)*t2,sin(i)*t2), 0.4, 0.4, 0.005);\n    }\n    float r = mix(1./d, d, abs(t3));\n    float g = mix(r, d, abs(t3));\n    float b = mix(g, d, abs(t3));\n    vec3 c = vec3(r,g,b);\n\tfragColor.rgb = vec3(c-t*2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXGRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 207, 227, 227, 391], [392, 392, 456, 456, 589], [590, 590, 646, 646, 1087]], "test": "untested"}
{"id": "MlXGzr", "name": "Jelly-something", "author": "Kali", "description": "Just raymarching something jelly but I don't have any idea what it is... :D - added some kind of noisy DOF", "tags": ["raymarching"], "likes": 71, "viewed": 3820, "published": "Public", "date": "1417846483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Jelly-something\" by Kali\n\nconst int Iterations=7;  \nconst float Wavelength=.5; \nconst float Scale=1.5; \nconst float Amplitude=.1; \nconst float Speed=.3; \n\nvec3 z;\n\nconst vec3 fore=vec3(200.,20.,30.)/255.;\nconst vec3 back=vec3(45.,52.,55.)/255.;\nconst vec3 innards=vec3(250.,0.,0.)/255.;\nconst float detail=.04;\n\nconst vec3 lightdir=-vec3(-1.0,0.5,-0.5);\n\nmat2 rot2D(float angle)\n{\n\tfloat a=radians(angle);\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n\n}\n\n\n\nfloat de (in vec3 p);\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvec3 light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*fore+pow(spec,40.)*.4+fore*.2+back*.3;\t\n\t\t}\n\nfloat kaliset(vec3 p) {\n\tp.x+=.23;\n\tp.z+=.18;\n    p*=.5;\n    p.y+=iTime*1.5;\n    p.y=abs(2.-mod(p.y,4.));\n    for (int i=0;i<8;i++) p=abs(p)/dot(p,p)-.8;\n    return p.y;\n}\n\nfloat rnd(vec2 co){\n\treturn fract(sin(iTime*.1+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n    vec3 odir=dir;\n    float totdist=0., v=0.;\n\tvec3 col=vec3(0.), p;\n\tfloat d=9999.;\n\tfor (int i=0; i<80; i++) {\n        if (d>detail && totdist<50.) {\n        \tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\ttotdist+=d*.8; \n            v++;\n\t\t\tdir=normalize(odir+pow(max(0.,totdist*totdist-9.),2.)*.0000003*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n        }\n\t}\n\ttotdist=min(50.,totdist);\n\t\tdir=normalize(odir+.1*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n    vec3 backg=back*(1.+pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5));\n    if (d<detail) {\n\t\tfloat k=kaliset(p);\n        col=light(p-detail*dir, dir)+k*.05*(innards+.3); \n    } else {\n        col=backg+v*.015*pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5);\n    }\n\tcol = mix(col*1.2, backg, 1.0-exp(-.0045*totdist*totdist));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tfloat time=iTime*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tuv=uv.yx;\n\tvec3 from=vec3(.5,0.,-18.+cos(time*.8)*4.5);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tmat2 camrot1=rot2D(50.);\n\tmat2 camrot2=rot2D(190.+sin(time*.5)*80.);\n\tmat2 camrot3=rot2D((sin(time))*10.);\n\tfrom.xz=from.xz*camrot1;\n\tdir.xz=dir.xz*camrot1;\n\tfrom.xy=from.xy*camrot2;\n\tdir.xy=dir.xy*camrot2;\n\tdir.yz=dir.yz*camrot3;\n\t\n\tvec3 col=raymarch(from,dir); \n\tcol=pow(col,vec3(1.3))*vec3(1.,1.2,1.2);\n\tfragColor = vec4(col,1.0);\n}\n\n\nfloat de(vec3 pos)\n{\n\tfloat time=iTime;\n\tz=pos;\n\tfloat O=7.;\n\tfloat sc=1.;\n\tfloat tsc=pow(Scale,float(Iterations));\n\tfloat t=time*Speed*10./tsc+100.;\n\tfloat amp1=Amplitude;\n\tfloat amp2=amp1*1.1256;\n\tfloat amp3=amp1*1.0586;\n\tfloat amp4=amp1*0.9565;\n\tfloat l1=length(z.xy-vec2(O*1.1586,0));\n\tfloat l2=length(z.xy+vec2(O*.98586,0));\n\tfloat l3=length(z.xy+vec2(0,O*1.13685));\n\tfloat l4=length(z.xy-vec2(0,O));\n\tfor (int n=0; n<Iterations ; n++) {\n\t\tz+=sin(length(z.xy)*sc*Wavelength-t)*amp1/sc*2.;\n\t\tz+=sin(l1*sc*Wavelength-t)*amp1/sc;\n\t\tz+=sin(l2*sc*Wavelength-t)*amp2/sc;\n\t\tz+=sin(l3*sc*Wavelength-t)*amp3/sc;\n\t\tz+=sin(l4*sc*Wavelength-t)*amp4/sc;\n\t\tt=t*Scale*Scale;\n\t\tsc*=Scale;\n\t}\n\t//z.z*=3.;\n\tfloat wd=-z.z+2.;\n\treturn length(z)-6.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 359, 384, 384, 456], [483, 483, 504, 504, 658], [661, 661, 697, 697, 899], [901, 901, 924, 924, 1072], [1074, 1074, 1093, 1093, 1171], [1174, 1174, 1217, 1217, 2072], [2074, 2074, 2131, 2131, 2714], [2717, 2717, 2737, 2737, 3452]], "test": "untested"}
{"id": "Mtf3RM", "name": "Shaderforth Mandelbrot", "author": "daeken", "description": "Realized that I've never written a Mandelbrot set renderer; figured I'd correct that.", "tags": ["mandelbrot", "shaderforth"], "likes": 0, "viewed": 167, "published": "Public", "date": "1419794974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\niResolution frag->position =p\n\n:m c* ( $a $b ) [ a .x b .x * a .y b .y * - a .y b .x * a .x b .y * + ] ;\n:m csq dup c* ;\n:m cmag length ;\n\n6 =>maxplunge\n\n[\n\t0 [ -.746 .09997 ]\n\t1 [ .275 .0077 ]\n\t2 [ -.101 .837 ]\n\t[ -.088 .6555 ]\n] !size 1 + =>count time maxplunge count * mod maxplunge 2 * / floor choose =point\n\nmaxplunge time maxplunge 2 * mod maxplunge swap - abs - =mtime\n[ 0 0 ] =z\np mtime mtime 1 + ** / point + =c\n\n200 =>numiters\n\n{\n\tfloat numiters 1 - / =depth\n\tz csq c + =z\n\t&break z cmag 2 > when\n} numiters times\n\n\t[ depth 1 1 ] hsv1->rgb\n\t[ 0 0 0 ]\ndepth 1 < select ->fragcolor\n*/\n\nvec3 hsv1_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat depth;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tvec2 point = floor(mod(iTime, 48.) / 12.) == 0. ? vec2(-.746, .09997) : floor(mod(iTime, 48.) / 12.) == 1. ? vec2(.275, .0077) : floor(mod(iTime, 48.) / 12.) == 2. ? vec2(-.101, .837) : vec2(-.088, .6555);\n\tfloat mtime = 6. - abs(6. - mod(iTime, 12.));\n\tvec2 z = vec2(0., 0.);\n\tvec2 c = p / pow(mtime, mtime + 1.) + point;\n\tfor(int temp_4 = 0; temp_4 < 200; ++temp_4) {\n\t\tdepth = float(temp_4) / 199.;\n\t\tz = vec2(z.x * z.x - z.y * z.y, z.y * z.x + z.x * z.y) + c;\n\t\tif(length(z) > 2.) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfragColor = vec4(depth < 1. ? hsv1_rgb(vec3(depth, 1., 1.)) : vec3(0., 0., 0.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtf3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 742, 767, 767, 885], [886, 886, 943, 943, 1645]], "test": "untested"}
{"id": "Mtf3zM", "name": "Aquarium", "author": "dr2", "description": "How many robofish can you see?", "tags": ["reflection", "refraction", "waveoptics"], "likes": 10, "viewed": 1055, "published": "Public API", "date": "1419840115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Aquarium\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Includes refraction, total internal reflection and Fresnel reflection\n// (correctness not guaranteed, proof left as exercise for reader).\n\n// Pseudo-caustics based on Dave_H's \"Tileable Water Caustic\".\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  float s = length (max (d, 0.));\n  d = min (d, 0.);\n  return max (d.x, max (d.y, d.z)) + s;\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrIBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = min (abs (p) - b, 0.);\n  return max (d.x, max (d.y, d.z));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)),\n     step (c.b, c.g));\n  vec4 q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  float d = q.x - min (q.w, q.y);\n  const float e = 1.e-10;\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nint idObj;\nmat3 fishMat, vuMat;\nvec3 fishPos, qHit, sunDir, tankSize, waterDisp, cloudDisp;\nfloat tCur, fishLen, angTail, angFin, posMth;\nbool inTank, chkTank;\nconst float dstFar = 100.;\nconst int idStn = 1, idTkFlr = 2, idTkFrm = 3, idBrWall = 4, idTbl = 5,\n   idFBdy = 21, idTail = 22, idFin = 23, idEye = 24;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f;\n  if (rd.y > 0.) {\n    ro.xz += cloudDisp.xz;\n    p = 0.05 * (rd.xz * (70. - ro.y) / rd.y + ro.xz);\n    w = 0.8;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.5;  p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.3, 0., 1.);\n    f = max (dot (rd, sunDir), 0.);\n    col =  mix (vec3 (0.2, 0.3, 0.55) + 0.2 * pow (1. - rd.y, 5.) +\n       (0.35 * pow (f, 6.) + 0.65 * min (pow (f, 256.), 0.3)),\n       vec3 (0.85), cloudFac);\n  } else {\n    p = -0.02 * (rd.xz * ro.y / rd.y + ro.xz);\n    w = 1.;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.7;  p *= 2.5;\n    }\n    col = mix ((1. + min (f, 1.)) * vec3 (0.15, 0.2, 0.15),\n       vec3 (0.2, 0.3, 0.55) + 0.2, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nvec3 BrickSurfCol (vec2 p) {\n  vec2 q = p * vec2 (1./40., 1./20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y / 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (10. * p)) * (0.2 + 0.8 * q.x * q.y) *\n     vec3 (0.5, 0.4, 0.3);\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 150.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nfloat WaterHt (vec3 p)\n{\n  float ht, w;\n  const float wb = 1.414;\n  p *= 0.05;\n  ht = 0.;\n  w = wb;\n  for (int j = 0; j < 4; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    p += waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.1 * ht;\n}\n\nvec3 WaterNf (vec3 p)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nfloat TableDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, d1, d2, br, bl, sFac;\n  sFac = 2.5;  br = 1.6 * sFac;  bl = 1.1 * sFac;\n  p -= vec3 (0., - 2.2 * sFac - 0.01 * br, 0.);\n  q = p;\n  d = PrBoxDf (q, br * vec3 (1., 0.042, 0.6));\n  p.xz += 0.05 * br * vec2 (1., 1.5);\n  q = p;  q.y += bl;\n  d1 = PrCylDf (q.xzy, 0.07 * br, bl);\n  q = p;  q.y += 2. * bl;\n  d2 = max (PrCylDf (q.xzy, 0.5 * br, 0.15 * br * (1. -\n     0.7 * smoothstep (0.2 * br, 0.35 * br, length (p.xz)))), -0.05 * br - q.y);\n  d = min (d, min (d1, d2));\n  if (d < dHit) { dHit = d;  idObj = idTbl;  qHit = q; }\n  return dHit;\n}\n\nfloat TankWlDf (vec3 p, float dHit)\n{\n  float d;\n  d = (inTank)? max (PrIBoxDf (p, tankSize + 0.025 * tankSize.x),\n     - PrIBoxDf (p, tankSize + 0.015 * tankSize.x)) : PrOBoxDf (p, tankSize);\n  if (d < dHit) { dHit = d;  qHit = p;  idObj = 10; }\n  return dHit;\n}\n\nfloat FishDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, wr, tr, u;\n  q = p;  q.x = abs (q.x);  q -= fishLen * vec3 (0.12, 0.1, 0.9);\n  d = PrSphDf (q, 0.05 * fishLen);\n  if (d < dHit) { dHit = d;  idObj = idEye;  qHit = q; }\n  q = p;\n  wr = q.z / fishLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * (0.33 - 0.13 * u); \n  }\n  q.y *= 0.5;\n  d = PrCapsDf (q, 1.1 * tr * fishLen, fishLen);\n  q.y *= 2.;  q.z -= posMth * fishLen;\n  d = max (d, - PrCylDf (q.yzx, 0.03 * fishLen, 0.1 * fishLen));\n  if (d < dHit + 0.01 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.01 * fishLen);  idObj = idFBdy;  qHit = q;\n  }\n  q = p;  q.z -= -0.9 * fishLen;  q.y *= 0.1;\n  wr = q.z / (0.4 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.05 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  float dTail = PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen);\n  d = max (dTail, 0.15 * fishLen - q.z);\n  if (d < dHit + 0.01 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.01 * fishLen);  idObj = idTail;  qHit = q;\n  }\n  q.z -= 0.15 * fishLen;\n  q.xz = Rot2D (q.xz, angTail);\n  d = max (PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen), q.z);\n  if (d < dHit) { dHit = d;  idObj = idTail;  qHit = q; }\n  q = p;  q.y *= 0.5;  q.z -= -0.75 * fishLen;\n  q = q.xzy;\n  d = max (PrCylDf (q, 0.022 * fishLen, 0.11 * fishLen), dTail);\n  if (d < dHit) { dHit = d;  idObj = idTail;  qHit = 0.2 * q.xzy; }\n  q = p;  q.x = abs (q.x) - 0.18 * fishLen;  q.y *= 0.1;  q.z -= 0.4 * fishLen;\n  q.xz = Rot2D (q.xz, angFin);\n  wr = q.z / (0.2 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.01 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  q.z -= 0.3 * fishLen;\n  d = PrCylDf (q, 0.12 * tr * fishLen, 0.5 * fishLen);\n  if (d < dHit + 0.005 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.005 * fishLen);  idObj = idFin;  qHit = q;\n  }\n  return 0.75 * dHit;\n}\n\nfloat TankIntDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.y -= -0.548 * tankSize.x;\n  d = max (max (PrSphDf (q, 0.35 * tankSize.x), q.y - 0.25 * tankSize.x), - q.y);\n  q.y -= 0.25 * tankSize.x;\n  d = max (d, - min (PrCylDf (q, 0.1 * tankSize.x, 0.4 * tankSize.x),\n     PrCylDf (q.zyx, 0.1 * tankSize.x, 0.4 * tankSize.x)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idStn; }\n  return dHit;\n}\n\nfloat TankExtDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.y -= - 2.7 * tankSize.x + 11.;  q.z -= 1.1 * tankSize.x;\n  d = PrBoxDf (q, vec3 (2.4, 1.35, 0.05) * tankSize.x);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrWall; }\n  q = p;  q -= vec3 (0., -2. * tankSize.x + 1., 1.1 * tankSize.x);\n  d = max (PrCylDf (q.xzy, 2.4 * tankSize.x, 0.05 * tankSize.x),\n     q.z);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrWall; }\n  q = p;  q.y -= - tankSize.y + 5.1;\n  dHit = TableDf (q, dHit);\n  return dHit;\n}\n\nfloat TankFrameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.y -= -0.489 * tankSize.x;\n  d = max (q.y, PrBoxDf (q, vec3 (tankSize.x, 0.01 * tankSize.x, tankSize.z)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idTkFlr; }\n  vec3 ts = tankSize - 0.01 * tankSize.x;\n  vec3 db = vec3 (0.1 * tankSize.x, 0., 0.);\n  q = p;\n  d = max (PrBoxDf (q, ts + 0.05 * tankSize.x),\n     - min (PrBoxDf (q, ts + 0.025 * tankSize.x),\n     min (PrBoxDf (q, ts + db.yzx), min (PrBoxDf (q, ts + db.zxy),\n     PrBoxDf (q, ts + db)))));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idTkFrm; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  if (chkTank) dHit = TankWlDf (p, dHit);\n  else {\n    dHit = TankFrameDf (p, dHit);\n    if (inTank) {\n      dHit = TankIntDf (p, dHit);\n      dHit = FishDf (fishMat * (p - fishPos), dHit);\n    } else dHit = TankExtDf (p, dHit);\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 60; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.1;\n    if (h < 0.001) break;\n  }\n  return clamp (0.6 + sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.3 + 0.7 * clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec3 FishCol (vec3 n)\n{\n  vec3 col;\n  const vec3 col1 = vec3 (1., 0.2, 0.1), col2 = vec3 (0.1, 1., 0.2);\n  qHit *= 20. / fishLen;\n  if (idObj == idEye) {\n    col = vec3 (0., 0.6, 1.);\n    if (qHit.z > 0.5) col = vec3 (0., 0., 0.1);\n  } else if (idObj == idFBdy) {\n    col = mix (col2, col1, 0.5 * (1. + sin (2. * qHit.y)));\n    vec3 nn = fishMat * n;\n    col = mix (col1,  mix (col, col2, smoothstep (0.7, 1., nn.y)),\n       smoothstep (-1., -0.7, nn.y)) *\n       (1. - 0.2 * SmoothBump (-0.2, 0.2, 0.1, qHit.x));\n  } else if (idObj == idTail) {\n    col = mix (col2, col1, 0.5 * (1. + sin (20. * qHit.y)));\n  } else if (idObj == idFin) {\n    col = mix (col2, col1, 0.5 * (1. + sin (20. * qHit.y)));\n  }\n  return col;\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col;\n  if (idObj == idStn) col = vec4 (0.16, 0.2, 0.16, 0.2) *\n     (0.1 + Fbm2 (5. * qHit.xz));\n  else if (idObj == idTkFlr) col = vec4 (0.2, 0.2, 0.05, 0.1) *\n     (0.5 + 0.5 * Fbm2 (10. * qHit.xz));\n  else if (idObj == idTkFrm) col = vec4 (0.2, 0.3, 0.9, 2.);\n  else if (idObj == idBrWall) col = vec4 (BrickCol (0.1 * qHit, n), 0.1);\n  else if (idObj == idTbl) col = vec4 (WoodCol (qHit, n), 0.3);\n  else col = vec4 (FishCol (n), 1.);\n  return col;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  qq = q;  c = 0.;\n  for (int k = 1; k <= 6; k ++) {\n    tt = t * (1. + 1. / float (k));\n    a1 = tt - qq;  a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.1 - 40. * c), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 roW, rdW, rdd, vn, vno, vnW, colD, colR, qHitTank;\n  float dstHit, dstTank, dstTankW, yLim, dif, ao, sh, reflFac, frnlFac;\n  int idObjT, idTank;\n  bool tWallHit, isDown;\n  const float eta = 1.25;\n  yLim = 0.999 * tankSize.y;\n  idObj = -1;\n  inTank = false;\n  chkTank = true;\n  dstTank = ObjRay (ro, rd);\n  if (idObj < 0) dstTank = dstFar;\n  idTank = -1;\n  if (dstTank < dstFar) {\n    idTank = idObj;\n    qHitTank = qHit;\n  }\n  idObj = -1;\n  chkTank = false;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  roW = ro;  rdW = rd;\n  dstTankW = dstTank;\n  reflFac = 1.;\n  frnlFac = 0.;\n  tWallHit = (dstTank < dstHit && idTank > 0);\n  if (tWallHit) {\n    ro += dstTank * rd;\n    chkTank = true;\n    vn = (qHitTank.y < yLim) ? ObjNf (ro) : WaterNf (qHitTank);\n    vnW = vn;\n    frnlFac = (qHitTank.y > - yLim) ? abs (dot (rd, vn)) : 0.;\n    rd = refract (rd, vn, 1. / eta);\n    ro += 0.01 * rd;\n    idObj = -1;\n    inTank = true;\n    dstTank = ObjRay (ro, rd);\n    if (idObj < 0) dstTank = dstFar;\n    idTank = -1;\n    if (dstTank < dstFar) {\n      idTank = idObj;\n      qHitTank = qHit;\n    }\n    idObj = -1;\n    chkTank = false;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    idObjT = idObj;\n    if (dstTank < dstHit && idTank > 0) {\n      ro += dstTank * rd;\n      chkTank = true;\n      vn = (qHitTank.y < yLim) ? ObjNf (ro) : - WaterNf (qHitTank);\n      rdd = refract (rd, vn, eta);\n      if (length (rdd) > 0.) {\n        rd = rdd;\n        reflFac *= 0.8;\n        inTank = false;\n      } else rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      idObj = -1;\n      chkTank = false;\n      dstHit = ObjRay (ro, rd);\n      if (idObj < 0) dstHit = dstFar;\n      idObjT = idObj;\n    }\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    chkTank = false;\n    vn = ObjNf (ro);\n    vno = vn;\n    idObj = idObjT;\n    if (idObj == idStn) {\n      vn = VaryNf (6. * qHit, vn, 5.);\n    } else if (idObj == idTkFlr) {\n      vn = (vn.y > 0.) ? VaryNf (10. * qHit, vn, 2.) : vn;\n    }\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, sunDir), 0.);\n    ao = ObjAO (ro, vn);\n    sh = (idObjT < idFBdy) ? ObjSShadow (ro, sunDir) : 1.;\n    colD = reflFac * objCol.rgb * (0.2 * ao + max (0., dif) * sh *\n       (dif + ao * objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    isDown = (vno.y < -0.999);\n    vno = normalize (smoothstep (0.1, 0.9, abs (vno)));\n    idObj = idObjT;\n    if (! isDown && (idObj <= idTkFlr || idObj >= idFBdy)) colD *= 1. +\n       ((idObj <= idTkFlr) ? 3. : 0.3) * TurbLt (0.1 * ro, vno, 0.5 * tCur);\n  } else colD = reflFac * BgCol (ro, rd);\n  colR = vec3 (0.);\n  reflFac = 1.;\n  if (tWallHit) {\n    ro = roW + dstTankW * rdW;\n    rd = (frnlFac > 0.) ? reflect (rdW, vnW) : rdW;\n    ro += 0.01 * rd;\n    inTank = false;\n    idObj = -1;\n    chkTank = false;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    idObjT = idObj;\n    if (dstHit < dstFar) {\n      ro += rd * dstHit;\n      vn = ObjNf (ro);\n      idObj = idObjT;\n      objCol = ObjCol (vn);\n      dif = max (dot (vn, sunDir), 0.);\n      ao = ObjAO (ro, vn);\n      sh = ObjSShadow (ro, sunDir);\n      colR = reflFac * objCol.rgb * (0.2 * ao + max (0., dif) * sh *\n         (dif + ao * objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    } else colR = reflFac * BgCol (ro, rd);\n    colR = HsvToRgb (RgbToHsv (colR) * vec3 (1., 0.7, 0.5));\n  }\n  frnlFac = (eta != 1. && frnlFac > 0.) ? 1. - pow (frnlFac, 4.) : 0.;\n  return sqrt (clamp (mix (colD, colR, smoothstep (0.98, 1., frnlFac)), 0., 1.));\n}\n\nvec3 FishTrack (float t)\n{\n  return 0.75 * tankSize * vec3 (cos (0.2 * t),\n     0.1 + 0.9 * sin (0.037 * t), sin (0.2 * t));\n}\n\nvoid FishPM (float t)\n{\n  float dt = 1.;\n  fishPos = FishTrack (t);\n  vec3 vel = (FishTrack (t + dt) - FishTrack (t - dt)) / (2. * dt);\n  float a = atan (vel.z, vel.x) - 0.5 * pi;\n  float ca = cos (a);\n  float sa = sin (a);\n  fishMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd;\n  float el, az, zmFac;\n  tankSize = vec3 (5., 2.5, 3.);\n  FishPM (tCur);\n  fishLen = 0.2 * tankSize.x;\n  angTail = 0.1 * pi * sin (5. * tCur);\n  angFin = pi * (0.8 + 0.1 * sin (2.5 * tCur));\n  posMth = 1.04 + 0.01 * sin (5. * tCur);\n  zmFac = clamp (3. + 0.4 * tCur, 3., 7.);\n  waterDisp = 0.1 * tCur * vec3 (1., 0., 1.);\n  cloudDisp = 4. * tCur * vec3 (1., 0., 1.);\n  el = pi * (-0.25 + 0.7 * SmoothBump (0.25, 0.75, 0.25,\n     mod (0.071 * tCur + 0.4 * pi, 2. * pi) / (2. * pi)));\n  az = 0.6 * pi * (1. - 0.5 * abs (el)) * sin (0.21 * tCur);\n  vec2 vf = vec2 (el, az);\n  vec2 cf = cos (vf);\n  vec2 sf = sin (vf);\n  vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n     mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n  rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  ro = vec3 (0., 0., -40.) * vuMat;\n  sunDir = normalize (vec3 (-0.2, 0.2, -1.)) * vuMat;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtf3zM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[258, 469, 493, 493, 540], [542, 542, 567, 567, 746], [748, 748, 773, 773, 1079], [1081, 1081, 1102, 1102, 1239], [1241, 1241, 1270, 1270, 1472], [1474, 1474, 1513, 1513, 1720], [1722, 1722, 1767, 1767, 1865], [1867, 1867, 1924, 1924, 2007], [2009, 2009, 2039, 2039, 2113], [2115, 2115, 2147, 2147, 2266], [2268, 2268, 2301, 2301, 2344], [2346, 2346, 2379, 2379, 2451], [2453, 2453, 2486, 2486, 2513], [2515, 2515, 2557, 2557, 2608], [2610, 2610, 2653, 2653, 2726], [2728, 2728, 2752, 2752, 3065], [3067, 3067, 3091, 3091, 3222], [3537, 3537, 3568, 3568, 4386], [4388, 4388, 4416, 4416, 4705], [4707, 4707, 4739, 4739, 4866], [4868, 4868, 4899, 4899, 5105], [5107, 5107, 5131, 5131, 5390], [5392, 5392, 5415, 5415, 5556], [5558, 5558, 5594, 5594, 6155], [6157, 6157, 6194, 6194, 6420], [6422, 6422, 6457, 6457, 8490], [8492, 8492, 8530, 8530, 8903], [8905, 8905, 8943, 8943, 9434], [9436, 9436, 9476, 9476, 10042], [10044, 10044, 10066, 10066, 10339], [10341, 10341, 10374, 10374, 10550], [10552, 10552, 10573, 10573, 10781], [10783, 10783, 10820, 10820, 11036], [11038, 11038, 11070, 11070, 11267], [11269, 11269, 11292, 11292, 11987], [11989, 11989, 12011, 12011, 12472], [12474, 12474, 12514, 12514, 12952], [12954, 12954, 12989, 12989, 16584], [16586, 16586, 16612, 16612, 16712], [16714, 16714, 16737, 16737, 16996], [16998, 16998, 17055, 17055, 18117]], "test": "untested"}
{"id": "Mtl3z4", "name": "Seabirds at Sunset", "author": "dr2", "description": "Searching for dinner.", "tags": ["raymarching", "birds", "atmospherics"], "likes": 70, "viewed": 3056, "published": "Public API", "date": "1419440496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Seabirds at Sunset\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Clouds and sky colors borrowed from nimitz's \"PostCard\".\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nint idObj, idObjGrp;\nmat3 bdMat, birdMat[2];\nvec3 bdPos, birdPos[2], fltBox, qHit, sunDir, waterDisp, cloudDisp;\nfloat tCur, birdVel, birdLen, legAng;\nconst float dstFar = 100.;\nconst int idWing = 21, idBdy = 22, idEye = 23, idBk = 24, idLeg = 25;\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.03;\n  p += waterDisp;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) + 20. * waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  float ht = WaterHt (p);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nfloat FbmS (vec2 p)\n{\n  float a = 1.;\n  float v = 0.;\n  for (int i = 0; i < 5; i ++) {\n    v += a * (sin (6. * Noisefv2 (p)) + 1.);\n    a *= 0.5;\n    p *= 2.;\n    p *= mat2 (0.8, -0.6, 0.6, 0.8);\n  }\n  return v;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, dDotS, skyHt;\n  skyHt = 200.;\n  p = ro + rd * (skyHt - ro.y) / rd.y;\n  ds = 0.1 * sqrt (distance (ro, p));\n  fd = 0.001 / (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz += cloudDisp.xz;\n  att = FbmS (p.xz);\n  attSum = att;\n  d = fd;\n  ds *= fd;\n  for (int i = 0; i < 4; i ++) {\n    attSum += FbmS (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  attSum *= 0.27;\n  att *= 0.27;\n  dDotS = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * dDotS);\n  sunCol = vec3 (1., 0.8, 0.7) * pow (dDotS, 1024.) +\n     vec3 (1., 0.4, 0.2) * pow (dDotS, 256.);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - dDotS) *\n     max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2), att), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (dDotS, 10.) + 0.5);\n  return col;\n}\n\nfloat AngQnt (float a, float s1, float s2, float nr)\n{\n  return (s1 + floor (s2 + a * (nr / (2. * pi)))) * (2. * pi / nr);\n}\n\nfloat BdWingDf (vec3 p, float dHit)\n{\n  vec3 q, qh;\n  float d, dd, a, wr;\n  float wngFreq = 6.;\n  float wSegLen = 0.15 * birdLen;\n  float wChord = 0.3 * birdLen;\n  float wSpar = 0.03 * birdLen;\n  float fTap = 8.;\n  float tFac = (1. - 1. / fTap);\n  q = p - vec3 (0., 0., 0.3 * birdLen);\n  q.x = abs (q.x) - 0.1 * birdLen;\n  float wf = 1.;\n  a = -0.1 + 0.2 * sin (wngFreq * tCur);\n  d = dHit;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar,\n         wr * wChord), - q.x));\n    }\n    if (dd < d) { d = dd;  qh = q; }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idWing;  qHit = qh; }\n  return dHit;\n}\n\nfloat BdBodyDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, a, wr;\n  float bkLen = 0.15 * birdLen;\n  q = p;\n  wr = q.z / birdLen;\n  float tr, u;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * birdLen, birdLen);\n  if (d < dHit) {\n    dHit = d;  idObj = idObjGrp + idBdy;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= birdLen * vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009 * birdLen, 0.2 * birdLen);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04 * birdLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idEye;  qHit = q; }\n  q = p;  q -= birdLen * vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.25 * wr * bkLen, 0.25 * wr * bkLen, bkLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idBk;  qHit = q; }\n  return dHit;\n}\n\nfloat BdFootDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float lgLen = 0.1 * birdLen;\n  float ftLen = 0.5 * lgLen;\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.1, -0.12, 0.6);\n  q.yz = Rot2D (q.yz, legAng);\n  q.xz = Rot2D (q.xz, -0.05 * pi);\n  q.z += lgLen;\n  d = PrCylDf (q, 0.15 * lgLen, lgLen);\n  if (d < dHit) { dHit = d;  idObj = idLeg;  qHit = q; }\n  q.z += lgLen;\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (q.xy, AngQnt (atan (q.y, - q.x), 0., 0.5, 3.));\n  q.xz = Rot2D (q.xz, - pi + 0.4 * legAng);\n  q.z -= ftLen;\n  d = PrCapsDf (q, 0.2 * ftLen, ftLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idLeg;  qHit = q; }\n  return dHit;\n}\n\nfloat BirdDf (vec3 p, float dHit)\n{\n  dHit = BdWingDf (p, dHit);\n  dHit = BdBodyDf (p, dHit);\n  dHit = BdFootDf (p, dHit);\n  return dHit;\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec3 col;\n  int ig = idObj / 256;\n  int id = idObj - 256 * ig;\n  float spec = 1.;\n  if (id == idWing) {\n    float gw = 0.15 * birdLen;\n    float w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col = mix (vec3 (0.05), vec3 (1.), w);\n  } else if (id == idEye) {\n    col = vec3 (0., 0.6, 0.);\n    spec = 5.;\n  } else if (id == idBdy) {\n    vec3 nn;\n    if (ig == 1) nn = birdMat[0] * n;\n    else nn = birdMat[1] * n;\n    col = mix (mix (vec3 (1.), vec3 (0.1), smoothstep (0.5, 1., nn.y)), vec3 (1.),\n       1. - smoothstep (-1., -0.7, nn.y));\n  } else if (id == idBk) {\n    col = vec3 (1., 1., 0.);\n  } else if (id == idLeg) {\n    col = (0.5 + 0.4 * sin (100. * qHit.z)) * vec3 (0.6, 0.4, 0.);\n  }\n  col.gb *= 0.7;\n  return vec4 (col, spec);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  idObjGrp = 1 * 256;\n  dHit = BirdDf (birdMat[0] * (p - birdPos[0]), dHit);\n  idObjGrp = 2 * 256;\n  dHit = BirdDf (birdMat[1] * (p - birdPos[1]), dHit);\n  return 0.9 * dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn;\n  vec4 objCol;\n  float dstHit;\n  float htWat = -1.5;\n  float reflFac = 1.;\n  vec3 col = vec3 (0.);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (rd.y < 0. && dstHit >= dstFar) {\n    float dw = - (ro.y - htWat) / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    reflFac *= 0.7;\n  }\n  int idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = reflFac * SkyCol (ro, rd);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = BirdCol (vn);\n    float dif = max (dot (vn, sunDir), 0.);\n    col = reflFac * objCol.xyz * (0.2 + max (0., dif) *\n       (dif + objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.)));\n  }\n  return col;\n}\n\nvec3 BirdTrack (float t)\n{\n  t = - t;\n  vec3 bp;\n  float rdTurn = 0.45 * min (fltBox.x, fltBox.z);\n  float tC = 0.5 * pi * rdTurn / birdVel;\n  vec3 tt = vec3 (fltBox.x - rdTurn, length (fltBox.xy), fltBox.z - rdTurn) *\n     2. / birdVel;\n  float tCyc = 2. * (2. * tt.z + tt.x  + 4. * tC + tt.y);\n  float tSeq = mod (t, tCyc);\n  float ti[9];  ti[0] = 0.;  ti[1] = ti[0] + tt.z;  ti[2] = ti[1] + tC;\n  ti[3] = ti[2] + tt.x;  ti[4] = ti[3] + tC;  ti[5] = ti[4] + tt.z;\n  ti[6] = ti[5] + tC;  ti[7] = ti[6] + tt.y;  ti[8] = ti[7] + tC;\n  float a, h, hd, tf;\n  h = - fltBox.y;\n  hd = 1.;\n  if (tSeq > 0.5 * tCyc) { tSeq -= 0.5 * tCyc;  h = - h;  hd = - hd; }\n  float rSeg = -1.;\n  vec3 fbR = vec3 (1.);\n  fbR.xz -= vec2 (rdTurn) / fltBox.xz;\n  bp.xz = fltBox.xz;\n  bp.y = h;\n  if (tSeq < ti[4]) {\n    if (tSeq < ti[1]) {\n      tf = (tSeq - ti[0]) / (ti[1] - ti[0]);\n      bp.xz *= vec2 (1., fbR.z * (2. * tf - 1.));\n    } else if (tSeq < ti[2]) {\n      tf = (tSeq - ti[1]) / (ti[2] - ti[1]);  rSeg = 0.;\n      bp.xz *= fbR.xz;\n    } else if (tSeq < ti[3]) {\n      tf = (tSeq - ti[2]) / (ti[3] - ti[2]);\n      bp.xz *= vec2 (fbR.x * (1. - 2. * tf), 1.);\n    } else {\n      tf = (tSeq - ti[3]) / (ti[4] - ti[3]);  rSeg = 1.;\n      bp.xz *= fbR.xz * vec2 (-1., 1.);\n    }\n  } else {\n    if (tSeq < ti[5]) {\n      tf = (tSeq - ti[4]) / (ti[5] - ti[4]);\n      bp.xz *= vec2 (- 1., fbR.z * (1. - 2. * tf));\n    } else if (tSeq < ti[6]) {\n      tf = (tSeq - ti[5]) / (ti[6] - ti[5]);  rSeg = 2.;\n      bp.xz *= - fbR.xz;\n    } else if (tSeq < ti[7]) {\n      tf = (tSeq - ti[6]) / (ti[7] - ti[6]);\n      bp.xz *= vec2 (fbR.x * (2. * tf - 1.), - 1.);\n      bp.y = h + 2. * fltBox.y * hd * tf;\n    } else {\n      tf = (tSeq - ti[7]) / (ti[8] - ti[7]);  rSeg = 3.;\n      bp.xz *= fbR.xz * vec2 (1., -1.);\n      bp.y = - h;\n    }\n  }\n  if (rSeg >= 0.) {\n    a = 0.5 * pi * (rSeg + tf);\n    bp += rdTurn * vec3 (cos (a), 0., sin (a));\n  }\n  bp.y -= - 1.1 * fltBox.y;\n  return bp;\n}\n\nvoid BirdPM (float t)\n{\n  float dt = 1.;\n  bdPos = BirdTrack (t);\n  vec3 bpF = BirdTrack (t + dt);\n  vec3 bpB = BirdTrack (t - dt);\n  vec3 vel = (bpF - bpB) / (2. * dt);\n  float vy = vel.y;\n  vel.y = 0.;\n  vec3 acc = (bpF - 2. * bdPos + bpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  float el = - 0.7 * asin (vel.y / length (vel));\n  vec3 ort = vec3 (el, atan (vel.z, vel.x) - 0.5 * pi, 0.2 * length (va) * sign (va.y));\n  vec3 cr = cos (ort);\n  vec3 sr = sin (ort);\n  bdMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  legAng = pi * clamp (0.4 + 1.5 * el, 0.12, 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd, vd;\n  float zmFac = 2.4;\n  sunDir = normalize (vec3 (-1., 0.05, 0.));\n  waterDisp = -0.002 * tCur * vec3 (-1., 0., 1.);\n  cloudDisp = -0.05 * tCur * vec3 (1., 0., 1.);\n  birdLen = 1.2;\n  birdVel = 7.;\n  float tGap = 10.;\n  fltBox = vec3 (12., 4., 12.);\n  BirdPM (tCur);\n  birdMat[0] = bdMat;\n  birdPos[0] = bdPos;\n  BirdPM (tCur + tGap);\n  birdMat[1] = bdMat;\n  birdPos[1] = bdPos;\n  float el = 0.;\n  float az = -0.5 * pi;\n  vec2 ca = cos (vec2 (el, az));\n  vec2 sa = sin (vec2 (el, az));\n  mat3 vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 0., -30.);\n  ro.y = 4.;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3z4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 334, 358, 358, 405], [407, 407, 432, 432, 611], [613, 613, 638, 638, 944], [946, 946, 991, 991, 1089], [1091, 1091, 1148, 1148, 1231], [1233, 1233, 1263, 1263, 1337], [1339, 1339, 1372, 1372, 1399], [1401, 1401, 1444, 1444, 1517], [1519, 1519, 1561, 1561, 1612], [1614, 1614, 1673, 1673, 1777], [1779, 1779, 1825, 1825, 1882], [2133, 2133, 2157, 2157, 2423], [2425, 2425, 2457, 2457, 2619], [2621, 2621, 2642, 2642, 2834], [2836, 2836, 2868, 2868, 3856], [3858, 3858, 3912, 3912, 3982], [3984, 3984, 4021, 4021, 5043], [5045, 5045, 5082, 5082, 6150], [6152, 6152, 6189, 6189, 6816], [6818, 6818, 6853, 6853, 6957], [6959, 6959, 6982, 6982, 7759], [7761, 7761, 7783, 7783, 7983], [7985, 7985, 8018, 8018, 8215], [8217, 8217, 8238, 8238, 8455], [8457, 8457, 8492, 8492, 9288], [9290, 9290, 9316, 9316, 11253], [11255, 11255, 11278, 11278, 12001], [12003, 12003, 12060, 12060, 12960]], "test": "untested"}
{"id": "Mtl3zr", "name": "Meta Hole", "author": "aiekick", "description": "Curious Effect of two Meta hole", "tags": ["meta", "shape"], "likes": 2, "viewed": 1114, "published": "Public API", "date": "1418243566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 getPos(vec2 p){\n    float ratio = iResolution.x/iResolution.y;\n    return (p/iResolution.xy*2.-1.)*vec2(ratio, 1.);//centering -1->0->1 x & y\n}\nfloat metahole(vec2 p, vec2 o, float radius, float thick){\n    vec2 po = p-o;\n\treturn thick / dot(po+radius, po-radius);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = getPos(fragCoord.xy);\n    float t = sin(iTime*0.3);\n    float h1 = metahole(uv, vec2(t,0.), 0.5, 0.4);\n\tfloat h2 = metahole(uv, vec2(-t,0.), 0.6, -0.2);\n\tfloat o = h1+h2;\n\tfragColor.rgb = vec3(o-0.6);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3zr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 137, 157, 157, 285], [286, 286, 344, 344, 408], [409, 409, 465, 465, 682]], "test": "untested"}
{"id": "MtlGRn", "name": "Morphing bokeh shape sample taps", "author": "BeRo", "description": "Morphing bokeh shape sample taps for depth of field.\n\nReference: http://www.crytek.com/download/Sousa_Graphics_Gems_CryENGINE3.pdf on slide 36\n\nNEW: Now with new fine sample tap count control", "tags": ["dof", "depthoffield", "morph", "bokehs"], "likes": 34, "viewed": 2571, "published": "Public API", "date": "1418123891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Reference: http://www.crytek.com/download/Sousa_Graphics_Gems_CryENGINE3.pdf on slide 36\n// Implemented as GLSL example by Benjamin 'BeRo' Rosseaux - CC0\n\n// NEW: Now with new fine sample tap count control\n\nconst float PI = 3.14159265359;\n\n#define NEW_FINE_SAMPLE_TAP_COUNT_CONTROL    \nconst float COUNT_SAMPLES = 17.0 * 17.0;       // 17^2 for to match the old code\n\n// o = tap sample xy, f = f-factor, n = diaphragm shape ngon, phiShutterMax = max. lens shutter rotation \nvec2 getBokehTapSampleCoord(const in vec2 o, const in float f, const float n, const in float phiShutterMax){\n    vec2 ab = (o * 2.0) - vec2(1.0);    \n    vec2 phir = ((ab.x * ab.x) > (ab.y * ab.y)) ? vec2((abs(ab.x) > 1e-8) ? ((PI * 0.25) * (ab.y / ab.x)) : 0.0, ab.x) : vec2((abs(ab.y) > 1e-8) ? ((PI * 0.5) - ((PI * 0.25) * (ab.x / ab.y))) : 0.0, ab.y); \n    phir.x += f * phiShutterMax;\n   \tphir.y *= (f > 0.0) ? pow((cos(PI / n) / cos(phir.x - ((2.0 * (PI / n)) * floor(((n * phir.x) + PI) / (2.0 * PI))))), f) : 1.0;\n    return vec2(cos(phir.x), sin(phir.x)) * phir.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    // should for real usage: (fstop - fstopmin) / (fstopmax - fstopmin)\n    float f = (sin(iTime) * 0.5) + 0.5; \n    \n    // Diaphragm shape structure: 4.0 = box, 5.0 = pentagon, 6.0 = hexagon, 7.0 = heptagon, 8.0 = octagon etc.\n    float ngon = 6.0; // 6.0 because I like hexagons :-) \n    \n\tvec2 coord = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 4.0 * vec2(1.0, iResolution.y /  iResolution.x);\n    float v = 0.0;\n#ifdef NEW_FINE_SAMPLE_TAP_COUNT_CONTROL    \n    const float width = floor(sqrt(COUNT_SAMPLES));\n    const float height = floor(COUNT_SAMPLES / width);\n    const vec2 invMax = vec2(1.0) / (vec2(width, height) - vec2(1.0));  \n    for(float y = 0.0; y < height; y++){\n    \tfor(float x = 0.0; x < width; x++){\n            vec2 c = getBokehTapSampleCoord(vec2(x, y) * invMax, f, ngon, PI * 0.5);\n            v = mix(1.0, v, pow(smoothstep(0.0, 0.05, length(coord - c)), 8.0));\n\t\t}\n    }    \n#else\n    for(float y = 0.0; y <= 1.0; y += 1.0 / 16.0){\n    \tfor(float x = 0.0; x <= 1.0; x += 1.0 / 16.0){\n            vec2 c = getBokehTapSampleCoord(vec2(x, y), f, ngon, PI * 0.5);\n            v = mix(1.0, v, pow(smoothstep(0.0, 0.05, length(coord - c)), 8.0));\n\t\t}\n    }\n#endif\n    \n\tfragColor = vec4(v);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 478, 586, 586, 1053], [1055, 1055, 1111, 1188, 2342]], "test": "untested"}
{"id": "MtlGz8", "name": "Flow Dots", "author": "KazimirO", "description": "potential flow visualized as dots", "tags": ["flow", "dots", "potential"], "likes": 18, "viewed": 422, "published": "Public", "date": "1418710406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float divs = 12.0;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 div = vec2( divs, divs*iResolution.y/iResolution.x );\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\t\t\t\t\t\t\t\t\t// center on screen\n//  float b = 4.0*divs/iResolution.x;\t\t\t// blur over 2.4 pixels\n    vec2 xy = div*uv;\n    \n    vec2 S;\n\tS.x = (xy.x + xy.y)*(xy.x - xy.y)*0.5;\t\t// \"velocity potential\"\n    S.y = xy.x*xy.y;\t\t\t\t\t\t\t// stream function\n\tS.x += iTime*3.0;\t\t\t\t\t\t// animate stream\n//  S.x += 0.75;\n    \n    vec2 sxy = abs( sin(3.14159265*S) );\n    float a = sxy.x * sxy.y;\t\t\t\t\t// combine sine waves using product\n    \n    float b = length(fwidth(sxy))*0.7071;\t\t// jacobian\n\ta = smoothstep( 0.8-b, 0.8+b, a );\t\t\t// threshold\n    \n    float c = sqrt( a );\t\t\t\t\t\t// correct for gamma\n\tfragColor = vec4(c, c, c, 1.0);\n//\tfragColor = vec4(c, sxy.x, sxy.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 865]], "test": "untested"}
{"id": "MtX3z4", "name": "Green dragon", "author": "guil", "description": "While experimenting with quadruplex multiplication, I met this strange creature.", "tags": ["3d", "fractal", "dragon"], "likes": 0, "viewed": 153, "published": "Public", "date": "1419102612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst int MaxIter = 16;\nconst int maxSteps =256;\nfloat preci =  .5/min(iResolution.x,iResolution.y);//0.001;//\nfloat zoom=1.;\nfloat flapTime = cos(iTime);\n\n// Complex operations\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\n\n// Exotic multiplication\n\nvec4 dmul( vec4 a, vec4 b )  {\n    float r = length(a);    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    b.zw=cmul(normalize(a.zw), b.zw);\n    return r*b;\n}\n\n// Distance estimation for fractal\n\nfloat de( vec3 p)\n{\t\n    float dr = 1.;\t\n    p*=dr;\n    float r2;\n    vec4 z = vec4(-p.yzx,0.); \n    dr=dr/length(z);\n    if(z.z>-0.5)z.x+=.4*flapTime*abs(z.y)*(z.z+.5);  \n    dr=dr*length(z);      \n    vec4 c= z;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{                           \n\t\tr2 = dot(z,z);\n\t\tif(r2>100.)continue;\n\t\tdr=2.*sqrt(r2)*dr+1.0;\t\t\t\n\t\tz=dmul(z,z)+c; \t\t\t\t\n\t}\n    return .5*length(z)*log(length(z))/dr;\t    \t\n}\n\n    \n// Orbit trapping for fractal\n    \nvec4 map(in vec3 p)\n{\n    float dr = 1.0;\n    vec4 ot = vec4(1000.0);        \n    float r2;\n    vec4 z = vec4(-p.yzx,0.);\n    if(z.z>-0.5)z.x+=.4*flapTime*abs(z.y)*(z.z+.5);         \n    vec4 c= z;\n    for( int i=0; i<MaxIter;i++ )\n\t{            \n\t\tr2 = dot(z,z);\n\t\tif(r2>100.)continue;\t\t\n\t\tot = min( ot, vec4(abs(z.xyz),r2) );       \n\t\tdr=2.*sqrt(r2)*dr+1.0;\t\t\t\n\t\tz=dmul(z,z)+c;    \t\t\t\t\t\t\n\t}\t\t    \n    return ot;\t\n}\n\nfloat field(in vec3 p) {\n\t\n\tfloat res = 0.;\n\tvec4 z = vec4(-p.yzx,0.);\n    if(z.z>-0.5)z.x+=.4*flapTime*abs(z.y)*(z.z+.5);   \n    vec4 c = z;\n\tfor (int i = 0; i < 10; ++i) {\n\t\t\n        \n        z=dmul(z,z)+c;\n\t\tres += 2.*exp(-3. * abs(dot(z,c)));\n\t\t\n\t}\n\treturn res/4.;\n}\n\n\n\nvec3 raycast( in vec3 ro, vec3 rd, vec2 tminmax   )\n{\n    float t = tminmax.x;\n    float dt = .07;\n    vec3 col= vec3(0.);\n    for( int i=0; i<32; i++ )\n\t{\n        \n        float c = field(ro+t*rd);               \n        t-=dt;\n        c = max(5.0 * c - .9, 0.0);\n        col = .95*col+ .08*vec3(0.5*c*c*c, .6*c*c, c);\n\t\t\n    }\n    \n    return col;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3  delta = vec3(.0001,0.0,0.0);\n    vec3 nor;   \n    nor.x = de(pos+delta.xyy) - de(pos-delta.xyy);\n    nor.y = de(pos+delta.yxy) - de(pos-delta.yxy);\n    nor.z = de(pos+delta.yyx) - de(pos-delta.yyx);   \n    return normalize(nor);\n}\n\n\nfloat march( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\t\n\tfloat t = tminmax.x,pd=10.0,os=0.0,step;\n   \tfloat dt = 1.;   \n\tfor(int i=0; i<maxSteps; i++)\n\t{\t\t\n            if( t>tminmax.y || dt<=preci*t ) continue;\n            vec3 pos = ro + t*rd;\t\t\t\t\n            dt = de(pos);                \n            t += dt;                    \t\t\n\t}\n   \tif(t>tminmax.y||dt>preci*t*1.)return-1.;     \n\treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.05*iTime - mo.x+180.;\n    \n    vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n\n    vec3 ro = zoom*1.7*vec3(sin(an),0.+0.8*cos(1.3*an+mo.y), cos(an));\n    vec3 ta = vec3(cos(an),0.0, sin(an));\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = vec3(0.05);\n    float t;\n    vec2 seg= vec2(0.,30.);;\n\n      \n    t = march( ro, rd, seg );\n    seg = vec2(2.,t);\n    vec3 col2 = vec3(0.);\n    if(t<0.)col2 = raycast(ro,rd, seg);\n    if(t>=0.){\n \n\t\t\n        vec3 pos = ro+ t* rd;\n        vec4 res = map( pos);\n\t\tvec3 col1 =clamp(res.xyz,0.,1.);\n\t\tcol1=.5*(col1+col1.brg);\n\t\tcol1.g+=col1.r;              \n\t\tvec3 nor = calcNormal( pos);\n  \n\n        // lighting\n        \n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(res.a*2.0,0.2,1.0), 2.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+1.5*key+.2*bac);\n        \n        col = col1*brdf;\n\t    \n        }       \n    col = pow( col, vec3(0.4) ) * 1.2+col2*.4;\n    col *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtX3z4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[245, 268, 298, 298, 353], [354, 354, 376, 376, 425], [426, 426, 447, 447, 472], [474, 500, 530, 530, 691], [693, 729, 748, 748, 1147], [1154, 1189, 1210, 1210, 1605], [1607, 1607, 1631, 1631, 1877], [1881, 1881, 1934, 1934, 2232], [2236, 2236, 2268, 2268, 2509], [2512, 2512, 2569, 2569, 2914], [2917, 2917, 2974, 2974, 4466]], "test": "untested"}
{"id": "MtXGRN", "name": "Green dragon v2", "author": "guil", "description": "A new version combining the volumetric and sphere marching \nin the same loop for better performances ", "tags": ["3d", "fractal", "dragon"], "likes": 15, "viewed": 2274, "published": "Public", "date": "1419117388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst int MaxIter = 16;\nconst int maxSteps =256;\nconst float zoom=1.;\n\n#define flapTime (cos(iTime))\n\n// Complex operations\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\n\n// Exotic multiplication\n\nvec4 dmul( vec4 a, vec4 b )  {\n    float r = length(a);    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    b.zw=cmul(normalize(a.zw), b.zw);\n    return r*b;\n}\n\n// Distance estimation for fractal\n\nfloat de( vec3 p)\n{\t\n    float dr = 1.;\t\n    p*=dr;\n    float r2;\n    vec4 z = vec4(-p.yzx,0.2); \n    dr=dr/length(z);\n    if(z.z>-0.5)z.x+=.5*flapTime*abs(z.y)*(z.z+.5);  \n    dr=dr*length(z);      \n    vec4 c= z;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{                           \n\t\tr2 = dot(z,z);\n\t\tif(r2>100.)continue;\n\t\tdr=2.*sqrt(r2)*dr+1.0;\t\t\t\n\t\tz=dmul(z,z)+c; \t\t\t\t\n\t}\n    return .5*length(z)*log(length(z))/dr;\t    \t\n}\n\n    \n// Orbit trapping for fractal\n    \nvec4 map(in vec3 p)\n{\n    float dr = 1.0;\n    vec4 ot = vec4(1000.0);        \n    float r2;\n    vec4 z = vec4(-p.yzx,0.2);\n    if(z.z>-0.5)z.x+=.5*flapTime*abs(z.y)*(z.z+.5);         \n    vec4 c= z;\n    for( int i=0; i<MaxIter;i++ )\n\t{            \n\t\tr2 = dot(z,z);\n\t\tif(r2>100.)continue;\t\t\n\t\tot = min( ot, vec4(abs(z.xyz),r2) );       \n\t\tdr=2.*sqrt(r2)*dr+1.0;\t\t\t\n\t\tz=dmul(z,z)+c;    \t\t\t\t\t\t\n\t}\t\t    \n    return ot;\t\n}\n\n\nfloat field(in vec3 p, inout float ot) {\n\tfloat dr = 1.0;      \n    float r2;\n\tfloat res = 0.;\n\tvec4 z = vec4(-p.yzx,0.2);\n    dr=dr/length(z);\n    if(z.z>-0.5)z.x+=.5*flapTime*abs(z.y)*(z.z+.5);  \n    dr=dr*length(z);  \n    vec4 c = z;\n\tfor (int i = 0; i < MaxIter; ++i) {\n\t\t\n        r2 = dot(z,z);\n\t\tif(r2>100.)continue;\n\t\tdr=2.*sqrt(r2)*dr+1.0;\t\n        z=dmul(z,z)+c;\n\t\tif(i<10)res += 2.*exp(-3. * abs(dot(z,c)));\n\t\t\n\t}\n\tot = res/4.;\n    return .5*length(z)*log(length(z))/dr;\t\n}\n\n\n\nvec4 raymarch( in vec3 ro, vec3 rd, vec2 tminmax   )\n{\n    float preci =  .5/min(iResolution.x,iResolution.y);\n    \n    float t = tminmax.x;\n    vec3 col= vec3(0.);\n    float ot;\n    float dt = 1.; \n    for( int i=0; i<maxSteps; i++ )   \n\t{\n        if( t>tminmax.y || dt<=preci*t ) continue;\n        dt = field(ro+t*rd,ot);\n        t+=dt;\n        float c = max(5.0 * ot - .9, 0.0);\n        col = .95*col+ .08*vec3(0.5*c*c*c, .6*c*c, c);\n\t\t\n    }\n    if(t>tminmax.y||dt>preci*t*1.)return vec4(col,-1.);\n    return vec4(col,t);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3  delta = vec3(.0001,0.0,0.0);\n    vec3 nor;   \n    nor.x = de(pos+delta.xyy) - de(pos-delta.xyy);\n    nor.y = de(pos+delta.yxy) - de(pos-delta.yxy);\n    nor.z = de(pos+delta.yyx) - de(pos-delta.yyx);   \n    return normalize(nor);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.05*iTime - mo.x+180.;\n    \n    vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n\n    vec3 ro = zoom*1.7*vec3(sin(an),0.+0.8*cos(1.3*an+mo.y), cos(an));\n    vec3 ta = vec3(cos(an),0.0, sin(an));\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = vec3(0.05);\n    float t;\n    vec2 seg= vec2(0.,30.);;\n\n      \n    vec4 rm = raymarch( ro, rd, seg );\n    t=rm.a;\n    seg = vec2(2.,t);\n    vec3 col2 = vec3(0.);\n    if(t<0.)col2 = rm.rgb;\n    if(t>=0.){\n \t\t//col2=.05*rm.rgb;\n\t\t\n        vec3 pos = ro+ t* rd;\n        vec4 res = map( pos);\n\t\tvec3 col1 =clamp(res.xyz,0.,1.);\n\t\tcol1=.5*(col1+col1.brg);\n\t\tcol1.g+=col1.r;              \n\t\tvec3 nor = calcNormal( pos);\n  \n\n        // lighting\n        \n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(res.a*2.0,0.2,1.0), 2.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+1.5*key+.2*bac);\n        \n        col = col1*brdf;\n\t    \n        }       \n    col = pow( col, vec3(0.4) ) * 1.2+col2*.4;\n    col *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[191, 214, 244, 244, 299], [300, 300, 322, 322, 371], [372, 372, 393, 393, 418], [420, 446, 476, 476, 637], [639, 675, 694, 694, 1094], [1101, 1136, 1157, 1157, 1553], [1556, 1556, 1596, 1596, 2039], [2043, 2043, 2097, 2097, 2570], [2574, 2574, 2606, 2606, 2847], [2852, 2852, 2909, 2909, 4429]], "test": "untested"}
{"id": "Xlf3z4", "name": "Congrats Luxo Jr", "author": "mplanck", "description": "Rendering a film resolution frame of Pixar's Luxo Jr. back in 1986 took hours.  This takes millseconds (the hard way).  A love letter to Pixar...  [url]http://www.loc.gov/today/pr/2014/14-210.html[/url]", "tags": ["distancefields", "luxo", "pixar"], "likes": 55, "viewed": 5178, "published": "Public", "date": "1418890547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// DEFINES\n\n#define COWL_MATL 1.\n#define LAMP_MATL 2.\n#define BULB_MATL 3.\n#define FLOOR_MATL 4.\n#define SPRING_MATL 5.\n#define TAIL_MATL 6.\n#define WALL_MATL 7.\n#define DEBUG_MATL 10.\n\n//#define DEBUG_ACCEL_MARCH 1\n#define CALC_SHADOWS 1\n//#define CALC_AMBIENTOCCLUSION 1\n\n// **************************************************************************\n// KINEMATIC STATE\n\nstruct LuxoData\n{\n    vec3 footorient;\n    vec3 footjoint;\n    vec3 midjoint;\n    vec3 headjoint;\n    vec3 headorient;\n    float celbowang;\n    float selbowang;\n};\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin   = vec3(0.);\n\nfloat g_time        = 0.;\nvec4  g_debugcolor  = vec4(0.);\n\n// Default Pose\nLuxoData g_lux = LuxoData(vec3(0., -.4, 0.),\n                          vec3(0., -.1, 0.),\n                          vec3(.22, .18, 0.),\n                          vec3(-0.16, .76, 0.),\n                          vec3(-1.0, 0.5, 0.),\n                          1., 0.);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice.\nvec3 rot_around_y( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice.\nvec3 rot_around_x( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the 2d origin by the angle given as a cos(angle)\n// and sin(angle) argument.\nvec2 rot_vec2( vec2 xy, float cosangle, float sinangle )\n{\n    return vec2(xy.x * cosangle - xy.y * sinangle,\n                xy.x * sinangle + xy.y * cosangle);\n}\n\nvec3 orient_to_y( vec3 p, vec3 lookdir )\n{\n    // assume lookdir is a normalized vector that we will use to\n    // normalize with the y-axis\n\n    // if lookdir is pointing exactly in the positive or negative\n    // y direction, then we can return the positive or negative\n    // identity respectively.\n    if (abs(lookdir.y) >= 1.) return sign(lookdir.y) * p;\n\n    vec3 v1 = lookdir;\n    vec3 up = vec3(0., 1., 0.); // assuming up vector in world is y\n    vec3 v3 = normalize( cross(v1, up) );\n    vec3 v2 = cross(v3, v1);\n    \n    // orthogonal matrix so inverse == transpose\n    return vec3( dot(p,v2),\n                 dot(p,v1),\n                 dot(p,v3) );\n}\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\nvec2 mergeobjs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\nfloat uniondf(float a, float b) { return min(a, b); }\nfloat intersdf(float a, float b) { return max(a, b); }\nfloat diffdf(float a, float b) { return max(a, -b); }\n\n#define NOISE_DIMENSION 64.\n\nfloat noise1f( float n )\n{   \n    \n    vec2 coords = vec2(mod(floor(n),NOISE_DIMENSION)/NOISE_DIMENSION, \n                       floor(n/NOISE_DIMENSION)/NOISE_DIMENSION);\n    \n    return texture(iChannel0, coords, -100. ).r;\n} \n\n// **************************************************************************\n// INTERSECTION FOR ACCELERATION STRUCTURE\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere or there is any interesection, >1 is returned, otherwise 0.\n\nfloat intersect_sphere(vec3 ro, vec3 rd, float r, vec3 sphc)\n{\n\n    vec3 so = ro - sphc;\n\n    float a = dot(rd, rd);\n    float b = dot(so, rd);\n    float c = dot(so, so) - r*r;\n    float discr = b*b - a*c;\n\n    float zero_discr = step(SMALL_FLOAT, discr);\n    float tmin = (-b - sqrt(discr))/a;\n\n    return zero_discr * (step(0., tmin) + step(dot(so, so), r*r)); \n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat roundboxdf( vec3 p, vec3 bounds, float r )\n{\n    return length(max(abs(p)-bounds * vec3(1., .5, 1.),0.0))-r;\n}\n\nfloat cylinderdf( vec3 p, float r, float h)\n{\n    return max( length(p.xz)-r, abs(p.y) - h*.5 );\n}\n\nfloat spheredf( vec3 p, float r )\n{\n    return length(p) - r;    \n}\n\nfloat clippedconedf( vec3 p, vec2 dims, vec2 clips )\n{\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    return max( max( dot(q, dims.xy), p.y), max(p.y+clips.x, -p.y-clips.y ));\n}\n\nfloat torusdf( vec3 p, float r, float d )\n{\n  vec2 q = vec2(length(p.xz)-r,p.y);\n  return length(q)-d;\n}\n\nfloat oroundboxdf( vec3 p, vec3 a, vec3 b, \n                   vec3 bounds, float r )\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y -= bounds.y * .5;\n    return roundboxdf(o, bounds, r);\n}\n\nfloat ocylinderdf( vec3 p, vec3 a, vec3 b, \n                   float r, float h)\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y -= h * .5;\n    return cylinderdf(o, r, h);\n}\n\n\nfloat ospheredf( vec3 p, vec3 a, vec3 b,\n                float r )\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); o.y *= -1.; o.y += r;\n    return spheredf(o, r);\n}\n\nfloat oclippedconedf( vec3 p, vec3 a, vec3 b, \n                      vec2 dims, vec2 clips)\n{\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a));\n    \n    return clippedconedf(o, dims, clips);\n}\n\n\nvec2 lampobj( vec3 p, vec3 rd, vec3 a, vec3 b )\n{\n\n    vec2 obj = vec2(BIG_FLOAT, -1.);\n\n    vec3 o = p - a;    \n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n    \n    obj.x = uniondf( obj.x, spheredf(o - vec3(0., .16, 0.), .365));\n    \n    o.x += -.09;\n    \n    float ty = -.04;\n\n    // cowl\n    vec2 cowl = vec2(BIG_FLOAT, COWL_MATL);\n    vec3 cowlo = o; cowlo.y += ty;\n\n    float c = min(0., -.55*cos(4.8*cowlo.y-.25)*(1.2 * cowlo.y- .06) - .1);\n\n    cowlo.xz += .7 * c * normalize(cowlo.xz);\n    \n    float m = .11;\n\n    cowlo *= -1.; cowlo.y -= .4;\n    cowl.x = clippedconedf(cowlo, \n                  vec2(.4, m), vec2(0.21, 0.7));\n\n    cowl.x = diffdf( cowl.x, clippedconedf( cowlo, \n                     vec2(.4, m * .95), vec2(0.22, 1.)));\n\n    // - vent slits\n    float numSlits = 16.;\n    float ang = TWO_PI * (mod(atan(o.x,o.z)/TWO_PI, 1./numSlits) - (.5/numSlits));\n    float l = length(o.xz);\n    vec3 modo = vec3(l * cos(ang), o.y + ty, l * sin(ang));\n\n    cowl.x = diffdf(cowl.x, ocylinderdf(modo, \n                                         vec3(.08, -0.16, 0.0), vec3(.42, 1., 0.), \n                                        .008, .07)); // EXPENSIVE\n\n\n    // + nubbin and base\n    cowl.x = uniondf(cowl.x, cylinderdf(o + vec3(0., .18 + ty, 0.), .017, .08));\n    cowl.x = uniondf(cowl.x, spheredf((vec3(.6, 1., 0.6) * o) + vec3(0., .22 + ty, 0.), .018));\n\n    // + bulb seat\n    cowl.x = uniondf(cowl.x, cylinderdf(o + vec3(0., .12 + ty, 0.), .045, .12));\n                     \n    // + bulb\n    vec2 bulb = vec2(BIG_FLOAT, BULB_MATL);\n    bulb.x = spheredf(o - vec3(0., .12 - ty, 0.), .15);\n\n    obj = mergeobjs(cowl, bulb);\n\n    return obj;\n}\n\nvec2 upperarm( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n\n    vec3 t = vec3(-0.05, -.045, 0.);\n    o += t;\n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // neck\n    obj.x = cylinderdf(o - vec3(-.05, .51, 0.), .025, .12);\n\n    obj.x = uniondf( obj.x, cylinderdf(o - vec3(-.05, .59, 0.),  .04, .07));\n\n    // + rear top block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.06, .5,.035),\n                                        vec3(0.), vec3(.25, -.25, .0),\n                                        vec3(.022, .19, .01), .002)); // EXPENSIVE\n\n    // + front top block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.05, .5, .035),\n                                        vec3(.0), vec3(-.08, -.3, .0),\n                                        vec3(.022, .19, .01), .002)); // EXPENSIVE\n\n    // + rear top rod\n    obj.x = uniondf( obj.x,\n                    cylinderdf(o - vec3(.06, .24, .0), .025, .35));\n\n    // + front top rod\n    obj.x = uniondf( obj.x,\n                    cylinderdf(o - vec3(-.09, .22, .0), .025, .35));\n\n    // + bolts\n    obj.x = uniondf( obj.x, spheredf(o - vec3(-.05,  .48, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(.06, .38, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(-.09, .35, .04), .016));\n\n    // + horizontal rods and nubs\n    vec3 hrodo = o - vec3(0.06, .09, 0.);\n    hrodo = orient_to_y(hrodo, normalize(vec3(0., 0., 1.))); // EXPENSIVE\n\n    obj.x = uniondf( obj.x, cylinderdf(hrodo, .01, .15));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.0, .07, .0), .015, .01));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.125, .0, .15), .01, .15));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo - vec3(.125, .07, .15), .015, .01));\n\n    // + upper spring\n    vec2 springobj = vec2(BIG_FLOAT, SPRING_MATL);\n\n    vec3 springo = o;\n    springo -= vec3(.055, .09, .06);\n    springo = orient_to_y(springo, normalize(vec3(-1., 0.85, 0.))); // EXPENSIVE\n    springo.y -= .1;\n    float  c = cos(240.0*springo.y);\n    float  s = sin(240.0*springo.y);\n    mat2   m = mat2(c,s,-s,c);\n    springo.xz = m*springo.xz;\n    springo -= vec3(.0, .0, .01);\n    springobj.x = cylinderdf(springo, .0095, .2);\n\n    obj = mergeobjs(obj, springobj);\n\n\n    return obj;\n}\n\nvec2 elbow( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    \n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n    \n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); // EXPENSIVE\n\n    vec3 t = vec3(-0.05, -.045, 0.);\n    o += t;\n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // rear mid block   \n    vec3 baro = o - vec3(-.063, -.04, .035);\n    vec3 barb = vec3(.3, .3, .01);\n    vec3 bounds = vec3(.05, .21, .01);\n    baro = orient_to_y(baro, normalize(barb)); baro.y -= bounds.y * .5; // EXPENSIVE\n    baro.x *= mix(1., 2.5, smoothstep(-.2, .26, baro.y));\n    obj.x = uniondf( obj.x, roundboxdf(baro, bounds, .002));\n\n    // + front mid block\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.06, -.08, .035),\n                                        vec3(.0), vec3(-.1644, .9864, .0),\n                                        vec3(.025, .21, .01), .002)); // EXPENSIVE  \n    // + bolt\n    obj.x = uniondf( obj.x, spheredf(o - vec3(.0, .0, .04)-t, .016));\n\n    return obj;\n}\n\nvec2 lowerarm( vec3 p, vec3 rd, vec3 a, vec3 b)\n{\n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;\n    o = orient_to_y(o, normalize(b - a)); \n\n    // symmetry along the xy plane\n    o.z = abs(o.z);\n\n    // rear bottom rod\n    obj.x = roundboxdf(o - vec3(0.01, .2, 0.),\n                       vec3(0.022, .35, 0.012), .007);\n\n    // + rear ankle joint    \n    vec2 rearank = rot_vec2(vec2(0.9578, 0.2873), g_lux.celbowang, g_lux.selbowang);\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.01, .04,.035),\n                                        vec3(0.), vec3(rearank.x, rearank.y, .0),\n                                        vec3(.022, .25, .01), .002));\n\n    // + front ankle joint\n    vec2 frontank = rot_vec2(vec2(0.9987, -.05), g_lux.celbowang, g_lux.selbowang);\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(-.01, .04,.035),\n                                        vec3(0.), vec3(frontank.x, frontank.y, .0),\n                                        vec3(.018, .18, .01), .002));\n\n    // + horizontal rods and nubs\n    \n    vec2 tfo = vec2(-.01, .04) + .155 * frontank;\n    vec2 tro = vec2(-.01, .04) + .22 * rearank;\n\n    vec3 hrodo = orient_to_y(o, normalize(vec3(0., 0., 1.)));\n\t\n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tfo.y, 0., -tfo.x), .01, .26));    \n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tfo.y + 0.15, 0., -tfo.x), .01, .2));\n    obj.x = uniondf( obj.x, cylinderdf(hrodo-vec3(tro.y, 0., -tro.x), .01, .16));\n\n    // + zig zag strut    \n    obj.x = uniondf( obj.x, roundboxdf(o - vec3(tfo.x, tfo.y + .09, 0.105),\n                       vec3(0.011, .2, 0.008), .007));\n\n    obj.x = uniondf( obj.x, oroundboxdf(o - vec3(tfo.x, tfo.y + .185, 0.105),\n                                        vec3(0.), vec3(0., 1., -1.),\n                                        vec3(0.008, .05, 0.011), .007));\n\n    obj.x = uniondf( obj.x, roundboxdf(o - vec3(tfo.x, tfo.y + .285, 0.07),\n                       vec3(0.011, .13, 0.008), .007));\n\n    // + bolts\n    vec2 bfo = vec2(-.01, .04) + .02 * frontank;\n    obj.x = uniondf( obj.x, spheredf(o - vec3(bfo.x, bfo.y, .04), .016));\n    obj.x = uniondf( obj.x, spheredf(o - vec3(tfo.x, tfo.y + .33, .085), .016));\n\n    // + lower spring\n    vec2 springobj = vec2(BIG_FLOAT, SPRING_MATL);\n\n    vec3 so = vec3(tfo.x + .03, tfo.y + .115, .07);\n    vec3 springo = orient_to_y(o - so, normalize(vec3(tro.x - so.x, tro.y - so.y, 0.)));\n    springo.y *= 0.06/length(vec3(tro.x - so.x, tro.y - so.y, 0.));\n    float  c = cos(300.0*springo.y);\n    float  s = sin(300.0*springo.y);\n    mat2   m = mat2(c,s,-s,c);\n    springo.xz = m*springo.xz;\n    springo -= vec3(.0, .0, .01);\n    springobj.x = cylinderdf(springo, .0095, .1);\n\n    obj = mergeobjs(obj, springobj);\n    \n    return obj;\n}\n\nvec2 base( vec3 p, vec3 rd, vec3 a, vec3 b)\n{    \n    vec2 obj = vec2(BIG_FLOAT, LAMP_MATL);\n\n    vec3 o = p - a;    \n\n    o = orient_to_y(o, normalize(b - a));\n    \n    vec3 baseo = o;\n    baseo *= vec3(.9, .9, .9);\n    baseo.y += -.16;\n\n    // base ring rounded curve\n    obj.x = torusdf( baseo, .3, .05);\n\n    // + base cylinder\n    obj.x = uniondf( obj.x, cylinderdf( baseo, .3, .1));\n\n    // - base bottom\n    obj.x = diffdf( obj.x, -baseo.y );\n\n    // + base bottom piping\n    obj.x = uniondf( obj.x, torusdf(baseo, .35, .015));\n\n    baseo.y += .0603;\n\n    // + base neck scarf\n    float baseneck = cylinderdf( baseo, .08, .05);\n    baseneck = diffdf( baseneck, torusdf(baseo + vec3(0., .012, 0.), .07, .024));\n    obj.x = uniondf( obj.x, baseneck);\n\n    baseo.y += .025;\n\n    // + base neck piping \n    obj.x = uniondf( obj.x, torusdf(baseo, .045, .015));\n\n    // + base neck\n    obj.x = uniondf( obj.x, cylinderdf(baseo, .025, .2));\n    \n    return obj;\n}\n\nvec2 tailobj( vec3 p, vec3 rd, vec3 a)\n{    \n    vec2 obj = vec2(BIG_FLOAT, TAIL_MATL);\n\n    vec3 o = p - a;    \n    \n    o.z += .2 * sin(2. * o.x);\n\n    obj.x = ocylinderdf( o, vec3(.4, -.18, 0.2), vec3(1., -.18, 0.2), .015, 5.);// EXPENSIVE\n\n    return obj;\n}\n\nvec2 floorobj( vec3 pos ) \n{\n    return vec2(abs( pos.y + 0.3 ), FLOOR_MATL);\n}\n\nvec2 wallsobj( vec3 pos )\n{\n    return vec2(10. - length(pos.xz), WALL_MATL);\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 scenedf( vec3 pos, vec3 rd )\n{\n    vec2 obj = vec2(BIG_FLOAT, -1.);\n    \n    // Base\n    vec3 sphc = g_lux.footjoint - vec3(0., .34, .0);\n    float sphr = .44;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, base( pos, rd, g_lux.footjoint, g_lux.footorient));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lower Arm\n    sphc = .4 * (g_lux.footjoint + g_lux.midjoint);\n    sphr = .85 * length(g_lux.midjoint - g_lux.footjoint);\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, lowerarm( pos, rd, g_lux.footjoint, g_lux.midjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n    \n    // Elbow\n    sphc = g_lux.midjoint + vec3(-.01, .12, .0);\n    sphr = .18;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, elbow(pos, rd, g_lux.midjoint, g_lux.headjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Upper Arm\n    sphc = .5 * (g_lux.midjoint + g_lux.headjoint);\n    sphr = .5 * length(g_lux.headjoint - g_lux.midjoint);\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, upperarm(pos, rd, g_lux.midjoint, g_lux.headjoint));\n\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lamp Head \n    sphc = g_lux.headjoint + vec3(-.2, .05, 0.);\n    sphr = .5;\n    if (intersect_sphere(pos, rd, sphr, sphc) > .5)\n    {    \n        obj = mergeobjs(obj, lampobj( pos, rd, g_lux.headjoint, g_lux.headorient) );\n        #ifdef DEBUG_ACCEL_MARCH\n        obj = mergeobjs(obj, vec2(spheredf(pos - sphc, sphr), DEBUG_MATL));\n        #endif\n    }\n\n    // Lamp Tail\n    obj = mergeobjs(obj, tailobj( pos, rd, g_lux.footjoint) );\n\n    // distance from a floor\n    obj = mergeobjs(obj, floorobj( pos ));\n    \n    // distance from surrounding cylinder wall\n    obj = mergeobjs(obj, wallsobj( pos ));\n    \n    return obj;\n}\n\n#define DISTMARCH_STEPS 60\n#define DISTMARCH_MAXDIST 40.\n\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{    \n    float dist = 10. * SMALL_FLOAT;\n    float t = 0.;\n    float material = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < SMALL_FLOAT || t > maxd ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd, rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec2( t, material );\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\nvec3 compute_normal( vec3 p )\n{\n    vec3 d = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + d.xyy, normalize(d.xyy)).x - scenedf(p - d.xyy, -normalize(d.xyy)).x,\n        scenedf(p + d.yxy, normalize(d.yxy)).x - scenedf(p - d.yxy, -normalize(d.yxy)).x,\n        scenedf(p + d.yyx, normalize(d.yyx)).x - scenedf(p - d.yyx, -normalize(d.yyx)).x );\n    return normalize( n );\n}\n\n#define SOFTSHADOW_STEPS 90\n#define SOFTSHADOW_STEPSIZE .025\n\nfloat soft_shadow( vec3 ro, \n                      vec3 rd, \n                      float mint, \n                      float maxt, \n                      float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t, rd ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 8\n#define AO_STEPSIZE .02\n#define AO_STEPSCALE .7\n\nfloat ambient_occlusion( vec3 p, \n              vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi < AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop, n ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n// **************************************************************************\n// CAMERA\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setup_camera(vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    vec3 point;\n    vec3 normal;\n    vec3 basecolor;\n    vec3 emissive;\n    float roughness;\n    float specular;\n    float metallic;\n    float ambocc_amount;\n    float cowl_shadow;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), vec3(0.), 0., 1., 0., 1., 1.)\n\nstruct BRDFVars\n{\n    // vdir is the view direction vector\n    vec3 vdir;\n    // The half vector of a microfacet model \n    vec3 hdir;\n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh; \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd;      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl;\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv;\n};\n\n\nvoid calc_material(float matid,\n                   inout SurfaceData surf)\n{\n    vec3 surfcol = vec3(1.);\n    if (matid - .5 < COWL_MATL) \n    { \n        surf.basecolor = vec3(.95); \n        surf.roughness = .25;\n        surf.metallic = .0;\n        surf.specular = 1.;\n        surf.ambocc_amount = 0.;\n        surf.cowl_shadow = 0.;\n    } \n    else if (matid - .5 < LAMP_MATL) \n    { \n        surf.basecolor =  vec3(.95); \n        surf.roughness = .25;\n        surf.metallic = 0.;\n        surf.specular = 1.;\n    } \n    else if (matid - .5 < BULB_MATL)\n    {\n        surf.ambocc_amount = 0.;\n        surf.basecolor = vec3(.3);\n        surf.emissive = 2.8 * vec3(1., 1., .6);\n        surf.roughness = 0.;\n        surf.specular = 1.;\n    }\n    else if (matid - .5 < FLOOR_MATL)\n    {\n        float board = 1.2 * surf.point.x;\n        float rboard = noise1f(floor(board));\n        float grainrot = mix(-.5, .5, rboard);\n        vec2 boarduv = rot_vec2(vec2(.5, 1.) * surf.point.zx, cos(grainrot), sin(grainrot)) + vec2(40.323, 17.232) * rboard;\n        \n        vec4 pavem = texture(iChannel1, boarduv);\n        float floordivide = smoothstep(.0, .03, fract(board)) * smoothstep(1., .99, fract(board));\n        surf.basecolor = pavem.rgb * (.3 + .7 * floordivide);\n        surf.metallic = .0;\n        surf.roughness = .2;\n        surf.specular = .1;\n\n        // hacky bump map\n        surf.normal.xz += .2 * pavem.bg + vec2(mix(-.1, .1, rboard), 0.);\n        surf.normal = normalize(surf.normal);\n    }\n    else if (matid - .5 < SPRING_MATL)\n    {\n        surf.basecolor = vec3(.2, .2, .3);\n        surf.metallic = 1.;\n        surf.roughness = .02;\n        surf.specular = .5;\n    }\n    else if (matid - .5 < TAIL_MATL)\n    {\n        surf.basecolor = vec3(1.);\n        surf.metallic = .0;\n        surf.roughness = .8;\n        surf.specular = .2;\n    }\n    else if (matid - .5 < DEBUG_MATL)\n    {\n        surf.basecolor = vec3(.6, 0., 0.);\n        surf.metallic = 0.;\n        surf.roughness = 1.;\n        surf.specular = 0.;\n        surf.emissive = vec3(.3, 0., 0.);\n    }\n\n}\n\n\nBRDFVars calc_BRDFvars(SurfaceData surf, vec3 ldir)\n{\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n    vec3 hdir = normalize(ldir + vdir);\n\t/*\n    float costh = max(0., dot(surf.normal, hdir)); \n    float costd = max(0., dot(ldir, hdir));      \n    float costl = max(0., dot(surf.normal, ldir));\n    float costv = max(0., dot(surf.normal, vdir));\n\t*/\n    \n    float costh = dot(surf.normal, hdir); \n    float costd = dot(ldir, hdir);      \n    float costl = dot(surf.normal, ldir);\n    float costv = dot(surf.normal, vdir);\n    return BRDFVars(vdir, hdir, costh, costd, costl, costv);\n\n}\n\nvec3 integrate_dirlight(vec3 ldir, vec3 lcolor, float shadowAtten, SurfaceData surf)\n{\n\n    BRDFVars bvars = calc_BRDFvars( surf, ldir );\n\n    vec3 cout = vec3(0.);\n\n    if (bvars.costl > SMALL_FLOAT)\n    {\n        float frk = .5 + 2.* bvars.costd * bvars.costd * surf.roughness;        \n        vec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-bvars.costl)) * (1. + (frk - 1.) * pow5(1.-bvars.costv));\n\n        float rroughness = max(0.05, surf.roughness);\n        // D(h) factor\n        // using the GGX approximation where the gamma factor is 2.\n\n        float alpha = rroughness * rroughness;\n        float denom = bvars.costh * bvars.costh * (alpha*alpha - 1.) + 1.;\n        float D = (alpha*alpha)/(PI * denom*denom); \n\n        // G(h,l,v) factor    \n        // remap hotness of roughness for analytic lights\n        float k = rroughness / 2.;\n        float Gv = step(0., bvars.costv) * (bvars.costv/(bvars.costv * (1. - k) + k));\n        float Gl = step(0., bvars.costl) * (bvars.costl/(bvars.costl * (1. - k) + k));\n\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = surf.specular * mix(vec3(1.), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - bvars.costd);\n\n        vec3 spec = D * F * G / (4. * bvars.costl * bvars.costv);\n        \n        float shad = 1.;\n        #ifdef CALC_SHADOWS\n        if ( bvars.costl > SMALL_FLOAT && shadowAtten > SMALL_FLOAT)\n        {        \n            shad = mix(1., soft_shadow( surf.point, ldir, 0.1, 2.5, 50.), shadowAtten);\n        }\n        #endif\n\n        cout  += diff * bvars.costl * shad * lcolor;\n        cout  += spec * bvars.costl * shad * lcolor;\n    }\n    cout += surf.emissive;\n    \n    return cout;\n}\n\nvec3 shade(SurfaceData surf)\n{    \n\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = 0.;\n    #ifdef CALC_AMBIENTOCCLUSION\n    ao = ambient_occlusion(surf.point, surf.normal) * surf.ambocc_amount;\n    //g_debugcolor = vec4(vec3(ao), 1.);\n    #endif\n    \n    // MAIN KEY\n    vec3 keydir = normalize(vec3(-1.5, 1.,-0.8));\n    vec3 keyillum  = vec3(3.);\n    vec3 cout   = (1. - 2.5 * ao) * integrate_dirlight(keydir, keyillum, 1., surf);\n    \n    // LAMP\n    vec3 lamporient = normalize(g_lux.headorient - g_lux.headjoint);\n    vec3 lamppos = .32 * lamporient + g_lux.headjoint;\n    \n    vec3 lampv = lamppos - surf.point;\n    float lampvl = length(lampv);\n    vec3 lampdir = normalize(lampv);\n    \n    float lampatten = 15./(lampvl * lampvl);\n    lampatten *= mix(1., smoothstep(.0, .4, dot(-lamporient, lampdir)), surf.cowl_shadow);\n    lampatten *= .04 + .96 * surf.cowl_shadow;\n    vec3 lampillum = lampatten * vec3(1., 1., .8);    \n    \n    if (lampatten > SMALL_FLOAT)\n    {\n        cout   += integrate_dirlight(lampdir, lampillum, 0., surf);\n    }\n    \n    // AMBIENT\n    vec3 amb = vec3(.15) * surf.basecolor;\n    \n    // BOUNCE\n    vec3 bncpos = (.5 * lamporient + g_lux.headjoint) * vec3(1., -1., 1.);\n    vec3 bncv = bncpos - surf.point;\n    float bncvl = length(bncv);\n    vec3 bncdir = normalize(bncv);\n    float ndbnc =  max(0., dot(bncdir, surf.normal));\n    vec3 bnc = surf.basecolor * vec3(1., .9, .8) * (1./(bncvl * bncvl)) * ndbnc * ndbnc;\n    //g_debugcolor = vec4(bnc, 1.) * max(0., (1. - 5.5 * ao));\n    cout       += (amb + bnc) * max(0., (1. - 5.5 * ao));\n\n    return cout;\n\n}\n\n// **************************************************************************\n// GLOBALS\n\n// reference: https://www.shadertoy.com/view/ldlGR7\nvec3 ik_solve( vec3 foot,\n               vec3 head,\n               float larm,\n               float uarm)\n{\n \n    vec3 q = head - foot;\n    q = q * ( 0.5 + 0.5*(larm*larm-uarm*uarm)/dot(q, q ) );\n    float s = larm*larm/dot(q,q) - 1.0;\n    return q + q.yxz*sqrt( s ) + foot;\n}\n\nvoid animate_globals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = iTime;\n\n    // camera position\n    g_camOrigin = vec3(3., 0.0, 3.);\n    \n    float rotXAng    = -PI * (.5 * sin(.88 * PI * click.y) + .5);\n    float cosrotXAng = cos(rotXAng);\n    float sinrotXAng = sin(rotXAng);\n    \n    float rotYAng    = .2 * g_time + TWO_PI * click.x;\n    float cosrotYAng = cos(rotYAng);\n    float sinrotYAng = sin(rotYAng);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rot_around_x(g_camOrigin, cosrotXAng, sinrotXAng);\n    g_camOrigin = rot_around_y(g_camOrigin, cosrotYAng, sinrotYAng);\n\n    g_camPointAt   = vec3(0., 0.2, 0.);\n\n    // animate luxo\n    g_lux.headjoint.y += -.03 + .12 * sin(3.8 * g_time);\n    g_lux.headorient.z += .05 * cos(3.6 * g_time);   \n    g_lux.headorient.y += .2 * sin(.8 * g_time) - .1;    \n     \n    \n    g_lux.midjoint = ik_solve(g_lux.footjoint, \n                              g_lux.headjoint,\n                              .45, .6);\n    \n    vec3 larmv = normalize(g_lux.midjoint - g_lux.footjoint);\n    vec3 uarmv = normalize(g_lux.headjoint - g_lux.midjoint);\n    float larmang = atan( larmv.y, larmv.x );\n    float uarmang = atan( uarmv.y, uarmv.x );\n    // change in elbow angle from the default modeled position\n    float elbowang = -(.9048 - 2.1508) + (larmang - uarmang);\n    g_lux.celbowang = cos(elbowang);\n    g_lux.selbowang = sin(elbowang);\n    \n    g_lux.headorient.z += .5 * sin(3.8 * g_time);  \n\n}\n\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // Animate globals\n\n    animate_globals();\n\n    // ----------------------------------\n    // Setup Camera\n\n    CameraData cam = setup_camera(fragCoord);\n\n    // ----------------------------------\n    // SCENE MARCHING\n\n    vec2 scenemarch = distmarch( cam.origin, \n                                 cam.dir, \n                                 DISTMARCH_MAXDIST );\n    \n    // ----------------------------------\n    // SHADING\n    vec3 scenecol = vec3(0.);\n    if (scenemarch.y > 0.5)\n    {\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\n        vec3 mn = compute_normal( mp );\n\n        SurfaceData currSurf = INITSURF(mp, mn);\n        calc_material(scenemarch.y, currSurf);\n\n        scenecol = shade( currSurf );\n    }\n    \n    // ----------------------------------\n    // POST PROCESSING\n    \n    // fall off exponentially into the distance (as if there is a spot light\n    // on the point of interest).\n    scenecol *= exp( -0.05*scenemarch.x*scenemarch.x );\n\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    if (g_debugcolor.a > 0.) {        \n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scenecol;\n    }\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlf3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1454, 1679, 1744, 1744, 1888], [1890, 2115, 2180, 2180, 2322], [2324, 2434, 2492, 2492, 2597], [2599, 2599, 2641, 2900, 3263], [3265, 3265, 3286, 3286, 3331], [3333, 3333, 3365, 3365, 3401], [3402, 3402, 3435, 3435, 3455], [3456, 3456, 3490, 3490, 3510], [3511, 3511, 3543, 3543, 3564], [3595, 3595, 3621, 3621, 3822], [3947, 4091, 4153, 4153, 4456], [4458, 4556, 4606, 4606, 4672], [4674, 4674, 4719, 4719, 4772], [4774, 4774, 4809, 4809, 4841], [4843, 4843, 4897, 4897, 5022], [5024, 5024, 5067, 5067, 5128], [5130, 5130, 5217, 5217, 5340], [5342, 5342, 5424, 5424, 5535], [5538, 5538, 5606, 5606, 5719], [5721, 5721, 5814, 5814, 5925], [5928, 5928, 5977, 5977, 7595], [7597, 7597, 7646, 7646, 9946], [9948, 9948, 9994, 9994, 10934], [10936, 10936, 10985, 10985, 13697], [13699, 13699, 13744, 13744, 14662], [14664, 14664, 14704, 14704, 14925], [14927, 14927, 14955, 14955, 15006], [15008, 15008, 15035, 15035, 15087], [15089, 15186, 15221, 15221, 17419], [17479, 17479, 17527, 17527, 17977], [17979, 18081, 18112, 18112, 18470], [18534, 18534, 18698, 18698, 19022], [19097, 19097, 19155, 19155, 19506], [19508, 19665, 19706, 19727, 20228], [20230, 21127, 21203, 21203, 23198], [23201, 23201, 23254, 23254, 23798], [23800, 23800, 23886, 23886, 25527], [25529, 25529, 25559, 25732, 27259], [27351, 27403, 27510, 27510, 27679], [27681, 27681, 27705, 27759, 29245], [29248, 29335, 29392, 29465, 30636]], "test": "untested"}
{"id": "XlfGR4", "name": "Voxel land 2", "author": "Nrx", "description": "Rework of [url=https://www.shadertoy.com/view/XtlGRr]Voxel land[/url] to be faster on mobile devices (no reflection) and propose different colors...", "tags": ["voxel"], "likes": 33, "viewed": 1856, "published": "Public API", "date": "1418827414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Parameters\n#define CAMERA_FOCAL_LENGTH\t1.5\n#define VOXEL_STEP\t\t\t50.0\n#define SOUND\n#define MOUSE\n#define HSV2RGB_FAST\n\n// Constants\n#define PI\t\t3.14159265359\n#define SQRT2\t1.41421356237\n\n// PRNG\n// From https://www.shadertoy.com/view/4djSRW\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// HSV to RGB\nvec3 hsv2rgb (in vec3 hsv) {\n\t#ifdef HSV2RGB_SAFE\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\t#endif\n\t#ifdef HSV2RGB_FAST\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n\t#else\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n\t#endif\n}\n\n// Main function\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 ((2.0 * fragCoord.xy - iResolution.xy) / iResolution.y, CAMERA_FOCAL_LENGTH));\n\n\t// Get the music info\n\t#ifdef SOUND\n\tfloat soundBass = texture (iChannel0, vec2 (0.0)).x;\n\tfloat soundTreble = texture (iChannel0, vec2 (0.9, 0.0)).x;\n\t#else\n\tfloat soundBass = 0.6 + 0.4 * cos (iTime * 0.2);\n\tfloat soundTreble = 0.5 + 0.5 * cos (iTime * 1.2);\n\t#endif\n\n\t// Set the camera\n\tvec3 origin = vec3 (0.0, 6.0 - 3.0 * cos (iTime * 0.3), iTime * 2.0 + 700.0 * (0.5 + 0.5 * sin (iTime * 0.1)));\n\tfloat cameraAngle = iTime * 0.1;\n\t#ifdef MOUSE\n\tcameraAngle += 2.0 * PI * iMouse.x / iResolution.x;\n\t#endif\n\tvec3 cameraForward = vec3 (cos (cameraAngle), cos (iTime * 0.3) - 1.5, sin (cameraAngle));\n\tvec3 cameraUp = vec3 (0.2 * cos (iTime * 0.7), 1.0, 0.0);\n\tmat3 cameraRotation;\n\tcameraRotation [2] = normalize (cameraForward);\n\tcameraRotation [0] = normalize (cross (cameraUp, cameraForward));\n\tcameraRotation [1] = cross (cameraRotation [2], cameraRotation [0]);\n\tray = cameraRotation * ray;\n\n\t// Voxel\n\tvec3 color = vec3 (0.0);\n\n    vec2 voxelSign = sign (ray.xz);\n\tvec2 voxelIncrement = voxelSign / ray.xz;\n\tfloat voxelTimeCurrent = 0.0;\n\tvec2 voxelTimeNext = (0.5 + voxelSign * (0.5 - fract (origin.xz + 0.5))) * voxelIncrement;\n\tvec2 voxelPosition = floor (origin.xz + 0.5);\n\tfloat voxelHeight = 0.0;\n\tbool voxelDone = false;\n\tvec3 voxelNormal = vec3 (0.0);\n\tfor (float voxelStep = 1.0; voxelStep <= VOXEL_STEP; ++voxelStep) {\n\n\t\t// Compute the height of this column\n\t\tvoxelHeight = 2.0 * rand (voxelPosition) * smoothstep (0.2, 0.5, soundBass) * sin (soundBass * 8.0 + voxelPosition.x * voxelPosition.y) - 5.0 * (0.5 + 0.5 * cos (voxelPosition.y * 0.15));\n\n\t\t// Check whether we hit the side of the column\n\t\tif (voxelDone = voxelHeight > origin.y + voxelTimeCurrent * ray.y) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check whether we hit the top of the column\n\t\tfloat timeNext = min (voxelTimeNext.x, voxelTimeNext.y);\n\t\tfloat timeIntersect = (voxelHeight - origin.y) / ray.y;\n\t\tif (voxelDone = timeIntersect > voxelTimeCurrent && timeIntersect < timeNext) {\n\t\t\tvoxelTimeCurrent = timeIntersect;\n\t\t\tvoxelNormal = vec3 (0.0, 1.0, 0.0);\n\t\t\tbreak;\n\t\t}\n\n\t\t// Next voxel...\n\t\tvoxelTimeCurrent = timeNext;\n\t\tvoxelNormal.xz = step (voxelTimeNext.xy, voxelTimeNext.yx);\n\t\tvoxelTimeNext += voxelNormal.xz * voxelIncrement;\n\t\tvoxelPosition += voxelNormal.xz * voxelSign;\n\t}\n\tif (voxelDone) {\n\t\torigin += voxelTimeCurrent * ray;\n\n\t\t// Compute the local color\n\t\tvec3 mapping = origin;\n\t\tmapping.y -= voxelHeight + 0.5;\n\t\tmapping *= 1.0 - voxelNormal;\n\t\tmapping += 0.5;\n\t\tfloat id = rand (voxelPosition);\n\t\tcolor = hsv2rgb (vec3 ((iTime + floor (mapping.y)) * 0.05 + voxelPosition.x * 0.01, smoothstep (0.2, 0.4, soundBass), 0.7 + 0.3 * cos (id * iTime + PI * soundTreble)));\n\t\tcolor *= smoothstep (0.8 - 0.6 * cos (soundBass * PI), 0.1, length (fract (mapping) - 0.5));\n\t\tcolor *= 0.5 + smoothstep (0.90, 0.95, cos (id * 100.0 + soundTreble * PI * 0.5 + iTime * 0.5));\n\t\tcolor *= 1.0 - voxelTimeCurrent / VOXEL_STEP * SQRT2;\n\t}\n\n\t// Set the fragment color\n\tfragColor = vec4 (color, 1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 244, 271, 271, 421], [423, 437, 465, 465, 800], [802, 819, 875, 926, 4004]], "test": "untested"}
{"id": "XlfGRr", "name": "MÄjasdarbs", "author": "DustyLv", "description": "MÄjas darbs datorgrafikÄ. Lauris Taube", "tags": ["music", "awesome"], "likes": 0, "viewed": 145, "published": "Public", "date": "1417630088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (fragCoord.xy/iResolution.xy) - 0.5 ;\n    float time = iTime;\n    \n    float beat = texture( iChannel1, vec2(0.0, 0.01 ) ).x;\n    \n    float light = 1.5/length(20. / beat*length(0.5 * position.x - vec2(0, 0)));\n    \n    float dia = position.y *2.*sin(0.01*position.y + 2. * time * 0.1) * beat;\n    dia = 1.0 / (200. *(position.x - dia));\n    dia += 0.001/length(position - vec2(0., position.y));\n    \n    float dia2 = -(position.y *2.*sin(0.01*position.y + 2. * time * 0.1) * beat);\n    dia2 = -(1.0 / (200. *(position.x - dia2)));\n    dia2 += 0.001/length(position - vec2(0., position.y));\n    \n    float stripe = position.y * 0.15* sin(500.0*position.y*beat - 5. * time * 0.5) * 0.9;\n    stripe += 0.5 / (1000. * abs(position.x - stripe*0.5));\n    \n\tvec4 veclight = vec4(light *5. , light, light*5. , 1.0);\n    vec4 diag = vec4(position.y*1.1 - dia, dia, dia * 45., 3.);\n    vec4 diag2 = vec4(position.y*1.1 - dia2, dia2, dia2 * 45., 3.);\n    vec4 alldiag = mix(diag,diag2,0.5);\n\n    vec4 vecstripe = vec4(position.y*1. - stripe, stripe, stripe/5.,1.0);\n\n    fragColor = mix(alldiag,mix(veclight,vecstripe,0.5),0.9);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1195]], "test": "untested"}
{"id": "XlfGzH", "name": "The evolution of motion", "author": "xTr1m", "description": "This is a prototype for the PC 8k \"The evolution of motion\" by Alcatraz, ranked 3rd at the Revision 2015 PC 8k compo.\nLink: http://www.pouet.net/prod.php?which=65381", "tags": ["prototype"], "likes": 80, "viewed": 8058, "published": "Public API", "date": "1418333984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.141592;\n\nfloat hash(float n) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise2(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(mix(hash(n+0.0), hash(n+1.0),f.x), mix(hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat noise3(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(\n        mix(mix(hash(n+  0.0), hash(n+  1.0),f.x), mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n        mix(mix(hash(n+113.0), hash(n+114.0),f.x), mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    if (a.x < b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 smax(vec3 a, vec3 b)\n{\n\tif (a.x > b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 sinv(vec3 a)\n{\n\treturn vec3(-a.x, a.y, a.z);    \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat smoothmax( float a, float b, float k )\n{\n    return -log(exp(k*a) + exp(k*b))/-k;\n}\n\nfloat smoothmin( float a, float b, float k )\n{\n    return -log(exp(-k*a) + exp(-k*b))/k;\n}\n\nfloat cylsphere(vec3 p)\n{\n    float d = max(sdCylinder(p, vec3(0.0, 0.0, 0.04)), sdBox(p, vec3(0.3), 0.0));\n    d = smoothmin(d, sdSphere(p+vec3(0.0, 0.35, 0.0), 0.08), 48.0);\n    d = smoothmin(d, sdSphere(p-vec3(0.0, 0.35, 0.0), 0.08), 48.0);\n    return d;\n}\n\nvec3 greeble0(vec3 p, float phase)\n{\n    float t = mod(phase + iTime * 0.5, 1.0);\n    float rotation = sign(phase-0.5) * min(1.0, max(0.0, -0.2 + 5.0 * t)) * pi / 2.0;\n    float translation = min(1.0, max(0.0, 2.0 * sin(min(t - 0.02, 0.5) * 10.0)));\n    \n    float d = sdBox(p, vec3(0.4), 0.075);\n    float e = sdSphere(p - vec3(0.0, 0.6, 0.0), 0.2);\n    d = smoothmax(d, -e, 32.0);\n    p.y -= translation * 0.3 - 0.1;\n    p.xz = r(p.xz, rotation);\n    e = max(sdCylinder(p, vec3(0.0, 0.0, 0.1)), sdBox(p, vec3(0.8), 0.0));\n    vec3 q = p;    \n    q.y -= 0.8;\n    q.yz = r(q.yz,pi/2.0);\n    e = smoothmin(e, cylsphere(q), 16.0);\n    q.xy = r(q.xy,pi/2.0);\n    e = smoothmin(e, cylsphere(q), 16.0);\n    return smin(vec3(d, 0.0, 0.0), vec3(e, 1.0, 0.0));\n}\n\nvec3 greeble1(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.425), 0.05);\n    d = smoothmax(d, -sdBox(p + vec3(0.0, 0.0, 0.3), vec3(0.3, 1.0, 0.01), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.0, 0.0, 0.3), vec3(0.3, 1.0, 0.01), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p + vec3(0.3, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.3, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    \n    float t = mod(phase + sign(phase-0.5) * iTime * 0.5, 1.0);\n    float x = max(-1.0, min(1.0, 4.0*cos(t*2.0*pi)));\n    float y = max(-1.0, min(1.0, 4.0*sin(t*2.0*pi)));\n    x *= 0.3;\n    y *= 0.3;\n    vec3 q = p + vec3(x, 0, y);\n    float e = sdBox(q, vec3(0.03, 0.75, 0.03), 0.0);\n    q.y -= 0.75;\n    e = smoothmin(e, sdSphere(q, 0.1), 32.0);\n    return smin(vec3(d, 2.0, 0.0), vec3(e, 3.0, 0.0));\n}\n\nvec3 greeble2(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.425), 0.05);\n    d = smoothmax(d, -sdBox(p + vec3(0.2, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.2, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    \n    float x = pow(mod(phase + sign(phase-0.5) * iTime * 0.5, 1.0), 2.0) * 2.0 * pi;\n    float t = max(-0.5, min(0.5, sin(x)));\n    p.yz = r(p.yz, t);\n    vec3 q = p + vec3(0.0, 0.25, 0.0);\n    float e =  sdBox(q - vec3(0.2, 0.0, 0.0), vec3(0.02, 1.0, 0.02), 0.0);\n    e = min(e, sdBox(q + vec3(0.2, 0.0, 0.0), vec3(0.02, 1.0, 0.02), 0.0));\n    e = min(e, sdBox(q - vec3(0.0, 1.0, 0.0), vec3(0.175, 0.02, 0.02), 0.0));\n    e = smoothmin(e, sdSphere(q - vec3(0.2, 1.01, 0.0), 0.03), 32.0);\n    e = smoothmin(e, sdSphere(q - vec3(-0.2, 1.01, 0.0), 0.03), 32.0);\n    q.y -= 1.0;\n    q.xy = r(q.xy, pi / 2.0);\n    e = smoothmin(e, max(sdCylinder(q, vec3(0.0, 0.0, 0.03)), sdBox(q, vec3(0.1), 0.0)), 32.0);\n    return smin(vec3(d, 4.0, 0.0), vec3(e, 5.0, 0.0));\n}\n\nvec3 greeble3(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.4), 0.08);\n    ivec2 i = ivec2(p.xz / 0.15 + floor(phase * 815.0));\n    float phase2 = noise2(vec2(i));\n    vec3 q = p;\n    q.xz = mod(q.xz, 0.15);\n    q.xz -= 0.075;\n    q.y -= 0.5;\n    float hole = max(sdBox(q, vec3(0.05, 1.0, 0.05), 0.0), sdBox(p, vec3(0.3, 2.0, 0.3), 0.0));\n    d = smoothmax(d, -hole, 96.0);\n    \n    float t = phase2 * 2.0 * pi + iTime * 8.0;\n    q.y -= 0.1 * max(-0.5, min(0.5, sin(t)));\n    q.y += 0.5;\n    float e = sdBox(q, vec3(0.025, 0.6, 0.025), 0.0);\n    e = max(e, sdBox(p, vec3(0.3, 2.0, 0.3), 0.0));\n    return smin(vec3(d, 6.0, 0.0), vec3(e, 7.0, 0.0));\n}\n\nvec3 greeble4(vec3 p, float phase)\n{\n    float angle = floor(phase * 4.0) * 0.5 * pi;\n    p.xz = r(p.xz, angle);\n    float d = sdBox(p, vec3(0.4), 0.08);\n    d = smoothmax(d, -sdBox(p - vec3(0.2, 0.0, 0.1), vec3(0.1, 1.0, 0.2), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p + vec3(0.2, 0.0, -0.1), vec3(0.1, 1.0, 0.2), 0.0), 32.0);\n    vec3 q = p - vec3(0.0, 0.8, -0.3);\n    float e = sdBox(q + vec3(0.0, 0.2, 0.0), vec3(0.0, 0.15, 0.0), 0.1) / 0.6;\n    q /= 0.6;\n    q.yz = r(q.yz,pi/2.0);\n    \n    float t = phase + 0.2 * iTime;\n    angle = 0.45 * max(-1.0, min(1.0, 4.0*cos(t*2.0*pi)));\n    float y = 0.5 + 0.5 * max(-1.0, min(1.0, 4.0*sin(t*2.0*pi)));\n    y = pow(y, 1.25 + 0.75 * cos(t*2.0*pi));\n    q.xy = r(q.xy, angle);\n    q.y += 0.4;\n    \n    e = smoothmin(e, cylsphere(q), 16.0);\n    q += vec3(0.0, 0.35, 0.05);\n    e = min(e, sdBox(q, vec3(0.0, 0.0, -0.1), 0.2)) * 0.6;\n    float f = sdBox(q + vec3(0.0, 0.0, 1.2 - y), vec3(0.1), 0.0) * 0.6;\n    return smin(smin(vec3(d, 8.0, 0.0), vec3(e, 9.0, 0.0)), vec3(f, 10.0, 0.0));\n}\n\nvec3 greeble(vec3 p, float findex, float phase)\n{\n    const int indexCount = 6;\n    int index = int(findex * float(indexCount));\n    p.y -= phase * 0.2 - 0.2;\n    if (index == 0)\n        return greeble0(p, phase);\n    else if (index == 1)\n        return greeble1(p, phase);\n    else if (index == 2)\n        return greeble2(p, phase);\n    else if (index == 3)\n        return greeble3(p, phase);\n    else if (index == 4)\n        return greeble4(p, phase);\n        \n    return vec3(sdBox(p, vec3(0.4), 0.025), 10.0, 0.0);\n}\n\nvec3 f( vec3 p )\n{\n    ivec3 h = ivec3(p+1337.0);\n    float hash = noise2(vec2(h.xz));\n    h = ivec3(p+42.0);\n    float phase = noise2(vec2(h.xz));\n    vec3 q = p;\n    q.xz = mod(q.xz, 1.0);\n    q -= 0.5;\n\treturn greeble(q, hash, phase);\n}\n\nvec3 colorize(float index)\n{\n    if (index == 0.0)\n        return vec3(0.4, 0.6, 0.2);\n    \n    if (index == 1.0)\n        return vec3(0.6, 0.3, 0.2);\n    \n    if (index == 2.0)\n        return vec3(1.0, 0.8, 0.5);\n    \n    if (index == 3.0)\n        return vec3(0.9, 0.2, 0.6);\n    \n    if (index == 4.0)\n        return vec3(0.3, 0.6, 0.7);\n    \n    if (index == 5.0)\n        return vec3(1.0, 1.0, 0.3);\n    \n    if (index == 6.0)\n        return vec3(0.7, 0.5, 0.7);\n    \n    if (index == 7.0)\n        return vec3(0.4, 0.3, 0.4);\n    \n    if (index == 8.0)\n        return vec3(0.8, 0.3, 0.2);\n    \n    if (index == 9.0)\n        return vec3(0.5, 0.8, 0.2);\n    \n\treturn vec3(index / 10.0);\n}\n\nfloat ao(vec3 v, vec3 n) \n{\n    const int ao_iterations = 10;\n    const float ao_step = 0.2;\n    const float ao_scale = 0.75;\n    \n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n    \n\tfor (int i = 0; i < ao_iterations; i++)\n    {\n\t\tsum += (len - f(v + n * len).x) * att;\t\t\n\t\tlen += ao_step;\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn 1.0 - max(sum * ao_scale, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = vec3(0);\n    \n    vec3 q = vec3((fragCoord.xy / iResolution.xy - 0.5), 1.0);     \n    float vignette = 1.0 - length(q.xy);\n    q.x *= iResolution.x / iResolution.y;\n    q.y -= 0.5;\n    vec3 p = vec3(0, 0.0, -10.0);\n    q = normalize(q);\n    q.xz = r(q.xz, iTime * 0.1);\n    p.y += 2.5;\n\tp.z -= iTime*0.5;\n    \n    float t=0.0;\n    vec3 d = vec3(0);\n    float steps = 0.0;\n    const float maxSteps = 96.0;\n    for (float tt = 0.0; tt < maxSteps; ++tt)\n    {\n        d = f(p+q*t);\n        t += d.x*0.45;\n        if(!(t<=50.0)||d.x<=0.0001)\n        {\n            break;\n        }\n        steps = tt;\n    }\n\n    vec3 glow = vec3(1.1, 1.1, 1.0);\n    vec3 fog = vec3(0.7, 0.75, 0.8);\n    vec3 color = fog;\n\n    if (t <= 50.0)\n    {\n        vec3 hit = p+q*t;\n\n        vec2 e = vec2(0.001, 0.00);\n        vec3 normal= vec3( f(hit + e.xyy).x - f(hit - e.xyy).x, f(hit + e.yxy).x - f(hit - e.yxy).x, f(hit + e.yyx).x - f(hit - e.yyx).x) / (2.0 * e.x);\n\n        normal= normalize(normal);\n    \n        float fao = ao(hit, normal);\n        vec3 ldir = normalize(vec3(1.0, 1.0, -1.0));\n        vec3 light = (0.5 * fog.rgb + vec3(0.5 * fao * abs(dot(normal, ldir)))) * colorize(d.y); // diffuse\n        light += (1.0 - t / 50.0) * vec3(fao * pow(1.0 - abs(dot(normal, q)), 4.0)); // rim\n        q = reflect(q, normal);\n        light += fao * vec3(pow(abs(dot(q, ldir)), 16.0)); // specular\n        color = min(vec3(1), light);\n        color *= fao;\n    }\n    \n    float luma = dot(color.rgb, vec3(0.3, 0.5, 0.2));\n    color = mix(color, 1.0 * luma * vec3(1.0, 0.9, 0.5), 2.0 * max(0.0, luma-0.5)); // yellow highlights\n    color = mix(color, 1.0 * luma * vec3(0.2, 0.5, 1.0), 2.0 * max(0.0, 0.5-luma)); // blue shadows\n    //color = mix(color, glow, 0.8 * pow(steps / 90.0, 8.0)); // glow\n    color = mix(color, fog, pow(min(1.0, t / 50.0), 0.5)); // fog\n    color = pow(color, vec3(0.8)); // gamma\n    color = smoothstep(0.0, 1.0, color); // contrast\n    color *= pow(vignette + 0.3, 0.5); // vignette\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 88], [90, 90, 115, 115, 315], [317, 317, 342, 342, 671], [673, 673, 697, 697, 742], [744, 744, 771, 771, 829], [831, 831, 858, 858, 913], [915, 915, 934, 934, 970], [972, 972, 1005, 1005, 1029], [1031, 1031, 1069, 1069, 1169], [1171, 1171, 1207, 1207, 1241], [1243, 1243, 1289, 1289, 1332], [1334, 1334, 1380, 1380, 1424], [1426, 1426, 1451, 1451, 1685], [1687, 1687, 1723, 1723, 2441], [2443, 2443, 2479, 2479, 3283], [3285, 3285, 3321, 3321, 4303], [4305, 4305, 4341, 4341, 4962], [4964, 4964, 5000, 5000, 5997], [5999, 5999, 6048, 6048, 6519], [6521, 6521, 6539, 6539, 6760], [6762, 6762, 6790, 6790, 7450], [7452, 7452, 7479, 7479, 7816], [7818, 7818, 7875, 7875, 9920]], "test": "untested"}
{"id": "Xll3RM", "name": "Marching the Desert", "author": "jameswilddev", "description": "A scene of infinite rolling sand dunes.", "tags": ["raymarchingdesertsandskysceneinfinite"], "likes": 3, "viewed": 372, "published": "Public", "date": "1420059581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define MORE_MOUSE_MOVEMENT\n//#define RANDOM_BALL_OFFSETS\n\n// Gets the normal vector along which to trace a ray for the current pixel.\nvec3 lens(vec2 fragCoord) {\n    return normalize(vec3(fragCoord.xy / iResolution.xy - 0.5, 0.3));\n}\n\n// Terrain.\nfloat terrainWave(vec3 at, float xzScale, float yScale) {\n    return (sin(at.x * xzScale) + cos(at.z * xzScale)) * yScale;\n}\n\nfloat terrain(vec3 at) {\n    return \n        terrainWave(at, 0.01, 32.0)\n        + terrainWave(at, 0.1, 2.0)\n        -abs(sin((at.x/40.0) + sin(at.z / 100.0) * 1.0)) * 50.0;\n}\n\nfloat terrainDetailed(vec3 at) {\n    return terrain(at);\n}\n\n// Shapes.\nstruct shapeResult {\n    float distance;\n    int materialId;\n};\n    \nshapeResult sphere(vec3 origin, float radius, int materialId, vec3 at) {\n    return shapeResult(distance(origin, at) - radius, materialId);\n}\n\nshapeResult plane(float origin, int materialId, float at) {\n    return shapeResult(at - origin, materialId);\n}\n\n// Shape CSG.\nshapeResult add(shapeResult left, shapeResult right) {\n    return shapeResult(left.distance < right.distance ? left.distance : right.distance, left.distance < right.distance ? left.materialId : right.materialId);\n}\n\n// Scene analysis.\n#define MATERIAL_SKY 0\n#define MATERIAL_SAND 1\n#define MATERIAL_MIRROR 2\n\nshapeResult scene(vec3 at) {\n    return add(\n        sphere(vec3(30.0, 30.0, 30.0)\n\t\t\t\t#ifdef RANDOM_BALL_OFFSETS\n\t\t\t\t\t+ sin(floor(at.x / 60.0) * 2.0 + floor(at.y / 60.0) * 3.1 + floor(at.z / 60.0) * 4.6) * 16.0\n\t\t\t\t#endif\n\t\t\t, 5.0, MATERIAL_MIRROR, mod(at, 60.0)), \n        plane(terrainDetailed(at), MATERIAL_SAND, at.y)\n    );\n}\n\n#define NORMAL_OFFSET vec2(0.01, 0.0)\nvec3 sceneNormal(vec3 at) {\n    return normalize(vec3(\n        scene(at + NORMAL_OFFSET.xyy).distance - scene(at - NORMAL_OFFSET.xyy).distance,\n        scene(at + NORMAL_OFFSET.yxy).distance - scene(at - NORMAL_OFFSET.yxy).distance,\n        scene(at + NORMAL_OFFSET.yyx).distance - scene(at - NORMAL_OFFSET.yyx).distance\n    ));\n}\n\nstruct raymarchResult {\n    vec3 location;\n    int materialId;\n};\n\nraymarchResult raymarch(vec3 at, vec3 normal) {\n    for(int iteration = 0; iteration < 128; iteration++) {\n        shapeResult sam = scene(at);\n        if(sam.distance < 0.1)\n            return raymarchResult(at, sam.materialId);\n        at += normal * sam.distance * 0.5;\n    }\n    return raymarchResult(vec3(0.0), MATERIAL_SKY);\n}\n\nraymarchResult raymarchFast(vec3 at, vec3 normal) {\n    for(int iteration = 0; iteration < 24; iteration++) {\n        shapeResult sam = scene(at);\n        if(sam.distance < 0.1)\n            return raymarchResult(at, sam.materialId);\n        at += normal * sam.distance;\n    }\n    return raymarchResult(vec3(0.0), MATERIAL_SKY);\n}\n\n// Materials.\n\n\n// Computes the sky color at a given normal.\nvec3 sky(vec3 normal) {\n    if(normal.y < -0.1) return vec3(0.0);\n    // Sun normal.\n    float sunBlend = dot(normal, normalize(vec3(1.0, 2.0, 2.0))) * 0.5 + 0.5;\n    return mix(\n        mix(\n            // Horizon color.\n            vec3(0.4, 0.5, 0.7),\n            mix(\n                // Sky color.\n                vec3(0.0, 0.0, 1.0), \n                vec3(0.0, 0.0, 0.1),\n            \tsunBlend\n            ),\n            normal.y\n        ), \n        // Sun color.\n        vec3(2.0, 2.0, 1.0),\n        pow(\n \t\t\tsunBlend,\n            // Sun size.\n            32.0\n        )\n    );\n}\n\nfloat occlusion(vec3 at, vec3 normal, float radius) {\n    return max(scene(at + normal * radius).distance / radius, 0.0);\n}\n\nvec3 diffuse(vec3 at, vec3 color) {\n    vec3 normal = sceneNormal(at);\n    vec3 light = sky(normal) * occlusion(at, normal, 8.0);\n    return light * color;\n}\n\nvec3 sand(vec3 at) {\n    return diffuse(at, vec3(0.9, 0.4, 0.01));\n}\n\nvec3 secondary(vec3 at, vec3 normal) {\n    raymarchResult sam = raymarchFast(at, normal);\n    if(sam.materialId == MATERIAL_SAND) {\n        return sand(sam.location);\n    } else if(sam.materialId == MATERIAL_MIRROR) {\n        vec3 refl = sceneNormal(sam.location);\n        return sky(reflect(normal, refl)) * occlusion(sam.location, refl, 8.0);\n    }    \n    return sky(normal);\n}\n\nvec3 mirror(vec3 at, vec3 inboundNormal) {\n    vec3 normal = reflect(inboundNormal, sceneNormal(at));\n    return secondary(at + normal * 0.1, normal);\n}\n\nvec3 primary(vec3 at, vec3 normal) {\n    raymarchResult sam = raymarch(at, normal);\n    if(sam.materialId == MATERIAL_SAND) {\n        return sand(sam.location);\n    } else if(sam.materialId == MATERIAL_MIRROR) {\n        return mirror(sam.location, normal);\n    }    \n    return sky(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLocation = vec3(0.0, 50.0, -2.0) + vec3((iMouse.xy / iResolution.xy) * \n\t\t#ifdef MORE_MOUSE_MOVEMENT\n\t\t\t72.0, \n\t\t#else\n\t\t\t8.0,\n\t\t#endif\n\t\t-50.0 + iTime * 5.0);\n    vec3 cameraNormal = lens(fragCoord);\n\tfragColor = vec4(pow(primary(cameraLocation, cameraNormal), vec3(1.0 / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xll3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 137, 164, 164, 236], [238, 250, 307, 307, 374], [376, 376, 400, 400, 551], [553, 553, 585, 585, 611], [613, 693, 765, 765, 834], [836, 836, 895, 895, 946], [948, 962, 1016, 1016, 1176], [1178, 1271, 1299, 1299, 1602], [1642, 1642, 1669, 1669, 1972], [2041, 2041, 2088, 2088, 2373], [2375, 2375, 2426, 2426, 2704], [2722, 2767, 2790, 2790, 3352], [3354, 3354, 3407, 3407, 3477], [3479, 3479, 3514, 3514, 3636], [3638, 3638, 3658, 3658, 3706], [3708, 3708, 3746, 3746, 4088], [4090, 4090, 4132, 4132, 4242], [4244, 4244, 4280, 4280, 4536], [4538, 4538, 4595, 4595, 4897]], "test": "untested"}
{"id": "Xll3Rr", "name": "Alpine Jets", "author": "dr2", "description": "Flight over snowy landscape.", "tags": ["raymarch", "mountains", "snow", "jetplane"], "likes": 22, "viewed": 1453, "published": "Public API", "date": "1418056080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Alpine Jets\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nint idObj, idObjGrp;\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, qHit, qHitTransObj, sunDir, sunCol;\nvec2 trkOffset;\nfloat szFac, wSpan, fusLen, flameLen, tCur;\nconst float dstFar = 200.;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t) + 100. * trkOffset.x,\n     1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = 0.06 * p;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4 && hiRes == 0) break;\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y += (sqrt (abs (ht) + 1.) - 1.) * sign (ht) + 0.3 * Noisefv2 (0.1 * p);\n  float g = smoothstep (0.7 * (0.6 + 0.4 * Noisefv2 (0.31 * p)), 3.5 *\n     (0.7 + 0.4 * Noisefv2 (0.11 * p)), sqrt (abs (p.x - pt.x) + 1.) - 1.);\n  return SmoothMin (ht, pt.y * (1. - g) + ht * g, 0.5);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.7, 0.8, 0.8), gCol2 = vec3 (0.3, 0.2, 0.2),\n     gCol3 = vec3 (0.5, 0.4, 0.4), gCol4 = vec3 (0.2, 0.3, 0.2);\n  vec3 col = vec3 (0.9, 0.9, 1.);\n  float cSpec = 1.;\n  float f, d;\n  vec2 q = p.xz;\n  if (n.y < 0.5) {\n    f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n        0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n    col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec = 0.5;\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * f * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 2.;\n  for (int i = 0; i < 10; i++) {\n    vec3 p = ro + rd * d;\n    float h = p.y - GrndHt (p.xz, 0);\n    sh = min (sh, 20. * h / d);\n    d += 4.;\n    if (h < 0.01) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, tapr;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  vec2 q = p.yz;\n  float s = abs (p.x - wg.trans);\n  float dz = s / wg.span;\n  return max (length (abs (q) + vec2 (wg.sRad + wg.tapr * dz * dz * dz, 0.)) -\n     wg.thck, s - wg.span);\n}\n\nfloat FlameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.z -= - (fusLen + 0.5 * flameLen);\n  float wr = 0.5 * (q.z / flameLen - 1.);\n  d = PrCylDf (q, 0.045 * (1. + 0.6 * wr) * fusLen, flameLen);\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar / szFac;\n  dHit = FlameDf (flyerMat[0] * (p - flyerPos[0]) / szFac, dHit);\n  dHit = FlameDf (flyerMat[1] * (p - flyerPos[1]) / szFac, dHit);\n  dHit = FlameDf (flyerMat[2] * (p - flyerPos[2]) / szFac, dHit);\n  return dHit * szFac;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.01;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wt;\n  float wSweep = 0.1;\n  float taPos = 0.75 * fusLen;\n  q = p;\n  wt = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.07 + 0.11 * wt, -0.05),\n      0.08 * fusLen, 0.4 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q = p;\n  q -= fusLen * vec3 (0., 0., -0.12);\n  d = max (PrCylDf (q, (0.14 - 0.1 * wt * wt) * fusLen, fusLen),\n     - min (PrCylDf (q - fusLen * vec3 (0., 0., 1.07), 0.06 * fusLen, 0.1 * fusLen),\n     PrCylDf (q - fusLen * vec3 (0., 0., -0.99), 0.04 * fusLen, 0.15 * fusLen)));\n  d = min (d, PrTorusDf (q - fusLen * vec3 (0., 0., 0.99),\n     0.01 * fusLen, 0.055 * fusLen));\n  if (d < dHit + 0.1) { dHit = SmoothMin (dHit, d, 0.1);  idObj = idObjGrp + 2;  qHit = q; }\n  q = p;\n  q -= fusLen * vec3 (0., 0., 0.9);\n  d = PrConeDf (q, fusLen * vec3 (0.04, 0.02, 0.05));\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + 6;  qHit = q; }\n  q = p;\n  q -= fusLen * vec3 (0., 0.15, -0.1);\n  d = PrCylDf (q.xzy, 0.005 * fusLen, 0.05 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + 1;  qHit = q; }\n  wt = wSweep * abs (p.x) / wSpan;\n  q = p - vec3 (0., - 0.05 * fusLen + 12. * wt, 1. - 2. * wt);\n  wg = WingParm (wSpan, 13.7, 0., 14.05, 0.37);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.2) { dHit = SmoothMin (dHit, d, 0.2);  idObj = 3;  qHit = q; }\n  q = p - vec3 (0., -0.01 * fusLen + 6. * wt, - taPos - 4. * wt);\n  wg = WingParm (0.45 * wSpan, 6.8, 0., 7.05, 0.37);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) { dHit = SmoothMin (dHit, d, 0.1);  idObj = idObjGrp + 4;  qHit = q; }\n  wt = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (-0.2, 0., taPos + 40. * wt);\n  wg = WingParm (0.2 * wSpan, 7., 1.5, 7.2, 0.2);\n  d = max (WingDf (q, wg), - q.x);\n  if (d < dHit + 0.1) { dHit = SmoothMin (dHit, d, 0.1);  idObj = idObjGrp + 5;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar / szFac;\n  idObjGrp = 1 * 256;\n  dHit = FlyerDf (flyerMat[0] * (p - flyerPos[0]) / szFac, dHit);\n  idObjGrp = 2 * 256;\n  dHit = FlyerDf (flyerMat[1] * (p - flyerPos[1]) / szFac, dHit);\n  idObjGrp = 3 * 256;\n  dHit = FlyerDf (flyerMat[2] * (p - flyerPos[2]) / szFac, dHit);\n  return dHit * szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.07 * szFac;\n  for (int i = 0; i < 40; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.07 * szFac;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec3 FlyerCol (vec3 n)\n{\n  vec3 col = vec3 (1., 0.3, 0.3), pCol = vec3 (0., 1., 0.);\n  int ig = idObj / 256;\n  int id = idObj - 256 * ig;\n  if (id >= 3 && id <= 5) {\n    float s1, s2, s3;\n    if (id == 3) { s1 = 1.6;  s2 = 6.; s3 = 11.; }\n    else if (id == 4) { s1 = 1.;  s2 = 1.2; s3 = 4.1; }\n    else if (id == 5) { s1 = 1.;  s2 = 0.9; s3 = 3.4; }\n    if (abs (qHit.x) > s2 - 0.03 && abs (qHit.x) < s3 + 0.03)\n       col *= 1. - 1. * SmoothBump (-0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1)\n       col *= 1. - 1. * (SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2) +\n       SmoothBump (-0.05, 0.05, 0.02, abs (qHit.x) - s3));\n  }\n  qHit /= fusLen;\n  if (id == 1) {\n    if (abs (abs (qHit.z - 0.09) - 0.25) > 0.006) col = vec3 (0.3);\n  } else if (id == 2) {\n    vec3 nn;\n    if (ig == 1) nn = flyerMat[0] * n;\n    else if (ig == 2) nn = flyerMat[1] * n;\n    else nn = flyerMat[2] * n;\n    if (qHit.z > 0.97  || qHit.z < -0.83) col *= 0.1;\n    else if (qHit.z > 0. && nn.z > 0.9) col *= 0.1;\n    else if (qHit.z < 0. && nn.z < -0.9) col = vec3 (1., 0., 0.);\n    else {\n      qHit.z -= -0.3;\n      col = mix (pCol, col,\n         (1. - SmoothBump (0.04, 0.07, 0.01, length (qHit.yz))) *\n         (1. - 0.8 * SmoothBump (-0.01, 0.02, 0.01, length (qHit.yz))));\n    }\n  } else if (id == 3) {\n    qHit.x = abs (qHit.x) - 0.4;\n    qHit.z -= 0.03;\n      col = mix (pCol, col,\n        (1. - 0.8 * SmoothBump (0.07, 0.11, 0.01, length (qHit.xz))) *\n        (1. - 0.8 * SmoothBump (-0.01, 0.03, 0.01, length (qHit.xz))));\n  } else if (id == 6) col = vec3 (1., 0., 0.);\n  idObj = 10;\n  return col;\n}\n\nvec3 FlameCol (vec3 col)\n{\n  vec3 q = qHitTransObj;\n  float fFac = clamp (mod (4. * (q.z / flameLen + 1.) +\n     0.5 * Noisefv2 (10. * q.xy + tCur * vec2 (11., 13.)) +\n     7.1 * tCur, 1.), 0., 1.);\n  float c = clamp (q.z, 0., 1.);\n  return fFac * vec3 (c + 0.5, 0.5 * c + 0.1, 0.1 * c + 0.1) + 0.8 * (1. - c) * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, vn;\n  float dstHit, dstGrnd, dstObj, dstFlame, f, ao;\n  int idObjT;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  wSpan = 13.;\n  fusLen = 12.;\n  flameLen = 0.25 * fusLen;\n  dstFlame = TransObjRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (dstObj < dstFlame) dstFlame = dstFar;\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = FlyerCol (vn);\n    if (idObj == 10) objCol = 0.7 * objCol + 0.5 * SkyCol (ro, reflect (rd, vn));\n    float dif = max (dot (vn, sunDir), 0.);\n    ao = ObjAO (ro, vn);\n    col = objCol * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (dif + ao * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    dstHit = dstObj;\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      isGrnd = true;\n    } else col = SkyCol (ro, rd);\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    vec4 col4 = GrndCol (ro, vn);\n    float dif = max (dot (vn, sunDir), 0.);\n    col = col4.xyz * sunCol * (0.2 + max (0., dif) * GrndSShadow (ro, sunDir) *\n       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n  }\n  if (dstFlame < dstFar) col = FlameCol (col);\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid PlanePM (float t, float vu)\n{\n  float tInterp = 100.;\n  float dt = 2.;\n  flPos = TrackPath (t);\n  vec3 fpF = TrackPath (t + dt);\n  vec3 fpB = TrackPath (t - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  float vy = vel.y;\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  float m1, m2;\n  if (vu == 0.) { m1 = 1.;  m2 = 25.; }\n  else { m1 = 0.2;  m2 = 10.; }\n  vel.y = vy;\n  vec3 ort = vec3 (- m1 * asin (vel.y / length (vel)),\n     atan (vel.z, vel.x) - 0.5 * pi, m2 * length (va) * sign (va.y));\n  if (vu > 0.) { ort.xz *= -1.;  ort.y += pi; }\n  vec3 cr = cos (ort);\n  vec3 sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  float tDisc = floor ((t) / tInterp) * tInterp;\n  float s = (t - tDisc) / tInterp;\n  flPos.y = (1. - s) * GrndHt (TrackPath (tDisc).xz, 0) +\n     s * GrndHt (TrackPath (tDisc + tInterp).xz, 0) + 7.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 3.3;\n  tCur = 18. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (-0.9, 1., 1.));\n  sunCol = vec3 (1.);\n  szFac = 0.2;\n  float tGap = 12.;\n  tCur += tGap;\n  PlanePM (tCur, 0.);  flyerPos[0] = flPos;  flyerMat[0] = flMat;\n  PlanePM (tCur + tGap, 0.);  flyerPos[1] = flPos;  flyerMat[1] = flMat;\n  PlanePM (tCur + 2. * tGap, 0.);  flyerPos[2] = flPos;  flyerMat[2] = flMat;\n  float vuPeriod = 900.;\n  float lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  float dVu = smoothstep (0.8, 0.97, mod (tCur, vuPeriod) / vuPeriod);\n  PlanePM (tCur + tGap * (1. + 1.5 * lookDir * (1. - 1.2 * dVu)), lookDir);\n  vec3 ro = flPos;\n  ro.y += 2.5 * sqrt (dVu);\n  vec3 rd = normalize (vec3 (uv, zmFac)) * flMat;\n  ro.y += 0.3;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xll3Rr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 240, 264, 264, 311], [313, 313, 338, 338, 517], [519, 519, 544, 544, 903], [905, 905, 950, 950, 1048], [1050, 1050, 1107, 1107, 1190], [1192, 1192, 1235, 1235, 1308], [1310, 1310, 1352, 1352, 1403], [1405, 1405, 1451, 1451, 1522], [1524, 1524, 1557, 1557, 1630], [1853, 1853, 1879, 1879, 2064], [2066, 2066, 2100, 2100, 2815], [2817, 2817, 2848, 2848, 3030], [3032, 3032, 3063, 3063, 3711], [3713, 3713, 3747, 3747, 4290], [4292, 4292, 4314, 4314, 4448], [4450, 4450, 4482, 4482, 5047], [5049, 5049, 5087, 5087, 5322], [5385, 5385, 5421, 5421, 5607], [5609, 5609, 5645, 5645, 5893], [5895, 5895, 5922, 5922, 6176], [6178, 6178, 6216, 6216, 6423], [6425, 6425, 6461, 6461, 8310], [8312, 8312, 8334, 8334, 8654], [8656, 8656, 8689, 8689, 8892], [8894, 8894, 8915, 8915, 9138], [9140, 9140, 9177, 9177, 9404], [9406, 9406, 9438, 9438, 9620], [9622, 9622, 9646, 9646, 11224], [11226, 11226, 11252, 11252, 11544], [11546, 11546, 11581, 11581, 13127], [13129, 13129, 13163, 13163, 14181], [14183, 14183, 14240, 14240, 15169]], "test": "untested"}
{"id": "XllGRn", "name": "Visible Clock", "author": "dr2", "description": "The mechanics of timekeeping; when the clock is open time speeds up to show all the gears rotating (there is an optional second hand - see the source).\n", "tags": ["raymarching", "gears", "time"], "likes": 9, "viewed": 805, "published": "Public API", "date": "1418289768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Visible Clock\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n//#define SHOW_SEC   // uncomment to show second hand (may crash some browsers)\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, todCur, tCyc, tSeq, aVelFac, axDist, wlGap, fadeCase, openMech;\nbool visCase;\nconst float ntM1 = 36., ntM2 = 12., ntM3 = 48., ntM4 = 12.;\n#ifdef SHOW_SEC\nconst float ntS1 = 32., ntS2 = 16., ntS3 = 36., ntS4 = 12.,\n   ntS5 = 60., ntS6 = 12., ntS7 = 32., ntS8 = 16.;\n#endif\nconst float rtFacB = (7./32.), ttWid = 0.35;\nconst int idBody = 10, idGearS = 11, idGearB = 12, idHandH = 13,\n   idHandM = 14, idHandS = 15, idAxH = 16, idAxM = 17, idAxS = 18,\n   idAxF = 19, idAxB = 20, idCase = 21, idDial = 22, idRing = 23, idFoot = 24;\nconst float dstFar = 100.;\nconst float pi = 3.14159;\n\nfloat GearDf (vec3 p, float rtFac, float nth, float aRot, float tWid, float wlThk,\n   float dHit, int idGear)\n{\n  float nsp = 8.;\n  float rad = rtFac * nth;\n  float d, a;\n  vec3 q = p;\n  vec2 s = vec2 (abs (length (q.xz) - (rad - 1.5 * tWid)) - 2. * tWid,\n     abs (q.y) - wlThk);\n  d = min (max (s.x, s.y), 0.) + length (max (s, 0.));\n  d = min (d, max (length (q.xz) - 5. * wlThk, abs (q.y) - wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  vec3 qq = q;\n  float g = atan (q.z, - q.x);\n  a = 2. * pi / nth;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  d = max (d, - (rad - 1.5 * tWid - tWid + clamp (2. * abs (q.z) - abs (q.x) - tWid,\n     q.x, q.x + 2. * tWid)));\n  q = qq;\n  a = 2. * pi / nsp;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  q.x += 0.5 * rad - 0.5 * tWid;\n  d = min (d, PrBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  if (d < dHit) { dHit = d;  idObj = idGear;  qHit = q; }\n  return dHit;\n}\n\nfloat GearTrainDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, angRot, rtFac;\n  float wlThk = 0.15;\n  angRot = - todCur * aVelFac;\n  rtFac = rtFacB;\n  p.y -= 4. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntM1, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntM1 / ntM2;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntM2, angRot + pi / ntM2, ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = (4./5.) * rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntM3, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntM3 / ntM4;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntM4, angRot + pi / ntM4, ttWid, wlThk, dHit, idGearS);\n#ifdef SHOW_SEC\n  wlThk *= 0.9;\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS1, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS1 / ntS2;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS2, angRot + pi / ntS2, ttWid, wlThk, dHit, idGearS);\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS3, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS3 / ntS4;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS4, angRot + pi / ntS4, ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = (2./3.) * rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS5, angRot, ttWid, wlThk, dHit, idGearB);\n  q = p;  q.x += axDist;\n  angRot *= - ntS5 / ntS6;\n  dHit = GearDf (q, rtFac, ntS6, angRot + pi / ntS6, 0.65 * ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS7, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS7 / ntS8;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS8, angRot + pi / ntS8, ttWid, wlThk, dHit, idGearS);\n#endif\n  return 0.5 * dHit;\n}\n\nfloat AxleDf (vec3 p, float rad, float len, float dHit, int idAx)\n{\n  vec3 q = p.xzy;\n  float d;\n  d = PrCylDf (q, rad, len);\n  if (d < dHit) { dHit = d;  idObj = idAx;  qHit = q; }  \n  return dHit;\n}\n\nfloat FrameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float axRad = 0.3;\n  p.y -= 4. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.5 * wlGap);\n  dHit = AxleDf (q, 1.5 * axRad, 1.4 * wlGap, dHit, idAxH);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 0.6 * wlGap, dHit, idAxB);\n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3. * wlGap);\n  dHit = AxleDf (q, axRad, 4. * wlGap, dHit, idAxM);\n#ifdef SHOW_SEC\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 0.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 0.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n#else\n  p.y += 5. * wlGap;\n#endif\n  p.y += wlGap;\n  q = p;  q.xy -= vec2 (axDist, 6.4 * wlGap);\n  dHit = AxleDf (q, 0.5 * axRad, 7.2 * wlGap, dHit, idAxS);\n  q = p;  q.xy -= vec2 (- axDist, 5. * wlGap);\n  dHit = AxleDf (q, 0.5 * axRad, 6.1 * wlGap, dHit, idAxF);\n  p.y -= 5. * wlGap;\n  q = p;  q.y = abs (q.y) - 5.5 * wlGap;\n  d = PrBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  if (d < dHit) { dHit = d;  idObj = idAxB;  qHit = q; }\n  return dHit;\n}\n\nfloat HandsDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, angRot, angRotS, angRotM, angRotH;\n  p.x -= axDist;\n  angRot = todCur * aVelFac;\n  angRotH = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotH) * vec2 (1., 1.) + q.zx * sin (angRotH) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2., 5.7 * wlGap);\n  d = PrCylDf (q.zyx, 0.5 * ttWid, 2.);\n  if (d < dHit) { dHit = d;  idObj = idHandH;  qHit = q; }\n  angRot *= (ntM1 / ntM2) * (ntM3 / ntM4);\n  angRotM = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotM) * vec2 (1., 1.) + q.zx * sin (angRotM) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2.5, 6.5 * wlGap);\n  d = PrCylDf (q.zyx, 0.5 * ttWid, 2.5);\n  if (d < dHit) { dHit = d;  idObj = idHandM;  qHit = q; }\n#ifdef SHOW_SEC\n  angRot *= (ntS1 / ntS2) * (ntS3 / ntS4) * (ntS5 / ntS6) * (ntS7 / ntS8);\n  angRotS = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotS) * vec2 (1., 1.) + q.zx * sin (angRotS) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2.7, 7.3 * wlGap);\n  d = PrCylDf (q.zyx, 0.3 * ttWid, 3.2);\n  if (d < dHit) { dHit = d;  idObj = idHandS;  qHit = q; }\n#endif\n  return dHit;\n}\n\nfloat CaseDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8;\n  q = p;\n  d = PrBoxDf (q, vec3 (13.5, 4.4, 8.5));\n  if (d < dHit) { dHit = d;  idObj = idCase;  qHit = q; }\n  q.xy -= vec2 (axDist, 4.3);\n  d = max (PrCylDf (q.xzy, 7.4, 0.4), - PrCylDf (q.xzy, 7., 0.41));\n  if (d < dHit) { dHit = d;  idObj = idRing;  qHit = q; }\n  d = PrCylDf (q.xzy, 7., 0.1);\n  if (d < dHit) { dHit = d;  idObj = idDial;  qHit = q; }\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  if (d < dHit) { dHit = d;  idObj = idFoot;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  if (visCase) dHit = CaseDf (p, dHit);\n  else dHit = GearTrainDf (p, dHit);\n  dHit = FrameDf (p, dHit);\n  dHit = HandsDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 5.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.4, 0.2, 0.1), vec3 (0.3, 0.1, 0.), f);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == idCase) {\n    if (n.y < 0.99 || length (qHit.xz - vec2 (-8., -3.)) > 3.)\n       col4 = vec4 (WoodCol (qHit, n), 1.);\n    else col4 = vec4 (0.1, 0.07, 0., 0.1) *\n       (0.5 + 0.5 * Noisefv2 (50. * qHit.xz));\n  } else if (idObj == idDial) {\n    col4 = vec4 (0.7, 1., 1., 1.);\n    float a = 6. * (atan (qHit.z, - qHit.x) / pi + 1.);\n    if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n       abs (length (qHit.xz) - 5.9) < 0.9) col4 *= 0.1;\n  } else if (idObj == idRing) col4 = vec4 (0.2, 0.7, 1., 1.);\n  else if (idObj == idGearB) col4 = vec4 (1., 1., 0.5, 1.);\n  else if (idObj == idGearS) col4 = vec4 (0.8, 0.8, 0.2, 1.);\n  else if (idObj == idAxB) col4 = vec4 (0.6, 0.6, 0.3, 1.);\n  else if (idObj == idAxF) col4 = vec4 (0.4, 0.4, 0.3, 1.);\n  else if (idObj == idHandH || idObj == idAxH) col4 = vec4 (1., 0.3, 0.2, 1.);\n  else if (idObj == idHandM || idObj == idAxM) col4 = vec4 (0.3, 0.2, 1., 1.);\n#ifdef SHOW_SEC\n  else if (idObj == idHandS || idObj == idAxS) col4 = vec4 (0.3, 1., 0.2, 1.);\n#endif\n  else if (idObj == idFoot) col4 = vec4 (0.3, 0.2, 0.1, 0.1);\n  else col4 = vec4 (0.);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, roo;\n  int idObjT;\n  float dstHit, dif, ao;\n  vec3 colC = vec3 (0., 0., 0.04), colNC = vec3 (0., 0., 0.04);\n  roo = ro;\n  visCase = true;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    ao = ObjAO (ro, vn);\n    colC = objCol.xyz * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * (dif + ao * objCol.w *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  ro = roo;\n  visCase = false;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    ao = ObjAO (ro, vn);\n    colNC = objCol.xyz * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * (dif + ao * objCol.w *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  return sqrt (clamp (mix (colC, colNC, fadeCase), 0., 1.));\n}\n\nvoid SetConfig ()\n{\n  tCyc = 30.;\n  tSeq = mod (tCur, tCyc);\n  fadeCase = SmoothBump (5., 25., 2., tSeq);\n  openMech = SmoothBump (10., 20., 1., tSeq);\n#ifdef SHOW_SEC\n  aVelFac = (2. * pi / (12. * 3600.)) * (1. + 99. * step (0.2, openMech));\n#else\n  aVelFac = (2. * pi / (12. * 3600.)) * (1. + 1999. * step (0.2, openMech));\n#endif\n  wlGap = 0.7 * (1. + 1.3 * openMech);\n  axDist = 4.83;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  float dist = 60.;\n  float zmFac = 5.;\n  float az = pi;\n  float el = 0.5 * pi;\n  SetConfig ();\n  float dir = (1. - 2. * floor (mod (tCur / (3. * tCyc), 2.)));\n  az += dir * 2. * pi * tSeq / tCyc;\n  el -= 0.04 * pi * openMech;\n  vec2 ca = cos (vec2 (el, az));\n  vec2 sa = sin (vec2 (el, az));\n  mat3 vuMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  vec3 rd = vuMat * normalize (vec3 (uv, zmFac));\n  vec3 ro = - vuMat * vec3 (0., 0., dist);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllGRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 323, 347, 347, 402], [404, 404, 428, 428, 475], [477, 477, 502, 502, 681], [683, 683, 704, 704, 841], [843, 843, 900, 900, 983], [985, 985, 1015, 1015, 1089], [1091, 1091, 1123, 1123, 1218], [1220, 1220, 1262, 1262, 1313], [1938, 1938, 2049, 2049, 2864], [2866, 2866, 2906, 2906, 4752], [4754, 4754, 4821, 4821, 4954], [4956, 4956, 4992, 4992, 6519], [6521, 6521, 6557, 6557, 7604], [7606, 7606, 7641, 7641, 8195], [8197, 8197, 8219, 8219, 8392], [8394, 8394, 8427, 8427, 8630], [8632, 8632, 8653, 8653, 8876], [8878, 8878, 8910, 8910, 9092], [9094, 9094, 9125, 9125, 9328], [9330, 9330, 9352, 9352, 10483], [10485, 10485, 10520, 10520, 11771], [11773, 11773, 11792, 11792, 12163], [12166, 12166, 12223, 12223, 13030]], "test": "untested"}
{"id": "XllGzN", "name": "Cosmic 2", "author": "huwb", "description": "Original by Kali. Collaboration with Beibei Wang. Two noise reductions. Reduces temporal noise by keeping samples stationary in world. Reduces spatial high freq noise by limiting size of contribution from each fractal iteration.", "tags": ["fractal", "volume", "raymarch", "kaliset"], "likes": 55, "viewed": 1552, "published": "Public", "date": "1419336787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Started as Star Nest by Pablo RomÃ¡n Andrioli\n// Modifications by Beibei Wang and Huw Bowles.\n// This content is under the MIT License.\n\n// On reducing the spatial high frequency noise:\n\n// We simply limit the size of each contribution of each iteration of the fractal using min():\n// a += i > 7 ? min( 12.,abs(length(p)-pa)) : abs(length(p)-pa)\n// The test on the iteration count is optional, we found that most of the problem noise is introduced in the later\n// iterations so we found that keeping the original formula for the earlier iterations helps to retain the 'volume'\n// without the noise.\n\n\n// On reducing the temporal noise:\n\n// This version has volume samples aligned along view space Z isolines. When the camera moves\n// forwards, the samples are shifted towards the viewer, allowing the camera to move forward\n// smoothly without aliasing (besides the high frequency speckle noise).\n\n// However if the  camera were to rotate around its origin, the volume samples towards\n// the sides of the image sweep in Z and aliasing would occur. To make this case work, the samples\n// need to be arranged in concentric rings around the camera. However in this configuration\n// there will be some aliasing at the sides of the screen when the camera moves forward,\n// because the motion of the camera can no longer be compensated for completely - one can\n// pull in the vert rings but they will move at different rates in Z\n\n// I had similar issues in a different context and made some diagrams etc, see\n// http://advances.realtimerendering.com/s2013/OceanShoestring_SIGGRAPH2013_Online.pptx\n// And developed a fast realtime version of adaptive stationary sampling:\n// https://www.shadertoy.com/view/XdBXWW\n\n\n// Question - the derivative can be computed for \"free\" using dual numbers, as in https://www.shadertoy.com/view/Xd2GzR .\n// The derivate may help to eliminate noise? Or perhaps the second derivate. It would be very interesting to see these\n// derivatives rendered.\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 18\n#define stepsize 0.050\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.10 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.760\n#define saturation 0.800\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=(iTime-3311.)*speed;\n\n\t\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\t\n\tvec3 forward = vec3(0.,0.,1.);\n\t\n\t//mouse rotation\n\tfloat a1 = 0.3;//3.1415926 * (iMouse.x/iResolution.x-.5);\n\tmat2 rot1 = mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tfloat a2 = .6;//3.1415926 * (iMouse.y/iResolution.y-.5);\n\tmat2 rot2 = mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tforward.xz *= rot1;\n\tdir.yz*=rot1;\n\tforward.yz *= rot1;\n\n\t// pan (dodgy)\n\tfrom += (iMouse.x/iResolution.x-.5)*vec3(-forward.z,0.,forward.x);\n\t\n\t//zoom\n\tfloat zooom = time;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize; // make from 0 to 1\n\t\n\t//volumetric rendering\n\tfloat s=0.1;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset);\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\t//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise\n            float D = abs(length(p)-pa); // absolute sum of average change\n            a += i > 7 ? min( 12., D) : D;\n\t\t\tpa=length(p);\n\t\t}\n\t\t//float dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\t//if (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\t// brightens stuff up a bit\n\t\tfloat s1 = s+zoffset;\n\t\t// need closed form expression for this, now that we shift samples\n\t\tfloat fade = pow(distfading,max(0.,float(r)-sampleShift));\n\t\tv+=fade;\n        \n\t\t// fade out samples as they approach the camera\n\t\tif( r == 0 )\n\t\t\tfade *= 1. - sampleShift;\n\t\t// fade in samples as they approach from the distance\n\t\tif( r == volsteps-1 )\n\t\t\tfade *= sampleShift;\n\t\tv+=vec3(2.*s1,4.*s1*s1,16.*s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllGzN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1714, 2239, 2296, 2324, 4392]], "test": "untested"}
{"id": "Xls3R4", "name": "GoldenDunes", "author": "Passion", "description": "Displaced raymarched plane with distance fog. References: http://www.iquilezles.org/www/articles/fog/fog.htm and https://www.shadertoy.com/view/Msf3DB", "tags": ["noise", "raymarch", "perlin", "terrian"], "likes": 18, "viewed": 577, "published": "Public", "date": "1419229469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* 2014 Passion*/\n#define rigged\n\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p ) {                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\nfloat distanceFunction(vec3 p)\n{\n  vec4 n = vec4(0.0,1.0,0.0,1.0); \n  float disp = .3*sin(.4*p.z)*sin(p.x+noise(p.zx))*2.5;\n  #ifdef rigged\n  disp = .3*sin(1.4*p.x+cos(p.z*1.3))-(1.0-abs(sin(p.x+noise(p.zx))))*.4;\n  #endif\n  float plane = dot(p,n.xyz) + n.w;\n  return (plane+disp);\n}\n \nvec3 getNormal(vec3 p)\n{\n  const float d = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),\n        distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),\n        distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))\n      )\n    );\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n   vec2 resolution = iResolution.xy;\n   float time = iTime*.3;\n\n  float tt = iTime; \n    \n  vec2 pos = (fragCoord.xy*2.0 -resolution) / resolution.y;\n  vec3 bg = mix(vec3(0.0,0.0,0.9*pos.y),vec3(1.5),.3);  \n\n  vec3 camPos = vec3(sin(time*.1)*20., -.2, 3.0-time);\n  vec3 camDir = vec3(.3, -0.2, -1.0);\n  vec3 camUp = vec3(0.0, 1.0, 0.0);\n  vec3 camSide = cross(camDir, camUp);\n  float focus = 1.8;\n  vec3 col = vec3(0.0);\n  vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*focus);\n  \n  float t = 0.0, d;\n  vec3 posOnRay = camPos;\n \n  for(int i=0; i<64; ++i)\n  {\n    d = distanceFunction(posOnRay);\n    t += d;\n    posOnRay = camPos + t*rayDir;\n  }\n    \n  vec4 tex = texture(iChannel0,posOnRay.xz*1.5);\n  vec3 l = vec3(sin(time),20.,-20.);\n  vec3 normal = getNormal(posOnRay);\n  \n    if(abs(d) < 0.5)\n  {\n    float diff = dot(normal,normalize(l));\n    float spe = 1.5*pow(clamp(dot(reflect(rayDir, normal), l), 0., 1.), 150.);\n    vec3 brdf = 1.5*vec3(.10, .11, .11);\n    float fre = .2*pow(clamp(1. + dot(normal, rayDir), 0., 1.), 2.);\n    brdf += 1.30*diff*vec3(1., .9, .75);\n    col=diff*vec3(.8,.6,.3)*spe*brdf+fre*tex.rgb;\n    fragColor = vec4(mix(col,bg,smoothstep(.1,.2,t*.015)),1.0);\n  }else\n  {\n    fragColor = vec4(bg,1.0);\n  }\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 225, 246, 286, 423], [424, 424, 450, 450, 821], [823, 823, 855, 855, 1106], [1109, 1109, 1133, 1133, 1469], [1472, 1472, 1529, 1529, 2789]], "test": "untested"}
{"id": "XlsGRN", "name": "Fractal Bridge", "author": "dr2", "description": "A bridge appears in a tranquil valley; follow the bird as it flies through it.", "tags": ["raymarching", "flight", "bridge"], "likes": 17, "viewed": 1054, "published": "Public API", "date": "1419286198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fractal Bridge\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.5 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  float s = length (max (d, 0.));\n  d = min (d, 0.);\n  return max (d.x, max (d.y, d.z)) + s;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrArchDf (vec3 p, float ht, float wd)\n{\n  return max (length (p.yx - vec2 (ht * clamp (p.y / ht, -1., 1.), 0.)) - wd, - p.y);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nstruct RBridge {\n  float bLen, bHt, lvHt, aWd, aHt, aTk, aRp, rFac;\n};\nRBridge rb;\n\nint idObj;\nmat3 bdMat, birdMat;\nvec3 bdPos, birdPos, fltBox, qHit, ltDir;\nfloat tCur, tBldCyc, tBldSeq, birdLen, birdVel, scnRad, scnLen;\nbool isShad, brBuild, brShow;\nconst float dstFar = 50.;\nconst int idBrg1 = 1, idBrg2 = 2, idSlope = 3, idRocks = 4, idCase = 5,\n   idWat = 6, idWing = 11, idBdy = 12, idEye = 13, idBk = 14;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n  return sbCol + 0.2 * pow (1. - max (rd.y, 0.), 5.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 10. * tCur;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * f * rd.y - 1., 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, ltDir), 0.);\n  col = SkyBg (rd) + (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.05;\n  p += 0.005 * tCur * vec3 (0., 0., 1.);\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) +\n       0.003 * tCur * vec3 (0., 0., 1.);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.12 * ht;\n}\n\nvec3 WaterNf (vec3 p)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nfloat BdWingDf (vec3 p, float dHit)\n{\n  vec3 q, qh;\n  float d, dd, a, wr;\n  float wngFreq = 6.;\n  float wSegLen = 0.15 * birdLen;\n  float wChord = 0.3 * birdLen;\n  float wSpar = 0.02 * birdLen;\n  float fTap = 8.;\n  float tFac = (1. - 1. / fTap);\n  q = p - vec3 (0., 0., 0.3 * birdLen);\n  q.x = abs (q.x) - 0.1 * birdLen;\n  float wf = 1.;\n  a = -0.1 + 0.2 * sin (wngFreq * tCur);\n  d = dHit;\n  qh = q;\n  for (int k = 0; k < 5; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSegLen;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSegLen));\n    dd = PrFlatCylDf (q.zyx, wr * wChord, wr * wSpar, wSegLen);\n    if (k < 4) {\n      q.x -= wSegLen;\n      dd = min (dd, PrCapsDf (q, wr * wSpar, wr * wChord));\n    } else {\n      q.x += wSegLen;\n      dd = max (dd, PrCylDf (q.xzy, wr * wChord, wSpar));\n      dd = min (dd, max (PrTorusDf (q.xzy, 0.98 * wr * wSpar, wr * wChord), - q.x));\n    }\n    if (dd < d) {\n      d = dd;  qh = q;\n    }\n    a *= 1.03;\n    wf *= tFac;\n  }\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idWing;  qHit = qh; }\n  return dHit;\n}\n\nfloat BdBodyDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, a, wr;\n  float bkLen = 0.15 * birdLen;\n  q = p;\n  wr = q.z / birdLen;\n  float tr, u;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * birdLen, birdLen);\n  if (d < dHit) { dHit = d;  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  wr = (wr + 1.) * (wr + 1.);\n  q -= birdLen * vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCylDf (q, 0.009 * birdLen, 0.2 * birdLen);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= birdLen * vec3 (0.08, 0.05, 0.9);\n  d = PrSphDf (q, 0.04 * birdLen);\n  if (d < dHit) { dHit = d;  idObj = idEye;  qHit = q; }\n  q = p;  q -= birdLen * vec3 (0., -0.015, 1.15);\n  wr = clamp (0.5 - 0.3 * q.z / bkLen, 0., 1.);\n  d = PrFlatCylDf (q, 0.25 * wr * bkLen, 0.25 * wr * bkLen, bkLen);\n  if (d < dHit) { dHit = d;  idObj = idBk;  qHit = q; }\n  return dHit;\n}\n\nfloat BirdDf (vec3 p, float dHit)\n{\n  dHit = BdWingDf (p, dHit);\n  dHit = BdBodyDf (p, dHit);\n  return 0.9 * dHit;\n}\n\nvec4 BirdCol (vec3 n)\n{\n  vec3 col;\n  float spec = 1.;\n  if (idObj == idWing) {\n    float gw = 0.15 * birdLen;\n    float w = mod (qHit.x, gw);\n    w = SmoothBump (0.15 * gw, 0.65 * gw, 0.1 * gw, w);\n    col = mix (vec3 (0., 0., 1.), vec3 (1., 0., 0.), w);\n  } else if (idObj == idEye) {\n    col = vec3 (0., 0.6, 0.);\n    spec = 5.;\n  } else if (idObj == idBdy) {\n    vec3 nn = birdMat * n;\n    col = mix (mix (vec3 (1., 0., 0.), vec3 (0., 0., 1.),\n       smoothstep (0.5, 1., nn.y)), vec3 (1.),\n       1. - smoothstep (-1., -0.7, nn.y));\n  } else if (idObj == idBk) {\n    col = vec3 (1., 1., 0.);\n  }\n  return vec4 (col, spec);\n}\n\nvec3 BirdTrack (float t)\n{\n  vec3 bp;\n  float rdTurn = 0.3 * min (fltBox.x, fltBox.z);\n  float tC = 0.5 * pi * rdTurn / birdVel;\n  vec3 tt = vec3 (fltBox.x - rdTurn, length (fltBox.xy), fltBox.z - rdTurn) *\n     2. / birdVel;\n  float tFlyCyc = 2. * (2. * tt.z + tt.x  + 4. * tC + tt.y);\n  float tFlySeq = mod (t + 0.2 * tt.z, tFlyCyc);\n  float ti[9];  ti[0] = 0.;  ti[1] = ti[0] + tt.z;  ti[2] = ti[1] + tC;\n  ti[3] = ti[2] + tt.x;  ti[4] = ti[3] + tC;  ti[5] = ti[4] + tt.z;\n  ti[6] = ti[5] + tC;  ti[7] = ti[6] + tt.y;  ti[8] = ti[7] + tC;\n  float a, h, hd, tf;\n  h = - fltBox.y;\n  hd = 1.;\n  if (tFlySeq > 0.5 * tFlyCyc) {\n    tFlySeq -= 0.5 * tFlyCyc;\n    h = - h;  hd = - hd;\n  }\n  float rSeg = -1.;\n  vec3 fbR = vec3 (1.);\n  fbR.xz -= vec2 (rdTurn) / fltBox.xz;\n  bp.xz = fltBox.xz;\n  bp.y = h;\n  if (tFlySeq < ti[4]) {\n    if (tFlySeq < ti[1]) {\n      tf = (tFlySeq - ti[0]) / (ti[1] - ti[0]);\n      bp.xz *= vec2 (1., fbR.z * (2. * tf - 1.));\n    } else if (tFlySeq < ti[2]) {\n      tf = (tFlySeq - ti[1]) / (ti[2] - ti[1]);  rSeg = 0.;\n      bp.xz *= fbR.xz;\n    } else if (tFlySeq < ti[3]) {\n      tf = (tFlySeq - ti[2]) / (ti[3] - ti[2]);\n      bp.xz *= vec2 (fbR.x * (1. - 2. * tf), 1.);\n    } else {\n      tf = (tFlySeq - ti[3]) / (ti[4] - ti[3]);  rSeg = 1.;\n      bp.xz *= fbR.xz * vec2 (-1., 1.);\n    }\n  } else {\n    if (tFlySeq < ti[5]) {\n      tf = (tFlySeq - ti[4]) / (ti[5] - ti[4]);\n      bp.xz *= vec2 (- 1., fbR.z * (1. - 2. * tf));\n    } else if (tFlySeq < ti[6]) {\n      tf = (tFlySeq - ti[5]) / (ti[6] - ti[5]);  rSeg = 2.;\n      bp.xz *= - fbR.xz;\n    } else if (tFlySeq < ti[7]) {\n      tf = (tFlySeq - ti[6]) / (ti[7] - ti[6]);\n      bp.xz *= vec2 (fbR.x * (2. * tf - 1.), - 1.);\n      bp.y = h + 2. * fltBox.y * hd * tf;\n    } else {\n      tf = (tFlySeq - ti[7]) / (ti[8] - ti[7]);  rSeg = 3.;\n      bp.xz *= fbR.xz * vec2 (1., -1.);\n      bp.y = - h;\n    }\n  }\n  if (rSeg >= 0.) {\n    a = 0.5 * pi * (rSeg + tf);\n    bp += rdTurn * vec3 (cos (a), 0., sin (a));\n  }\n  bp.y -= 0.85 * rb.bHt - fltBox.y;\n  return bp;\n}\n\nfloat BridgeDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, ds, yb, yh, sRed, aw, ah;\n  float zCut = 0.3 * rb.bHt;\n  q = p;\n  yh = 0.02 * q.z;\n  q = p;  q.y -= 0.01 * rb.bHt;\n  d = PrBoxDf (q, vec3 (rb.bLen, rb.bHt, 0.0875 * rb.bHt * (1. - 0.444 * q.y / rb.bHt)));\n  sRed = 1.;\n  yb = - rb.bHt;\n  for (int k = 0; k < 4; k ++) {\n    float kf = float (k);\n    aw = rb.aWd * sRed;\n    ah = rb.aHt * sRed;\n    q = p;\n    q.x = mod (q.x + kf * rb.aRp * aw, 2. * rb.aRp * aw) - rb.aRp * aw;\n    q.y -= yb;\n    d = max (max (d, - PrArchDf (q, ah, aw)), - PrArchDf (q.zyx, 0.6 * ah, 0.3 * aw));\n    yb += rb.lvHt * sRed;\n    sRed *= rb.rFac;\n  }\n  q = p;  q.y -= rb.bHt;  q.y -= yh;\n  float dc = PrCylDf (q, scnRad, zCut);\n  d = max (d, dc);\n  float varHt, varHtP, varLen;\n  if (brBuild) {\n    varHt = 0.;\n    varLen = rb.bLen * min (mod (5. * tBldSeq / tBldCyc, 1.) + 0.01, 1.);\n    int iq = int (floor (5. * tBldSeq / tBldCyc));\n    sRed = 1.;\n    for (int k = 0; k <= 4; k ++) {\n      varHtP = varHt;\n      varHt += rb.lvHt * sRed;\n      sRed *= rb.rFac;\n      if (k == iq) break;\n    }\n    q = p;  q.y -= - rb.bHt;\n    ds = min (PrBoxDf (q, vec3 (varLen, varHt, zCut)),\n       PrBoxDf (q, vec3 (rb.bLen, varHtP, zCut)));\n    d = max (d, ds);\n  }\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrg1; }\n  yb = - rb.bHt;\n  q = p;  q.y -= yb;\n  d = min (d, PrBoxDf (q, vec3 (rb.bLen, rb.aTk, 10. * rb.aTk)));\n  q.x = mod (q.x, 2. * rb.aRp * rb.aWd) - rb.aRp * rb.aWd;\n  d = max (d, - PrBoxDf (q, vec3 (5.5 * rb.aTk, 2. * rb.aTk, zCut)));\n  sRed = 1.;\n  for (int k = 0; k <= 3; k ++) {\n    yb += rb.lvHt * sRed;\n    sRed *= rb.rFac;\n    q = p;  q.y -= yb;\n    d = min (d, PrBoxDf (q, vec3 (rb.bLen, rb.aTk * sRed, 10. * rb.aTk * sRed)));\n  }\n  d = max (d, dc);\n  if (brBuild) {\n    q = p;  q.y -= - rb.bHt + 0.125 * rb.lvHt - 3. * rb.aTk;\n    d = max (d, ds);\n  }\n  d = max (d, dc);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrg2; }\n  return dHit;\n}\n\nfloat GroundDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, db, dc, yh, dw, a, g;\n  q = p;  q.y -= rb.bHt;\n  yh = 0.02 * q.z;\n  dc = PrCylDf (q, scnRad, 1.2 * scnLen);\n  db = max (max (PrCylDf (q, 1.01 * scnRad, scnLen), q.y + 0.015 * rb.bHt),\n     - q.y - 2.11 * rb.bHt + yh);\n  d = max (db, - dc);\n  q = p;  q.y -= - 1.05 * rb.bHt + yh;\n  dw = PrBoxDf (q, vec3 (0.7 * scnRad, 0.025 * scnRad, 1.005 * scnLen));\n  q.y -= 0.025 * scnRad;\n  dw = max (dw, - PrBoxDf (q, vec3 (0.6 * scnRad, 0.025 * scnRad, scnLen)));\n  d = min (d, max (dw, dc));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idCase; }\n  q = p;  q.y -= rb.bHt + yh;\n  a = atan (q.x, - q.y) / pi;\n  g = Fbm2 (2. * vec2 ((abs (a) < 0.8) ? 12. * a : q.x, q.z));\n  d = max (db, - PrCylDf (q, scnRad  * (0.995 - 0.07 * (1. - abs (a)) * g),\n     1.2 * scnLen));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idSlope; }\n  d = max (db, q.y + 2.12 * rb.bHt * (1. - 0.05 * g));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRocks; }\n  d = max (db, q.y + 2. * rb.bHt);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idWat; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dHit = dstFar;\n  if (brShow) dHit = BridgeDf (p, dHit);\n  if (! isShad) dHit = GroundDf (p, dHit);\n  if (! brBuild) {\n    q = p;  q -= birdPos;\n    if (PrSphDf (q, 0.2) < dHit) dHit = BirdDf (birdMat * q, dHit);\n  }\n  return 0.9 * dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.03;\n  for (int i = 0; i < 50; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.03;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.01 + float (i) / 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 SceneCol (vec3 n)\n{\n  vec3 col;\n  float spec = 1.;\n  if (idObj == idBrg1) col = vec3 (0.55, 0.35, 0.15);\n  else if (idObj == idBrg2) col = 0.9 * vec3 (0.55, 0.35, 0.15);\n  else if (idObj == idSlope) {\n    col = mix (vec3 (0.3, 0.2, 0.1), vec3 (0.2, 0.7, 0.2),\n       clamp (qHit.y + 3.5, 0., 1.));\n    if (abs (n.z) < 0.99 && n.y < 0.5) col = mix (vec3 (0.25, 0.25, 0.2), col, \n       smoothstep (0.2, 0.5, n.y));\n    spec = 0.2;\n  } else if (idObj == idRocks) {\n    col = mix (vec3 (0.2, 0.4, 0.1), vec3 (0.3, 0.25, 0.1),\n       clamp (10. * (qHit.y + 3.5), 0., 1.));\n    spec = 0.5;\n  } else if (idObj == idCase) col = WoodCol (3. * qHit.zyx, n);\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, col;\n  float reflFac;\n  int idObjT;\n  float dstHit, ao, sh;\n  isShad = false;\n  reflFac = 1.;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar && idObj == idWat) {\n    ro += rd * dstHit;\n    rd = reflect (rd, WaterNf (qHit));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    reflFac *= 0.8;\n  }\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit >= dstFar) col = SkyCol (ro, rd);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idBrg1 || idObj == idBrg2) vn = VaryNf (50. * qHit, vn, 0.5);\n    else if (idObj == idCase) vn = VaryNf (qHit * vec3 (10., 10., 0.5), vn, 1.);\n    if (idObj >= idWing) objCol = BirdCol (vn);\n    else objCol = SceneCol (vn);\n    float dif = max (dot (vn, ltDir), 0.);\n    ao = ObjAO (ro, vn);\n    isShad = true;\n    sh = ObjSShadow (ro, ltDir);\n    col = reflFac * objCol.xyz * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) + \n       max (0., dif) * sh *\n       (dif + ao * objCol.w * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid BirdPM (float t, int id)\n{\n  float dt = 1.;\n  bdPos = BirdTrack (t);\n  vec3 bpF = BirdTrack (t + dt);\n  vec3 bpB = BirdTrack (t - dt);\n  vec3 vel = (bpF - bpB) / (2. * dt);\n  float vy = vel.y;  vel.y = 0.;\n  vec3 acc = (bpF - 2. * bdPos + bpB) / (dt * dt);  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  float el = - 0.75 * asin (vel.y / length (vel));\n  float rl = 1.5 * length (va) * sign (va.y);\n  if (id > 0) {\n    el += 0.05 * pi;  rl = 0.5 * rl;\n  }\n  vec3 ort = vec3 (el, atan (vel.z, vel.x) - 0.5 * pi, rl);\n  vec3 cr = cos (ort);\n  vec3 sr = sin (ort);\n  bdMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid SetConf ()\n{\n  rb.bLen = 5.;\n  rb.bHt = 0.343 * rb.bLen;  rb.lvHt = rb.bHt * 0.7314;\n  rb.aHt = 0.6 * rb.lvHt;  rb.aWd = 0.0526 * rb.bLen;  rb.aTk = 0.0243 * rb.bHt;\n  rb.aRp = 1.2;  rb.rFac = 0.75;\n  scnRad = 0.867 * rb.bLen;  scnLen = 1.3 * rb.bLen;\n  fltBox = vec3 (3. * rb.aRp * rb.aWd, 0.25 * (1. + rb.rFac) * rb.lvHt, 0.7 * scnLen);\n  birdVel = 0.5;\n  BirdPM (tCur, 0);\n  birdPos = bdPos;  birdMat = bdMat;\n  birdLen = 0.08;\n}\n\n//#define TRACK_MODE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  int vuMode;\n  mat3 vuMat;\n  vec3 ro, rd, vd;\n  float tDel, zmFac;\n  SetConf ();\n  tBldCyc = 10.;\n  tBldSeq = mod (tCur, tBldCyc);\n  brShow = true;  brBuild = false;\n  ltDir = normalize (vec3 (-0.4, 0.2, -0.3));\n  if (tCur < tBldCyc) {\n    vuMode = 1;  brShow = false;\n  } else if (tCur < 2. * tBldCyc) {\n    vuMode = 1;  brBuild = true;\n#ifdef TRACK_MODE\n  } else if (tCur < 10. * tBldCyc) {\n    vuMode = 2;\n#endif\n  } else vuMode = 3;\n  if (vuMode == 1) {\n    zmFac = 3.6;\n    float az = 0.05 * 2. * pi * tCur;\n    float el = 0.6 - 0.5 * cos (2. * az);\n    float cEl = cos (el), sEl = sin (el);\n    float cAz = cos (az), sAz = sin (az);\n\n    vuMat = mat3 (cAz, 0., - sAz, 0., 1., 0., sAz, 0., cAz) *\n       mat3 (1., 0., 0., 0., cEl, sEl, 0., - sEl, cEl);\n    float dist = max (25. - 10. * tCur / tBldCyc, 15.);\n    ro = dist * vuMat * vec3 (0., 0., -1.);\n    ltDir = ltDir * vuMat;\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n  } else if (vuMode == 2) {\n    ro = vec3 (-0.45 * fltBox.x, 2. * fltBox.y, - 4. * fltBox.z);\n    vd = normalize (birdPos - ro);\n    vec3 u = - vd.y * vd;\n    float f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    zmFac = 30. * (birdPos.z - ro.z) / (scnLen - ro.z);\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n  } else if (vuMode == 3) {\n    tDel = 1.2;\n    BirdPM (tCur - tDel, 1);\n    ro = bdPos;  ro.y += 2.5 * birdLen;\n    vuMat = bdMat;\n    zmFac = 1.3;\n    rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  }\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 269, 293, 293, 340], [342, 342, 366, 366, 421], [423, 423, 448, 448, 627], [629, 629, 654, 654, 960], [962, 962, 983, 983, 1120], [1122, 1122, 1151, 1151, 1353], [1355, 1355, 1394, 1394, 1601], [1603, 1603, 1648, 1648, 1746], [1748, 1748, 1805, 1805, 1888], [1890, 1890, 1921, 1921, 2133], [2135, 2135, 2165, 2165, 2239], [2241, 2241, 2273, 2273, 2392], [2394, 2394, 2427, 2427, 2454], [2456, 2456, 2498, 2498, 2549], [2551, 2551, 2594, 2594, 2667], [2669, 2669, 2728, 2728, 2832], [2834, 2834, 2879, 2879, 2967], [2969, 2969, 3015, 3015, 3072], [3487, 3487, 3509, 3509, 3609], [3611, 3611, 3643, 3643, 4197], [4199, 4199, 4223, 4223, 4543], [4545, 4545, 4568, 4568, 4709], [4711, 4711, 4748, 4748, 5760], [5762, 5762, 5799, 5799, 6817], [6819, 6819, 6854, 6854, 6935], [6937, 6937, 6960, 6960, 7566], [7568, 7568, 7594, 7594, 9615], [9617, 9617, 9654, 9654, 11567], [11569, 11569, 11606, 11606, 12670], [12672, 12672, 12694, 12694, 12951], [12953, 12953, 12986, 12986, 13189], [13191, 13191, 13212, 13212, 13420], [13422, 13422, 13459, 13459, 13670], [13672, 13672, 13704, 13704, 13887], [13889, 13889, 13913, 13913, 14571], [14573, 14573, 14608, 14608, 15791], [15793, 15793, 15824, 15824, 16569], [16571, 16571, 16588, 16588, 17008], [17010, 17032, 17089, 17089, 18782]], "test": "untested"}
{"id": "XlX3R4", "name": "Christmas Mandeltree", "author": "guil", "description": "A bicomplex Mandelbrot like fractal for the tree.\nA pseudo kleinian fractal for the environment.\nUsing IQ's code for coloring and lighting and", "tags": ["3d", "fractal"], "likes": 2, "viewed": 393, "published": "Public", "date": "1418934524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Overstepping from Eiffie's sans normal : https://www.shadertoy.com/view/Xll3zH \n// Coloring and lighting based on IQ's Apollonian : https://www.shadertoy.com/view/4ds3zn\n\n#define AUTO_OVERSTEP\n\nconst int MaxIter = 12;\nfloat zoom=1.;\n\n\n// Complex operations\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n// Biomplex multiplication\n\nvec4 bmul(vec4 a, vec4 b){vec2 dx = cmul(a.xy,b.xy)-cmul(a.zw,b.zw);vec2 dy = cmul(a.xy,b.zw)+cmul(a.zw,b.xy);return vec4(dx,dy);}\n\n// Intersection with sphere from IQ\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// Distance estimation for bicomplex fractal\n\nfloat de( vec3 p)\n{\n\tfloat dr = 1.;\t\n    p*=dr;\n\tfloat r2;\n    vec4 z = vec4(p.yzx,0.);        \n    vec4 c= z;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(z,z);\n            if(r2>100.)continue;\n            dr=2.*sqrt(r2)*dr+1.0;\n\t\t\tz=z.wxyz;\n            z=bmul(z,z)+c;\n            \t\t\t\t\t\t\n\t}\n    return .5*length(z)*log(length(z))/dr;\t    \t\n}\n\n    \n// Orbit trapping for bicomplex fractal\n    \nvec4 map(in vec3 p,inout vec3 nor)\n{\n\tfloat dr = 1.0;\n\tvec4 ot = vec4(1000.0);\n        \n\tfloat r2;\n    vec4 z = vec4(p.yzx,0.);     \n    vec4 c= z;\n    vec4 pz= vec4(0.);\n    float otl=100.;\n\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(z,z);\n            if(r2>100.)continue;\n\t\t\n            ot = min( ot, vec4(abs(z.xyz),r2) );\n        \n            pz=z;\n            dr=2.*sqrt(r2)*dr+1.0;\n\t\t\tz=z.wxyz;\n            z=bmul(z,z)+c;           \t\t\t\t\t\t\n\t}\t\n\t\n        nor= normalize((z-pz).xyz);    \n        return ot;\t\n}\n\n\n// Distance estimation for pseudo kleinian fractal    \n\t\n\nvec4 orb;\nfloat de2( vec3 p )\n{\n\tfloat scale = .4;\n\tvec3 CSize = vec3(1.0,0.8,1.1);\n    float g=.85;\n\torb = vec4(1000.0);\n    p+=vec3(2.5,0.,2.5);\n\tp*=scale;\n    \n    \n\tfor( int i=0; i<6;i++ )\n\t{\n\n\t\tp = (-1.0 + 2.0*fract(0.5*p*CSize+0.5))/CSize;\n\t\tp = clamp(p,-CSize,  CSize) * 2.0 - p;\n\n\t\tfloat r2 = dot(p,p);\t\t\t\t\n        orb = min( orb, vec4(abs(p),r2) );\t\t\n\t\tfloat k = max(1.3/r2,.1)*g;\n\n\t\tp     *= k;\n\t\tscale *= k;\n\n\t}\n\n    return 0.5*abs(p.y+.03)/scale;\t\n}\n\n\n\nbool hit1,hit2 = false;\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  delta = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n    if(hit1){\n\t\tnor.x = de(pos+delta.xyy) - de(pos-delta.xyy);\n\t\tnor.y = de(pos+delta.yxy) - de(pos-delta.yxy);\n\t\tnor.z = de(pos+delta.yyx) - de(pos-delta.yyx);\n    }else{\n    \tnor.x = de2(pos+delta.xyy) - de2(pos-delta.xyy);\n\t\tnor.y = de2(pos+delta.yxy) - de2(pos-delta.yxy);\n        nor.z = de2(pos+delta.yyx) - de2(pos-delta.yyx);\n    }\n\treturn normalize(nor);\n}\n\n\nfloat march( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\t\n\tfloat t = tminmax.x,pd=10.0,os=0.0,step;\n   \tfloat dt = 1.;\n    float dt1 = 1.;\n    float dt2 = 1.;\n       \n    float preci =  .3/min(iResolution.x,iResolution.y);//0.001;//\n\n\tfor(int i=0; i<128; i++)\n\t{\n\t\t\n        if( t>tminmax.y || dt<=preci*t ) continue;\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\t\n\t\tdt1 = de(pos);\n        dt2 = de2(pos);\n        dt= min(dt1,dt2);\n#ifdef AUTO_OVERSTEP\n\t\tif(dt>=os){\t\t//we have NOT stepped over anything\n\t\t\tos=0.44*dt*dt/pd;//overstep based on ratio of this step to last\n\t\t\tstep=dt+os;\t//add in the overstep\n\t\t\tpd=dt;\t\t//save this step length for next calc\n\t\t}else{step=-os*1.2;dt=1.0;pd=100000.0;os=0.0;}//remove overstep\n#else\n\t\tstep=dt;\n#endif\n        \n        t += step;\n                     \t\t\n\t}\n   \tif(t>tminmax.y||dt>preci*t)return-1.;\n    if(dt1<dt2)hit1=true;\n    else hit2=true;\n    \n\treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n    \n    vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n\n    vec3 ro = zoom*1.7*vec3(cos(an), .6-0.5*cos(2.*an), sin(an));\n    vec3 ta = vec3(0.0,.6, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = vec3(0.0);\n    float t;\n    vec2 seg= vec2(0.,30.);;\n\n      \n    t = march( ro, rd, seg );\n    if(t>=0.&&hit1){//Bicomplex\n        //t-=.01;\n\t\tvec3 nor=vec3(0.);\n\t\tvec3 pos = ro+ t* rd;\n\t\tvec4 res = map( pos,nor );\n\t\tvec3 col1 =clamp(res.xyz,0.,1.);\n\t\tcol1=.5*(col1+col1.brg);\n\t\tcol1.g+=col1.r;\n\t\tif(pos.y>1.5)col1=vec3(.9,.9,.2);                     \n\t\tvec3 nor1 = calcNormal( pos);\n         //nor1=nor;\n\n        // lighting\n        \n\t\tfloat key = clamp( dot( light1, nor1 ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor1 ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor1.y);\n\t\tfloat ao = pow( clamp(res.a*2.0,0.2,1.0), 2.2 );\t\t\n        vec3 brdf = vec3(ao)*(.4*amb+1.5*key+.2*bac);\n        \n        col = col1*brdf;\n            \n            \n\t\t//Light Strings\n                \n\t\tvec3 lightString1=vec3(.7,.6,0.2);\n\t\tvec3 lightString2=vec3(.4,.5,0.7);\n\t\tif(fract(iTime)<.5)lightString1=vec3(0.);\n\t\tif(fract(1.3*iTime)>.5)lightString2=vec3(0.);\n\t\tif(abs(res.x-sin(res.y))<.0005)col+=lightString1;\n\t\tif(abs(res.y-sin(res.z))<.0005)col+=lightString2;\n               \n                \n\t    \n        }\n        \n        \n        vec3 c = vec3(.8,.4,.5);\n        seg = iSphere( ro, rd, vec4(c,0.05) );\n        if(seg.x<t&&seg.y>0.||t<0.&&seg.x>0.){\n            col=   vec3(  0.8, 0., 0. );\n            vec3 pos = ro+ seg.x* rd;\n            vec3 nor = normalize(pos-c);\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            nor = reflect(rd, nor);\n            col*=(.2+key);\n            col += pow(max(dot(light1, nor), 0.0), 25.0)*vec3(.3);\n            hit2=false;\n        }\n        c = vec3(-.32,1.15,-.0);\n        seg = iSphere( ro, rd, vec4(c,0.05) );\n        if(seg.x<t&&seg.y>0.||t<0.&&seg.x>0.){\n            col=   vec3(  0.0, 0., 0.7 );\n            vec3 pos = ro+ seg.x* rd;\n            vec3 nor = normalize(pos-c);\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            nor = reflect(rd, nor);\n            col*=(.2+key);\n            col += pow(max(dot(light1, nor), 0.0), 25.0)*vec3(.3);\n            hit2=false;\n        }\n        \n\n    if( t>0.0&&hit2 )\n\t{\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n       \n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(orb.w*2.0,0.0,1.0), 1.2 );\n\n\t\tvec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n\t\t\t brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n\t\t\t brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n\t\tvec3 rgb = vec3(1.0);\n\t\trgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*orb.y,0.0,1.0) );\n\t\trgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*orb.z,0.0,1.0),8.0) );\n\t\t\n\t\tcol = rgb*brdf*exp(-0.2*t);\n\t}          \n\n        \n   \n\tcol = pow( col, vec3(0.4) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3R4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[325, 348, 378, 378, 433], [434, 434, 456, 456, 505], [507, 535, 561, 561, 665], [667, 704, 757, 757, 943], [945, 991, 1010, 1010, 1355], [1362, 1407, 1443, 1443, 1943], [1946, 2014, 2035, 2035, 2465], [2494, 2494, 2526, 2526, 2939], [2942, 2942, 2999, 2999, 3831], [3834, 3834, 3891, 3891, 7403]], "test": "untested"}
{"id": "XlX3Rn", "name": "Fake Hough Lines", "author": "lamogui", "description": "Having fun with GLSL.\nHere a demo with noise detection (not available on shadertoy):\nhttp://youtu.be/7k4Y19fZoBA", "tags": ["2d", "simple", "sound", "reactive", "music", "lines", "hough"], "likes": 11, "viewed": 800, "published": "Public", "date": "1417560202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash3( vec2 p ) //By iq !\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float l=sqrt(iResolution.x*iResolution.x+iResolution.y*iResolution.y);\n    float eps=2.6;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 3.1415*0.5;\n    uv.y *= 2.0;\n    uv.y -= 1.0;\n    uv.y *= iResolution.y;\n    vec3 color = vec3(0.0,0.0,0.0);\n    const float passes = 256.0;\n    \n    for  (float i=0.0; i<passes; i++) {\n        vec3 rd=hash3(vec2(1.265*i/passes,2.0*i/passes)*26.351);\n        float rd_l=0.1+rd.x;\n        float rd_p=3.1415*(rd.y-0.3*texture(iChannel0,vec2(i/passes,0.0)).x);\n        float rd_speed=0.7+0.1*rd.z;\n        float fy=l*rd_l*cos(uv.x+rd_speed*iTime+rd_p);\n        if (uv.y >= fy - eps && uv.y <= fy + eps) {\n            color += vec3(0.22 - 0.12*abs(uv.y - fy)/eps,0.0,0.0);\n        }\n        if (color.r > .9) {\n            color.g=color.r-.5;\n        }\n        if (color.r > 1.0) color.r=1.0;\n        if (color.g > 1.0) color.g=1.0;\n    }\n    \n\tfragColor = vec4(color.xyz,1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 183], [185, 185, 242, 242, 1166]], "test": "untested"}
{"id": "XsBXRV", "name": "Trace cone with CRT effect", "author": "klk", "description": "raytrace cone, cylinder, sphere, ellips and plane with shadows and reflections\nKeys:\n'A' - dither\n'B' - CRT effect\n'D', 'E' - number of colours if dither is on\n'F' - pixelization\n'G' - antialiasing\n'H' - C64 palette\n'I' - color weights for C64\n", "tags": ["c64", "raytrace", "palette", "cone", "256colors", "vga", "arrows", "nostalgia"], "likes": 39, "viewed": 5096, "published": "Public API", "date": "1418144790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n#define float3x3 mat3\n\nfloat3 campos=float3(-10.0,2.0,0.0);\nfloat3 look_at=float3(0.0,1.0,0.0);\nfloat3 up=float3(0,1,0);\nfloat3 forward;\nfloat3 right;\n\nfloat3 light=float3(0,10,10);\n\nconst float MAX_RAY_LENGTH=10000.0;\n\nfloat fltmod(float x, float m)\n{\n    return fract(x/m)*m;\n}\n\nvoid RP(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n   \n\tuv=float3(u,v,0.0);\n    n=normalize(dett);\n}\n\nvoid RDisk(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n    if((u*u+v*v)>1.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n        \n\tuv=float3(u,v,0);    \n    n=normalize(dett);\n}\n\nvoid RDDisk(float3 tp0, float3 np0, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n    \n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dp1;\n\tfloat3 dp2;\n    np0=normalize(np0);\n\n\tif(abs(np0.x)<abs(np0.y))\n\t\tdp2=float3(1,0,0);\n\telse\n\t\tdp2=float3(0,1,0);\n\t\t\n\tdp1=normalize(cross(dp2,np0))*r;\n\tdp2=normalize(cross(dp1,np0))*r;\n    \n    \n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n    if((u*u+v*v)>1.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n        \n\tuv=float3(u,v,0);    \n    n=normalize(dett);\n    if(dot(n,rd)>0.)\n        n=-n;\n}\n\nvoid RCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)    \n{\n\tfloat3 locX;\n\tfloat3 locY;\n\tfloat3 locZ=-(p1-p0)/(1.0-r1/r0);\n\n    rp0-=p0-locZ;\n\n\tif(abs(locZ.x)<abs(locZ.y))\n\t\tlocX=float3(1,0,0);\n\telse\n\t\tlocX=float3(0,1,0);\n\t\t\n\tfloat len=length(locZ);\n\tlocZ=normalize(locZ)/len;\n\tlocY=normalize(cross(locX,locZ))/r0;\n\tlocX=normalize(cross(locY,locZ))/r0;\n\n\tfloat3x3 tm;\n\ttm[0]=locX;\n\ttm[1]=locY;\n\ttm[2]=locZ;\n\n    rd=rd*tm;\t\n    rp0=rp0*tm;\n    \t\n\tfloat dx=rd.x;\n\tfloat dy=rd.y;\n\tfloat dz=rd.z;\n\n\tfloat x0=rp0.x;\n\tfloat y0=rp0.y;\n\tfloat z0=rp0.z;\n\n\tfloat x02=x0*x0;\n\tfloat y02=y0*y0;\n\tfloat z02=z0*z0;\n\n\tfloat dx2=dx*dx;\n\tfloat dy2=dy*dy;\n\tfloat dz2=dz*dz;\n\n\tfloat det=(\n\t\t-2.0*x0*dx*z0*dz\n        +2.0*x0*dx*y0*dy\n        -2.0*z0*dz*y0*dy\n        +dz2*x02\n        +dz2*y02\n        +dx2*z02\n        +dy2*z02\n        -dy2*x02\n        -dx2*y02\n        );\n    \n\n    if(det<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))/(dx2-dz2+dy2);\n\tfloat t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))/(dx2-dz2+dy2);\n\n\tt=t0;\n\tif(t<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat3 pt=rp0+t*rd;\n\n\tif(pt.z>1.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n        \n    if(pt.z<r1/r0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tn=float3(pt);\n    uv.z=0.0;\n    uv.y=n.z;\n\tn.z=0.0;\n\tn=normalize(n);\n    uv.x=atan(n.x,n.y)/2.0/PI;\n\tn.z=-pt.z/abs(pt.z);\n\tn=normalize(n);\n    n=tm*n;\n    n=normalize(n);\n}\n\nvoid RSph(float3 p0, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 l=p0-rp0;\n\tfloat tc=dot(l,rd);\n\tif(tc<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    };\n\n    float d2=r*r+tc*tc-dot(l,l);\n\n\tif(d2<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    };\n\n\tfloat thc=sqrt(d2);\n    t=tc-thc;\n    float3 p=rp0+rd*t;\n    n=normalize(p-p0);\n    uv.x=atan(n.x,n.z)/2.0/PI;\n    uv.y=asin(n.y)/PI;\n    uv.z=0.0;\n}\n\nvoid RCyl(float3 p0, float3 p1, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat r2=r*r;\n\n\n\tfloat3 dp=p1-p0;\n\tfloat3 dpt=dp/dot(dp,dp);\n\n\tfloat3 ao=rp0-p0;\n\tfloat3 aoxab=cross(ao,dpt);\n\tfloat3 vxab=cross(rd,dpt);\n\tfloat ab2=dot(dpt,dpt);\n\tfloat a=2.0*dot(vxab,vxab);\n\tfloat ra=1.0/a;\n\tfloat b=2.0*dot(vxab,aoxab);\n\tfloat c=dot(aoxab,aoxab)-r2*ab2;\n\n\tfloat det=b*b-2.0*a*c;\n\n\tif(det<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n     }\n\n\n\tdet=sqrt(det);\n\n    float t0=(-b+det)*ra;\n\tfloat t1=(-b-det)*ra;\n\n\tif(t0>t1)\n\t{\n\t\tfloat temp=t1;\n\t\tt1=t0;\n\t\tt0=temp;\n\t}\n\tfloat d=t0;\n\tif(d<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat3 ip=rp0+rd*d;\n\tfloat3 lp=ip-p0;\n\tfloat ct=dot(lp,dpt);\n\tif((ct<0.0)||(ct>1.0))\n\t{\n\t\td=t1;\n\t\tif(d<0.0)\n        {\n            t=MAX_RAY_LENGTH;\n            return;\n        }\n\n\t\tip=rp0+rd*d;\n\t\tfloat3 lp=ip-p0;\n        float ct=dot(lp,dpt);\n\t\tif((ct<0.0)||(ct>1.0))\n        {\n        \tt=MAX_RAY_LENGTH;\n            return;\n        }\n\t}\n\n\tt=d;\n    n=normalize(ip-(p0+dp*ct));\n    uv.y=ct;\n\tuv.x=n.x;\n    uv.z=0.0;\n}\n\nvoid RRCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n float3 l  = p1-p0;\n float ld = length(l);\n l=l/ld;\n float d=r0-r1;\n float sa = d/ld;\n float h0=r0*sa;\n float h1=r1*sa;\n float cr0 = sqrt(r0*r0-h0*h0);\n float cr1 = sqrt(r1*r1-h1*h1);\n float3 coneP0=p0+l*h0;\n float3 coneP1=p1+l*h1;\n    \n    float t0=MAX_RAY_LENGTH;\n    {\n        float t1;\n        float3 uv1;\n        float3 n1;\n\t    RCone(coneP0,cr0,coneP1,cr1,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n\t    RSph(p0,r0,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n\t    RSph(p1,r1,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n    }\n    t=t0;\n    \n}\n\nfloat3x3 Transpose(in float3x3 m)\n{\n\tfloat3 i0 = m[0];\n\tfloat3 i1 = m[1];\n\tfloat3 i2 = m[2];\n\tfloat3x3 o=float3x3(\n                 float3(i0.x, i1.x, i2.x),\n                 float3(i0.y, i1.y, i2.y),\n                 float3(i0.z, i1.z, i2.z)\n                 );\n\treturn o;\n}\nvoid REll(float3 p0, float3 r0, float3 r1, float3 r2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n    float3 irp0=rp0-p0;\n//\tfloat3 ir0=r0;\n//\tfloat3 ir1=r1;\n//\tfloat3 ir2=r2;\n\n    float3 ir0=r0/dot(r0,r0);\n\tfloat3 ir1=r1/dot(r1,r1);\n\tfloat3 ir2=r2/dot(r2,r2);\n//\tr0=normalize(r0)/length(r0);\n//\tr1=normalize(r1)/length(r1);\n//\tr2=normalize(r2)/length(r2);\n\n\tfloat3x3 tm;\n\ttm[0]=ir0;\n\ttm[1]=ir1;\n\ttm[2]=ir2;\n\n//    tm=Transpose(tm);\n    \n    float3 ird=rd*tm;\t\n    irp0=irp0*tm;\t\n    float t1=MAX_RAY_LENGTH;\n    float3 uv1;\n    float3 n1;\n    float lr=length(ird);\n    ird=normalize(ird);\n    RSph(float3(0.0,0.0,0.0),1.0,irp0,ird,t1,uv1,n1);\n    n=normalize(tm*n1);\n    t=t1/lr;\n    uv=uv1;\n}\n\nvoid trace(float3 rp0, float3 rd, out float t, out float3 col, out float3 n)\n{\n    float t1=MAX_RAY_LENGTH;\n    float3 col1;\n    float3 n1;\n\n    {\n    \tRP(float3(0.0,-1.0,0.0),float3(-1.0,0.0,0.0),float3(0.0,0,1.0),rp0, rd, t1, col1, n1);\n        float3 p=rp0+rd*t1;\n    \tcol1=float3(floor(fltmod(floor(p.z), 2.0)));\n        if(fltmod(floor(p.x),2.0)==0.0)\n        {\n            p/=2.0;\n    \t\tcol1=float3(floor(fltmod(floor(p.x+p.z+0.25)+floor(p.z-p.x+0.25), 2.0)));\n        }\n            \n    }\n\n    t=t1;\n    col=col1;\n    n=n1;\n\n\n    float3 coneP0=float3(-3.0,0.0,1.0);\n    float3 coneP1=float3(-3.5,1.0,2.0);\n    float coneR0=1.5;\n    float coneR1=0.5;\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RCone(coneP0,coneR0,coneP1,coneR1,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            float x=mod(floor(col1.x*8.0)+floor(col1.y*4.0),2.0);\n            col=float3(x,x,x);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t2=MAX_RAY_LENGTH;\n        float3 col2;\n        float3 n2;\n//\t    RSph(float3(-1.0,1.0,sin(iTime)*4.0),1.0,rp0,rd,t1,col1,n1);\n        REll(\n            //float3(-1.0,1.0,sin(iTime)*4.0),\n            float3(0.0,3.0,0.0),\n             float3(1.0,0.0,0.0),\n             float3(0.0,2.0,0.0),\n             float3(0.0,0.0,1.0),\n             rp0,rd,t2,col2,n2);\n        if(t2<t)\n        {\n            float x=mod(floor(col2.x*8.0)+floor(col2.y*4.0),2.0);\n            col=float3(x,x,x);\n            t=t2;\n            n=n2;\n        }\n    }\n    \n//return;\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDDisk(coneP0,coneP1-coneP0,coneR0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDDisk(coneP1,coneP0-coneP1,coneR1,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    \n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RSph(float3(1.0,3.0,3.0),0.4,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.0,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDisk(float3(0.0,0.0,1.0),float3(0.0,-1.0,0.0),float3(1.0,0.0,0.0),rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RCyl(float3(0.0,0.0,1.0),float3(0.0,0.0,-1.0),1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RRCone(float3(3.0,0.0,2.0),1.0,float3(3.0,0.0,1.0),0.5,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(0.0,1.0,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RSph(float3(0.0,0.0,-1.0),1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n}\n\n\nvoid lit(in float3 p, in float3 rd, in float3 n, in float3 icol, out float3 col)\n{\n    float3 tolight=normalize(light-p);\n\n    float diffuse=clamp(dot(tolight,n),0.0,1.0);\n    \n    float3 halfNormal=normalize(tolight-rd);\n\n    float3 nr=n*dot(n,-rd);\n    float3 refl=normalize(-rd+(nr+rd)*2.0);\n    \n    float fresnel=(1.0-dot(-rd,n));\n    float RF=0.2;\n    fresnel=RF+(1.0-RF)*pow(1.0-dot(-rd,n),5.0);\n    diffuse*=1.0-fresnel;\n    \n    float spec1=clamp(dot(n,halfNormal),0.0,1.0);\n    float spec2=clamp(dot(tolight,refl),0.0,1.0);\n    \n    spec1=pow(spec1,20.0);\n    spec2=pow(spec2,120.0)*2.0;\n    float spec=spec1+spec2;\n    \n    diffuse=pow(diffuse,1.5);\n\n    float shadow=1.0;\n    float t1=MAX_RAY_LENGTH;\n    float3 cols;\n    float3 ns;\n    trace(p+tolight*0.01,tolight,t1,cols,ns);\n    if(t1<1000.0)\n    {\n       shadow=0.0;\n       spec=0.0;\n    }\n    diffuse*=shadow;\n    \n    col=icol;\n    \n    col*=(0.2+diffuse*0.8);\n    col=clamp(col+(0.5+col*0.5)*spec1*(0.2+fresnel),0.0,10.0);\n    col+=float3(1.0,1.0,1.0)*clamp(spec2*diffuse*(1.0+fresnel),0.0,10.0);\n}\n\nvoid shade(float3 rp0, float3 rd, out float t, out float3 col, out float3 n)\n{\n    trace(rp0,rd,t,col,n);\n//\tcol=n*0.5+0.5;\n    float3 tolight=normalize(light-(rp0+rd*t));\n    float diffuse=clamp(dot(tolight,n),0.0,1.0);\n    \n    float3 halfNormal=normalize(tolight-rd);\n\n    float3 nr=n*dot(n,-rd);\n    float3 refl=normalize(-rd+(nr+rd)*2.0);\n    \n    float fresnel=(1.0-dot(-rd,n));\n    float RF=0.2;\n    fresnel=RF+(1.0-RF)*pow(1.0-dot(-rd,n),5.0);\n    diffuse*=1.0-fresnel;\n    \n    float spec1=clamp(dot(n,halfNormal),0.0,1.0);\n    float spec2=clamp(dot(tolight,refl),0.0,1.0);\n    \n    spec1=pow(spec1,20.0);\n    spec2=pow(spec2,120.0)*2.0;\n    float spec=spec1+spec2;\n//\tspec=spec*1.2;\n    float3 pos;\n//    pos=n;col=fract(pos*0.5+0.5);\n//    pos=rp0+rd*t;col=fract(pos*4.0);\n//    return;\n    \n\tfloat shadow=1.0;\n//    if(false)\n    {\n\t    float t1=MAX_RAY_LENGTH;\n    \tfloat3 col1;\n    \tfloat3 n1;\n        float3 pos=rp0+t*rd+n*0.001;\n        trace(pos,normalize(light-pos), t1, col1, n1);\n        if(t1<MAX_RAY_LENGTH)\n        {\n            shadow=0.0;\n            spec=0.0;\n        }\n    }\n    spec1*=shadow;\n    spec2*=shadow;\n    diffuse=pow(diffuse,1.5);\n    diffuse*=shadow;\n    col*=(0.2+diffuse*0.8);\n//\treturn;\n//    if(false)\n    {\n        \n\t    float t1=MAX_RAY_LENGTH;\n    \tfloat3 col1;\n    \tfloat3 n1;\n        float3 pos=rp0+t*rd+n*0.001;\n        trace(pos,refl, t1, col1, n1);\n        float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-refl.y)*(1.0-refl.y));\n        float fogf=clamp(1.8/(exp(t1*0.25)),0.0,1.0);\n        float3 col2=col1;\n        lit(pos+refl*t1, refl, n1, col2, col1);\n    \tcol1=mix(fogcol,col1,fogf);\n\t    \n        \n//        if(t1<MAX_RAY_LENGTH)\n        {\n//            col+=(col*0.5+0.5)*col1/exp(t1*0.05)*clamp(dot(tolight,n1),0.0,1.0)*fresnel;\n            col+=col1*(0.3+fresnel*0.7);\n        }\n    }\n\n    col=clamp(col+(0.5+col*0.5)*spec1*(0.2+fresnel),0.0,10.0);\n    col+=float3(1.0,1.0,1.0)*clamp(spec2*diffuse*(1.0+fresnel),0.0,10.0);\n\n    float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-rd.y)*(1.0-rd.y));\n    float sun=clamp(dot(normalize(light-rp0),rd),0.0,1.0);\n    fogcol+=\n        pow(sun,1200.0)*float3(1.0,0.7,0.3)*0.5\n        +pow(sun,5.0)*float3(1.0,0.7,0.5)*0.15;\n    col=mix(fogcol,col,clamp(1.8/(exp(t*0.025)),0.0,1.0));\n    \n    \n//    col*=(0.5+shadow*0.5);\n}\n\nfloat scurve(float x)\n{\n    return (3.0-2.0*x)*x*x;\n}\n\nfloat tooth(float x)\n{\n    x=fract(x);\n    x=abs(x-0.5)*2.0;\n    x=scurve(x);\n    return x;\n}\n\nvec4 crt(vec2 pos)\n{\n   float l=0.5+tooth(pos.y/3.0+0.5)*0.75;\n   float dx=tooth(pos.y/3.0*1.6+1.0/4.0);\n   vec3 rgb=vec3(\n    tooth(pos.x/3.0*1.6+dx        ),\n    tooth(pos.x/3.0*1.6+dx+1.0/3.0),\n    tooth(pos.x/3.0*1.6+dx+2.0/3.0)\n    )*0.8+0.6;\n   return vec4(rgb*l, 1.0);\n}\n/*\nint dp(int i)\n{\n    if(i==0)\n        return 0;\n    else if(i==1)\n        return 2;\n    else if(i==2)\n        return 3;\n    else if(i==3)\n        return 1;\n    else return 0;\n}\n\n\nfloat dith(float2 xy)\n{\n    int x=int(floor(xy.x));\n    int y=int(floor(xy.y));\n    int v=0;\n    int sz=8;\n    int mul=1;\n    for(int i=0;i<4;i++)\n    {\n    \tv+=dp(((x/sz)%2+2*((y/sz)%2))%4)*mul;\n        sz/=2;\n        mul*=4;\n    }\n\treturn float(v)/float(mul-1);\n}\n\n*/\n\n\nfloat dp(float i)\n{ \n    i=floor(i);\n    return i*2.0-floor(i/2.0)-floor(i/3.0)*4.0;\n}\n\n\nfloat dith(float2 xy)\n{\n    float iTime=0.0;\n    float x=floor(xy.x+iTime*16.0*64.0*60.0);\n    float y=floor(xy.y+iTime*16.0*16.0*60.0);\n    float v=0.0;\n    float sz=16.0;\n    float mul=1.0;\n    for(int i=0;i<5;i++)\n    {\n    \t\tv+=dp(\n                fltmod(fltmod(x/sz,2.0)+2.0*fltmod(y/sz,2.0),4.0)\n            )*mul;\n        sz/=2.0;\n        mul*=4.0;\n    }\n\treturn float(v)/float(mul-1.0);\n}\n\nbool keyPressed(int key)\n{\n\treturn texture(iChannel2,float2((float(key)+0.5)/256.0,0.25)).x>0.0;\n}\n\nbool keyToggled(int key)\n{\n\treturn texture(iChannel2,float2((float(key)+0.5)/256.0,0.75)).x>0.0;\n}\n\nfloat3 c64col(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(  1.0,   1.0,   1.0);\n    else if (c ==  2)col = float3(103.7,  55.4,  43.0)/255.0;\n    else if (c ==  3)col = float3(111.9, 163.5, 177.9)/255.0;\n    else if (c ==  4)col = float3(111.4,  60.7, 133.6)/255.0;\n    else if (c ==  5)col = float3( 88.1, 140.6,  67.1)/255.0;\n    else if (c ==  6)col = float3( 52.8,  40.3, 121.4)/255.0;\n    else if (c ==  7)col = float3(183.9, 198.7, 110.6)/255.0;\n    else if (c ==  8)col = float3(111.4,  79.2,  37.2)/255.0;\n    else if (c ==  9)col = float3( 66.9,  57.4,   0.0)/255.0;\n    else if (c == 10)col = float3(153.7, 102.6,  89.1)/255.0;\n    else if (c == 11)col = float3( 67.9,  67.9,  67.9)/255.0;\n    else if (c == 12)col = float3(107.8, 107.8, 107.8)/255.0;\n    else if (c == 13)col = float3(154.2, 209.8, 131.6)/255.0;\n    else if (c == 14)col = float3(107.8,  94.1, 180.9)/255.0;\n    else             col = float3(149.5, 149.5, 149.5)/255.0;\n    return col;\n}\n\n/*\nfloat3 db16col(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if     (c== 0)col=float3(20.0, 12.0, 28.0)/255.0;\n    else if(c== 1)col=float3(68.0, 36.0, 52.0)/255.0;\n    else if(c== 2)col=float3(48.0, 52.0, 109.0)/255.0;\n    else if(c== 3)col=float3(78.0, 74.0, 78.0)/255.0;\n    else if(c== 4)col=float3(133.0, 76.0, 48.0)/255.0;\n    else if(c== 5)col=float3(52.0, 101.0, 36.0)/255.0;\n    else if(c== 6)col=float3(208.0, 70.0, 72.0)/255.0;\n    else if(c== 7)col=float3(117.0, 113.0, 97.0)/255.0;\n    else if(c== 8)col=float3(89.0, 125.0, 206.0)/255.0;\n    else if(c== 9)col=float3(210.0, 125.0, 44.0)/255.0;\n    else if(c==10)col=float3(133.0, 149.0, 161.0)/255.0;\n    else if(c==11)col=float3(109.0, 170.0, 44.0)/255.0;\n    else if(c==12)col=float3(210.0, 170.0, 153.0)/255.0;\n    else if(c==13)col=float3(109.0, 194.0, 202.0)/255.0;\n    else if(c==14)col=float3(218.0, 212.0, 94.0)/255.0;\n    else          col=float3(222.0, 238.0, 214.0)/255.0; \n    return col;\n}\n*/\n\nfloat3 db32col0(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if     (c== 0)col=float3(0.0, 0.0, 0.0)/255.0;\n    else if(c== 1)col=float3(34.0, 32.0, 52.0)/255.0;\n    else if(c== 2)col=float3(69.0, 40.0, 60.0)/255.0;\n    else if(c== 3)col=float3(102.0, 57.0, 49.0)/255.0;\n    else if(c== 4)col=float3(143.0, 86.0, 59.0)/255.0;\n    else if(c== 5)col=float3(223.0, 113.0, 38.0)/255.0;\n    else if(c== 6)col=float3(217.0, 160.0, 102.0)/255.0;\n    else if(c== 7)col=float3(238.0, 195.0, 154.0)/255.0;\n    else if(c== 8)col=float3(251.0, 242.0, 54.0)/255.0;\n    else if(c== 9)col=float3(153.0, 229.0, 80.0)/255.0;\n    else if(c==10)col=float3(106.0, 190.0, 48.0)/255.0;\n    else if(c==11)col=float3(55.0, 148.0, 110.0)/255.0;\n    else if(c==12)col=float3(75.0, 105.0, 47.0)/255.0;\n    else if(c==13)col=float3(82.0, 75.0, 36.0)/255.0;\n    else if(c==14)col=float3(50.0, 60.0, 57.0)/255.0;\n    else          col=float3(63.0, 63.0, 116.0)/255.0;\n    return col;\n}\n\nfloat3 db32col1(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if     (c==16)col=float3(48.0, 96.0, 130.0)/255.0;\n    else if(c==17)col=float3(91.0, 110.0, 225.0)/255.0;\n    else if(c==18)col=float3(99.0, 155.0, 255.0)/255.0;\n    else if(c==19)col=float3(95.0, 205.0, 228.0)/255.0;\n    else if(c==20)col=float3(203.0, 219.0, 252.0)/255.0;\n    else if(c==21)col=float3(255.0, 255.0, 255.0)/255.0;\n    else if(c==22)col=float3(155.0, 173.0, 183.0)/255.0;\n    else if(c==23)col=float3(132.0, 126.0, 135.0)/255.0;\n    else if(c==24)col=float3(105.0, 106.0, 106.0)/255.0;\n    else if(c==25)col=float3(89.0, 86.0, 82.0)/255.0;\n    else if(c==26)col=float3(118.0, 66.0, 138.0)/255.0;\n    else if(c==27)col=float3(172.0, 50.0, 50.0)/255.0;\n    else if(c==28)col=float3(217.0, 87.0, 99.0)/255.0;\n    else if(c==29)col=float3(215.0, 123.0, 186.0)/255.0;\n    else if(c==30)col=float3(143.0, 151.0, 74.0)/255.0;\n    else          col=float3(138.0, 111.0, 48.0)/255.0;\n    return col;\n}\n\nfloat3 db32col(int c)\n{\n    if(c<16)\n        return db32col0(c);\n   \telse\n        return db32col1(c);\n}\n\n\nfloat3 cgacol(int c)    \n{\n    float3 col;\n/*\n    col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  1)col = float3(  1.0,   1.0,   1.0);\n    return col;\n\n  col = float3(  0.0,   0.0,   0.5);\n    if      (c ==  1)col = float3(  0.0,   0.5,   0.25);\n    else if (c ==  2)col = float3(  1.0,  0.65,  0.0);\n    else if (c ==  3)col = float3(  1.0,   0.85,   0.85);\n    return col;\n*/\n    col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  1)col = float3(  0.0,   1.0,   1.0);\n    else if (c ==  2)col = float3(  1.0,   0.0,   1.0);\n    else if (c ==  3)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}  \n\nfloat3 simple8col(int c)    \n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(  0.0,   0.0,   1.0);\n    else if (c ==  2)col = float3(  0.0,   1.0,   0.0);\n    else if (c ==  3)col = float3(  0.0,   1.0,   1.0);\n    else if (c ==  4)col = float3(  1.0,   0.0,   0.0);\n    else if (c ==  5)col = float3(  1.0,   0.0,   1.0);\n    else if (c ==  6)col = float3(  1.0,   1.0,   0.0);\n    else if (c ==  7)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}\nfloat3 egacol(int c)    \n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(170.0,   0.0,   0.0);\n    else if (c ==  2)col = float3(  0.0, 170.0,   0.0)/255.0;\n    else if (c ==  3)col = float3(170.0,  85.0,   0.0)/255.0;\n    else if (c ==  4)col = float3(  0.0,   0.0, 170.0)/255.0;\n    else if (c ==  5)col = float3(170.0,   0.0, 170.0)/255.0;\n    else if (c ==  6)col = float3(  0.0, 170.0, 170.0)/255.0;\n    else if (c ==  7)col = float3(170.0, 170.0, 170.0)/255.0;\n    else if (c ==  8)col = float3( 85.0,  85.0,  85.0)/255.0;\n    else if (c ==  9)col = float3(255.0,  85.0,  85.0)/255.0;\n    else if (c == 10)col = float3( 85.0, 255.0,  85.0)/255.0;\n    else if (c == 11)col = float3(255.0, 255.0,  85.0)/255.0;\n    else if (c == 12)col = float3( 85.0,  85.0, 255.0)/255.0;\n    else if (c == 13)col = float3(255.0,  85.0, 255.0)/255.0;\n    else if (c == 14)col = float3( 85.0, 255.0, 255.0)/255.0;\n    else             col = float3(255.0, 255.0, 255.0)/255.0;\n    return col;\n}\n\nfloat3 cubecol(int c)    \n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0)/4.0;\n    else if (c ==  1)col = float3(  0.0,   0.0,   4.0)/4.0;\n    else if (c ==  2)col = float3(  0.0,   4.0,   0.0)/4.0;\n    else if (c ==  3)col = float3(  0.0,   4.0,   4.0)/4.0;\n    else if (c ==  4)col = float3(  4.0,   0.0,   0.0)/4.0;\n    else if (c ==  5)col = float3(  4.0,   0.0,   4.0)/4.0;\n    else if (c ==  6)col = float3(  4.0,   4.0,   0.0)/4.0;\n    else if (c ==  7)col = float3(  4.0,   4.0,   4.0)/4.0;\n    else if (c ==  8)col = float3(  2.0,   2.0,   0.0)/4.0;\n    else if (c ==  9)col = float3(  2.0,   0.0,   2.0)/4.0;\n    else if (c == 10)col = float3(  0.0,   2.0,   2.0)/4.0;\n    else if (c == 11)col = float3(  2.0,   2.0,   4.0)/4.0;\n    else if (c == 12)col = float3(  2.0,   4.0,   2.0)/4.0;\n    else if (c == 13)col = float3(  4.0,   2.0,   2.0)/4.0;\n    else if (c == 14)col = float3(  1.0,   1.0,   1.0)/4.0;\n    else             col = float3(  3.0,   3.0,   3.0)/4.0;\n    return col;\n}\n\n\nfloat3 amiga4col(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.4,   1.0);\n    else if (c ==  1)col = float3(  1.0,   0.6,   0.0);\n    else if (c ==  2)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}\n\nfloat3 palette(int c)\n{\n    if(keyToggled(KEY_J))\n    \treturn simple8col(c);\n    else if(keyToggled(KEY_K))\n    \treturn egacol(c);\n    else if(keyToggled(KEY_L))\n    \treturn cgacol(c);\n    else if(keyToggled(KEY_U))\n    \treturn amiga4col(c);\n//\telse if(keyToggled(KEY_Q))\n//    \treturn db16col(c);\n    else if(keyToggled(KEY_T))\n    \treturn db32col(c);\n    return c64col(c);\n    return amiga4col(c);\n}\n\nfloat3 nearestcol(float3 col)\n{\n    const float3 W=float3(0.299,0.587,0.114);\n//    const float3 W=float3(0.21,0.72,0.07);\n    float3 res;\n    float rv=100.0;\n    float luma0=dot(col,W);\n    for(int i=0;i<32;i++)\n    {\n        float3 icol=palette(i);\n        float3 dist=col-icol;\n//        dist*=dist;\n\t\tif(keyToggled(KEY_I))\n        \tdist*=W;\n        \n        float d=dot(dist,dist);\n        float luma=luma0-dot(icol,W);\n\t\tif(keyToggled(KEY_O))\n\t        d=d*0.75+luma*luma*0.25;\n        if(d<rv)\n        {\n            res=icol;\n            rv=d;\n        }\n    }\n    return res;\n}\n\n\nfloat3 pixelRay(float2 uv)\n{\n    if(!keyToggled(KEY_R))\n    {\n\t\tuv*=0.75;\n\t  \treturn normalize(forward+up*uv.y+right*uv.x);\n    }\n    else\n    {\n\t\tuv*=0.65;\n        if(dot(uv,uv)>1.0)\n            return float3(0.0);\n        \n        float z=sqrt(1.0-uv.x*uv.x-uv.y*uv.y)*1.95-0.95;\n        float3 uvz=float3(uv,z);\n        uvz=normalize(uvz);\n        return normalize(forward*uvz.z+up*uvz.y+right*uvz.x);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T=iTime*0.45;\n    \n    light.x=cos(T)*10.0;\n    light.z=sin(T)*10.0;\n    light.y=5.0;\n    \n    float mposx=iMouse.x;\n    float mposy=iMouse.y;\n    if(iMouse.z<0.0)mposx=-iMouse.z;\n    if(iMouse.w<0.0)mposy=-iMouse.w;\n    \n    float a1=-(mposy/iResolution.y)*PI/2.1+0.1;\n    float a2=mposx/iResolution.x*PI*2.0-0.3;\n    campos.y=sin(a1)*campos.x;\n    float camx=cos(a1)*6.0;\n    campos.x=cos(a2)*camx;\n    campos.z=sin(a2)*camx;\n    campos+=look_at;\n    \n    forward=normalize(look_at-campos);\n    right=normalize(cross(up,forward));\n    up=normalize(cross(forward,right));\n    \n\tfloat2 scr = fragCoord.xy /iResolution.xy;\n//    scr.x+=sin(iTime*140.0+scr.y*0.1)*0.001;\n    scr=2.0*scr-1.0;\n//    scr.x*=(iResolution.x/iResolution.y);\n    \n    float2 dscr;\n    dscr=floor(scr*iResolution.xy/6.0)*6.0;\n    if(keyToggled(KEY_F))\n        dscr=scr*iResolution.xy;\n\n    scr=dscr/iResolution.xy;\n    float2 scruv=scr;\n    \n    float2 scr2ray=scruv;\n    float ratio=(iResolution.x/iResolution.y);\n    scr2ray.x*=ratio;\n\n    float3 ray=pixelRay(scr2ray);\n\n    float3 col=float3(0.0,0.0,0.0);\n    float3 n;\n\n    \n//    shade(campos, ray, t, col, n);\n    float w=0.0;\n    float3 col1;\n    const float nx=3.0;\n    const float ny=2.0;\n    \n    if(keyToggled(KEY_G))\n    {\n\t    float t=MAX_RAY_LENGTH;\n    \tshade(campos, pixelRay(scr2ray), t, col, n);\n        w=1.0;\n    }\n\telse        \n\tfor(float i=0.0;i<ny;i+=1.001)\n    {\n\t\tfor(float j=0.0;j<nx;j+=1.001)\n        {\n\t\t    float t=MAX_RAY_LENGTH;\n\t    \tshade(campos, pixelRay(scr2ray\n                                   +3.0*float2((j*1.0/(nx+0.0))/iResolution.y,\n                                               (i*1.0/(ny+0.0))/iResolution.y)), t, col1, n);\n            w=w+1.0;\n            col+=col1;\n        }\n    }\n  \tcol=col/w;\n\n    \n    float3 suncol=float3(0.0,0.0,0.0);\n    float sunvis=0.0;\n    for(int i=-4;i<5;i++)\n    {\n        float t;\n        float3 col1;\n        float3 n; \n    \ttrace(campos,normalize(light-campos+0.05*right*(float(i))),t,col1,n);\n        if(t==MAX_RAY_LENGTH)\n        {\n\t\t\tfloat sun=clamp(dot(normalize(light-campos),pixelRay(scr2ray)),0.0,1.0);\n\t\t\tsuncol+=pow(sun,25.0)*float3(1.0,0.7,0.5)*0.1;\n            sunvis+=1.0;\n        }\n            \n    }\n    for(int i=-3;i<3;i++)\n    {\n        float t;\n        float3 col1;\n        float3 n;\n        float3 tolight=normalize(light-campos);\n        float3 tolight0=tolight;\n        \n        tolight=normalize(forward+(-up*dot(up,tolight)-right*dot(right,tolight)*ratio)*(1.0+float(i)*0.15));\n//        tolight=normalize(forward-(tolight-forward));\n    \ttrace(campos,tolight0,t,col1,n);\n        if(t==MAX_RAY_LENGTH)\n        {\n\t\t\tfloat sun=clamp(dot(tolight,pixelRay(scr2ray)),0.0,1.0);\n\t\t\tsuncol+=clamp(pow(sun,350.0-float(i)*30.0),0.0,0.25)*float3(1.0,0.7,0.5);\n        }\n            \n    }\n\tcol=col*(1.0-sunvis/25.0)+suncol;\n    \n  \n    col=col-0.25*dot(scruv.xy*abs(scruv.xy),scruv.xy);\n\n    \n    \n    \n//    fragColor = float4(col,1.0);return;\n\tif(keyToggled(KEY_Z))\n    {\n        vec2 uv = (fragCoord.xy-iMouse.xy) / max(iResolution.x,iResolution.y)*4.0-0.5;\n        float t=iTime;\n        float r=length(uv)-t;\n        float a=atan(uv.x,uv.y)/PI/2.0+sin(r+t)*0.1;\n\n        col.r+=(0.5+0.5*sin(r*2.915+150.0))+(0.5+0.5*sin(-r*3.915+150.0));\n        col.g+=(0.5+0.5*sin(r*2.533- 11.0))+(0.5+0.5*sin(-r*3.213+ 57.0));\n        col.b+=(0.5+0.5*sin(r*2.107      ))+(0.5+0.5*sin(-r*3.515+150.0));\n        col.r+=(0.5+0.5*sin(r*6.315+150.0))+(0.5+0.5*sin(-r*7.915+ 50.0));\n        col.g+=(0.5+0.5*sin(r*6.533- 11.0))+(0.5+0.5*sin(-r*7.213+ 77.0));\n        col.b+=(0.5+0.5*sin(r*6.107      ))+(0.5+0.5*sin(-r*7.515+150.0));\n        col*=0.25;\n    }\n    \n\n    \n\n//    float2 dscr=floor((fragCoord.xy)/3.0)*3.0;\n    float vd=dith(fragCoord.xy)-0.5;\n    vd=(dith(dscr/2.0)-0.5);\n//    vd=dith(scr*iResolution.xy/2.0    )-0.5;\n    \n    \n    float lvlsR=0.0;//floor(mposx/4.0)+1.0;\n    if(keyToggled(KEY_C))\n        lvlsR+=0.5;\n    if(keyToggled(KEY_D))\n        lvlsR+=0.25;\n    if(keyToggled(KEY_E))\n        lvlsR+=0.125;\n//    if(fragCoord.x<iMouse.x)\n    if(keyToggled(KEY_A))\n    {\n        if(keyToggled(KEY_H))\n        {\n\t        if(keyToggled(KEY_M))\n    \t        vd*=1.5;\n            col=float3(col.x+vd*(lvlsR),col.y+vd*(lvlsR),col.z+vd*(lvlsR));\n            col=nearestcol(col);\n\t\t    if(fragCoord.y<25.0)\n\t\t        col=palette(int(fragCoord.x/iResolution.x*32.0));\n        }\n        else\n        {\n            col=float3(\n                floor(col.x+vd*lvlsR+0.5),\n                floor(col.y+vd*lvlsR+0.5),\n                floor(col.z+vd*lvlsR+0.5)\n            );\n        }\n    }\n    fragColor = float4(col,1.0);\n    if(keyToggled(KEY_B))\n\t    fragColor = clamp(fragColor,0.0,1.0)*crt(fragCoord.xy);\n}\n\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[940, 940, 972, 972, 999], [1001, 1001, 1111, 1111, 1436], [1438, 1438, 1551, 1551, 1959], [1961, 1961, 2072, 2072, 2727], [2729, 2729, 2852, 2852, 4239], [4241, 4241, 4337, 4337, 4697], [4699, 4699, 4806, 4806, 5782], [5784, 5784, 5904, 5904, 6663], [6665, 6665, 6700, 6700, 6940], [6941, 6941, 7061, 7061, 7658], [7660, 7660, 7738, 7738, 10991], [10994, 10994, 11076, 11076, 12062], [12064, 12064, 12142, 12142, 14429], [14431, 14431, 14454, 14454, 14484], [14486, 14486, 14508, 14508, 14579], [14581, 14581, 14601, 14601, 14858], [14859, 15312, 15331, 15331, 15398], [15401, 15401, 15424, 15424, 15797], [15799, 15799, 15825, 15825, 15897], [15899, 15899, 15925, 15925, 15997], [15999, 15999, 16021, 16021, 17065], [17067, 18053, 18077, 18077, 19022], [19024, 19024, 19048, 19048, 20009], [20011, 20011, 20034, 20034, 20114], [20117, 20117, 20143, 20143, 20725], [20729, 20729, 20759, 20759, 21271], [21272, 21272, 21298, 21298, 22342], [22344, 22344, 22371, 22371, 23395], [23398, 23398, 23423, 23423, 23655], [23657, 23657, 23680, 23680, 24058], [24060, 24060, 24091, 24091, 24642], [24645, 24645, 24673, 24673, 25057], [25061, 25061, 25118, 25118, 29847]], "test": "untested"}
{"id": "XsjSR3", "name": "penis", "author": "Teflo", "description": "penis", "tags": ["penis"], "likes": 1, "viewed": 354, "published": "Public", "date": "1417712289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(in vec2 p)\n{\n\treturn sin(p.x * 1.5) * sin(p.y * 1.5);   \n}\n\nfloat fbm(in vec2 p)\n{\n\tfloat f = 0.0;\n    float factor = 2.5;\n    float factor2 = 0.5;\n    for(int i = 0; i < 6; ++i)\n    {\n        f += factor2 * noise(p * factor);\n        factor2 *= 0.54;\n        factor *= 2.0;\n    }\n    return f;\n}\n\nfloat pattern(in vec2 p)\n{\n    p *= 0.5;\n    float rad = fbm(p);\n    rad = mix(0.2, 0.8, rad);\n\tp.x += sin(iTime*rad * 0.1) * 0.02 * rad;\n    p.y += cos(iTime*rad * 0.1) * 0.02 * rad;\n    \n    vec2 q;\n    q.x = fbm(p);\n    q.y = fbm(p*2.0);\n    \n    q.x += sin(iTime*rad*0.6) * 0.03 * rad;\n    q.y += cos(iTime*rad*0.6) * 0.02 * rad;\n    \n    vec2 r;\n    r.x = fbm(q);\n    r.y = fbm(q*2.0);\n    \n    float f = fbm(r);\n    \n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float f = pattern(p);\n    fragColor = vec4(f, f, f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 70], [72, 72, 94, 94, 308], [310, 310, 336, 336, 748], [751, 751, 808, 808, 913]], "test": "untested"}
{"id": "XtfGRr", "name": "Janis Mateuss", "author": "jajanka3", "description": "Homework", "tags": ["shader"], "likes": 1, "viewed": 122, "published": "Public", "date": "1417627333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n vec2 position = (fragCoord.xy/iResolution.xy) - 0.5;\n    float time = iTime;\n    \n    //nodrosina beatu\n    float beat = texture( iChannel1, vec2(0.0, 0.01 ) ).x;\n \n    //cilpa pa y asi\n    float y = 2. * position.y * sin(400.0 * position.y - 20.0 * time *0.01);\n y = 1. / (1000. * abs(position.x - y));\n \n    //cilpa pa x asi\n float x = 2. * position.x * sin(500.0 * position.x - 20.0 * time *0.01);\n    x = 1. / (1000. * abs(position.y - x));\n    \n    //spiideklis viduu\n    float saule = 5./length(50. / beat*length(position - vec2(0, 0)));\n\n \t//saules atrashanaas vieta.\n    vec4 vsaule = vec4(saule, saule*2., saule, 1.0);\n vec4 vstari = vec4((position.y+position.x)*0.5 - y, (y+x)*7., y+x, 1.0);\n    \n    //realizaacija\n    fragColor = mix(vsaule, vstari, 0.5)-0.3; //-0.3 ir spiidekla spozums jeyyb mirdzums\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 875]], "test": "untested"}
{"id": "Xtl3zn", "name": "Spacebubbles", "author": "srtuss", "description": "Little shader art.", "tags": ["art"], "likes": 12, "viewed": 758, "published": "Public API", "date": "1417996031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// srtuss, 2014\n\nfloat strs(vec3 p)\n{\n\tvec3 pos = p;\n\tp += vec3(1.35, 1.54, 1.23);\n\tp *= .3;\n\tfor(int i = 0; i < 18; i++)\n    {\n\t\tp.xyz = abs(p.xyz);\n\t\tp = p / dot(p,p);\n\t\tp = p * 1. - vec3(.9);\n\t}\n\treturn pow(length(p),1.5)*.04;\n}\n\nfloat hash(float p)\n{\n    return fract(sin(p * 11.111111) * 91962.592632);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(p.x + p.y * 3.3333333) * 91962.592632);\n}\n\nfloat nse(float p)\n{\n    float fl = floor(p);\n    p = fract(p);\n    p = p * p * (3.0 - 2.0 * p);\n    return mix(hash(fl), hash(fl + 1.0), p);\n}\n\nfloat nse(vec2 p)\n{\n    vec2 fl = floor(p);\n    p = fract(p);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    return mix(\n        mix(hash(fl), hash(fl + vec2(1.0, 0.0)), p.x),\n       \tmix(hash(fl + vec2(0.0, 1.0)), hash(fl + vec2(1.0, 1.0)), p.x),\n           p.y);\n}\n\nfloat fbm(vec2 p)\n{\n    return nse(p * 0.5) * 0.4 + nse(p) * 0.5 + nse(p * 2.0 - 3.3333) * 0.25 + nse(p * 4.01 + 3.3333) * 0.125;\n}\n\nfloat fbm2(vec2 p)\n{\n    return nse(p) * 0.5 + nse(p * 2.0 - 3.3333) * 0.25 + nse(p * 4.01 + 3.3333) * 0.125 + nse(p * 10.01) * 0.09;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv *= 1.5 - exp(iTime * -0.01) * 0.5;\n    \n    float sd = iTime;//fragCoord.x * 7.0 + fragCoord.y * 1.11111;\n    uv += (fract(vec2(cos(sd), sin(sd)) * 192925.1972) - 0.5) * 0.01 * exp(iTime * -0.04);\n    \n    float v = 0.0;\n    \n    float sf = strs(vec3(uv * 0.1, 0.0));\n    \n    vec2 p = vec2(uv.yx + sf * 0.13);\n    vec2 c = vec2(0.1, 0.7);\n    float fo = 20.0, it = 1.0 * exp(iTime * -0.01);\n    for(int i = 0; i < 8; i++)\n    {\n    \tp = vec2(p.x * p.x - p.y * p.y, 2.0 * p.x * p.y) + c;\n        //p += nse(p * 20.0) * 0.02;\n        v += exp(abs(dot(p, p) - iTime * 0.03) * -fo) * it;\n        it *= 0.7;\n        fo *= 0.8;\n    }\n    \n    float v2 = /*v * 0.8 +*/ sf + abs(fbm(uv * 2.1 + fbm2(uv * 10.0) * 0.6) - 0.5);\n    \n    //v *= 2.0;\n    \n    vec3 col;\n    \n    //col = pow(vec3(clamp(v2 - v * 0.5, 0.0, 1.0) + length(uv) * 0.15), vec3(1.0, 0.8, 0.5) * 4.5) * 3.0;\n    //col += pow(vec3(v * 1.0), vec3(0.5, 0.5, 0.7) * 6.5) * 4.0;\n    \n    float lit = pow(nse(iTime * 10.0), 3.0) * nse(uv * 4.0 - iTime) * (0.5 + v2 * 1.0) * exp(iTime * -0.04) + 0.5;\n    \n    vec3 cp = mix(vec3(1.0, 0.8, 0.5), vec3(0.3, 0.6, 0.7), smoothstep(0.0, 1.0, v2 + v));\n    col = pow(vec3(v2 + v * 0.4) + exp(length(uv) * -2.0) * lit, cp * 7.0) * 4.0;\n    \n    \n    //1.0 - fbm(uv * 2.0) * 0.5\n    \n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 37, 37, 231], [233, 233, 254, 254, 309], [311, 311, 331, 331, 394], [396, 396, 416, 416, 539], [541, 541, 560, 560, 802], [804, 804, 823, 823, 935], [937, 937, 957, 957, 1072], [1074, 1074, 1131, 1131, 2609]], "test": "untested"}
{"id": "XtsGRH", "name": "carcarSpacecar morph", "author": "eiffie", "description": "I was told I would have a flying car by now. :(", "tags": ["morph", "car", "spacecar"], "likes": 11, "viewed": 596, "published": "Public", "date": "1418577101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// carcarspacecar by eiffie\n// This is the morph from the shiney toy car to the space car in kali's shader.\n// It is part of a larger animation that wouldn't compile :(\n\n//from iq, this version removes the mix\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\n\nmat2 trmx,mrmx;//the wheel spinners\nfloat minL,cc3,cc4;//car config\nvec4 trpc,cc;//color and stuff\nbool bColoring=false;\n\nfloat DE(in vec3 p0){//carcarspacecar by eiffie\n\tvec3 p=p0;\n\tp.y+=1.24;\n\tfloat d=length(max(vec3(abs(p.x)-0.35,length(p.yz)-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz);\n\tfloat w1=0.24,w2=cc.z,dL=length(p+vec3(-0.3,0.0,-1.18-p0.z*0.17))-0.05;\n\tp.xz-=vec2(cc.w,1.0);\n\tif(p0.z<0.0){\n\t\tw1=cc.x;w2=cc.y;\n\t\tp.xy=mrmx*p.xy;\n\t}else p.xz=mrmx*p.xz;\n\tp.x=abs(p.x);\n\tfloat r=length(p.yz);\n\td=smin(d,length(vec2(max(max(p.x-w2,0.0),-p.y-0.08),r-w1))-0.02,0.25);\n\tfloat d1=length(vec2(max(p.x-w2-0.01,0.0),r-w1+0.05))-0.04;\n\tif(p0.z<0.0)p.yz=p.yz*trmx;\n\telse p.yz=trmx*p.yz;\n\tfloat d2=min(min(abs(p.z+p.y),abs(p.z-p.y)),min(abs(p.z),abs(p.y)));//8 blades\n\td2=max(r-w1+cc3,max(d2-0.003,p.x-w2+0.04));\n\td2=min(d2,dL);\n\tminL=min(minL,d2);//catch the minimum distance to the glowing things\n\tif(bColoring){\n\t\tif(d2<d && d2<d1){trpc+=vec4(1.0,0.6,0.5,256.0);}//spokes/turbines\n\t\telse if(d1<d){trpc+=vec4(vec3(clamp(1.0-(r-w1+0.09)*100.0,0.0,1.0)),256.0);}\n\t\telse {//the car's body\n\t\t\tif(p0.z<-1.04 || (abs(p0.y-0.58)>0.05-p0.z*0.09 || p0.z>0.25) && length(max(abs(p0.xz+vec2(0.0,-0.27))-vec2(0.18,0.39),0.0))>0.1)trpc+=vec4(1.0,0.9,0.4,16.0);\n\t\t\telse trpc+=vec4(0.1,0.2,0.3,2.0);//the windshield\n\t\t}\n\t}\n\treturn min(d,min(d1,d2)); \n}\nvoid setConfig(){\n\tfloat t=mod(iTime,10.0);\n\tt=t-5.0;\n\tif(t>4.0)t=5.0-t;\n\tt=clamp(t,0.0,1.0);\n\tcc3=mix(0.06,-0.03,t);\n\tcc4=mix(0.0,-0.5,t);\n\tcc=mix(vec4(0.24,0.07,0.1,0.55),vec4(0.33,0.04,0.22,0.72),t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tsetConfig();\n\tfloat tim=iTime*5.0,a=cc4*3.0;\n\ttrmx=mat2(cos(tim),sin(tim),-sin(tim),cos(tim));//the turbine spinner\n\tmrmx=mat2(cos(a),sin(a),-sin(a),cos(a));\n\ttim=iTime*0.5;\n\tvec3 ro=vec3(cos(tim),0.1+sin(tim*0.7),sin(tim))*(2.5-abs(sin(tim*0.7)));\n\tvec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y,1.0));\n\tvec3 col=vec3(0.4,0.5,0.6)+rd*0.1,L=normalize(vec3(0.5,0.5,-0.5));\n\tfloat t=0.0,d=1.0;\n\tminL=100.0;\n\tfor(int i=0;i<32;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t}\n\tif(d<0.1){\n\t\tvec3 p=ro+rd*t;\n\t\tvec2 v=vec2(2.0/iResolution.y,0.0);\n\t\ttrpc=vec4(0.0);bColoring=true;\n\t\tvec3 N=normalize(vec3(-DE(p-v.xyy)+DE(p+v.xyy),-DE(p-v.yxy)+DE(p+v.yxy),-DE(p-v.yyx)+DE(p+v.yyx)));\n\t\tcol=trpc.rgb*0.1666*max(0.2,0.25+0.75*dot(N,L));\n\t\tcol*=mix(vec3(0.5,0.5,1.0),vec3(1.0,1.0,0.5),abs(dot(rd,N)));\n\t\tcol+=vec3(1.0,0.5,0.0)*pow(max(0.0,dot(reflect(rd,N),L)),trpc.a);\n\t}\n\tcol+=vec3(1.0,0.5,0.2)/(1.0+minL*minL*10000.0);//the glow\n\tfragColor = vec4(clamp(col,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 210, 246, 246, 309], [326, 433, 454, 480, 1692], [1693, 1693, 1710, 1710, 1897], [1898, 1898, 1927, 1927, 2023], [2024, 2024, 2081, 2081, 3081]], "test": "untested"}
{"id": "XtXGR8", "name": "Heart Beat 3D", "author": "miloyip", "description": "Beating of a 3D heart", "tags": ["heart", "implicitfunction"], "likes": 27, "viewed": 3347, "published": "Public", "date": "1418232265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://mathworld.wolfram.com/HeartSurface.html\n\nfloat f(vec3 p) {\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\n// Bisection solver for y\nfloat h(float x, float z) {\n    float a = 0.0, b = 0.75, y = 0.5;\n    for (int i = 0; i < 10; i++) {\n        if (f(vec3(x, y, z)) <= 0.0)\n            a = y;\n        else\n            b = y;\n        y = (a + b) * 0.5;\n    }\n    return y;\n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2) \n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, h(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n   \ta *= a;\n    \n  \treturn normalize(vec3(\n        -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n      -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n      v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0);\n    \n    float s = sin(iTime * 5.0);\n    s *= s;\n    s *= s;\n    s *= 0.1;\n    vec3 tp = p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;\n    \n    vec3 c;\n    if (f(tp.xzy) <= 0.0) {\n        vec3 n = normal(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 64.0);\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        c = diffuse * vec3(1.0, 0, 0) + specular * vec3(0.8) + rim * vec3(0.5);\n    }\n\telse\n        c = vec3(1.0, 0.8, 0.7 - 0.07 * p.y) * (1.0 - 0.15 * length(p));\n    \n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 68, 68, 216], [218, 244, 271, 271, 481], [483, 658, 679, 679, 1015], [1017, 1017, 1074, 1074, 1777]], "test": "untested"}
